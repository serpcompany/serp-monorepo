[
  {
    "owner": "akkadotnet",
    "repo": "akka.net",
    "content": "TITLE: Defining the ActorBase Abstract Class in Akka.NET\nDESCRIPTION: The `ActorBase` class is an abstract base class for actors in Akka.NET. It provides fundamental methods and properties that all actors inherit, such as `Context`, `Self`, `Sender`, and lifecycle hooks like `PreStart`, `PostStop`, `PreRestart`, and `PostRestart`. The `Receive` method is an abstract method that must be implemented by concrete actor classes to define how they handle incoming messages. It also includes methods for behavior modification (`Become`, `UnbecomeStacked`) and handling unhandled messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace Akka.Actor\n{\n    public abstract class ActorBase : Akka.Actor.IInternalActor\n    {\n        protected ActorBase() { }\n        protected static Akka.Actor.IActorContext Context { get; }\n        protected static Akka.Actor.Receive EmptyReceive { get; }\n        protected Akka.Actor.IActorRef Self { get; }\n        protected Akka.Actor.IActorRef Sender { get; }\n        public virtual void AroundPostRestart(System.Exception cause, object message) { }\n        public virtual void AroundPostStop() { }\n        public virtual void AroundPreRestart(System.Exception cause, object message) { }\n        public virtual void AroundPreStart() { }\n        protected virtual bool AroundReceive(Akka.Actor.Receive receive, object message) { }\n        protected void Become(Akka.Actor.Receive receive) { }\n        protected void BecomeStacked(Akka.Actor.Receive receive) { }\n        protected virtual void PostRestart(System.Exception reason) { }\n        protected virtual void PostStop() { }\n        protected virtual void PreRestart(System.Exception reason, object message) { }\n        protected virtual void PreStart() { }\n        protected abstract bool Receive(object message);\n        protected void SetReceiveTimeout(System.Nullable<System.TimeSpan> timeout) { }\n        protected virtual Akka.Actor.SupervisorStrategy SupervisorStrategy() { }\n        protected void UnbecomeStacked() { }\n        protected virtual void Unhandled(object message) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: One-For-One Supervision Strategy Implementation in C#\nDESCRIPTION: Implementation of supervision strategy where each child actor is treated independently. Allows configuration of retry attempts and time windows for handling actor failures.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\npublic class OneForOneStrategy : Akka.Actor.SupervisorStrategy, System.IEquatable<Akka.Actor.OneForOneStrategy>\n{\n    public OneForOneStrategy(System.Nullable<int> maxNrOfRetries, System.Nullable<System.TimeSpan> withinTimeRange, System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider) { }\n    public OneForOneStrategy(System.Nullable<int> maxNrOfRetries, System.Nullable<System.TimeSpan> withinTimeRange, Akka.Actor.IDecider decider) { }\n    public OneForOneStrategy(int maxNrOfRetries, int withinTimeMilliseconds, System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider, bool loggingEnabled = True) { }\n    public OneForOneStrategy(int maxNrOfRetries, int withinTimeMilliseconds, Akka.Actor.IDecider decider, bool loggingEnabled = True) { }\n    public OneForOneStrategy(System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider) { }\n    public OneForOneStrategy(System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider, bool loggingEnabled = True) { }\n    public OneForOneStrategy(Akka.Actor.IDecider decider) { }\n    protected OneForOneStrategy() { }\n    public override Akka.Actor.IDecider Decider { get; }\n    public int MaxNumberOfRetries { get; }\n    public int WithinTimeRangeMilliseconds { get; }\n    public bool Equals(Akka.Actor.OneForOneStrategy other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    protected override Akka.Actor.Directive Handle(Akka.Actor.IActorRef child, System.Exception exception) { }\n    public override void HandleChildTerminated(Akka.Actor.IActorContext actorContext, Akka.Actor.IActorRef child, System.Collections.Generic.IEnumerable<Akka.Actor.IInternalActorRef> children) { }\n    public override void ProcessFailure(Akka.Actor.IActorContext context, bool restart, Akka.Actor.IActorRef child, System.Exception cause, Akka.Actor.Internal.ChildRestartStats stats, System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> children) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Actor.OneForOneStrategy WithMaxNrOfRetries(int maxNrOfRetries) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ActorCell Class in Akka.NET\nDESCRIPTION: The ActorCell class serves as the runtime container for actor instances, implementing IActorContext and other interfaces. It manages actor lifecycle, message dispatching, and child actor supervision. This class handles the actual message processing and actor state management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n    [System.Diagnostics.DebuggerDisplayAttribute(\"{Self,nq}\")]\n    public class ActorCell : Akka.Actor.IActorContext, Akka.Actor.IActorRefFactory, Akka.Actor.ICanWatch, Akka.Actor.ICell, Akka.Actor.IUntypedActorContext\n    {\n        public const int UndefinedUid = 0;\n        public ActorCell(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.IInternalActorRef self, Akka.Actor.Props props, Akka.Dispatch.MessageDispatcher dispatcher, Akka.Actor.IInternalActorRef parent) { }\n        public Akka.Actor.Internal.IChildrenContainer ChildrenContainer { get; }\n        public int CurrentEnvelopeId { get; }\n        public object CurrentMessage { get; }\n        public Akka.Dispatch.MessageDispatcher Dispatcher { get; }\n        public bool HasMessages { get; }\n        public bool IsLocal { get; }\n        protected bool IsNormal { get; }\n        public bool IsTerminated { get; }\n        protected bool IsTerminating { get; }\n        public Akka.Dispatch.Mailbox Mailbox { get; }\n        public int NumberOfMessages { get; }\n        public Akka.Actor.IInternalActorRef Parent { get; }\n        public Akka.Actor.Props Props { get; }\n        public System.Nullable<System.TimeSpan> ReceiveTimeout { get; }\n        public Akka.Actor.IActorRef Self { get; }\n        public Akka.Actor.IActorRef Sender { get; }\n        public Akka.Actor.ActorSystem System { get; }\n        public Akka.Actor.Internal.ActorSystemImpl SystemImpl { get; }\n        public virtual Akka.Dispatch.ActorTaskScheduler TaskScheduler { get; }\n        public virtual Akka.Actor.IActorRef ActorOf(Akka.Actor.Props props, string name = null) { }\n        public Akka.Actor.ActorSelection ActorSelection(string path) { }\n        public Akka.Actor.ActorSelection ActorSelection(Akka.Actor.ActorPath path) { }\n        protected void AddWatcher(Akka.Actor.IActorRef watchee, Akka.Actor.IActorRef watcher) { }\n        protected void AddressTerminated(Akka.Actor.Address address) { }\n        public virtual Akka.Actor.IActorRef AttachChild(Akka.Actor.Props props, bool isSystemService, string name = null) { }\n        protected virtual void AutoReceiveMessage(Akka.Actor.Envelope envelope) { }\n        public void Become(Akka.Actor.Receive receive) { }\n        public void BecomeStacked(Akka.Actor.Receive receive) { }\n        public void CheckReceiveTimeout(bool reschedule = True) { }\n        protected void ClearActor(Akka.Actor.ActorBase actor) { }\n        protected void ClearActorCell() { }\n        protected virtual Akka.Actor.ActorBase CreateNewActorInstance() { }\n        [System.ObsoleteAttribute(\"Use TryGetChildStatsByName [0.7.1]\", true)]\n        public Akka.Actor.IInternalActorRef GetChildByName(string name) { }\n        public System.Collections.Generic.IEnumerable<Akka.Actor.IInternalActorRef> GetChildren() { }\n        public static Akka.Actor.IActorRef GetCurrentSelfOrNoSender() { }\n        public static Akka.Actor.IActorRef GetCurrentSenderOrNoSender() { }\n        public Akka.Actor.IInternalActorRef GetSingleChild(string name) { }\n        public void Init(bool sendSupervise, Akka.Dispatch.MailboxType mailboxType) { }\n        public Akka.Actor.Internal.ChildRestartStats InitChild(Akka.Actor.IInternalActorRef actor) { }\n        public void Invoke(Akka.Actor.Envelope envelope) { }\n        protected virtual void PreStart() { }\n        protected void PrepareForNewActor() { }\n        protected virtual void ReceiveMessage(object message) { }\n        public void ReceiveMessageForTest(Akka.Actor.Envelope envelope) { }\n        protected void ReceivedTerminated(Akka.Actor.Terminated t) { }\n        protected void RemWatcher(Akka.Actor.IActorRef watchee, Akka.Actor.IActorRef watcher) { }\n        protected Akka.Actor.Internal.SuspendReason RemoveChildAndGetStateChange(Akka.Actor.IActorRef child) { }\n        public void ReserveChild(string name) { }\n        public void Restart(System.Exception cause) { }\n        public void Resume(System.Exception causedByFailure) { }\n        public virtual void SendMessage(Akka.Actor.Envelope message) { }\n        public virtual void SendMessage(Akka.Actor.IActorRef sender, object message) { }\n        public virtual void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage systemMessage) { }\n        protected void SetActorFields(Akka.Actor.ActorBase actor) { }\n        protected bool SetChildrenTerminationReason(Akka.Actor.Internal.SuspendReason reason) { }\n        public void SetReceiveTimeout(System.Nullable<System.TimeSpan> timeout = null) { }\n        protected void SetTerminated() { }\n        public virtual void Start() { }\n        protected void Stash(Akka.Dispatch.SysMsg.SystemMessage msg) { }\n        public void Stop(Akka.Actor.IActorRef child) { }\n        public void Stop() { }\n        protected void StopFunctionRefs() { }\n        public void Suspend() { }\n        protected void TellWatchersWeDied() { }\n        public void TerminatedQueuedFor(Akka.Actor.IActorRef subject, Akka.Util.Option<object> customMessage) { }\n        public bool TryGetChildStatsByName(string name, out Akka.Actor.Internal.IChildStats child) { }\n        protected bool TryGetChildStatsByRef(Akka.Actor.IActorRef actor, out Akka.Actor.Internal.ChildRestartStats child) { }\n        public void UnbecomeStacked() { }\n        protected void UnreserveChild(string name) { }\n        public Akka.Actor.IActorRef Unwatch(Akka.Actor.IActorRef subject) { }\n        protected void UnwatchWatchedActors(Akka.Actor.ActorBase actor) { }\n        public void UseThreadContext(System.Action action) { }\n        public Akka.Actor.IActorRef Watch(Akka.Actor.IActorRef subject) { }\n        public Akka.Actor.IActorRef WatchWith(Akka.Actor.IActorRef subject, object message) { }\n        protected void WatchedActorTerminated(Akka.Actor.IActorRef actor, bool existenceConfirmed, bool addressTerminated) { }\n    }\n    public sealed class ActorIdentity\n    {\n```\n\n----------------------------------------\n\nTITLE: Defining the Cluster class in Akka.Cluster\nDESCRIPTION: This snippet defines the `Cluster` class, which is an Akka.NET extension used for managing cluster membership, failure detection, and other cluster-related operations. It offers methods for joining, leaving, and downing nodes, subscribing to cluster events, and retrieving cluster state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Core.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n public class Cluster : Akka.Actor.IExtension\n    {\n        public Cluster(Akka.Actor.Internal.ActorSystemImpl system) { }\n        public Akka.Cluster.IDowningProvider DowningProvider { get; }\n        public Akka.Remote.DefaultFailureDetectorRegistry<Akka.Actor.Address> FailureDetector { get; }\n        public bool IsTerminated { get; }\n        public bool IsUp { get; }\n        public Akka.Actor.Address SelfAddress { get; }\n        public Akka.Cluster.Member SelfMember { get; }\n        public System.Collections.Immutable.ImmutableHashSet<string> SelfRoles { get; }\n        public Akka.Cluster.UniqueAddress SelfUniqueAddress { get; }\n        public Akka.Cluster.ClusterSettings Settings { get; }\n        public Akka.Cluster.ClusterEvent.CurrentClusterState State { get; }\n        public Akka.Actor.ExtendedActorSystem System { get; }\n        public void Down(Akka.Actor.Address address) { }\n        public static Akka.Cluster.Cluster Get(Akka.Actor.ActorSystem system) { }\n        public void Join(Akka.Actor.Address address) { }\n        public System.Threading.Tasks.Task JoinAsync(Akka.Actor.Address address, System.Threading.CancellationToken token = null) { }\n        public void JoinSeedNodes(System.Collections.Generic.IEnumerable<Akka.Actor.Address> seedNodes) { }\n        public System.Threading.Tasks.Task JoinSeedNodesAsync(System.Collections.Generic.IEnumerable<Akka.Actor.Address> seedNodes, System.Threading.CancellationToken token = null) { }\n        public void Leave(Akka.Actor.Address address) { }\n        public System.Threading.Tasks.Task LeaveAsync() { }\n        public System.Threading.Tasks.Task LeaveAsync(System.Threading.CancellationToken cancellationToken) { }\n        public void RegisterOnMemberRemoved(System.Action callback) { }\n        public void RegisterOnMemberUp(System.Action callback) { }\n        public Akka.Actor.ActorPath RemotePathOf(Akka.Actor.IActorRef actorRef) { }\n        public void SendCurrentClusterState(Akka.Actor.IActorRef receiver) { }\n        public void Subscribe(Akka.Actor.IActorRef subscriber, params System.Type[] to) { }\n        public void Subscribe(Akka.Actor.IActorRef subscriber, Akka.Cluster.ClusterEvent.SubscriptionInitialStateMode initialStateMode, params System.Type[] to) { }\n        public void Unsubscribe(Akka.Actor.IActorRef subscriber) { }\n        public void Unsubscribe(Akka.Actor.IActorRef subscriber, System.Type to) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing PreStart Hook in Akka.NET Actor\nDESCRIPTION: Shows implementation of the PreStart lifecycle hook which is called when an actor is first created or during restarts depending on PostRestart implementation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override void PreStart()\n{\n    child = Context.ActorOf(Props.Empty);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Wildcard Patterns in ActorSelection in Akka.NET C#\nDESCRIPTION: Shows how to use wildcard patterns in ActorSelection to broadcast messages to multiple actors matching a pattern.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n// will look all children to serviceB with names starting with worker\nContext.ActorSelection(\"/user/serviceB/worker*\");\n\n// will look up all siblings beneath same supervisor\nContext.ActorSelection(\"../*\");\n```\n\n----------------------------------------\n\nTITLE: Installing Akka.NET Project Templates via .NET CLI\nDESCRIPTION: This command installs the Akka.Templates package using the .NET CLI, which makes various Akka.NET project templates available both in the CLI and in IDEs like Visual Studio and JetBrains Rider.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/README.md#2025-04-16_snippet_2\n\nLANGUAGE: powershell\nCODE:\n```\ndotnet new install \"Akka.Templates::*\"\n```\n\n----------------------------------------\n\nTITLE: Implementing ReceiveActor Class in Akka.NET\nDESCRIPTION: Defines the ReceiveActor class, which provides a declarative way to define message handlers for actors. It includes methods for specifying typed and untyped message handlers, as well as asynchronous handlers.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ReceiveActor : Akka.Actor.UntypedActor, Akka.Actor.Internal.IInitializableActor\n{\n    protected ReceiveActor() { }\n    protected void Become(System.Action configure) { }\n    protected void BecomeStacked(System.Action configure) { }\n    protected virtual void OnReceive(object message) { }\n    protected void Receive<T>(System.Action<T> handler, System.Predicate<T> shouldHandle = null) { }\n    protected void Receive<T>(System.Predicate<T> shouldHandle, System.Action<T> handler) { }\n    // ... (additional methods)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Actor Supervision in C#\nDESCRIPTION: Demonstrates supervision behavior when an actor fails by throwing an exception. Shows how parent actors handle child actor failures and the default restart strategy.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-1.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../../src/core/Akka.Docs.Tutorials/Tutorial1/ActorHierarchyExperiments.cs?name=supervise)]\n```\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../../src/core/Akka.Docs.Tutorials/Tutorial1/ActorHierarchyExperiments.cs?name=supervise2)]\n```\n\n----------------------------------------\n\nTITLE: Combining Custom Strategy with Default Strategy in C#\nDESCRIPTION: This code shows how to combine a custom supervisor strategy with the default strategy. It handles ArithmeticException specifically and delegates other exceptions to the default strategy.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/fault-tolerance.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override SupervisorStrategy SupervisorStrategy()\n{\n    return new OneForOneStrategy(\n        maxNrOfRetries: 10,\n        withinTimeRange: TimeSpan.FromMinutes(1),\n        localOnlyDecider: ex =>\n        {\n            if (ex is ArithmeticException)\n            {\n                return Directive.Resume;\n            }\n\n            return Akka.Actor.SupervisorStrategy.DefaultStrategy.Decider.Decide(ex);\n        });\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Device Actor with Read and Write Protocols in C#\nDESCRIPTION: Full implementation of a Device actor in Akka.NET, handling both temperature queries and temperature recording. Includes message handling for ReadTemperature, RecordTemperature, and corresponding response messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-2.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class Device : UntypedActor\n{\n    private double? _temperature;\n\n    protected override void OnReceive(object message)\n    {\n        switch (message)\n        {\n            case RecordTemperature recordTemperature:\n                _temperature = recordTemperature.Value;\n                Sender.Tell(new TemperatureRecorded(recordTemperature.Id));\n                break;\n            case ReadTemperature readTemperature:\n                Sender.Tell(new RespondTemperature(readTemperature.RequestId, _temperature));\n                break;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Device Registration in Device Group Actor (C#)\nDESCRIPTION: This snippet shows the implementation of device registration in the Device Group actor. It handles registration requests by either forwarding them to existing child actors or creating new ones. The code uses a Dictionary to keep track of device IDs and their corresponding actor references.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-3.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override void OnReceive(object message)\n{\n    switch (message)\n    {\n        case RequestTrackDevice trackMsg when trackMsg.GroupId.Equals(GroupId):\n            if (_deviceIdToActor.TryGetValue(trackMsg.DeviceId, out var actorRef))\n            {\n                actorRef.Forward(trackMsg);\n            }\n            else\n            {\n                var deviceActor = Context.ActorOf(Props.Create(() =>\n                    new Device(GroupId, trackMsg.DeviceId)), $\"device-{trackMsg.DeviceId}\");\n                _deviceIdToActor.Add(trackMsg.DeviceId, deviceActor);\n                deviceActor.Forward(trackMsg);\n            }\n            break;\n        case RequestTrackDevice trackMsg:\n            Log.Warning($\"Ignoring TrackDevice request for {trackMsg.GroupId}. This actor is responsible for {GroupId}.\");\n            break;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Dependency Injection in Startup Class\nDESCRIPTION: This code snippet demonstrates how to set up dependency injection in a typical .NET application's Startup class using Microsoft.Extensions.DependencyInjection.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/dependency-injection.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Startup](../../../src/examples/AspNetCore/Samples.Akka.AspNetCore/Startup.cs?name=DiSetup)]\n```\n\n----------------------------------------\n\nTITLE: Setting Actor Mailbox in Props using C#\nDESCRIPTION: Example showing how to specify a custom mailbox when creating an actor using the Props factory. This approach allows setting the mailbox at the code level when instantiating actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/mailboxes.md#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nProps.Create<ActorType>().WithMailbox(\"my-custom-mailbox\");\n```\n\n----------------------------------------\n\nTITLE: Stopping Actors in Akka.NET\nDESCRIPTION: This snippet illustrates how to stop actors using `Context.Stop`. It demonstrates stopping a child actor and stopping the actor itself. Stopping an actor is an asynchronous operation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_24\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyStoppingActor : ReceiveActor\n{\n    private IActorRef child;\n\n    public MyStoppingActor()\n    {\n        Receive<string>(s => s.Equals(\"interrupt-child\"), msg =>\n        {\n            Context.Stop(child);\n        });\n\n        Receive<string>(s => s.Equals(\"done\"), msg =>\n        {\n            Context.Stop(Self);\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Obtaining and Querying a Read Journal in Akka.NET\nDESCRIPTION: This snippet demonstrates how to obtain a read journal instance and issue a query to retrieve events by persistence ID. It shows the setup of an actor system, obtaining the read journal, and materializing a stream of events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistence-query.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar actorSystem = ActorSystem.Create(\"query\");\n\n// obtain read journal by plugin id\nvar readJournal = PersistenceQuery.Get(actorSystem)\n    .ReadJournalFor<SqlReadJournal>(\"akka.persistence.query.my-read-journal\");\n\n// issue query to journal\nSource<EventEnvelope, NotUsed> source = readJournal\n    .EventsByPersistenceId(\"user-1337\", 0, long.MaxValue);\n\n// materialize stream, consuming events\nvar mat = ActorMaterializer.Create(actorSystem);\nsource.RunForeach(envelope =>\n{\n    Console.WriteLine($\"event {envelope}\");\n}, mat);\n```\n\n----------------------------------------\n\nTITLE: Deploying Worker Actors with RoundRobinPool Router in C#\nDESCRIPTION: Demonstrates how to create and deploy 5 worker actors using a round robin router in code. The router will create and manage the worker instances, distributing messages in round-robin order.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar props = Props.Create<Worker>().WithRouter(new RoundRobinPool(5));\nvar actor = system.ActorOf(props, \"worker\");\n```\n\n----------------------------------------\n\nTITLE: Message Forwarding in Akka.NET\nDESCRIPTION: Shows how to forward messages between actors while maintaining the original sender reference.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\ntarget.Forward(result);\n```\n\n----------------------------------------\n\nTITLE: Implementing Immutable Messages in C#\nDESCRIPTION: Example of creating an immutable message class with read-only properties and collections for use in Akka.NET actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ImmutableMessage\n{\n    public ImmutableMessage(int sequenceNumber, List<string> values)\n    {\n        SequenceNumber = sequenceNumber;\n        Values = values.AsReadOnly();\n    }\n\n    public int SequenceNumber { get; }\n    public IReadOnlyCollection<string> Values { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AllForOneStrategy Supervisor in C#\nDESCRIPTION: Implementation of the AllForOneStrategy supervisor strategy class that handles child actor failure scenarios. Includes configuration for retry policies and failure handling directives.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic class AllForOneStrategy : Akka.Actor.SupervisorStrategy, System.IEquatable<Akka.Actor.AllForOneStrategy>\n{\n    public AllForOneStrategy(System.Nullable<int> maxNrOfRetries, System.Nullable<System.TimeSpan> withinTimeRange, System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider) { }\n    public AllForOneStrategy(System.Nullable<int> maxNrOfRetries, System.Nullable<System.TimeSpan> withinTimeRange, Akka.Actor.IDecider decider) { }\n    public AllForOneStrategy(int maxNrOfRetries, int withinTimeMilliseconds, System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider, bool loggingEnabled = True) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing At-Least-Once Delivery in a Persistent Actor using C#\nDESCRIPTION: This code demonstrates how to implement at-least-once delivery in a persistent actor. It shows how to use the Deliver method to send messages, handle confirmations, and manage the delivery state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/at-least-once-delivery.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ExampleAtLeastOnceDeliveryActor : AtLeastOnceDeliveryReceiveActor\n{\n    public class RegisterConfirm { }\n    public class RegisterRequest { }\n\n    private readonly IActorRef _destination;\n    public int N { get; private set; }\n\n    public const string PersistenceId = \"AtLeastOnceDeliveryExampleActor\";\n\n    public ExampleAtLeastOnceDeliveryActor(IActorRef destination)\n        : base(PersistenceId)\n    {\n        _destination = destination;\n\n        Recover<RegisterRequest>(request => N++);\n        Recover<RegisterConfirm>(confirm =>\n        {\n            ConfirmDelivery(confirm.DeliveryId);\n        });\n\n        Command<string>(str =>\n        {\n            Persist(new RegisterRequest(), request =>\n            {\n                N++;\n                SaveSnapshot(N);\n                Deliver(_destination.Path, deliveryId => new Msg(str, deliveryId));\n            });\n        });\n\n        Command<Confirmation>(confirm =>\n        {\n            Persist(new RegisterConfirm { DeliveryId = confirm.DeliveryId },\n                registerConfirm => ConfirmDelivery(confirm.DeliveryId));\n        });\n\n        Command<string>(str =>\n        {\n            Persist(new RegisterRequest(), request =>\n            {\n                N++;\n                SaveSnapshot(N);\n                Deliver(_destination.Path, deliveryId => new Msg(str, deliveryId));\n            });\n        });\n    }\n\n    protected override bool ReceiveSnapshot(object snapshot)\n    {\n        switch (snapshot)\n        {\n            case int n:\n                N = n;\n                return true;\n            default:\n                return false;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Materializing SinkRef in C#\nDESCRIPTION: This snippet demonstrates how to materialize a received SinkRef on the remote side. It shows running a Source into the SinkRef and handling the completion.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/streamrefs.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nISinkRef<int> sinkRef = // received from the origin actor\n\nsinkRef.Sink.RunWith(Source.From(new[] { 1, 2, 3 }), Materializer)\n    .ContinueWith(task =>\n    {\n        if (task.IsFaulted)\n            Console.WriteLine($\"[Producer] Stream failed: {task.Exception.Message}\");\n        else\n            Console.WriteLine(\"[Producer] Stream completed successfully\");\n    });\n```\n\n----------------------------------------\n\nTITLE: Open Valve in Akka.NET Stream\nDESCRIPTION: This code demonstrates using a valve to control the flow of elements in a stream. It materializes to a task with an `IValveSwitch` interface allowing pause and resume operations on the stream. Dependencies include the Akka.Streams library, and it operates by buffering potentially one element when the valve is closed, which may be dropped if the stream completes or fails while closed.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/builtinstages.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Valve](../../../src/core/Akka.Streams.Tests/Dsl/ValveSpec.cs?name=OpenValve)]\n```\n\n----------------------------------------\n\nTITLE: Implementing a Supervisor Actor with Custom Strategy in C#\nDESCRIPTION: This snippet shows a complete Supervisor actor implementation with a custom strategy. It includes the supervisor strategy and message handling for creating child actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/fault-tolerance.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Supervisor : UntypedActor\n{\n    protected override SupervisorStrategy SupervisorStrategy()\n    {\n        return new OneForOneStrategy(\n            maxNrOfRetries: 10,\n            withinTimeRange: TimeSpan.FromMinutes(1),\n            localOnlyDecider: ex =>\n            {\n                switch (ex)\n                {\n                    case ArithmeticException ae:\n                        return Directive.Resume;\n                    case NullReferenceException nre:\n                        return Directive.Restart;\n                    case ArgumentException are:\n                        return Directive.Stop;\n                    default:\n                        return Directive.Escalate;\n                }\n            });\n    }\n\n    protected override void OnReceive(object message)\n    {\n        if (message is Props p)\n        {\n            var child = Context.ActorOf(p); // create child\n            Sender.Tell(child); // send back reference to child actor\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Config Class in C#\nDESCRIPTION: A class for managing HOCON configuration in Akka.NET. Provides methods for accessing typed configuration values and managing configuration hierarchies with fallbacks.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_69\n\nLANGUAGE: C#\nCODE:\n```\npublic class Config\n{\n    public static readonly Akka.Configuration.Config Empty;\n    public Config() { }\n    public Config(Akka.Configuration.Hocon.HoconRoot root) { }\n    public Config(Akka.Configuration.Config source, Akka.Configuration.Config fallback) { }\n    public Akka.Configuration.Config Fallback { get; }\n    public virtual bool IsEmpty { get; }\n    public Akka.Configuration.Hocon.HoconValue Root { get; }\n    public System.Collections.Generic.IEnumerable<Akka.Configuration.Hocon.HoconSubstitution> Substitutions { get; set; }\n    public virtual System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Akka.Configuration.Hocon.HoconValue>> AsEnumerable() { }\n    protected Akka.Configuration.Config Copy(Akka.Configuration.Config fallback = null) { }\n    public virtual bool GetBoolean(string path, bool default = False) { }\n    public virtual System.Collections.Generic.IList<bool> GetBooleanList(string path) { }\n    public virtual System.Collections.Generic.IList<byte> GetByteList(string path) { }\n    public virtual System.Nullable<long> GetByteSize(string path) { }\n    public virtual System.Nullable<long> GetByteSize(string path, System.Nullable<long> def = null) { }\n    public virtual Akka.Configuration.Config GetConfig(string path) { }\n    public virtual decimal GetDecimal(string path, [System.Runtime.CompilerServices.DecimalConstantAttribute(0, 0, 0u, 0u, 0u)] decimal @default) { }\n    public virtual System.Collections.Generic.IList<decimal> GetDecimalList(string path) { }\n    public virtual double GetDouble(string path, double default = 0) { }\n    public virtual System.Collections.Generic.IList<double> GetDoubleList(string path) { }\n    public virtual float GetFloat(string path, float default = 0) { }\n    public virtual System.Collections.Generic.IList<float> GetFloatList(string path) { }\n    public virtual int GetInt(string path, int default = 0) { }\n    public virtual System.Collections.Generic.IList<int> GetIntList(string path) { }\n    public virtual long GetLong(string path, long default = 0) { }\n    public virtual System.Collections.Generic.IList<long> GetLongList(string path) { }\n    public virtual string GetString(string path, string default = null) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Device Actor with Temperature Reading in C#\nDESCRIPTION: Implements the device actor class with temperature measurement storage and query response functionality using the improved read protocol.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-2.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Device : UntypedActor\n{\n    private double? _temperature;\n\n    public Device(string groupId, string deviceId)\n    {\n        GroupId = groupId;\n        DeviceId = deviceId;\n    }\n\n    public string GroupId { get; }\n    public string DeviceId { get; }\n\n    protected override void OnReceive(object message)\n    {\n        switch (message)\n        {\n            case ReadTemperature read:\n                Sender.Tell(new RespondTemperature(read.RequestId, _temperature));\n                break;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Actor References in C#\nDESCRIPTION: Demonstrates how to create top-level and child actors, and print their references to show the actor hierarchy.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-1.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nIActorRef firstRef = system.ActorOf(Props.Create<PrintMyActorRefActor>(), \"first-actor\");\nConsole.WriteLine($\"First : {firstRef}\");\nfirstRef.Tell(\"printit\");\n```\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override void OnReceive(object message)\n{\n    switch (message)\n    {\n        case \"printit\":\n            IActorRef secondRef = Context.ActorOf(Props.Empty, \"second-actor\");\n            Console.WriteLine($\"Second: {secondRef}\");\n            break;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Supervisor Strategy in C#\nDESCRIPTION: This snippet demonstrates how to create a custom OneForOneStrategy for handling different types of exceptions in child actors. It defines specific directives for various exception types and sets limits on the number of restarts.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/fault-tolerance.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override SupervisorStrategy SupervisorStrategy()\n{\n    return new OneForOneStrategy(\n        maxNrOfRetries: 10,\n        withinTimeRange: TimeSpan.FromMinutes(1),\n        localOnlyDecider: ex =>\n        {\n            switch (ex)\n            {\n                case ArithmeticException ae:\n                    return Directive.Resume;\n                case NullReferenceException nre:\n                    return Directive.Restart;\n                case ArgumentException are:\n                    return Directive.Stop;\n                default:\n                    return Directive.Escalate;\n            }\n        });\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Device Manager Messages in C#\nDESCRIPTION: This snippet defines the message protocol for device registration in the device management system. It includes messages for requesting device tracking, acknowledging registration, and handling failure responses.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-3.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class RequestTrackDevice\n{\n    public RequestTrackDevice(string groupId, string deviceId)\n    {\n        GroupId = groupId;\n        DeviceId = deviceId;\n    }\n\n    public string GroupId { get; }\n    public string DeviceId { get; }\n}\n\npublic sealed class DeviceRegistered\n{\n    public static DeviceRegistered Instance { get; } = new DeviceRegistered();\n    private DeviceRegistered() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Manager Actor with Graceful Stop Logic in Akka.NET\nDESCRIPTION: This code defines an actor named `Manager` that handles shutdown messages using `PoisonPill` and context management.  It demonstrates how to change actor behavior during shutdown using `Context.Become` to handle subsequent messages appropriately and stop the actor after the worker has terminated. The actor monitors a worker actor and stops itself after receiving a Terminated message from the worker.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Manager : UntypedActor\n{\n    private IActorRef worker = Context.Watch(Context.ActorOf<Cruncher>(\"worker\"));\n\n    protected override void OnReceive(object message)\n    {\n        switch (message)\n        {\n            case \"job\":\n                worker.Tell(\"crunch\");\n                break;\n            case Shutdown s:\n                worker.Tell(PoisonPill.Instance, Self);\n                Context.Become(ShuttingDown);\n                break;\n        }\n    }\n\n    private void ShuttingDown(object message)\n    {\n        switch (message)\n        {\n            case \"job\":\n                Sender.Tell(\"service unavailable, shutting down\", Self);\n                break;\n            case Terminated t:\n                Context.Stop(Self);\n                break;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic ReceiveActor Implementation in C#\nDESCRIPTION: Demonstrates how to create a basic actor by inheriting from ReceiveActor and handling different message types using the Receive<T> method.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyActor: ReceiveActor\n{\n  private readonly ILoggingAdapter log = Context.GetLogger();\n\n  public MyActor()\n  {\n    Receive<string>(message => {\n      log.Info(\"Received String message: {0}\", message);\n      Sender.Tell(message);\n    });\n    Receive<SomeMessage>(message => {...});\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Producer Registration with Akka.Delivery\nDESCRIPTION: Shows how to register a Producer actor with the ProducerController, including starting the delivery process and setting up message handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/reliable-delivery.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar producerId = \"myProducerId\";\nvar producerController = Context.ActorOf(\n    ProducerController.Create<IDeliveryMessage>(Context.System, producerId));\nproducerController.Tell(new ProducerController.Start<IDeliveryMessage>(producer));\n```\n\n----------------------------------------\n\nTITLE: Implementing Best Practices for Actor Dependency Management\nDESCRIPTION: This code shows a best practice implementation of an actor that manages its dependencies using IServiceProvider and IServiceScope, ensuring proper lifecycle management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/dependency-injection.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[MixedActor](../../../src/contrib/dependencyinjection/Akka.DependencyInjection.Tests/ActorServiceProviderPropsWithScopesSpecs.cs?name=MixedActor)]\n```\n\n----------------------------------------\n\nTITLE: ClusterClient Class Definition in C#\nDESCRIPTION: The ClusterClient class implementation that allows external clients to communicate with actors in an Akka.NET cluster. It includes methods for sending messages to specific paths, publishing to topics, and sending messages to all instances.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterClient : Akka.Actor.ActorBase\n{\n    public ClusterClient(Akka.Cluster.Tools.Client.ClusterClientSettings settings) { }\n    protected override void PostStop() { }\n    public static Akka.Actor.Props Props(Akka.Cluster.Tools.Client.ClusterClientSettings settings) { }\n    protected override bool Receive(object message) { }\n    public sealed class Publish\n    {\n        public Publish(string topic, object message) { }\n        public object Message { get; }\n        public string Topic { get; }\n    }\n    public sealed class Send\n    {\n        public Send(string path, object message, bool localAffinity = False) { }\n        public bool LocalAffinity { get; }\n        public object Message { get; }\n        public string Path { get; }\n    }\n    public sealed class SendToAll\n    {\n        public SendToAll(string path, object message) { }\n        public object Message { get; }\n        public string Path { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Akka.Streams with Observables in C#\nDESCRIPTION: This snippet demonstrates how to create an observable from an Akka stream source using the Sink.AsObservable method and how to read from an observable using Source.FromObservable, including overflow strategies for handling backpressure.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nIObservable<int> observable = Source.From(new []{ 1, 2, 3 })\n    .RunWith(Sink.AsObservable<int>(), materializer);\n\nawait Source.FromObservable(observable, maxBufferCapacity: 128, overflowStrategy: OverflowStrategy.DropHead)\n    .RunForEach(Console.WriteLine, materializer);\n```\n\n----------------------------------------\n\nTITLE: Implementing ActorSubscriber for Worker Pool Management in C#\nDESCRIPTION: This code snippet demonstrates the implementation of an ActorSubscriber for managing a worker pool in Akka.NET Streams. It includes classes for Message, Work, Reply, and Done, as well as the main WorkerPool class that extends ActorSubscriber. The WorkerPool class manages a queue of work items, routes them to worker actors, and controls backpressure using a custom MaxInFlightRequestStrategy.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Message\n{\n    public int Id { get; }\n\n    public IActorRef ReplyTo { get; }\n\n    public Message(int id, IActorRef replyTo)\n    {\n        Id = id;\n        ReplyTo = replyTo;\n    }\n}\n\npublic class Work\n{\n    public Work(int id)\n    {\n        Id = id;\n    }\n\n    public int Id { get; }\n}\n\npublic class Reply\n{\n    public Reply(int id)\n    {\n        Id = id;\n    }\n\n    public int Id { get; }\n}\n\npublic class Done\n{\n    public Done(int id)\n    {\n        Id = id;\n    }\n\n    public int Id { get; }\n}\n\npublic class WorkerPool : Actors.ActorSubscriber\n{\n    public static Props Props { get; } = Props.Create<WorkerPool>();\n        \n    private class Strategy : MaxInFlightRequestStrategy\n    {\n        private readonly Dictionary<int, IActorRef> _queue;\n\n        public Strategy(int max, Dictionary<int, IActorRef> queue) : base(max)\n        {\n            _queue = queue;\n        }\n\n        public override int InFlight => _queue.Count;\n    }\n\n    private const int MaxQueueSize = 10;\n    private readonly Dictionary<int, IActorRef> _queue;\n    private readonly Router _router;\n\n    public WorkerPool()\n    {\n        _queue = new Dictionary<int, IActorRef>();\n        var routees = new Routee[]\n        {\n            new ActorRefRoutee(Context.ActorOf<Worker>()),\n            new ActorRefRoutee(Context.ActorOf<Worker>()),\n            new ActorRefRoutee(Context.ActorOf<Worker>())\n        };\n        _router = new Router(new RoundRobinRoutingLogic(), routees);\n        RequestStrategy = new Strategy(MaxQueueSize, _queue);\n    }\n\n    public override IRequestStrategy RequestStrategy { get; }\n\n    protected override bool Receive(object message)\n    {\n        return message.Match()\n            .With<OnNext>(next =>\n            {\n                var msg = next.Element as Message;\n                if (msg != null)\n                {\n                    _queue.Add(msg.Id, msg.ReplyTo);\n                    if (_queue.Count > MaxQueueSize)\n                        throw new IllegalStateException($\"Queued too many : {_queue.Count}\");\n                    _router.Route(new Work(msg.Id), Self);\n                }\n            })\n            .With<Reply>(reply =>\n            {\n                _queue[reply.Id].Tell(new Done(reply.Id));\n                _queue.Remove(reply.Id);\n            })\n            .WasHandled;\n    }\n}\n\npublic class Worker : ReceiveActor\n{\n    public Worker()\n    {\n        Receive<Work>(work =>\n        {\n            //...\n            Sender.Tell(new Reply(work.Id));\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ActorCell Class in Akka.NET\nDESCRIPTION: Defines the ActorCell class which provides the core implementation of an actor's context and internal state management. It handles actor lifecycle, message processing, child actor creation, and supervision responsibilities within the Akka.NET system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Diagnostics.DebuggerDisplayAttribute(\"{Self,nq}\")]\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic class ActorCell : Akka.Actor.IActorContext, Akka.Actor.IActorRefFactory, Akka.Actor.ICanWatch, Akka.Actor.ICell, Akka.Actor.IUntypedActorContext\n{\n    public const int UndefinedUid = 0;\n    public ActorCell(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.IInternalActorRef self, Akka.Actor.Props props, Akka.Dispatch.MessageDispatcher dispatcher, Akka.Actor.IInternalActorRef parent) { }\n    public Akka.Actor.Internal.IChildrenContainer ChildrenContainer { get; }\n    public int CurrentEnvelopeId { get; }\n    [System.Runtime.CompilerServices.NullableAttribute(2)]\n    public object CurrentMessage { get; }\n    public Akka.Dispatch.MessageDispatcher Dispatcher { get; }\n    public bool HasMessages { get; }\n    public bool IsLocal { get; }\n    protected bool IsNormal { get; }\n    public bool IsTerminated { get; }\n    protected bool IsTerminating { get; }\n    [System.Runtime.CompilerServices.NullableAttribute(2)]\n    public Akka.Dispatch.Mailbox Mailbox { get; }\n    public int NumberOfMessages { get; }\n    public Akka.Actor.IInternalActorRef Parent { get; }\n    public Akka.Actor.Props Props { get; }\n    public System.Nullable<System.TimeSpan> ReceiveTimeout { get; }\n    public Akka.Actor.IActorRef Self { get; }\n    [System.Runtime.CompilerServices.NullableAttribute(2)]\n    public Akka.Actor.IActorRef Sender { get; }\n    public Akka.Actor.ActorSystem System { get; }\n    public Akka.Actor.Internal.ActorSystemImpl SystemImpl { get; }\n    public virtual Akka.Dispatch.ActorTaskScheduler TaskScheduler { get; }\n    public virtual Akka.Actor.IActorRef ActorOf(Akka.Actor.Props props, [System.Runtime.CompilerServices.NullableAttribute(2)] string name = null) { }\n    public Akka.Actor.ActorSelection ActorSelection(string path) { }\n    public Akka.Actor.ActorSelection ActorSelection(Akka.Actor.ActorPath path) { }\n    protected void AddWatcher(Akka.Actor.IActorRef watchee, Akka.Actor.IActorRef watcher) { }\n    protected void AddressTerminated(Akka.Actor.Address address) { }\n    public virtual Akka.Actor.IActorRef AttachChild(Akka.Actor.Props props, bool isSystemService, [System.Runtime.CompilerServices.NullableAttribute(2)] string name = null) { }\n    protected virtual void AutoReceiveMessage(Akka.Actor.Envelope envelope) { }\n    public void Become(Akka.Actor.Receive receive) { }\n    public void BecomeStacked(Akka.Actor.Receive receive) { }\n    public void CheckReceiveTimeout(bool reschedule = True) { }\n    protected void ClearActor(Akka.Actor.ActorBase actor) { }\n    protected void ClearActorCell() { }\n    [return: System.Runtime.CompilerServices.NullableAttribute(2)]\n    protected virtual Akka.Actor.ActorRestarted CreateActorRestartedEvent(System.Exception cause) { }\n    protected virtual Akka.Actor.ActorStarted CreateActorStartedEvent() { }\n    protected virtual Akka.Actor.ActorStopped CreateActorStoppedEvent() { }\n    protected virtual Akka.Actor.ActorBase CreateNewActorInstance() { }\n    [System.ObsoleteAttribute(\"Use TryGetChildStatsByName [0.7.1]\", true)]\n    public Akka.Actor.IInternalActorRef GetChildByName(string name) { }\n    public System.Collections.Generic.IEnumerable<Akka.Actor.IInternalActorRef> GetChildren() { }\n    public static Akka.Actor.IActorRef GetCurrentSelfOrNoSender() { }\n    public static Akka.Actor.IActorRef GetCurrentSenderOrNoSender() { }\n    public Akka.Actor.IInternalActorRef GetSingleChild(string name) { }\n    public void Init(bool sendSupervise, Akka.Dispatch.MailboxType mailboxType) { }\n    [return: System.Runtime.CompilerServices.NullableAttribute(2)]\n    public Akka.Actor.Internal.ChildRestartStats InitChild(Akka.Actor.IInternalActorRef actor) { }\n    public void Invoke(Akka.Actor.Envelope envelope) { }\n    protected virtual void PreStart() { }\n    protected void PrepareForNewActor() { }\n    protected virtual void ReceiveMessage(object message) { }\n    public void ReceiveMessageForTest(Akka.Actor.Envelope envelope) { }\n    protected void ReceivedTerminated(Akka.Actor.Terminated t) { }\n    protected void RemWatcher(Akka.Actor.IActorRef watchee, Akka.Actor.IActorRef watcher) { }\n    [return: System.Runtime.CompilerServices.NullableAttribute(2)]\n    protected Akka.Actor.Internal.SuspendReason RemoveChildAndGetStateChange(Akka.Actor.IActorRef child) { }\n    public void ReserveChild(string name) { }\n    public void Restart(System.Exception cause) { }\n    public void Resume(System.Exception causedByFailure) { }\n    public virtual void SendMessage(Akka.Actor.Envelope message) { }\n    public virtual void SendMessage(Akka.Actor.IActorRef sender, object message) { }\n    public virtual void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage systemMessage) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Cluster Sharding with Message Routing in C#\nDESCRIPTION: Example of setting up Akka.Cluster.Sharding with a custom message extractor. This snippet demonstrates how to define a message envelope, implement an extractor for routing, and initialize a shard region to communicate with entities.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-sharding.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// define envelope used to message routing\npublic sealed class ShardEnvelope\n{\n    public readonly int ShardId;\n    public readonly int EntityId;\n    public readonly object Message;\n\n    ...\n}\n\n// define, how shard id, entity id and message itself should be resolved\npublic sealed class MessageExtractor : IMessageExtractor\n{\n    public string EntityId(object message) => (message as ShardEnvelope)?.EntityId.ToString();\n\n    public string ShardId(object message) => (message as ShardEnvelope)?.ShardId.ToString();\n\n    public object EntityMessage(object message) => (message as ShardEnvelope)?.Message;\n}\n\n// register actor type as a sharded entity\nvar region = await ClusterSharding.Get(system).StartAsync(\n    typeName: \"my-actor\",\n    entityPropsFactory: s => Props.Create(() => new MyActor(s)),\n    settings: ClusterShardingSettings.Create(system),\n    messageExtractor: new MessageExtractor());\n\n// send message to entity through shard region\nregion.Tell(new ShardEnvelope(shardId: 1, entityId: 1, message: \"hello\"))\n```\n\n----------------------------------------\n\nTITLE: Implementing DeathWatch in Akka.NET C#\nDESCRIPTION: Demonstrates how to use Context.Watch to monitor the lifecycle of a child actor and react to its termination. The example shows registration for Terminated messages and handling of actor termination.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic class WatchActor : ReceiveActor\n{\n    private IActorRef child = Context.ActorOf(Props.Empty, \"child\");\n    private IActorRef lastSender = Context.System.DeadLetters;\n\n    public WatchActor()\n    {\n        Context.Watch(child); // <-- this is the only call needed for registration\n\n        Receive<string>(s => s.Equals(\"kill\"), msg =>\n        {\n            Context.Stop(child);\n            lastSender = Sender;\n        });\n\n        Receive<Terminated>(t => t.ActorRef.Equals(child), msg =>\n        {\n            lastSender.Tell(\"finished\");\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Actor Instantiation in C#\nDESCRIPTION: This snippet shows the proper way to create and reference an Akka.NET actor using Props.Create and ActorSystem.ActorOf. It includes an example of creating an actor with constructor parameters.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK1000.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Actor;\n\nclass MyActor : ReceiveActor {\n    private readonly string _name;\n    private readonly int _myVar;\n\n    public MyActor(string name, int myVar){\n        _name = name;\n        _myVar = myVar;\n        ReceiveAny(_ => {\n            Sender.Tell(_name + _myVar);\n        });\n    }\n}\n\nclass Test\n{\n    void Method()\n    {\n        // obviously, don't create a new ActorSystem every time - this is just an example.\n        ActorSystem sys = ActorSystem.Create(\"MySys\");\n        Akka.Actor.Props props = Akka.Actor.Props.Create(() => new MyActor(\"foo\", 1));\n        IActorRef realActorInstance = sys.ActorOf(props);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing CircuitBreaker Pattern in Akka.NET\nDESCRIPTION: Circuit breaker implementation for fault tolerance. Helps prevent cascading failures by temporarily disabling operations after a threshold of failures. Supports exponential backoff for reset timeouts.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_194\n\nLANGUAGE: C#\nCODE:\n```\npublic class CircuitBreaker\n{\n    public CircuitBreaker(Akka.Actor.IScheduler scheduler, int maxFailures, System.TimeSpan callTimeout, System.TimeSpan resetTimeout) { }\n    public CircuitBreaker(Akka.Actor.IScheduler scheduler, int maxFailures, System.TimeSpan callTimeout, System.TimeSpan resetTimeout, System.TimeSpan maxResetTimeout, double exponentialBackoffFactor) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring TLS Security in Akka.Remote with HOCON\nDESCRIPTION: HOCON configuration for enabling TLS security in Akka.Remote using the DotNetty transport. This snippet shows how to enable SSL, specify certificate paths, passwords, and storage flags. A valid SSL certificate must be installed on all participating hosts.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/remoting/security.md#2025-04-16_snippet_0\n\nLANGUAGE: hocon\nCODE:\n```\nakka {\n  loglevel = DEBUG\n  actor {\n    provider = remote\n  }\n  remote {\n    dot-netty.tcp {\n      port = 0\n      hostname = 127.0.0.1\n      enable-ssl = true\n      log-transport = true\n      ssl {\n        suppress-validation = true\n        certificate {\n          # valid ssl certificate must be installed on both hosts\n          path = \"<valid certificate path>\" \n          password = \"<certificate password>\"\n          # flags is optional: defaults to \"default-flag-set\" key storage flag\n          # other available storage flags:\n          #   exportable | machine-key-set | persist-key-set | user-key-set | user-protected\n          flags = [ \"default-flag-set\" ] \n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Materialized Values in Akka Streams\nDESCRIPTION: Demonstrates various techniques for managing and combining materialized values from different stream components using Keep methods and materialization strategies\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/basics.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n// An source that can be signalled explicitly from the outside\nSource<int, TaskCompletionSource<int>> source = Source.Maybe<int>();\n\n// A flow that internally throttles elements to 1 / second, and returns a Cancellable\n// which can be used to shut down the stream\nFlow<int, int, ICancelable> flow = throttler;\n\n// A sink that returns the first element of a stream in the returned Task\nSink<int, Task<int>> sink = Sink.First<int>();\n\n// By default, the materialized value of the leftmost stage is preserved\nIRunnableGraph<TaskCompletionSource<int>> r1 = source.Via(flow).To(sink);\n\n// Simple selection of materialized values by using Keep.right\nIRunnableGraph<ICancelable> r2 = source.ViaMaterialized(flow, Keep.Right).To(sink);\nIRunnableGraph<Task<int>> r3 = source.Via(flow).ToMaterialized(sink, Keep.Right);\n```\n\n----------------------------------------\n\nTITLE: Combining Pipelining and Parallel Processing in Akka Streams (C#)\nDESCRIPTION: Illustrates how to combine pipelining and parallel processing techniques in Akka Streams. This example creates two parallel pipelines, each consisting of two pipelined stages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/pipeliningandparallelism.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar pancakeChef = Flow.FromGraph(GraphDsl.Create(b =>\n{\n    var dispatchBatter = b.Add(new Balance<ScoopOfBatter>(2));\n    var mergePancakes = b.Add(new Merge<Pancake>(2));\n\n    // Using two pipelines, having two frying pans each, in total using\n    // four frying pans\n    b.From(dispatchBatter.Out(0)).Via(fryingPan1.Async()).Via(fryingPan2.Async()).To(mergePancakes.In(0));\n    b.From(dispatchBatter.Out(1)).Via(fryingPan1.Async()).Via(fryingPan2.Async()).To(mergePancakes.In(1));\n\n    return new FlowShape<ScoopOfBatter, Pancake>(dispatchBatter.In, mergePancakes.Out);\n}));\n```\n\n----------------------------------------\n\nTITLE: Implementing Echo Server with Akka Streams TCP\nDESCRIPTION: This snippet demonstrates how to create a simple Echo Server using Akka Streams TCP. It binds to an address and handles incoming connections, adding exclamation marks to each received message.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithstreamingio.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar connections = await Tcp.Get(system).BindAndHandle(\n    connectionHandler,\n    EndPoint.Parse(\"127.0.0.1:8888\"),\n    settings,\n    materializer);\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvar delimiter = Framing.Delimiter(ByteString.FromString(\"\\n\"), maximumFrameLength: 256, allowTruncation: true);\n\nvar echo = Flow.Create<ByteString>()\n    .Via(delimiter)\n    .Select(text => ByteString.FromString(text.ToString() + \"!!!\"));\n\nvar handler = Sink.ForEach<Tcp.IncomingConnection>(connection =>\n    connection.HandleWith(echo, materializer));\n\nconnections.RunWith(handler, materializer);\n```\n\n----------------------------------------\n\nTITLE: Acquiring ActorRef from ActorSelection in Akka.NET C#\nDESCRIPTION: Demonstrates how to acquire an IActorRef from an ActorSelection using the Identify message. This example shows handling of ActorIdentity messages and actor termination.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Follower : ReceiveActor\n{\n    private readonly IActorRef _probe;\n    private string identifyId = \"1\";\n    private IActorRef _another;\n\n    public Follower(IActorRef probe)\n    {\n        _probe = probe;\n\n        var selection = Context.ActorSelection(\"/user/another\");\n        selection.Tell(new Identify(identifyId), Self);\n\n        Receive<ActorIdentity>(identity =>\n        {\n            if (identity.MessageId.Equals(identifyId))\n            {\n                var subject = identity.Subject;\n\n                if (subject == null)\n                {\n                    Context.Stop(Self);\n                }\n                else\n                {\n                    _another = subject;\n                    Context.Watch(_another);\n                    _probe.Tell(subject, Self);\n                }\n            }\n        });\n\n        Receive<Terminated>(t =>\n        {\n            if (t.ActorRef.Equals(_another))\n            {\n                Context.Stop(Self);\n            }\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating TestActorRef for Synchronous Actor Testing in C#\nDESCRIPTION: Demonstrates how to create a TestActorRef for synchronous testing of an actor, allowing direct access to the underlying actor instance.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/testing-actor-systems.md#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nvar props = Props.Create<MyActor>();\nvar myTestActor = new TestActorRef<MyActor>(Sys, props, null, \"testA\");\nMyActor myActor = myTestActor.UnderlyingActor;\n```\n\n----------------------------------------\n\nTITLE: Implementing ActorBase Abstract Class in Akka.NET\nDESCRIPTION: Defines the ActorBase abstract class which is the foundation for actor implementations in Akka.NET. It provides core actor lifecycle methods, message handling capabilities, and state management through Become/Unbecome patterns.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class ActorBase : Akka.Actor.IInternalActor\n{\n    protected ActorBase() { }\n    protected static Akka.Actor.IActorContext Context { get; }\n    protected static Akka.Actor.Receive EmptyReceive { get; }\n    protected Akka.Actor.IActorRef Self { get; }\n    protected Akka.Actor.IActorRef Sender { get; }\n    public virtual void AroundPostRestart(System.Exception cause, object message) { }\n    public virtual void AroundPostStop() { }\n    public virtual void AroundPreRestart(System.Exception cause, object message) { }\n    public virtual void AroundPreStart() { }\n    protected virtual bool AroundReceive(Akka.Actor.Receive receive, object message) { }\n    protected void Become(Akka.Actor.Receive receive) { }\n    protected void BecomeStacked(Akka.Actor.Receive receive) { }\n    protected virtual void PostRestart(System.Exception reason) { }\n    protected virtual void PostStop() { }\n    protected virtual void PreRestart(System.Exception reason, object message) { }\n    protected virtual void PreStart() { }\n    protected abstract bool Receive(object message);\n    protected void SetReceiveTimeout(System.Nullable<System.TimeSpan> timeout) { }\n    protected virtual Akka.Actor.SupervisorStrategy SupervisorStrategy() { }\n    protected void UnbecomeStacked() { }\n    protected virtual void Unhandled(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Actor Creation Examples\nDESCRIPTION: Demonstrates creating actors using ActorSystem and within other actors as child actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// ActorSystem is a heavy object: create only one per application\nActorSystem system = ActorSystem.Create(\"MySystem\");\nIActorRef myActor = system.ActorOf<MyActor>(\"myactor\");\n```\n\n----------------------------------------\n\nTITLE: Akka.NET Persistence Actor Class Hierarchy\nDESCRIPTION: Core persistence classes in Akka.NET including UntypedPersistentActor, PersistentView, AtLeastOnceDeliveryActor, AsyncWriteJournal and SnapshotStore. These base classes provide persistence capabilities to actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/architecture.md#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n* UntypedPersistentActor\n* PersistentView\n* AtLeastOnceDeliveryActor\n* AsyncWriteJournal\n* SnapshotStore\n```\n\n----------------------------------------\n\nTITLE: Defining the ActorCell Class in Akka.NET\nDESCRIPTION: The `ActorCell` class in Akka.NET manages the internal state and lifecycle of an actor instance. It implements interfaces such as `IActorContext`, `IActorRefFactory`, and `ICell`.  It handles message dispatch, child actor management, supervision, and other internal actor operations. Key responsibilities include creating child actors, managing mailbox, handling system messages, and supervising child actors during failures.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n    [System.Diagnostics.DebuggerDisplayAttribute(\"{Self,nq}\")]\n    [System.Runtime.CompilerServices.NullableAttribute(0)]\n    public class ActorCell : Akka.Actor.IActorContext, Akka.Actor.IActorRefFactory, Akka.Actor.ICanWatch, Akka.Actor.ICell, Akka.Actor.IUntypedActorContext\n    {\n        public const int UndefinedUid = 0;\n        public ActorCell(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.IInternalActorRef self, Akka.Actor.Props props, Akka.Dispatch.MessageDispatcher dispatcher, Akka.Actor.IInternalActorRef parent) { }\n        public Akka.Actor.Internal.IChildrenContainer ChildrenContainer { get; }\n        public int CurrentEnvelopeId { get; }\n        [System.Runtime.CompilerServices.NullableAttribute(2)]\n        public object CurrentMessage { get; }\n        public Akka.Dispatch.MessageDispatcher Dispatcher { get; }\n        public bool HasMessages { get; }\n        public bool IsLocal { get; }\n        protected bool IsNormal { get; }\n        public bool IsTerminated { get; }\n        protected bool IsTerminating { get; }\n        [System.Runtime.CompilerServices.NullableAttribute(2)]\n        public Akka.Dispatch.Mailbox Mailbox { get; }\n        public int NumberOfMessages { get; }\n        public Akka.Actor.IInternalActorRef Parent { get; }\n        public Akka.Actor.Props Props { get; }\n        public System.Nullable<System.TimeSpan> ReceiveTimeout { get; }\n        public Akka.Actor.IActorRef Self { get; }\n        [System.Runtime.CompilerServices.NullableAttribute(2)]\n        public Akka.Actor.IActorRef Sender { get; }\n        public Akka.Actor.ActorSystem System { get; }\n        public Akka.Actor.Internal.ActorSystemImpl SystemImpl { get; }\n        public virtual Akka.Dispatch.ActorTaskScheduler TaskScheduler { get; }\n        public virtual Akka.Actor.IActorRef ActorOf(Akka.Actor.Props props, [System.Runtime.CompilerServices.NullableAttribute(2)] string name = null) { }\n        public Akka.Actor.ActorSelection ActorSelection(string path) { }\n        public Akka.Actor.ActorSelection(Akka.Actor.ActorPath path) { }\n        protected void AddWatcher(Akka.Actor.IActorRef watchee, Akka.Actor.IActorRef watcher) { }\n        protected void AddressTerminated(Akka.Actor.Address address) { }\n        public virtual Akka.Actor.IActorRef AttachChild(Akka.Actor.Props props, bool isSystemService, [System.Runtime.CompilerServices.NullableAttribute(2)] string name = null) { }\n        protected virtual void AutoReceiveMessage(Akka.Actor.Envelope envelope) { }\n        public void Become(Akka.Actor.Receive receive) { }\n        public void BecomeStacked(Akka.Actor.Receive receive) { }\n        public void CheckReceiveTimeout(bool reschedule = True) { }\n        protected void ClearActor(Akka.Actor.ActorBase actor) { }\n        protected void ClearActorCell() { }\n        [return: System.Runtime.CompilerServices.NullableAttribute(2)]\n        protected virtual Akka.Actor.ActorRestarted CreateActorRestartedEvent(System.Exception cause) { }\n        protected virtual Akka.Actor.ActorStarted CreateActorStartedEvent() { }\n        protected virtual Akka.Actor.ActorStopped CreateActorStoppedEvent() { }\n        protected virtual Akka.Actor.ActorBase CreateNewActorInstance() { }\n        [System.ObsoleteAttribute(\"Use TryGetChildStatsByName [0.7.1]\", true)]\n        public Akka.Actor.IInternalActorRef GetChildByName(string name) { }\n        public System.Collections.Generic.IEnumerable<Akka.Actor.IInternalActorRef> GetChildren() { }\n        public static Akka.Actor.IActorRef GetCurrentSelfOrNoSender() { }\n        public static Akka.Actor.IActorRef GetCurrentSenderOrNoSender() { }\n        public Akka.Actor.IInternalActorRef GetSingleChild(string name) { }\n        public void Init(bool sendSupervise, Akka.Dispatch.MailboxType mailboxType) { }\n        [return: System.Runtime.CompilerServices.NullableAttribute(2)]\n        public Akka.Actor.Internal.ChildRestartStats InitChild(Akka.Actor.IInternalActorRef actor) { }\n        public void Invoke(Akka.Actor.Envelope envelope) { }\n        protected virtual void PreStart() { }\n        protected void PrepareForNewActor() { }\n        protected virtual void ReceiveMessage(object message) { }\n        public void ReceiveMessageForTest(Akka.Actor.Envelope envelope) { }\n        protected void ReceivedTerminated(Akka.Actor.Terminated t) { }\n        protected void RemWatcher(Akka.Actor.IActorRef watchee, Akka.Actor.IActorRef watcher) { }\n        [return: System.Runtime.CompilerServices.NullableAttribute(2)]\n        protected Akka.Actor.Internal.SuspendReason RemoveChildAndGetStateChange(Akka.Actor.IActorRef child) { }\n        public void ReserveChild(string name) { }\n        public void Restart(System.Exception cause) { }\n        public void Resume(System.Exception causedByFailure) { }\n        public virtual void SendMessage(Akka.Actor.Envelope message) { }\n        public virtual void SendMessage(Akka.Actor.IActorRef sender, object message) { }\n        public virtual void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage systemMessage) { }\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Remote Actor Communication in C#\nDESCRIPTION: Example showing how to set up remote messaging between two actors using a shared message class. Demonstrates sending messages via ActorSelection and handling responses between remote systems.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/remoting/messaging.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Written into a shared library\npublic class Msg {\n    public string Content {get; set;}\n}\n\npublic class StartRemoting{}\n\n// Initiates remote contact \npublic class SendActor : ReceiveActor{\n    public SendActor(){\n        Receive<StartRemoting>(s => {\n            Context.ActorSelection(\"akka.tcp://RemoteSys@localhost:9000/user/Echo\")\n            .Tell(new Msg(\"hi!\"));\n        });\n        Receive<Msg>(msg => {\n            Console.WriteLine(\"Received {0} from {1}\", msg.Content, Sender);\n        });\n    }    \n}\n\n// Runs in a separate process from SendActor\npublic class EchoActor : ReceiveActor{\n    public EchoActor(){\n        Receive<Msg>(msg => {\n            // echo message back to sender\n            Sender.Tell(msg);\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Settings Class for Akka.NET ActorSystem in C#\nDESCRIPTION: Defines the Settings class with various configuration properties for the Akka.NET ActorSystem. It includes constructors and methods for managing system settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\npublic class Settings\n{\n    public Settings(Akka.Actor.ActorSystem system, Akka.Configuration.Config config) { }\n    public Settings(Akka.Actor.ActorSystem system, Akka.Configuration.Config config, Akka.Actor.Setup.ActorSystemSetup setup) { }\n    public bool AddLoggingReceive { get; }\n    public System.TimeSpan AskTimeout { get; }\n    public Akka.Configuration.Config Config { get; }\n    // ... (other properties)\n    public void InjectTopLevelFallback(Akka.Configuration.Config config) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Actor with Message Handling in C#\nDESCRIPTION: Example of creating a basic actor by extending UntypedActor class and implementing message handling logic in the OnReceive method.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyActor : UntypedActor\n{\n    private ILoggingAdapter log = Context.GetLogger();\n\n    protected override void OnReceive(object message)\n    {\n        switch (message)\n        {\n            case \"test\":\n                log.Info(\"received test\");\n                break;\n            default:\n                log.Info(\"received unknown message\");\n                break;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Reusing Receive Specifications in Akka.NET\nDESCRIPTION: This snippet illustrates how to structure actor code to reuse receive specifications, reducing redundancy in message handler definitions. A method is created to handle mood changes, which is called in different state methods for code reusability.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka/Util/MatchHandler/README.md#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class MoodActor : ReceiveActor\n{\n  public MoodActor()\n  {\n    Receive<string>(s => s == \"Mood?\", _ => Sender.Tell(\"I'm neutral\"));\n    ReceiveMoodSwitchers();\n  }\n\n  private void Happy()\n  {\n    Receive<string>(s => s == \"Mood?\", _ => Sender.Tell(\"I'm happy\"));\n    Receive<string>(s => s == \"Happy\", _ => Sender.Tell(\"I'm already happy!\", Self));\n    ReceiveMoodSwitchers();\n  }\n\n  private void Angry()\n  {\n    Receive<string>(s => s == \"Mood?\", _ => Sender.Tell(\"I'm angry\")); \n    Receive<string>(s => s == \"Angry\", _ => Sender.Tell(\"I'm already angry!\", Self));\n    ReceiveMoodSwitchers();\n  }\n\n  private void Grumpy()\n  {\n    Receive<string>(s => s == \"Snap out of it!\", s => Unbecome());\n    Receive<string>(s => Sender.Tell(\"Leave me alone. I'm Grumpy!\"));\n  }\n\n  private void ReceiveMoodSwitchers()\n  {\n    Receive<string>(s => s == \"Happy\", _ => Become(Happy));\n    Receive<string>(s => s == \"Angry\", _ => Become(Angry));\n    Receive<string>(s => s == \"Grumpy\", _ => Become(Grumpy, discardOld: false));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Bus Infrastructure in Akka.NET\nDESCRIPTION: Defines the core event bus infrastructure for Akka.NET, including the abstract EventBus class, EventStream implementation, and extension methods. This provides the foundation for publish-subscribe communication in Akka actor systems.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_138\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class EventBus<TEvent, TClassifier, TSubscriber>\n{\n    protected EventBus() { }\n    protected abstract bool Classify(TEvent @event, TClassifier classifier);\n    protected abstract TClassifier GetClassifier(TEvent @event);\n    protected abstract bool IsSubClassification(TClassifier parent, TClassifier child);\n    protected abstract void Publish(TEvent @event, TSubscriber subscriber);\n    public virtual void Publish(TEvent @event) { }\n    protected string SimpleName(object source) { }\n    protected string SimpleName(System.Type source) { }\n    public virtual bool Subscribe(TSubscriber subscriber, TClassifier classifier) { }\n    public virtual bool Unsubscribe(TSubscriber subscriber) { }\n    public virtual bool Unsubscribe(TSubscriber subscriber, TClassifier classifier) { }\n}\n\npublic class EventStream : Akka.Event.LoggingBus\n{\n    public EventStream(bool debug) { }\n    public void StartUnsubscriber(Akka.Actor.Internal.ActorSystemImpl system) { }\n    public override bool Subscribe(Akka.Actor.IActorRef subscriber, System.Type channel) { }\n    public override bool Unsubscribe(Akka.Actor.IActorRef subscriber, System.Type channel) { }\n    public override bool Unsubscribe(Akka.Actor.IActorRef subscriber) { }\n}\n\npublic class static EventStreamExtensions\n{\n    public static bool Subscribe<TChannel>(this Akka.Event.EventStream eventStream, Akka.Actor.IActorRef subscriber) { }\n    public static bool Unsubscribe<TChannel>(this Akka.Event.EventStream eventStream, Akka.Actor.IActorRef subscriber) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Circuit Breaker Implementation in C#\nDESCRIPTION: Implements circuit breaker pattern for failure handling with configurable timeout, reset, and exponential backoff settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_175\n\nLANGUAGE: C#\nCODE:\n```\npublic class CircuitBreaker\n{\n    public CircuitBreaker(Akka.Actor.IScheduler scheduler, int maxFailures, System.TimeSpan callTimeout, System.TimeSpan resetTimeout) { }\n    public CircuitBreaker(Akka.Actor.IScheduler scheduler, int maxFailures, System.TimeSpan callTimeout, System.TimeSpan resetTimeout, System.TimeSpan maxResetTimeout, double exponentialBackoffFactor) { }\n    public CircuitBreaker(Akka.Actor.IScheduler scheduler, int maxFailures, System.TimeSpan callTimeout, System.TimeSpan resetTimeout, System.TimeSpan maxResetTimeout, double exponentialBackoffFactor, double randomFactor) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting a Publisher Actor in Akka.NET Cluster\nDESCRIPTION: Code for creating and starting a publisher actor that will send messages to the \"content\" topic, which will be delivered to all subscribers across the cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/distributed-publish-subscribe.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nsystem.ActorOf(Props.Create(() => new Publisher()), \"publisher\");\n```\n\n----------------------------------------\n\nTITLE: ReceiveActor Implementation in Akka.NET (C#)\nDESCRIPTION: Actor base class providing a DSL for defining message handlers using the Receive pattern. Supports typed and untyped message handling, asynchronous message processing, and state changes through Become methods.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ReceiveActor : Akka.Actor.UntypedActor, Akka.Actor.Internal.IInitializableActor\n{\n    protected ReceiveActor() { }\n    protected void Become(System.Action configure) { }\n    protected void BecomeStacked(System.Action configure) { }\n    protected virtual void OnReceive(object message) { }\n    protected void Receive<T>(System.Action<T> handler, System.Predicate<T> shouldHandle = null) { }\n    protected void Receive<T>(System.Predicate<T> shouldHandle, System.Action<T> handler) { }\n    protected void Receive(System.Type messageType, System.Action<object> handler, System.Predicate<object> shouldHandle = null) { }\n    protected void Receive(System.Type messageType, System.Predicate<object> shouldHandle, System.Action<object> handler) { }\n    protected void Receive<T>(System.Func<T, bool> handler) { }\n    protected void Receive(System.Type messageType, System.Func<object, bool> handler) { }\n    protected void ReceiveAny(System.Action<object> handler) { }\n    protected void ReceiveAnyAsync(System.Func<object, System.Threading.Tasks.Task> handler) { }\n    protected void ReceiveAsync<T>(System.Func<T, System.Threading.Tasks.Task> handler, System.Predicate<T> shouldHandle = null) { }\n    protected void ReceiveAsync<T>(System.Predicate<T> shouldHandle, System.Func<T, System.Threading.Tasks.Task> handler) { }\n    protected void ReceiveAsync(System.Type messageType, System.Func<object, System.Threading.Tasks.Task> handler, System.Predicate<object> shouldHandle = null) { }\n    protected void ReceiveAsync(System.Type messageType, System.Predicate<object> shouldHandle, System.Func<object, System.Threading.Tasks.Task> handler) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Ask Pattern Methods for Akka.NET Actors in C#\nDESCRIPTION: Defines static extension methods for the Ask pattern in Akka.NET. These methods allow sending messages to actors and receiving responses as Tasks, with optional timeout and cancellation support.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic class static Futures\n{\n    public static System.Threading.Tasks.Task<object> Ask(this Akka.Actor.ICanTell self, object message, System.Nullable<System.TimeSpan> timeout = null) { }\n    public static System.Threading.Tasks.Task<object> Ask(this Akka.Actor.ICanTell self, object message, System.Threading.CancellationToken cancellationToken) { }\n    public static System.Threading.Tasks.Task<object> Ask(this Akka.Actor.ICanTell self, object message, System.Nullable<System.TimeSpan> timeout, System.Threading.CancellationToken cancellationToken) { }\n    public static System.Threading.Tasks.Task<T> Ask<T>(this Akka.Actor.ICanTell self, object message, System.Nullable<System.TimeSpan> timeout = null) { }\n    public static System.Threading.Tasks.Task<T> Ask<T>(this Akka.Actor.ICanTell self, object message, System.Threading.CancellationToken cancellationToken) { }\n    public static System.Threading.Tasks.Task<T> Ask<T>(this Akka.Actor.ICanTell self, object message, System.Nullable<System.TimeSpan> timeout, System.Threading.CancellationToken cancellationToken) { }\n    public static System.Threading.Tasks.Task<T> Ask<T>(this Akka.Actor.ICanTell self, System.Func<Akka.Actor.IActorRef, object> messageFactory, System.Nullable<System.TimeSpan> timeout, System.Threading.CancellationToken cancellationToken) { }\n}\n```\n\n----------------------------------------\n\nTITLE: IoT Application Entry Point in C#\nDESCRIPTION: Main application entry point that creates the actor system and instantiates the top-level IoT supervisor actor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-1.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../../src/core/Akka.Docs.Tutorials/Tutorial1/IotApp.cs?name=iot-app)]\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream Recovery in C#\nDESCRIPTION: Demonstrates how to use Recover to emit a final element and complete the stream on upstream failure. The example shows handling an ArithmeticException and returning a fallback value.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/error-handling.md#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nSource.From(Enumerable.Range(0, 6)).Select(n =>\n    {\n        if (n < 5)\n            return n.ToString();\n\n        throw new ArithmeticException(\"Boom!\");\n    })\n    .Recover(exception =>\n    {\n        if (exception is ArithmeticException)\n            return new Option<string>(\"stream truncated\");\n        return Option<string>.None;\n    })\n    .RunForeach(Console.WriteLine, materializer);\n```\n\n----------------------------------------\n\nTITLE: Setting Actor Dispatcher in C# Code\nDESCRIPTION: Demonstrates how to programmatically assign a custom dispatcher to an actor during creation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/dispatchers.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nsystem.ActorOf(Props.Create<MyActor>().WithDispatcher(\"my-dispatcher\"), \"my-actor\");\n```\n\n----------------------------------------\n\nTITLE: Registering FSM Transition Handler in C#\nDESCRIPTION: Shows how to register a transition handler using OnTransition method to monitor state changes in an FSM actor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/finite-state-machine.md#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nOnTransition(handler)\n```\n\n----------------------------------------\n\nTITLE: Implementing CoordinatedShutdown in C#\nDESCRIPTION: Core class for managing graceful shutdown of Akka.NET actor systems. Provides methods for system shutdown with configurable phases and timeouts.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic static Akka.Actor.CoordinatedShutdown Get(Akka.Actor.ActorSystem sys) { }\npublic System.Threading.Tasks.Task<Akka.Done> Run(Akka.Actor.CoordinatedShutdown.Reason reason, string fromPhase = null) { }\npublic System.TimeSpan Timeout(string phase) { }\n```\n\n----------------------------------------\n\nTITLE: Creating Props for Actor Instantiation\nDESCRIPTION: Shows different ways to create Props instances for actor initialization, including passing constructor arguments.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nProps props1 = Props.Create(typeof(MyActor));\nProps props2 = Props.Create(() => new MyActorWithArgs(\"arg\"));\nProps props3 = Props.Create<MyActor>();\nProps props4 = Props.Create(typeof(MyActorWithArgs), \"arg\");\n```\n\n----------------------------------------\n\nTITLE: Example of Using PartitionHub for Stateless Routing in C#\nDESCRIPTION: This example demonstrates the basic usage of PartitionHub to route elements from a producer to multiple consumers based on a partitioning function. It outlines how to wire up a producer and consumers, and the functionality related to materialization and backpressure handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/stream-dynamic.md#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[HubsDocTests.cs](../../../src/core/Akka.Docs.Tests/Streams/HubsDocTests.cs?name=partition-hub)]\n```\n\n----------------------------------------\n\nTITLE: Implementing DistributedPubSubMediator Actor in C#\nDESCRIPTION: Defines a class DistributedPubSubMediator that extends ReceiveActor. It handles distributed publish-subscribe operations in the cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic class DistributedPubSubMediator : Akka.Actor.ReceiveActor\n{\n    public DistributedPubSubMediator(Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings settings) { }\n    public Akka.Event.ILoggingAdapter Log { get; }\n    public System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, long> OwnVersions { get; }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n    public static Akka.Actor.Props Props(Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings settings) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Cluster Events in Akka.NET\nDESCRIPTION: Demonstrates how to subscribe to cluster membership events. This allows actors to receive notifications about changes in the cluster membership state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-extension.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// subscribe to all future IMemberEvents and get current state as snapshot\nCluster.Subscribe(Self, new[] { typeof(ClusterEvent.IMemberEvent) });\n```\n\n----------------------------------------\n\nTITLE: Implementing ActorSystemImpl for Akka.NET in C#\nDESCRIPTION: Defines the ActorSystemImpl class which is the core implementation of the Akka.NET actor system. It provides methods for creating actors, managing extensions, and controlling the lifecycle of the actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_47\n\nLANGUAGE: C#\nCODE:\n```\npublic class ActorSystemImpl : Akka.Actor.ExtendedActorSystem\n{\n    public ActorSystemImpl(string name) { }\n    public ActorSystemImpl(string name, Akka.Configuration.Config config, Akka.Actor.Setup.ActorSystemSetup setup, System.Nullable<Akka.Util.Option<Akka.Actor.Props>> guardianProps = null) { }\n    public override Akka.Actor.ActorProducerPipelineResolver ActorPipelineResolver { get; }\n    public override Akka.Actor.IActorRef DeadLetters { get; }\n    public override Akka.Dispatch.Dispatchers Dispatchers { get; }\n    public override Akka.Event.EventStream EventStream { get; }\n    public override Akka.Actor.IInternalActorRef Guardian { get; }\n    public Akka.Util.Option<Akka.Actor.Props> GuardianProps { get; }\n    public override Akka.Actor.IActorRef IgnoreRef { get; }\n    public override Akka.Event.ILoggingAdapter Log { get; }\n    public override Akka.Actor.IInternalActorRef LookupRoot { get; }\n    public override Akka.Dispatch.Mailboxes Mailboxes { get; }\n    public override string Name { get; }\n    public override Akka.Actor.IActorRefProvider Provider { get; }\n    public override Akka.Actor.IScheduler Scheduler { get; }\n    public override Akka.Serialization.Serialization Serialization { get; }\n    public override Akka.Actor.Settings Settings { get; }\n    public override Akka.Actor.IInternalActorRef SystemGuardian { get; }\n    public override System.Threading.Tasks.Task WhenTerminated { get; }\n    public override void Abort() { }\n    public override Akka.Actor.IActorRef ActorOf(Akka.Actor.Props props, string name = null) { }\n    public override Akka.Actor.ActorSelection ActorSelection(Akka.Actor.ActorPath actorPath) { }\n    public override Akka.Actor.ActorSelection ActorSelection(string actorPath) { }\n    public override object GetExtension(Akka.Actor.IExtensionId extensionId) { }\n    public override T GetExtension<T>()\n        where T :  class, Akka.Actor.IExtension { }\n    public override bool HasExtension(System.Type type) { }\n    public override bool HasExtension<T>()\n        where T :  class, Akka.Actor.IExtension { }\n    public override string PrintTree() { }\n    public override object RegisterExtension(Akka.Actor.IExtensionId extension) { }\n    public override void RegisterOnTermination(System.Action code) { }\n    public void Start() { }\n    public override void Stop(Akka.Actor.IActorRef actor) { }\n    public override Akka.Actor.IActorRef SystemActorOf(Akka.Actor.Props props, string name = null) { }\n    public override Akka.Actor.IActorRef SystemActorOf<TActor>(string name = null)\n        where TActor : Akka.Actor.ActorBase, new () { }\n    public override System.Threading.Tasks.Task Terminate() { }\n    public override string ToString() { }\n    public override bool TryGetExtension(System.Type extensionType, out object extension) { }\n    public override bool TryGetExtension<T>(out T extension)\n}\n```\n\n----------------------------------------\n\nTITLE: ReduceByKey Generic Function in Akka.NET\nDESCRIPTION: This snippet provides a generic function for performing reduce-by-key operations in Akka.NET Streams. It groups elements by a key, applies a mapping function, reduces the values within each group, and merges the results.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/cookbook.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic Flow<TIn, Tuple<TKey, TOut>, NotUsed> ReduceByKey<TIn, TKey, TOut>(int maximumGroupSize, \n    Func<TIn, TKey> groupKey, \n    Func<TIn, TOut> map,\n    Func<TOut, TOut, TOut> reduce)\n{\n    return (Flow<TIn, Tuple<TKey, TOut>, NotUsed>)\n        Flow.Create<TIn>()\n            .GroupBy(maximumGroupSize, groupKey)\n            .Select(e => Tuple.Create(groupKey(e), map(e)))\n            .Sum((l, r) => Tuple.Create(l.Item1, reduce(l.Item2, r.Item2)))\n            .MergeSubstreams();\n}\n\nvar counts = words.Via(ReduceByKey(MaximumDistinctWords,\n    groupKey: (string word) => word,\n    map: word => 1,\n    reduce: (l, r) => l + r));\n```\n\n----------------------------------------\n\nTITLE: Implementing a Persistent Actor in C#\nDESCRIPTION: This snippet demonstrates how to implement a persistent actor using the UntypedPersistentActor class. It shows the structure for handling commands, persisting events, and recovering state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/event-sourcing.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/core/Akka.Docs.Tests/Persistence/PersistentActor/PersistentActor.cs?name=PersistActor)]\n```\n\n----------------------------------------\n\nTITLE: Extending Flow Combinators with Custom Operators in C#\nDESCRIPTION: This code snippet shows how to create extension methods for Source and Flow classes to add custom operators like Filter. It demonstrates a way to extend Akka.NET stream combinators for more convenient syntax.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/custom-stream-processing.md#2025-04-16_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class Extensions\n{\n    public static Flow<TIn, TOut, TMat> Filter<TIn, TOut, TMat>(this Flow<TIn, TOut, TMat> flow,\n        Predicate<TOut> predicate) => flow.Via(new Filter<TOut>(predicate));\n\n    public static Source<TOut, TMat> Filter<TOut, TMat>(this Source<TOut, TMat> source,\n        Predicate<TOut> predicate) => source.Via(new Filter<TOut>(predicate));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RestartSource with Backoff in C#\nDESCRIPTION: Shows how to create a backoff supervisor using RestartSource for handling stream failures with exponential backoff delays.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/error-handling.md#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n[!code-csharp[RestartDocTests.cs](../../../src/core/Akka.Docs.Tests/Streams/RestartDocTests.cs?name=restart-with-backoff-source)]\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a ClusterClient in C#\nDESCRIPTION: Code example demonstrating how to create a ClusterClient actor and send messages to services in the cluster, including examples of Send and SendToAll operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-client.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nRunOn(() =>\n{\n    var c = Sys.ActorOf(Client.ClusterClient.Props(\n        ClusterClientSettings.Create(Sys).WithInitialContacts(initialContacts)), \"client\");\n    c.Tell(new Client.ClusterClient.Send(\"/user/serviceA\", \"hello\", localAffinity: true));\n    c.Tell(new Client.ClusterClient.SendToAll(\"/user/serviceB\", \"hi\"));\n}, client);\n```\n\n----------------------------------------\n\nTITLE: Implementing BackoffSupervisor with OnStop Strategy in C#\nDESCRIPTION: Creates a backoff supervisor that restarts a failed actor with exponential delays between 3-30 seconds when it stops. Uses randomFactor to prevent synchronized restarts across multiple actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/concepts/supervision.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar childProps = Props.Create<EchoActor>();\n\nvar supervisor = BackoffSupervisor.Props(\n    Backoff.OnStop(\n        childProps,\n        childName: \"myEcho\",\n        minBackoff: TimeSpan.FromSeconds(3),\n        maxBackoff: TimeSpan.FromSeconds(30),\n        randomFactor: 0.2));\n\nsystem.ActorOf(supervisor, \"echoSupervisor\");\n```\n\n----------------------------------------\n\nTITLE: Graceful Stop in Akka.NET\nDESCRIPTION: This snippet demonstrates using `GracefulStop` to stop an actor and wait for its termination. It also shows how to handle a timeout if the actor does not stop within the specified duration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_27\n\nLANGUAGE: csharp\nCODE:\n```\nvar manager = system.ActorOf<Manager>();\n\ntry\n{\n    await manager.GracefulStop(TimeSpan.FromMilliseconds(5), \"shutdown\");\n    // the actor has been stopped\n}\ncatch (TaskCanceledException)\n{\n    // the actor wasn't stopped within 5 seconds\n}\n\n...\npublic class Manager : ReceiveActor\n{\n    private IActorRef worker = Context.Watch(Context.ActorOf<Cruncher>(\"worker\"));\n\n    public Manager()\n    {\n        Receive<string>(s => s.Equals(\"job\"), msg =>\n        {\n            worker.Tell(\"crunch\");\n        });\n\n        Receive<Shutdown>(_ =>\n        {\n            worker.Tell(PoisonPill.Instance, Self);\n            Context.Become(ShuttingDown);\n        });\n    }\n\n    private void ShuttingDown(object message)\n    {\n        Receive<string>(s => s.Equals(\"job\"), msg =>\n        {\n            Sender.Tell(\"service unavailable, shutting down\", Self);\n        });\n\n        Receive<Shutdown>(_ =>\n        {\n            Context.Stop(Self);\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RouterConfig Abstract Class in Akka.NET\nDESCRIPTION: Abstract base class for router configurations that defines common properties and methods for all router implementations. Handles router creation, verification, and management message detection.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_210\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class RouterConfig : Akka.Util.ISurrogated, System.IEquatable<Akka.Routing.RouterConfig>\n{\n    protected RouterConfig() { }\n    protected RouterConfig(string routerDispatcher) { }\n    public virtual string RouterDispatcher { get; }\n    public virtual bool StopRouterWhenAllRouteesRemoved { get; }\n    public abstract Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system);\n    [Akka.Annotations.InternalApiAttribute()]\n    public abstract Akka.Actor.ActorBase CreateRouterActor();\n    public bool Equals(Akka.Routing.RouterConfig other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public virtual bool IsManagementMessage(object message) { }\n    public virtual Akka.Actor.Props RoutingLogicController(Akka.Routing.RoutingLogic routingLogic) { }\n    public abstract Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system);\n    public virtual void VerifyConfig(Akka.Actor.ActorPath path) { }\n    public virtual Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PipeToSupport Static Class for Task Integration\nDESCRIPTION: Provides extension methods to pipe Task and ValueTask results to actors. Supports mapping success and failure cases to custom messages and configuring awaiting behavior.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\npublic static class PipeToSupport\n{\n    public static System.Threading.Tasks.Task PipeTo<T>(this System.Threading.Tasks.Task<T> taskToPipe, Akka.Actor.ICanTell recipient, Akka.Actor.IActorRef sender = null, System.Func<T, object> success = null, System.Func<System.Exception, object> failure = null) { }\n    public static System.Threading.Tasks.Task PipeTo<T>(this System.Threading.Tasks.ValueTask<T> taskToPipe, Akka.Actor.ICanTell recipient, Akka.Actor.IActorRef sender = null, System.Func<T, object> success = null, System.Func<System.Exception, object> failure = null) { }\n    public static System.Threading.Tasks.Task PipeTo<T>(this System.Threading.Tasks.Task<T> taskToPipe, Akka.Actor.ICanTell recipient, bool useConfigureAwait, Akka.Actor.IActorRef sender = null, System.Func<T, object> success = null, System.Func<System.Exception, object> failure = null) { }\n    public static System.Threading.Tasks.Task PipeTo<T>(this System.Threading.Tasks.ValueTask<T> taskToPipe, Akka.Actor.ICanTell recipient, bool useConfigureAwait, Akka.Actor.IActorRef sender = null, System.Func<T, object> success = null, System.Func<System.Exception, object> failure = null) { }\n    public static System.Threading.Tasks.Task PipeTo(this System.Threading.Tasks.Task taskToPipe, Akka.Actor.ICanTell recipient, Akka.Actor.IActorRef sender = null, System.Func<object> success = null, System.Func<System.Exception, object> failure = null) { }\n    public static System.Threading.Tasks.Task PipeTo(this System.Threading.Tasks.ValueTask taskToPipe, Akka.Actor.ICanTell recipient, Akka.Actor.IActorRef sender = null, System.Func<object> success = null, System.Func<System.Exception, object> failure = null) { }\n    public static System.Threading.Tasks.Task PipeTo(this System.Threading.Tasks.Task taskToPipe, Akka.Actor.ICanTell recipient, bool useConfigureAwait, Akka.Actor.IActorRef sender = null, System.Func<object> success = null, System.Func<System.Exception, object> failure = null) { }\n    public static System.Threading.Tasks.Task PipeTo(this System.Threading.Tasks.ValueTask taskToPipe, Akka.Actor.ICanTell recipient, bool useConfigureAwait, Akka.Actor.IActorRef sender = null, System.Func<object> success = null, System.Func<System.Exception, object> failure = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting a Flow to an IProcessor in C#\nDESCRIPTION: Demonstrates how to materialize a Flow to an IProcessor which can directly connect Publishers and Subscribers in the Reactive Streams model.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nvar processor = authors.ToProcessor().Run(materializer);\ntweets.Subscribe(processor);\nprocessor.Subscribe(storage);\n```\n\n----------------------------------------\n\nTITLE: Merging BootstrapSetup with Other Setup Classes in Akka.NET\nDESCRIPTION: This snippet demonstrates how to create a BootstrapSetup with HOCON configuration and merge it with other Setup classes (in this case SerializationSetup) to create an ActorSystemSetup object.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/config.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar config = ConfigurationFactory.ParseString(@\"\"\"\nakka.actor{\n    serializers{\n        hyperion = \"\"Akka.Serialization.HyperionSerializer, Akka.Serialization.Hyperion\"\"\n    }\n}\"\"\");\n\n// sets up the ActorSystem with both the bootstrap configuration\n// settings we need for DI plus the programmatic serialization\nvar bootstrap = BootstrapSetup.Create().WithConfig(config);\nvar serializationSetup = SerializationSetup.Create(system => {\n    // we'll use Hyperion to serialize all of our messages\n    system.Serialization.AddSerializer(\"hyperion\", new SerializerDetails(\n        typeof(HyperionSerializer),\n        \"hyperion\",\n        new[] { typeof(IActorRef) }\n    ));\n});\n\nvar actorSystemSetup = bootstrap.And(serializationSetup);\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract Serializer Class in C#\nDESCRIPTION: Defines an abstract Serializer class with methods for binary serialization and deserialization. It includes an abstract Identifier property and methods for converting objects to and from byte arrays.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_215\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Serializer\n{\n    protected readonly Akka.Actor.ExtendedActorSystem system;\n    protected Serializer(Akka.Actor.ExtendedActorSystem system) { }\n    public virtual int Identifier { get; }\n    public abstract bool IncludeManifest { get; }\n    public abstract object FromBinary(byte[] bytes, System.Type type);\n    public T FromBinary<T>(byte[] bytes) { }\n    public abstract byte[] ToBinary(object obj);\n    public byte[] ToBinaryWithAddress(Akka.Actor.Address address, object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting FSM Timer in C#\nDESCRIPTION: Demonstrates how to set a named timer in FSM with options for interval and repeat behavior. The timer sends a specified message after the interval elapses.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/finite-state-machine.md#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nSetTimer(name, msg, interval, repeat);\n```\n\n----------------------------------------\n\nTITLE: Basic Message Receiving in Actor in C#\nDESCRIPTION: Demonstrates implementing OnReceive method in an UntypedActor to handle different types of messages with logging.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyActor : UntypedActor\n{\n    private ILoggingAdapter log = Context.GetLogger();\n\n    protected override void OnReceive(object message)\n    {\n        switch (message)\n        {\n            case \"test\":\n                log.Info(\"received test\");\n                break;\n            default:\n                log.Info(\"received unknown message\");\n                break;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Routee Class in C#\nDESCRIPTION: Definition of the Routee class which represents destination endpoints for routed messages. It provides methods for sending and asking messages to routees, and static factory methods to create routees from actor references.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_191\n\nLANGUAGE: C#\nCODE:\n```\npublic class Routee\n{\n    public static readonly Akka.Routing.Routee NoRoutee;\n    public Routee() { }\n    public virtual System.Threading.Tasks.Task<object> Ask(object message, System.Nullable<System.TimeSpan> timeout) { }\n    public static Akka.Routing.Routee FromActorRef(Akka.Actor.IActorRef actorRef) { }\n    public virtual void Send(object message, Akka.Actor.IActorRef sender) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Message Queue Interface in Akka.NET\nDESCRIPTION: Defines the core interface for all message queues in Akka.NET. Specifies essential operations including enqueueing, dequeueing, cleanup, and status checking that all queue implementations must provide.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_110\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IMessageQueue\n{\n    int Count { get; }\n    bool HasMessages { get; }\n    void CleanUp(Akka.Actor.IActorRef owner, Akka.Dispatch.MessageQueues.IMessageQueue deadletters);\n    void Enqueue(Akka.Actor.IActorRef receiver, Akka.Actor.Envelope envelope);\n    bool TryDequeue(out Akka.Actor.Envelope envelope);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Persistent Actor with Sharding\nDESCRIPTION: Shows how to implement a persistent actor class that works with cluster sharding by using the entityId to create a unique PersistenceId.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-sharding.md#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Aggregate : PersistentActor\n{\n    public override string PersistenceId { get; }\n\n    // Passed in via entityPropsFactory via the ShardRegion\n    public Aggregate(string persistentId)\n    {\n        PersistenceId = persistentId;\n    }\n\n    // rest of class\n}\n```\n\n----------------------------------------\n\nTITLE: Combining DeferAsync with Persist in Akka.NET Persistent Actors\nDESCRIPTION: Illustrates how to use DeferAsync in combination with Persist to define actions that should occur after event persistence.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/event-sourcing.md#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/core/Akka.Docs.Tests/Persistence/PersistentActor/DeferWithPersist.cs?name=DeferWithPersist)]\n```\n\n----------------------------------------\n\nTITLE: Implementing Akka.NET Hosted Service in ASP.NET Core\nDESCRIPTION: Implements Akka.NET as an IHostedService that also serves as an IActorBridge. This service manages the ActorSystem lifecycle, starting it when the application starts and terminating it when the application stops.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/deployment/aspnet-core.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class AkkaService : IHostedService, IActorBridge\n{\n    private readonly IServiceProvider _serviceProvider;\n    private readonly IHostApplicationLifetime _applicationLifetime;\n    private ActorSystem _actorSystem;\n\n    public AkkaService(IServiceProvider serviceProvider, IHostApplicationLifetime appLifetime)\n    {\n        _serviceProvider = serviceProvider;\n        _applicationLifetime = appLifetime;\n    }\n\n    public Task StartAsync(CancellationToken cancellationToken)\n    {\n        var config = HoconLoader.FromFile(\"app.conf\");\n        var bootstrap = BootstrapSetup.Create().WithConfig(config);\n\n        var di = DependencyResolverSetup.Create(_serviceProvider);\n\n        var actorSystemSetup = bootstrap.And(di);\n\n        _actorSystem = ActorSystem.Create(\"my-app\", actorSystemSetup);\n\n        _applicationLifetime.ApplicationStarted.Register(() =>\n        {\n            // initialize your actors here\n            var actor = ActorOf(Props.Create(() => new ExampleActor()), \"example\");\n        });\n\n        _applicationLifetime.ApplicationStopping.Register(() =>\n        {\n            CoordinatedShutdown.Get(_actorSystem).Run(CoordinatedShutdown.ClrExitReason.Instance);\n            \n        });\n\n        return Task.CompletedTask;\n    }\n\n    public async Task StopAsync(CancellationToken cancellationToken)\n    {\n        await CoordinatedShutdown.Get(_actorSystem).Run(CoordinatedShutdown.ClrExitReason.Instance);\n    }\n\n    public ActorSystem ActorSystem => _actorSystem;\n\n    public IActorRef ActorOf(Props props, string name = null)\n    {\n        return name is null ? _actorSystem.ActorOf(props) : _actorSystem.ActorOf(props, name);\n    }\n\n    public IActorRef ActorSelection(string actorPath)\n    {\n        return _actorSystem.ActorSelection(actorPath).ResolveOne(TimeSpan.FromSeconds(3)).Result;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Akka.Streams Package\nDESCRIPTION: Adds the Akka.Streams NuGet package to the project\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/quickstart.md#2025-04-16_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\nInstall-Package Akka.Streams\n```\n\n----------------------------------------\n\nTITLE: Basic Division Error Handling in Akka Stream\nDESCRIPTION: Demonstrates default stream failure behavior with division by zero, where the stream will complete with a failure\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/error-handling.md#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nvar source = Source.From(Enumerable.Range(0, 6)).Select(x => 100/x);\nvar result = source.RunWith(Sink.Aggregate<int, int>(0, (sum, i) => sum + i), materializer);\n```\n\n----------------------------------------\n\nTITLE: Implementing a ClusterClient Event Listener in C#\nDESCRIPTION: Implementation of an actor that subscribes to and receives notifications about available contact points from the ClusterClient. Shows how to handle the initial state and subsequent updates.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-client.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/core/Akka.Docs.Tests/Networking/ClusterClient/ClientListener.cs?name=ClusterClient)]\n```\n\n----------------------------------------\n\nTITLE: Configuring Actor Deployment with Custom Dispatcher\nDESCRIPTION: Shows how to assign a custom dispatcher to an actor using HOCON deployment configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/dispatchers.md#2025-04-16_snippet_1\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.deployment {\n    /my-actor {\n        dispatcher = my-dispatcher\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Protecting Asynchronous and Synchronous Calls with Circuit Breaker in Akka.NET\nDESCRIPTION: Shows how to use the CircuitBreaker to protect both asynchronous and synchronous method calls, including error handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/circuit-breaker.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// Asynchronous\npublic async Task<string> CallAsynchronousService(string message)\n{\n    return await breaker.CallAsync(() => ExtensionMethod.AsTask(\n        externalService.Tell, message, TimeSpan.FromSeconds(5)));\n}\n\n// Synchronous\npublic string CallSynchronousService(string message)\n{\n    return breaker.Call(() => {\n        var task = ExtensionMethod.AsTask(\n            externalService.Tell, message, TimeSpan.FromSeconds(5));\n        task.Wait();\n        return task.Result;\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: ClusterSharding Class Implementation in Akka.NET\nDESCRIPTION: Implementation of the ClusterSharding extension class that manages entity distribution across a cluster. It provides methods to start sharding regions, proxies, and access settings for entity management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Core.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterSharding : Akka.Actor.IExtension\n{\n    public ClusterSharding(Akka.Actor.ExtendedActorSystem system) { }\n    public Akka.Cluster.Sharding.ClusterShardingSettings Settings { get; }\n    public System.Collections.Immutable.ImmutableHashSet<string> ShardTypeNames { get; }\n    public static Akka.Configuration.Config DefaultConfig() { }\n    public Akka.Cluster.Sharding.IShardAllocationStrategy DefaultShardAllocationStrategy(Akka.Cluster.Sharding.ClusterShardingSettings settings) { }\n    public static Akka.Cluster.Sharding.ClusterSharding Get(Akka.Actor.ActorSystem system) { }\n    public Akka.Actor.IActorRef ShardRegion(string typeName) { }\n    public Akka.Actor.IActorRef ShardRegionProxy(string typeName) { }\n    public Akka.Actor.IActorRef Start(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n    public Akka.Actor.IActorRef Start(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n    public Akka.Actor.IActorRef Start(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n    public Akka.Actor.IActorRef Start(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n    public Akka.Actor.IActorRef Start(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n    public Akka.Actor.IActorRef Start(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n    public Akka.Actor.IActorRef Start(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n    public Akka.Actor.IActorRef Start(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n    public Akka.Actor.IActorRef StartProxy(string typeName, string role, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n    public Akka.Actor.IActorRef StartProxy(string typeName, string role, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartProxyAsync(string typeName, string role, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartProxyAsync(string typeName, string role, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Akka.Remote Configuration\nDESCRIPTION: HOCON configuration example showing the minimal setup required to enable Akka.Remote. It sets the actor provider to 'remote' and configures the TCP transport to listen on localhost port 8080.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/remoting/index.md#2025-04-16_snippet_1\n\nLANGUAGE: xml\nCODE:\n```\nakka {\n    actor {\n        provider = remote\n    }\n\n    remote {\n        dot-netty.tcp {\n            port = 8080\n            hostname = localhost\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Group Router from HOCON Configuration in C#\nDESCRIPTION: Demonstrates how to create a group router from HOCON configuration. Note the use of Props.Empty since the routees are pre-existing actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar props = Props.Create<Worker>().WithRouter(FromConfig.Instance);\nvar actor = system.ActorOf(props, \"workers\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Side-Channels in a Custom GraphStage Flow (C#)\nDESCRIPTION: This snippet demonstrates how to implement asynchronous side-channels in a custom GraphStage flow. The KillSwitch stage starts dropping elements when a given Task completes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/custom-stream-processing.md#2025-04-16_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nclass KillSwitch<T> : GraphStage<FlowShape<T, T>>\n{\n    private sealed class Logic : GraphStageLogic\n    {\n        private readonly KillSwitch<T> _killSwitch;\n\n        public Logic(KillSwitch<T> killSwitch) : base(killSwitch.Shape)\n        {\n            _killSwitch = killSwitch;\n\n            SetHandler(killSwitch.In, onPush: () => Push(killSwitch.Out, Grab(killSwitch.In)));\n            SetHandler(killSwitch.Out, onPull: () => Pull(killSwitch.In));\n        }\n\n        public override void PreStart()\n        {\n            var callback = GetAsyncCallback(CompleteStage);\n            _killSwitch._killSwitch.ContinueWith(_ => callback());\n        }\n    }\n\n    private readonly Task _killSwitch;\n\n    public KillSwitch(Task killSwitch)\n    {\n        _killSwitch = killSwitch;\n        Shape = new FlowShape<T, T>(In, Out);\n    }\n\n    public Inlet<T> In { get; } = new Inlet<T>(\"KillSwitch.in\");\n\n    public Outlet<T> Out { get; } = new Outlet<T>(\"KillSwitch.out\");\n\n    public override FlowShape<T, T> Shape { get; }\n\n    protected override GraphStageLogic CreateLogic(Attributes inheritedAttributes) => new Logic(this);\n}\n```\n\n----------------------------------------\n\nTITLE: UntypedPersistentActor Base Class Implementation in C#\nDESCRIPTION: Abstract base class for untyped persistent actors with methods for command and recovery message handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class UntypedPersistentActor : Akka.Persistence.Eventsourced\n{\n    protected UntypedPersistentActor() { }\n    protected static Akka.Actor.IUntypedActorContext Context { get; }\n    protected void Become(Akka.Actor.UntypedReceive receive) { }\n    protected void BecomeStacked(Akka.Actor.UntypedReceive receive) { }\n    protected abstract void OnCommand(object message);\n    protected abstract void OnRecover(object message);\n    protected override bool Receive(object message) { }\n    protected virtual bool ReceiveCommand(object message) { }\n    protected virtual bool ReceiveRecover(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Ask Pattern for Actor Communication in C#\nDESCRIPTION: This static class provides extension methods for implementing the Ask pattern in Akka.NET, allowing actors to send messages and receive responses asynchronously using Tasks.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic class static Futures\n{\n    public static System.Threading.Tasks.Task<object> Ask(this Akka.Actor.ICanTell self, object message, System.Nullable<System.TimeSpan> timeout = null) { }\n    public static System.Threading.Tasks.Task<object> Ask(this Akka.Actor.ICanTell self, object message, System.Threading.CancellationToken cancellationToken) { }\n    public static System.Threading.Tasks.Task<object> Ask(this Akka.Actor.ICanTell self, object message, System.Nullable<System.TimeSpan> timeout, System.Threading.CancellationToken cancellationToken) { }\n    public static System.Threading.Tasks.Task<T> Ask<T>(this Akka.Actor.ICanTell self, object message, System.Nullable<System.TimeSpan> timeout = null) { }\n    public static System.Threading.Tasks.Task<T> Ask<T>(this Akka.Actor.ICanTell self, object message, System.Threading.CancellationToken cancellationToken) { }\n    public static System.Threading.Tasks.Task<T> Ask<T>(this Akka.Actor.ICanTell self, object message, System.Nullable<System.TimeSpan> timeout, System.Threading.CancellationToken cancellationToken) { }\n    public static System.Threading.Tasks.Task<T> Ask<T>(this Akka.Actor.ICanTell self, System.Func<Akka.Actor.IActorRef, object> messageFactory, System.Nullable<System.TimeSpan> timeout, System.Threading.CancellationToken cancellationToken) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing High-Throughput Persistent Actor with PersistAsync in Akka.NET\nDESCRIPTION: Demonstrates the use of PersistAsync for implementing a high-throughput persistent actor. This approach allows processing commands quickly while persisting events asynchronously.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/event-sourcing.md#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/core/Akka.Docs.Tests/Persistence/PersistentActor/PersistAsync.cs?name=PersistAsync)]\n```\n\n----------------------------------------\n\nTITLE: Implementing Ask Pattern with Task Aggregation\nDESCRIPTION: Shows how to use Ask pattern for request-response messaging, combined with Task.WhenAll for parallel processing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nvar tasks = new List<Task>();\ntasks.Add(actorA.Ask(\"request\", TimeSpan.FromSeconds(1)));\ntasks.Add(actorB.Ask(\"another request\", TimeSpan.FromSeconds(5)));\n\nTask.WhenAll(tasks).PipeTo(actorC, Self);\n```\n\n----------------------------------------\n\nTITLE: Recommended Actor Factory Pattern\nDESCRIPTION: Demonstrates the recommended practice of providing static factory methods for actor creation with Props configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DemoActor : ReceiveActor\n{\n    private readonly int _magicNumber;\n\n    public DemoActor(int magicNumber)\n    {\n        _magicNumber = magicNumber;\n        Receive<int>(x =>\n        {\n            Sender.Tell(x + _magicNumber);\n        });\n    }\n\n    public static Props Props(int magicNumber)\n    {\n        return Akka.Actor.Props.Create(() => new DemoActor(magicNumber));\n    }\n}\n\nsystem.ActorOf(DemoActor.Props(42), \"demo\");\n```\n\n----------------------------------------\n\nTITLE: Using SelectAsyncUnordered for Efficient Stream Processing with External Services in C#\nDESCRIPTION: This snippet shows how to use SelectAsyncUnordered for more efficient processing when order is not important. It demonstrates looking up email addresses and sending emails using external services.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar authors = tweets\n    .Where(t => t.HashTags.Contains(\"Akka.Net\"))\n    .Select(t => t.Author);\n    \nvar emailAddresses = authors\n    .SelectAsyncUnordered(4, author => AddressSystem.LookUpEmail(author.Handle))\n    .Collect(s => string.IsNullOrWhiteSpace(s) ? null : s);\n    \nvar sendEmails = emailAddresses.SelectAsyncUnordered(4, address =>\n    EmailServer.Send(\n        new Email(to: address, title: \"Akka.Net\", body: \"I like your tweet\"))\n    )\n    .To(Sink.Ignore<int>());\n\nsendEmails.Run(materializer);\n```\n\n----------------------------------------\n\nTITLE: Handling Back-Pressure with Buffer in Akka.NET Streams\nDESCRIPTION: Demonstrates how to handle back-pressure using a Buffer element with a specific overflow strategy. This example keeps only the 10 most recent tweets when processing is slow.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/reactivetweets.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\ntweetSource\n    .Buffer(10, OverflowStrategy.DropHead)\n    .Select(SlowComputation)\n    .RunWith(Sink.Ignore<ComputationResult>(), mat);\n```\n\n----------------------------------------\n\nTITLE: Defining ShardedDaemonProcess Class in Akka.NET Sharding\nDESCRIPTION: This class is an Akka.NET extension that manages a set of child actors across a cluster.  It is used to ensure that a specific number of actors are running, even if nodes fail. The `Init` methods create and start the sharded daemon processes, and the `InitProxy` creates a proxy for accessing the processes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\n    [Akka.Annotations.ApiMayChangeAttribute()]\n    [Akka.Annotations.DoNotInheritAttribute()]\n    [System.Runtime.CompilerServices.NullableAttribute(0)]\n    public class ShardedDaemonProcess : Akka.Actor.IExtension\n    {\n        public ShardedDaemonProcess(Akka.Actor.ExtendedActorSystem system) { }\n        public static Akka.Cluster.Sharding.ShardedDaemonProcess Get(Akka.Actor.ActorSystem system) { }\n        [return: System.Runtime.CompilerServices.NullableAttribute(2)]\n        public Akka.Actor.IActorRef Init(string name, int numberOfInstances, System.Func<int, Akka.Actor.Props> propsFactory) { }\n        [return: System.Runtime.CompilerServices.NullableAttribute(2)]\n        public Akka.Actor.IActorRef Init(string name, int numberOfInstances, System.Func<int, Akka.Actor.Props> propsFactory, [System.Runtime.CompilerServices.NullableAttribute(2)] object stopMessage) { }\n        [return: System.Runtime.CompilerServices.NullableAttribute(2)]\n        public Akka.Actor.IActorRef Init(string name, int numberOfInstances, System.Func<int, Akka.Actor.Props> propsFactory, Akka.Cluster.Sharding.ShardedDaemonProcessSettings settings, [System.Runtime.CompilerServices.NullableAttribute(2)] object stopMessage) { }\n        public Akka.Actor.IActorRef InitProxy(string name, int numberOfInstances, string role) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing a Supervisor with Custom PreRestart Behavior in C#\nDESCRIPTION: This snippet shows a Supervisor2 actor that overrides the PreRestart method to prevent child actors from being restarted when the supervisor itself restarts. It includes both the custom strategy and the PreRestart override.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/fault-tolerance.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Supervisor2 : UntypedActor\n{\n    protected override SupervisorStrategy SupervisorStrategy()\n    {\n        return new OneForOneStrategy(\n            maxNrOfRetries: 10,\n            withinTimeRange: TimeSpan.FromMinutes(1),\n            localOnlyDecider: ex =>\n            {\n                switch (ex)\n                {\n                    case ArithmeticException ae:\n                        return Directive.Resume;\n                    case NullReferenceException nre:\n                        return Directive.Restart;\n                    case ArgumentException are:\n                        return Directive.Stop;\n                    default:\n                        return Directive.Escalate;\n                }\n            });\n    }\n\n    protected override void PreRestart(Exception reason, object message)\n    {\n    }\n\n    protected override void OnReceive(object message)\n    {\n        if (message is Props p)\n        {\n            var child = Context.ActorOf(p); // create child\n            Sender.Tell(child); // send back reference to child actor\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Azure Worker Role with Akka.NET Actor System\nDESCRIPTION: Complete implementation of a Worker Role class that initializes and manages an Akka.NET actor system. The code handles actor system lifecycle including startup, shutdown, and async message processing. It demonstrates proper cancellation token usage and async/await patterns.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/deployment/azure-cloud-service.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Actor;\n\nnamespace MyActorWorkerRole\n{\n    public class WorkerRole : RoleEntryPoint\n    {\n        private readonly CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();\n        private readonly ManualResetEvent runCompleteEvent = new ManualResetEvent(false);\n\n        private ActorSystem _actorSystem;\n\n        public override bool OnStart()\n        {\n            // Setup the Actor System\n            _actorSystem = ActorSystem.Create(\"MySystem\");\n\n            return (base.OnStart());\n        }\n\n        public override void OnStop()\n        {\n            this.cancellationTokenSource.Cancel();\n            this.runCompleteEvent.WaitOne();\n\n            // Shutdown the Actor System\n            _actorSystem.Shutdown();\n\n            base.OnStop();\n        }\n\n        public override void Run()\n        {\n            try\n            {\n                this.RunAsync(this.cancellationTokenSource.Token).Wait();\n            }\n            finally\n            {\n                this.runCompleteEvent.Set();\n            }\n        }\n\n        private async Task RunAsync(CancellationToken cancellationToken)\n        {\n            // Create an instance to the top-level user Actor\n            var workerRoleActor = _actorSystem.ActorOf<WorkerRoleActor>(\"WorkerRole\");\n\n            // Send a message to the Actor\n            workerRoleActor.Tell(new WorkerRoleMessage(\"Hello World!\"));\n\n            while (!cancellationToken.IsCancellationRequested)\n            {\n                await Task.Delay(1000, cancellationToken);\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Stream Materialization in C#\nDESCRIPTION: Shows how to create and materialize a simple stream by connecting a Source to a Sink. The example demonstrates aggregating numbers 1-10 using ToMaterialized() and Keep.Right to preserve the Sink's materialized value.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/basics.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar source = Source.From(Enumerable.Range(1, 10));\nvar sink = Sink.Aggregate<int, int>(0, (agg, i) => agg + i);\n  \n// connect the Source to the Sink, obtaining a RunnableGraph\nvar runnable = source.ToMaterialized(sink, Keep.Right);\n\n// materialize the flow and get the value of the AggregateSink\nTask<int> sum = runnable.Run(materializer);\n```\n\n----------------------------------------\n\nTITLE: Querying Events by Persistence ID in Akka.NET\nDESCRIPTION: This snippet demonstrates how to retrieve events for a specific PersistentActor identified by its PersistenceId. It shows obtaining the read journal, creating a source of events, and selecting the Event property from each EventEnvelope.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistence-query.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar queries = PersistenceQuery.Get(actorSystem)\n    .ReadJournalFor<SqlReadJournal>(\"akka.persistence.query.my-read-journal\");\n\nvar mat = ActorMaterializer.Create(actorSystem);\nvar src = queries.EventsByPersistenceId(\"some-persistence-id\", 0L, long.MaxValue);\nSource<object, NotUsed> events = src.Select(c => c.Event);\n```\n\n----------------------------------------\n\nTITLE: ClusterSharding Class Definition in C#\nDESCRIPTION: Implements the Akka.NET ClusterSharding extension that manages entity actors distributed across a cluster. It provides methods for starting shard regions, proxies, and accessing existing shard regions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterSharding : Akka.Actor.IExtension\n{\n    public ClusterSharding(Akka.Actor.ExtendedActorSystem system) { }\n    public Akka.Cluster.Sharding.ClusterShardingSettings Settings { get; }\n    public System.Collections.Immutable.ImmutableHashSet<string> ShardTypeNames { get; }\n    public static Akka.Configuration.Config DefaultConfig() { }\n    public Akka.Cluster.Sharding.IShardAllocationStrategy DefaultShardAllocationStrategy(Akka.Cluster.Sharding.ClusterShardingSettings settings) { }\n    public static Akka.Cluster.Sharding.ClusterSharding Get(Akka.Actor.ActorSystem system) { }\n    public Akka.Actor.IActorRef ShardRegion(string typeName) { }\n    public Akka.Actor.IActorRef ShardRegionProxy(string typeName) { }\n    public Akka.Actor.IActorRef Start(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n    public Akka.Actor.IActorRef Start(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n    public Akka.Actor.IActorRef Start(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n    public Akka.Actor.IActorRef Start(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n    public Akka.Actor.IActorRef Start(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n    public Akka.Actor.IActorRef Start(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n    public Akka.Actor.IActorRef Start(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n    public Akka.Actor.IActorRef Start(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n    public Akka.Actor.IActorRef StartProxy(string typeName, string role, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n    public Akka.Actor.IActorRef StartProxy(string typeName, string role, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartProxyAsync(string typeName, string role, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartProxyAsync(string typeName, string role, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Confirmable Messages with ShardingProducerController in C#\nDESCRIPTION: Demonstrates how to use the AskNextTo method of ShardingProducerController to confirm that outbound messages have been successfully persisted. This is useful when the Producer needs to ensure message persistence before proceeding.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-sharding-delivery.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nprivate async Task<long> ProduceMessages(IActorRef<ShardingProducerController.Message<MessageEnvelope>> producerController)\n{\n    var done = new TaskCompletionSource<long>();\n    producerController.Tell(new ShardingProducerController.RequestNext<MessageEnvelope>(\n        1,\n        (id, confirmed) =>\n        {\n            confirmed.Tell(new MessageEnvelope(id, new ShoppingCart.AddItem(\"foo\", 42)));\n            return true;\n        },\n        askNextTo: Context.System.DeadLetters,\n        onDemandSent: done.SetResult));\n    return await done.Task;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Publish-Subscribe Channel in Akka.NET Streams\nDESCRIPTION: Example of combining MergeHub and BroadcastHub to create a publish-subscribe channel. This allows for dynamic publishing and subscribing to a stream of elements.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/stream-dynamic.md#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n[!code-csharp[HubsDocTests.cs](../../../src/core/Akka.Docs.Tests/Streams/HubsDocTests.cs?name=pub-sub-1)]\n```\n\n----------------------------------------\n\nTITLE: Implementing Config Class for Akka.NET Configuration in C#\nDESCRIPTION: This class handles configuration for Akka.NET, providing methods to retrieve various types of configuration values and manage fallback configurations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_64\n\nLANGUAGE: C#\nCODE:\n```\npublic class Config\n{\n    public static readonly Akka.Configuration.Config Empty;\n    public Config() { }\n    public Config(Akka.Configuration.Hocon.HoconRoot root) { }\n    public Config(Akka.Configuration.Config source, Akka.Configuration.Config fallback) { }\n    public Akka.Configuration.Config Fallback { get; }\n    public virtual bool IsEmpty { get; }\n    public Akka.Configuration.Hocon.HoconValue Root { get; }\n    public System.Collections.Generic.IEnumerable<Akka.Configuration.Hocon.HoconSubstitution> Substitutions { get; set; }\n    public virtual System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Akka.Configuration.Hocon.HoconValue>> AsEnumerable() { }\n    protected Akka.Configuration.Config Copy(Akka.Configuration.Config fallback = null) { }\n    public virtual bool GetBoolean(string path, bool default = False) { }\n    public virtual System.Collections.Generic.IList<bool> GetBooleanList(string path) { }\n    public virtual System.Collections.Generic.IList<byte> GetByteList(string path) { }\n    public virtual System.Nullable<long> GetByteSize(string path) { }\n    public virtual System.Nullable<long> GetByteSize(string path, System.Nullable<long> def = null) { }\n    public virtual Akka.Configuration.Config GetConfig(string path) { }\n    public virtual decimal GetDecimal(string path, [System.Runtime.CompilerServices.DecimalConstantAttribute(0, 0, 0u, 0u, 0u)] decimal @default) { }\n    public virtual System.Collections.Generic.IList<decimal> GetDecimalList(string path) { }\n    public virtual double GetDouble(string path, double default = 0) { }\n    public virtual System.Collections.Generic.IList<double> GetDoubleList(string path) { }\n    public virtual float GetFloat(string path, float default = 0) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Flow from a Processor Factory in C#\nDESCRIPTION: Shows how to re-wrap IProcessor instances as an Akka Streams Flow using a factory function to create new processor instances, enabling reusability.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\nFunc<IMaterializer, IProcessor<int, int>> createProcessor = \n    mat => Flow.Create<int>().ToProcessor().Run(mat);\n\nvar flow = Flow.FromProcessor(()=> createProcessor(materializer));\n```\n\n----------------------------------------\n\nTITLE: Installing Akka.NET Hosting Package via PowerShell\nDESCRIPTION: This command installs the Akka.Hosting NuGet package using the Package Manager Console in Visual Studio. Akka.Hosting includes the base Akka package and provides integration with Microsoft.Extensions ecosystem components.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/README.md#2025-04-16_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\nPM> Install-Package Akka.Hosting\n```\n\n----------------------------------------\n\nTITLE: Actor System Abstract Base Class\nDESCRIPTION: Abstract base class for actor systems providing core functionality like actor creation, extension management, and lifecycle control\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ActorSystem : Akka.Actor.IActorRefFactory, System.IDisposable { \n    public abstract Akka.Actor.IActorRef ActorOf(Akka.Actor.Props props, string name = null); \n    public abstract Akka.Actor.ActorSelection ActorSelection(Akka.Actor.ActorPath actorPath); \n    public static Akka.Actor.ActorSystem Create(string name, Akka.Configuration.Config config) { } \n}\n```\n\n----------------------------------------\n\nTITLE: Creating IoT Supervisor Actor in C#\nDESCRIPTION: Implementation of a top-level supervisor actor for an IoT system using Akka.NET logging adapter and recommended Props pattern.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-1.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../../src/core/Akka.Docs.Tutorials/Tutorial1/IotSupervisor.cs?name=iot-supervisor)]\n```\n\n----------------------------------------\n\nTITLE: Creating Reusable Partial Graph Component in C#\nDESCRIPTION: This snippet demonstrates how to create a reusable partial graph component using GraphDSL.Create(). It returns a FlowShape, allowing the component to be used in both complex graph constructions and simpler linear DSLs.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/modularitycomposition.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar partial = GraphDsl.Create(builder =>\n{\n    var b = builder.Add(new Broadcast<int>(2));\n    var c = builder.Add(new Merge<int>(2));\n    var e = builder.Add(new Balance<int>(2));\n    var f = builder.Add(new Merge<int>(2));\n\n    builder.To(c).From(f);\n    builder.From(b).Via(c).To(f);\n    builder.From(b).Via(Flow.Create<int>().Select(x => x + 1)).Via(e).To(f);\n    \n    return new FlowShape<int, int>(b.In, e.Out(1));\n}).Named(\"partial\");\n```\n\n----------------------------------------\n\nTITLE: Message Queue Interface Definition\nDESCRIPTION: Interface defining core functionality for message queues in Akka.NET, including methods for enqueueing and dequeueing messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_91\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IMessageQueue\n{\n    int Count { get; }\n    bool HasMessages { get; }\n    void CleanUp(Akka.Actor.IActorRef owner, Akka.Dispatch.MessageQueues.IMessageQueue deadletters);\n    void Enqueue(Akka.Actor.IActorRef receiver, Akka.Actor.Envelope envelope);\n    bool TryDequeue(out Akka.Actor.Envelope envelope);\n}\n```\n\n----------------------------------------\n\nTITLE: Actor Model Explanation in Akka.NET\nDESCRIPTION: This snippet provides an explanation of the Actor Model within Akka.NET, focusing on its advantages for concurrent and distributed systems.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/index.md#2025-04-16_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<h2><strong>Actor</strong> Model</h2>\n<p class=\"lead\">\nThe Actor Model provides a higher level of abstraction for writing concurrent and distributed systems. It alleviates the developer from having to deal with explicit locking and thread management, making it easier to write correct concurrent and parallel systems. </p>\n<p>Actors were defined in the 1973 paper by <a href=\"http://en.wikipedia.org/wiki/Carl_Hewitt\">Carl Hewitt</a> but have been popularized by the Erlang language, and used for example at Ericsson with great success to build highly concurrent and reliable telecom systems.</p>\n<p><a href=\"/articles/intro/what-problems-does-actor-model-solve.html\">Read more</a></p>\n```\n\n----------------------------------------\n\nTITLE: Defining the ClusterEvent class\nDESCRIPTION: This code defines the `ClusterEvent` class, which contains nested classes and interfaces representing different types of cluster events, such as `ClusterShuttingDown`, `CurrentClusterState`, `LeaderChanged`, `MemberJoined`, `MemberLeft`, `MemberUp`, `MemberDowned`, and `MemberRemoved`. These events are used to track changes in the cluster membership and state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Core.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n public class ClusterEvent\n    {\n        public static readonly Akka.Cluster.ClusterEvent.SubscriptionInitialStateMode InitialStateAsEvents;\n        public static readonly Akka.Cluster.ClusterEvent.SubscriptionInitialStateMode InitialStateAsSnapshot;\n        public ClusterEvent() { }\n        public sealed class ClusterShuttingDown : Akka.Cluster.ClusterEvent.IClusterDomainEvent, Akka.Event.IDeadLetterSuppression\n        {\n            public static readonly Akka.Cluster.ClusterEvent.IClusterDomainEvent Instance;\n            public override string ToString() { }\n        }\n        public sealed class CurrentClusterState : Akka.Actor.INoSerializationVerificationNeeded\n        {\n            public CurrentClusterState() { }\n            public CurrentClusterState(System.Collections.Immutable.ImmutableSortedSet<Akka.Cluster.Member> members, System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.Member> unreachable, System.Collections.Immutable.ImmutableHashSet<Akka.Actor.Address> seenBy, Akka.Actor.Address leader, System.Collections.Immutable.ImmutableDictionary<string, Akka.Actor.Address> roleLeaderMap) { }\n            public System.Collections.Immutable.ImmutableHashSet<string> AllRoles { get; }\n            public bool HasMoreThanOneAppVersion { get; }\n            public Akka.Actor.Address Leader { get; }\n            public System.Collections.Immutable.ImmutableSortedSet<Akka.Cluster.Member> Members { get; }\n            public System.Collections.Immutable.ImmutableHashSet<Akka.Actor.Address> SeenBy { get; }\n            public System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.Member> Unreachable { get; }\n            public Akka.Cluster.ClusterEvent.CurrentClusterState Copy(System.Collections.Immutable.ImmutableSortedSet<Akka.Cluster.Member> members = null, System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.Member> unreachable = null, System.Collections.Immutable.ImmutableHashSet<Akka.Actor.Address> seenBy = null, Akka.Actor.Address leader = null, System.Collections.Immutable.ImmutableDictionary<string, Akka.Actor.Address> roleLeaderMap = null) { }\n            public Akka.Actor.Address RoleLeader(string role) { }\n        }\n        public interface IClusterDomainEvent : Akka.Event.IDeadLetterSuppression { }\n        public interface IMemberEvent : Akka.Cluster.ClusterEvent.IClusterDomainEvent, Akka.Event.IDeadLetterSuppression\n        {\n            Akka.Cluster.Member Member { get; }\n        }\n        public interface IReachabilityEvent : Akka.Cluster.ClusterEvent.IClusterDomainEvent, Akka.Event.IDeadLetterSuppression { }\n        public sealed class LeaderChanged : Akka.Cluster.ClusterEvent.IClusterDomainEvent, Akka.Event.IDeadLetterSuppression\n        {\n            public LeaderChanged(Akka.Actor.Address leader) { }\n            public Akka.Actor.Address Leader { get; }\n            public override bool Equals(object obj) { }\n            public override int GetHashCode() { }\n            public override string ToString() { }\n        }\n        public sealed class MemberDowned : Akka.Cluster.ClusterEvent.MemberStatusChange\n        {\n            public MemberDowned(Akka.Cluster.Member member) { }\n        }\n        public sealed class MemberExited : Akka.Cluster.ClusterEvent.MemberStatusChange\n        {\n            public MemberExited(Akka.Cluster.Member member) { }\n        }\n        public sealed class MemberJoined : Akka.Cluster.ClusterEvent.MemberStatusChange\n        {\n            public MemberJoined(Akka.Cluster.Member member) { }\n        }\n        public sealed class MemberLeft : Akka.Cluster.ClusterEvent.MemberStatusChange\n        {\n            public MemberLeft(Akka.Cluster.Member member) { }\n        }\n        public sealed class MemberRemoved : Akka.Cluster.ClusterEvent.MemberStatusChange\n        {\n            public MemberRemoved(Akka.Cluster.Member member, Akka.Cluster.MemberStatus previousStatus) { }\n            public Akka.Cluster.MemberStatus PreviousStatus { get; }\n            public override bool Equals(object obj) { }\n            public override int GetHashCode() { }\n        }\n        public abstract class MemberStatusChange : Akka.Cluster.ClusterEvent.IClusterDomainEvent, Akka.Cluster.ClusterEvent.IMemberEvent, Akka.Event.IDeadLetterSuppression\n        {\n            protected readonly Akka.Cluster.Member _member;\n            protected MemberStatusChange(Akka.Cluster.Member member, Akka.Cluster.MemberStatus validStatus) { }\n            public Akka.Cluster.Member Member { get; }\n            public override bool Equals(object obj) { }\n            public override int GetHashCode() { }\n            public override string ToString() { }\n        }\n        public sealed class MemberUp : Akka.Cluster.ClusterEvent.MemberStatusChange\n        {\n```\n\n----------------------------------------\n\nTITLE: Custom Materialized Value Combination in Akka.NET RunnableGraph\nDESCRIPTION: This snippet demonstrates using a custom combiner function to transform materialized values from a source and sink into a new type (MyClass). It shows how to create a runnable graph with a custom materialized value type.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/modularitycomposition.md#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class MyClass\n{\n    private readonly TaskCompletionSource<int> _completion;\n    private readonly Tcp.OutgoingConnection _connection;\n\n    public MyClass(TaskCompletionSource<int> completion, Tcp.OutgoingConnection connection)\n    {\n        _completion = completion;\n        _connection = connection;\n    }\n\n    public void Close() => _completion.SetResult(1);\n}\n\n// Materializes to Task<MyClass>        (purple)\nvar runnableGraph = nestedSource.ToMaterialized(nestedSink, (completion, rest) =>\n{\n    var connectionTask = rest.Item1;\n    return connectionTask.ContinueWith(task => new MyClass(completion, task.Result));\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing VersionVector in Akka.NET Distributed Data\nDESCRIPTION: This abstract class represents a version vector for distributed data in Akka.NET. It provides methods for comparing, incrementing, merging, and pruning version vectors, as well as checking relationships between different version vectors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_45\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class VersionVector : Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IRemovedNodePruning<Akka.DistributedData.VersionVector>, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.VersionVector>, System.IEquatable<Akka.DistributedData.VersionVector>\n{\n    protected static readonly Akka.Util.Internal.AtomicCounterLong Counter;\n    public static readonly Akka.DistributedData.VersionVector Empty;\n    protected VersionVector() { }\n    public abstract int Count { get; }\n    public abstract bool IsEmpty { get; }\n    public abstract System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.UniqueAddress> ModifiedByNodes { get; }\n    public abstract System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<Akka.Cluster.UniqueAddress, long>> VersionEnumerator { get; }\n    public Akka.DistributedData.VersionVector.Ordering Compare(Akka.DistributedData.VersionVector other) { }\n    public abstract bool Contains(Akka.Cluster.UniqueAddress node);\n    public static Akka.DistributedData.VersionVector Create(Akka.Cluster.UniqueAddress node, long version) { }\n    public static Akka.DistributedData.VersionVector Create(System.Collections.Immutable.ImmutableDictionary<Akka.Cluster.UniqueAddress, long> versions) { }\n    public bool Equals(Akka.DistributedData.VersionVector other) { }\n    public override bool Equals(object obj) { }\n    public abstract Akka.DistributedData.VersionVector Increment(Akka.Cluster.UniqueAddress node);\n    public bool IsAfter(Akka.DistributedData.VersionVector y) { }\n    public bool IsBefore(Akka.DistributedData.VersionVector y) { }\n    public bool IsConcurrent(Akka.DistributedData.VersionVector y) { }\n    public bool IsSame(Akka.DistributedData.VersionVector y) { }\n    public abstract Akka.DistributedData.VersionVector Merge(Akka.DistributedData.VersionVector other);\n    public Akka.DistributedData.IReplicatedData Merge(Akka.DistributedData.IReplicatedData other) { }\n    public abstract bool NeedPruningFrom(Akka.Cluster.UniqueAddress removedNode);\n    public abstract Akka.DistributedData.VersionVector Prune(Akka.Cluster.UniqueAddress removedNode, Akka.Cluster.UniqueAddress collapseInto);\n    public abstract Akka.DistributedData.VersionVector PruningCleanup(Akka.Cluster.UniqueAddress removedNode);\n    public abstract long VersionAt(Akka.Cluster.UniqueAddress node);\n    public static bool ==(Akka.DistributedData.VersionVector x, Akka.DistributedData.VersionVector y) { }\n    public static bool >(Akka.DistributedData.VersionVector x, Akka.DistributedData.VersionVector y) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Serializers in Akka.NET HOCON\nDESCRIPTION: Configuration example showing how to register custom serializers for specific payload and snapshot types in Akka.NET. Demonstrates setting up serializer mappings in the akka.actor configuration section for MyPayload and MySnapshot types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/custom-serialization.md#2025-04-16_snippet_0\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor {\n  serializers {\n    my-payload = \"docs.persistence.MyPayloadSerializer\"\n    my-snapshot = \"docs.persistence.MySnapshotSerializer\"\n  }\n  serialization-bindings {\n    \"docs.persistence.MyPayload\" = my-payload\n    \"docs.persistence.MySnapshot\" = my-snapshot\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FSM Base Class in C# for Akka.NET\nDESCRIPTION: This abstract class provides the foundation for implementing Finite State Machines in Akka.NET. It includes methods for state transitions, timer management, and event handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class FSM<TState, TData> : Akka.Actor.FSMBase, Akka.Actor.Internal.IInternalSupportsTestFSMRef<TState, TData>, Akka.Routing.IListeners\n{\n    protected bool DebugEvent;\n    protected FSM() { }\n    public Akka.Routing.ListenerSupport Listeners { get; }\n    public TData NextStateData { get; }\n    public TData StateData { get; }\n    public TState StateName { get; }\n    public void CancelTimer(string name) { }\n    public Akka.Actor.FSMBase.State<TState, TData> GoTo(TState nextStateName) { }\n    [System.ObsoleteAttribute(\"This method is obsoleted. Use GoTo(nextStateName).Using(newStateData) [1.2.0]\")]\n    public Akka.Actor.FSMBase.State<TState, TData> GoTo(TState nextStateName, TData stateData) { }\n    public void Initialize() { }\n    public bool IsTimerActive(string name) { }\n    protected virtual void LogTermination(Akka.Actor.FSMBase.Reason reason) { }\n    public void OnTermination(System.Action<Akka.Actor.FSMBase.StopEvent<TState, TData>> terminationHandler) { }\n    public void OnTransition(Akka.Actor.FSM<TState, TData>.TransitionHandler transitionHandler) { }\n    protected override void PostStop() { }\n    protected override bool Receive(object message) { }\n    public void SetStateTimeout(TState state, System.Nullable<System.TimeSpan> timeout) { }\n    public void SetTimer(string name, object msg, System.TimeSpan timeout, bool repeat = False) { }\n    public void StartWith(TState stateName, TData stateData, System.Nullable<System.TimeSpan> timeout = null) { }\n    public Akka.Actor.FSMBase.State<TState, TData> Stay() { }\n    public Akka.Actor.FSMBase.State<TState, TData> Stop() { }\n    public Akka.Actor.FSMBase.State<TState, TData> Stop(Akka.Actor.FSMBase.Reason reason) { }\n    public Akka.Actor.FSMBase.State<TState, TData> Stop(Akka.Actor.FSMBase.Reason reason, TData stateData) { }\n    public Akka.Actor.FSM<TState, TData>.TransformHelper Transform(Akka.Actor.FSM<TState, TData>.StateFunction func) { }\n    public void When(TState stateName, Akka.Actor.FSM<TState, TData>.StateFunction func, System.Nullable<System.TimeSpan> timeout = null) { }\n    public void WhenUnhandled(Akka.Actor.FSM<TState, TData>.StateFunction stateFunction) { }\n    public delegate Akka.Actor.FSMBase.State<TState, TData> StateFunction<TState, TData>(Akka.Actor.FSMBase.Event<TData> fsmEvent);\n    public sealed class TransformHelper<TState, TData>\n    {\n        public TransformHelper(Akka.Actor.FSM<TState, TData>.StateFunction func) { }\n        public Akka.Actor.FSM<TState, TData>.StateFunction Func { get; }\n        public Akka.Actor.FSM<TState, TData>.StateFunction Using(System.Func<Akka.Actor.FSMBase.State<TState, TData>, Akka.Actor.FSMBase.State<TState, TData>> andThen) { }\n    }\n    public delegate void TransitionHandler<TState, TData>(TState initialState, TState nextState);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Actor System Scheduler in C#\nDESCRIPTION: HashedWheelTimerScheduler class that implements core scheduling functionality for the actor system. Handles both one-time and repeated task scheduling with support for cancellation and timing control.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class HashedWheelTimerScheduler : Akka.Actor.SchedulerBase, Akka.Actor.IDateTimeOffsetNowTimeProvider, Akka.Actor.ITimeProvider, System.IDisposable\n{\n    public HashedWheelTimerScheduler(Akka.Configuration.Config scheduler, Akka.Event.ILoggingAdapter log) { }\n    public override System.TimeSpan HighResMonotonicClock { get; }\n    public override System.TimeSpan MonotonicClock { get; }\n    protected override System.DateTimeOffset TimeNow { get; }\n    public void Dispose() { }\n    protected override void InternalScheduleOnce(System.TimeSpan delay, System.Action action, Akka.Actor.ICancelable cancelable) { }\n    protected override void InternalScheduleOnce(System.TimeSpan delay, Akka.Dispatch.IRunnable action, Akka.Actor.ICancelable cancelable) { }\n    protected override void InternalScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action, Akka.Actor.ICancelable cancelable) { }\n    protected override void InternalScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Dispatch.IRunnable action, Akka.Actor.ICancelable cancelable) { }\n    protected override void InternalScheduleTellOnce(System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable) { }\n    protected override void InternalScheduleTellRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing IServiceProvider from ActorSystem\nDESCRIPTION: This snippet demonstrates how to access the IServiceProvider from an ActorSystem using the ServiceProvider.For method.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/dependency-injection.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[ServiceProviderFor](../../../src/examples/AspNetCore/Samples.Akka.AspNetCore/Actors/AkkaService.cs?name=ServiceProviderFor)]\n```\n\n----------------------------------------\n\nTITLE: Triggering Flow with Zip Operation in Akka.NET Streams\nDESCRIPTION: This snippet demonstrates how to trigger the flow of elements programmatically using a `Zip` operation in Akka.NET Streams. It combines a stream of messages with a stream of triggers, emitting a message only when a trigger is received.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/cookbook.md#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nvar elements = Source.Empty<Message>();\nvar triggerSource = Source.Empty<Trigger>();\nvar sink = Sink.Ignore<Message>().MapMaterializedValue(_ => NotUsed.Instance);\n\nvar graph = RunnableGraph.FromGraph(GraphDsl.Create(b =>\n{\n    var zip = b.Add(new Zip<Message, Trigger>());\n\n    b.From(elements).To(zip.In0);\n    b.From(triggerSource).To(zip.In1);\n    b.From(zip.Out).Via(Flow.Create<Tuple<Message, Trigger>>().Select(t => t.Item1)).To(sink);\n\n    return ClosedShape.Instance;\n}));\n```\n\n----------------------------------------\n\nTITLE: Enhancing Publish-Subscribe Channel with KillSwitch in Akka.NET Streams\nDESCRIPTION: Example of wrapping the Sink and Source in a Flow, adding a KillSwitch, and implementing a backpressure timeout for the publish-subscribe channel.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/stream-dynamic.md#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n[!code-csharp[HubsDocTests.cs](../../../src/core/Akka.Docs.Tests/Streams/HubsDocTests.cs?name=pub-sub-3)]\n```\n\n----------------------------------------\n\nTITLE: Stream Immutability Example in C#\nDESCRIPTION: Illustrates the immutable nature of stream processing stages, showing how operations return new instances instead of modifying existing ones.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/basics.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar source = Source.From(Enumerable.Range(1, 10));\nsource.Select(_ => 0); // has no effect on source, since it's immutable\nsource.RunWith(Sink.Aggregate<int,int>(0, (agg, i) => agg + i), materializer); // 55\n  \nvar zeroes = source.Select(_ => 0); // returns new Source<Int>, with Select() appended\nzeroes.RunWith(Sink.Aggregate<int,int>(0, (agg, i) => agg + i), materializer); // 0\n```\n\n----------------------------------------\n\nTITLE: Actor Lifecycle Methods Implementation\nDESCRIPTION: Demonstrates the implementation of actor lifecycle hook methods including PreStart, PreRestart, PostRestart, and PostStop.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic override void PreStart()\n{\n}\n\nprotected override void PreRestart(Exception reason, object message)\n{\n    foreach (IActorRef each in Context.GetChildren())\n    {\n      Context.Unwatch(each);\n      Context.Stop(each);\n    }\n    PostStop();\n}\n\nprotected override void PostRestart(Exception reason)\n{\n    PreStart();\n}\n\nprotected override void PostStop()\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RoundRobinRoutingLogic Class in C#\nDESCRIPTION: Definition of the RoundRobinRoutingLogic class which implements a round-robin message routing strategy. It maintains state to track which routee should receive the next message, distributing messages in circular order among available routees.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_190\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class RoundRobinRoutingLogic : Akka.Routing.RoutingLogic\n{\n    public RoundRobinRoutingLogic() { }\n    public RoundRobinRoutingLogic(int next) { }\n    public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining State Handlers in Akka.NET FSM\nDESCRIPTION: This code shows how to define state handlers for different states in the FSM actor, handling various events and transitions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/finite-state-machine.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/core/Akka.Docs.Tests/Actors/FiniteStateMachine/ExampleFSMActor.cs?name=FSMHandlers)]\n```\n\n----------------------------------------\n\nTITLE: Implementing Random Element Drop with Conflate\nDESCRIPTION: This snippet demonstrates using `ConflateWithSeed` to implement random element dropping when a consumer cannot keep up with a producer.  It introduces a probability `p` for dropping elements, effectively sampling from the incoming stream. This flow shows one approach to dealing with backpressure when explicit backpressure signals aren't possible.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/buffersandworkingwithrate.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n var p = 0.01;\n  var sampleFlow = Flow.Create<double>()\n       .ConflateWithSeed(x => ImmutableList.Create(x), (agg, d) => {\n           if (ThreadLocalRandom.Current.NextDouble() < p)\n               agg.Add(d);\n           return agg;\n       }).Concat(identity);\n```\n\n----------------------------------------\n\nTITLE: Flattening Sequence Stream in C#\nDESCRIPTION: Demonstrates how to flatten a stream of sequences into a stream of individual elements using SelectMany.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/cookbook.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nSource<List<Message>,NotUsed > myData = someDataSource;\nSource<Message, NotUsed> flattened = myData.SelectMany(x => x);\n```\n\n----------------------------------------\n\nTITLE: Initializing Sharded Daemon Process for Tag Processing in C#\nDESCRIPTION: This snippet demonstrates how to set up a Sharded Daemon Process for tag processing. It initializes the process with a specified number of workers, each handling a subset of tagged events for updating projections.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-sharded-daemon-process.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar shardedDaemon = ShardedDaemonProcess.Get(system);\nshardedDaemon.Init<TaggedEvent>(\n    \"worker\",\n    numberOfWorkers,\n    id => Props.Create(() => new TagProcessingWorker(id)),\n    ShardedDaemonProcessSettings.Create(system),\n    new MessageExtractor());\n```\n\n----------------------------------------\n\nTITLE: Defining PersistenceExtension Class in Akka.NET\nDESCRIPTION: This code defines the `PersistenceExtension` class, which represents the Akka.NET persistence extension. It provides access to persistence settings, default stash overflow strategy, event adapters, and methods for retrieving journal and snapshot store actors. This extension enables access to various persistence-related functionalities within an Akka.NET actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\npublic class PersistenceExtension : Akka.Actor.IExtension\n{\n    public PersistenceExtension(Akka.Actor.ExtendedActorSystem system) { }\n    public Akka.Persistence.IStashOverflowStrategy DefaultInternalStashOverflowStrategy { get; }\n    public Akka.Persistence.PersistenceSettings Settings { get; }\n    public Akka.Persistence.Journal.EventAdapters AdaptersFor(string journalPluginId) { }\n    public Akka.Actor.IActorRef JournalFor(string journalPluginId) { }\n    public string PersistenceId(Akka.Actor.IActorRef actor) { }\n    public Akka.Actor.IActorRef SnapshotStoreFor(string snapshotPluginId) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Consumer Message Delivery and Acknowledgment in Akka.Delivery\nDESCRIPTION: Example showing how a Consumer actor receives messages from a ConsumerController and acknowledges them as processed. The Consumer implements the pattern of confirming delivery back to the DeliverTo reference.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/reliable-delivery.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nclass Consumer : ReceiveActor\n{\n    public Consumer()\n    {\n        Receive<ConsumerController.Delivery<string>>(delivery => {\n            var message = delivery.Message;\n            // process message\n            delivery.DeliverTo.Tell(ConsumerController.Confirmed.Instance);\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Lease Acquisition Process\nDESCRIPTION: Implementation of the lease acquisition process including callback handling for lease loss scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/lease.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nprivate async Task AcquireLease()\n{\n    try\n    {\n        var acquired = await _lease.Acquire(exception =>\n        {\n            Self.Tell(new LeaseLost());\n        });\n        Self.Tell(acquired ? new AcquireLeaseSuccess() : new AcquireLeaseFailed());\n    }\n    catch (Exception)\n    {\n        Self.Tell(new AcquireLeaseFailed());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Cluster Singleton in C#\nDESCRIPTION: Shows how to initialize a cluster singleton actor using the ClusterSingleton extension. Demonstrates creating and accessing a singleton proxy.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-singleton.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar singleton = ClusterSingleton.Get(system);\n// start if needed and provide a proxy to a named singleton\nvar proxy = singleton.Init(SingletonActor.Create(Counter.Props, \"GlobalCounter\"));\nproxy.Tell(Counter.Increment);\n```\n\n----------------------------------------\n\nTITLE: ClusterClient Class Definition with Message Types\nDESCRIPTION: The ClusterClient class acts as a gateway for external clients to communicate with an Akka cluster. It includes nested message classes (Send, SendToAll, Publish) that represent different communication patterns for interacting with cluster services.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterClient : Akka.Actor.ActorBase\n{\n    public ClusterClient(Akka.Cluster.Tools.Client.ClusterClientSettings settings) { }\n    protected override void PostStop() { }\n    public static Akka.Actor.Props Props(Akka.Cluster.Tools.Client.ClusterClientSettings settings) { }\n    protected override bool Receive(object message) { }\n    public sealed class Publish : Akka.Cluster.Tools.Client.IClusterClientProtocolMessage, System.IEquatable<Akka.Cluster.Tools.Client.ClusterClient.Publish>\n    {\n        public Publish(string topic, object message) { }\n        public object Message { get; }\n        public string Topic { get; }\n        public bool Equals(Akka.Cluster.Tools.Client.ClusterClient.Publish other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n    }\n    public sealed class Send : Akka.Cluster.Tools.Client.IClusterClientProtocolMessage, System.IEquatable<Akka.Cluster.Tools.Client.ClusterClient.Send>\n    {\n        public Send(string path, object message, bool localAffinity = False) { }\n        public bool LocalAffinity { get; }\n        public object Message { get; }\n        public string Path { get; }\n        public bool Equals(Akka.Cluster.Tools.Client.ClusterClient.Send other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n    }\n    public sealed class SendToAll : Akka.Cluster.Tools.Client.IClusterClientProtocolMessage, System.IEquatable<Akka.Cluster.Tools.Client.ClusterClient.SendToAll>\n    {\n        public SendToAll(string path, object message) { }\n        public object Message { get; }\n        public string Path { get; }\n        public bool Equals(Akka.Cluster.Tools.Client.ClusterClient.SendToAll other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom Stages in Stream Processing with C#\nDESCRIPTION: This snippet demonstrates how to use the custom-defined stages in a stream processing pipeline in Akka.NET, illustrating a complete data flow transformation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/custom-stream-processing.md#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nvar resultTask = Source.From(new [] {1,2,3,4,5})\n        .Via(new Filter<int>(n => n%2 ==0))\n        .Via(new Duplicator<int>())\n        .Via(new Map<int, int>(n=>n/2))\n        .RunAggregate(0, (sum, next) => sum + next, materializer);\n```\n\n----------------------------------------\n\nTITLE: Implementing Props for Actor Creation in C#\nDESCRIPTION: Defines the Props class, which is used for creating and configuring actors in Akka.NET. It includes various constructors and methods for setting actor properties such as dispatcher, mailbox, and router configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic class Props : Akka.Util.ISurrogated, System.IEquatable<Akka.Actor.Props>\n{\n    public static readonly Akka.Actor.Props None;\n    protected Props() { }\n    protected Props(Akka.Actor.Props copy) { }\n    public Props(System.Type type, object[] args) { }\n    public Props(System.Type type) { }\n    public Props(System.Type type, Akka.Actor.SupervisorStrategy supervisorStrategy, System.Collections.Generic.IEnumerable<object> args) { }\n    public Props(System.Type type, Akka.Actor.SupervisorStrategy supervisorStrategy, params object[] args) { }\n    public Props(Akka.Actor.Deploy deploy, System.Type type, System.Collections.Generic.IEnumerable<object> args) { }\n    public Props(Akka.Actor.Deploy deploy, System.Type type, params object[] args) { }\n    public object[] Arguments { get; }\n    public Akka.Actor.Deploy Deploy { get; set; }\n    [Newtonsoft.Json.JsonIgnoreAttribute()]\n    public string Dispatcher { get; }\n    public static Akka.Actor.Props Empty { get; }\n    [Newtonsoft.Json.JsonIgnoreAttribute()]\n    public string Mailbox { get; }\n    [Newtonsoft.Json.JsonIgnoreAttribute()]\n    public Akka.Routing.RouterConfig RouterConfig { get; }\n    public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }\n    [Newtonsoft.Json.JsonIgnoreAttribute()]\n    public System.Type Type { get; }\n    public string TypeName { get; }\n    protected virtual Akka.Actor.Props Copy() { }\n    public static Akka.Actor.Props Create<TActor>(System.Linq.Expressions.Expression<System.Func<TActor>> factory, Akka.Actor.SupervisorStrategy supervisorStrategy = null)\n        where TActor : Akka.Actor.ActorBase { }\n    public static Akka.Actor.Props Create<TActor>(params object[] args)\n        where TActor : Akka.Actor.ActorBase { }\n    public static Akka.Actor.Props Create<TActor>(Akka.Actor.SupervisorStrategy supervisorStrategy)\n        where TActor : Akka.Actor.ActorBase, new () { }\n    public static Akka.Actor.Props Create(System.Type type, params object[] args) { }\n    [System.ObsoleteAttribute(\"Do not use this method. Call CreateBy(IIndirectActorProducer, params object[] arg\" +\n        \"s) instead\")]\n    public static Akka.Actor.Props CreateBy<TProducer>(params object[] args)\n        where TProducer :  class, Akka.Actor.IIndirectActorProducer { }\n    public static Akka.Actor.Props CreateBy(Akka.Actor.IIndirectActorProducer producer, params object[] args) { }\n    public bool Equals(Akka.Actor.Props other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public virtual Akka.Actor.ActorBase NewActor() { }\n    public Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Actor.Props WithDeploy(Akka.Actor.Deploy deploy) { }\n    public Akka.Actor.Props WithDispatcher(string dispatcher) { }\n    public Akka.Actor.Props WithMailbox(string mailbox) { }\n    public Akka.Actor.Props WithRouter(Akka.Routing.RouterConfig routerConfig) { }\n    public Akka.Actor.Props WithStashCapacity(int stashCapacity) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Actor Integration in Akka.NET Streams\nDESCRIPTION: Integration patterns for combining Akka.NET actors with streams, including ActorRef, ActorRefWithAck, and ActorSubscriber implementations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/builtinstages.md#2025-04-16_snippet_6\n\n\n\n----------------------------------------\n\nTITLE: Configuring Akka.NET with IServiceProvider in AkkaService\nDESCRIPTION: This code shows how to set up an Akka.NET ActorSystem as an IHostedService and incorporate the IServiceProvider into it using ServiceProviderSetup.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/dependency-injection.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[AkkaServiceSetup](../../../src/examples/AspNetCore/Samples.Akka.AspNetCore/Actors/AkkaService.cs?name=AkkaServiceSetup)]\n```\n\n----------------------------------------\n\nTITLE: Reading Data from Akka.DistributedData Replicator\nDESCRIPTION: Demonstrates how to retrieve data from the distributed data store using a Replicator.Get request. It shows the use of read consistency and handling of the response.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/distributed-data.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.DistributedData;\nusing static Akka.DistributedData.Dsl;\n\nvar replicator = DistributedData.Get(system).Replicator;\nvar key = new ORSetKey<string>(\"keyA\");\nvar readConsistency = ReadLocal.Instance;\n\nvar response = await replicator.Ask<Replicator.IGetResponse>(Get(key, readConsistency));\nif (response.IsSuccessful) \n{\n    var data = response.Get(key);    \n}\n```\n\n----------------------------------------\n\nTITLE: Defining IMessageExtractor Interface in Akka.NET Sharding\nDESCRIPTION: This interface defines methods for extracting the entity ID, entity message, and shard ID from a message. It is used by the ShardRegion to route messages to the correct entity.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n    public interface IMessageExtractor\n    {\n        [return: System.Runtime.CompilerServices.NullableAttribute(2)]\n        string EntityId(object message);\n        [return: System.Runtime.CompilerServices.NullableAttribute(2)]\n        object EntityMessage(object message);\n        [System.ObsoleteAttribute(\"Use ShardId(EntityId, object) instead.\")]\n        [return: System.Runtime.CompilerServices.NullableAttribute(2)]\n        string ShardId(object message);\n        string ShardId(string entityId, [System.Runtime.CompilerServices.NullableAttribute(2)] object messageHint = null);\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Delayed Entity Shutdown in C#\nDESCRIPTION: Demonstrates how to intercept a custom stop message in a sharded entity actor to perform asynchronous operations before shutdown. This allows for graceful termination during shard re-balancing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-sharding.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Delayed Stop](../../../src/contrib/cluster/Akka.Cluster.Sharding.Tests.MultiNode/ClusterShardingGracefulShutdownOldestSpec.cs?name=DelayedStop)]\n```\n\n----------------------------------------\n\nTITLE: Implementing FSM Actor in Akka.NET\nDESCRIPTION: This code demonstrates the implementation of the Buncher FSM actor, including state definitions, initial state setup, and state transitions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/finite-state-machine.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/core/Akka.Docs.Tests/Actors/FiniteStateMachine/ExampleFSMActor.cs?name=FSMActorStart)]\n[!code-csharp[Main](../../../src/core/Akka.Docs.Tests/Actors/FiniteStateMachine/ExampleFSMActor.cs?name=FSMActorEnd)]\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested Persist Calls in Akka.NET Persistent Actors\nDESCRIPTION: Demonstrates how to use nested Persist calls within callback blocks, maintaining thread safety and stashing guarantees.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/event-sourcing.md#2025-04-16_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/core/Akka.Docs.Tests/Persistence/PersistentActor/NestedPersists.cs?name=NestedPersists1)]\n```\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/core/Akka.Docs.Tests/Persistence/PersistentActor/NestedPersists.cs?name=NestedPersists2)]\n```\n\n----------------------------------------\n\nTITLE: Actor System and Swapper Actor Interaction in Akka.NET\nDESCRIPTION: This code shows how to create an `ActorSystem`, instantiate the `Swapper` actor, and send it multiple `Swap` messages. It demonstrates the basic setup for running Akka.NET actors and interacting with them. The example also includes a `Console.ReadLine()` to keep the application running until a key is pressed.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_24\n\nLANGUAGE: csharp\nCODE:\n```\nstatic void Main(string[] args)\n{\n    var system = ActorSystem.Create(\"MySystem\");\n    var swapper = system.ActorOf<Swapper>();\n\n    swapper.Tell(Swapper.Swap.Instance);\n    swapper.Tell(Swapper.Swap.Instance);\n    swapper.Tell(Swapper.Swap.Instance);\n    swapper.Tell(Swapper.Swap.Instance);\n    swapper.Tell(Swapper.Swap.Instance);\n    swapper.Tell(Swapper.Swap.Instance);\n\n    Console.ReadLine();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dead Letter Handling in Akka.NET\nDESCRIPTION: Defines classes for handling undelivered messages (dead letters) in the actor system. The DeadLetterListener actor monitors and logs dead letters to provide visibility into message delivery failures.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_141\n\nLANGUAGE: C#\nCODE:\n```\npublic class DeadLetterListener : Akka.Actor.ActorBase\n{\n    public DeadLetterListener() { }\n    protected override void PostRestart(System.Exception reason) { }\n    protected override void PostStop() { }\n    protected override void PreRestart(System.Exception reason, object message) { }\n    protected override void PreStart() { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MessageDispatcher Abstract Class in Akka.NET\nDESCRIPTION: The base class for all message dispatchers that manage actor message execution. It defines core functionality for attaching, detaching, and dispatching messages to actor cells. This class is the foundation for different dispatcher implementations in Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_88\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class MessageDispatcher\n    {\n        public const int DefaultThroughput = 100;\n        protected MessageDispatcher(Akka.Dispatch.MessageDispatcherConfigurator configurator) { }\n        public Akka.Dispatch.MessageDispatcherConfigurator Configurator { get; }\n        public Akka.Event.EventStream EventStream { get; }\n        public string Id { get; set; }\n        protected long Inhabitants { get; }\n        public Akka.Dispatch.Mailboxes Mailboxes { get; }\n        [Akka.Annotations.InternalApiAttribute()]\n        public System.TimeSpan ShutdownTimeout { get; set; }\n        public int Throughput { get; set; }\n        public System.Nullable<long> ThroughputDeadlineTime { get; set; }\n        public virtual void Attach(Akka.Actor.ActorCell cell) { }\n        public virtual void Detach(Akka.Actor.ActorCell cell) { }\n        public virtual void Dispatch(Akka.Actor.ActorCell cell, Akka.Actor.Envelope envelope) { }\n        protected abstract void ExecuteTask(Akka.Dispatch.IRunnable run);\n```\n\n----------------------------------------\n\nTITLE: Compacting ByteStrings in Akka.NET Stream\nDESCRIPTION: Demonstrates how to compact ByteStrings in a stream to create clean copies that don't reference original ByteStrings. This operation is useful as the final step in a transformation chain to optimize memory usage.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/cookbook.md#2025-04-16_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\nvar data = Source.Empty<ByteString>();\nvar compacted = data.Select(b => b.Compact());\n```\n\n----------------------------------------\n\nTITLE: Creating a PriorityWorkerPool Graph with Akka.NET Streams\nDESCRIPTION: Implements a static factory method to create a Graph representing a priority worker pool. The implementation merges normal and priority jobs, balances them across multiple workers, and then merges the results.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithgraphs.md#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class PriorityWorkerPool\n{\n    public static IGraph<PriorityWorkerPoolShape<TIn, TOut>, NotUsed> Create<TIn, TOut>(\n        Flow<TIn, TOut, NotUsed> worker, int workerCount)\n    {\n        return GraphDsl.Create(b =>\n        {\n            var priorityMerge = b.Add(new MergePreferred<TIn>(1));\n            var balance = b.Add(new Balance<TIn>(workerCount));\n            var resultsMerge = b.Add(new Merge<TOut>(workerCount));\n\n            // After merging priority and ordinary jobs, we feed them to the balancer\n            b.From(priorityMerge).To(balance);\n\n            // Wire up each of the outputs of the balancer to a worker flow\n            // then merge them back\n            for (var i = 0; i < workerCount; i++)\n                b.From(balance.Out(i)).Via(worker).To(resultsMerge.In(i));\n\n            // We now expose the input ports of the priorityMerge and the output\n            // of the resultsMerge as our PriorityWorkerPool ports\n            // -- all neatly wrapped in our domain specific Shape\n            return new PriorityWorkerPoolShape<TIn, TOut>(jobsIn: priorityMerge.In(0),\n                priorityJobsIn: priorityMerge.Preferred, resultsOut: resultsMerge.Out);\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Clustered Group Router in HOCON\nDESCRIPTION: HOCON configuration for a clustered Group router that uses a broadcast strategy. This example sets up a router that targets the /user/api path on nodes with the 'crawler' role, with a maximum of 3 total routees.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-routing.md#2025-04-16_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\nakka {\n   actor{\n      provider = cluster\n      deployment {\n        /api/myClusterGroupRouter {\n          router = broadcast-group # routing strategy\n          routees.paths = [\"/user/api\"] # path of routee on each node\n          nr-of-instances = 3 # max number of total routees\n          cluster {\n             enabled = on\n             allow-local-routees = on\n             use-role = crawler\n          }\n        }\n      }\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Routing to Fastest Consumer in PartitionHub Using C#\nDESCRIPTION: This code snippet illustrates how to implement routing logic that prefers to send elements to the consumer with the least buffered elements, thus optimizing processing speed by leveraging consumer information like queue sizes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/stream-dynamic.md#2025-04-16_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[HubsDocTests.cs](../../../src/core/Akka.Docs.Tests/Streams/HubsDocTests.cs?name=partition-hub-fastest)]\n```\n\n----------------------------------------\n\nTITLE: Constructing a Simple Graph in Akka Streams (C#)\nDESCRIPTION: This snippet demonstrates how to construct a simple graph using Akka Streams' GraphDSL. It creates a graph with a source, multiple flows, broadcast and merge junctions, and a sink.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithgraphs.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar g = RunnableGraph.FromGraph(GraphDsl.Create(builder =>\n{\n    var source = Source.From(Enumerable.Range(1, 10));\n    var sink = Sink.Ignore<int>().MapMaterializedValue(_ => NotUsed.Instance);\n\n    var broadcast = builder.Add(new Broadcast<int>(2));\n    var merge = builder.Add(new Merge<int>(2));\n\n    var f1 = Flow.Create<int>().Select(x => x + 10);\n    var f2 = Flow.Create<int>().Select(x => x + 10);\n    var f3 = Flow.Create<int>().Select(x => x + 10);\n    var f4 = Flow.Create<int>().Select(x => x + 10);\n\n    builder.From(source).Via(f1).Via(broadcast).Via(f2).Via(merge).Via(f3).To(sink);\n    builder.From(broadcast).Via(f4).To(merge);\n\n    return ClosedShape.Instance;\n}));\n```\n\n----------------------------------------\n\nTITLE: Implementing Switch Class in C#\nDESCRIPTION: A thread-safe boolean switch with methods to control and observe state transitions and execute actions conditionally based on state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_234\n\nLANGUAGE: C#\nCODE:\n```\npublic class Switch\n{\n    public Switch(bool startAsOn = False) { }\n    public bool IsOff { get; }\n    public bool IsOn { get; }\n    public bool IfOff(System.Action action) { }\n    public bool IfOn(System.Action action) { }\n    public void Locked(System.Action action) { }\n    public bool SwitchOff(System.Action action) { }\n    public bool SwitchOff() { }\n    public bool SwitchOn(System.Action action) { }\n    public bool SwitchOn() { }\n    protected bool TranscendFrom(bool from, System.Action action) { }\n    public bool WhileOff(System.Action action) { }\n    public bool WhileOn(System.Action action) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Flow with Global Rate Limiter in C#\nDESCRIPTION: This code snippet demonstrates how to create a Flow that uses the global limiter actor. It utilizes SelectAsync and the Ask pattern with a timeout to control the flow rate.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/cookbook.md#2025-04-16_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\npublic Flow<T, T, NotUsed> LimitGlobal<T>(IActorRef limiter, TimeSpan maxAllowedWait)\n  => Flow.Create<T>().SelectAsync(4, element =>\n  {\n      var limiterTriggerTask = limiter.Ask<T>(WantToPass.Instance, maxAllowedWait);\n      return limiterTriggerTask.ContinueWith(t => element);\n  });\n```\n\n----------------------------------------\n\nTITLE: Actor Initialization Pattern with PreStart Override in C#\nDESCRIPTION: Shows how to implement custom initialization logic that runs only once during actor creation by overriding PreStart, PostRestart, and PreRestart methods.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_30\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override void PreStart()\n{\n    // Initialize children here\n}\n\n// Overriding postRestart to disable the call to preStart() after restarts\nprotected override void PostRestart(Exception reason)\n{ \n}\n\n// The default implementation of PreRestart() stops all the children\n// of the actor. To opt-out from stopping the children, we\n// have to override PreRestart()\nprotected override void PreRestart(Exception reason, object message)\n{\n    // Keep the call to PostStop(), but no stopping of children\n    PostStop();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ConsumerController for Akka.NET Delivery in C#\nDESCRIPTION: This snippet defines the ConsumerController class for managing message delivery in Akka.NET. It includes various nested classes and interfaces for handling different aspects of message consumption and delivery.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_71\n\nLANGUAGE: C#\nCODE:\n```\npublic class static ConsumerController\n{\n    public static Akka.Actor.Props Create<T>(Akka.Actor.IActorRefFactory actorRefFactory, Akka.Util.Option<Akka.Actor.IActorRef> producerControllerReference, Akka.Delivery.ConsumerController.Settings settings = null) { }\n    public sealed class Confirmed\n    {\n        public static readonly Akka.Delivery.ConsumerController.Confirmed Instance;\n    }\n    public sealed class DeliverThenStop<T> : Akka.Delivery.ConsumerController.IConsumerCommand<T>\n    {\n        public static readonly Akka.Delivery.ConsumerController.DeliverThenStop<T> Instance;\n    }\n    public sealed class Delivery<T> : Akka.Delivery.ConsumerController.IConsumerCommand<T>, Akka.Delivery.Internal.IDeliverySerializable, Akka.Event.IDeadLetterSuppression, System.IEquatable<Akka.Delivery.ConsumerController.Delivery<T>>\n    {\n        public Delivery(T Message, Akka.Actor.IActorRef ConfirmTo, string ProducerId, long SeqNr) { }\n        public Akka.Actor.IActorRef ConfirmTo { get; set; }\n        public T Message { get; set; }\n        public string ProducerId { get; set; }\n        public long SeqNr { get; set; }\n        public override string ToString() { }\n    }\n    public interface IConsumerCommand<T> { }\n    public sealed class RegisterToProducerController<T> : Akka.Delivery.ConsumerController.IConsumerCommand<T>\n    {\n        public RegisterToProducerController(Akka.Actor.IActorRef producerController) { }\n        public Akka.Actor.IActorRef ProducerController { get; }\n    }\n    public sealed class SequencedMessage<T> : Akka.Delivery.ConsumerController.IConsumerCommand<T>, Akka.Delivery.Internal.IDeliverySerializable, Akka.Event.IDeadLetterSuppression, System.IEquatable<Akka.Delivery.ConsumerController.SequencedMessage<T>>\n    {\n        public SequencedMessage(string ProducerId, long SeqNr, Akka.Delivery.Internal.MessageOrChunk<T> Message, bool First, bool Ack) { }\n        public bool Ack { get; set; }\n        public bool First { get; set; }\n        public Akka.Delivery.Internal.MessageOrChunk<T> Message { get; set; }\n        public string ProducerId { get; set; }\n        public long SeqNr { get; set; }\n        public bool Equals(Akka.Delivery.ConsumerController.SequencedMessage<T> other) { }\n        public override int GetHashCode() { }\n    }\n    public sealed class Settings : System.IEquatable<Akka.Delivery.ConsumerController.Settings>\n    {\n        public int FlowControlWindow { get; set; }\n        public bool OnlyFlowControl { get; set; }\n        public System.TimeSpan ResendIntervalMax { get; set; }\n        public System.TimeSpan ResendIntervalMin { get; set; }\n        public static Akka.Delivery.ConsumerController.Settings Create(Akka.Actor.ActorSystem actorSystem) { }\n        public static Akka.Delivery.ConsumerController.Settings Create(Akka.Configuration.Config config) { }\n        public override string ToString() { }\n    }\n    public sealed class Start<T> : Akka.Delivery.ConsumerController.IConsumerCommand<T>\n    {\n        public Start(Akka.Actor.IActorRef deliverTo) { }\n        public Akka.Actor.IActorRef DeliverTo { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ClusterSharding Class Definition in C#\nDESCRIPTION: Defines the core ClusterSharding class that implements Akka's IExtension interface. This class provides methods for starting and managing sharded actors across a cluster with various configurations for entity creation and message routing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Net.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.Cluster.Sharding\n{\n    [System.Runtime.CompilerServices.NullableAttribute(0)]\n    public class ClusterSharding : Akka.Actor.IExtension\n    {\n        public ClusterSharding(Akka.Actor.ExtendedActorSystem system) { }\n        [Akka.Annotations.InternalApiAttribute()]\n        public Akka.Cluster.Sharding.IShardingBufferMessageAdapter BufferMessageAdapter { get; }\n        public Akka.Cluster.Sharding.ClusterShardingSettings Settings { get; }\n        public System.Collections.Immutable.ImmutableHashSet<string> ShardTypeNames { get; }\n        public static Akka.Configuration.Config DefaultConfig() { }\n        public Akka.Cluster.Sharding.IShardAllocationStrategy DefaultShardAllocationStrategy(Akka.Cluster.Sharding.ClusterShardingSettings settings) { }\n        public static Akka.Cluster.Sharding.ClusterSharding Get(Akka.Actor.ActorSystem system) { }\n        [Akka.Annotations.InternalApiAttribute()]\n        public void SetShardingBufferMessageAdapter(Akka.Cluster.Sharding.IShardingBufferMessageAdapter bufferMessageAdapter) { }\n        public Akka.Actor.IActorRef ShardRegion(string typeName) { }\n        public Akka.Actor.IActorRef ShardRegionProxy(string typeName) { }\n        [System.ObsoleteAttribute(\"Use one of the overloads that accepts an IMessageExtractor instead\")]\n        public Akka.Actor.IActorRef Start(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n        [System.ObsoleteAttribute(\"Use one of the overloads that accepts an IMessageExtractor instead\")]\n        public Akka.Actor.IActorRef Start(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n        public Akka.Actor.IActorRef Start(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n        public Akka.Actor.IActorRef Start(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n        [System.ObsoleteAttribute(\"Use one of the overloads that accepts an IMessageExtractor instead\")]\n        public Akka.Actor.IActorRef Start(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n        [System.ObsoleteAttribute(\"Use one of the overloads that accepts an IMessageExtractor instead\")]\n        public Akka.Actor.IActorRef Start(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n        public Akka.Actor.IActorRef Start(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n        public Akka.Actor.IActorRef Start(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n        [System.ObsoleteAttribute(\"Use one of the overloads that accepts an IMessageExtractor instead\")]\n        public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n        [System.ObsoleteAttribute(\"Use one of the overloads that accepts an IMessageExtractor instead\")]\n        public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n        public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n        public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n        [System.ObsoleteAttribute(\"Use one of the overloads that accepts an IMessageExtractor instead\")]\n        public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n        [System.ObsoleteAttribute(\"Use one of the overloads that accepts an IMessageExtractor instead\")]\n        public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n        public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n        public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n        [System.ObsoleteAttribute(\"Use one of the overloads that accepts an IMessageExtractor instead\")]\n        public Akka.Actor.IActorRef StartProxy(string typeName, string role, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n        public Akka.Actor.IActorRef StartProxy(string typeName, string role, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n        [System.ObsoleteAttribute(\"Use one of the overloads that accepts an IMessageExtractor instead\")]\n        public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartProxyAsync(string typeName, string role, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n        public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartProxyAsync(string typeName, string role, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Base FSM Actor in C#\nDESCRIPTION: Defines abstract FSM (Finite State Machine) base actor class with core FSM functionality including state transitions, timers, and event handling. Includes nested classes for state management and event handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class FSM<TState, TData> : Akka.Actor.FSMBase, Akka.Actor.Internal.IInternalSupportsTestFSMRef<TState, TData>, Akka.Routing.IListeners\n{\n    protected bool DebugEvent;\n    protected FSM() { }\n    public Akka.Routing.ListenerSupport Listeners { get; }\n    public TData NextStateData { get; }\n    public TData StateData { get; }\n    public TState StateName { get; }\n    public void CancelTimer(string name) { }\n    public Akka.Actor.FSMBase.State<TState, TData> GoTo(TState nextStateName) { }\n    public void Initialize() { }\n    public bool IsTimerActive(string name) { }\n    protected virtual void LogTermination(Akka.Actor.FSMBase.Reason reason) { }\n    public void OnTermination(System.Action<Akka.Actor.FSMBase.StopEvent<TState, TData>> terminationHandler) { }\n    public void OnTransition(Akka.Actor.FSM<TState, TData>.TransitionHandler transitionHandler) { }\n    protected override void PostStop() { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Seed Node for Akka.Cluster\nDESCRIPTION: HOCON configuration for setting up a seed node in Akka.Cluster. Specifies actor provider, remote transport settings, and seed node address.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-overview.md#2025-04-16_snippet_1\n\nLANGUAGE: xml\nCODE:\n```\nakka {\n    actor.provider = cluster\n    remote {\n        dot-netty.tcp {\n            port = 8081\n            hostname = localhost\n        }\n    }\n    cluster {\n        seed-nodes = [\"akka.tcp://ClusterSystem@localhost:8081\"]\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up a Persistent FSM in C#\nDESCRIPTION: Complete setup of a WebStoreCustomerFSMActor showing how to wire together states, events, and transitions. Demonstrates the core structure of a Persistent FSM implementation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistent-fsm.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Akka.NET Discovery with Azure using C#\nDESCRIPTION: This snippet shows how to initialize Akka.NET service discovery with Azure for the receptionist side. It demonstrates the use of the Akka.Discovery API in C# to load the service discovery method configured in HOCON. This setup is essential for updating Azure tables used for node discovery.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-client.md#2025-04-16_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\nDiscovery.Get(myActorSystem).LoadServiceDiscovery(\"azure-cluster-client\");\n```\n\n----------------------------------------\n\nTITLE: Implementing ByteLimiter in C# for Akka.NET Streams\nDESCRIPTION: This code defines a ByteLimiter GraphStage that fails the stream if more than a given maximum number of bytes has been consumed. It's useful for enforcing data size limits in streams.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/cookbook.md#2025-04-16_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ByteLimiter : GraphStage<FlowShape<ByteString, ByteString>>\n{\n    private sealed class Logic : GraphStageLogic\n    {\n        private long _count;\n\n        public Logic(ByteLimiter limiter) : base(limiter.Shape)\n        {\n            SetHandler(limiter.In, onPush: () =>\n            {\n                var chunk = Grab(limiter.In);\n                _count += chunk.Count;\n                if (_count > limiter._maximumBytes)\n                    FailStage(new IllegalStateException(\"Too much bytes\"));\n                else\n                    Push(limiter.Out, chunk);\n            });\n\n            SetHandler(limiter.Out, onPull: () => Pull(limiter.In));\n        }\n    }\n\n    private readonly long _maximumBytes;\n\n    public ByteLimiter(long maximumBytes)\n    {\n        _maximumBytes = maximumBytes;\n        Shape = new FlowShape<ByteString, ByteString>(In, Out);\n    }\n\n    public Inlet<ByteString> In { get; } = new Inlet<ByteString>(\"ByteLimiter.in\");\n\n    public Outlet<ByteString> Out { get; } = new Outlet<ByteString>(\"ByteLimiter.out\");\n\n    public override FlowShape<ByteString, ByteString> Shape { get; }\n\n    protected override GraphStageLogic CreateLogic(Attributes inheritedAttributes) => new Logic(this);\n}\n\nvar limiter = Flow.Create<ByteString>().Via(new ByteLimiter(SizeLimit));\n```\n\n----------------------------------------\n\nTITLE: Injecting Keep-Alive Messages in Akka.NET ByteString Stream\nDESCRIPTION: Shows how to inject keep-alive messages into a ByteString stream using the KeepAlive flow operator. The operation adds keep-alive messages only when there is no normal traffic, with a configurable time interval.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/cookbook.md#2025-04-16_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\nvar injectKeepAlive = Flow.Create<ByteString>().KeepAlive(TimeSpan.FromSeconds(1), () => keepAliveMessage);\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested PersistAsync Calls in Akka.NET Persistent Actors\nDESCRIPTION: Shows how to use nested PersistAsync calls, which do not involve stashing but maintain the expected order of event persistence and callback execution.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/event-sourcing.md#2025-04-16_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/core/Akka.Docs.Tests/Persistence/PersistentActor/NestedPersistsAsync.cs?name=NestedPersistsAsync1)]\n```\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/core/Akka.Docs.Tests/Persistence/PersistentActor/NestedPersistsAsync.cs?name=NestedPersistsAsync2)]\n```\n\n----------------------------------------\n\nTITLE: Executing Task with CircuitBreaker in C#\nDESCRIPTION: Method to execute a task with circuit breaker protection. It takes a function that returns a Task<T> and wraps it with circuit breaker logic.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_197\n\nLANGUAGE: C#\nCODE:\n```\npublic System.Threading.Tasks.Task<T> WithCircuitBreaker<T>(System.Func<System.Threading.Tasks.Task<T>> body) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Message Extractor for Remembered Entities in C#\nDESCRIPTION: Example of a message extractor implementation that handles both regular messages and StartEntity messages for remembered entities. Uses HashCodeMessageExtractor to compute shard IDs from entity IDs.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-sharding.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class ShardEnvelope\n{\n    public readonly int EntityId;\n    public readonly object Message;\n\n    ...\n}\n\npublic sealed class MessageExtractor : HashCodeMessageExtractor\n{\n    public MessageExtractor() : base(maxNumberOfShards: 100) { }\n\n    public string EntityId(object message) \n    {\n        switch(message)\n        {\n            case ShardEnvelope e: return e.EntityId;\n            case ShardRegion.StartEntity start: return start.EntityId;\n        }\n    } \n    public object EntityMessage(object message) => (message as ShardEnvelope)?.Message ?? message;\n}\n```\n\n----------------------------------------\n\nTITLE: Parallel Processing with ForEachParallel in Akka.NET\nDESCRIPTION: Enables parallel processing of stream elements with configurable parallelism level. Maintains backpressure when parallel operations are incomplete.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/builtinstages.md#2025-04-16_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Implementing Rate Control with ZipWith and Conflate\nDESCRIPTION: Shows how to handle rate differences between stream components using ZipWith and conflate operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/buffersandworkingwithrate.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nRunnableGraph.FromGraph(GraphDsl.Create(b => {\n    // this is the asynchronous stage in this graph\n    var zipper = b.Add(ZipWith.Apply<Tick,int,int>((tick, count) => count).Async());\n\n    var s = b.Add(Source.Tick(TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(3), new Tick()));\n    b.From(s).To(zipper.In0);\n\n    var s2 = b.Add(Source.Tick(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), \"message!\")\n        .ConflateWithSeed(seed => 1, (count, _) => count + 1));\n    \n    b.From(s2).To(zipper.In1);\n\n    b.From(zipper.Out).To(Sink.ForEach<int>(i => Console.WriteLine($\"test: {i}\"))\n        .MapMaterializedValue(_ => NotUsed.Instance));\n   \n    return ClosedShape.Instance;\n                }));\n```\n\n----------------------------------------\n\nTITLE: Setting Up a DeployTarget System in Akka.NET\nDESCRIPTION: Configures and initializes the target actor system that will receive remotely deployed actors. This system doesn't create any actors initially but is configured with remote capabilities to accept deployments.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/remoting/deployment.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nclass Program\n{\n    static void Main(string[] args)\n    {\n        using (var system = ActorSystem.Create(\"DeployTarget\", ConfigurationFactory.ParseString(@\"\n            akka {  \n                actor.provider = remote\n                remote {\n                    dot-netty.tcp {\n                        port = 8090\n                        hostname = localhost\n                    }\n                }\n            }\")));\n        {\n            Console.ReadKey();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Node-Specific Code in Multi-Node Test in C#\nDESCRIPTION: This code snippet demonstrates how to run specific code on different nodes in a multi-node test using the RunOn method. It also shows how to synchronize test progression across nodes using the EnterBarrier method.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/testing/multi-node-testing.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nRunOn(() =>\n{\n    Cluster.JoinSeedNodes(SeedNodes);\n    Cluster.Subscribe(TestActor, ClusterEvent.InitialStateAsEvents, new[] { typeof(ClusterEvent.IMemberEvent) });\n    AwaitMembersUp(2);\n}, _config.Seed2);\n\nRunOn(() =>\n{\n    Cluster.JoinSeedNodes(SeedNodes);\n    Cluster.Subscribe(TestActor, ClusterEvent.InitialStateAsEvents, new[] { typeof(ClusterEvent.IMemberEvent) });\n    AwaitMembersUp(2);\n}, _config.Seed1);\n\nEnterBarrier(\"cluster started\");\n```\n\n----------------------------------------\n\nTITLE: Extending Akka.NET TestKit for Xunit\nDESCRIPTION: The TestKit class extends Akka's TestKitBase to integrate Xunit testing capabilities, offering various constructors for Akka systems and providing utility functions for initializing loggers and managing configurations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKitXunit2.Net.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.TestKit.Xunit2\n{\n    public class TestKit : Akka.TestKit.TestKitBase, System.IDisposable\n    {\n        protected readonly Xunit.Abstractions.ITestOutputHelper Output;\n        public TestKit(Akka.Actor.ActorSystem system = null, Xunit.Abstractions.ITestOutputHelper output = null) { }\n        public TestKit(Akka.Actor.Setup.ActorSystemSetup config, string actorSystemName = null, Xunit.Abstractions.ITestOutputHelper output = null) { }\n        public TestKit(Akka.Configuration.Config config, string actorSystemName = null, Xunit.Abstractions.ITestOutputHelper output = null) { }\n        public TestKit(string config, Xunit.Abstractions.ITestOutputHelper output = null) { }\n        protected static Akka.TestKit.Xunit2.XunitAssertions Assertions { get; }\n        public new static Akka.Configuration.Config DefaultConfig { get; }\n        public new static Akka.Configuration.Config FullDebugConfig { get; }\n        protected virtual void AfterAll() { }\n        protected virtual void Dispose(bool disposing) { }\n        public void Dispose() { }\n        protected void InitializeLogger(Akka.Actor.ActorSystem system) { }\n        protected void InitializeLogger(Akka.Actor.ActorSystem system, string prefix) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Services with ClusterClientReceptionist in C#\nDESCRIPTION: Code example showing how to register actor services with the ClusterClientReceptionist on different cluster nodes so they can be accessed by the cluster client.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-client.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nRunOn(() =>\n{\n    var serviceA = Sys.ActorOf(Props.Create<Service>(), \"serviceA\");\n    ClusterClientReceptionist.Get(Sys).RegisterService(serviceA);\n}, host1);\n\nRunOn(() =>\n{\n    var serviceB = Sys.ActorOf(Props.Create<Service>(), \"serviceB\");\n    ClusterClientReceptionist.Get(Sys).RegisterService(serviceB);\n}, host2, host3);\n```\n\n----------------------------------------\n\nTITLE: Implementing Producer Controller with Message Chunking in Akka.Delivery\nDESCRIPTION: Code example showing how to register a Producer with a ProducerController that has message chunking enabled. ChunkLargeMessagesBytes is set to create 100KB chunks.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/reliable-delivery.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nprivate ActorSystem system = ActorSystem.Create(\"test\");\nprivate IActorRef producerController;\n\nprivate void CreateProducerWithController()\n{\n    var producerId = \"p1\";\n    var settings = ProducerController.Settings.Create(system)\n        .WithChunkLargeMessagesBytes(100 * 1024); // 100KB chunks\n    producerController = system.ActorOf(ProducerController.Props(producerId, settings));\n    // create producer\n    var producer = system.ActorOf(Props.Create(() => new Producer(producerController)));\n    // register producer with the controller\n    producerController.Tell(new ProducerController.Start<string>(producer));\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Message Sending with Akka.NET Inbox\nDESCRIPTION: Shows how to create an Inbox instance and use it to send messages to an actor and receive replies with timeout handling. The inbox acts as a wrapper around normal Tell operations and provides a way to receive responses.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/inbox.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar target = system.ActorOf(Props.Empty);\nvar inbox = Inbox.Create(system);\n\ninbox.Send(target, \"hello\");\n\ntry\n{\n    inbox.Receive(TimeSpan.FromSeconds(1)).Equals(\"world\");\n}\ncatch (TimeoutException)\n{\n    // timeout\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming Tweet Stream to Authors using Akka Streams Flow in C#\nDESCRIPTION: Connecting a Publisher to a Subscriber using Akka Streams Flow to transform the stream. This filters tweets with specific hashtags and extracts author information.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nvar authors = Flow.Create<Tweet>()\n    .Where(t => t.HashTags.Contains(\"Akka.net\"))\n    .Select(t => t.Author);\n\nSource.FromPublisher(tweets)\n    .Via(authors)\n    .To(Sink.FromSubscriber(storage))\n    .Run(materializer);\n```\n\n----------------------------------------\n\nTITLE: Hot-Swapping Actor Behavior with Become in Akka.NET\nDESCRIPTION: This code snippet shows how to use `Context.Become` in Akka.NET to dynamically change an actor's behavior based on received messages. The `HotSwapActor` switches between `Angry` and `Happy` states, demonstrating a simple state machine implementation.  This allows an actor to respond differently to messages depending on its current state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\npublic class HotSwapActor : UntypedActor\n{\n    protected override void OnReceive(object message)\n    {\n        switch (message)\n        {\n            case \"foo\":\n                Become(Angry);\n                break;\n            case \"bar\":\n                Become(Happy);\n                break;\n        }\n    }\n\n    private void Angry(object message)\n    {\n        switch (message)\n        {\n            case \"foo\":\n                Sender.Tell(\"I am already angry?\");\n                break;\n            case \"bar\":\n                Become(Angry);\n                break;\n        }\n    }\n\n    private void Happy(object message)\n    {\n        switch (message)\n        {\n            case \"foo\":\n                Sender.Tell(\"I am already happy :-)\");\n                break;\n            case \"bar\":\n                Become(Angry);\n                break;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dropping Broadcast Pattern in Akka.NET\nDESCRIPTION: Creates a broadcast graph with buffered outputs that drop elements when buffers are full. Uses OverflowStrategy.DropHead to handle backpressure by dropping oldest elements when buffer capacity is reached.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/cookbook.md#2025-04-16_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nvar mysink1 = Sink.Ignore<int>();\nvar mysink2 = Sink.Ignore<int>();\nvar mysink3 = Sink.Ignore<int>();\n\nvar graph = RunnableGraph.FromGraph(GraphDsl.Create(mysink1, mysink2, mysink3, Tuple.Create,\n    (builder, sink1, sink2, sink3) =>\n    {\n        var broadcast = builder.Add(new Broadcast<int>(3));\n\n        builder.From(broadcast).Via(Flow.Create<int>().Buffer(10, OverflowStrategy.DropHead)).To(sink1);\n        builder.From(broadcast).Via(Flow.Create<int>().Buffer(10, OverflowStrategy.DropHead)).To(sink2);\n        builder.From(broadcast).Via(Flow.Create<int>().Buffer(10, OverflowStrategy.DropHead)).To(sink3);\n\n        return ClosedShape.Instance;\n    }));\n```\n\n----------------------------------------\n\nTITLE: Configuring Akka.NET with Kubernetes API using YAML\nDESCRIPTION: This snippet illustrates how to configure an Akka.NET cluster using the Kubernetes API. It demonstrates the YAML setup needed for labeling the instances and exposing the management port required for Akka.ClusterBootstrap. The configuration requires setting labels in the metadata and naming the Akka.Management port in the pod specification.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-client.md#2025-04-16_snippet_15\n\nLANGUAGE: yaml\nCODE:\n```\nmetadata:\\n  labels:\\n    app: cluster\\n    contact: cluster-client\n```\n\nLANGUAGE: yaml\nCODE:\n```\nspec:\\n  template:\\n    spec:\\n      containers:\\n        ports:\\n        - containerPort: 8558 # This is the remoting port, change this to match yours\\n          protocol: TCP\\n          name: management # this is important\n```\n\n----------------------------------------\n\nTITLE: Basic Akka.NET Cluster Configuration with Roles\nDESCRIPTION: Basic cluster configuration example showing how to set up seed nodes, roles, and minimum node counts for specific roles using HOCON format.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-configuration.md#2025-04-16_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\nakka {\n   actor.provider = cluster\n    remote {\n        dot-netty.tcp {\n            port = 8081\n            hostname = localhost\n        }\n    }\n    cluster {\n       seed-nodes = [\"akka.tcp://ClusterSystem@localhost:8081\"] # address of seed node\n       roles = [\"crawler\", \"logger\"] # roles this member is in\n       role.[\"crawler\"].min-nr-of-members = 3 # crawler role minimum node count\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Serializers in HOCON\nDESCRIPTION: HOCON configuration example showing how to define serializers and their implementations in Akka.NET\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/serialization/serialization.md#2025-04-16_snippet_0\n\nLANGUAGE: hocon\nCODE:\n```\nakka {\n  actor {\n     serializers {\n        json = \"Akka.Serialization.NewtonSoftJsonSerializer\"\n        bytes = \"Akka.Serialization.ByteArraySerializer\"\n     }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Reusing Flow Instances in Parallel Streams (C#)\nDESCRIPTION: This example shows how to create a graph with two parallel streams that reuse the same Flow instance. It demonstrates proper materialization of connections between Sources and Sinks.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithgraphs.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar topHeadSink = Sink.First<int>();\nvar bottomHeadSink = Sink.First<int>();\nvar sharedDoubler = Flow.Create<int>().Select(x => x*2);\n\nRunnableGraph.FromGraph(GraphDsl.Create(topHeadSink, bottomHeadSink, Keep.Both,\n    (builder, topHs, bottomHs) =>\n    {\n        var broadcast = builder.Add(new Broadcast<int>(2));\n        var source = Source.Single(1).MapMaterializedValue<Tuple<Task<int>, Task<int>>>(_ => null);\n\n        builder.From(source).To(broadcast.In);\n\n        builder.From(broadcast.Out(0)).Via(sharedDoubler).To(topHs.Inlet);\n        builder.From(broadcast.Out(1)).Via(sharedDoubler).To(bottomHs.Inlet);\n\n        return ClosedShape.Instance;\n    }));\n```\n\n----------------------------------------\n\nTITLE: Word Count using Akka.NET Streams\nDESCRIPTION: This snippet demonstrates a basic word count operation using Akka.NET Streams. It groups words, counts their occurrences, and merges the results into a single output stream.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/cookbook.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar words = Source.Empty<string>();\nvar counts = words\n    // split the words into separate streams first\n    .GroupBy(MaximumDistinctWords, x => x)\n    //transform each element to pair with number of words in it\n    .Select(x => Tuple.Create(x, 1))\n    // add counting logic to the streams\n    .Sum((l, r) => Tuple.Create(l.Item1, l.Item2 + r.Item2))\n    // get a stream of word counts\n    .MergeSubstreams();\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Messages to Router Routees in C#\nDESCRIPTION: This example demonstrates how to send messages to individual workers and broadcast a message to all routees of a router in Akka.NET using C#.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_28\n\nLANGUAGE: csharp\nCODE:\n```\nactorSystem.ActorOf(Props.Create<Worker>(), \"worker1\");\nactorSystem.ActorOf(Props.Create<Worker>(), \"worker2\");\nactorSystem.ActorOf(Props.Create<Worker>(), \"worker3\");\n\nvar workers = new[] { \"/user/worker1\", \"/user/worker2\", \"/user/worker3\" };\nvar router = actorSystem.ActorOf(Props.Empty.WithRouter(new RoundRobinGroup(workers)), \"workers\");\n\n// this sends to individual worker\nrouter.Tell(\"Hello, worker1\");\nrouter.Tell(\"Hello, worker2\");\nrouter.Tell(\"Hello, worker3\");\n\n// this sends to all workers\nrouter.Tell(new Broadcast(\"Hello, workers\"));\n```\n\n----------------------------------------\n\nTITLE: Multiple Stream Materialization in C#\nDESCRIPTION: Shows how the same stream definition can be materialized multiple times, producing different materialized values each time.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/basics.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n// connect the Source to the Sink, obtaining a RunnableGraph\nvar sink = Sink.Aggregate<int, int>(0, (sum, i) => sum + i);\nvar runnable = Source.From(Enumerable.Range(1, 10))\n    .ToMaterialized(sink, Keep.Right);\n\n// get the materialized value of the AggregateSink\nvar sum1 = runnable.Run(materializer);\nvar sum2 = runnable.Run(materializer);\n\n// sum1 and sum2 are different Tasks!\n```\n\n----------------------------------------\n\nTITLE: Declaring Tag Query Method Signature in C#\nDESCRIPTION: Method signature for querying events by tags with metadata using Source and QueryMetadata.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistence-query.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic Source<RichEvent, QueryMetadata> ByTagsWithMeta(ISet<string> tags) { }\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom PriorityWorkerPool Shape in C#\nDESCRIPTION: Creates a custom FanInShape for a priority worker pool with two input ports (regular and priority jobs) and one output port. The shape extends FanInShape and defines the necessary input/output ports.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithgraphs.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\npublic class PriorityWorkerPoolShape2<TIn, TOut> : FanInShape<TOut>\n{\n    public PriorityWorkerPoolShape2(IInit init = null)\n        : base(init ?? new InitName(\"PriorityWorkerPool\"))\n    {\n    }\n\n    protected override FanInShape<TOut> Construct(IInit init)\n        => new PriorityWorkerPoolShape2<TIn, TOut>(init);\n\n    public Inlet<TIn> JobsIn { get; } =  new Inlet<TIn>(\"JobsIn\");\n\n    public Inlet<TIn> PriorityJobsIn { get; } = new Inlet<TIn>(\"priorityJobsIn\");\n\n    // Outlet[Out] with name \"out\" is automatically created\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Sending SinkRef in C#\nDESCRIPTION: This code demonstrates how to create a SinkRef from a Sink and send it to a remote actor. It includes error handling and uses the PipeTo pattern for asynchronous operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/streamrefs.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nprivate IActorRef _database;\n\nprivate void Handle(StreamInitialized init)\n{\n    var sink = Sink.ActorRef<int>(_database, CompletionMessage, ex => new Failed(ex));\n\n    StreamRefs.SinkRef<int>().RunWith(sink, Materializer)\n        .PipeTo(\n            recipient: Sender,\n            success: sinkRef => new InitializeStreamAck(sinkRef),\n            failure: ex => new Status.Failure(ex));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SmallestMailboxPool in C#\nDESCRIPTION: This class implements a smallest mailbox routing strategy for a pool of actors, allowing configuration of instances, resizer, supervisor strategy, and dispatcher.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_189\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SmallestMailboxPool : Akka.Routing.Pool\n{\n    public SmallestMailboxPool(Akka.Configuration.Config config) { }\n    public SmallestMailboxPool(int nrOfInstances) { }\n    public SmallestMailboxPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False) { }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Routing.SmallestMailboxPool WithDispatcher(string dispatcher) { }\n    public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n    public Akka.Routing.SmallestMailboxPool WithResizer(Akka.Routing.Resizer resizer) { }\n    public Akka.Routing.SmallestMailboxPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }\n    public class SmallestMailboxPoolSurrogate : Akka.Util.ISurrogate\n    {\n        public SmallestMailboxPoolSurrogate() { }\n        public int NrOfInstances { get; set; }\n        public Akka.Routing.Resizer Resizer { get; set; }\n        public string RouterDispatcher { get; set; }\n        public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }\n        public bool UsePoolDispatcher { get; set; }\n        public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using GracefulStop in Akka.NET\nDESCRIPTION: The `GracefulStop` method allows waiting for an actor to terminate gracefully.  It sends a shutdown message to the actor and waits for it to stop, throwing a `TaskCanceledException` if the actor doesn't stop within the specified timeout.  The provided C# code demonstrates how to send a shutdown message and handle the result.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\nvar manager = system.ActorOf<Manager>();\n\ntry\n{\n    await manager.GracefulStop(TimeSpan.FromMilliseconds(5), \"shutdown\");\n    // the actor has been stopped\n}\ncatch (TaskCanceledException)\n{\n    // the actor wasn't stopped within 5 seconds\n}\n```\n\n----------------------------------------\n\nTITLE: Using Ask Pattern with Tasks in C#\nDESCRIPTION: Shows how to use Ask pattern with tasks for sending messages and receiving responses asynchronously. Demonstrates combining Ask with Pipe Pattern for non-blocking operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nvar tasks = new List<Task>();\ntasks.Add(actorA.Ask(\"request\", TimeSpan.FromSeconds(1)));\ntasks.Add(actorB.Ask(\"another request\", TimeSpan.FromSeconds(5)));\n\nTask.WhenAll(tasks).PipeTo(actorC, Self);\n```\n\n----------------------------------------\n\nTITLE: Constructing a Source with Akka.NET in C#\nDESCRIPTION: This snippet demonstrates how to create a Source in Akka.NET using the GraphDSL. It defines a graph with a zip junction connecting two streams filtered over odd and even numbers. The resulting source zips the pairs together. Dependencies include Akka.NET libraries and a materializer for running the stream.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithgraphs.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar pairs = Source.FromGraph(GraphDsl.Create(b =>\n{\n    // prepare graph elements\n    var zip = b.Add(new Zip<int, int>());\n    Func<Source<int, Task<Tuple<int, int>>>> ints = () =>\n        Source.From(Enumerable.Range(1, int.MaxValue))\n            .MapMaterializedValue<Task<Tuple<int, int>>>(_ => null);\n\n    // connect the graph\n    b.From(ints().Where(x => x%2 != 0)).To(zip.In0);\n    b.From(ints().Where(x => x % 2 == 0)).To(zip.In1);\n\n    // expose port\n    return new SourceShape<Tuple<int, int>>(zip.Out);\n}));\n\nvar firstPair = pairs.RunWith(Sink.First<Tuple<int, int>>(), materializer);\n```\n\n----------------------------------------\n\nTITLE: Defining Backoff Pattern Static Factory Methods in Akka.NET\nDESCRIPTION: Factory methods for creating backoff supervisor configurations based on different strategies. Supports both failure-based and stop-based backoff patterns with configurable retry parameters.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_190\n\nLANGUAGE: C#\nCODE:\n```\npublic class static Backoff\n{\n    [System.ObsoleteAttribute(\"Use the overloaded one which accepts maxNrOfRetries instead.\")]\n    public static Akka.Pattern.BackoffOptions OnFailure(Akka.Actor.Props childProps, string childName, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor) { }\n    public static Akka.Pattern.BackoffOptions OnFailure(Akka.Actor.Props childProps, string childName, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor, int maxNrOfRetries) { }\n    [System.ObsoleteAttribute(\"Use the overloaded one which accepts maxNrOfRetries instead.\")]\n    public static Akka.Pattern.BackoffOptions OnStop(Akka.Actor.Props childProps, string childName, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor) { }\n    public static Akka.Pattern.BackoffOptions OnStop(Akka.Actor.Props childProps, string childName, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor, int maxNrOfRetries) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ReceiveActor Base Class in C#\nDESCRIPTION: Abstract base class for implementing actors that can receive and handle messages. Provides various overloads for message handling including async operations and type-specific handlers.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ReceiveActor : Akka.Actor.UntypedActor, Akka.Actor.Internal.IInitializableActor\n{\n    protected ReceiveActor() { }\n    protected void Become(System.Action configure) { }\n    protected void BecomeStacked(System.Action configure) { }\n    protected virtual void OnReceive(object message) { }\n    protected void Receive<T>(System.Action<T> handler, System.Predicate<T> shouldHandle = null) { }\n    protected void Receive<T>(System.Predicate<T> shouldHandle, System.Action<T> handler) { }\n    protected void Receive(System.Type messageType, System.Action<object> handler, System.Predicate<object> shouldHandle = null) { }\n    protected void Receive(System.Type messageType, System.Predicate<object> shouldHandle, System.Action<object> handler) { }\n    protected void Receive<T>(System.Func<T, bool> handler) { }\n    protected void Receive(System.Type messageType, System.Func<object, bool> handler) { }\n    protected void ReceiveAny(System.Action<object> handler) { }\n    protected void ReceiveAnyAsync(System.Func<object, System.Threading.Tasks.Task> handler) { }\n    protected void ReceiveAsync<T>(System.Func<T, System.Threading.Tasks.Task> handler, System.Predicate<T> shouldHandle = null) { }\n    protected void ReceiveAsync<T>(System.Predicate<T> shouldHandle, System.Func<T, System.Threading.Tasks.Task> handler) { }\n    protected void ReceiveAsync(System.Type messageType, System.Func<object, System.Threading.Tasks.Task> handler, System.Predicate<object> shouldHandle = null) { }\n    protected void ReceiveAsync(System.Type messageType, System.Predicate<object> shouldHandle, System.Func<object, System.Threading.Tasks.Task> handler) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Using EventFilters for Log Event Assertions in Akka.NET Tests\nDESCRIPTION: Example of using EventFilters to intercept and assert on various types of log events, including DeadLetters, custom logs, and exceptions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/testing-actor-systems.md#2025-04-16_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nvar filter = CreateEventFilter(Sys);\n            \nfilter.DeadLetter<string>().ExpectOne(() =>\n{\n    //cause a message to be deadlettered here\n    \n});\n\nfilter.Custom(logEvent => logEvent is Error && (string)logEvent.Message == \"whatever\").ExpectOne(() =>\n{\n    Log.Error(\"whatever\");\n});\n\nfilter.Exception<MyException>().ExpectOne(() => Log.Error(new MyException(), \"the message\"));\n```\n\n----------------------------------------\n\nTITLE: Remote Actor Reference Provider Implementation in C#\nDESCRIPTION: Implementation of RemoteActorRefProvider class that handles creation and management of remote actor references. Contains properties and methods for actor system initialization, actor creation, and remote deployment.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class RemoteActorRefProvider : Akka.Actor.IActorRefProvider, Akka.Remote.IRemoteActorRefProvider\n{\n    public RemoteActorRefProvider(string systemName, Akka.Actor.Settings settings, Akka.Event.EventStream eventStream) { }\n    public Akka.Actor.IActorRef DeadLetters { get; }\n    public Akka.Actor.Address DefaultAddress { get; }\n    public Akka.Actor.Deployer Deployer { get; set; }\n    // ... additional properties and methods\n}\n```\n\n----------------------------------------\n\nTITLE: Basic TestProbe Usage in C#\nDESCRIPTION: Demonstrates how to create and use a TestProbe to verify message forwarding in Akka.NET\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/testing-actor-systems.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar probe = CreateTestProbe();\nprobe.Watch(target);\n\ntarget.Tell(PoisonPill.Instance);\n\nvar msg = probe.ExpectMsg<Terminated>();\nAssert.Equal(msg.ActorRef, target);\n```\n\n----------------------------------------\n\nTITLE: Implementing SchedulerExtensions in C# for Akka.NET\nDESCRIPTION: This class provides extension methods for scheduling actions and messages in Akka.NET. It includes methods for one-time and repeated scheduling of actions and message sending.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_47\n\nLANGUAGE: C#\nCODE:\n```\npublic class static SchedulerExtensions\n{\n    public static void ScheduleOnce(this Akka.Actor.IActionScheduler scheduler, int millisecondsDelay, System.Action action, Akka.Actor.ICancelable cancelable = null) { }\n    public static Akka.Actor.ICancelable ScheduleOnceCancelable(this Akka.Actor.IActionScheduler scheduler, System.TimeSpan delay, System.Action action) { }\n    public static Akka.Actor.ICancelable ScheduleOnceCancelable(this Akka.Actor.IActionScheduler scheduler, int millisecondsDelay, System.Action action) { }\n    public static void ScheduleRepeatedly(this Akka.Actor.IActionScheduler scheduler, int initialMillisecondsDelay, int millisecondsInterval, System.Action action, Akka.Actor.ICancelable cancelable = null) { }\n    public static Akka.Actor.ICancelable ScheduleRepeatedlyCancelable(this Akka.Actor.IActionScheduler scheduler, System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action) { }\n    public static Akka.Actor.ICancelable ScheduleRepeatedlyCancelable(this Akka.Actor.IActionScheduler scheduler, int initialMillisecondsDelay, int millisecondsInterval, System.Action action) { }\n    public static void ScheduleTellOnce(this Akka.Actor.ITellScheduler scheduler, int millisecondsDelay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable = null) { }\n    public static Akka.Actor.ICancelable ScheduleTellOnceCancelable(this Akka.Actor.IScheduler scheduler, System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender) { }\n    public static Akka.Actor.ICancelable ScheduleTellOnceCancelable(this Akka.Actor.IScheduler scheduler, int millisecondsDelay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender) { }\n    public static void ScheduleTellRepeatedly(this Akka.Actor.ITellScheduler scheduler, int initialMillisecondsDelay, int millisecondsInterval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable = null) { }\n    public static Akka.Actor.ICancelable ScheduleTellRepeatedlyCancelable(this Akka.Actor.IScheduler scheduler, System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender) { }\n    public static Akka.Actor.ICancelable ScheduleTellRepeatedlyCancelable(this Akka.Actor.IScheduler scheduler, int initialMillisecondsDelay, int millisecondsInterval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WriteMessagesAsync Method for Akka.Persistence Journal\nDESCRIPTION: Implementation of the WriteMessagesAsync method for a SQLite-based Akka.Persistence journal. This method handles atomic writes of persistent messages, ensuring all messages in a batch are stored successfully.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/custom-persistence-provider.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override async Task<IImmutableList<Exception>> WriteMessagesAsync(IEnumerable<AtomicWrite> messages)\n{\n    try\n    {\n        using (var connection = await _connectionFactory.CreateConnection())\n        using (var transaction = connection.BeginTransaction())\n        {\n            var allCommands = ImmutableList<Exception>.Empty;\n\n            foreach (var atomicWrite in messages)\n            {\n                var persistentMessages = (IImmutableList<IPersistentRepresentation>)atomicWrite.Payload;\n                foreach (var persistentMessage in persistentMessages)\n                {\n                    try\n                    {\n                        await WriteMessageAsync(connection, transaction, persistentMessage);\n                    }\n                    catch (Exception exception)\n                    {\n                        _log.Warning(exception, \"Failed to write {0} because of: {1}\", persistentMessage, exception.Message);\n                        var updatedList = allCommands.Add(exception);\n                        allCommands = updatedList;\n                    }\n                }\n            }\n\n            if (allCommands.IsEmpty)\n            {\n                transaction.Commit();\n                return null; // all good\n            }\n            transaction.Rollback();\n            return allCommands;\n        }\n    }\n    catch (Exception e)\n    {\n        _log.Error(e, \"Error while writing messages\");\n        throw;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Adaptive Load Balancing Router in HOCON\nDESCRIPTION: HOCON configuration for setting up an adaptive load balancing router using cluster metrics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-metrics.md#2025-04-16_snippet_3\n\nLANGUAGE: HOCON\nCODE:\n```\nakka.actor.deployment {\n  /factorialFrontend/factorialBackendRouter = {\n    # Router type provided by metrics extension.\n    router = cluster-metrics-adaptive-group\n    # Router parameter specific for metrics extension.\n    # metrics-selector = memory\n    # metrics-selector = cpu\n    metrics-selector = mix\n    #\n    routees.paths = [\"/user/factorialBackend\"]\n    cluster {\n      enabled = on\n      use-roles = [\"backend\"]\n      allow-local-routees = off\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Keep Oldest Strategy in Akka.NET\nDESCRIPTION: Configuration for the keep-oldest strategy which downs the part of the cluster that doesn't contain the oldest node. This is particularly useful when using Cluster Singleton which typically runs on the oldest member.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/split-brain-resolver.md#2025-04-16_snippet_5\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster.split-brain-resolver {\n  active-strategy = keep-oldest\n\n  keep-oldest {\n    # Enable downing of the oldest node when it is partitioned from all other nodes\n    down-if-alone = on\n    \n    # if the 'role' is defined the decision is based only on members with that 'role',\n    # i.e. using the oldest member (singleton) within the nodes with that role\n    role = \"\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing CoordinatedShutdown in C#\nDESCRIPTION: Implementation of the CoordinatedShutdown extension that manages graceful system shutdown with multiple phases and customizable tasks.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class CoordinatedShutdown : Akka.Actor.IExtension\n{\n    public const string PhaseActorSystemTerminate = \"actor-system-terminate\";\n    public const string PhaseBeforeActorSystemTerminate = \"before-actor-system-terminate\";\n    public const string PhaseBeforeClusterShutdown = \"before-cluster-shutdown\";\n    public const string PhaseBeforeServiceUnbind = \"before-service-unbind\";\n    public Akka.Actor.CoordinatedShutdown.Reason ShutdownReason { get; }\n    public Akka.Actor.ExtendedActorSystem System { get; }\n    public System.TimeSpan TotalTimeout { get; }\n    public void AddTask(string phase, string taskName, System.Func<System.Threading.Tasks.Task<Akka.Done>> task) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Query Protocol for Device Group in Akka.NET\nDESCRIPTION: Defines message types for querying temperature from multiple devices in an Akka.NET actor system. The protocol handles different response states including available temperature, unavailable temperature, stopped devices, and timed out devices.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-4.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[DeviceGroup.cs](../../../../src/core/Akka.Docs.Tutorials/Tutorial4/DeviceGroup.cs?name=query-protocol)]\n```\n\n----------------------------------------\n\nTITLE: Creating Props Configurations for Actor Instantiation\nDESCRIPTION: Demonstrates different ways to create Props configurations for actor instantiation, including passing constructor arguments.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nProps props1 = Props.Create(typeof(MyActor));\nProps props2 = Props.Create(() => new MyActorWithArgs(\"arg\"));\nProps props3 = Props.Create<MyActor>();\nProps props4 = Props.Create(typeof(MyActorWithArgs), \"arg\");\n```\n\n----------------------------------------\n\nTITLE: Setting Upper Bound for Event Replay in C#\nDESCRIPTION: This snippet shows how to set an upper bound for event replay during recovery, allowing the actor to be recovered to a specific point in the past.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/event-sourcing.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic override Recovery Recovery => new Recovery(new SnapshotSelectionCriteria(457));\n```\n\n----------------------------------------\n\nTITLE: Implementing Try<T> Class in C#\nDESCRIPTION: A container representing an operation that may succeed with a value or fail with an exception, with methods for composition and error handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_238\n\nLANGUAGE: C#\nCODE:\n```\npublic class Try<T>\n{\n    public Try(T success) { }\n    public Try(System.Exception failure) { }\n    public Akka.Util.Option<System.Exception> Failure { get; }\n    public bool IsSuccess { get; }\n    public Akka.Util.Option<T> Success { get; }\n    public static Akka.Util.Try<T> From(System.Func<T> func) { }\n    public T Get() { }\n    public Akka.Util.Try<T> GetOrElse(System.Func<T> fallback) { }\n    public Akka.Util.Try<T> OrElse(Akka.Util.Try<T> @default) { }\n    public Akka.Util.Try<T> Recover(System.Action<System.Exception> failureHandler) { }\n    public Akka.Util.Try<T> RecoverWith(System.Func<System.Exception, Akka.Util.Try<T>> failureHandler) { }\n    public static Akka.Util.Try<T> op_Implicit(T value) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Persistent Actor Classes in C#\nDESCRIPTION: Defines base classes for persistent actors including PersistentActor and ReceivePersistentActor that provide persistence capabilities to actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class PersistentActor : Akka.Persistence.Eventsourced\n{\n    protected PersistentActor() { }\n    protected override bool Receive(object message) { }\n}\n\npublic abstract class ReceivePersistentActor : Akka.Persistence.UntypedPersistentActor, Akka.Actor.Internal.IInitializableActor\n{\n    protected ReceivePersistentActor() { }\n    protected void Become(System.Action configure) { }\n    protected void BecomeStacked(System.Action configure) { }\n    protected void Command<T>(System.Action<T> handler, System.Predicate<T> shouldHandle = null) { }\n    protected void Command<T>(System.Predicate<T> shouldHandle, System.Action<T> handler) { }\n    protected void Command(System.Type messageType, System.Action<object> handler, System.Predicate<object> shouldHandle = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Actor Supervision Strategies in F#\nDESCRIPTION: Examples of setting up OneForOne and remote supervision strategies for actors using F# API. Shows error handling patterns and strategy configuration options.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.FSharp/README.md#2025-04-16_snippet_7\n\nLANGUAGE: F#\nCODE:\n```\nlet aref =\n        spawnOpt system \"my-actor\" (actorOf myFunc)\n            [ SpawnOption.SupervisorStrategy (Strategy.OneForOne (fun error ->\n                match error with\n                | :? ArithmeticException -> Directive.Escalate\n                | _ -> SupervisorStrategy.DefaultDecider error )) ]\n\n    let remoteRef =\n        spawne system \"remote-actor\" <@ actorOf myFunc @>\n            [ SpawnOption.SupervisorStrategy (Strategy.OneForOne <@ fun error ->\n                match error with\n                | :? ArithmeticException -> Directive.Escalate\n                | _ -> SupervisorStrategy.DefaultDecider error ) @>\n              SpawnOption.Deploy (Deploy (RemoteScope remoteNodeAddr)) ]\n```\n\n----------------------------------------\n\nTITLE: Default HOCON Configuration for Akka.NET\nDESCRIPTION: The base configuration file for Akka.NET that defines default settings for actor systems, dispatchers, serialization, remote actors, and other core framework components. This HOCON configuration serves as the foundation for any Akka.NET application.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/modules/akka.md#2025-04-16_snippet_0\n\nLANGUAGE: hocon\nCODE:\n```\n####################################\n####################################\n# Akka.NET Default Configuration #\n####################################\n####################################\n\n# This is the reference config file that contains all the default settings.\n# Make your edits/overrides in your application.conf.\n\nakka {\n\n    # Loggers to register at boot time (akka.event.Logging$DefaultLogger logs\n    # to STDOUT)\n    loggers = [\"Akka.Event.DefaultLogger, Akka\"]\n\n    # Specifies the default loggers dispatcher\n    loggers-dispatcher = \"akka.actor.default-dispatcher\"\n\n    # Log level used by the configured loggers (see \"loggers\") as soon\n    # as they have been started; before that, see \"stdout-loglevel\"\n    # Options: OFF, ERROR, WARNING, INFO, DEBUG\n    loglevel = \"INFO\"\n\n    # Log level for the very basic logger activated during ActorSystem startup.\n    # This logger prints the log messages to stdout (System.out).\n    # Options: OFF, ERROR, WARNING, INFO, DEBUG\n    stdout-loglevel = \"WARNING\"\n\n    # Filter of log events that is used by the LoggingAdapter before\n    # publishing log events to the eventStream.\n    logging-filter = \"Akka.Event.DefaultLoggingFilter, Akka\"\n\n    # Used to set the behavior of the ActorSystem when an actor terminates because of an exceptions. \n\tactor {\n\t\t# Default timeout for IActorRef.Ask() and Tell redelivery requests\n\t\task-timeout = 10s\n\t\t\n\t\t# Default timeout for ActorSystem.ActorOf() calls\n\t\tcreation-timeout = 20s\n        \n        # Default timeout for the guardian actor to terminate all children\n        guardian-supervisor-strategy {\n             termination-timeout = 5s\n        }\n        \n\t\t# Used as default dispatcher for all actors if not specified otherwise\n\t\tdefault-dispatcher {\n\t\t\ttype = \"Akka.Dispatch.DefaultDispatcher, Akka\"\n\t\t\t\n\t\t\t# Must be one of the following\n\t\t\t# Dispatcher, PinnedDispatcher, or a FQCN to a class inheriting\n\t\t\t# MessageDispatcherConfigurator with a public constructor with\n\t\t\t# both com.typesafe.config.Config parameter and\n\t\t\t# akka.dispatch.DispatcherPrerequisites parameter.\n\t\t\t# PinnedDispatcher must be used together with executor=thread-pool-executor.\n\t\t\ttype = Dispatcher\n\t\t\t\n\t\t\t# Which kind of ExecutorService to use for this dispatcher\n\t\t\t# Valid options:\n\t\t\t#   \"fork-join-executor\" requires a \"parallelism-min\", a \"parallelism-factor\" and a \"parallelism-max\" / \"task-queue-size\" parameter\n\t\t\t#   \"thread-pool-executor\" requires a \"core-pool-size-min\", a \"core-pool-size-factor\" and a \"core-pool-size-max\" parameter\n\t\t\t#   \"custom-executor\" requires a path to a class extending the Akka.Dispatch.SingleProducerConsumerQueue\n\t\t\texecutor = \"default-executor\"\n\t\t\t\n\t\t\t# How long time the dispatcher will wait for new actors until it shuts down\n\t\t\tshutdown-timeout = 1s\n\t\t\t\n\t\t\t# Throughput defines the number of messages that are processed in a batch\n\t\t\t# before the thread is returned to the pool. Set to 1 for as fair as possible.\n\t\t\tthroughput = 30\n\t\t\t\n\t\t\t# Throughput deadline for Dispatcher, set to 0 or negative for no deadline\n\t\t\tthroughput-deadline-time = 0ms\n\t\t\t\n\t\t\t# If negative (or zero) then an unbounded mailbox is used (default)\n\t\t\t# If positive then a bounded mailbox is used and the capacity is set using the\n\t\t\t# property\n\t\t\t\n\t\t\t# SPECIAL CASE: 0 means an unbounded mailbox, but since Akka.NET is written in c# \n\t\t\t# we have to use the int.maxvalue for it to be unbounded\n\t\t\tmailbox-capacity = -1\n\t\t\t\n\t\t\t# Specifies the timeout to add a new message to a mailbox that is full -\n\t\t\t# negative number means `block` (blocking mode, wait until queue has space)\n\t\t\t# 0 and positive numbers mean adding to the mailbox will fail immediately\n\t\t\t# after the time specified. This is only relevant for bounded mailboxes\n\t\t\tmailbox-push-timeout-time = 10s\n\t\t\t\n\t\t\t# For \"fork-join-executor\" only.\n\t\t\t# Min number of threads to cap factor-based parallelism number to.\n\t\t\tfork-join-executor {\n\t\t\t\t# The parallelism factor is used to determine thread pool size using the\n\t\t\t\t# following formula: ceil(available processors * factor). Resulting size\n\t\t\t\t# is then bounded by the parallelism-min and parallelism-max values.\n\t\t\t\tparallelism-factor = 1.0\n\t\t\t\t\n\t\t\t\t# Min number of threads to cap factor-based parallelism number to.\n\t\t\t\tparallelism-min = 8\n\t\t\t\t\n\t\t\t\t# Max number of threads to cap factor-based parallelism number to.\n\t\t\t\tparallelism-max = 16\n\t\t\t\t\n\t\t\t\ttask-queue-size = 32768\n\t\t\t}\n\t\t\t\n\t\t\t# For \"thread-pool-executor\" only.\n\t\t\t# Allows configuration of a Threadpool for this dispatcher\n\t\t\tthread-pool-executor {\n\t\t\t\t# Keep alive time for threads\n\t\t\t\tkeep-alive-time = 60s\n\t\t\t\t\n\t\t\t\t# Define a fixed thread pool size with this property. The corePoolSize\n\t\t\t\t# will not grow and shrink. This is the default for this executor.\n\t\t\t\tfixed-pool-size = 4\n\t\t\t\t\n\t\t\t\t# Min number of threads to cap factor-based corePoolSize number to.\n\t\t\t\tcore-pool-size-min = 8\n\t\t\t\t\n\t\t\t\t# The core-pool-size-factor is used to determine corePoolSize using the\n\t\t\t\t# following formula: ceil(available processors * factor).\n\t\t\t\t# Resulting size is then bounded by the core-pool-size-min and\n\t\t\t\t# core-pool-size-max values.\n\t\t\t\tcore-pool-size-factor = 2.0\n\t\t\t\t\n\t\t\t\t# Max number of threads to cap factor-based corePoolSize number to.\n\t\t\t\tcore-pool-size-max = 16\n\t\t\t\t\n\t\t\t\t# Minimum number of threads to cap factor-based maximumPoolSize number to.\n\t\t\t\tmax-pool-size-min = 8\n\t\t\t\t\n\t\t\t\t# The max-pool-size-factor is used to determine maximumPoolSize using the\n\t\t\t\t# following formula: ceil(available processors * factor)\n\t\t\t\t# The maximumPoolSize will not be less than corePoolSize.\n\t\t\t\t# It is only used if using a bounded task queue.\n\t\t\t\tmax-pool-size-factor = 2.0\n\t\t\t\t\n\t\t\t\t# Max number of threads to cap factor-based maximumPoolSize number to.\n\t\t\t\tmax-pool-size-max = 16\n\t\t\t\t\n\t\t\t\ttask-queue-size = -1\n                task-queue-type = LINKED\n\t\t\t}\n\t\t\t\n\t\t\t# For \"custom-executor\" only. Need to be a class extending the Akka.Dispatch.ThreadPoolExecutorConfigurator\n\t\t\tcustom-executor {\n\t\t\t\t# Path to the class extending the Akka.Dispatch.ThreadPoolExecutorConfigurator\n\t\t\t\texecutor-path = \"namespace.of.class, assembly\"\n\t\t\t}\n\t\t\t\n\t\t\t# Throughput for default Dispatcher, set to 1 for as fair as possible\n\t\t\tthroughput = 30\n\t\t}\n\t\t\n\t\t# Dispatcher for running actors that perform blocking IO\n\t\tblocking-io-dispatcher {\n\t\t\ttype = \"Akka.Dispatch.DefaultDispatcher, Akka\"\n\t\t\texecutor = \"thread-pool-executor\"\n\t\t\tthroughput = 10\n\t\t\t\n\t\t\tthread-pool-executor {\n\t\t\t\tfixed-pool-size = 20\n\t\t\t}\n\t\t}\n\t\t\n\t\t# What happens when: actor throws an exception, actor failed to receive a message\n\t\t# (used by ask/?, explicit receive timeout)\n\t\tdefault-receive-timeout = 10s\n\t\t\n\t\t# If the mailbox is a single consumer queue\n\t\t# the actor will be scheduled on a thread that processes the\n\t\t# mailbox. Otherwise, the actor will be scheduled on a thread\n\t\t# from the thread pool\n\t\tsingle-consumer-queue = on \n\t\t\n\t\tsynchronous-io-blackboxing = on\n\t\t\n\t\tguardian-supervisor-strategy = \"Akka.Actor.DefaultSupervisorStrategy, Akka\"\n\t\t\n\t\t# Serializes and deserializes (non-primitive) messages to ensure immutability,\n\t\t# this is only intended for testing. \n\t\t# WARNING: do not change unless you know what you're doing.\n\t\t# Enabling developer-mode for production deployments is highly discouraged.\n\t\tdeveloper {\n            # enable function serialization for TestActorRef\n            serialize-function = off\n\n            # enable serialization for ReceiveTimeout\n            serialize-receive-timeout = off\n\n            # enable serialization of ActorPath\n            serialize-actor-path = off\n\n            # Enable telemetry for developer mode\n            telemetry = off\n\t\t}\n\t\t\n\t\tinstrumentation {\n\t\t\t# Whether or not to automatically generate actor metrics\n\t\t\tenabled = off\n        }\n\t\t\n\t\t# Set to on to enable quarantine of OnFailure termination strategy\n\t\t# Attaches a MonitoredByCorrelationId to all messages processed by the actor\n\t\t# WARNING: do not change unless you know what you're doing\n\t\tquarantine-on-failure = off\n\t\t\n\t\tdebug {\n\t\t\t# enable DEBUG logging of all AutoReceiveMessages (Kill, PoisonPill etc.)\n\t\t\treceive = off\n\t\t\t\n\t\t\t# enable DEBUG logging of actor lifecycle changes\n\t\t\tlifecycle = off\n\t\t\t\n\t\t\t# enable DEBUG logging of all LoggingFSMs for events, transitions and timers\n\t\t\tfsm = off\n\t\t\t\n\t\t\t# enable DEBUG logging of subscription changes on the eventStream\n\t\t\tevent-stream = off\n\t\t\t\n\t\t\t# enable DEBUG logging of unhandled messages\n\t\t\tunhandled = off\n\t\t\t\n\t\t\t# enable WARN logging of misconfigured routers\n\t\t\trouter-misconfiguration = off\n\t\t}\n\t}\n\n    scheduler {\n        # The LightArrayRevolverScheduler implementation is used as the default \n        # scheduler in the system. It does not execute the scheduled tasks on exact\n        # time, but on every tick, it will run everything that is (over)due.\n        # Ticks are scheduled using the configured \"tick-duration\" and is fixed\n        # delay execution in the executor configured in \"tick-executor\".\n        implementation = \"Akka.Actor.LightArrayRevolverScheduler, Akka\"\n        \n        # The scheduling interval for the Revolving Wheel.\n        tick-duration = 200ms\n        # The executor to schedule the ticks on.\n        tick-executor = \"default-executor\"\n\t\t\n        # When shutting down the scheduler, there will typically be a thread which\n        # needs to be stopped, and this timeout determines how long to wait for\n        # that to happen. In case of timeout the shutdown of the actor system will\n        # proceed without running possibly still enqueued tasks.\n        shutdown-timeout = 5s\n    }\n\t\n\t# Serializes and deserializes actors using proto buf\n\tserial-versions = {}\n\t\n\t# Used as default serializer if no configured class can be matched to the class to be serialization\n\t# should be one of the serializers defined under akka.actor.serialization-bindings\n\tserializers {\n\t\tproto = \"Akka.Serialization.ProtobufSerializer, Akka\"\n\t\tjson = \"Akka.Serialization.NewtonSoftJsonSerializer, Akka\"\n\t\tbytesbe = \"Akka.Serialization.ByteArraySerializer, Akka\"\n\t\tbytesmem = \"Akka.Serialization.MemoryPoolByteArraySerializer, Akka\"\n\t\tack = \"Akka.Serialization.AckSerializer, Akka\"\n\t}\n\t\n\t# class name of binding => serializer to be used\n\tserilization-bindings {\n\t\t\"System.Byte[]\" = bytesmem\n\t\t\"System.Object\" = json\n\t\t\"Google.ProtocolBuffers.IMessage, Google.ProtocolBuffers\" = proto\n\t\t\"Akka.Serialization.Serialization+AckISerializable, Akka\" = ack\n\t}\n\t\n\t# Configuration for the default serializer\n\tserializer-config {\n\t\t# To be used with Akka.Serialization.AckSerializer\n\t\tack {\n\t\t\ttype = \"Akka.Serialization.AckSerializer, Akka\"\n\t\t}\n\t\t\n\t\tproto {\n\t\t\ttype = \"Akka.Serialization.ProtobufSerializer, Akka\"\n\t\t}\n\t\t\n\t\tjson {\n\t\t\ttype = \"Akka.Serialization.NewtonSoftJsonSerializer, Akka\"\n\t\t\t\n\t\t\tindented = off\n\t\t\t\n\t\t\t# Number of objects cached by the serializer\n\t\t\tserializer-cache-size = 1024\n\t\t\t\n\t\t\tpreserveObjectReferences = off\n\t\t}\n\t\t\n\t\tdiagnostics {\n\t\t\t# Set to on to enable serializer-verification. When enabled, the serializer will\n\t\t\t# verify that a message can be serialized/deserialized. If it can't, the system\n\t\t\t# falls back to the previous serializer. If no serializers can serialize the message,\n\t\t\t# Akka will fall back to the default serializer.\n\t\t\tserializer-verification = off\n\t\t}\n\t}\n\t\n\t# Entries for pluggable serializers and their bindings.\n\tserializers {}\n\t\n\t# Class to Serializer binding. You only need to specify the name of an interface\n\t# or class here if you want it to be serialized when it's sent across the wire.\n\t# Classes extending ISerializable are always serialized, so they don't need to be\n\t# included here.\n\tserilization-bindings {}\n\t\n\t# Additional serialization settings\n\tserializer-settings {}\n\t\n\texecution-context {\n\t\t# The ID of the bounded mailbox to be used by the we dispatcher \n\t\tdefault-mailbox {\n\t\t\t# Any MailboxType can be used here, for example: Akka.Dispatch.SingleConsumerOnlyUnboundedMailbox\n\t\t\tmailbox-type = \"\"\n\t\t\t# If the mailbox is bounded then it uses this setting to determine its capacity\n\t\t\tmailbox-capacity = 1000\n\t\t\t# If the mailbox is bounded then this is the timeout for enqueueing\n\t\t\tmailbox-push-timeout-time = 10s\n\t\t}\n\t\t\n\t\t# How long time the dispatcher will wait for new actors until it shuts down\n\t\tdefault-shutdown-timeout = 1s\n\t}\n\n\t# Used to set the behavior of the AkkaSystem, wether its responsible for \n\t# creating the Threadpool for your actors. \n\tdefault-executor {\n\t\t# Valid options: fork-join-executor, thread-pool-executor,custom-executor\n\t\texecutor = \"fork-join-executor\"\n\t}\n\t\n\t# Configuration namespace of default threadpool-based dispatcher\n\tthread-pool-executor {\n\t\t\t# Keep alive time for threads\n\t\tkeep-alive-time = 60s\n\t\t\t\n\t\t# Define a fixed thread pool size with this property. The corePoolSize\n\t\t# will not grow and shrink. This is the default for this executor.\n\t\tfixed-pool-size = 4\n\t\t\t\n\t\t# Min number of threads to cap factor-based corePoolSize number to.\n\t\tcore-pool-size-min = 8\n\t\t\t\n\t\t# The core-pool-size-factor is used to determine corePoolSize using the\n\t\t# following formula: ceil(available processors * factor).\n\t\t# Resulting size is then bounded by the core-pool-size-min and\n\t\t# core-pool-size-max values.\n\t\tcore-pool-size-factor = 2.0\n\t\t\t\n\t\t# Max number of threads to cap factor-based corePoolSize number to.\n\t\tcore-pool-size-max = 16\n\t\t\t\n\t\t# Minimum number of threads to cap factor-based maximumPoolSize number to.\n\t\tmax-pool-size-min = 8\n\t\t\t\n\t\t# The max-pool-size-factor is used to determine maximumPoolSize using the\n\t\t# following formula: ceil(available processors * factor)\n\t\t# The maximumPoolSize will not be less than corePoolSize.\n\t\t# It is only used if using a bounded task queue.\n\t\tmax-pool-size-factor = 2.0\n\t\t\t\n\t\t# Max number of threads to cap factor-based maximumPoolSize number to.\n\t\tmax-pool-size-max = 16\n\t\t\t\n\t\ttask-queue-size = 32768\n        task-queue-type = LINKED\n\t}\n\t\n\t# Configuration namespace of fork-join-executor dispatcher\n\tfork-join-executor {\n\t\t# Min number of threads to cap factor-based parallelism number to.\n\t\tparallelism-min = 8\n\t\t\n\t\t# The parallelism factor is used to determine thread pool size using the\n\t\t# following formula: ceil(available processors * factor). Resulting size\n\t\t# is then bounded by the parallelism-min and parallelism-max values.\n\t\tparallelism-factor = 1.0\n\t\t\n\t\t# Max number of threads to cap factor-based parallelism number to.\n\t\tparallelism-max = 16\n\t\t\n\t\ttask-queue-size = 32768\n\t}\n\n\t# Value types providers, only used for serialization (with typehints) so far\n\tvalue-types-providers {\n\t}\n\n    # Serialization uses serializer-bindings as configuration\n    serialization {\n        # This setting configures serialization queues and how many operations it can\n        # fit in a single ActorMessage (processed at once).\n        throughput = 10\n    }\n\n\t# Used to configure Loggers\n\tlogger-startup-timeout = 30s\n\n\texceptions {\n\t\t# Fully qualified class name of the UnhandledExceptionHandler\n\t\t# The handler is used for logging and the message of the exception will be thrown out\n\t\tunhandled {\n\t\t\thandler-class = \"Akka.Event.DefaultUnhandledExceptionHandler, Akka\"\n\t\t}\n\t}\n\n\tdot-net {\n\t\t# Objects sent in AskDotNet operations will be wrapped in this type name.\n\t\tserializer-wrapper-name = \"AskValueWrapper\"\n\t}\n\n    # Configuration of the transport used to communicate with other nodes in the cluster\n    remote {\n        # Default configuration which applies to all of the transport types\n        transport-failure-detector {\n            # FQCN of the failure detector implementation.\n            # It must implement akka.remote.FailureDetector and have\n            # a public constructor with a com.typesafe.config.Config and\n            # akka.actor.EventStream parameter.\n            implementation-class = \"Akka.Remote.DeadlineFailureDetector, Akka.Remote\"\n\n            # How often keep-alive heartbeat messages should be sent to each connection.\n            heartbeat-interval = 4 s\n\n            # Number of potentially lost/delayed heartbeats that will be\n            # accepted before considering it to be an anomaly.\n            # A margin to the +/- 50% failure detection threshold is important to\n            # be able to survive sudden, occasional, pauses in heartbeat arrivals,\n            # due to for example garbage collect or network drop.\n            acceptable-heartbeat-pause = 20 s\n        }\n\n        # Settings for the Phi accrual failure detector (used for remote death watch) \n        watch-failure-detector {\n            # FQCN of the failure detector implementation; Inherits from MultipleAssociationsFailureDetector\n            implementation-class = \"Akka.Remote.PhiAccrualFailureDetector, Akka.Remote\"\n\n            # How often keep-alive heartbeat messages should be sent to each connection.\n            heartbeat-interval = 1 s\n\n            # Defines the failure detector threshold; A low threshold is prone to generate many false positives, while a high threshold will generate false negatives.\n            # The threshold usually triggered by a sudden, steep increase in response latency rather than a mild, sustained increase in latency.\n            # The phi accrual failure detector measures this latency and filter by what is considered \"normal\", allowing some room for sustained latency increase.\n            # The default threshold for a 1 second heartbeat interval is 8 and that is considered to be a good default value. Adjust to the same value your transport-failure-detector threshold (in this case 12)\n            threshold = 12.0\n\n            # Number of potentially lost/delayed heartbeats that will be\n            # accepted before considering it to be an anomaly.\n            # A margin to the +/- 50% failure detection threshold is important to\n            # be able to survive sudden, occasional, pauses in heartbeat arrivals,\n            # due to for example garbage collect or network drop.\n            acceptable-heartbeat-pause = 10 s\n\n            # Maximum burst time window, for PhiAccrualFailureDetector\n            min-std-deviation = 100 ms\n\n            # Configures the size of the max-sample-size ring buffer\n            # Sample window to keep data\n            max-sample-size = 1000\n\n            # Minimum size of window we'd like to use\n            min-samples = 2\n        }\n\n        ### Configuration for the Gossip failure detector to check remote systems for stability\n        system-message-buffer-size = 1000\n\n        # This failure detector will be used for in remote death watch\n        system-failure-detector = {\n            \n            # FQCN of the failure detector implementation; Inherits from MultipleAssociationsFailureDetector\n            implementation-class = \"Akka.Remote.PhiAccrualFailureDetector, Akka.Remote\"\n\n            # How often keep-alive heartbeat messages should be sent to each connection.\n            heartbeat-interval = 1 s\n\n            # Defines the failure detector threshold;  A low threshold is prone to generate many false positives, while a high threshold will generate false negatives.\n            # The threshold usually triggered by a sudden, steep increase in response latency rather than a mild, sustained increase in latency.\n            # The phi accrual failure detector measures this latency and filter by what is considered \"normal\", allowing some room for sustained latency increase.\n            # The default threshold for a 1 second heartbeat interval is 8 and that is considered to be a good default value.\n            threshold = 8.0\n\n            # Number of potentially lost/delayed heartbeats that will be\n            # accepted before considering it to be an anomaly.\n            # A margin to the +/- 50% failure detection threshold is important to\n            # be able to survive sudden, occasional, pauses in heartbeat arrivals,\n            # due to for example garbage collect or network drop.\n            acceptable-heartbeat-pause = 10 s\n\n            # Maximum burst time window, for PhiAccrualFailureDetector\n            min-std-deviation = 100 ms\n\n            # Configures the size of the max-sample-size ring buffer\n            # Sample window to keep data\n            max-sample-size = 1000\n\n            # Minimum size of window we'd like to use\n            min-samples = 2\n        }\n\n        # How many retries should be made to a node, before it's being disconnected\n        retry-window = 3s\n        # Time between retries.\n        retry-delay = 1s\n        # Maximum number of connection attempts before unreachable connection\n        maximum-retries-in-window = 5\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Serializer with String Manifest in C#\nDESCRIPTION: This code snippet demonstrates how to implement a custom serializer with a string manifest in C#. It includes methods for serialization and deserialization, as well as manifest handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/serialization/serialization.md#2025-04-16_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\npublic class CustomerSerializer : SerializerWithStringManifest\n{\n    public CustomerSerializer(ExtendedActorSystem system) : base(system)\n    {\n    }\n\n    public override int Identifier => 1234567;\n\n    public override byte[] ToBinary(object obj)\n    {\n        var customer = (Customer)obj;\n        // implement customer serialization here\n        // return serialized bytes\n    }\n\n    public override object FromBinary(byte[] bytes, string manifest)\n    {\n        switch (manifest)\n        {\n            case \"customer\":\n                // implement customer deserialization here\n                // return customer instance\n            default:\n                throw new SerializationException($\"Unimplemented deserialization of manifest [{manifest}] in CustomerSerializer\");\n        }\n    }\n\n    public override string Manifest(object o)\n    {\n        switch (o)\n        {\n            case Customer _:\n                return \"customer\";\n            default:\n                throw new SerializationException($\"Unimplemented Manifest for type {o.GetType()}\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Complete Cluster Listener in Akka.NET\nDESCRIPTION: A full implementation of a SimpleClusterListener that subscribes to cluster events, handles different event types, and properly manages subscriptions during actor lifecycle. This showcases the pattern for monitoring cluster state changes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-extension.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic class SimpleClusterListener : UntypedActor\n{\n    protected ILoggingAdapter Log = Context.GetLogger();\n    protected Akka.Cluster.Cluster Cluster = Akka.Cluster.Cluster.Get(Context.System);\n\n    /// <summary>\n    /// Need to subscribe to cluster changes\n    /// </summary>\n    protected override void PreStart()\n    {\n        // subscribe to IMemberEvent and UnreachableMember events\n        Cluster.Subscribe(Self, ClusterEvent.InitialStateAsEvents,\n            new []{ typeof(ClusterEvent.IMemberEvent), typeof(ClusterEvent.UnreachableMember) });\n    }\n\n    /// <summary>\n    /// Re-subscribe on restart\n    /// </summary>\n    protected override void PostStop()\n    {\n        Cluster.Unsubscribe(Self);\n    }\n\n    protected override void OnReceive(object message)\n    {\n        var up = message as ClusterEvent.MemberUp;\n        if (up != null)\n        {\n            var mem = up;\n            Log.Info(\"Member is Up: {0}\", mem.Member);\n        } else if(message is ClusterEvent.UnreachableMember)\n        {\n            var unreachable = (ClusterEvent.UnreachableMember) message;\n            Log.Info(\"Member detected as unreachable: {0}\", unreachable.Member);\n        }\n        else if (message is ClusterEvent.MemberRemoved)\n        {\n            var removed = (ClusterEvent.MemberRemoved) message;\n            Log.Info(\"Member is Removed: {0}\", removed.Member);\n        }\n        else if (message is ClusterEvent.IMemberEvent)\n        {\n            //IGNORE\n        }\n        else\n        {\n            Unhandled(message);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Streams with External Email Service using SelectAsync in C#\nDESCRIPTION: This example demonstrates how to use SelectAsync to integrate a stream with an external email service. It processes tweets, looks up email addresses, and sends emails using external services.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar authors = tweets\n    .Where(t => t.HashTags.Contains(\"Akka.Net\"))\n    .Select(t => t.Author);\n\nvar emailAddresses = authors\n    .SelectAsync(4, author => AddressSystem.LookUpEmail(author.Handle))\n    .Collect(s => string.IsNullOrWhiteSpace(s) ? null : s);\n\nvar sendEmails = emailAddresses.SelectAsync(4, address =>\n    EmailServer.Send(\n        new Email(to: address, title: \"Akka.Net\", body: \"I like your tweet\"))\n    )\n    .To(Sink.Ignore<int>());\n\nsendEmails.Run(materializer);\n```\n\n----------------------------------------\n\nTITLE: Implementing Map Transformation Stage in C#\nDESCRIPTION: This snippet implements a `Map` transformation using a GraphStage in Akka.NET. It allows each input element to be transformed to an output element using a provided function.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/custom-stream-processing.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nclass Map<TIn, TOut> : GraphStage<FlowShape<TIn, TOut>>\n{\n    private sealed class Logic : GraphStageLogic\n    {\n        public Logic(Map<TIn, TOut> map) : base(map.Shape)\n        {\n            SetHandler(map.In, onPush: () => Push(map.Out, map._func(Grab(map.In))));\n            SetHandler(map.Out, onPull: ()=> Pull(map.In));\n        }\n    }\n\n    private readonly Func<TIn, TOut> _func;\n\n    public Map(Func<TIn, TOut> func)\n    {\n        _func = func;\n        Shape = new FlowShape<TIn, TOut>(In, Out);\n    }\n\n    public Inlet<TIn> In { get; } = new Inlet<TIn>(\"Map.in\");\n\n    public Outlet<TOut> Out { get; } = new Outlet<TOut>(\"Map.out\");\n\n    public override FlowShape<TIn, TOut> Shape { get; }\n\n    protected override GraphStageLogic CreateLogic(Attributes inheritedAttributes) => new Logic(this);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Message Types for Akka.NET FSM Actor\nDESCRIPTION: This code defines the message types used by the Buncher FSM actor, including SetTarget, Queue, Flush, and Batch messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/finite-state-machine.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/core/Akka.Docs.Tests/Actors/FiniteStateMachine/FiniteStateMachine.Messages.cs?name=FSMEvents)]\n```\n\n----------------------------------------\n\nTITLE: Implementing Core Serialization Manager in Akka.NET\nDESCRIPTION: Defines the main Serialization class that manages serializers and handles serialization operations in Akka.NET. It provides methods for registering serializers, serializing/deserializing objects, and managing serialization transport context.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_198\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Serialization\n{\n    public Serialization(Akka.Actor.ExtendedActorSystem system) { }\n    public Akka.Actor.ExtendedActorSystem System { get; }\n    public void AddSerializationMap(System.Type type, Akka.Serialization.Serializer serializer) { }\n    [System.ObsoleteAttribute(\"No longer supported. Use the AddSerializer(name, serializer) overload instead.\", true)]\n    public void AddSerializer(Akka.Serialization.Serializer serializer) { }\n    public void AddSerializer(string name, Akka.Serialization.Serializer serializer) { }\n    public object Deserialize(byte[] bytes, int serializerId, System.Type type) { }\n    public object Deserialize(byte[] bytes, int serializerId, string manifest) { }\n    public Akka.Actor.IActorRef DeserializeActorRef(string path) { }\n    public Akka.Serialization.Serializer FindSerializerFor(object obj, string defaultSerializerName = null) { }\n    public Akka.Serialization.Serializer FindSerializerForType(System.Type objectType, string defaultSerializerName = null) { }\n    public static Akka.Serialization.Information GetCurrentTransportInformation() { }\n    public static string ManifestFor(Akka.Serialization.Serializer s, object msg) { }\n    public byte[] Serialize(object o) { }\n    public static string SerializedActorPath(Akka.Actor.IActorRef actorRef) { }\n    [System.ObsoleteAttribute(\"Obsolete. Use the SerializeWithTransport<T>(ExtendedActorSystem) method instead.\")]\n    public static T WithTransport<T>(Akka.Actor.ActorSystem system, Akka.Actor.Address address, System.Func<T> action) { }\n    public static T WithTransport<T>(Akka.Actor.ExtendedActorSystem system, System.Func<T> action) { }\n    public static T WithTransport<TState, T>(Akka.Actor.ExtendedActorSystem system, TState state, System.Func<TState, T> action) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract UnboundedPriorityMailbox Class in C#\nDESCRIPTION: Abstract class for implementing priority-based mailboxes in Akka.NET. Derived classes must provide a priority generator function to determine message ordering based on custom logic.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_104\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class UnboundedPriorityMailbox : Akka.Dispatch.MailboxType, Akka.Dispatch.IProducesMessageQueue<Akka.Dispatch.MessageQueues.UnboundedPriorityMessageQueue>\n{\n    public const int DefaultCapacity = 11;\n    protected UnboundedPriorityMailbox(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }\n    public int InitialCapacity { get; }\n    public virtual Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }\n    protected abstract int PriorityGenerator(object message);\n}\n```\n\n----------------------------------------\n\nTITLE: HOCON Configuration for Contact Auto-Discovery\nDESCRIPTION: Demonstrates the HOCON configuration needed to set up ClusterClient contact auto-discovery. This includes enabling the feature, specifying the discovery method, and configuring service and actor system names.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-client.md#2025-04-16_snippet_14\n\nLANGUAGE: text\nCODE:\n```\nakka.cluster.client\n{\n  use-initial-contacts-discovery = false\n\n  discovery\n  {\n    method = <method>\n    actor-system-name = null\n    receptionist-name = receptionist\n    service-name = null\n    port-name = null\n    discovery-retry-interval = 1s\n    discovery-timeout = 60s\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cluster-Aware Router Groups in HOCON\nDESCRIPTION: HOCON configuration for creating role-based cluster-aware router groups that automatically route messages to actors deployed on nodes with specific roles.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/member-roles.md#2025-04-16_snippet_10\n\nLANGUAGE: hocon\nCODE:\n```\nakka\n{\n   actor\n   {\n      provider = \"Akka.Cluster.ClusterActorRefProvider, Akka.Cluster\"\n      deployment\n      {\n         /webdispatcher\n         {\n            router = consistent-hashing-group # routing strategy\n            routees.paths = [\"/user/web\"] # path of routee on each node\n            nr-of-instances = 3 # max number of total routees\n            cluster\n            {\n               enabled = on\n               use-role = \"web\"\n            }\n         }\n         /frauddispatcher\n         {\n            router = consistent-hashing-group # routing strategy\n            routees.paths = [\"/user/fraud\"] # path of routee on each node\n            nr-of-instances = 3 # max number of total routees\n            cluster\n            {\n               enabled = on\n               use-role = \"fraud\"\n            }\n         }\n         /billingdispatcher\n         {\n            router = consistent-hashing-group # routing strategy\n            routees.paths = [\"/user/billing\"] # path of routee on each node\n            nr-of-instances = 3 # max number of total routees\n            cluster\n            {\n               enabled = on\n               use-role = \"billing\"\n            }\n         }\n         /orderdispatcher\n         {\n            router = consistent-hashing-group # routing strategy\n            routees.paths = [\"/user/order\"] # path of routee on each node\n            nr-of-instances = 3 # max number of total routees\n            cluster\n            {\n               enabled = on\n               use-role = \"order\"\n            }\n         }\n         /storagedispatcher\n         {\n            router = consistent-hashing-group # routing strategy\n            routees.paths = [\"/user/storage\"] # path of routee on each node\n            nr-of-instances = 3 # max number of total routees\n            cluster\n            {\n               enabled = on\n               use-role = \"storage\"\n            }\n         }\n      }\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Advanced Service Lookup with Port and Protocol\nDESCRIPTION: Shows how to create a service lookup with additional specifications for port name and protocol, returning a Task with the resolved service.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/discovery/index.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nTask<ServiceDiscovery.Resolved> lookup = serviceDiscovery.Lookup(\n    new Lookup(\"akka.io\").WithPortName(\"remoting\").WithProtocol(\"tcp\"),\n    TimeSpan.FromSeconds(1));\n```\n\n----------------------------------------\n\nTITLE: Implementing BackoffSupervisor with OnFailure Strategy in C#\nDESCRIPTION: Creates a backoff supervisor that restarts a crashed actor with exponential delays between 3-30 seconds after exceptions. Uses randomFactor for distributed restart timing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/concepts/supervision.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar childProps = Props.Create<EchoActor>();\n\nvar supervisor = BackoffSupervisor.Props(\n    Backoff.OnFailure(\n        childProps,\n        childName: \"myEcho\",\n        minBackoff: TimeSpan.FromSeconds(3),\n        maxBackoff: TimeSpan.FromSeconds(30),\n        randomFactor: 0.2));\n\nsystem.ActorOf(supervisor, \"echoSupervisor\");\n```\n\n----------------------------------------\n\nTITLE: Using Materialized Values in Event Queries in C#\nDESCRIPTION: Example of using materialized values to access query metadata and process events with logging.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistence-query.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nvar query = readJournal.ByTagsWithMeta(ImmutableHashSet.Create(\"red\", \"blue\"));\nquery\n    .MapMaterializedValue(meta =>\n    {\n        Console.WriteLine(\n            $\"The query is: ordered deterministically: {meta.DeterministicOrder}, infinite: {meta.Infinite}\");\n        return meta;\n    })\n    .Select(evt =>\n    {\n        Console.WriteLine($\"Event payload: {evt.Payload}\");\n        return evt;\n    })\n    .RunWith(Sink.Ignore<RichEvent>(), mat);\n```\n\n----------------------------------------\n\nTITLE: Untyped Actor Base Class\nDESCRIPTION: Abstract base class for untyped actors with message handling capabilities\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_54\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class UntypedActor : Akka.Actor.ActorBase\n{\n    protected UntypedActor() { }\n    protected static Akka.Actor.IUntypedActorContext Context { get; }\n    protected void Become(Akka.Actor.UntypedReceive receive) { }\n    protected void BecomeStacked(Akka.Actor.UntypedReceive receive) { }\n    protected abstract void OnReceive(object message);\n    protected virtual bool Receive(object message) { }\n    protected void RunTask(System.Action action) { }\n    protected void RunTask(System.Func<System.Threading.Tasks.Task> action) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Confirmable Messages with AskNextTo in Akka.Delivery\nDESCRIPTION: Code showing how to use the AskNextTo method to get confirmation when messages are persisted. The producer receives the sequence number after the message has been stored in the EventSourcedProducerQueue.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/reliable-delivery.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nclass Producer : ReceiveActor\n{\n    private IActorRef _controller;\n    private long _nextSequenceNr = 0;\n    \n    public Producer(IActorRef controller)\n    {\n        _controller = controller;\n        \n        Receive<string>(message => {\n            var nextMsg = new ProducerController.RequestNext<string>(\n                AskNextTo: Self,\n                MessageMapper: _ => message);\n                \n            _controller.Tell(nextMsg);\n        });\n        \n        Receive<ProducerController.MessageWithConfirmation<string>>(confirmed => {\n            _nextSequenceNr = confirmed.SequenceNr;\n            // message with sequence number confirmed.SequenceNr has been persisted\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Flow with Akka.NET in C#\nDESCRIPTION: This snippet illustrates the creation of a Flow in Akka.NET using the GraphDSL. It broadcasts an integer stream into two branches before zipping the integer with its string representation. The functionality requires Akka.NET libraries and a compatible materializer for execution.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithgraphs.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar pairUpWithToString = Flow.FromGraph(\n    GraphDsl.Create(b =>\n    {\n        // prepare graph elements\n        var broadcast = b.Add(new Broadcast<int>(2));\n        var zip = b.Add(new Zip<int, string>());\n\n        // connect the graph\n        b.From(broadcast.Out(0)).Via(Flow.Create<int>().Select(x => x)).To(zip.In0);\n        b.From(broadcast.Out(1)).Via(Flow.Create<int>().Select(x => x.ToString())).To(zip.In1);\n\n        // expose ports\n        return new FlowShape<int, Tuple<int, string>>(broadcast.In, zip.Out);\n    }));\n\npairUpWithToString.RunWith(Source.From(new[] {1}), Sink.First<Tuple<int, string>>(), materializer);\n```\n\n----------------------------------------\n\nTITLE: Querying All Persistence IDs in Akka.NET\nDESCRIPTION: This snippet shows how to retrieve all persistence IDs of persistent actors using the AllPersistenceIds query. It demonstrates obtaining the read journal and creating a source of persistence IDs.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistence-query.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar queries = PersistenceQuery.Get(actorSystem)\n    .ReadJournalFor<SqlReadJournal>(\"akka.persistence.query.my-read-journal\");\n\nvar mat = ActorMaterializer.Create(actorSystem);\nSource<string, NotUsed> src = queries.AllPersistenceIds();\n```\n\n----------------------------------------\n\nTITLE: Actor System Class Definition\nDESCRIPTION: Core actor system class providing actor lifecycle management, extension support, and system services.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ActorSystem : Akka.Actor.IActorRefFactory, System.IDisposable\n{\n    protected ActorSystem() { }\n    public abstract Akka.Actor.IActorRef DeadLetters { get; }\n    public abstract Akka.Dispatch.Dispatchers Dispatchers { get; }\n    public abstract Akka.Event.EventStream EventStream { get; }\n    public abstract Akka.Actor.IActorRef IgnoreRef { get; }\n    public abstract Akka.Event.ILoggingAdapter Log { get; }\n    public abstract Akka.Dispatch.Mailboxes Mailboxes { get; }\n    public abstract string Name { get; }\n    public abstract Akka.Actor.IScheduler Scheduler { get; }\n    public abstract Akka.Serialization.Serialization Serialization { get; }\n    public abstract Akka.Actor.Settings Settings { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ShardRegion Class in Akka.NET Sharding\nDESCRIPTION: This class is an actor that manages a set of shards. It is responsible for routing messages to the correct entity within a shard. The constructor takes in the entity props factory, settings, coordinator path, message extractor, handoff stop message, and remember entities provider.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\n    [Akka.Annotations.InternalStableApiAttribute()]\n    [System.Runtime.CompilerServices.NullableAttribute(0)]\n    public sealed class ShardRegion : Akka.Actor.ActorBase, Akka.Actor.IWithTimers\n    {\n        public ShardRegion(string typeName, [System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n                2,\n                1,\n                1})] System.Func<string, Akka.Actor.Props> entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, string coordinatorPath, Akka.Cluster.Sharding.IMessageExtractor messageExtractor, object handOffStopMessage, [System.Runtime.CompilerServices.NullableAttribute(2)] Akka.Cluster.Sharding.Internal.IRememberEntitiesProvider rememberEntitiesProvider) { }\n        public Akka.Actor.ITimerScheduler Timers { get; set; }\n        protected override void PostStop() { }\n        protected override void PreStart() { }\n        protected override bool Receive(object message) { }\n        [System.Runtime.CompilerServices.NullableAttribute(0)]\n        public sealed class StartEntity : Akka.Cluster.Sharding.IClusterShardingSerializable, System.IEquatable<Akka.Cluster.Sharding.ShardRegion.StartEntity>\n        {\n            public readonly string EntityId;\n            public StartEntity(string entityId) { }\n            public override bool Equals(object obj) { }\n            public bool Equals(Akka.Cluster.Sharding.ShardRegion.StartEntity other) { }\n            public override int GetHashCode() { }\n            public override string ToString() { }\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Initializing Circuit Breaker in Akka.NET\nDESCRIPTION: Demonstrates how to configure a CircuitBreaker with specific parameters for maximum failures, call timeout, and reset timeout.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/circuit-breaker.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar breaker = new CircuitBreaker(\n    scheduler,\n    maxFailures: 5,\n    callTimeout: TimeSpan.FromSeconds(10),\n    resetTimeout: TimeSpan.FromMinutes(1));\n```\n\n----------------------------------------\n\nTITLE: Implementing LoggingBus Class in C#\nDESCRIPTION: Core implementation of the logging event bus that extends ActorEventBus. It manages log levels and provides methods for classifying and publishing log events to appropriate subscribers based on event types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_133\n\nLANGUAGE: C#\nCODE:\n```\npublic class LoggingBus : Akka.Event.ActorEventBus<object, System.Type>\n{\n    public LoggingBus() { }\n    public Akka.Event.LogLevel LogLevel { get; }\n    protected override bool Classify(object @event, System.Type classifier) { }\n    protected override System.Type GetClassifier(object @event) { }\n    protected override bool IsSubClassification(System.Type parent, System.Type child) { }\n    protected override void Publish(object @event, Akka.Actor.IActorRef subscriber) { }\n    public void SetLogLevel(Akka.Event.LogLevel logLevel) { }\n    public void StartStdoutLogger(Akka.Actor.Settings config) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Domain Events for Persistent FSM in C#\nDESCRIPTION: Domain events definition for a WebStoreCustomerFSMActor that are persisted and replayed to restore the customer's state. These events track customer actions in the web store.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistent-fsm.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Filter Transformation Stage in C#\nDESCRIPTION: This snippet implements a `Filter` transformation stage. It only propagates the element downstream if it matches a given predicate.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/custom-stream-processing.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nclass Filter<T> : GraphStage<FlowShape<T, T>>\n{\n    private sealed class Logic : GraphStageLogic\n    {\n        public Logic(Filter<T> filter) : base(filter.Shape)\n        {\n            SetHandler(filter.In, onPush: () =>\n            {\n                var element = Grab(filter.In);\n                if(filter._predicate(element))\n                    Push(filter.Out, element);\n                else\n                    Pull(filter.In);\n            });\n\n            SetHandler(filter.Out, onPull: ()=> Pull(filter.In));\n        }\n    }\n\n    private readonly Predicate<T> _predicate;\n\n    public Filter(Predicate<T> predicate)\n    {\n        _predicate = predicate;\n        Shape = new FlowShape<T, T>(In, Out);\n    }\n\n    public Inlet<T> In { get; } = new Inlet<T>(\"Filter.in\");\n\n    public Outlet<T> Out { get; } = new Outlet<T>(\"Filter.out\");\n\n    public override FlowShape<T, T> Shape { get; }\n\n    protected override GraphStageLogic CreateLogic(Attributes inheritedAttributes) => new Logic(this);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IWithStash Interface for Message Stashing in Akka.NET\nDESCRIPTION: Demonstrates how to implement the IWithStash interface to temporarily store messages that cannot be handled by the actor's current behavior, and then process them later when the actor's state changes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_30\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ActorWithProtocol : ReceiveActor, IWithStash\n{\n    public IStash Stash { get; set; }\n\n    public ActorWithProtocol()\n    {\n        Receive<string>(s => s.Equals(\"open\"), open =>\n        {\n            Stash.UnstashAll();\n\n            BecomeStacked(() =>\n            {\n                Receive<string>(s => s.Equals(\"write\"), write =>\n                {\n                    // do writing...\n                });\n\n                Receive<string>(s => s.Equals(\"close\"), write =>\n                {\n                    Stash.UnstashAll();\n                    Context.UnbecomeStacked();\n                });\n\n                ReceiveAny(_ => Stash.Stash());\n            });\n        });\n\n        ReceiveAny(_ => Stash.Stash());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Logging All Received Messages in Akka.NET Actor\nDESCRIPTION: This code snippet is an implementation example of an Akka.NET actor that logs all received messages. It utilizes the ILogReceive interface for detailed logging of handled messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/logging.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyActor : ReceiveActor, ILogReceive\n{\n    public MyActor()\n    {\n        Receive<string>(s => Sender.Tell(\"ok\"));\n    }\n}\n\n...\n\n// send a MyActor instance a string message\nmyActor.Tell(\"hello\");\n```\n\n----------------------------------------\n\nTITLE: Retrieving Current Cluster State On-Demand in C#\nDESCRIPTION: This snippet demonstrates how to use the SendCurrentClusterState method to get a snapshot of the current cluster state. It sends the state to the current actor (Self).\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-extension.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// get the current state of cluster\nCluster.SendCurrentClusterState (Self);\n```\n\n----------------------------------------\n\nTITLE: Testing a Flow with Custom Source and Sink in C#\nDESCRIPTION: This snippet demonstrates testing a flow by attaching a custom source and sink, allowing control over input data and easier assertions on the output.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/testingstreams.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar flowUnderTest = Flow.Create<int>().TakeWhile(x => x < 5);\n\nvar task = Source.From(Enumerable.Range(1, 10))\n    .Via(flowUnderTest)\n    .RunWith(Sink.Aggregate<int, List<int>>(new List<int>(), (list, i) =>\n    {\n        list.Add(i);\n        return list;\n    }), materializer);\n\ntask.Wait(TimeSpan.FromMilliseconds(500)).Should().BeTrue();\ntask.Result.ShouldAllBeEquivalentTo(Enumerable.Range(1, 4));\n```\n\n----------------------------------------\n\nTITLE: Creating Child Actor with Test Probe Parent\nDESCRIPTION: Example showing how to create a child actor using a TestProbe as the parent for testing purposes\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/testing-actor-systems.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nFunc<IUntypedActorContext, IActorRef> maker = (ctx) => probe.Ref;\nvar parent = Sys.ActorOf(Props.Create<GenericDependentParent>(maker));\n```\n\n----------------------------------------\n\nTITLE: Implementing LoggingAdapterBase Abstract Class in C#\nDESCRIPTION: Abstract base class for logging adapters in Akka.NET. Provides common functionality for different logging implementations, including log level checking and message formatting. Concrete implementations must provide logic for enabling specific log levels and sending log notifications.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_150\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class LoggingAdapterBase : Akka.Event.ILoggingAdapter\n{\n    protected LoggingAdapterBase(Akka.Event.ILogMessageFormatter logMessageFormatter) { }\n    public Akka.Event.ILogMessageFormatter Formatter { get; }\n    public abstract bool IsDebugEnabled { get; }\n    public abstract bool IsErrorEnabled { get; }\n    public abstract bool IsInfoEnabled { get; }\n    public abstract bool IsWarningEnabled { get; }\n    public bool IsEnabled(Akka.Event.LogLevel logLevel) { }\n    public void Log(Akka.Event.LogLevel logLevel, System.Exception cause, Akka.Event.LogMessage message) { }\n    public void Log(Akka.Event.LogLevel logLevel, System.Exception cause, string format) { }\n    protected abstract void NotifyLog(Akka.Event.LogLevel logLevel, object message, System.Exception cause = null);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Counter Singleton Actor in C#\nDESCRIPTION: Example implementation of a basic counter actor that can run as a cluster singleton. Demonstrates message handling for increment, value retrieval, and graceful shutdown operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-singleton.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Counter : UntypedActor\n{\n    public sealed class Increment\n    {\n        public static Increment Instance => new Increment();\n        private Increment() { }\n    }\n\n    public sealed class GetValue\n    {\n        public IActorRef ReplyTo { get; }\n        public GetValue(IActorRef replyTo) => ReplyTo = replyTo;\n    }\n\n    public sealed class GoodByeCounter\n    {\n        public static GoodByeCounter Instance => new GoodByeCounter();\n        private GoodByeCounter() { }\n    }\n\n    private int _value;\n    \n    public static Props Props => Props.Create<Counter>();\n\n    protected override void OnReceive(object message)\n    {\n        switch (message)\n        {\n            case Increment _:\n                _value++;\n                break;\n            case GetValue msg:\n                msg.ReplyTo.Tell(_value);\n                break;\n            case GoodByeCounter _:\n                Context.Stop(Self);\n                break;\n            default:\n                base.Unhandled(message);\n                break;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ClusterSettings Class Definition\nDESCRIPTION: This snippet defines a sealed class `ClusterSettings` which encapsulates the configuration settings for Akka.Cluster. It initializes settings from a `Akka.Configuration.Config` object and system name, and exposes numerous properties to control cluster behavior such as auto-downing, failure detection, gossip intervals, heartbeat parameters, roles, and seed nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class ClusterSettings\n{\n    public ClusterSettings(Akka.Configuration.Config config, string systemName) { }\n    public bool AllowWeaklyUpMembers { get; }\n    public Akka.Util.AppVersion AppVersion { get; }\n    [System.ObsoleteAttribute(\"Deprecated as of Akka.NET v1.5.2 - clustering defaults to using KeepMajority SBR \" +\n        \"instead\")]\n    public System.Nullable<System.TimeSpan> AutoDownUnreachableAfter { get; }\n    public System.Type DowningProviderType { get; }\n    public Akka.Configuration.Config FailureDetectorConfig { get; }\n    public string FailureDetectorImplementationClass { get; }\n    public double GossipDifferentViewProbability { get; }\n    public System.TimeSpan GossipInterval { get; }\n    public System.TimeSpan GossipTimeToLive { get; }\n    public System.TimeSpan HeartbeatExpectedResponseAfter { get; }\n    public System.TimeSpan HeartbeatInterval { get; }\n    public System.TimeSpan LeaderActionsInterval { get; }\n    public bool LogInfo { get; }\n    public bool LogInfoVerbose { get; }\n    public int MinNrOfMembers { get; }\n    public System.Collections.Immutable.ImmutableDictionary<string, int> MinNrOfMembersOfRole { get; }\n    public int MonitoredByNrOfMembers { get; }\n    public System.TimeSpan PeriodicTasksInitialDelay { get; }\n    public System.Nullable<System.TimeSpan> PublishStatsInterval { get; }\n    public int ReduceGossipDifferentViewProbability { get; }\n    public System.Nullable<System.TimeSpan> RetryUnsuccessfulJoinAfter { get; }\n    public System.Collections.Immutable.ImmutableHashSet<string> Roles { get; }\n    public bool RunCoordinatedShutdownWhenDown { get; }\n    public System.TimeSpan SchedulerTickDuration { get; }\n    public int SchedulerTicksPerWheel { get; }\n    public System.TimeSpan SeedNodeTimeout { get; }\n    public System.Collections.Immutable.ImmutableList<Akka.Actor.Address> SeedNodes { get; }\n    public System.Nullable<System.TimeSpan> ShutdownAfterUnsuccessfulJoinSeedNodes { get; }\n    public System.TimeSpan UnreachableNodesReaperInterval { get; }\n    public string UseDispatcher { get; }\n    public bool UseLegacyHeartbeatMessage { get; }\n    public bool VerboseGossipReceivedLogging { get; }\n    public bool VerboseHeartbeatLogging { get; }\n    public System.TimeSpan WeaklyUpAfter { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GreetingActor in C# for Akka.NET\nDESCRIPTION: Defines the GreetingActor class which inherits from ReceiveActor. It handles Greet messages and implements PreStart and PostStop methods for actor lifecycle management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/deployment/console.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class GreetingActor : ReceiveActor\n{\n    public GreetingActor()\n    {\n        Receive<Greet>(greet =>\n            Console.WriteLine($\"Hello {greet.Name}\"));\n    }\n\n    protected override void PreStart() => Console.WriteLine(\"GreetingActor PreStart\");\n\n    protected override void PostStop() => Console.WriteLine(\"GreetingActor PostStop\");\n}\n```\n\n----------------------------------------\n\nTITLE: Configuration Class Implementation in C#\nDESCRIPTION: Core configuration class for Akka.NET that handles HOCON configuration parsing and access. Provides methods for retrieving typed configuration values and managing fallbacks.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_66\n\nLANGUAGE: C#\nCODE:\n```\npublic class Config\n{\n    public static readonly Akka.Configuration.Config Empty;\n    public Config() { }\n    public Config(Akka.Configuration.Hocon.HoconRoot root) { }\n    public Config(Akka.Configuration.Config source, Akka.Configuration.Config fallback) { }\n    public Akka.Configuration.Config Fallback { get; }\n    public virtual bool IsEmpty { get; }\n    public Akka.Configuration.Hocon.HoconValue Root { get; }\n    public System.Collections.Generic.IEnumerable<Akka.Configuration.Hocon.HoconSubstitution> Substitutions { get; set; }\n    // Additional methods omitted for brevity\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic GraphStage Structure in C#\nDESCRIPTION: Demonstrates the basic structure of a GraphStage implementation for creating a custom Source that emits numbers. Shows the definition of stage interface including output port and shape definition.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/custom-stream-processing.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Streams.Stage;\n\nclass NumbersSource : GraphStage<SourceShape<int>>\n{\n    //this is where the actual (possibly statefull) logic will live\n    private sealed class Logic : GraphStageLogic\n    {\n        public Logic(NumbersSource source) : base(source.Shape)\n        {\n        }\n    }\n\n    // Define the (sole) output port of this stage \n    public Outlet<int> Out { get; } = new Outlet<int>(\"NumbersSource\");\n\n    // Define the shape of this tage, which is SourceShape with the port we defined above\n    public override SourceShape<int> Shape => new SourceShape<int>(Out);\n\n    //this is where the actual logic will be created\n    protected override GraphStageLogic CreateLogic(Attributes inheritedAttributes) => new Logic(this);\n}\n```\n\n----------------------------------------\n\nTITLE: Akka.NET Persistent Actor Members\nDESCRIPTION: Required and specialized members available in persistent actors for managing persistence, recovery, and state management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/architecture.md#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n* PersistenceId\n* OnRecover\n* OnCommand\n* Persist\n* PersistAsync\n* DeferAsync\n* DeleteMessages\n* LoadSnapshot\n* SaveSnapshot\n* DeleteSnapshot\n* DeleteSnapshots\n* OnReplaySuccess\n* OnReplayFailure\n* IsRecovering\n* SnapshotSequenceNr\n```\n\n----------------------------------------\n\nTITLE: Implementing DeathWatch Monitoring in Akka.NET Actor\nDESCRIPTION: Demonstrates how to implement lifecycle monitoring using DeathWatch to receive Terminated messages when a watched actor stops. Shows registration using Context.Watch() and handling of termination notifications.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic class WatchActor : UntypedActor\n{\n    private IActorRef child = Context.ActorOf(Props.Empty, \"child\");\n    private IActorRef lastSender = Context.System.DeadLetters;\n\n    public WatchActor()\n    {\n        Context.Watch(child); // <-- this is the only call needed for registration\n    }\n\n    protected override void OnReceive(object message)\n    {\n        switch (message)\n        {\n            case \"kill\":\n                Context.Stop(child);\n                lastSender = Sender;\n                break;\n            case Terminated t when t.ActorRef.Equals(child):\n                lastSender.Tell(\"finished\");\n                break;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ProducerController Static Class for Message Production\nDESCRIPTION: A static class that provides factory methods for creating producer controllers, which manage the sending of messages with delivery guarantees in Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_75\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic class static ProducerController\n{\n    public static Akka.Actor.Props Create<[System.Runtime.CompilerServices.NullableAttribute(2)]  T>(Akka.Actor.IActorRefFactory actorRefFactory, string producerId, [System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})] Akka.Util.Option<Akka.Actor.Props> durableProducerQueue, [System.Runtime.CompilerServices.NullableAttribute(2)] Akka.Delivery.ProducerController.Settings settings = null, [System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            2,\n            1,\n            1})] System.Action<Akka.Delivery.ConsumerController.SequencedMessage<T>> sendAdapter = null) { }\n```\n\n----------------------------------------\n\nTITLE: Source Pre-Materialization in Akka Streams\nDESCRIPTION: Demonstrates how to pre-materialize a Source to obtain its materialized value before connecting it to a stream graph\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/basics.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n// Source pre-materialization example\nvar (mat, source) = originalSource.PreMaterialize();\n```\n\n----------------------------------------\n\nTITLE: Implementing ActorTask Class in Akka.NET\nDESCRIPTION: Definition of the ActorTask class which wraps a System.Threading.Tasks.Task. This provides a way to work with tasks within the Akka actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_92\n\nLANGUAGE: csharp\nCODE:\n```\npublic ActorTask(System.Threading.Tasks.Task task) { }\npublic System.Threading.Tasks.Task Task { get; }\n```\n\n----------------------------------------\n\nTITLE: Implementing FSM Base Class in C#\nDESCRIPTION: Abstract base class implementing Finite State Machine functionality for Akka.NET actors. Includes inner classes for state management, events, and logging.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class FSMBase : Akka.Actor.ActorBase\n{\n    protected FSMBase() { }\n    public sealed class CurrentState<TS>\n    {\n        public CurrentState(Akka.Actor.IActorRef fsmRef, TS state) { }\n        public Akka.Actor.IActorRef FsmRef { get; }\n        public TS State { get; }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IWithTimers in an Actor Class for Scheduled Messages\nDESCRIPTION: Demonstrates how to implement the IWithTimers interface in an actor to schedule recurring and one-time messages. This approach automatically handles timer disposal when the actor terminates.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/schedulers.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class TimerActor : ReceiveActor, IWithTimers\n{\n    public ITimerScheduler Timers { get; set; }\n\n    public class Tick { }\n\n    public TimerActor()\n    {\n        Receive<string>(str =>\n        {\n            switch (str)\n            {\n                case \"StartTicking\":\n                    // this message will be sent to the self actor repeatedly\n                    Timers.StartPeriodicTimer(\"TickKey\", new Tick(), TimeSpan.FromSeconds(1));\n                    break;\n                case \"StopTicking\":\n                    Timers.Cancel(\"TickKey\");\n                    break;\n                case \"Single\":\n                    // this message will be sent to the self actor once, after 500ms\n                    Timers.StartSingleTimer(\"SingleKey\", \"SingleTick\", TimeSpan.FromMilliseconds(500));\n                    break;\n            }\n        });\n\n        Receive<Tick>(tick => {\n            Console.WriteLine(\"Tick\");\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using SelectAsync with SometimesSlowService in C#\nDESCRIPTION: This snippet demonstrates how to utilize the SometimesSlowService with SelectAsync in an Akka stream. It processes a list of strings while outputting their order before and after processing, showcasing the ordering characteristics of SelectAsync.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar service = new SometimesSlowService();\nvar settings = ActorMaterializerSettings.Create(sys).WithInputBuffer(4, 4);\nvar materializer = sys.Materializer(settings);\n\nSource.From(new[] {\"a\", \"B\", \"C\", \"D\", \"e\", \"F\", \"g\", \"H\", \"i\", \"J\"})\n    .Select(x => {\n        Console.WriteLine($\"before {x}\");\n        return x;\n    })\n    .SelectAsync(4, service.Convert)\n    .RunForeach(x => Console.WriteLine($\"after: {x}\"), materializer);\n```\n\n----------------------------------------\n\nTITLE: Nested Stream Components in C#\nDESCRIPTION: Shows how to create nested stream components using Named() to establish component boundaries and create composite modules.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/modularitycomposition.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar nestedSource = \n    Source.Single(0) // An atomic source\n    .Select(x => x + 1) // an atomic processing stage\n    .Named(\"nestedSource\"); // wraps up the current Source and gives it a name\n\nvar nestedFlow =\n    Flow.Create<int>().Where(x => x != 0) // an atomic processing stage\n        .Select(x => x - 2) // another atomic processing stage\n        .Named(\"nestedFlow\"); // wraps up the Flow, and gives it a name\n\nvar nestedSink = nestedFlow\n    .To(Sink.Aggregate<int, int>(0, (sum, x) => sum + x)) // wire an atomic sink to the nestedFlow\n    .Named(\"nestedSink\"); // wrap it up\n\n// Create a RunnableGraph\nvar runnableGraph = nestedSource.To(nestedSink);\n```\n\n----------------------------------------\n\nTITLE: Replying to Messages in C#\nDESCRIPTION: Shows how to reply to messages using the Sender reference to maintain actor communication.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override void OnReceive(object message)\n{\n  var result = calculateResult();\n\n  // do not forget the second argument!\n  Sender.Tell(result, Self);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Static Result Class in C#\nDESCRIPTION: Static class with factory methods for creating Result<T> instances representing success or failure states.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_226\n\nLANGUAGE: C#\nCODE:\n```\npublic class static Result\n{\n    public static Akka.Util.Result<T> Failure<T>(System.Exception exception) { }\n    public static Akka.Util.Result<T> From<T>(System.Func<T> func) { }\n    public static Akka.Util.Result<T> FromTask<T>(System.Threading.Tasks.Task<T> task) { }\n    public static Akka.Util.Result<T> Success<T>(T value) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Actor Lifecycle Demonstration in C#\nDESCRIPTION: Shows how to implement and use PreStart() and PostStop() lifecycle hooks in actors, demonstrating the order of execution when stopping actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-1.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nclass StartStopActor1 : UntypedActor\n{\n    protected override void PreStart() { Console.WriteLine(\"first started\"); }\n    protected override void PostStop() { Console.WriteLine(\"first stopped\"); }\n\n    protected override void OnReceive(object message)\n    {\n        switch (message)\n        {\n            case \"stop\":\n                Context.Stop(Self);\n                break;\n        }\n    }\n}\n\nclass StartStopActor2 : UntypedActor\n{\n    protected override void PreStart() { Console.WriteLine(\"second started\"); }\n    protected override void PostStop() { Console.WriteLine(\"second stopped\"); }\n\n    protected override void OnReceive(object message) { }\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\nIActorRef first = system.ActorOf(Props.Create<StartStopActor1>(), \"first\");\nfirst.Tell(\"stop\");\n```\n\n----------------------------------------\n\nTITLE: Balancing Graph Cycle Using ZipWith - Akka.Net\nDESCRIPTION: This code snippet illustrates the use of ZipWith in an Akka.Net graph to balance a cycle. The function ensures that an element from the source and the feedback arc must pair together to form one cycle element, addressing the feedback arc's balance to prevent stillstands.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithgraphs.md#2025-04-16_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\n// WARNING! The graph below never processes any elements\nRunnableGraph.FromGraph(GraphDsl.Create(b =>\n{\n    var zip = b.Add(ZipWith.Apply<int, int, int>(Keep.Right));\n    var broadcast = b.Add(new Broadcast<int>(2));\n    var print = Flow.Create<int>().Select(s =>\n    {\n        Console.WriteLine(s);\n        return s;\n    });\n    \n    var sink = Sink.Ignore<int>().MapMaterializedValue(_ => NotUsed.Instance);\n    \n    b.From(source).To(zip.In0);\n    b.From(zip.Out).Via(print).Via(broadcast).To(sink);\n    b.To(zip.In1).From(broadcast);\n\n    return ClosedShape.Instance;\n}));\n```\n\n----------------------------------------\n\nTITLE: Configuring Web Role in Akka.NET Cluster\nDESCRIPTION: HOCON configuration for setting up a cluster node with the 'web' role, which will handle receiving requests from users and pushing them to the cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/member-roles.md#2025-04-16_snippet_0\n\nLANGUAGE: hocon\nCODE:\n```\nakka\n{\n  cluster\n  {\n    roles = [\"web\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Publisher Actor in Akka.NET Cluster\nDESCRIPTION: Example of an actor that publishes messages to the \"content\" topic using the DistributedPubSubMediator. It periodically sends content to all subscribers of the topic across the cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/distributed-publish-subscribe.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Publisher : ReceiveActor\n{\n    private readonly IActorRef _mediator;\n    private readonly ICancelable _task;\n\n    private int _count = 0;\n\n    public class Tick { }\n\n    public Publisher()\n    {\n        // activate the extension\n        _mediator = DistributedPubSub.Get(Context.System).Mediator;\n\n        Receive<Tick>(_ => \n        {\n            var msg = $\"Message #{_count++}\";\n            // publish to the topic named \"content\"\n            _mediator.Tell(new Publish(\"content\", msg));\n            Console.WriteLine($\"Published {msg}\");\n        });\n\n        // publishes a message every second\n        _task = Context.System.Scheduler.ScheduleTellRepeatedlyCancelable(\n            TimeSpan.FromSeconds(1),\n            TimeSpan.FromSeconds(1),\n            Self, new Tick(), Self);\n    }\n\n    protected override void PostStop()\n    {\n        // clean up resources\n        _task.Cancel();\n\n        base.PostStop();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Query Capability to Device Group Actor - C#\nDESCRIPTION: This snippet demonstrates how to integrate the query feature into the group actor. It outlines the necessary steps to construct the query with the appropriate initial parameters.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-4.md#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[DeviceGroupQueryInProgress.cs](../../../../src/core/Akka.Docs.Tutorials/Tutorial4/DeviceGroupQueryInProgress.cs?name=query-added)]\n```\n\n----------------------------------------\n\nTITLE: Become/Unbecome in Akka.NET for Hot-Swapping Actor Behavior\nDESCRIPTION: This snippet demonstrates how to use `Context.Become` to hot-swap an actor's behavior at runtime. It uses the `Become` method to change the actor's message handling based on the received message.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_28\n\nLANGUAGE: csharp\nCODE:\n```\npublic class HotSwapActor : ReceiveActor\n{\n    public HotSwapActor()\n    {\n        Receive<string>(s => s.Equals(\"foo\"), msg =>\n        {\n            Become(Angry);\n        });\n\n        Receive<string>(s => s.Equals(\"bar\"), msg =>\n        {\n            Become(Happy);\n        });\n    }\n\n    private void Angry()\n    {\n        Receive<string>(s => s.Equals(\"foo\"), msg =>\n        {\n            Sender.Tell(\"I am already angry?\");\n        });\n\n        Receive<string>(s => s.Equals(\"bar\"), msg =>\n        {\n            Become(Happy);\n        });\n    }\n\n    private void Happy()\n    {\n        Receive<string>(s => s.Equals(\"foo\"), msg =>\n        {\n            Sender.Tell(\"I am already happy :-)\");\n        });\n\n        Receive<string>(s => s.Equals(\"bar\"), msg =>\n        {\n            Become(Angry);\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Device Removal and Termination Handling in Device Group Actor (C#)\nDESCRIPTION: This snippet demonstrates how to handle device termination and removal in the Device Group actor. It uses Akka.NET's Death Watch feature to monitor device actors and remove them from the tracking dictionaries when they stop.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-3.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nprivate Dictionary<string, IActorRef> _deviceIdToActor = new Dictionary<string, IActorRef>();\nprivate Dictionary<IActorRef, string> _actorToDeviceId = new Dictionary<IActorRef, string>();\n\nprotected override void PreStart() => Log.Info($\"Device group {GroupId} started\");\nprotected override void PostStop() => Log.Info($\"Device group {GroupId} stopped\");\n\nprotected override void OnReceive(object message)\n{\n    switch (message)\n    {\n        case RequestTrackDevice trackMsg when trackMsg.GroupId.Equals(GroupId):\n            if (_deviceIdToActor.TryGetValue(trackMsg.DeviceId, out var actorRef))\n            {\n                actorRef.Forward(trackMsg);\n            }\n            else\n            {\n                var deviceActor = Context.ActorOf(Props.Create(() =>\n                    new Device(GroupId, trackMsg.DeviceId)), $\"device-{trackMsg.DeviceId}\");\n                Context.Watch(deviceActor);\n                _deviceIdToActor.Add(trackMsg.DeviceId, deviceActor);\n                _actorToDeviceId.Add(deviceActor, trackMsg.DeviceId);\n                deviceActor.Forward(trackMsg);\n            }\n            break;\n        case RequestTrackDevice trackMsg:\n            Log.Warning($\"Ignoring TrackDevice request for {trackMsg.GroupId}. This actor is responsible for {GroupId}.\");\n            break;\n        case Terminated terminated:\n            var deviceId = _actorToDeviceId[terminated.ActorRef];\n            Log.Info($\"Device actor for {deviceId} has been terminated\");\n            _actorToDeviceId.Remove(terminated.ActorRef);\n            _deviceIdToActor.Remove(deviceId);\n            break;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conflating stream elements in Akka.NET\nDESCRIPTION: This snippet uses `ConflateWithSeed` to combine a stream of doubles into a summary object containing the standard deviation, mean, and count. It demonstrates decoupling the element rate at the start and end of the flow, which is useful when producers are much faster than consumers.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/buffersandworkingwithrate.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n var statsFlow = Flow.Create<double>()\n                    .ConflateWithSeed(_ => ImmutableList.Create(_), (agg, acc) => agg.Add(acc))\n                    .Select(s => {\n                        var u = s.Sum()/s.Count();\n\n                        var se = s.Select(x => Math.Pow(x - u, 2));\n                        var s = Math.Sqrt(se.Sum()/ se.Count());\n                        return new { s , u , size=s.Count()};\n                    });\n```\n\n----------------------------------------\n\nTITLE: Creating Network Partitions with TestConductor.Blackhole in Akka.NET\nDESCRIPTION: Creates a network partition between two nodes using TestConductor.Blackhole which simulates 100% packet loss. The code must be run on the specified node and uses a barrier to synchronize test execution across nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/testing/multi-node-testing.md#2025-04-16_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nRunOn(() =>\n{\n    TestConductor.Blackhole(_config.First, _config.Second, \n        ThrottleTransportAdapter.Direction.Both).Wait();\n}, _config.First);\nEnterBarrier(\"blackhole-2\");\n```\n\n----------------------------------------\n\nTITLE: Exposing a Source as a Publisher in C#\nDESCRIPTION: Shows how to convert an Akka Streams Source into a Reactive Streams Publisher using Sink.AsPublisher. This example creates a Publisher that supports only a single subscription.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\nvar authorPublisher = Source.FromPublisher(tweets)\n    .Via(authors)\n    .RunWith(Sink.AsPublisher<Author>(fanout: false), materializer);\n\nauthorPublisher.Subscribe(storage);\n```\n\n----------------------------------------\n\nTITLE: Defining StandardMetrics Static Class in C#\nDESCRIPTION: Static class that provides standard metrics constants and extraction methods for CPU and Memory metrics. Contains nested classes for representing CPU and Memory metrics with associated methods to decompose NodeMetrics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.DotNet.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class static StandardMetrics\n{\n    public const string CpuProcessUsage = \"CpuProcessUsage\";\n    public const string CpuTotalUsage = \"CpuTotalUsage\";\n    public const string MaxMemoryRecommended = \"MaxMemoryRecommended\";\n    public const string MemoryAvailable = \"MemoryAvailable\";\n    public const string MemoryUsed = \"MemoryUsed\";\n    public const string Processors = \"Processors\";\n    public static Akka.Util.Option<Akka.Cluster.Metrics.StandardMetrics.Cpu> ExtractCpu(Akka.Cluster.Metrics.Serialization.NodeMetrics nodeMetrics) { }\n    public static Akka.Util.Option<Akka.Cluster.Metrics.StandardMetrics.Memory> ExtractMemory(Akka.Cluster.Metrics.Serialization.NodeMetrics nodeMetrics) { }\n    public sealed class Cpu\n    {\n        public Cpu(Akka.Actor.Address address, long timestamp, double cpuProcessUsage, double cpuTotalUsage, int processorsNumber) { }\n        public Akka.Actor.Address Address { get; }\n        public double ProcessUsage { get; }\n        public int ProcessorsNumber { get; }\n        public long Timestamp { get; }\n        public double TotalUsage { get; }\n        [return: System.Runtime.CompilerServices.TupleElementNamesAttribute(new string[] {\n                \"Address\",\n                \"Timestamp\",\n                \"CpuProcessUsage\",\n                \"CpuTotalUsage\",\n                \"Processors\"})]\n        public static Akka.Util.Option<System.ValueTuple<Akka.Actor.Address, long, double, double, int>> Decompose(Akka.Cluster.Metrics.Serialization.NodeMetrics nodeMetrics) { }\n    }\n    public sealed class Memory\n    {\n        public Memory(Akka.Actor.Address address, long timestamp, double used, double available, Akka.Util.Option<double> max) { }\n        public Akka.Actor.Address Address { get; }\n        public double Available { get; }\n        public Akka.Util.Option<double> MaxRecommended { get; }\n        public long Timestamp { get; }\n        public double Used { get; }\n        [return: System.Runtime.CompilerServices.TupleElementNamesAttribute(new string[] {\n                \"Address\",\n                \"Timestamp\",\n                \"UsedSmoothValue\",\n                \"AvailableSmoothValue\",\n                \"MaxRecommendedSmoothValue\"})]\n        public static Akka.Util.Option<System.ValueTuple<Akka.Actor.Address, long, double, double, Akka.Util.Option<double>>> Decompose(Akka.Cluster.Metrics.Serialization.NodeMetrics nodeMetrics) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Cluster Metrics Collector in Akka.NET\nDESCRIPTION: The `ClusterMetricsCollector` class provides functionalities to collect cluster metrics in Akka.NET by extending `Akka.Actor.ActorBase`. This implementation includes methods to handle actor lifecycle events and process received messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Net.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterMetricsCollector : Akka.Actor.ActorBase {\n    public ClusterMetricsCollector() { }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Actor Mailbox in HOCON Deployment Settings\nDESCRIPTION: Example showing how to specify a custom mailbox in the actor's deployment configuration using HOCON. This approach allows setting the mailbox at the configuration level for specific actor paths.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/mailboxes.md#2025-04-16_snippet_1\n\nLANGUAGE: HOCON\nCODE:\n```\nakka.actor.deployment {\n    /my-actor-path {\n        mailbox = my-custom-mailbox\n    }\n}  \n```\n\n----------------------------------------\n\nTITLE: Typed Pattern Matching in C# 7\nDESCRIPTION: This C# 7 code demonstrates typed pattern matching using a switch statement. It checks the type of the input 'x' and returns a string based on the matched type.  The example handles string, int, float, int[], Dog, List<int>, and Dictionary<int, string> types. Relies on `Dog` class.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/porting-guide.md#2025-04-16_snippet_10\n\nLANGUAGE: c#\nCODE:\n```\npublic string TestPattern(object x)\n{\n    switch(x)\n    {\n        case string s: return $\"you gave me this string: {s}\";\n        case int i: return $\"thanks for the int: {i}\";\n        case float f: return $\"thanks for the float: {f}\";\n        case int[] a: return $\"an array of int: {string.Join(\",\", a)}\";\n        case Dog d: return $\"dog: ${d.Name}\";\n        case List<int> list: return $\"thanks for the List: {list}\";\n        case Dictionary<int, string> dict: return $\"dictionary: {dict}\";\n    }\n    return string.Empty;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Message Handlers in C#\nDESCRIPTION: This snippet shows how to define message handlers in the constructor of a class inheriting from ReceiveActor. The Receive method is employed to handle strings and integers, with each handler printing a message to the console indicating the type and value of the received message.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka/Util/MatchHandler/README.md#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nprivate class MyActor : ReceiveActor\n{\n  public MyActor()\n  {\n    Receive<string>(s => Console.WriteLine(\"Received string: \" + s)); //1\n    Receive<int>(i => Console.WriteLine(\"Received integer: \" + i));   //2\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Consumer Registration with Akka.Delivery\nDESCRIPTION: Illustrates the consumer registration process with ConsumerController, including setting up message delivery and producer controller registration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/reliable-delivery.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar consumerController = Context.ActorOf(\n    ConsumerController.Create<IDeliveryMessage>(Context.System));\nconsumerController.Tell(new ConsumerController.Start<IDeliveryMessage>(consumer));\nconsumerController.Tell(new ConsumerController.RegisterToProducerController<IDeliveryMessage>(producerController));\n```\n\n----------------------------------------\n\nTITLE: Creating Router from HOCON Configuration in C#\nDESCRIPTION: Demonstrates how to create a router using the FromConfig.Instance method, which loads the router configuration from the HOCON configuration file.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar props = Props.Create<Worker>().WithRouter(FromConfig.Instance);\nvar actor = system.ActorOf(props, \"workers\");\n```\n\n----------------------------------------\n\nTITLE: Implementing ConcurrentSet<T> Collection in C#\nDESCRIPTION: A thread-safe set implementation that implements ICollection<T> interface. Provides concurrent access for multiple threads with multiple constructor overloads for flexibility.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_234\n\nLANGUAGE: C#\nCODE:\n```\npublic class ConcurrentSet<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable\n{\n    public ConcurrentSet() { }\n    public ConcurrentSet(System.Collections.Generic.IEnumerable<T> collection) { }\n    public ConcurrentSet(System.Collections.Generic.IEqualityComparer<T> comparer) { }\n    public ConcurrentSet(System.Collections.Generic.IEnumerable<T> collection, System.Collections.Generic.IEqualityComparer<T> comparer) { }\n    public ConcurrentSet(int concurrencyLevel, int capacity) { }\n    public ConcurrentSet(int concurrencyLevel, System.Collections.Generic.IEnumerable<T> collection, System.Collections.Generic.IEqualityComparer<T> comparer) { }\n    public ConcurrentSet(int concurrencyLevel, int capacity, System.Collections.Generic.IEqualityComparer<T> comparer) { }\n    public int Count { get; }\n    public bool IsEmpty { get; }\n    public void Clear() { }\n    public bool Contains(T item) { }\n    public bool TryAdd(T item) { }\n    public bool TryRemove(T item) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Destination Actor in Akka.NET Cluster\nDESCRIPTION: Example of a destination actor that registers itself with the DistributedPubSubMediator using a specific path, allowing it to receive point-to-point messages sent to that path from anywhere in the cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/distributed-publish-subscribe.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Destination : ReceiveActor\n{\n    private readonly IActorRef _mediator;\n\n    public Destination()\n    {\n        _mediator = DistributedPubSub.Get(Context.System).Mediator;\n\n        // register to the path\n        _mediator.Tell(new Put(Self));\n\n        Receive<string>(s => \n        {\n            Console.WriteLine($\"Got {s}\");\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Streams with TestSink.Probe in C#\nDESCRIPTION: This snippet demonstrates using TestSink.Probe from Akka.Streams.Testkit to test a stream, allowing manual control over demand and assertions on downstream elements.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/testingstreams.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar sourceUnderTest = Source.From(Enumerable.Range(1, 4)).Where(x => x%2 == 0).Select(x => x*2);\n\nsourceUnderTest.RunWith(this.SinkProbe<int>(), materializer)\n    .Request(2)\n    .ExpectNext(4, 8)\n    .ExpectComplete();\n```\n\n----------------------------------------\n\nTITLE: Implementing CoordinatedShutdown in C#\nDESCRIPTION: Manages the coordinated shutdown process for an Akka.NET actor system with defined phases and timeout handling. Provides methods for adding shutdown tasks and running the shutdown sequence.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class CoordinatedShutdown : Akka.Actor.IExtension\n{\n    public const string PhaseActorSystemTerminate = \"actor-system-terminate\";\n    public const string PhaseBeforeActorSystemTerminate = \"before-actor-system-terminate\";\n    public Akka.Actor.CoordinatedShutdown.Reason ShutdownReason { get; }\n    public System.TimeSpan TotalTimeout { get; }\n    public void AddTask(string phase, string taskName, System.Func<System.Threading.Tasks.Task<Akka.Done>> task) { }\n    public System.Threading.Tasks.Task<Akka.Done> Run(Akka.Actor.CoordinatedShutdown.Reason reason, string fromPhase = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Pipelined Processing in Akka Streams (C#)\nDESCRIPTION: Demonstrates how to create a pipelined flow using two asynchronous stages for cooking pancakes. The first stage creates half-cooked pancakes, while the second stage finishes them.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/pipeliningandparallelism.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Takes a scoop of batter and creates a pancake with one side cooked\nvar fryingPan1 = Flow.Create<ScoopOfBatter>().Select(batter => HalfCookedPancake());\n\n// Finishes a half-cooked pancake\nvar fryingPan2 = Flow.Create<HalfCookedPancake>().Select(halfCooked => Pancake());\n\n// With the two frying pans we can fully cook pancakes\nvar pancakeChef = Flow.Create<ScoopOfBatter>().Via(fryingPan1.Async()).Via(fryingPan2.Async());\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Pipeline Processing in Akka.NET\nDESCRIPTION: Demonstrates how to create an asynchronous processing pipeline using Select operations with async boundaries. Shows how elements can be processed out of order due to asynchronous execution.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/buffersandworkingwithrate.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar source = Source.From(Enumerable.Range(1, 100))\n                   .Select(i => { Console.WriteLine($\"A: {i}\"); return i; }).Async()\n                   .Select(i => { Console.WriteLine($\"B: {i}\"); return i; }).Async()\n                   .Select(i => { Console.WriteLine($\"C: {i}\"); return i; }).Async()\n                    .RunWith(Sink.Ignore<int>(), materializer);\n```\n\n----------------------------------------\n\nTITLE: Configuring ASP.NET Core Program with Akka.NET Service\nDESCRIPTION: Shows how to configure the ASP.NET Core application startup to register and use Akka.NET services. This includes registering the AkkaService as both an IHostedService and an IActorBridge in the dependency injection container.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/deployment/aspnet-core.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container.\n\nbuilder.Services.AddControllers();\n// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\n// register AkkaService as both IHostedService and IActorBridge\nbuilder.Services.AddSingleton<AkkaService>();\nbuilder.Services.AddSingleton<IHostedService>(sp => sp.GetRequiredService<AkkaService>());\nbuilder.Services.AddSingleton<IActorBridge>(sp => sp.GetRequiredService<AkkaService>());\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline.\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\n\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n----------------------------------------\n\nTITLE: DistributedPubSub Configuration in HOCON for Akka.NET\nDESCRIPTION: Reference configuration for the DistributedPubSub extension in Akka.NET showing all available settings including max-delta-elements, gossip-interval, and removed-time-to-live.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/distributed-publish-subscribe.md#2025-04-16_snippet_8\n\nLANGUAGE: hocon\nCODE:\n```\nakka.extensions = [\"Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubExtensionProvider,Akka.Cluster.Tools\"]\n```\n\n----------------------------------------\n\nTITLE: Using IScheduler for System-Level Task Scheduling\nDESCRIPTION: Demonstrates using the ActorSystem's IScheduler interface for scheduling tasks. This example shows scheduled one-time and recurring message delivery to actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/schedulers.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar system = ActorSystem.Create(\"MySystem\");\nvar actor = system.ActorOf<GreetingActor>(\"greeting-actor\");\n\n// schedule sending a message to the actor after 500 milliseconds\nsystem.Scheduler.ScheduleTellOnce(TimeSpan.FromMilliseconds(500), actor, \"Hello\", ActorRefs.Nobody);\n\n// schedule recurring message every second, starting immediately\n// IMPORTANT: need to save a reference to the ICancelable so we can cancel the recurring messages later\nvar cancellable = system.Scheduler.ScheduleTellRepeatedlyCancelable(\n    TimeSpan.Zero, // first time delay\n    TimeSpan.FromSeconds(1), // recurring time delay\n    actor,\n    \"Recurring message\",\n    ActorRefs.Nobody);\n\n// to stop the recurring messages\n// cancellable.Cancel();\n```\n\n----------------------------------------\n\nTITLE: Mapping Elements to Multiple Groups with groupBy\nDESCRIPTION: This snippet demonstrates how to map elements to multiple groups simultaneously using Akka.NET Streams. It uses `SelectMany` to create multiple pairs of (Message, Topic) and then groups them using `GroupBy`.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/cookbook.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nFunc<Message, ImmutableHashSet<Topic>> topicMapper = ExtractTopics;\nvar elements = Source.Empty<Message>();\nvar messageAndTopic = elements.SelectMany(msg =>\n{\n    var topicsForMessage = topicMapper(msg);\n    // Create a (Msg, Topic) pair for each of the topics\n    // the message belongs to\n    return topicsForMessage.Select(t => Tuple.Create(msg, t));\n});\n\nvar multiGroups = messageAndTopic.GroupBy(2, tuple => tuple.Item2).Select(tuple =>\n{\n    var msg = tuple.Item1;\n    var topic = tuple.Item2;\n\n    // do what needs to be done\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing LoggingBus Class in C#\nDESCRIPTION: Implementation of an actor-based event bus for logging in Akka.NET. Handles message classification and delivery to appropriate subscribers based on log level. Provides methods for setting log level and initializing standard logging to stdout.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_151\n\nLANGUAGE: C#\nCODE:\n```\npublic class LoggingBus : Akka.Event.ActorEventBus<object, System.Type>\n{\n    public LoggingBus() { }\n    public Akka.Event.LogLevel LogLevel { get; }\n    protected override bool Classify(object @event, System.Type classifier) { }\n    protected override System.Type GetClassifier(object @event) { }\n    protected override bool IsSubClassification(System.Type parent, System.Type child) { }\n    protected override void Publish(object @event, Akka.Actor.IActorRef subscriber) { }\n    public void SetLogLevel(Akka.Event.LogLevel logLevel) { }\n    public void StartStdoutLogger(Akka.Actor.Settings config) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SchedulerExtensions for Akka.NET\nDESCRIPTION: Static extension methods for Akka.NET schedulers to provide convenient scheduling capabilities. Methods include one-time and repeated action scheduling with various overloads supporting both millisecond delays and TimeSpan parameters.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\npublic class static SchedulerExtensions\n    {\n        public static void ScheduleOnce(this Akka.Actor.IActionScheduler scheduler, int millisecondsDelay, System.Action action, Akka.Actor.ICancelable cancelable = null) { }\n        public static Akka.Actor.ICancelable ScheduleOnceCancelable(this Akka.Actor.IActionScheduler scheduler, System.TimeSpan delay, System.Action action) { }\n        public static Akka.Actor.ICancelable ScheduleOnceCancelable(this Akka.Actor.IActionScheduler scheduler, int millisecondsDelay, System.Action action) { }\n        public static void ScheduleRepeatedly(this Akka.Actor.IActionScheduler scheduler, int initialMillisecondsDelay, int millisecondsInterval, System.Action action, Akka.Actor.ICancelable cancelable = null) { }\n        public static Akka.Actor.ICancelable ScheduleRepeatedlyCancelable(this Akka.Actor.IActionScheduler scheduler, System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action) { }\n        public static Akka.Actor.ICancelable ScheduleRepeatedlyCancelable(this Akka.Actor.IActionScheduler scheduler, int initialMillisecondsDelay, int millisecondsInterval, System.Action action) { }\n        public static void ScheduleTellOnce(this Akka.Actor.ITellScheduler scheduler, int millisecondsDelay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable = null) { }\n        public static Akka.Actor.ICancelable ScheduleTellOnceCancelable(this Akka.Actor.IScheduler scheduler, System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender) { }\n        public static Akka.Actor.ICancelable ScheduleTellOnceCancelable(this Akka.Actor.IScheduler scheduler, int millisecondsDelay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender) { }\n        public static void ScheduleTellRepeatedly(this Akka.Actor.ITellScheduler scheduler, int initialMillisecondsDelay, int millisecondsInterval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable = null) { }\n        public static Akka.Actor.ICancelable ScheduleTellRepeatedlyCancelable(this Akka.Actor.IScheduler scheduler, System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender) { }\n        public static Akka.Actor.ICancelable ScheduleTellRepeatedlyCancelable(this Akka.Actor.IScheduler scheduler, int initialMillisecondsDelay, int millisecondsInterval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining RoundRobinPool Router in HOCON Configuration\nDESCRIPTION: Shows how to define a round-robin pool router with 5 instances in HOCON configuration. This approach allows changing router configuration without recompiling code.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_2\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.deployment {\n  /workers {\n    router = round-robin-pool\n    nr-of-instances = 5\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Transport Class Methods in Akka.NET\nDESCRIPTION: Abstract Transport class that defines the core functionality for remote communication in Akka.NET. It includes methods for establishing associations, listening for connections, and shutting down transport.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Transport\n{\n    protected Transport() { }\n    public Akka.Configuration.Config Config { get; set; }\n    public virtual long MaximumPayloadBytes { get; set; }\n    public virtual string SchemeIdentifier { get; set; }\n    public Akka.Actor.ActorSystem System { get; set; }\n    public abstract System.Threading.Tasks.Task<Akka.Remote.Transport.AssociationHandle> Associate(Akka.Actor.Address remoteAddress);\n    public abstract bool IsResponsibleFor(Akka.Actor.Address remote);\n    public abstract System.Threading.Tasks.Task<System.ValueTuple<Akka.Actor.Address, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.IAssociationEventListener>>> Listen();\n    public virtual System.Threading.Tasks.Task<bool> ManagementCommand(object message) { }\n    public abstract System.Threading.Tasks.Task<bool> Shutdown();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Message Protocol for Akka.Cluster.Sharding.Delivery in C#\nDESCRIPTION: Defines a typed message protocol for use with Akka.Cluster.Sharding.Delivery, including a common interface and concrete message types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-sharding-delivery.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IConfirmableMessage\n{\n    long ConfirmationId { get; }\n}\n\npublic sealed class Message1 : IConfirmableMessage\n{\n    public Message1(long confirmationId)\n    {\n        ConfirmationId = confirmationId;\n    }\n\n    public long ConfirmationId { get; }\n}\n\npublic sealed class Message2 : IConfirmableMessage\n{\n    public Message2(long confirmationId)\n    {\n        ConfirmationId = confirmationId;\n    }\n\n    public long ConfirmationId { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Actor Supervision in C#\nDESCRIPTION: Abstract class defining supervisor strategy methods for handling actor failures, restarts and process management. Includes methods for handling failures, logging, and child actor management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_52\n\nLANGUAGE: C#\nCODE:\n```\npublic bool HandleFailure(Akka.Actor.ActorCell actorCell, Akka.Actor.IActorRef child, System.Exception cause, Akka.Actor.Internal.ChildRestartStats stats, System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> children) { }\nprotected virtual void LogFailure(Akka.Actor.IActorContext context, Akka.Actor.IActorRef child, System.Exception cause, Akka.Actor.Directive directive) { }\npublic abstract void ProcessFailure(Akka.Actor.IActorContext context, bool restart, Akka.Actor.IActorRef child, System.Exception cause, Akka.Actor.Internal.ChildRestartStats stats, System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> children);\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic EventBus in C#\nDESCRIPTION: An abstract base class for event buses that handles event subscription, publication, and classification. It uses generic type parameters for events, classifiers, and subscribers.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_123\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class EventBus<TEvent, TClassifier, TSubscriber>\n{\n    protected EventBus() { }\n    protected abstract bool Classify(TEvent @event, TClassifier classifier);\n    protected abstract TClassifier GetClassifier(TEvent @event);\n    protected abstract bool IsSubClassification(TClassifier parent, TClassifier child);\n    protected abstract void Publish(TEvent @event, TSubscriber subscriber);\n    public virtual void Publish(TEvent @event) { }\n    protected string SimpleName(object source) { }\n    protected string SimpleName(System.Type source) { }\n    public virtual bool Subscribe(TSubscriber subscriber, TClassifier classifier) { }\n    public virtual bool Unsubscribe(TSubscriber subscriber) { }\n    public virtual bool Unsubscribe(TSubscriber subscriber, TClassifier classifier) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the ClusterActorRefProvider class\nDESCRIPTION: This snippet defines the `ClusterActorRefProvider` class, which is responsible for providing actor references within a cluster.  It extends `RemoteActorRefProvider` and implements interfaces related to cluster actor references. It handles the creation of remote watchers and initialization of the actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Core.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n [Akka.Annotations.InternalApiAttribute()]\n    public class ClusterActorRefProvider : Akka.Remote.RemoteActorRefProvider, Akka.Actor.IActorRefProvider, Akka.Cluster.IClusterActorRefProvider, Akka.Remote.IRemoteActorRefProvider\n    {\n        public ClusterActorRefProvider(string systemName, Akka.Actor.Settings settings, Akka.Event.EventStream eventStream) { }\n        protected override Akka.Actor.IActorRef CreateRemoteWatcher(Akka.Actor.Internal.ActorSystemImpl system) { }\n        public override void Init(Akka.Actor.Internal.ActorSystemImpl system) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Creating an ActorSystem with ActorSystemSetup in Akka.NET\nDESCRIPTION: This code shows how to create an ActorSystem using the previously configured ActorSystemSetup object, allowing both HOCON and programmatic configuration to be applied.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/config.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar system = ActorSystem.Create(\"MySystem\", actorSystemSetup);\n\n// verify that we are using the HyperionSerializer\nvar serializer = system.Serialization.FindSerializerForType(typeof(IActorRef));\nserializer.Should().BeOfType<HyperionSerializer>();\n```\n\n----------------------------------------\n\nTITLE: Defining Key Abstract Class in C#\nDESCRIPTION: This snippet defines an abstract class `Key<T>` that implements the `IKey`, `IKey<T>`, and `IReplicatedDataSerialization` interfaces. It provides a base implementation for keys used in the distributed data system. The `Id` property stores a string identifier for the key.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\n    public abstract class Key<T> : Akka.DistributedData.IKey, Akka.DistributedData.IKey<T>, Akka.DistributedData.IReplicatedDataSerialization\n        where T : Akka.DistributedData.IReplicatedData\n    {\n        protected Key(string id) { }\n        public string Id { get; }\n        public bool Equals(Akka.DistributedData.IKey key) { }\n        public virtual bool Equals(object obj) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n        public static string op_Implicit(Akka.DistributedData.Key<T> key) { }\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Akka.NET Actor via Message Passing in C#\nDESCRIPTION: This code snippet demonstrates how to initialize an Akka.NET actor using message passing. It shows a Service actor that waits for an 'init' message to complete its initialization, then changes its behavior to handle subsequent messages. This approach is useful when not all initialization data can be passed through the constructor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_35\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Service : ReceiveActor\n{\n    private string _initializeMe;\n\n    public Service()\n    {\n        Receive<string>(s => s.Equals(\"init\"), init =>\n        {\n            _initializeMe = \"Up and running\";\n\n            Become(() =>\n            {\n                Receive<string>(s => s.Equals(\"U OK?\") && _initializeMe != null, m => \n                {\n                    Sender.Tell(_initializeMe, Self);\n                });\n            });\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Handlers with Func in C#\nDESCRIPTION: Shows how to specify message handlers using the Receive<T>(Func<T,bool> handler) overload. This allows more complex logic, with handlers stopping further handler checks if they return true. Examples show func-implemented conditions influencing message processing outcomes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka/Util/MatchHandler/README.md#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nReceive<string>(s => \n  { \n    if(s.Length>5)\n    {\n      Console.WriteLine(\"1: \" + s);\n      return true;\n    }\n    return false;\n  });\nReceive<string>(s => Console.WriteLine(\"2: \" + s);\n```\n\n----------------------------------------\n\nTITLE: Defining LoggingExtensions for fluent logging in Akka.NET\nDESCRIPTION: Static extension methods for the ILoggingAdapter interface to provide fluent and strongly-typed logging methods. Provides overloaded methods for Debug, Error, and Info log levels with varying numbers of generic parameters for type-safe message formatting.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_148\n\nLANGUAGE: C#\nCODE:\n```\npublic class static LoggingExtensions\n{\n    public static void Debug(this Akka.Event.ILoggingAdapter log, string format) { }\n    public static void Debug(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format) { }\n    public static void Debug<T1>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1) { }\n    public static void Debug<T1>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1) { }\n    public static void Debug<T1, T2>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2) { }\n    public static void Debug<T1, T2>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2) { }\n    public static void Debug<T1, T2, T3>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3) { }\n    public static void Debug<T1, T2, T3>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3) { }\n    public static void Debug<T1, T2, T3, T4>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4) { }\n    public static void Debug<T1, T2, T3, T4>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4) { }\n    public static void Debug<T1, T2, T3, T4, T5>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) { }\n    public static void Debug<T1, T2, T3, T4, T5>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) { }\n    public static void Debug<T1, T2, T3, T4, T5, T6>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) { }\n    public static void Debug<T1, T2, T3, T4, T5, T6>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) { }\n    public static void Debug(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, object[] args) { }\n    public static void Debug(this Akka.Event.ILoggingAdapter log, string format, object[] args) { }\n    public static void Error(this Akka.Event.ILoggingAdapter log, string format) { }\n    public static void Error(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format) { }\n    public static void Error<T1>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1) { }\n    public static void Error<T1>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1) { }\n    public static void Error<T1, T2>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2) { }\n    public static void Error<T1, T2>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2) { }\n    public static void Error<T1, T2, T3>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3) { }\n    public static void Error<T1, T2, T3>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3) { }\n    public static void Error<T1, T2, T3, T4>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4) { }\n    public static void Error<T1, T2, T3, T4>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4) { }\n    public static void Error<T1, T2, T3, T4, T5>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) { }\n    public static void Error<T1, T2, T3, T4, T5>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) { }\n    public static void Error<T1, T2, T3, T4, T5, T6>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) { }\n    public static void Error<T1, T2, T3, T4, T5, T6>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) { }\n    public static void Error(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, object[] args) { }\n    public static void Error(this Akka.Event.ILoggingAdapter log, string format, object[] args) { }\n    public static void Info(this Akka.Event.ILoggingAdapter log, string format) { }\n    public static void Info(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format) { }\n    public static void Info<T1>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1) { }\n    public static void Info<T1>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1) { }\n    public static void Info<T1, T2>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2) { }\n    public static void Info<T1, T2>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2) { }\n    public static void Info<T1, T2, T3>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3) { }\n    public static void Info<T1, T2, T3>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3) { }\n    public static void Info<T1, T2, T3, T4>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4) { }\n    public static void Info<T1, T2, T3, T4>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4) { }\n```\n\n----------------------------------------\n\nTITLE: Starting Timers in Akka.NET with IWithTimers\nDESCRIPTION: Shows how to start both periodic and single-shot timers using the IWithTimers interface. The code demonstrates using keys to identify specific timers for future reference.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/schedulers.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// this message will be sent to the self actor repeatedly\nTimers.StartPeriodicTimer(\"TickKey\", new Tick(), TimeSpan.FromSeconds(1));\n\n// this message will be sent to the self actor once, after 500ms\nTimers.StartSingleTimer(\"SingleKey\", \"SingleTick\", TimeSpan.FromMilliseconds(500));\n```\n\n----------------------------------------\n\nTITLE: Implementing Condition Awaiting Methods in Akka.NET TestKit\nDESCRIPTION: Method overloads for awaiting conditions in tests with various timeout and interval options. Includes both throwing and non-throwing variants, supporting both synchronous and asynchronous condition checking.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic System.Threading.Tasks.Task AwaitConditionAsync(System.Func<System.Threading.Tasks.Task<bool>> conditionIsFulfilled, System.Nullable<System.TimeSpan> max, string message, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.Task AwaitConditionAsync(System.Func<bool> conditionIsFulfilled, System.Nullable<System.TimeSpan> max, string message, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Time-Based Stream Processing\nDESCRIPTION: Combines factorial stream with index stream and applies throttling for controlled output rate\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/quickstart.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nawait factorials\n    .ZipWith(Source.From(Enumerable.Range(0, 100)), (num, idx) => $\"{idx}! = {num}\")\n    .Throttle(1, TimeSpan.FromSeconds(1), 1, ThrottleMode.Shaping)\n    .RunForeach(Console.WriteLine, materializer);\n```\n\n----------------------------------------\n\nTITLE: Defining Write Protocol Messages in C#\nDESCRIPTION: Defines the message structure for recording temperature in a device actor. Includes a RecordTemperature message with id and value fields, and a TemperatureRecorded acknowledgment message.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-2.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class RecordTemperature\n{\n    public RecordTemperature(long id, double value)\n    {\n        Id = id;\n        Value = value;\n    }\n\n    public long Id { get; }\n    public double Value { get; }\n}\n\npublic sealed class TemperatureRecorded\n{\n    public TemperatureRecorded(long id)\n    {\n        Id = id;\n    }\n\n    public long Id { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Logging Static Class in C#\nDESCRIPTION: Static utility class providing logging helper methods for Akka.NET applications. Contains methods for creating loggers, converting between log level types and strings, and simplifying type and object names for logging purposes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_149\n\nLANGUAGE: C#\nCODE:\n```\npublic class static Logging\n{\n    public static System.Type ClassFor(this Akka.Event.LogLevel logLevel) { }\n    public static Akka.Event.ILoggingAdapter GetLogger(this Akka.Actor.IActorContext context, Akka.Event.ILogMessageFormatter logMessageFormatter = null) { }\n    public static Akka.Event.ILoggingAdapter GetLogger(Akka.Actor.ActorSystem system, object logSourceObj, Akka.Event.ILogMessageFormatter logMessageFormatter = null) { }\n    public static Akka.Event.ILoggingAdapter GetLogger(Akka.Event.LoggingBus loggingBus, object logSourceObj, Akka.Event.ILogMessageFormatter logMessageFormatter = null) { }\n    public static Akka.Event.LogLevel LogLevelFor(string logLevel) { }\n    public static Akka.Event.LogLevel LogLevelFor<T>()\n        where T : Akka.Event.LogEvent { }\n    public static string SimpleName(object o) { }\n    public static string SimpleName(System.Type t) { }\n    public static string StringFor(this Akka.Event.LogLevel logLevel) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Actor Lifecycle Watching with Akka.NET Inbox\nDESCRIPTION: Demonstrates how to use Inbox to watch an actor's lifecycle, specifically monitoring for termination. The example shows watching a target actor and receiving a Terminated message when the actor is stopped.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/inbox.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing System.Diagnostics;\n...\nvar inbox = Inbox.Create(system);\ninbox.Watch(target);\ntarget.Tell(PoisonPill.Instance, ActorRefs.NoSender);\n\ntry\n{\n    Debug.Assert(inbox.Receive(TimeSpan.FromSeconds(1)) is Terminated);\n}\ncatch (TimeoutException)\n{\n    // timeout\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Finite State Machines with TestFSMRef in C#\nDESCRIPTION: Example of using TestFSMRef to test a Finite State Machine actor, including state assertions and timer operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/testing-actor-systems.md#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nvar fsm = new TestFSMRef<TestFsmActor, int, string>();\n            \nAssert.True(fsm.StateName == 1);\nAssert.True(fsm.StateData == \"\");\n\nfsm.Tell(\"go\"); //being a TestActorRef, this runs on the CallingThreadDispatcher\n\nAssert.True(fsm.StateName == 2);\nAssert.True(fsm.StateData == \"go\");\n\nfsm.SetState(1);\nAssert.True(fsm.StateName == 1);\n\nAssert.False(fsm.IsTimerActive(\"test\"));\nfsm.SetTimer(\"test\",12, 10.Milliseconds(), true);\nAssert.True(fsm.IsTimerActive(\"test\"));\nfsm.CancelTimer(\"test\");\nAssert.False(fsm.IsTimerActive(\"test\"));\n```\n\n----------------------------------------\n\nTITLE: Initializing Lease Configuration in Constructor\nDESCRIPTION: Constructor implementation showing how to obtain a lease reference using LeaseProvider with required parameters including lease name, owner name, configuration path, and retry interval.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/lease.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic LeaseActor(\n    string leaseName,\n    string ownerName,\n    string configPath,\n    TimeSpan retryInterval)\n{\n    _lease = LeaseProvider.Get(Context.System).GetLease(\n        leaseName,\n        configPath,\n        ownerName);\n    _retryInterval = retryInterval;\n    Become(AcquiringLease);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Persistent Actor Identifier in C#\nDESCRIPTION: This snippet shows how to define a unique and stable identifier for a persistent actor using the PersistenceId property.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/event-sourcing.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic override string PersistenceId { get; } = \"my-stable-persistence-id\";\n```\n\n----------------------------------------\n\nTITLE: Integrating Streams with Actor-based Database using Ask in C#\nDESCRIPTION: This example shows how to use Ask with SelectAsync to integrate a stream with an actor-based database service. It demonstrates saving tweets to a database using an actor interface.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar akkaTweets = tweets.Where(t => t.HashTags.Contains(\"Akka.Net\"));\n\nvar saveTweets = akkaTweets\n    .SelectAsync(4, tweet => database.Ask<DbResult>(new Save(tweet), TimeSpan.FromSeconds(3)))\n    .To(Sink.Ignore<DbResult>());\n```\n\n----------------------------------------\n\nTITLE: Defining NewtonSoftJsonSerializerSetup for Actor Systems in C#\nDESCRIPTION: A setup class that provides a way to configure JSON serialization settings when creating an actor system. Allows custom configuration of JsonSerializerSettings at system startup.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_211\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class NewtonSoftJsonSerializerSetup : Akka.Actor.Setup.Setup\n    {\n        public System.Action<Newtonsoft.Json.JsonSerializerSettings> ApplySettings { get; }\n        public static Akka.Serialization.NewtonSoftJsonSerializerSetup Create(System.Action<Newtonsoft.Json.JsonSerializerSettings> settings) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Member Class in C#\nDESCRIPTION: Defines the Member class which represents a node in the Akka.NET cluster. Includes methods for comparing members, checking roles, and handling state transitions between different member statuses.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.DotNet.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic class Member : System.IComparable, System.IComparable<Akka.Cluster.Member>\n{\n    public static readonly System.Collections.Generic.IComparer<Akka.Actor.Address> AddressOrdering;\n    public static readonly System.Collections.Generic.IComparer<Akka.Cluster.Member> AgeOrdering;\n    public Akka.Actor.Address Address { get; }\n    public Akka.Util.AppVersion AppVersion { get; }\n    public System.Collections.Immutable.ImmutableHashSet<string> Roles { get; }\n    public Akka.Cluster.MemberStatus Status { get; }\n    public Akka.Cluster.UniqueAddress UniqueAddress { get; }\n    public int CompareTo(Akka.Cluster.Member other) { }\n    public Akka.Cluster.Member Copy(Akka.Cluster.MemberStatus status) { }\n    public Akka.Cluster.Member CopyUp(int upNumber) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public bool HasRole(string role) { }\n    public static Akka.Cluster.Member HighestPriorityOf(Akka.Cluster.Member m1, Akka.Cluster.Member m2) { }\n    public bool IsOlderThan(Akka.Cluster.Member other) { }\n    public static System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.Member> PickHighestPriority(System.Collections.Generic.IEnumerable<Akka.Cluster.Member> a, System.Collections.Generic.IEnumerable<Akka.Cluster.Member> b) { }\n    public static System.Collections.Immutable.ImmutableSortedSet<Akka.Cluster.Member> PickNextTransition(System.Collections.Generic.IEnumerable<Akka.Cluster.Member> a, System.Collections.Generic.IEnumerable<Akka.Cluster.Member> b) { }\n    public static Akka.Cluster.Member PickNextTransition(Akka.Cluster.Member a, Akka.Cluster.Member b) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LWWRegister<T> Class in C#\nDESCRIPTION: Implements a Last-Write-Wins register, a conflict-free replicated data type that stores a single value and resolves conflicts using timestamps.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class LWWRegister<T> : Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.LWWRegister<T>>, System.IEquatable<Akka.DistributedData.LWWRegister<T>>\n{\n    public static readonly Akka.DistributedData.Clock<T> DefaultClock;\n    public static readonly Akka.DistributedData.Clock<T> ReverseClock;\n    public LWWRegister(Akka.Cluster.UniqueAddress node, T initial) { }\n    public LWWRegister(Akka.Cluster.UniqueAddress node, T value, long timestamp) { }\n    public LWWRegister(Akka.Cluster.UniqueAddress node, T initial, Akka.DistributedData.Clock<T> clock) { }\n    public System.Type RegisterType { get; }\n    public long Timestamp { get; }\n    public Akka.Cluster.UniqueAddress UpdatedBy { get; }\n    public T Value { get; }\n    public bool Equals(Akka.DistributedData.LWWRegister<T> other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public Akka.DistributedData.LWWRegister<T> Merge(Akka.DistributedData.LWWRegister<T> other) { }\n    public Akka.DistributedData.IReplicatedData Merge(Akka.DistributedData.IReplicatedData other) { }\n    public override string ToString() { }\n    public Akka.DistributedData.LWWRegister<T> WithValue(Akka.Cluster.UniqueAddress node, T value, Akka.DistributedData.Clock<T> clock = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Scheduling from Inside an Akka.NET Actor\nDESCRIPTION: Shows how to access and use the scheduler from within an actor using the Context.System property. This provides access to the same scheduler instance used throughout the ActorSystem.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/scheduler.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nContext.System.Scheduler.ScheduleTellRepeatedly(....);\n```\n\n----------------------------------------\n\nTITLE: Proper Timer Usage with IWithTimers in C#\nDESCRIPTION: This code snippet shows the correct approach using IWithTimers interface. The timers started using IWithTimers.Timers methods are tied to the actor lifecycle and are automatically removed when the actor is stopped or restarted.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK1004.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Actor;\nusing System.Threading.Tasks;\nusing System;\n\npublic sealed class MyActor : ReceiveActor, IWithTimers\n{\n    private sealed class TimerKey\n    {\n        public static readonly TimerKey Instance = new();\n        private TimerKey() { }\n    }\n    \n    private sealed class TimerMessage\n    {\n        public static readonly TimerMessage Instance = new();\n        private TimerMessage() { }\n    }\n    \n    public MyActor()\n    {\n        Timers.StartPeriodicTimer(\n            key: TimerKey.Instance, \n            msg: TimerMessage.Instance, \n            initialDelay: TimeSpan.FromSeconds(3), \n            interval: TimeSpan.FromSeconds(3));\n    }\n\n    public ITimerScheduler Timers { get; set; } = null!;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Snapshots in Persistent Actor\nDESCRIPTION: Shows how to save snapshots of internal state within a persistent actor using the SaveSnapshot method. The actor receives SaveSnapshotSuccess or SaveSnapshotFailure messages based on the operation result.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/snapshots.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nif (message is SnapshotOffer offeredSnapshot)\n{\n    state = offeredSnapshot.Snapshot;\n}\nelse if (message is RecoveryCompleted)\n{\n    // ..\n}\nelse\n{\n    // event\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ActorSystem with HOCON String in Akka.NET\nDESCRIPTION: Example of parsing HOCON configuration from a string and using it to create an ActorSystem with specific network transport settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/config.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar config = ConfigurationFactory.ParseString(@\"\nakka.remote.dot-netty.tcp {\n    transport-class = \"\"Akka.Remote.Transport.DotNetty.TcpTransport, Akka.Remote\"\"\n    transport-protocol = tcp\n    port = 8091\n    hostname = \"\"127.0.0.1\"\"\n}\");\n\nvar system = ActorSystem.Create(\"MyActorSystem\", config);\n```\n\n----------------------------------------\n\nTITLE: Implementing EventStreamExtensions in C#\nDESCRIPTION: Static extension methods for EventStream that provide generic type-safe Subscribe and Unsubscribe operations for actor references.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_125\n\nLANGUAGE: C#\nCODE:\n```\npublic class static EventStreamExtensions\n{\n    public static bool Subscribe<TChannel>(this Akka.Event.EventStream eventStream, Akka.Actor.IActorRef subscriber) { }\n    public static bool Unsubscribe<TChannel>(this Akka.Event.EventStream eventStream, Akka.Actor.IActorRef subscriber) { }\n}\n```\n\n----------------------------------------\n\nTITLE: NLog Configuration in Akka.NET\nDESCRIPTION: This snippet provides an example of how to configure NLog logging within the Akka.NET configuration file (HOCON format). It specifies the logger to be used by the Akka.NET actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/logging.md#2025-04-16_snippet_2\n\nLANGUAGE: hocon\nCODE:\n```\nakka {\n    loggers = [\"Akka.Logger.NLog.NLogLogger, Akka.Logger.NLog\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BroadcastPool Router in C#\nDESCRIPTION: BroadcastPool class for Akka.NET routing. It creates a pool of actors and broadcasts messages to all of them. The constructor takes the number of instances and optional parameters for customization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_199\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class BroadcastPool : Akka.Routing.Pool\n{\n    public BroadcastPool(int nrOfInstances) { }\n    public BroadcastPool(Akka.Configuration.Config config) { }\n    public BroadcastPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False) { }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Routing.BroadcastPool WithDispatcher(string dispatcher) { }\n    public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n    public Akka.Routing.BroadcastPool WithResizer(Akka.Routing.Resizer resizer) { }\n    public Akka.Routing.BroadcastPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BoundedMailbox Types in C#\nDESCRIPTION: Defines two mailbox types, BoundedDequeBasedMailbox and BoundedMailbox, which implement bounded message queues with push timeout semantics. These classes are used for managing actor mailboxes with capacity limits.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_95\n\nLANGUAGE: C#\nCODE:\n```\npublic class BoundedDequeBasedMailbox : Akka.Dispatch.MailboxType, Akka.Dispatch.IProducesMessageQueue<Akka.Dispatch.MessageQueues.BoundedDequeMessageQueue>, Akka.Dispatch.IProducesPushTimeoutSemanticsMailbox\n{\n    public BoundedDequeBasedMailbox(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }\n    public int Capacity { get; }\n    public System.TimeSpan PushTimeout { get; }\n    public override Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }\n}\npublic sealed class BoundedMailbox : Akka.Dispatch.MailboxType, Akka.Dispatch.IProducesMessageQueue<Akka.Dispatch.MessageQueues.BoundedMessageQueue>, Akka.Dispatch.IProducesPushTimeoutSemanticsMailbox\n{\n    public BoundedMailbox(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }\n    public int Capacity { get; }\n    public System.TimeSpan PushTimeout { get; }\n    public override Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Logging Examples in Akka.NET Actors\nDESCRIPTION: Different ways to log messages within Akka.NET actors using Serilog.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/serilog.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar log = Context.GetLogger();\n...\nlog.Info(\"The value is {0}\", counter);\n\n// Alternative semantic logging\nvar log = Context.GetLogger();\n...\nlog.Info(\"The value is {Counter}\", counter);\n```\n\n----------------------------------------\n\nTITLE: Enum StateStoreMode in C# for Store Modes\nDESCRIPTION: Defines the \"StateStoreMode\" enumeration, specifying store modes like \"Persistence\", \"DData\", and \"Custom\", enabling different state store selection based on required persistence and recovery strategies.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Core.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic enum StateStoreMode {\n        Persistence = 0,\n        DData = 1,\n        Custom = 2,\n    }\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Supervision Strategy with Decider\nDESCRIPTION: Shows how to define a custom supervision strategy using a Decider to handle specific exception types, in this case resuming on division by zero\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/error-handling.md#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nDecider decider = cause => cause is DivideByZeroException\n    ? Directive.Resume\n    : Directive.Stop;\nvar settings = ActorMaterializerSettings.Create(system).WithSupervisionStrategy(decider);\nvar materializer = system.Materializer(settings);\n```\n\n----------------------------------------\n\nTITLE: Local Message Declaration Pattern\nDESCRIPTION: Shows the recommended practice of declaring local messages within the Actor class for better message organization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DemoActor : ReceiveActor\n{\n    public DemoActor()\n    {\n        Receive<DemoActor.DemoActorLocalMessage1>(x =>\n        {\n            // Handle message here...\n        });\n\n        Receive<DemoActor.DemoActorLocalMessage2>(x =>\n        {\n            // Handle message here...\n        });\n    }\n\n    public class DemoActorLocalMessage1\n    {\n    }\n\n    public class DemoActorLocalMessage2\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Akka Protocol Settings for Remote Communication\nDESCRIPTION: Implements AkkaProtocolSettings class to manage configuration for handshake timeout, transport failure detection, and heartbeat intervals in remote communication.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class AkkaProtocolSettings\n{\n    public AkkaProtocolSettings(Akka.Configuration.Config config) { }\n    public System.TimeSpan HandshakeTimeout { get; }\n    public Akka.Configuration.Config TransportFailureDetectorConfig { get; }\n    public string TransportFailureDetectorImplementationClass { get; }\n    public System.TimeSpan TransportHeartBeatInterval { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Mailbox Class in Akka.NET\nDESCRIPTION: Represents an actor's mailbox that holds messages to be processed. It implements IRunnable to be executed by dispatchers and provides methods for cleaning up resources and setting the associated actor. The mailbox is the message queue container for an actor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_86\n\nLANGUAGE: C#\nCODE:\n```\npublic class Mailbox : Akka.Dispatch.IRunnable\n    {\n        public Mailbox(Akka.Dispatch.MessageQueues.IMessageQueue messageQueue) { }\n        public Akka.Dispatch.MessageDispatcher Dispatcher { get; }\n        public Akka.Dispatch.MessageQueues.IMessageQueue MessageQueue { get; }\n        public virtual void CleanUp() { }\n        [System.Diagnostics.ConditionalAttribute(\"MAILBOXDEBUG\")]\n        public static void DebugPrint(string message, params object[] args) { }\n        public void Run() { }\n        public virtual void SetActor(Akka.Actor.ActorCell actorCell) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing TcpSettings Configuration Class in C#\nDESCRIPTION: Defines the TcpSettings class for configuring TCP-related behavior. Contains properties for buffer pools, timeouts, dispatcher settings, and factory methods for creating settings from configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_170\n\nLANGUAGE: C#\nCODE:\n```\npublic class TcpSettings\n{\n    public TcpSettings(string bufferPoolConfigPath, int initialSocketAsyncEventArgs, bool traceLogging, int batchAcceptLimit, System.Nullable<System.TimeSpan> registerTimeout, int receivedMessageSizeLimit, string managementDispatcher, string fileIoDispatcher, int transferToLimit, int finishConnectRetries, bool outgoingSocketForceIpv4, int writeCommandsQueueMaxSize) { }\n    public int BatchAcceptLimit { get; }\n    public string BufferPoolConfigPath { get; }\n    public string FileIODispatcher { get; }\n    public int FinishConnectRetries { get; }\n    public int InitialSocketAsyncEventArgs { get; }\n    public string ManagementDispatcher { get; }\n    public bool OutgoingSocketForceIpv4 { get; }\n    public int ReceivedMessageSizeLimit { get; }\n    public System.Nullable<System.TimeSpan> RegisterTimeout { get; }\n    public bool TraceLogging { get; }\n    public int TransferToLimit { get; set; }\n    public int WriteCommandsQueueMaxSize { get; }\n    public static Akka.IO.TcpSettings Create(Akka.Actor.ActorSystem system) { }\n    public static Akka.IO.TcpSettings Create(Akka.Configuration.Config config) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Data in Akka.DistributedData Replicator\nDESCRIPTION: Shows how to update and replicate data in the distributed data store using a Replicator.Update request. It demonstrates setting write consistency and handling the response.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/distributed-data.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing Akka.Cluster;\nusing Akka.DistributedData;\nusing static Akka.DistributedData.Dsl;\n\nvar cluster = Cluster.Get(system);\nvar replicator = DistributedData.Get(system).Replicator;\nvar key = new ORSetKey<string>(\"keyA\");\nvar set = ORSet.Create(cluster, \"value\");\nvar writeConsistency = new WriteTo(3, TimeSpan.FromSeconds(1));\n\nvar response = await replicator.Ask<Replicator.IUpdateResponse>(Update(key, set, writeConsistency, old => old.Merge(set)));\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Messages of Type string in Akka.NET\nDESCRIPTION: This snippet shows how to subscribe to messages of a specific type (string in this case) using the EventStream in Akka.NET. It creates an actor system, subscribes an actor to string messages, and publishes a string message.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/event-bus.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar system = ActorSystem.Create(\"MySystem\");\nvar subscriber = system.ActorOf<SomeActor>();\n//Subscribe to messages of type string\nsystem.EventStream.Subscribe(subscriber,typeof(string));\n//send a message\nsystem.EventStream.Publish(\"hello\"); //this will be forwarded to subscriber\n```\n\n----------------------------------------\n\nTITLE: Configuring ClusterSingletonProxy in C#\nDESCRIPTION: Shows how to set up a ClusterSingletonProxy to access the singleton actor from any cluster node.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-singleton.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nsystem.ActorOf(ClusterSingletonProxy.Props(\n    singletonManagerPath: \"/user/consumer\",\n    settings: ClusterSingletonProxySettings.Create(system).WithRole(\"worker\")),\n    name: \"consumerProxy\");\n```\n\n----------------------------------------\n\nTITLE: Actor System Core Interfaces in C#\nDESCRIPTION: Defines core interfaces for the Akka.NET actor system including IDecider, IExtension, IScheduler, IStash and various other interfaces for actor lifecycle management and message handling. These interfaces form the foundation of Akka.NET's actor model implementation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IDecider\n{\n    Akka.Actor.Directive Decide(System.Exception cause);\n}\n\npublic interface IExtension { }\n\npublic interface IExtensionId\n{\n    System.Type ExtensionType { get; }\n    object Apply(Akka.Actor.ActorSystem system);\n    object CreateExtension(Akka.Actor.ExtendedActorSystem system);\n    object Get(Akka.Actor.ActorSystem system);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SqlSnapshotStore for Akka.NET Persistence in C#\nDESCRIPTION: Abstract class for SQL-based snapshot store in Akka.NET, implementing the SnapshotStore interface. It provides methods for saving, loading, and deleting snapshots using SQL database.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.DotNet.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class SqlSnapshotStore : Akka.Persistence.Snapshot.SnapshotStore, Akka.Actor.IActorStash, Akka.Actor.IWithUnboundedStash, Akka.Actor.IWithUnrestrictedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics>\n{\n    protected readonly Akka.Persistence.Sql.Common.SnapshotStoreSettings Settings;\n    protected SqlSnapshotStore(Akka.Configuration.Config config) { }\n    protected Akka.Event.ILoggingAdapter Log { get; }\n    public abstract Akka.Persistence.Sql.Common.Snapshot.ISnapshotQueryExecutor QueryExecutor { get; }\n    public Akka.Actor.IStash Stash { get; set; }\n    // ... (methods omitted for brevity)\n}\n```\n\n----------------------------------------\n\nTITLE: Example Logging Configuration for Akka.NET\nDESCRIPTION: This complete logging configuration example for Akka.NET encompasses log levels and debugging settings, which can be used to fine-tune the logging output at different system states.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/logging.md#2025-04-16_snippet_6\n\nLANGUAGE: hocon\nCODE:\n```\nakka {\n  stdout-loglevel = DEBUG\n  loglevel = DEBUG\n  log-config-on-start = on\n  actor {\n    debug {\n      receive = on\n      autoreceive = on\n      lifecycle = on\n      event-stream = on\n      unhandled = on\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: ClusterReceptionist Actor Implementation in C#\nDESCRIPTION: An actor implementation that manages connections from cluster clients to cluster services, handling message routing, pubsub integration, and client heartbeating.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterReceptionist : Akka.Actor.ActorBase\n{\n    public ClusterReceptionist(Akka.Actor.IActorRef pubSubMediator, Akka.Cluster.Tools.Client.ClusterReceptionistSettings settings) { }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n    public static Akka.Actor.Props Props(Akka.Actor.IActorRef pubSubMediator, Akka.Cluster.Tools.Client.ClusterReceptionistSettings settings) { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SupervisorStrategy in C# for Akka.NET\nDESCRIPTION: This abstract class defines the supervisor strategy for handling actor failures in Akka.NET. It includes default strategies and a decider for determining how to handle exceptions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_50\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class SupervisorStrategy : Akka.Util.ISurrogated\n{\n    public static Akka.Actor.IDecider DefaultDecider;\n    public static readonly Akka.Actor.SupervisorStrategy DefaultStrategy;\n    public static readonly Akka.Actor.OneForOneStrategy StoppingStrategy;\n    protected SupervisorStrategy() { }\n    public abstract Akka.Actor.IDecider Decider { get; }\n    protected bool LoggingEnabled { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing ActorSystem and Materializer\nDESCRIPTION: Creates the ActorSystem and materializer required for stream execution\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/quickstart.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nusing (var system = ActorSystem.Create(\"system\"))\nusing (var materializer = system.Materializer())\n```\n\n----------------------------------------\n\nTITLE: Testing Device Actor Read and Write Functionality in C#\nDESCRIPTION: Unit test for the Device actor, verifying both temperature recording and querying functionality. Uses Akka.TestKit to create test probes and assert expected behavior.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-2.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n[Fact]\npublic void Device_actor_should_reply_with_latest_temperature_reading()\n{\n    var probe = CreateTestProbe();\n    var deviceActor = Sys.ActorOf(Props.Create<Device>());\n\n    deviceActor.Tell(new RecordTemperature(requestId: 1, value: 24.0), probe.Ref);\n    probe.ExpectMsg<TemperatureRecorded>(s => s.Id == 1);\n\n    deviceActor.Tell(new ReadTemperature(requestId: 2), probe.Ref);\n    probe.ExpectMsg<RespondTemperature>(s => s.RequestId == 2 && s.Value == 24.0);\n\n    deviceActor.Tell(new RecordTemperature(requestId: 3, value: 55.0), probe.Ref);\n    probe.ExpectMsg<TemperatureRecorded>(s => s.Id == 3);\n\n    deviceActor.Tell(new ReadTemperature(requestId: 4), probe.Ref);\n    probe.ExpectMsg<RespondTemperature>(s => s.RequestId == 4 && s.Value == 55.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Initial Cluster State in Akka.NET\nDESCRIPTION: Shows how to retrieve the current state of the cluster upon initial subscription. This can be done either as a snapshot or as a stream of events, depending on application needs.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-extension.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// subscribe to all future IMemberEvents and get current state as snapshot\nCluster.Subscribe(Self, ClusterEvent.SubscriptionInitialStateMode.InitialStateAsSnapshot,\n    new[] { typeof(ClusterEvent.IMemberEvent) });\n\n// subscribe to all future IMemberEvents and get current state as event stream\nCluster.Subscribe(Self, ClusterEvent.SubscriptionInitialStateMode.InitialStateAsEvents,\n    new[] { typeof(ClusterEvent.IMemberEvent) });\n```\n\n----------------------------------------\n\nTITLE: Implementing Remote DeathWatch in Akka.NET Actor\nDESCRIPTION: Example showing how to set up DeathWatch monitoring in an Akka.NET actor to track remote actor lifecycle and handle termination events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/remoting/deathwatch.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyActor : ReceiveActor{\n    public MyActor(){\n        Receive<Foo>(x => {\n            // notify us if the actor who sent\n            // this message dies in the future.\n            Context.Watch(Sender);\n        });\n\n        // message we'll receive anyone we DeathWatch\n        // dies, OR if the network terminates\n        Receive<Terminated>(t => {\n            // ...\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Device Manager Actor in Akka.NET (C#)\nDESCRIPTION: This snippet demonstrates the implementation of the Device Manager actor, which serves as the entry point for the device management component. It creates and manages Device Group actors for different group IDs.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-3.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DeviceManager : UntypedActor\n{\n    private Dictionary<string, IActorRef> _groupIdToActor = new Dictionary<string, IActorRef>();\n    private ILoggingAdapter Log = Context.GetLogger();\n\n    protected override void PreStart() => Log.Info(\"DeviceManager started\");\n    protected override void PostStop() => Log.Info(\"DeviceManager stopped\");\n\n    protected override void OnReceive(object message)\n    {\n        switch (message)\n        {\n            case RequestTrackDevice trackMsg:\n                if (_groupIdToActor.TryGetValue(trackMsg.GroupId, out var actorRef))\n                {\n                    actorRef.Forward(trackMsg);\n                }\n                else\n                {\n                    Log.Info($\"Creating device group actor for {trackMsg.GroupId}\");\n                    var groupActor = Context.ActorOf(Props.Create(() =>\n                        new DeviceGroup(trackMsg.GroupId)), $\"group-{trackMsg.GroupId}\");\n                    Context.Watch(groupActor);\n                    _groupIdToActor.Add(trackMsg.GroupId, groupActor);\n                    groupActor.Forward(trackMsg);\n                }\n                break;\n            case Terminated t:\n                var groupId = _groupIdToActor.FirstOrDefault(x => x.Value.Equals(t.ActorRef)).Key;\n                if (groupId != null)\n                {\n                    Log.Info($\"Device group actor for {groupId} has been terminated\");\n                    _groupIdToActor.Remove(groupId);\n                }\n                break;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Complete NumbersSource with GraphStage Logic\nDESCRIPTION: Shows the complete implementation of a custom Source that emits incrementing numbers. Includes state management within GraphStageLogic and handling of downstream demand through onPull callback.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/custom-stream-processing.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Streams.Stage;\n\nclass NumbersSource : GraphStage<SourceShape<int>>\n{\n    //this is where the actual (possibly statefull) logic will live\n    private sealed class Logic : GraphStageLogic\n    {\n        // All state MUST be inside the GraphStageLogic,\n        // never inside the enclosing GraphStage.\n        // This state is safe to access and modify from all the\n        // callbacks that are provided by GraphStageLogic and the\n        // registered handlers.\n        private int _counter = 1;\n\n        public Logic(NumbersSource source) : base(source.Shape)\n        {\n            SetHandler(source.Out, onPull: () => Push(source.Out, _counter++));\n        }\n    }\n\n    // Define the (sole) output port of this stage \n    public Outlet<int> Out { get; } = new Outlet<int>(\"NumbersSource\");\n\n    // Define the shape of this stage, which is SourceShape with the port we defined above\n    public override SourceShape<int> Shape => new SourceShape<int>(Out);\n\n    //this is where the actual logic will be created\n    protected override GraphStageLogic CreateLogic(Attributes inheritedAttributes) => new Logic(this);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Non-Seed Node for Akka.Cluster\nDESCRIPTION: HOCON configuration for setting up a regular (non-seed) node in Akka.Cluster. Uses random port assignment and connects to a specified seed node.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-overview.md#2025-04-16_snippet_2\n\nLANGUAGE: xml\nCODE:\n```\nakka {\n    actor.provider = cluster\n    remote {\n        dot-netty.tcp {\n            port = 0 #let os pick random port\n            hostname = localhost\n        }\n    }\n    cluster {\n        seed-nodes = [\"akka.tcp://ClusterSystem@localhost:8081\"]\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Split Brain Resolver Strategy in Akka.NET HOCON\nDESCRIPTION: Detailed configuration for the Split Brain Resolver in Akka.NET, including strategy selection, stability threshold, and down-all-when-unstable option.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/split-brain-resolver.md#2025-04-16_snippet_2\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster.downing-provider-class = \"Akka.Cluster.SBR.SplitBrainResolverProvider, Akka.Cluster\"\nakka.cluster.split-brain-resolver {\n  # Enable one of the available strategies (see descriptions below):\n  # static-quorum, keep-majority, keep-oldest, keep-referee \n  active-strategy = off\n  \n  # Decision is taken by the strategy when there has been no membership or\n  # reachability changes for this duration, i.e. the cluster state is stable.\n  stable-after = 20s\n\n  # When reachability observations by the failure detector are changed the SBR decisions\n  # are deferred until there are no changes within the 'stable-after' duration.\n  # If this continues for too long it might be an indication of an unstable system/network\n  # and it could result in delayed or conflicting decisions on separate sides of a network\n  # partition.\n  #\n  # As a precaution for that scenario all nodes are downed if no decision is made within\n  # `stable-after + down-all-when-unstable` from the first unreachability event.\n  # The measurement is reset if all unreachable have been healed, downed or removed, or\n  # if there are no changes within `stable-after * 2`.\n  #\n  # The value can be on, off, or a duration.\n  #\n  # By default it is 'on' and then it is derived to be 3/4 of stable-after, but not less than\n  # 4 seconds.\n  down-all-when-unstable = on\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SqlReadJournal Class for Akka.NET Persistence Query\nDESCRIPTION: Defines the SqlReadJournal class which implements multiple interfaces from Akka.Persistence.Query namespace. It provides methods for querying events and persistence IDs from a SQL-based journal.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommonQuery.Net.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class SqlReadJournal : Akka.Persistence.Query.IAllEventsQuery, Akka.Persistence.Query.ICurrentAllEventsQuery, Akka.Persistence.Query.ICurrentEventsByPersistenceIdQuery, Akka.Persistence.Query.ICurrentEventsByTagQuery, Akka.Persistence.Query.ICurrentPersistenceIdsQuery, Akka.Persistence.Query.IEventsByPersistenceIdQuery, Akka.Persistence.Query.IEventsByTagQuery, Akka.Persistence.Query.IPersistenceIdsQuery, Akka.Persistence.Query.IReadJournal\n{\n    public const string Identifier = \"akka.persistence.query.journal.sql\";\n    public SqlReadJournal(Akka.Actor.ExtendedActorSystem system, Akka.Configuration.Config config) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> AllEvents(Akka.Persistence.Query.Offset offset = null) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentAllEvents(Akka.Persistence.Query.Offset offset) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentEventsByPersistenceId(string persistenceId, long fromSequenceNr, long toSequenceNr) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentEventsByTag(string tag, Akka.Persistence.Query.Offset offset = null) { }\n    public Akka.Streams.Dsl.Source<string, Akka.NotUsed> CurrentPersistenceIds() { }\n    public static Akka.Configuration.Config DefaultConfiguration() { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> EventsByPersistenceId(string persistenceId, long fromSequenceNr, long toSequenceNr) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> EventsByTag(string tag, Akka.Persistence.Query.Offset offset = null) { }\n    public Akka.Streams.Dsl.Source<string, Akka.NotUsed> PersistenceIds() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Receive Timeout in C#\nDESCRIPTION: Demonstrates how to set and handle receive timeouts in actors for managing inactivity periods.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyActor : UntypedActor\n{\n    private ILoggingAdapter log = Context.GetLogger();\n\n    protected override void OnReceive(object message)\n    {\n        switch (message)\n        {\n            case \"Hello\":\n                Context.SetReceiveTimeout(TimeSpan.FromMilliseconds(100));\n                break;\n            case ReceiveTimeout r:\n                Context.SetReceiveTimeout(null);\n                throw new Exception(\"Receive timed out\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Actor with Overflow Stash in Akka.NET\nDESCRIPTION: This code defines an actor, `StashingActorWithOverflow`, that can be configured with a bounded stash. While the class definition itself doesn't specify the stash size, it implements `IWithStash` which allows the stash capacity to be set via props or HOCON configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_26\n\nLANGUAGE: csharp\nCODE:\n```\npublic class StashingActorWithOverflow : UntypedActor, IWithStash\n```\n\n----------------------------------------\n\nTITLE: Handling Device Responses in Akka.NET Query Actor\nDESCRIPTION: Implementation of the ReceivedResponse method that processes temperature readings from devices. It updates the collection of responses, removes devices from the waiting list, and completes the query when all devices have responded.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-4.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nprivate void ReceivedResponse(\n    IActorRef deviceActor,\n    long requestId,\n    double? temperature,\n    Dictionary<string, TemperatureReading> repliesSoFar,\n    HashSet<IActorRef> stillWaiting)\n{\n    Context.Unwatch(deviceActor);\n    var deviceId = ActorToDeviceId[deviceActor];\n    \n    stillWaiting.Remove(deviceActor);\n\n    TemperatureReading reading;\n    if (temperature.HasValue)\n    {\n        reading = new Temperature(temperature.Value);\n    }\n    else\n    {\n        reading = DeviceNotAvailable.Instance;\n    }\n    \n    repliesSoFar.Add(deviceId, reading);\n\n    if (stillWaiting.Count == 0)\n    {\n        Requester.Tell(new RespondAllTemperatures(RequestId, repliesSoFar));\n        Context.Stop(Self);\n    }\n    else\n    {\n        Context.Become(WaitingForReplies(repliesSoFar, stillWaiting));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Recovery Completion in Persistent Actor in C#\nDESCRIPTION: This snippet shows how to perform additional initialization after recovery is completed by handling the RecoveryCompleted message in the OnRecover method.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/event-sourcing.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override void OnRecover(object message)\n{\n    switch(message)\n    {\n        case RecoveryCompleted _:\n            // perform init after recovery, before any other messages\n            break;\n        // ...\n    }\n}\n\nprotected override void OnCommand(object message)\n{\n    // ..\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Maximum Frame Size in Akka.Remote\nDESCRIPTION: HOCON configuration example showing how to increase the maximum message frame size for remote communication to 4 MB. This is necessary when sending messages larger than the default 128 kB limit.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/remoting/index.md#2025-04-16_snippet_0\n\nLANGUAGE: hocon\nCODE:\n```\nakka {\n    dot-netty.tcp {\n        # Maximum frame size: 4 MB\n        maximum-frame-size = 4000000b\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Core Replicated Data Interfaces in Akka.NET\nDESCRIPTION: Core interfaces for replicated data types in Akka.NET's distributed data system. These interfaces define the basic operations and behaviors of replicated data structures.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IReplicatedData\n{\n    Akka.DistributedData.IReplicatedData Merge(Akka.DistributedData.IReplicatedData other);\n}\npublic interface IReplicatedDataSerialization { }\npublic interface IReplicatedData<T> : Akka.DistributedData.IReplicatedData\n    where T : Akka.DistributedData.IReplicatedData\n{\n    T Merge(T other);\n}\n```\n\n----------------------------------------\n\nTITLE: CircuitBreaker Class Implementation in C#\nDESCRIPTION: Implements circuit breaker pattern for fault tolerance with configurable failure thresholds, timeouts, and exponential backoff. Includes methods for handling circuit state transitions and executing protected code blocks.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_165\n\nLANGUAGE: csharp\nCODE:\n```\npublic class CircuitBreaker\n{\n    public CircuitBreaker(Akka.Actor.IScheduler scheduler, int maxFailures, System.TimeSpan callTimeout, System.TimeSpan resetTimeout) { }\n    public CircuitBreaker(Akka.Actor.IScheduler scheduler, int maxFailures, System.TimeSpan callTimeout, System.TimeSpan resetTimeout, System.TimeSpan maxResetTimeout, double exponentialBackoffFactor) { }\n    public CircuitBreaker(Akka.Actor.IScheduler scheduler, int maxFailures, System.TimeSpan callTimeout, System.TimeSpan resetTimeout, System.TimeSpan maxResetTimeout, double exponentialBackoffFactor, double randomFactor) { }\n```\n\n----------------------------------------\n\nTITLE: Handling Unmatched Messages in C#\nDESCRIPTION: Explains handling messages with no matching handlers via the EventStream and UnhandledMessage. The Unhandled method can be overridden to customize this behavior, or a catch-all handler with ReceiveAny can be defined last to manage unmatched messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka/Util/MatchHandler/README.md#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nprotected override void Unhandled(object message)\n{\n  //Do something with the message.\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Receive Timeout in Akka.NET\nDESCRIPTION: This snippet demonstrates how to set a receive timeout for an actor using `Context.SetReceiveTimeout`. When the timeout expires, the actor receives a `ReceiveTimeout` message. The example also shows how to disable the timeout by setting it to `null`.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_23\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyActor : ReceiveActor\n{\n    private ILoggingAdapter log = Context.GetLogger();\n\n    public MyActor()\n    {\n        Receive<string>(s => s.Equals(\"Hello\"), msg =>\n        {\n            Context.SetReceiveTimeout(TimeSpan.FromMilliseconds(100));\n        });\n\n        Receive<ReceiveTimeout>(msg =>\n        {\n            Context.SetReceiveTimeout(null);\n            throw new Exception(\"Receive timed out\");\n            return;\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AtomicBoolean Class in C#\nDESCRIPTION: A thread-safe boolean wrapper that provides atomic operations like CompareAndSet and GetAndSet. Supports implicit conversion to boolean type for convenient usage.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_230\n\nLANGUAGE: C#\nCODE:\n```\npublic class AtomicBoolean\n{\n    public AtomicBoolean(bool initialValue = False) { }\n    public bool Value { get; set; }\n    public bool CompareAndSet(bool expected, bool newValue) { }\n    public bool GetAndSet(bool newValue) { }\n    public static bool op_Implicit(Akka.Util.AtomicBoolean atomicBoolean) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Unhandled Events in Akka.NET FSM\nDESCRIPTION: This code shows how to handle unhandled events in the FSM actor, such as queueing messages and logging warnings for unexpected events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/finite-state-machine.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/core/Akka.Docs.Tests/Actors/FiniteStateMachine/ExampleFSMActor.cs?name=UnhandledHandler)]\n```\n\n----------------------------------------\n\nTITLE: Implementing MessageSent Struct for Tracking Sent Messages\nDESCRIPTION: Defines a structure that represents a sent message with its sequence number and timestamp. Includes methods for creating messages from chunked data and managing message qualifiers.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_79\n\nLANGUAGE: C#\nCODE:\n```\npublic Akka.Delivery.Internal.MessageOrChunk<T> Message { get; set; }\npublic long SeqNr { get; set; }\npublic long Timestamp { get; set; }\npublic bool Equals([System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n        2,\n        1})] Akka.Delivery.DurableProducerQueue.MessageSent<T> other) { }\npublic static Akka.Delivery.DurableProducerQueue.MessageSent<T> FromChunked(long seqNo, Akka.Delivery.Internal.ChunkedMessage chunkedMessage, bool ack, string confirmationQualifier, long timestamp) { }\npublic static Akka.Delivery.DurableProducerQueue.MessageSent<T> FromMessageOrChunked(long seqNo, [System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n        0,\n        1})] Akka.Delivery.Internal.MessageOrChunk<T> messageOrChunk, bool ack, string confirmationQualifier, long timestamp) { }\npublic override int GetHashCode() { }\npublic override string ToString() { }\npublic Akka.Delivery.DurableProducerQueue.MessageSent<T> WithQualifier(string qualifier) { }\npublic Akka.Delivery.DurableProducerQueue.MessageSent<T> WithTimestamp(long timestamp) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ReceiveTimeout for Idle Actor Detection\nDESCRIPTION: Shows how to implement idle timeout detection using the ReceiveTimeout feature. This creates a sliding window timeout that resets with each message and triggers a timeout message when the actor is idle.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/schedulers.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ReceiveTimeoutActor : ReceiveActor\n{\n    public ReceiveTimeoutActor()\n    {\n        // After 5 seconds without receiving any message, the\n        // receive method Actor.ReceiveTimeout will be called\n        Context.SetReceiveTimeout(TimeSpan.FromSeconds(5));\n\n        Receive<string>(str => {\n            Console.WriteLine($\"Received [{str}]\");\n            if (str.Equals(\"Stop\"))\n            {\n                // To turn it off\n                Context.SetReceiveTimeout(null);\n            }\n        });\n\n        // when the actor has been idle for 5 seconds\n        Receive<ReceiveTimeout>(timeout =>\n        {\n            Console.WriteLine(\"Received timeout\");\n\n            // could also shut self down or flush a cache to disk\n            // or any number of things\n\n            // cancel the receive timeout for now\n            Context.SetReceiveTimeout(null);\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AtomicCounter Class\nDESCRIPTION: An atomic counter implementation for integers that provides thread-safe incrementing, decrementing and other operations. Used for generating sequences of unique IDs or counting events in a concurrent environment.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_225\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.Util.Internal\n{\n    public class AtomicCounter : Akka.Util.Internal.IAtomicCounter<int>\n    {\n        public AtomicCounter(int initialValue) { }\n        public AtomicCounter() { }\n        public int Current { get; }\n        public int AddAndGet(int amount) { }\n        public bool CompareAndSet(int expected, int newValue) { }\n        public int Decrement() { }\n        public int DecrementAndGet() { }\n        public int GetAndAdd(int amount) { }\n        public int GetAndDecrement() { }\n        public int GetAndIncrement() { }\n        public int GetAndSet(int value) { }\n        public int IncrementAndGet() { }\n        public int Next() { }\n        public void Reset() { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Duplicator Transformation Stage in C#\nDESCRIPTION: This snippet defines a `Duplicator` stage that emits each upstream element twice downstream. It also handles upstream completion and manages internal state for duplication.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/custom-stream-processing.md#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nclass Duplicator<T> : GraphStage<FlowShape<T, T>>\n{\n    private sealed class Logic : GraphStageLogic\n    {\n        Option<T> _lastElement = Option<T>.None;\n\n        public Logic(Duplicator<T> duplicator) : base(duplicator.Shape)\n        {\n            SetHandler(duplicator.In,\n                onPush: () =>\n                {\n                    var element = Grab(duplicator.In);\n                    _lastElement = element;\n                    Push(duplicator.Out, element);\n                },\n                onUpstreamFinish: () =>\n                {\n                    if(_lastElement.HasValue)\n                        Emit(duplicator.Out, _lastElement.Value);\n\n                    Complete(duplicator.Out);\n                });\n\n            SetHandler(duplicator.Out, onPull: () =>\n            {\n                if (_lastElement.HasValue)\n                {\n                    Push(duplicator.Out, _lastElement.Value);\n                    _lastElement = Option<T>.None;\n                }\n                else\n                    Pull(duplicator.In);\n            });\n        }\n    }\n    \n    public Duplicator(Predicate<T> predicate)\n    {\n        Shape = new FlowShape<T, T>(In, Out);\n    }\n\n    public Inlet<T> In { get; } = new Inlet<T>(\"Duplicator.in\");\n\n    public Outlet<T> Out { get; } = new Outlet<T>(\"Duplicator.out\");\n\n    public override FlowShape<T, T> Shape { get; }\n\n    protected override GraphStageLogic CreateLogic(Attributes inheritedAttributes) => new Logic(this);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining States for Persistent FSM in C#\nDESCRIPTION: Implementation of states for a WebStoreCustomerFSMActor, showing the different states a customer can be in while browsing a web store. States must inherit from PersistentFSM.IFsmState and implement a string Identifier property.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistent-fsm.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n`LookingAround` customer is browsing the site, but hasn't added anything to the shopping cart `Shopping` customer has recently added items to the shopping cart `Inactive` customer has items in the shopping cart, but hasn't added anything recently `Paid` customer has purchased the items\n```\n\n----------------------------------------\n\nTITLE: Implementing OneForOneStrategy Supervisor in C#\nDESCRIPTION: Defines the OneForOneStrategy class, which is a supervision strategy in Akka.NET. It includes various constructors for different configuration options and methods for handling child actor failures.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\npublic class OneForOneStrategy : Akka.Actor.SupervisorStrategy, System.IEquatable<Akka.Actor.OneForOneStrategy>\n{\n    public OneForOneStrategy(System.Nullable<int> maxNrOfRetries, System.Nullable<System.TimeSpan> withinTimeRange, System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider) { }\n    public OneForOneStrategy(System.Nullable<int> maxNrOfRetries, System.Nullable<System.TimeSpan> withinTimeRange, Akka.Actor.IDecider decider) { }\n    public OneForOneStrategy(int maxNrOfRetries, int withinTimeMilliseconds, System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider, bool loggingEnabled = True) { }\n    public OneForOneStrategy(int maxNrOfRetries, int withinTimeMilliseconds, Akka.Actor.IDecider decider, bool loggingEnabled = True) { }\n    public OneForOneStrategy(System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider) { }\n    public OneForOneStrategy(System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider, bool loggingEnabled = True) { }\n    public OneForOneStrategy(Akka.Actor.IDecider decider) { }\n    protected OneForOneStrategy() { }\n    public override Akka.Actor.IDecider Decider { get; }\n    public int MaxNumberOfRetries { get; }\n    public int WithinTimeRangeMilliseconds { get; }\n    public bool Equals(Akka.Actor.OneForOneStrategy other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    protected override Akka.Actor.Directive Handle(Akka.Actor.IActorRef child, System.Exception exception) { }\n    public override void HandleChildTerminated(Akka.Actor.IActorContext actorContext, Akka.Actor.IActorRef child, System.Collections.Generic.IEnumerable<Akka.Actor.IInternalActorRef> children) { }\n    public override void ProcessFailure(Akka.Actor.IActorContext context, bool restart, Akka.Actor.IActorRef child, System.Exception cause, Akka.Actor.Internal.ChildRestartStats stats, System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> children) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Actor.OneForOneStrategy WithMaxNrOfRetries(int maxNrOfRetries) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ActorPath Class in C#\nDESCRIPTION: The ActorPath class represents the address of an actor in the actor system. It provides methods for parsing, comparing, and manipulating actor paths.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ActorPath : Akka.Util.ISurrogated, System.IComparable<Akka.Actor.ActorPath>, System.IEquatable<Akka.Actor.ActorPath>\n{\n    public const string ValidSymbols = \"\\\"-_.*$+:@&=,!~';()\";\n    protected ActorPath(Akka.Actor.Address address, string name) { }\n    protected ActorPath(Akka.Actor.ActorPath parentPath, string name, long uid) { }\n    public Akka.Actor.Address Address { get; }\n    public int Depth { get; }\n    public System.Collections.Generic.IReadOnlyList<string> Elements { get; }\n    public string Name { get; }\n    public Akka.Actor.ActorPath Parent { get; }\n    [Newtonsoft.Json.JsonIgnoreAttribute()]\n    public Akka.Actor.ActorPath Root { get; }\n    public long Uid { get; }\n    // ... (other methods)\n}\n```\n\n----------------------------------------\n\nTITLE: RestartSource with KillSwitch Implementation\nDESCRIPTION: Demonstrates combining RestartSource with a KillSwitch for controlled stream termination.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/error-handling.md#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n[!code-csharp[RestartDocTests.cs](../../../src/core/Akka.Docs.Tests/Streams/RestartDocTests.cs?name=with-kill-switch)]\n```\n\n----------------------------------------\n\nTITLE: Implementing OneForOneStrategy Class in Akka.NET Actor System\nDESCRIPTION: Defines the OneForOneStrategy supervision strategy that handles child actor failures individually. Provides multiple constructor overloads with options for retry limits, time windows, and custom exception handlers.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic OneForOneStrategy(System.Nullable<int> maxNrOfRetries, System.Nullable<System.TimeSpan> withinTimeRange, System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider) { }\npublic OneForOneStrategy(System.Nullable<int> maxNrOfRetries, System.Nullable<System.TimeSpan> withinTimeRange, Akka.Actor.IDecider decider) { }\npublic OneForOneStrategy(int maxNrOfRetries, int withinTimeMilliseconds, System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider, bool loggingEnabled = True) { }\npublic OneForOneStrategy(int maxNrOfRetries, int withinTimeMilliseconds, Akka.Actor.IDecider decider, bool loggingEnabled = True) { }\npublic OneForOneStrategy(System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider) { }\npublic OneForOneStrategy(System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider, bool loggingEnabled = True) { }\npublic OneForOneStrategy(Akka.Actor.IDecider decider) { }\nprotected OneForOneStrategy() { }\npublic override Akka.Actor.IDecider Decider { get; }\npublic int MaxNumberOfRetries { get; }\npublic int WithinTimeRangeMilliseconds { get; }\npublic bool Equals(Akka.Actor.OneForOneStrategy other) { }\npublic override bool Equals(object obj) { }\npublic override int GetHashCode() { }\nprotected override Akka.Actor.Directive Handle(Akka.Actor.IActorRef child, System.Exception exception) { }\npublic override void HandleChildTerminated(Akka.Actor.IActorContext actorContext, Akka.Actor.IActorRef child, System.Collections.Generic.IEnumerable<Akka.Actor.IInternalActorRef> children) { }\npublic override void ProcessFailure(Akka.Actor.IActorContext context, bool restart, Akka.Actor.IActorRef child, System.Exception cause, Akka.Actor.Internal.ChildRestartStats stats, System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> children) { }\npublic override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\npublic Akka.Actor.OneForOneStrategy WithMaxNrOfRetries(int maxNrOfRetries) { }\n```\n\n----------------------------------------\n\nTITLE: Using SharedKillSwitch for Shutdown in Akka.NET Streams\nDESCRIPTION: Example of using SharedKillSwitch to control the completion of multiple Graphs of FlowShape. This snippet demonstrates shutting down multiple streams.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/stream-dynamic.md#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n[!code-csharp[KillSwitchDocTests.cs](../../../src/core/Akka.Docs.Tests/Streams/KillSwitchDocTests.cs?name=shared-shutdown)]\n```\n\n----------------------------------------\n\nTITLE: Caching ActorMaterializer in Akka.NET Actor\nDESCRIPTION: This resolution creates a single ActorMaterializer instance as a field when the actor is instantiated, ensuring it's reused for all stream operations. It also properly disposes of the materializer when the actor is stopped.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK2002.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Actor;\nusing Akka.Streams;\nusing Akka.Streams.Dsl;\n\npublic sealed class MyActor : ReceiveActor\n{\n    private readonly ActorMaterializer _materializer;\n    \n    public MyActor()\n    {\n        _materializer = Context.Materializer();\n        \n        ReceiveAsync<string>(\n            s => s == \"hello\",\n            async _ =>\n            {\n                await Source.Single(1)\n                    .Select(x => x + 1)\n                    .ToMaterialized(Sink.ForEach<int>(_ => { }), Keep.Right)\n                    .Run(_materializer); // Use a cached ActorMaterializer\n            });\n    }\n\n    protected override void PostStop()\n    {\n        _materializer.Dispose(); // Dispose the ActorMaterializer when the actor is stopped.\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Stash in Akka.NET with UntypedActorWithStash\nDESCRIPTION: This code demonstrates how to use the `UntypedActorWithStash` class to stash messages temporarily.  The `ActorWithProtocol` stashes messages until it receives an \"open\" message, then unstashes them and switches to a new behavior where it can handle \"write\" and \"close\" messages.  The stash allows the actor to maintain message order while waiting for a specific state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_25\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ActorWithProtocol : UntypedActorWithStash\n{\n    protected override void OnReceive(object message)\n    {\n        switch (message)\n        {\n            case \"open\":\n                Stash.UnstashAll();\n                BecomeStacked(msg =>\n                {\n                    switch (msg)\n                    {\n                        case \"write\":\n                            // do writing...\n                            break;\n                        case \"close\":\n                            Stash.UnstashAll();\n                            Context.UnbecomeStacked();\n                            break;\n                        default:\n                            Stash.Stash();\n                            break;\n                    }\n                });\n                break;\n            default:\n                Stash.Stash();\n                break;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom Stream Extensions in C#\nDESCRIPTION: This code demonstrates how to use the custom Filter extension method in a stream pipeline. It shows the integration of custom operators with built-in Akka.NET stream operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/custom-stream-processing.md#2025-04-16_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\nvar resultTask = Source.From(new [] {1,2,3,4,5})\n    .Filter(n => n % 2 == 0)\n    .Via(new Duplicator<int>())\n    .Via(new Map<int, int>(n=>n/2))\n    .RunAggregate(0, (sum, next) => sum + next, materializer);\n```\n\n----------------------------------------\n\nTITLE: Balancing Jobs to Workers in Akka.NET Streams\nDESCRIPTION: This snippet shows how to balance jobs to a fixed pool of workers in Akka.NET Streams. It uses a `Balance` node to distribute jobs and a `Merge` node to collect the results.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/cookbook.md#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\npublic Flow<TIn, TOut, NotUsed> Balancer<TIn, TOut>(Flow<TIn, TOut, NotUsed> worker, int workerCount)\n{\n    return Flow.FromGraph(GraphDsl.Create(b =>\n    {\n        var balancer = b.Add(new Balance<TIn>(workerCount, waitForAllDownstreams: true));\n        var merge = b.Add(new Merge<TOut>(workerCount));\n\n        for (var i = 0; i < workerCount; i++)\n            b.From(balancer).Via(worker.Async()).To(merge);\n\n        return new FlowShape<TIn, TOut>(balancer.In, merge.Out);\n    }));\n}\n\nvar myJobs = Source.Empty<Job>();\nvar worker = Flow.Create<Job>().Select(j => new Done(j));\nvar processedJobs = myJobs.Via(Balancer(worker, 3));\n```\n\n----------------------------------------\n\nTITLE: Initializing BackoffSupervisor for Persistent Actor in C#\nDESCRIPTION: This snippet demonstrates how to initialize a BackoffSupervisor that manages the restart of a persistent actor after a failure, implementing a back-off strategy to allow the actor to recover. It uses the Props.Create method to create the persistent actor and the BackoffSupervisor.Props method to set up a back-off restart configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/event-sourcing.md#2025-04-16_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override void PreStart()\n{\n    var childProps = Props.Create<PersistentActor>();\n    var props = BackoffSupervisor.Props(\n        Backoff.OnStop(\n            childProps,\n            \"myActor\",\n            TimeSpan.FromSeconds(3),\n            TimeSpan.FromSeconds(30),\n            0.2));\n    Context.ActorOf(props, name: \"mySupervisor\");\n    base.PreStart();\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Flows with TestSource.Probe and TestSink.Probe in C#\nDESCRIPTION: This example shows how to use both TestSource.Probe and TestSink.Probe together to test flows, allowing full control over input and output assertions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/testingstreams.md#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nvar flowUnderTest = Flow.Create<int>().SelectAsyncUnordered(2, sleep => Task.Run(() =>\n{\n    Thread.Sleep(10*sleep);\n    return sleep;\n}));\n\nvar t = this.SourceProbe<int>()\n    .Via(flowUnderTest)\n    .ToMaterialized(this.SinkProbe<int>(), Keep.Both)\n    .Run(materializer);\n\nvar pub = t.Item1;\nvar sub = t.Item2;\n\nsub.Request(3);\npub.SendNext(3);\npub.SendNext(2);\npub.SendNext(1);\n\nsub.ExpectNextUnordered(1, 2, 3);\n\npub.SendError(new Exception(\"Power surge in the linear subroutine C-47!\"));\nvar ex = sub.ExpectError();\nex.Message.Should().Contain(\"C-47\");\n```\n\n----------------------------------------\n\nTITLE: Streaming File IO with Akka Streams\nDESCRIPTION: This snippet demonstrates how to stream data from a file using Akka Streams FileIO source. It also shows how to configure a custom dispatcher for file IO operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithstreamingio.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar file = new FileInfo(\"example.csv\");\nvar result = FileIO.FromFile(file)\n    .To(Sink.Ignore<ByteString>())\n    .Run(materializer);\n```\n\nLANGUAGE: csharp\nCODE:\n```\nFileIO.FromFile(file)\n    .WithAttributes(ActorAttributes.CreateDispatcher(\"custom-blocking-io-dispatcher\"));\n```\n\n----------------------------------------\n\nTITLE: TCP Extensions and Message Handling in Akka.NET\nDESCRIPTION: This snippet defines extension methods and message handling for TCP in Akka.NET, including the TcpExtensions static class and TcpMessage class with various command factory methods for TCP operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_168\n\nLANGUAGE: csharp\nCODE:\n```\n    public class static TcpExtensions\n    {\n        public static Akka.Actor.IActorRef Tcp(this Akka.Actor.ActorSystem system) { }\n    }\n    public class TcpMessage\n    {\n        public TcpMessage() { }\n        public static Akka.IO.Tcp.Command Abort() { }\n        public static Akka.IO.Tcp.Command Bind(Akka.Actor.IActorRef handler, System.Net.EndPoint endpoint, int backlog, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options, bool pullMode) { }\n        public static Akka.IO.Tcp.Command Bind(Akka.Actor.IActorRef handler, System.Net.EndPoint endpoint, int backlog) { }\n        public static Akka.IO.Tcp.Command Close() { }\n        public static Akka.IO.Tcp.Command ConfirmedClose() { }\n        public static Akka.IO.Tcp.Command Connect(System.Net.EndPoint remoteAddress, System.Net.EndPoint localAddress, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options, System.Nullable<System.TimeSpan> timeout, bool pullMode) { }\n        public static Akka.IO.Tcp.Command Connect(System.Net.EndPoint remoteAddress) { }\n        public static Akka.IO.Tcp.NoAck NoAck(object token = null) { }\n        public static Akka.IO.Tcp.Command Register(Akka.Actor.IActorRef handler, bool keepOpenOnPeerClosed = False, bool useResumeWriting = True) { }\n        public static Akka.IO.Tcp.Command ResumeAccepting(int batchSize) { }\n        public static Akka.IO.Tcp.Command ResumeReading() { }\n        public static Akka.IO.Tcp.Command ResumeWriting() { }\n        public static Akka.IO.Tcp.Command SuspendReading() { }\n        public static Akka.IO.Tcp.Command Unbind() { }\n        public static Akka.IO.Tcp.Command Write(Akka.IO.ByteString data, Akka.IO.Tcp.Event ack = null) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Configuring Snapshot Store Plugin in Akka.NET Persistence\nDESCRIPTION: Example configuration for a custom snapshot store plugin in Akka.NET Persistence. This configuration specifies the class and plugin-dispatcher for a local filesystem-based snapshot store.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/storage-plugins.md#2025-04-16_snippet_1\n\nLANGUAGE: json\nCODE:\n```\nakka.persistence.snapshot-store.local {\n  class = \"Akka.Persistence.Snapshot.LocalSnapshotStore, Akka.Persistence\"\n  plugin-dispatcher = \"akka.actor.default-dispatcher\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BackoffOptions Abstract Class in Akka.NET\nDESCRIPTION: Configuration options for backoff supervisor behavior. Provides a fluent interface for configuring reset strategies, supervisor behavior, and retry limits.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_191\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class BackoffOptions\n{\n    protected BackoffOptions() { }\n    public abstract Akka.Pattern.BackoffOptions WithAutoReset(System.TimeSpan resetBackoff);\n    public abstract Akka.Pattern.BackoffOptions WithDefaultStoppingStrategy();\n    public abstract Akka.Pattern.BackoffOptions WithFinalStopMessage(System.Func<object, bool> isFinalStopMessage);\n    public abstract Akka.Pattern.BackoffOptions WithManualReset();\n    public abstract Akka.Pattern.BackoffOptions WithMaxNrOfRetries(int maxNrOfRetries);\n    public abstract Akka.Pattern.BackoffOptions WithReplyWhileStopped(object replyWhileStopped);\n    public abstract Akka.Pattern.BackoffOptions WithSupervisorStrategy(Akka.Actor.OneForOneStrategy supervisorStrategy);\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Events by Tag in C#\nDESCRIPTION: Example of querying events by tag using Akka Streams, demonstrating offset-based pagination and stream manipulation with Take and RunAggregate operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistence-query.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// assuming journal is able to work with numeric offsets we can:\nSource<EventEnvelope, NotUsed> blueThings = readJournal.EventsByTag(\"blue\", 0L);\n\n// find top 10 blue things:\nTask<ImmutableHashSet<object>> top10BlueThings = blueThings\n    .Select(c => c.Event)\n    .Take(10) // cancels the query stream after pulling 10 elements\n    .RunAggregate(\n        ImmutableHashSet<object>.Empty,\n        (acc, c) => acc.Add(c),\n        mat);\n\n// start another query, from the known offset\nvar furtherBlueThings = readJournal.EventsByTag(\"blue\", offset: 10);\n```\n\n----------------------------------------\n\nTITLE: Expecting Messages Asynchronously in Akka.NET TestKitBase\nDESCRIPTION: These methods allow for asynchronous expectation of messages with various conditions and timeouts. They support generic types and can handle different assertion scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic System.Threading.Tasks.ValueTask<T> ExpectMsgAsync<T>(System.Func<T, Akka.Actor.IActorRef, bool> isMessageAndSender, System.Nullable<System.TimeSpan> timeout = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic System.Threading.Tasks.ValueTask<T> ExpectMsgAsync<T>(System.Action<T, Akka.Actor.IActorRef> assertMessageAndSender, System.Nullable<System.TimeSpan> timeout = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic System.Threading.Tasks.ValueTask<T> ExpectMsgAsync<T>(T expected, System.Func<T, T, bool> comparer, System.Nullable<System.TimeSpan> timeout = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Creating and Sending SourceRef in C#\nDESCRIPTION: This code snippet demonstrates how to create a SourceRef from a data source and send it to a remote actor. It includes error handling and uses the PipeTo pattern for asynchronous operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/streamrefs.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nprivate Source<int, NotUsed> _dataSource;\n\nprivate void Handle(StreamInitialized init)\n{\n    _dataSource.RunWith(StreamRefs.SourceRef<int>(), Materializer)\n        .PipeTo(\n            recipient: Sender,\n            success: sourceRef => new StreamInitialized(sourceRef),\n            failure: ex => new Status.Failure(ex));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ORSet Generic Class in C#\nDESCRIPTION: This class represents a distributed set (ORSet) in Akka.NET, implementing various interfaces for replication and delta updates.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ORSet<T> : Akka.DistributedData.FastMerge<Akka.DistributedData.ORSet<T>>, Akka.DistributedData.IDeltaReplicatedData, Akka.DistributedData.IDeltaReplicatedData<Akka.DistributedData.ORSet<T>, Akka.DistributedData.ORSet<T>.IDeltaOperation>, Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IRemovedNodePruning<Akka.DistributedData.ORSet<T>>, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.ORSet<T>>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.IEquatable<Akka.DistributedData.ORSet<T>>\n{\n    // ... (properties and methods omitted for brevity)\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Actor Hierarchy with ActorSelection in C#\nDESCRIPTION: Demonstrates how to use ActorSelection to send a message to all sibling actors including the current actor. ActorSelection supports using wildcards similar to Unix shells for flexible actor targeting.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/concepts/addressing.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nContext.ActorSelection(\"../*\").Tell(msg);\n```\n\n----------------------------------------\n\nTITLE: Checking Timer Status in Akka.NET\nDESCRIPTION: Demonstrates how to check if a specific timer is currently running by using its key. This is useful for conditional logic based on timer state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/schedulers.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n// check if a timer is still active\nif (Timers.IsTimerActive(\"TickKey\"))\n{\n    // do something if the timer is active\n}\n```\n\n----------------------------------------\n\nTITLE: ServiceDiscovery Abstract Class Definition in C#\nDESCRIPTION: The base abstract class for all service discovery implementations in Akka.NET. It defines the core lookup functionality that all discovery mechanisms must implement.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.DotNet.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ServiceDiscovery\n{\n    protected ServiceDiscovery() { }\n    public abstract System.Threading.Tasks.Task<Akka.Discovery.ServiceDiscovery.Resolved> Lookup(Akka.Discovery.Lookup lookup, System.TimeSpan resolveTimeout);\n    public System.Threading.Tasks.Task<Akka.Discovery.ServiceDiscovery.Resolved> Lookup(string serviceName, System.TimeSpan resolveTimeout) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Actor Routing Implementation in C#\nDESCRIPTION: Implements actor reference and selection routing mechanisms for distributed message handling in Akka.NET. Includes routee management and message distribution logic.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_177\n\nLANGUAGE: C#\nCODE:\n```\npublic class ActorRefRoutee : Akka.Routing.Routee\n{\n    public ActorRefRoutee(Akka.Actor.IActorRef actor) { }\n    public Akka.Actor.IActorRef Actor { get; }\n    public override System.Threading.Tasks.Task<object> Ask(object message, System.Nullable<System.TimeSpan> timeout) { }\n    public override void Send(object message, Akka.Actor.IActorRef sender) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Token Bucket Rate Limiting in C#\nDESCRIPTION: Defines TokenBucket abstract class and TickTimeTokenBucket implementation for rate limiting operations. The token bucket algorithm allows controlled throughput of operations over time with configurable capacity and refill rate.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_257\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class TickTimeTokenBucket : Akka.Util.TokenBucket\n{\n    public TickTimeTokenBucket(long capacity, long period) { }\n    public override long CurrentTime { get; }\n}\n[Akka.Annotations.InternalApiAttribute()]\npublic abstract class TokenBucket\n{\n    protected TokenBucket(long capacity, long ticksBetweenTokens) { }\n    public abstract long CurrentTime { get; }\n    public void Init() { }\n    public long Offer(long cost) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Composite Flows with Materialized Values in Akka.NET Streams\nDESCRIPTION: This example shows how to create a composite Flow from two components where the second Flow's materialized value (Task<OutgoingConnection>) is propagated to the parent using Keep.Right as the combiner function.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/modularitycomposition.md#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n// Materializes to NotUsed                      (orange)  \nvar flow1 = Flow.Create<int>().Select(x => ByteString.FromString(x.ToString()));\n\n// Materializes to Task<OutgoingConnection>     (yellow)  \nvar flow2 = Sys.TcpStream().OutgoingConnection(\"localhost\", 8080);\n\n// Materializes to Task<OutgoingConnection>     (yellow)  \nvar nestedFlow = flow1.ViaMaterialized(flow2, Keep.Right).Named(\"nestedFlow\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Split Brain Resolver Classes in C#\nDESCRIPTION: Defines classes for split brain resolution in Akka.NET clusters. These classes provide settings and strategies for handling network partitions and maintaining cluster integrity.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Core.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class KeepOldestSettings\n{\n    public KeepOldestSettings(bool downIfAlone, string role) { }\n    public bool DownIfAlone { get; }\n    public string Role { get; }\n}\n\npublic sealed class LeaseMajoritySettings\n{\n    public LeaseMajoritySettings(string leaseImplementation, System.TimeSpan acquireLeaseDelayForMinority, System.TimeSpan releaseAfter, string role, string leaseName) { }\n    public System.TimeSpan AcquireLeaseDelayForMinority { get; }\n    public string LeaseImplementation { get; }\n    public string LeaseName { get; }\n    public System.TimeSpan ReleaseAfter { get; }\n    public string Role { get; }\n    public string SafeLeaseName(string systemName) { }\n}\n\npublic class SplitBrainResolverProvider : Akka.Cluster.IDowningProvider\n{\n    public SplitBrainResolverProvider(Akka.Actor.ActorSystem system, Akka.Cluster.Cluster cluster) { }\n    public System.TimeSpan DownRemovalMargin { get; }\n    public Akka.Actor.Props DowningActorProps { get; }\n}\n\npublic sealed class SplitBrainResolverSettings\n{\n    public static readonly System.Collections.Immutable.ImmutableHashSet<string> AllStrategyNames;\n    public const string DownAllName = \"down-all\";\n    public const string KeepMajorityName = \"keep-majority\";\n    public const string KeepOldestName = \"keep-oldest\";\n    public const string LeaseMajorityName = \"lease-majority\";\n    public const string StaticQuorumName = \"static-quorum\";\n    public SplitBrainResolverSettings(Akka.Configuration.Config config) { }\n    public System.TimeSpan DownAllWhenUnstable { get; }\n    public System.TimeSpan DowningStableAfter { get; }\n    public string DowningStrategy { get; }\n    public string KeepMajorityRole { get; }\n    public Akka.Cluster.SBR.KeepOldestSettings KeepOldestSettings { get; }\n    public Akka.Cluster.SBR.LeaseMajoritySettings LeaseMajoritySettings { get; }\n    public Akka.Cluster.SBR.StaticQuorumSettings StaticQuorumSettings { get; }\n}\n\npublic sealed class StaticQuorumSettings\n{\n    public StaticQuorumSettings(int size, string role) { }\n    public string Role { get; }\n    public int Size { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Message Serialization Codec with BidiFlow\nDESCRIPTION: Implements a bidirectional message codec that handles serialization and deserialization of Ping/Pong messages using BidiFlow. Demonstrates both verbose and concise methods of creating bidirectional flows.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithgraphs.md#2025-04-16_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IMessage { }\n\npublic struct Ping : IMessage\n{\n    public Ping(int id)\n    {\n        Id = id;\n    }\n\n    public int Id { get; }\n}\n\npublic struct Pong : IMessage\n{\n    public Pong(int id)\n    {\n        Id = id;\n    }\n\n    public int Id { get; }\n}\n\npublic static ByteString ToBytes(IMessage message)\n{\n    // implementation details elided ...\n}\n\npublic static IMessage FromBytes(ByteString bytes)\n{\n    // implementation details elided ...\n}\n\nvar codecVerbose =\n  BidiFlow.FromGraph(GraphDsl.Create(b =>\n  {\n      // construct and add the top flow, going outbound\n      var outbound = b.Add(Flow.Create<IMessage>().Select(ToBytes));\n      // construct and add the bottom flow, going inbound\n      var inbound = b.Add(Flow.Create<ByteString>().Select(FromBytes));\n      // fuse them together into a BidiShape\n      return BidiShape.FromFlows(outbound, inbound);\n  }));\n\n// this is the same as the above\nvar codec = BidiFlow.FromFunction<IMessage, ByteString, ByteString, IMessage>(ToBytes, FromBytes);\n```\n\n----------------------------------------\n\nTITLE: Configuring Ninject Container and Dependency Resolver for Akka.NET\nDESCRIPTION: This snippet demonstrates how to create a Ninject container, bind types, and set up a dependency resolver for use with Akka.NET. It shows the process of creating an ActorSystem and integrating it with Ninject.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/dependency-injection.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n// Create and build your container\nvar container = new Ninject.StandardKernel();\ncontainer.Bind<TypedWorker>().To(typeof(TypedWorker));\ncontainer.Bind<IWorkerService>().To(typeof(WorkerService));\n\n// Create the ActorSystem and Dependency Resolver\nvar system = ActorSystem.Create(\"MySystem\");\nvar propsResolver = new NinjectDependencyResolver(container,system);\n```\n\n----------------------------------------\n\nTITLE: Synchronous Actor Behavior Testing with TestActorRef in C#\nDESCRIPTION: Shows how to use TestActorRef for synchronous testing of actor behavior, including sending messages and asserting responses.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/testing-actor-systems.md#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nvar props = Props.Create<MyActor>();\nvar myTestActor = new TestActorRef<MyActor>(Sys, props, null, \"testB\");\nTask<int> future = myTestActor.Ask<int>(\"say42\", TimeSpan.FromMilliseconds(3000));\nAssert.True(future.IsCompleted);\nAssert.Equal(42, await future);\n```\n\n----------------------------------------\n\nTITLE: Querying All Events in C#\nDESCRIPTION: Example of querying all events using Akka Streams with offset-based pagination and stream manipulation using Take and RunAggregate.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistence-query.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// assuming journal is able to work with numeric offsets we can:\nSource<EventEnvelope, NotUsed> allEvents = readJournal.AllEvents(offset: 0L);\n\n// replay the first 10 things stored:\nTask<ImmutableHashSet<object>> first10Things = allEvents\n    .Select(c => c.Event)\n    .Take(10) // cancels the query stream after pulling 10 elements\n    .RunAggregate(\n        ImmutableHashSet<object>.Empty,\n        (acc, c) => acc.Add(c),\n        mat);\n\n// start another query, from the known offset\nvar next10Things = readJournal.AllEvents(offset: 10);\n```\n\n----------------------------------------\n\nTITLE: Implementing Device List Query in Device Group Actor (C#)\nDESCRIPTION: This snippet shows the implementation of a device list query functionality in the Device Group actor. It allows querying the currently active device IDs managed by the group.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-3.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class RequestDeviceList\n{\n    public RequestDeviceList(long requestId)\n    {\n        RequestId = requestId;\n    }\n\n    public long RequestId { get; }\n}\n\npublic sealed class ReplyDeviceList\n{\n    public ReplyDeviceList(long requestId, ISet<string> ids)\n    {\n        RequestId = requestId;\n        Ids = ids;\n    }\n\n    public long RequestId { get; }\n    public ISet<string> Ids { get; }\n}\n\nprotected override void OnReceive(object message)\n{\n    switch (message)\n    {\n        case RequestDeviceList request:\n            Sender.Tell(new ReplyDeviceList(request.RequestId, new HashSet<string>(_deviceIdToActor.Keys)));\n            break;\n        // ... other cases ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ActorTaskScheduler in C#\nDESCRIPTION: Defines a custom TaskScheduler for Akka.NET actors. It provides methods for queueing and executing tasks, and includes properties for accessing the current message and maximum concurrency level.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_94\n\nLANGUAGE: C#\nCODE:\n```\npublic class ActorTaskScheduler : System.Threading.Tasks.TaskScheduler\n{\n    public object CurrentMessage { get; }\n    public override int MaximumConcurrencyLevel { get; }\n    protected override System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> GetScheduledTasks() { }\n    protected virtual void OnAfterTaskCompleted() { }\n    protected virtual void OnBeforeTaskStarted() { }\n    protected override void QueueTask(System.Threading.Tasks.Task task) { }\n    public static void RunTask(System.Action action) { }\n    public static void RunTask(System.Func<System.Threading.Tasks.Task> asyncAction) { }\n    protected override bool TryExecuteTaskInline(System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Actor Path Formats in Akka.NET\nDESCRIPTION: This snippet shows examples of actor path formats in Akka.NET, including a purely local path and a remote path using TCP transport.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/concepts/addressing.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n\"akka://my-sys/user/service-a/worker1\"                   // purely local\n\"akka.tcp://my-sys@host.example.com:5678/user/service-b\" // remote\n```\n\n----------------------------------------\n\nTITLE: Implementing a Rate-Decoupled Buffer Stage in C#\nDESCRIPTION: This code demonstrates a custom TwoBuffer graph stage that implements a buffer with a capacity of two elements. It shows how to handle push and pull operations, manage internal state, and deal with upstream finishing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/custom-stream-processing.md#2025-04-16_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\nclass TwoBuffer<T> : GraphStage<FlowShape<T, T>>\n{\n    private sealed class Logic : GraphStageLogic\n    {\n        private readonly TwoBuffer<T> _buffer;\n        private readonly Queue<T> _queue;\n        private bool _downstreamWaiting = false;\n\n        public Logic(TwoBuffer<T> buffer) : base(buffer.Shape)\n        {\n            _buffer = buffer;\n            _queue = new Queue<T>();\n\n            SetHandler(buffer.In, OnPush, OnUpstreamFinish);\n            SetHandler(buffer.Out, OnPull);\n        }\n\n        private bool BufferFull => _queue.Count == 2;\n\n        private void OnPush()\n        {\n            var element = Grab(_buffer.In);\n            _queue.Enqueue(element);\n            if (_downstreamWaiting)\n            {\n                _downstreamWaiting = false;\n                var bufferedElement = _queue.Dequeue();\n                Push(_buffer.Out, bufferedElement);\n            }\n            if(!BufferFull)\n                Pull(_buffer.In);\n        }\n\n        private void OnUpstreamFinish()\n        {\n            if (_queue.Count != 0)\n            {\n                // emit the rest if possible\n                EmitMultiple(_buffer.Out, _queue);\n            }\n\n            CompleteStage();\n        }\n\n        private void OnPull()\n        {\n            if (_queue.Count == 0)\n                _downstreamWaiting = true;\n            else\n            {\n                var element = _queue.Dequeue();\n                Push(_buffer.Out, element);\n            }\n\n            if(!BufferFull && !HasBeenPulled(_buffer.In))\n                Pull(_buffer.In);\n        }\n    }\n\n    public TwoBuffer()\n    {\n        Shape = new FlowShape<T, T>(In, Out);\n    }\n\n    public Inlet<T> In { get; } = new Inlet<T>(\"TwoBuffer.in\");\n\n    public Outlet<T> Out { get; } = new Outlet<T>(\"TwoBuffer.out\");\n\n    public override FlowShape<T, T> Shape { get; }\n\n    protected override GraphStageLogic CreateLogic(Attributes inheritedAttributes) => new Logic(this);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Actor System Settings in Akka.NET\nDESCRIPTION: Settings class that encapsulates configuration parameters for an Akka.NET ActorSystem. Includes numerous configuration options for logging, debugging, scheduling, and serialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_47\n\nLANGUAGE: C#\nCODE:\n```\npublic class Settings\n    {\n        public Settings(Akka.Actor.ActorSystem system, Akka.Configuration.Config config) { }\n        public Settings(Akka.Actor.ActorSystem system, Akka.Configuration.Config config, Akka.Actor.Setup.ActorSystemSetup setup) { }\n        public bool AddLoggingReceive { get; }\n        public System.TimeSpan AskTimeout { get; }\n        public Akka.Configuration.Config Config { get; }\n        public string ConfigVersion { get; }\n        public bool CoordinatedShutdownRunByActorSystemTerminate { get; }\n        public bool CoordinatedShutdownTerminateActorSystem { get; }\n        public System.TimeSpan CreationTimeout { get; }\n        public bool DebugAutoReceive { get; }\n        public bool DebugEventStream { get; }\n        public bool DebugLifecycle { get; }\n        public bool DebugRouterMisconfiguration { get; }\n        public bool DebugTimerScheduler { get; }\n        public bool DebugUnhandledMessage { get; }\n        public int DefaultVirtualNodesFactor { get; }\n        public bool EmitActorTelemetry { get; }\n        public bool FsmDebugEvent { get; }\n        public bool HasCluster { get; }\n        public string Home { get; }\n        public bool LogConfigOnStart { get; }\n        public int LogDeadLetters { get; }\n        public bool LogDeadLettersDuringShutdown { get; }\n        public System.TimeSpan LogDeadLettersSuspendDuration { get; }\n        public Akka.Event.LogFilterEvaluator LogFilter { get; }\n        public Akka.Event.ILogMessageFormatter LogFormatter { get; }\n        public string LogLevel { get; }\n        public bool LogSerializerOverrideOnStart { get; }\n        public bool LoggerAsyncStart { get; }\n        public System.TimeSpan LoggerStartTimeout { get; }\n        public System.Collections.Generic.IList<string> Loggers { get; }\n        public string LoggersDispatcher { get; }\n        public string ProviderClass { get; }\n        public Akka.Actor.ProviderSelection ProviderSelectionType { get; }\n        public string SchedulerClass { get; }\n        public System.TimeSpan SchedulerShutdownTimeout { get; }\n        public bool SerializeAllCreators { get; }\n        public bool SerializeAllMessages { get; }\n        public Akka.Actor.Setup.ActorSystemSetup Setup { get; }\n        public string StdoutLogLevel { get; }\n        public Akka.Event.MinimalLogger StdoutLogger { get; }\n        public string SupervisorStrategyClass { get; }\n        public Akka.Actor.ActorSystem System { get; }\n        public System.TimeSpan UnstartedPushTimeout { get; }\n        public void InjectTopLevelFallback(Akka.Configuration.Config config) { }\n        public override string ToString() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Serialization Management in C#\nDESCRIPTION: Defines the Serialization class for managing serialization in Akka.NET. It includes methods for adding serializers, finding serializers for objects, and performing serialization and deserialization operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_225\n\nLANGUAGE: C#\nCODE:\n```\npublic class Serialization\n{\n    public Serialization(Akka.Actor.ExtendedActorSystem system) { }\n    public Akka.Actor.ExtendedActorSystem System { get; }\n    public void AddSerializationMap(System.Type type, Akka.Serialization.Serializer serializer) { }\n    public void AddSerializer(string name, Akka.Serialization.Serializer serializer) { }\n    public object Deserialize(byte[] bytes, int serializerId, System.Type type) { }\n    public object Deserialize(byte[] bytes, int serializerId, string manifest) { }\n    public Akka.Actor.IActorRef DeserializeActorRef(string path) { }\n    public Akka.Serialization.Serializer FindSerializerFor(object obj, string defaultSerializerName = null) { }\n    public Akka.Serialization.Serializer FindSerializerForType(System.Type objectType, string defaultSerializerName = null) { }\n    public static Akka.Serialization.Information GetCurrentTransportInformation() { }\n    public static string ManifestFor(Akka.Serialization.Serializer s, object msg) { }\n    public byte[] Serialize(object o) { }\n    public static string SerializedActorPath(Akka.Actor.IActorRef actorRef) { }\n    public static T WithTransport<T>(Akka.Actor.ExtendedActorSystem system, System.Func<T> action) { }\n    public static T WithTransport<TState, T>(Akka.Actor.ExtendedActorSystem system, TState state, System.Func<TState, T> action) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LogLevel Enum in C#\nDESCRIPTION: Enumeration of log levels in increasing order of severity, from DebugLevel to ErrorLevel. This provides a standardized way to indicate the importance of log messages across the Akka.NET system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_131\n\nLANGUAGE: C#\nCODE:\n```\npublic enum LogLevel\n{\n    DebugLevel = 0,\n    InfoLevel = 1,\n    WarningLevel = 2,\n    ErrorLevel = 3,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Cluster Class for Distributed Actor Management\nDESCRIPTION: Provides core cluster management methods and properties for distributed actor systems, including joining, leaving, and tracking cluster state\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Cluster : Akka.Actor.IExtension\n{\n    public void Join(Akka.Actor.Address address) { }\n    public void Leave(Akka.Actor.Address address) { }\n    public Akka.Cluster.ClusterEvent.CurrentClusterState State { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Dropping Elements with Conflate in Akka.NET Streams\nDESCRIPTION: This snippet demonstrates how to drop elements using `Conflate` in Akka.NET Streams. It conflates multiple upstream elements into one, effectively dropping elements if the upstream is faster than the downstream.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/cookbook.md#2025-04-16_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nvar droppyStream = Flow.Create<Message>().Conflate((lastMessage, newMessage) => newMessage);\n```\n\n----------------------------------------\n\nTITLE: Handling Association Events in Akka.Remote C#\nDESCRIPTION: This code snippet introduces various AssociationEvent subclasses used to represent events in the Akka remote association lifecycle. Each event type, such as AssociatedEvent and DisassociatedEvent, encapsulates details about remote interactions, focusing on connection lifecycle states including causes and log levels. Dependencies include Akka.Actor.Address for address representations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class AssociatedEvent : Akka.Remote.AssociationEvent\n{\n    public AssociatedEvent(Akka.Actor.Address localAddress, Akka.Actor.Address remoteAddress, bool inbound) { }\n    public override bool IsInbound { get; set; }\n    public override Akka.Actor.Address LocalAddress { get; set; }\n    public override Akka.Actor.Address RemoteAddress { get; set; }\n    public override Akka.Event.LogLevel LogLevel() { }\n}\npublic sealed class DisassociatedEvent : Akka.Remote.AssociationEvent\n{\n    public DisassociatedEvent(Akka.Actor.Address localAddress, Akka.Actor.Address remoteAddress, bool inbound) { }\n    public override bool IsInbound { get; set; }\n    public override Akka.Actor.Address LocalAddress { get; set; }\n    public override Akka.Actor.Address RemoteAddress { get; set; }\n    public override Akka.Event.LogLevel LogLevel() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Initial State in Akka.NET FSM\nDESCRIPTION: This code demonstrates how to set the initial state of the FSM actor using the StartWith method.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/finite-state-machine.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/core/Akka.Docs.Tests/Actors/FiniteStateMachine/ExampleFSMActor.cs?name=StartWith)]\n```\n\n----------------------------------------\n\nTITLE: Implementing SSL Support for DotNetty in Akka.NET\nDESCRIPTION: SSL setup class for the DotNetty transport implementation in Akka.NET. It allows configuring X509 certificates and validation settings for secure remote communication.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DotNettySslSetup : Akka.Actor.Setup.Setup\n{\n    public DotNettySslSetup(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate, bool suppressValidation) { }\n    public System.Security.Cryptography.X509Certificates.X509Certificate2 Certificate { get; }\n    public bool SuppressValidation { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing External Shard Allocation in C#\nDESCRIPTION: Defines the external shard allocation system for Akka.NET clusters including client timeout handling, allocation strategy, and location management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Core.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ExternalShardAllocation : Akka.Actor.IExtension\n{\n    public ExternalShardAllocation(Akka.Actor.ExtendedActorSystem system) { }\n    public Akka.Cluster.Sharding.External.IExternalShardAllocationClient ClientFor(string typeName) { }\n    public static Akka.Cluster.Sharding.External.ExternalShardAllocation Get(Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Exception Handling in Actors with TestActorRef in C#\nDESCRIPTION: Demonstrates how to test exception handling in actors using the Receive method of TestActorRef.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/testing-actor-systems.md#2025-04-16_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nvar props = Props.Create<MyActor>();\nvar myTestActor = new TestActorRef<MyActor>(Sys, props, null, \"testB\");\ntry\n{\n    myTestActor.Receive(new Exception(\"expected\"));\n}\ncatch (Exception e)\n{\n    Assert.Equal(\"expected\", e.Message);\n}\n```\n\n----------------------------------------\n\nTITLE: Basic TestKit Usage in C#\nDESCRIPTION: Demonstrates the basic setup of a test using TestKit in Akka.NET. It shows how to create a test actor and use ExpectMsg assertions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/testing-actor-systems.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroSample](../../../src/core/Akka.Docs.Tests/Testkit/TestKitSampleTest.cs?name=IntroSample_0)]\n```\n\n----------------------------------------\n\nTITLE: Implementing Dispatcher Components in C#\nDESCRIPTION: Core dispatcher implementations for Akka.NET including CurrentSynchronizationContextDispatcher, DefaultDispatcherPrerequisites, Dispatcher, and DispatcherConfigurator. These classes control how messages are scheduled and executed in the actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_85\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class CurrentSynchronizationContextDispatcher : Akka.Dispatch.Dispatcher\n{\n    public CurrentSynchronizationContextDispatcher(Akka.Dispatch.MessageDispatcherConfigurator configurator, string id, int throughput, System.Nullable<long> throughputDeadlineTime, Akka.Dispatch.ExecutorServiceFactory executorServiceFactory, System.TimeSpan shutdownTimeout) { }\n}\n\npublic sealed class DefaultDispatcherPrerequisites : Akka.Dispatch.IDispatcherPrerequisites\n{\n    public DefaultDispatcherPrerequisites(Akka.Event.EventStream eventStream, Akka.Actor.IScheduler scheduler, Akka.Actor.Settings settings, Akka.Dispatch.Mailboxes mailboxes) { }\n    public Akka.Event.EventStream EventStream { get; }\n    public Akka.Dispatch.Mailboxes Mailboxes { get; }\n    public Akka.Actor.IScheduler Scheduler { get; }\n    public Akka.Actor.Settings Settings { get; }\n}\n\npublic class Dispatcher : Akka.Dispatch.MessageDispatcher\n{\n    public Dispatcher(Akka.Dispatch.MessageDispatcherConfigurator configurator, string id, int throughput, System.Nullable<long> throughputDeadlineTime, Akka.Dispatch.ExecutorServiceFactory executorServiceFactory, System.TimeSpan shutdownTimeout) { }\n    protected override void ExecuteTask(Akka.Dispatch.IRunnable run) { }\n    [Akka.Annotations.InternalApiAttribute()]\n    protected override void Shutdown() { }\n}\n\npublic sealed class DispatcherConfigurator : Akka.Dispatch.MessageDispatcherConfigurator\n{\n    public DispatcherConfigurator(Akka.Configuration.Config config, Akka.Dispatch.IDispatcherPrerequisites prerequisites) { }\n    public override Akka.Dispatch.MessageDispatcher Dispatcher() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ORMultiValueDictionary in C# for Akka.NET\nDESCRIPTION: This class implements an Observed-Remove Multi-Value Dictionary, a distributed data structure for Akka.NET. It provides methods for adding, removing, and merging key-value pairs across distributed nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\npublic class ORMultiValueDictionary<TKey, TValue> : IReplicatedData, IDeltaReplicatedData, IRemovedNodePruning\n{\n    public bool DeltaValues { get; }\n    public System.Collections.Immutable.IImmutableDictionary<TKey, System.Collections.Immutable.IImmutableSet<TValue>> Entries { get; }\n    public bool IsEmpty { get; }\n    public System.Collections.Immutable.IImmutableSet<TValue> this[TKey key] { get; }\n    public System.Type KeyType { get; }\n    public System.Collections.Generic.IEnumerable<TKey> Keys { get; }\n    public System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.UniqueAddress> ModifiedByNodes { get; }\n    public System.Type ValueType { get; }\n    public System.Collections.Generic.IEnumerable<TValue> Values { get; }\n    \n    // Method implementations...\n}\n```\n\n----------------------------------------\n\nTITLE: Using ActorSubscriber as a Sink in Akka.NET Streams Flow\nDESCRIPTION: This code snippet demonstrates how to use the WorkerPool ActorSubscriber as a Sink in an Akka.NET Streams Flow. It creates a Source from a range of integers, transforms them into Message objects, and then runs the stream with the WorkerPool as the Sink.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_23\n\nLANGUAGE: csharp\nCODE:\n```\nvar n = 118;\nSource.From(Enumerable.Range(1, n))\n    .Select(x => new Message(x, replyTo))\n    .RunWith(Sink.ActorSubscriber<Message>(WorkerPool.Props), materializer);\n```\n\n----------------------------------------\n\nTITLE: Customizing Actor Initialization and Restart Behavior in Akka.NET\nDESCRIPTION: Demonstrates how to override PreStart, PostRestart, and PreRestart methods to control initialization behavior across actor restarts, preventing child actors from being recreated during parent restarts.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_34\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override void PreStart()\n{\n    // Initialize children here\n}\n\n// Overriding postRestart to disable the call to preStart() after restarts\nprotected override void PostRestart(Exception reason)\n{ \n}\n\n// The default implementation of PreRestart() stops all the children\n// of the actor. To opt-out from stopping the children, we\n// have to override PreRestart()\nprotected override void PreRestart(Exception reason, object message)\n{\n    // Keep the call to PostStop(), but no stopping of children\n    PostStop();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Actor with Factory Method Pattern\nDESCRIPTION: Shows how to implement an actor with constructor parameters using the recommended factory method pattern for Props creation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DemoActor : UntypedActor\n{\n    private readonly int _magicNumber;\n\n    public DemoActor(int magicNumber)\n    {\n        _magicNumber = magicNumber;\n    }\n\n    protected override void OnReceive(object message)\n    {\n        if (message is int x)\n        {\n            Sender.Tell(x + _magicNumber);\n        }\n    }\n\n    public static Props Props(int magicNumber)\n    {\n        return Akka.Actor.Props.Create(() => new DemoActor(magicNumber));\n    }\n}\n\nsystem.ActorOf(DemoActor.Props(42), \"demo\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Either<TA, TB> Abstract Class in C#\nDESCRIPTION: An abstract base class for Either type, a functional programming construct that can hold a value of one of two possible types. Provides mapping and folding operations for functional composition.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_237\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Either<TA, TB>\n{\n    protected Either(TA left, TB right) { }\n    public abstract bool IsLeft { get; }\n    public abstract bool IsRight { get; }\n    protected TA Left { get; }\n    protected TB Right { get; }\n    public object Value { get; }\n    public TRes Fold<TRes>(System.Func<TA, TRes> left, System.Func<TB, TRes> right) { }\n    public Akka.Util.Either<TRes1, TRes2> Map<TRes1, TRes2>(System.Func<TA, TRes1> map1, System.Func<TB, TRes2> map2) { }\n    public Akka.Util.Either<TRes, TB> MapLeft<TRes>(System.Func<TA, TRes> map) { }\n    public Akka.Util.Either<TA, TRes> MapRight<TRes>(System.Func<TB, TRes> map) { }\n    public Akka.Util.Left<TA, TB> ToLeft() { }\n    public Akka.Util.Right<TA, TB> ToRight() { }\n    public static Akka.Util.Either<TA, TB> op_Implicit(Akka.Util.Left<TA> left) { }\n    public static Akka.Util.Either<TA, TB> op_Implicit(Akka.Util.Right<TB> right) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ActorSystemSetup Class in C#\nDESCRIPTION: Sealed class that handles setup configuration for Akka.NET actor systems. Provides methods for combining and retrieving setup configurations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_65\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ActorSystemSetup\n{\n    public static readonly Akka.Actor.Setup.ActorSystemSetup Empty;\n    public Akka.Actor.Setup.ActorSystemSetup And<T>(T setup)\n        where T : Akka.Actor.Setup.Setup { }\n    public static Akka.Actor.Setup.ActorSystemSetup Create(params Akka.Actor.Setup.Setup[] setup) { }\n    public Akka.Util.Option<T> Get<T>()\n        where T : Akka.Actor.Setup.Setup { }\n    public override string ToString() { }\n    public Akka.Actor.Setup.ActorSystemSetup WithSetup<T>(T setup)\n        where T : Akka.Actor.Setup.Setup { }\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Custom Configuration to Akka.TestKit in C#\nDESCRIPTION: Example of how to pass custom configuration to Akka.TestKit via the base class constructor in a test class.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/testing-actor-systems.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/contrib/cluster/Akka.Cluster.Tools.Tests/Singleton/ClusterSingletonConfigSpec.cs?name=ClusterSingletonConfigSpec)]\n```\n\n----------------------------------------\n\nTITLE: Implementing Consistency Models in C#\nDESCRIPTION: Implementation of different consistency models for distributed reads including ReadAll, ReadFrom, ReadLocal, ReadMajority, and ReadMajorityPlus.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_45\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ReadAll : Akka.DistributedData.IReadConsistency, System.IEquatable<Akka.DistributedData.ReadAll>\n{\n    public ReadAll(System.TimeSpan timeout) { }\n    public System.TimeSpan Timeout { get; }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.DistributedData.ReadAll other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n\npublic sealed class ReadFrom : Akka.DistributedData.IReadConsistency, System.IEquatable<Akka.DistributedData.ReadFrom>\n{\n    public ReadFrom(int n, System.TimeSpan timeout) { }\n    public int N { get; }\n    public System.TimeSpan Timeout { get; }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.DistributedData.ReadFrom other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect GracefulStop Usage in ReceiveActor\nDESCRIPTION: This example demonstrates the incorrect way of using GracefulStop() inside a ReceiveAsync handler, which will cause a deadlock. The actor awaits its own graceful stop, preventing the PoisonPill message from being processed.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK1002.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Actor;\nusing System.Threading.Tasks;\nusing System;\n\npublic sealed class MyActor : ReceiveActor\n{\n   public MyActor()\n   {\n      ReceiveAsync<string>(async str => {\n         await Context.Self.GracefulStop(); // THIS WILL DEADLOCK\n      }):\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Time Management in Akka.NET TestKit\nDESCRIPTION: Methods for managing time in test scenarios, including calculating remaining durations and dilating time. These utilities help in controlling the perceived passage of time in tests.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\nprotected System.TimeSpan RemainingOr(System.TimeSpan duration) { }\npublic System.TimeSpan RemainingOrDilated(System.Nullable<System.TimeSpan> duration) { }\n```\n\n----------------------------------------\n\nTITLE: Forwarding Messages in C#\nDESCRIPTION: Shows how to forward messages between actors while maintaining the original sender reference.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\ntarget.Forward(result, Context);\n```\n\n----------------------------------------\n\nTITLE: Implementing PostStop Hook in C#\nDESCRIPTION: Shows how to implement the PostStop hook for cleanup after actor termination.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override void PostStop()\n{\n    // clean up resources here ...\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Akka.NET F# Support via PowerShell\nDESCRIPTION: This command installs the Akka.FSharp NuGet package using the Package Manager Console in Visual Studio, providing F# programming language support for Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/README.md#2025-04-16_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\nPM> Install-Package Akka.FSharp\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterRouterGroup in C#\nDESCRIPTION: Defines a sealed class ClusterRouterGroup that extends Akka.Routing.Group. It includes methods for creating routers, managing paths, and handling messages in a clustered environment.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterRouterGroup : Akka.Routing.Group\n{\n    public ClusterRouterGroup(Akka.Routing.Group local, Akka.Cluster.Routing.ClusterRouterGroupSettings settings) { }\n    public Akka.Routing.Group Local { get; }\n    public override string RouterDispatcher { get; }\n    public Akka.Cluster.Routing.ClusterRouterGroupSettings Settings { get; }\n    public override bool StopRouterWhenAllRouteesRemoved { get; }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override Akka.Actor.ActorBase CreateRouterActor() { }\n    public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }\n    public override bool IsManagementMessage(object message) { }\n    public override Akka.Actor.Props RoutingLogicController(Akka.Routing.RoutingLogic routingLogic) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Hyperion as Default Serializer in HOCON\nDESCRIPTION: This HOCON configuration snippet shows how to set up Hyperion as the default serializer for Akka.NET. It binds the Hyperion serializer to all objects in the system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/serialization/serialization.md#2025-04-16_snippet_7\n\nLANGUAGE: hocon\nCODE:\n```\nakka {\n  actor {\n    serializers {\n      hyperion = \"Akka.Serialization.HyperionSerializer, Akka.Serialization.Hyperion\"\n    }\n    serialization-bindings {\n      \"System.Object\" = hyperion\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DistributedPubSubMediator in C#\nDESCRIPTION: Defines the core actor for distributed publish-subscribe operations. It handles message routing, topic management, and cluster communication for the pub-sub system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic class DistributedPubSubMediator : Akka.Actor.ReceiveActor\n{\n    public DistributedPubSubMediator(Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings settings) { }\n    public Akka.Event.ILoggingAdapter Log { get; }\n    public System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, long> OwnVersions { get; }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n    public static Akka.Actor.Props Props(Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings settings) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PipeToSupport for Task Piping in C#\nDESCRIPTION: Defines the PipeToSupport static class, which provides extension methods for piping Task and ValueTask results to actors in Akka.NET. It supports both generic and non-generic tasks with various configuration options.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic class static PipeToSupport\n{\n    public static System.Threading.Tasks.Task PipeTo<T>(this System.Threading.Tasks.Task<T> taskToPipe, Akka.Actor.ICanTell recipient, Akka.Actor.IActorRef sender = null, System.Func<T, object> success = null, System.Func<System.Exception, object> failure = null) { }\n    public static System.Threading.Tasks.Task PipeTo<T>(this System.Threading.Tasks.ValueTask<T> taskToPipe, Akka.Actor.ICanTell recipient, Akka.Actor.IActorRef sender = null, System.Func<T, object> success = null, System.Func<System.Exception, object> failure = null) { }\n    public static System.Threading.Tasks.Task PipeTo<T>(this System.Threading.Tasks.Task<T> taskToPipe, Akka.Actor.ICanTell recipient, bool useConfigureAwait, Akka.Actor.IActorRef sender = null, System.Func<T, object> success = null, System.Func<System.Exception, object> failure = null) { }\n    public static System.Threading.Tasks.Task PipeTo<T>(this System.Threading.Tasks.ValueTask<T> taskToPipe, Akka.Actor.ICanTell recipient, bool useConfigureAwait, Akka.Actor.IActorRef sender = null, System.Func<T, object> success = null, System.Func<System.Exception, object> failure = null) { }\n    public static System.Threading.Tasks.Task PipeTo(this System.Threading.Tasks.Task taskToPipe, Akka.Actor.ICanTell recipient, Akka.Actor.IActorRef sender = null, System.Func<object> success = null, System.Func<System.Exception, object> failure = null) { }\n    public static System.Threading.Tasks.Task PipeTo(this System.Threading.Tasks.ValueTask taskToPipe, Akka.Actor.ICanTell recipient, Akka.Actor.IActorRef sender = null, System.Func<object> success = null, System.Func<System.Exception, object> failure = null) { }\n    public static System.Threading.Tasks.Task PipeTo(this System.Threading.Tasks.Task taskToPipe, Akka.Actor.ICanTell recipient, bool useConfigureAwait, Akka.Actor.IActorRef sender = null, System.Func<object> success = null, System.Func<System.Exception, object> failure = null) { }\n    public static System.Threading.Tasks.Task PipeTo(this System.Threading.Tasks.ValueTask taskToPipe, Akka.Actor.ICanTell recipient, bool useConfigureAwait, Akka.Actor.IActorRef sender = null, System.Func<object> success = null, System.Func<System.Exception, object> failure = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Actor Interface Methods in C#\nDESCRIPTION: Core interface methods for managing actor lifecycle and communication including getting children, sending messages, and managing actor state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\nSystem.Collections.Generic.IEnumerable<Akka.Actor.IInternalActorRef> GetChildren();\nAkka.Actor.IInternalActorRef GetSingleChild(string name);\nvoid Restart(System.Exception cause);\nvoid Resume(System.Exception causedByFailure);\nvoid SendMessage(Akka.Actor.IActorRef sender, object message);\nvoid SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message);\nvoid Start();\nvoid Stop();\nvoid Suspend();\nbool TryGetChildStatsByName(string name, out Akka.Actor.Internal.IChildStats child);\n```\n\n----------------------------------------\n\nTITLE: Configuring Akka.NET Server for Remote Communication\nDESCRIPTION: This XML configuration sets up an Akka.NET server system for remote communication using the dot-netty.tcp transport. It specifies a fixed port (8081) and localhost as the hostname.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/remoting/index.md#2025-04-16_snippet_3\n\nLANGUAGE: xml\nCODE:\n```\nakka {  \n    actor {\n        provider = remote\n    }\n    remote {\n        dot-netty.tcp {\n            port = 8081 #bound to a specific port\n            hostname = localhost\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Akka.NET DistributedData Settings in HOCON\nDESCRIPTION: HOCON configuration settings for Akka.NET's distributed data plugin. These settings control replicator behavior, pruning intervals, gossip frequency, and other distributed data-related parameters. All settings are defined under the 'akka.cluster.distributed-data' configuration path.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/distributed-data.md#2025-04-16_snippet_5\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster.distributed-data {\n  name = \"ddataReplicator\"\n  role = none\n  gossip-interval = 2s\n  notify-subscribers-interval = 0.5s\n  max-delta-elements = 1000\n  use-dispatcher = \"akka.actor.default-dispatcher\"\n  pruning-interval = 30s\n  max-pruning-dissemination = 60s\n  serializer-cache-time-to-live = 10s\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Immutable Messages in Akka.NET\nDESCRIPTION: Example of creating an immutable message class with read-only properties and collections, which is a requirement for Akka.NET message passing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ImmutableMessage\n{\n    public ImmutableMessage(int sequenceNumber, List<string> values)\n    {\n        SequenceNumber = sequenceNumber;\n        Values = values.AsReadOnly();\n    }\n\n    public int SequenceNumber { get; }\n    public IReadOnlyCollection<string> Values { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: SelectAsync Error Handling with Supervision\nDESCRIPTION: Shows how to apply supervision strategies to asynchronous operations in streams, specifically handling failures in email lookup tasks\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/error-handling.md#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nvar emailAddresses = authors.Via(\n    Flow.Create<Author>()\n        .SelectAsync(4, author => AddressSystem.LookupEmail(author.Handle))\n        .WithAttributes(ActorAttributes.CreateSupervisionStrategy(Deciders.ResumingDecider)));\n```\n\n----------------------------------------\n\nTITLE: Defining Logging utility class with static methods\nDESCRIPTION: Static Logging utility class provides helper methods for log level management, logger creation, and name formatting. It includes methods to retrieve loggers from actor contexts or systems and convert between string and enum representations of log levels.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_145\n\nLANGUAGE: C#\nCODE:\n```\npublic class static Logging\n{\n    public static System.Type ClassFor(this Akka.Event.LogLevel logLevel) { }\n    public static Akka.Event.ILoggingAdapter GetLogger(this Akka.Actor.IActorContext context, Akka.Event.ILogMessageFormatter logMessageFormatter = null) { }\n    public static Akka.Event.ILoggingAdapter GetLogger(Akka.Actor.ActorSystem system, object logSourceObj, Akka.Event.ILogMessageFormatter logMessageFormatter = null) { }\n    public static Akka.Event.ILoggingAdapter GetLogger(Akka.Event.LoggingBus loggingBus, object logSourceObj, Akka.Event.ILogMessageFormatter logMessageFormatter = null) { }\n    public static Akka.Event.LogLevel LogLevelFor(string logLevel) { }\n    public static Akka.Event.LogLevel LogLevelFor<T>()\n        where T : Akka.Event.LogEvent { }\n    public static string SimpleName(object o) { }\n    public static string SimpleName(System.Type t) { }\n    public static string StringFor(this Akka.Event.LogLevel logLevel) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Logging in a Custom GraphStage Source (C#)\nDESCRIPTION: This snippet demonstrates how to implement logging within a custom GraphStage source that generates random letters. It uses the Log property provided by GraphStageLogic to log debug information.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/custom-stream-processing.md#2025-04-16_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nprivate sealed class RandomLettersSource : GraphStage<SourceShape<string>>\n{\n    #region internal classes\n\n    private sealed class Logic : GraphStageLogic\n    {\n        public Logic(RandomLettersSource stage) : base(stage.Shape)\n        {\n            SetHandler(stage.Out, onPull: () =>\n            {\n                var c = NextChar(); // ASCII lower case letters\n\n                Log.Debug($\"Randomly generated: {c}\");    \n\n                Push(stage.Out, c.ToString());\n            });\n        }\n\n        private static char NextChar() => (char) ThreadLocalRandom.Current.Next('a', 'z'1);\n    }\n\n    #endregion\n\n    public RandomLettersSource()\n    {\n        Shape = new SourceShape<string>(Out);\n    }\n\n    private Outlet<string> Out { get; } = new Outlet<string>(\"RandomLettersSource.out\");\n\n    public override SourceShape<string> Shape { get; }\n\n    protected override GraphStageLogic CreateLogic(Attributes inheritedAttributes) => new Logic(this);\n}\n\n\n[Fact]\npublic void A_GraphStageLogic_must_support_logging_in_custom_graphstage()\n{\n    const int n = 10;\n    EventFilter.Debug(start: \"Randomly generated\").Expect(n, () =>\n    {\n        Source.FromGraph(new RandomLettersSource())\n            .Take(n)\n            .RunWith(Sink.Ignore<string>(), Materializer)\n            .Wait(TimeSpan.FromSeconds(3));\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Static ORDictionary Factory Methods - C#\nDESCRIPTION: Static factory methods for creating instances of ORDictionary (Observed-Remove Dictionary), a convergent replicated data type. These methods provide convenient ways to initialize dictionaries with key-value pairs for distributed data operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic class static ORDictionary\n{\n    public static Akka.DistributedData.ORDictionary<TKey, TValue> Create<TKey, TValue>(Akka.Cluster.UniqueAddress node, TKey key, TValue value)\n        where TValue : Akka.DistributedData.IReplicatedData<TValue> { }\n    public static Akka.DistributedData.ORDictionary<TKey, TValue> Create<TKey, TValue>(params System.ValueTuple<, , >[] elements)\n        where TValue : Akka.DistributedData.IReplicatedData<TValue> { }\n    public static Akka.DistributedData.ORDictionary<TKey, TValue> Create<TKey, TValue>(System.Collections.Generic.IEnumerable<System.ValueTuple<Akka.Cluster.UniqueAddress, TKey, TValue>> elements)\n        where TValue : Akka.DistributedData.IReplicatedData<TValue> { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UnboundedMailbox Class in C#\nDESCRIPTION: Sealed class implementing a standard unbounded FIFO mailbox type. Creates message queues with unlimited capacity for actor message processing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_103\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class UnboundedMailbox : Akka.Dispatch.MailboxType, Akka.Dispatch.IProducesMessageQueue<Akka.Dispatch.MessageQueues.UnboundedMessageQueue>\n{\n    public UnboundedMailbox() { }\n    public UnboundedMailbox(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }\n    public override Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Router Class in Akka.NET\nDESCRIPTION: Defines the Router class that manages message routing based on routing logic and a collection of routees. Includes methods for adding, removing routees, and routing messages to appropriate destinations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_209\n\nLANGUAGE: C#\nCODE:\n```\npublic class Router\n{\n    [Akka.Annotations.InternalApiAttribute()]\n    public Router(Akka.Routing.RoutingLogic logic, Akka.Actor.IActorRef routee, params Akka.Actor.IActorRef[] routees) { }\n    public Router(Akka.Routing.RoutingLogic logic, params Akka.Routing.Routee[] routees) { }\n    public System.Collections.Generic.IEnumerable<Akka.Routing.Routee> Routees { get; }\n    public Akka.Routing.RoutingLogic RoutingLogic { get; }\n    public virtual Akka.Routing.Router AddRoutee(Akka.Routing.Routee routee) { }\n    public Akka.Routing.Router AddRoutee(Akka.Actor.IActorRef routee) { }\n    public Akka.Routing.Router AddRoutee(Akka.Actor.ActorSelection routee) { }\n    public virtual Akka.Routing.Router RemoveRoutee(Akka.Routing.Routee routee) { }\n    public Akka.Routing.Router RemoveRoutee(Akka.Actor.IActorRef routee) { }\n    public Akka.Routing.Router RemoveRoutee(Akka.Actor.ActorSelection routee) { }\n    public virtual void Route(object message, Akka.Actor.IActorRef sender) { }\n    protected virtual void Send(Akka.Routing.Routee routee, object message, Akka.Actor.IActorRef sender) { }\n    protected object UnWrap(object message) { }\n    public virtual Akka.Routing.Router WithRoutees(params Akka.Routing.Routee[] routees) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining StartEntity for Cluster Sharding in C#\nDESCRIPTION: Defines a \"StartEntity\" class, used in Akka.NET cluster sharding to manage sharded entity IDs. \"StartEntity\" implements related Akka.NET and system interfaces for serialization and equality checks, encapsulating entity initiation details.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Core.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class StartEntity : Akka.Cluster.Sharding.IClusterShardingSerializable, System.IEquatable<Akka.Cluster.Sharding.ShardRegion.StartEntity> {\n            public readonly string EntityId;\n            public StartEntity(string entityId) { }\n            public override bool Equals(object obj) { }\n            public bool Equals(Akka.Cluster.Sharding.ShardRegion.StartEntity other) { }\n            public override int GetHashCode() { }\n            public override string ToString() { }\n        }\n```\n\n----------------------------------------\n\nTITLE: Creating Actor System in F#\nDESCRIPTION: Creates an F#-aware actor system using Akka.FSharp.System.create function, which provides F#-specific features including serializers for F# quotations in remote deployment.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.FSharp/README.md#2025-04-16_snippet_0\n\nLANGUAGE: F#\nCODE:\n```\nopen Akka.FSharp\nuse system = System.create \"my-system\" (Configuration.load())\n```\n\n----------------------------------------\n\nTITLE: Creating Headless Akka Service\nDESCRIPTION: Implementation of the Akka service class that manages the actor system and service lifecycle. Extends BackgroundService for integration with .NET hosting.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/deployment/headless-service.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/examples/HeadlessService/AkkaHeadlesssService/AkkaService.cs?name=headless-akka-service)]\n```\n\n----------------------------------------\n\nTITLE: Implementing DistributedPubSubMessageSerializer in C#\nDESCRIPTION: Defines a serializer for distributed publish-subscribe messages, extending SerializerWithStringManifest for binary conversion and manifest handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Core.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic class DistributedPubSubMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public DistributedPubSubMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object o) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Message-Based Actor Initialization in C#\nDESCRIPTION: Demonstrates how to initialize an actor using message passing, useful when constructor initialization isn't possible due to circular dependencies.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_31\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Service : UntypedActor\n{\n    private string _initializeMe;\n\n    protected override void OnReceive(object message)\n    {\n        switch (message)\n        {\n            case \"init\":\n                _initializeMe = \"Up and running\";\n                Become(m =>\n                {\n                    if (m is \"U OK?\" && _initializeMe != null)\n                    {\n                        Sender.Tell(_initializeMe, Self);\n                    }\n                });\n                break;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AdaptiveLoadBalancingRoutingLogic in Akka.NET\nDESCRIPTION: This class provides the implementation of routing logic that adapts based on the metrics of cluster nodes. It selects routees according to the current metrics, allowing for dynamic adaptations to actor workload distribution.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Core.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class AdaptiveLoadBalancingRoutingLogic : Akka.Routing.RoutingLogic, Akka.Cluster.Metrics.IClusterMetricsRoutingLogic\n{\n    public AdaptiveLoadBalancingRoutingLogic(Akka.Actor.ActorSystem system, Akka.Cluster.Metrics.IMetricsSelector metricsSelector = null) { }\n    public void MetricsChanged(Akka.Cluster.Metrics.Events.ClusterMetricsChanged @event) { }\n    public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Router Logic Directly in C#\nDESCRIPTION: This example shows how to use router logic directly in C# without using pools or groups. It creates routees, initializes a Router with RoundRobinRoutingLogic, and routes messages to the routees.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_30\n\nLANGUAGE: csharp\nCODE:\n```\nvar routees = Enumerable\n    .Range(1, 5)\n    .Select(i => new ActorRefRoutee(system.ActorOf<Worker>(\"w\" + i)))\n    .ToArray();\n\nvar router = new Router(new RoundRobinRoutingLogic(), routees);\n\nfor (var i = 0; i < 10; i++)\n    router.Route(\"msg #\" + i, ActorRefs.NoSender);\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterClientSettings in Akka.NET\nDESCRIPTION: Comprehensive configuration settings class for ClusterClient that controls connection behavior, heartbeats, buffer sizes, and contact management. It includes methods for creating settings from configuration and fluent API for modifying settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Net.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class ClusterClientSettings : Akka.Actor.INoSerializationVerificationNeeded\n{\n    [System.ObsoleteAttribute(\"Use constructor with useLegacySerialization argument instead. Since 1.5.15\")]\n    public ClusterClientSettings(System.Collections.Immutable.IImmutableSet<Akka.Actor.ActorPath> initialContacts, System.TimeSpan establishingGetContactsInterval, System.TimeSpan refreshContactsInterval, System.TimeSpan heartbeatInterval, System.TimeSpan acceptableHeartbeatPause, int bufferSize, System.Nullable<System.TimeSpan> reconnectTimeout = null) { }\n    [System.ObsoleteAttribute(\"Use constructor with useInitialContactsDiscovery and discoverySettings argument i\" +\n        \"nstead. Since 1.5.25\")]\n    public ClusterClientSettings(System.Collections.Immutable.IImmutableSet<Akka.Actor.ActorPath> initialContacts, System.TimeSpan establishingGetContactsInterval, System.TimeSpan refreshContactsInterval, System.TimeSpan heartbeatInterval, System.TimeSpan acceptableHeartbeatPause, int bufferSize, bool useLegacySerialization, System.Nullable<System.TimeSpan> reconnectTimeout = null) { }\n    public ClusterClientSettings(System.Collections.Immutable.IImmutableSet<Akka.Actor.ActorPath> initialContacts, System.TimeSpan establishingGetContactsInterval, System.TimeSpan refreshContactsInterval, System.TimeSpan heartbeatInterval, System.TimeSpan acceptableHeartbeatPause, int bufferSize, bool useLegacySerialization, bool useInitialContactsDiscovery, [System.Runtime.CompilerServices.NullableAttribute(2)] Akka.Cluster.Tools.Client.ClusterClientDiscoverySettings discoverySettings = null, System.Nullable<System.TimeSpan> reconnectTimeout = null, bool verboseLogging = False) { }\n    public System.TimeSpan AcceptableHeartbeatPause { get; }\n    public int BufferSize { get; }\n    public Akka.Cluster.Tools.Client.ClusterClientDiscoverySettings DiscoverySettings { get; }\n    public System.TimeSpan EstablishingGetContactsInterval { get; }\n    public System.TimeSpan HeartbeatInterval { get; }\n    public System.Collections.Immutable.IImmutableSet<Akka.Actor.ActorPath> InitialContacts { get; }\n    public System.Nullable<System.TimeSpan> ReconnectTimeout { get; }\n    public System.TimeSpan RefreshContactsInterval { get; }\n    public bool UseInitialContactDiscovery { get; }\n    public bool UseLegacySerialization { get; }\n    public bool VerboseLogging { get; }\n    public static Akka.Cluster.Tools.Client.ClusterClientSettings Create(Akka.Actor.ActorSystem system) { }\n    public static Akka.Cluster.Tools.Client.ClusterClientSettings Create(Akka.Configuration.Config config) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithBufferSize(int bufferSize) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithEstablishingGetContactsInterval(System.TimeSpan value) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithHeartbeatInterval(System.TimeSpan value) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithInitialContacts(System.Collections.Immutable.IImmutableSet<Akka.Actor.ActorPath> initialContacts) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithInitialContactsDiscovery(bool useInitialContactsDiscovery, [System.Runtime.CompilerServices.NullableAttribute(2)] Akka.Cluster.Tools.Client.ClusterClientDiscoverySettings discoverySettings = null) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithReconnectTimeout(System.Nullable<System.TimeSpan> reconnectTimeout) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithRefreshContactsInterval(System.TimeSpan value) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithUseLegacySerialization(bool useLegacySerialization) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract MessageDispatcher Class in C#\nDESCRIPTION: Abstract base class for all message dispatchers in Akka.NET. Handles the routing of messages to actor mailboxes and manages the execution of message processing tasks. Defines core dispatch functionality that concrete implementations must extend.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_96\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class MessageDispatcher\n{\n    public const int DefaultThroughput = 100;\n    protected MessageDispatcher(Akka.Dispatch.MessageDispatcherConfigurator configurator) { }\n    public Akka.Dispatch.MessageDispatcherConfigurator Configurator { get; }\n    public Akka.Event.EventStream EventStream { get; }\n    public string Id { get; set; }\n    protected long Inhabitants { get; }\n    public Akka.Dispatch.Mailboxes Mailboxes { get; }\n    [Akka.Annotations.InternalApiAttribute()]\n    public System.TimeSpan ShutdownTimeout { get; set; }\n    public int Throughput { get; set; }\n    public System.Nullable<long> ThroughputDeadlineTime { get; set; }\n    public virtual void Attach(Akka.Actor.ActorCell cell) { }\n    public virtual void Detach(Akka.Actor.ActorCell cell) { }\n    public virtual void Dispatch(Akka.Actor.ActorCell cell, Akka.Actor.Envelope envelope) { }\n    protected abstract void ExecuteTask(Akka.Dispatch.IRunnable run);\n    protected void ReportFailure(System.Exception ex) { }\n    public void Schedule(System.Action run) { }\n    public void Schedule(Akka.Dispatch.IRunnable run) { }\n    [Akka.Annotations.InternalApiAttribute()]\n    protected abstract void Shutdown();\n    public virtual void SystemDispatch(Akka.Actor.ActorCell cell, Akka.Dispatch.SysMsg.SystemMessage message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Global Rate Limiter Actor in C#\nDESCRIPTION: This code defines a Limiter actor that globally limits the aggregate throughput of a set of streams. It uses a token-based system with replenishment to control the flow rate.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/cookbook.md#2025-04-16_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class WantToPass\n{\n    public static readonly WantToPass Instance = new WantToPass();\n\n    private WantToPass() { }\n}\n\npublic sealed class MayPass\n{\n    public static readonly MayPass Instance = new MayPass();\n\n    private MayPass() { }\n}\n\npublic sealed class ReplenishTokens\n{\n    public static readonly ReplenishTokens Instance = new ReplenishTokens();\n\n    private ReplenishTokens() { }\n}\n\n\npublic class Limiter : ReceiveActor\n{\n    public static Props Props(int maxAvailableTokens, TimeSpan tokenRefreshPeriod, int tokenRefreshAmount)\n        => Akka.Actor.Props.Create(() => new Limiter(maxAvailableTokens, tokenRefreshPeriod, tokenRefreshAmount));\n\n\n    private readonly int _maxAvailableTokens;\n    private readonly int _tokenRefreshAmount;\n    private ImmutableList<IActorRef> _waitQueue;\n    private int _permitTokens;\n    private readonly ICancelable _replenishTimer;\n\n    public Limiter(int maxAvailableTokens, TimeSpan tokenRefreshPeriod, int tokenRefreshAmount)\n    {\n        _maxAvailableTokens = maxAvailableTokens;\n        _tokenRefreshAmount = tokenRefreshAmount;\n\n        _waitQueue = ImmutableList.Create<IActorRef>();\n        _permitTokens = maxAvailableTokens;\n        _replenishTimer = Context.System.Scheduler.ScheduleTellRepeatedlyCancelable(initialDelay: tokenRefreshPeriod,\n            interval: tokenRefreshPeriod, receiver: Self, message: ReplenishTokens.Instance, sender: Nobody.Instance);\n\n        Become(Open);\n    }\n\n    private void Open(object message)\n    {\n        message.Match()\n            .With<ReplenishTokens>(() =>\n            {\n                _permitTokens = Math.Min(_permitTokens + _tokenRefreshAmount, _maxAvailableTokens);\n            })\n            .With<WantToPass>(() =>\n            {\n                _permitTokens--;\n                Sender.Tell(MayPass.Instance);\n                if(_permitTokens == 0)\n                    Become(Closed);\n            });\n    }\n\n    private void Closed(object message)\n    {\n        message.Match()\n            .With<ReplenishTokens>(() =>\n            {\n                _permitTokens = Math.Min(_permitTokens + _tokenRefreshAmount, _maxAvailableTokens);\n                ReleaseWaiting();\n            })\n            .With<WantToPass>(() =>\n            {\n                _waitQueue = _waitQueue.Add(Sender);\n            });\n    }\n\n    private void ReleaseWaiting()\n    {\n        var toBeReleased = _waitQueue.GetRange(0, _permitTokens);\n        _waitQueue = _waitQueue.RemoveRange(0, _permitTokens);\n        _permitTokens -= toBeReleased.Count;\n        toBeReleased.ForEach(s => s.Tell(MayPass.Instance));\n        if(_permitTokens > 0)\n            Become(Open);\n    }\n\n    protected override void PostStop()\n    {\n        _replenishTimer.Cancel();\n        _waitQueue.ForEach(s => s.Tell(new Status.Failure(new IllegalStateException(\"Limiter stopped\"))));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Entity Termination Logic in C#\nDESCRIPTION: Example of how to properly terminate remembered entities using passivation in an Akka.NET actor implementation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-sharding.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override bool ReceiveCommand(object message)\n{\n    switch (message)\n    {\n        case Increment _:\n            Persist(new CounterChanged(1), UpdateState);\n            return true;\n        case Decrement _:\n            Persist(new CounterChanged(-1), UpdateState);\n            return true;\n        case Get _:\n            Sender.Tell(_count);\n            return true;\n        case ReceiveTimeout _:\n            Context.Parent.Tell(new Passivate(Stop.Instance));\n            return true;\n        case Stop _:\n            Context.Stop(Self);\n            return true;\n    }\n    return false;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cluster-Aware Router Pools in HOCON\nDESCRIPTION: HOCON configuration for creating role-based cluster-aware router pools that automatically deploy and manage multiple instances of actors on nodes with specific roles.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/member-roles.md#2025-04-16_snippet_12\n\nLANGUAGE: hocon\nCODE:\n```\nakka\n{\n   actor\n   {\n      provider = \"Akka.Cluster.ClusterActorRefProvider, Akka.Cluster\"\n      deployment\n      {\n         /webdispatcher\n         {\n            router = round-robin-pool # routing strategy\n            max-nr-of-instances-per-node = 5\n            cluster\n            {\n               enabled = on\n               use-role = \"web\"\n            }\n         }\n         /frauddispatcher\n         {\n            router = round-robin-pool # routing strategy\n            max-nr-of-instances-per-node = 5\n            cluster\n            {\n               enabled = on\n               use-role = \"fraud\"\n            }\n         }\n         /billingdispatcher\n         {\n            router = round-robin-pool # routing strategy\n            max-nr-of-instances-per-node = 5\n            cluster\n            {\n               enabled = on\n               use-role = \"billing\"\n            }\n         }\n         /orderdispatcher\n         {\n            router = round-robin-pool # routing strategy\n            max-nr-of-instances-per-node = 5\n            cluster\n            {\n               enabled = on\n               use-role = \"order\"\n            }\n         }\n         /storagedispatcher\n         {\n            router = round-robin-pool # routing strategy\n            max-nr-of-instances-per-node = 5\n            cluster\n            {\n               enabled = on\n               use-role = \"storage\"\n            }\n         }\n      }\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Act class for DSL-based Actor Creation in C#\nDESCRIPTION: Defines the Act class which implements the IActorDsl interface. This class provides methods for configuring actor behavior using a domain-specific language (DSL) approach.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_46\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Act : Akka.Actor.ReceiveActor, Akka.Actor.Dsl.IActorDsl\n{\n    public Act(System.Action<Akka.Actor.Dsl.IActorDsl> config) { }\n    public Act(System.Action<Akka.Actor.Dsl.IActorDsl, Akka.Actor.IActorContext> config) { }\n    public System.Action<System.Exception, Akka.Actor.IActorContext> OnPostRestart { get; set; }\n    public System.Action<Akka.Actor.IActorContext> OnPostStop { get; set; }\n    public System.Action<System.Exception, object, Akka.Actor.IActorContext> OnPreRestart { get; set; }\n    public System.Action<Akka.Actor.IActorContext> OnPreStart { get; set; }\n    public Akka.Actor.SupervisorStrategy Strategy { get; set; }\n    public Akka.Actor.IActorRef ActorOf(System.Action<Akka.Actor.Dsl.IActorDsl> config, string name = null) { }\n    public void Become(System.Action<object, Akka.Actor.IActorContext> handler) { }\n    public void BecomeStacked(System.Action<object, Akka.Actor.IActorContext> handler) { }\n    public void DefaultPostRestart(System.Exception reason) { }\n    public void DefaultPostStop() { }\n    public void DefaultPreRestart(System.Exception reason, object message) { }\n    public void DefaultPreStart() { }\n    protected override void PostRestart(System.Exception reason) { }\n    protected override void PostStop() { }\n    protected override void PreRestart(System.Exception reason, object message) { }\n    protected override void PreStart() { }\n    public void Receive<T>(System.Action<T, Akka.Actor.IActorContext> handler) { }\n    public void Receive<T>(System.Action<T, Akka.Actor.IActorContext> handler, System.Predicate<T> shouldHandle) { }\n    public void Receive<T>(System.Predicate<T> shouldHandle, System.Action<T, Akka.Actor.IActorContext> handler) { }\n    public void ReceiveAny(System.Action<object, Akka.Actor.IActorContext> handler) { }\n    public void ReceiveAnyAsync(System.Func<object, Akka.Actor.IActorContext, System.Threading.Tasks.Task> handler) { }\n    public void ReceiveAsync<T>(System.Func<T, Akka.Actor.IActorContext, System.Threading.Tasks.Task> handler, System.Predicate<T> shouldHandle = null) { }\n    public void ReceiveAsync<T>(System.Predicate<T> shouldHandle, System.Func<T, Akka.Actor.IActorContext, System.Threading.Tasks.Task> handler) { }\n    protected override Akka.Actor.SupervisorStrategy SupervisorStrategy() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Timers in a Custom GraphStage Flow (C#)\nDESCRIPTION: This example shows how to use timers in a custom GraphStage flow. The TimedGate stage toggles between open and closed states, using a timer to control the duration of the open state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/custom-stream-processing.md#2025-04-16_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nclass TimedGate<T> : GraphStage<FlowShape<T, T>>\n{\n    private readonly TimeSpan _silencePeriod;\n\n    private sealed class Logic : TimerGraphStageLogic\n    {\n        private bool _open;\n\n        public Logic(TimedGate<T> gate) : base(gate.Shape)\n        {\n            SetHandler(gate.In, onPush: () =>\n            {\n                var element = Grab(gate.In);\n                if (_open)\n                    Pull(gate.In);\n                else\n                {\n                    Push(gate.Out, element);\n                    _open = true;\n                    ScheduleOnce(\"Close\", gate._silencePeriod);\n                }\n            });\n\n            SetHandler(gate.Out, onPull: () => Pull(gate.In));\n        }\n\n        protected internal override void OnTimer(object timerKey) => _open = false;\n    }\n\n    public TimedGate(TimeSpan silencePeriod)\n    {\n        _silencePeriod = silencePeriod;\n        Shape = new FlowShape<T, T>(In, Out);\n    }\n\n    public Inlet<T> In { get; } = new Inlet<T>(\"TimedGate.in\");\n\n    public Outlet<T> Out { get; } = new Outlet<T>(\"TimedGate.out\");\n\n    public override FlowShape<T, T> Shape { get; }\n\n    protected override GraphStageLogic CreateLogic(Attributes inheritedAttributes) => new Logic(this);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PersistentActor Abstract Class in Akka.NET Persistence\nDESCRIPTION: This code defines the `PersistentActor` abstract class, which inherits from `Akka.Persistence.Eventsourced`. It overrides the `Receive` method for message handling.  This class serves as a base class for persistent actors using event sourcing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class PersistentActor : Akka.Persistence.Eventsourced\n{\n    protected PersistentActor() { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Persistent FSM Base Class\nDESCRIPTION: Abstract base class implementing core FSM functionality with persistence support, including state transitions, timers, and event handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class PersistentFSMBase<TState, TData, TEvent> : Akka.Persistence.PersistentActor, Akka.Routing.IListeners\n{\n    protected PersistentFSMBase() { }\n    public Akka.Routing.ListenerSupport Listeners { get; }\n    public TData NextStateData { get; }\n    public TData StateData { get; }\n    public TState StateName { get; }\n    protected System.Collections.Generic.IEnumerable<TState> StateNames { get; }\n    protected virtual void ApplyState(Akka.Persistence.Fsm.PersistentFSM.State<TState, TData, TEvent> nextState) { }\n    // Additional methods omitted for brevity\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Service Lookup with Akka.Discovery\nDESCRIPTION: Demonstrates how to perform a basic service lookup using Akka.Discovery with only a service name and timeout.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/discovery/index.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nserviceDiscovery.Lookup(new Lookup(\"akka.io\"), TimeSpan.FromSeconds(1));\n// convenience for a Lookup with only a serviceName\nserviceDiscovery.Lookup(\"akka.io\", TimeSpan.FromSeconds(1));\n```\n\n----------------------------------------\n\nTITLE: Actor System Interface Definitions\nDESCRIPTION: Collection of core Akka.NET interfaces defining actor system components including IActionScheduler, IActorContext, IActorRef, and related interfaces for actor system functionality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IActionScheduler : Akka.Actor.IRunnableScheduler\n{\n    void ScheduleOnce(System.TimeSpan delay, System.Action action, Akka.Actor.ICancelable cancelable);\n    void ScheduleOnce(System.TimeSpan delay, System.Action action);\n    void ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action, Akka.Actor.ICancelable cancelable);\n    void ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FutureActor in C#\nDESCRIPTION: An actor implementation that completes a TaskCompletionSource when receiving messages. This actor handles Future/Task completion semantics in the actor system, responding to received messages by completing the associated task.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_88\n\nLANGUAGE: csharp\nCODE:\n```\npublic class FutureActor : Akka.Actor.ActorBase\n{\n    public FutureActor() { }\n    public FutureActor(System.Threading.Tasks.TaskCompletionSource<object> completionSource, Akka.Actor.IActorRef respondTo) { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Memory Journal Implementation in C#\nDESCRIPTION: Implementation of AsyncWriteJournal providing in-memory persistence capabilities with support for writing, reading, and deleting persistent messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_56\n\nLANGUAGE: C#\nCODE:\n```\npublic class MemoryJournal : Akka.Persistence.Journal.AsyncWriteJournal\n{\n    public MemoryJournal() { }\n    protected virtual System.Collections.Concurrent.ConcurrentDictionary<string, System.Collections.Generic.LinkedList<Akka.Persistence.IPersistentRepresentation>> Messages { get; }\n    public System.Collections.Generic.IDictionary<string, System.Collections.Generic.LinkedList<Akka.Persistence.IPersistentRepresentation>> Add(Akka.Persistence.IPersistentRepresentation persistent) { }\n    public System.Collections.Generic.IDictionary<string, System.Collections.Generic.LinkedList<Akka.Persistence.IPersistentRepresentation>> Delete(string pid, long seqNr) { }\n    protected override System.Threading.Tasks.Task DeleteMessagesToAsync(string persistenceId, long toSequenceNr) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Batching SQL Journal Implementation\nDESCRIPTION: Generic implementation of SQL journal with batching support, handling message persistence and replay operations for Akka.NET persistence.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Core.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class BatchingSqlJournal<TConnection, TCommand> : Akka.Persistence.Journal.WriteJournalBase\n    where TConnection : System.Data.Common.DbConnection\n    where TCommand : System.Data.Common.DbCommand\n{\n    protected readonly bool CanPublish;\n    protected const int IsDeletedIndex = 3;\n    protected readonly Akka.Event.ILoggingAdapter Log;\n    protected const int ManifestIndex = 4;\n    protected const int OrderingIndex = 7;\n    protected const int PayloadIndex = 5;\n    protected const int PersistenceIdIndex = 0;\n    protected const int SequenceNrIndex = 1;\n    protected const int SerializerIdIndex = 6;\n    protected const int TimestampIndex = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ClusterSingletonManager in C#\nDESCRIPTION: Example of configuring ClusterSingletonManager with specific role and termination message for a singleton actor implementation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-singleton.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nsystem.ActorOf(ClusterSingletonManager.Props(\n    singletonProps: Props.Create<MySingletonActor>(),\n    terminationMessage: PoisonPill.Instance,\n    settings: ClusterSingletonManagerSettings.Create(system).WithRole(\"worker\")),\n    name: \"consumer\");\n```\n\n----------------------------------------\n\nTITLE: Implementing TailChoppingPool Router Configuration in C#\nDESCRIPTION: Defines a router pool configuration for the TailChopping routing strategy. Unlike TailChoppingGroup, this class creates and manages a pool of actor instances, with support for resizing and supervision.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_205\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class TailChoppingPool : Akka.Routing.Pool\n    {\n        public TailChoppingPool(Akka.Configuration.Config config) { }\n        public TailChoppingPool(int nrOfInstances, System.TimeSpan within, System.TimeSpan interval) { }\n        public TailChoppingPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, System.TimeSpan within, System.TimeSpan interval, bool usePoolDispatcher = False) { }\n        public System.TimeSpan Interval { get; }\n        public System.TimeSpan Within { get; }\n        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n        public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }\n        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n        public Akka.Routing.TailChoppingPool WithDispatcher(string dispatcher) { }\n        public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n        public Akka.Routing.TailChoppingPool WithResizer(Akka.Routing.Resizer resizer) { }\n        public Akka.Routing.TailChoppingPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }\n        public class TailChoppingPoolSurrogate : Akka.Util.ISurrogate\n        {\n            public TailChoppingPoolSurrogate() { }\n            public System.TimeSpan Interval { get; set; }\n            public int NrOfInstances { get; set; }\n            public Akka.Routing.Resizer Resizer { get; set; }\n            public string RouterDispatcher { get; set; }\n            public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }\n            public bool UsePoolDispatcher { get; set; }\n            public System.TimeSpan Within { get; set; }\n            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing MultiNodeClusterSpec for Cluster Restart Test in C#\nDESCRIPTION: This code snippet shows the implementation of a multi-node test specification for testing cluster node restart. It includes the test setup, execution logic, and assertions to verify the cluster behavior after a node restart.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/testing/multi-node-testing.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class RestartNode2Spec : MultiNodeClusterSpec\n{\n    private readonly RestartNode2SpecConfig _config;\n\n    public RestartNode2Spec() : this(new RestartNode2SpecConfig())\n    {\n    }\n\n    protected RestartNode2Spec(RestartNode2SpecConfig config) : base(config)\n    {\n        _config = config;\n    }\n\n    private IImmutableSet<Address> SeedNodes\n    {\n        get { return ImmutableHashSet.Create(GetAddress(_config.Seed1), GetAddress(_config.Seed2)); }\n    }\n\n    [MultiNodeFact]\n    public void RestartNode2_spec()\n    {\n        Cluster_with_seed2_restarted_must_be_rejoinable();\n    }\n\n    private void Cluster_with_seed2_restarted_must_be_rejoinable()\n    {\n        // ... test implementation ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Hashed Wheel Timer Scheduler in C# for Akka.NET\nDESCRIPTION: This class implements a scheduler using a hashed wheel timer, providing methods for scheduling one-time and repeated actions with various delay and interval options.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\npublic class HashedWheelTimerScheduler : Akka.Actor.SchedulerBase, Akka.Actor.IDateTimeOffsetNowTimeProvider, Akka.Actor.ITimeProvider, System.IDisposable\n{\n    public HashedWheelTimerScheduler(Akka.Configuration.Config scheduler, Akka.Event.ILoggingAdapter log) { }\n    public override System.TimeSpan HighResMonotonicClock { get; }\n    public override System.TimeSpan MonotonicClock { get; }\n    protected override System.DateTimeOffset TimeNow { get; }\n    public void Dispose() { }\n    protected override void InternalScheduleOnce(System.TimeSpan delay, System.Action action, Akka.Actor.ICancelable cancelable) { }\n    protected override void InternalScheduleOnce(System.TimeSpan delay, Akka.Dispatch.IRunnable action, Akka.Actor.ICancelable cancelable) { }\n    protected override void InternalScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action, Akka.Actor.ICancelable cancelable) { }\n    protected override void InternalScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Dispatch.IRunnable action, Akka.Actor.ICancelable cancelable) { }\n    protected override void InternalScheduleTellOnce(System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterSingletonManagerSettings for Akka in C#\nDESCRIPTION: Defines a configuration class for ClusterSingletonManager with settings like singleton name, role, removal margin, and handover retry intervals. Provides builder methods for fluent configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_27\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class ClusterSingletonManagerSettings : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public ClusterSingletonManagerSettings(string singletonName, string role, System.TimeSpan removalMargin, System.TimeSpan handOverRetryInterval, bool considerAppVersion) { }\n    public ClusterSingletonManagerSettings(string singletonName, string role, System.TimeSpan removalMargin, System.TimeSpan handOverRetryInterval, Akka.Coordination.LeaseUsageSettings leaseSettings, bool considerAppVersion) { }\n    [System.ObsoleteAttribute(\"ConsiderAppVersion is not used anymore and will be removed in future versions.\")]\n    public bool ConsiderAppVersion { get; }\n    public System.TimeSpan HandOverRetryInterval { get; }\n    public Akka.Coordination.LeaseUsageSettings LeaseSettings { get; }\n    public System.TimeSpan RemovalMargin { get; }\n    public string Role { get; }\n    public string SingletonName { get; }\n    public static Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings Create(Akka.Actor.ActorSystem system) { }\n    public static Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings Create(Akka.Configuration.Config config) { }\n    public Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings WithHandOverRetryInterval(System.TimeSpan handOverRetryInterval) { }\n    public Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings WithLeaseSettings(Akka.Coordination.LeaseUsageSettings leaseSettings) { }\n    public Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings WithRemovalMargin(System.TimeSpan removalMargin) { }\n    public Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings WithRole(string role) { }\n    public Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings WithSingletonName(string singletonName) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel Processing in Akka Streams (C#)\nDESCRIPTION: Shows how to create a parallel processing flow using two identical stages for cooking pancakes. The flow uses Balance and Merge operators to distribute and collect the processed items.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/pipeliningandparallelism.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar fryingPan = Flow.Create<ScoopOfBatter>().Select(batter => Pancake());\n\nvar pancakeChef = Flow.FromGraph(GraphDsl.Create(b =>\n{\n    var dispatchBatter = b.Add(new Balance<ScoopOfBatter>(2));\n    var mergePancakes = b.Add(new Merge<Pancake>(2));\n\n    // Using two frying pans in parallel, both fully cooking a pancake from the batter.\n    // We always put the next scoop of batter to the first frying pan that becomes available.\n    b.From(dispatchBatter.Out(0)).Via(fryingPan.Async()).To(mergePancakes.In(0));\n    // Notice that we used the \"fryingPan\" flow without importing it via builder.Add().\n    // Flows used this way are auto-imported, which in this case means that the two\n    // uses of \"fryingPan\" mean actually different stages in the graph.\n    b.From(dispatchBatter.Out(1)).Via(fryingPan.Async()).To(mergePancakes.In(1));\n\n    return new FlowShape<ScoopOfBatter, Pancake>(dispatchBatter.In, mergePancakes.Out);\n}));\n```\n\n----------------------------------------\n\nTITLE: Implementing Result Factory Methods in C#\nDESCRIPTION: Static factory methods for creating Result<T> instances from different sources, including direct values, exceptions, functions, and tasks. These methods are annotated with nullable attributes to support C# nullable reference types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_249\n\nLANGUAGE: C#\nCODE:\n```\npublic static Akka.Util.Result<T> Failure<[System.Runtime.CompilerServices.NullableAttribute(2)]  T>(System.Exception exception) { }\n[return: System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n        0,\n        1})]\npublic static Akka.Util.Result<T> From<[System.Runtime.CompilerServices.NullableAttribute(2)]  T>(System.Func<T> func) { }\n[return: System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n        0,\n        1})]\npublic static Akka.Util.Result<T> FromTask<[System.Runtime.CompilerServices.NullableAttribute(2)]  T>(System.Threading.Tasks.Task<T> task) { }\n[return: System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n        0,\n        1})]\npublic static Akka.Util.Result<T> Success<[System.Runtime.CompilerServices.NullableAttribute(2)]  T>(T value) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Either for Functional Programming in C#\nDESCRIPTION: Defines the Either<TA, TB> abstract class and related classes for functional programming constructs in Akka.NET. It provides methods for handling two possible types and performing operations on them.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_208\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Either<TA, TB>\n{\n    protected Either(TA left, TB right) { }\n    public abstract bool IsLeft { get; }\n    public abstract bool IsRight { get; }\n    protected TA Left { get; }\n    protected TB Right { get; }\n    public object Value { get; }\n    public TRes Fold<TRes>(System.Func<TA, TRes> left, System.Func<TB, TRes> right) { }\n    public Akka.Util.Either<TRes1, TRes2> Map<TRes1, TRes2>(System.Func<TA, TRes1> map1, System.Func<TB, TRes2> map2) { }\n    public Akka.Util.Either<TRes, TB> MapLeft<TRes>(System.Func<TA, TRes> map) { }\n    public Akka.Util.Either<TA, TRes> MapRight<TRes>(System.Func<TB, TRes> map) { }\n    public Akka.Util.Left<TA, TB> ToLeft() { }\n    public Akka.Util.Right<TA, TB> ToRight() { }\n    public static Akka.Util.Either<TA, TB> op_Implicit(Akka.Util.Left<TA> left) { }\n    public static Akka.Util.Either<TA, TB> op_Implicit(Akka.Util.Right<TB> right) { }\n}\n```\n\n----------------------------------------\n\nTITLE: ClusterClientReceptionist Implementation in C#\nDESCRIPTION: An extension class that manages the receptionist component of the cluster client, allowing services to register themselves to be contacted by external clients. It handles service and subscriber registration and unregistration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Core.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterClientReceptionist : Akka.Actor.IExtension\n{\n    public ClusterClientReceptionist(Akka.Actor.ExtendedActorSystem system) { }\n    public bool IsTerminated { get; }\n    public Akka.Actor.IActorRef Underlying { get; }\n    public static Akka.Configuration.Config DefaultConfig() { }\n    public static Akka.Cluster.Tools.Client.ClusterClientReceptionist Get(Akka.Actor.ActorSystem system) { }\n    public void RegisterService(Akka.Actor.IActorRef actorRef) { }\n    public void RegisterSubscriber(string topic, Akka.Actor.IActorRef actorRef) { }\n    public void UnregisterService(Akka.Actor.IActorRef actorRef) { }\n    public void UnregisterSubscriber(string topic, Akka.Actor.IActorRef actorRef) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Complex RunnableGraph with GraphDSL in C#\nDESCRIPTION: This snippet demonstrates how to create a complex, non-linear stream processing network using Akka.NET's GraphDSL. It includes fan-in, fan-out stages, and directed cycles, showcasing the flexibility of the graph-based approach.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/modularitycomposition.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nRunnableGraph.FromGraph(GraphDsl.Create(builder =>\n{\n    var a = builder.Add(Source.Single(0)).Outlet;\n    var b = builder.Add(new Broadcast<int>(2));\n    var c = builder.Add(new Merge<int>(2));\n    var d = builder.Add(Flow.Create<int>().Select(x => x + 1));\n    var e = builder.Add(new Balance<int>(2));\n    var f = builder.Add(new Merge<int>(2));\n    var g = builder.Add(Sink.ForEach<int>(Console.WriteLine)).Inlet;\n\n    builder.To(c).From(f);\n    builder.From(a).Via(b).Via(c).To(f);\n    builder.From(b).Via(d).Via(e).To(f);\n    builder.From(e).To(g);\n\n    return ClosedShape.Instance;\n}));\n```\n\n----------------------------------------\n\nTITLE: Implementing ScatterGatherFirstCompletedRoutingLogic Class in C#\nDESCRIPTION: Definition of ScatterGatherFirstCompletedRoutingLogic which implements the scatter-gather pattern logic. It sends messages to all routees and returns the first response received within a configured timeout.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_199\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ScatterGatherFirstCompletedRoutingLogic : Akka.Routing.RoutingLogic\n{\n    public ScatterGatherFirstCompletedRoutingLogic(System.TimeSpan within) { }\n    public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }\n}\n```\n\n----------------------------------------\n\nTITLE: State Transition with ReceiveActor - C#\nDESCRIPTION: This snippet illustrates the improper and proper methods to implement state transitions in Akka.NET using ReceiveActor in C#. The incorrect method involves directly changing states within the Grumpy method, while the correct approach ensures state changes occur within message handlers utilizing the Become function. Dependencies include Akka.NET setup, and the key functionality is handling actor state transitions appropriately.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka/Util/MatchHandler/README.md#2025-04-16_snippet_10\n\nLANGUAGE: c#\nCODE:\n```\nReceive<string>(s => s == \"Grumpy\", _ => Become(Grumpy, discardOld: false));\n...\nprivate void Grumpy()\n{\n  _state = State.Grumpy;                      //DO NOT do this\n  Sender.Tell(\"I just became grumpy\", Self);  //DO NOT do this\n  Receive<string>(s => s == \"Snap out of it!\", s => Unbecome());\n  Receive<string>(s => Sender.Tell(\"Leave me alone. I'm Grumpy!\"));\n}\n```\n\nLANGUAGE: c#\nCODE:\n```\nReceive<string>(s => s == \"Grumpy\", _ => \n  {\n    _state = State.Grumpy;\n    Sender.Tell(\"I just became grumpy\", Self);\n    Become(Grumpy, discardOld: false));\n  });\n...\nprivate void Grumpy()\n{\n  Receive<string>(s => s == \"Snap out of it!\", s => Unbecome());\n  Receive<string>(s => Sender.Tell(\"Leave me alone. I'm Grumpy!\"));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TestEventListener Class in C#\nDESCRIPTION: Basic event listener implementation that extends DefaultLogger for testing purposes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestEventListener : Akka.Event.DefaultLogger\n{\n    public TestEventListener() { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IJournalPlugin Interface in C#\nDESCRIPTION: This code defines the IJournalPlugin interface, providing basic configurations and path specifications for journal plugins within Akka. This is essential for implementing various persistence backends.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IJournalPlugin\n{\n    Akka.Configuration.Config DefaultConfig { get; }\n    string JournalPath { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RandomGroup Router in HOCON Configuration\nDESCRIPTION: Shows how to define a random group router in HOCON configuration that will distribute messages randomly to the specified actor paths.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_15\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.deployment {\n  /some-group {\n    router = random-group\n    routees.paths = [\"/user/workers/w1\", \"/user/workers/w2\", \"/user/workers/w3\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ShardingEnvelope Class in C#\nDESCRIPTION: Implements the ShardingEnvelope class, which wraps messages with entity IDs for cluster sharding. It implements IWrappedMessage and IClusterShardingSerializable interfaces.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Net.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class ShardingEnvelope : Akka.Actor.IWrappedMessage, Akka.Cluster.Sharding.IClusterShardingSerializable, System.IEquatable<Akka.Cluster.Sharding.ShardingEnvelope>\n{\n    public ShardingEnvelope(string entityId, object message) { }\n    public string EntityId { get; }\n    public object Message { get; }\n    public bool Equals(Akka.Cluster.Sharding.ShardingEnvelope other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Reusing Latest Values Downstream with Akka.NET\nDESCRIPTION: This snippet uses `ReuseLatest` to cache and reuse the most recent value from a source, specifically an `HttpClient`.  It addresses scenarios where one source produces messages infrequently and needs to be combined with a faster stream, ensuring that every downstream request is serviced with the latest available value.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/buffersandworkingwithrate.md#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\npublic static Source<HttpClient, ICancelable> CreateSourceInternal(string clientId,\n        Func<Task<string>> tokenProvider, TimeSpan tokenRefreshTimeout)\n{\n        var source = Source.Tick(TimeSpan.Zero, TimeSpan.FromSeconds(30), clientId)\n            .SelectAsync(1, async c => \n                // refresh bearer token, create new HttpClient\n                CreateClient(c, (await tokenProvider().WaitAsync(tokenRefreshTimeout))))\n             // reuse the previous value whenever there's downstream demand\n            .ReuseLatest();\n        return source;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Consistent Hashing Router Classes in C#\nDESCRIPTION: Defines router classes for consistent hashing including ConsistentHashingGroup, ConsistentHashingPool, and related surrogate classes. Provides functionality for actor routing based on hash keys.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_179\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ConsistentHashingPool : Akka.Routing.Pool\n{\n    public ConsistentHashingPool(int nrOfInstances) { }\n    public ConsistentHashingPool(Akka.Configuration.Config config) { }\n    public ConsistentHashingPool(int nrOfInstances, Akka.Routing.ConsistentHashMapping hashMapping) { }\n    public ConsistentHashingPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False, int virtualNodesFactor = 0, Akka.Routing.ConsistentHashMapping hashMapping = null) { }\n    public int VirtualNodesFactor { get; }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MergeHub in Akka.NET Streams\nDESCRIPTION: Example of using MergeHub to implement a dynamic fan-in junction point in a graph. This allows elements from different producers to be emitted in a First-Comes-First-Served fashion.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/stream-dynamic.md#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n[!code-csharp[HubsDocTests.cs](../../../src/core/Akka.Docs.Tests/Streams/HubsDocTests.cs?name=merge-hub)]\n```\n\n----------------------------------------\n\nTITLE: Registering Consumer with ShardingConsumerController in C#\nDESCRIPTION: Demonstrates how a Consumer actor (ShoppingCart) registers itself with the ShardingConsumerController to begin receiving messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-sharding-delivery.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override void PreStart()\n{\n    base.PreStart();\n    _consumerController.Tell(ConsumerController.Start.Instance);\n}\n```\n\n----------------------------------------\n\nTITLE: Actor Context Interface Definition in C#\nDESCRIPTION: IActorContext interface that defines the core context functionality available to actors, including access to the actor system, parent/child relationships, and message handling capabilities.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IActorContext : Akka.Actor.IActorRefFactory, Akka.Actor.ICanWatch\n{\n    Akka.Dispatch.MessageDispatcher Dispatcher { get; }\n    Akka.Actor.IActorRef Parent { get; }\n    Akka.Actor.Props Props { get; }\n    System.Nullable<System.TimeSpan> ReceiveTimeout { get; }\n    Akka.Actor.IActorRef Self { get; }\n    Akka.Actor.IActorRef Sender { get; }\n    Akka.Actor.ActorSystem System { get; }\n    void Become(Akka.Actor.Receive receive);\n    void BecomeStacked(Akka.Actor.Receive receive);\n    Akka.Actor.IActorRef Child(string name);\n    System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> GetChildren();\n    void SetReceiveTimeout(System.Nullable<System.TimeSpan> timeout);\n    void Stop(Akka.Actor.IActorRef child);\n    void UnbecomeStacked();\n}\n```\n\n----------------------------------------\n\nTITLE: Programmatic Serialization Example\nDESCRIPTION: C# code demonstrating how to programmatically serialize and deserialize objects using Akka.NET's serialization system\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/serialization/serialization.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Actor;\nusing Akka.Serialization;\nActorSystem system = ActorSystem.Create(\"example\");\n\n// Get the Serialization Extension\nSerialization serialization = system.Serialization;\n\n// Have something to serialize\nstring original = \"woohoo\";\n\n// Find the Serializer for it\nSerializer serializer = serialization.FindSerializerFor(original);\n\n// Turn it into bytes\nbyte[] bytes = serializer.ToBinary(original);\n\n// Turn it back into an object,\n// the nulls are for the class manifest and for the classloader\nstring back = (string)serializer.FromBinary(bytes, original.GetType());\n\n// Voilá!\nAssert.AreEqual(original, back);\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterShardingSettings Class in C#\nDESCRIPTION: Defines the ClusterShardingSettings class with various configuration options for Akka.NET Cluster Sharding. Includes constructors and methods for customizing settings such as remember entities, journal plugin, and state store mode.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Net.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterShardingSettings\n{\n    public readonly Akka.Cluster.Sharding.StateStoreMode StateStoreMode;\n    public readonly Akka.Cluster.Sharding.TuningParameters TuningParameters;\n    public ClusterShardingSettings(string role, bool rememberEntities, string journalPluginId, string snapshotPluginId, System.TimeSpan passivateIdleEntityAfter, Akka.Cluster.Sharding.StateStoreMode stateStoreMode, Akka.Cluster.Sharding.TuningParameters tuningParameters, Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings coordinatorSingletonSettings) { }\n    // Additional constructors and methods...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Initial Read Protocol Messages in C#\nDESCRIPTION: Defines the initial messages for the read protocol of the device actor, including a request and response message for temperature queries.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-2.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class ReadTemperature\n{\n    public ReadTemperature()\n    {\n    }\n}\n\npublic sealed class RespondTemperature\n{\n    public RespondTemperature(double? value)\n    {\n        Value = value;\n    }\n\n    public double? Value { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring DotNetty TCP Transport in HOCON for Akka.Remote\nDESCRIPTION: HOCON configuration example showing how to enable and configure the default DotNetty TCP transport for Akka.Remote. This sets up the actor system to use remote communication with the specified port and hostname.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/remoting/transports.md#2025-04-16_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\nakka {  \n    actor {\n        provider = remote\n    }\n    remote {\n         dot-netty.tcp {\n            port = 8081 #bound to a specific port\n            hostname = localhost\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Partial Graph in Akka Streams (C#)\nDESCRIPTION: This snippet demonstrates how to create a partial graph with custom functionality (picking the maximum of three inputs) and then use it within a larger graph. It showcases the creation of custom shapes and their integration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithgraphs.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar pickMaxOfThree = GraphDsl.Create(b =>\n{\n    var zip1 = b.Add(ZipWith.Apply<int, int, int>(Math.Max));\n    var zip2 = b.Add(ZipWith.Apply<int, int, int>(Math.Max));\n    b.From(zip1.Out).To(zip2.In0);\n\n    return new UniformFanInShape<int, int>(zip2.Out, zip1.In0, zip1.In1, zip2.In1);\n});\n\nvar resultSink = Sink.First<int>();\n\nvar g = RunnableGraph.FromGraph(GraphDsl.Create(resultSink, (b, sink) =>\n{\n    // importing the partial graph will return its shape (inlets & outlets)\n    var pm3 = b.Add(pickMaxOfThree);\n    var s1 = Source.Single(1).MapMaterializedValue<Task<int>>(_ => null);\n    var s2 = Source.Single(2).MapMaterializedValue<Task<int>>(_ => null);\n    var s3 = Source.Single(3).MapMaterializedValue<Task<int>>(_ => null);\n\n    b.From(s1).To(pm3.In(0));\n    b.From(s2).To(pm3.In(1));\n    b.From(s3).To(pm3.In(2));\n\n    b.From(pm3.Out).To(sink.Inlet);\n\n    return ClosedShape.Instance;\n}));\n\nvar max = g.Run(materializer);\nmax.Wait(TimeSpan.FromSeconds(3)).Should().BeTrue();\nmax.Result.Should().Be(3);\n```\n\n----------------------------------------\n\nTITLE: Adding Features to Publish-Subscribe Channel in Akka.NET Streams\nDESCRIPTION: Example of adding features to the publish-subscribe channel, such as attaching a Sink.Ignore to keep it drained when there are no subscribers.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/stream-dynamic.md#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n[!code-csharp[HubsDocTests.cs](../../../src/core/Akka.Docs.Tests/Streams/HubsDocTests.cs?name=pub-sub-2)]\n```\n\n----------------------------------------\n\nTITLE: Configuring Akka.NET Client for Remote Communication\nDESCRIPTION: This XML configuration sets up an Akka.NET client system for remote communication using the dot-netty.tcp transport. It specifies a dynamic port and localhost as the hostname.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/remoting/index.md#2025-04-16_snippet_2\n\nLANGUAGE: xml\nCODE:\n```\nakka {  \n    actor {\n        provider = remote\n    }\n    remote {\n        dot-netty.tcp {\n            port = 0 # bound to a dynamic port assigned by the OS\n            hostname = localhost\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Interfaces for Cluster Sharding in C#\nDESCRIPTION: Interfaces for actor system-dependent allocation strategies, message extractors, shard allocation strategies, and shard region commands and queries.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IActorSystemDependentAllocationStrategy : Akka.Actor.INoSerializationVerificationNeeded, Akka.Cluster.Sharding.IShardAllocationStrategy\n{\n    void Start(Akka.Actor.ActorSystem system);\n}\n\npublic interface IClusterShardingSerializable { }\n\npublic interface IMessageExtractor\n{\n    string EntityId(object message);\n    object EntityMessage(object message);\n    string ShardId(object message);\n}\n\npublic interface IShardAllocationStrategy : Akka.Actor.INoSerializationVerificationNeeded\n{\n    System.Threading.Tasks.Task<Akka.Actor.IActorRef> AllocateShard(Akka.Actor.IActorRef requester, string shardId, System.Collections.Immutable.IImmutableDictionary<Akka.Actor.IActorRef, System.Collections.Immutable.IImmutableList<string>> currentShardAllocations);\n    System.Threading.Tasks.Task<System.Collections.Immutable.IImmutableSet<string>> Rebalance(System.Collections.Immutable.IImmutableDictionary<Akka.Actor.IActorRef, System.Collections.Immutable.IImmutableList<string>> currentShardAllocations, System.Collections.Immutable.IImmutableSet<string> rebalanceInProgress);\n}\n\npublic interface IShardRegionCommand { }\n\npublic interface IShardRegionQuery { }\n\npublic interface IStartableAllocationStrategy : Akka.Actor.INoSerializationVerificationNeeded, Akka.Cluster.Sharding.IShardAllocationStrategy\n{\n    void Start();\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Mailbox in HOCON Configuration\nDESCRIPTION: Example configuration that registers a custom mailbox implementation with a key that can be referenced in actor configurations. This demonstrates how to define a mailbox type outside the akka section.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/mailboxes.md#2025-04-16_snippet_2\n\nLANGUAGE: HOCON\nCODE:\n```\nakka { ... }\nmy-custom-mailbox {\n    mailbox-type : \"MyProject.CustomMailbox, MyProjectAssembly\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LWWRegister for Akka.NET Distributed Data\nDESCRIPTION: Last-Write-Wins Register implementation for Akka.NET's distributed data. This class provides a conflict-free replicated register with automatic conflict resolution based on timestamps.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class LWWRegister<T> : Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.LWWRegister<T>>, System.IEquatable<Akka.DistributedData.LWWRegister<T>>\n{\n    public static readonly Akka.DistributedData.Clock<T> DefaultClock;\n    public static readonly Akka.DistributedData.Clock<T> ReverseClock;\n    public LWWRegister(Akka.Cluster.UniqueAddress node, T initial) { }\n    public LWWRegister(Akka.Cluster.UniqueAddress node, T value, long timestamp) { }\n    public LWWRegister(Akka.Cluster.UniqueAddress node, T initial, Akka.DistributedData.Clock<T> clock) { }\n    public System.Type RegisterType { get; }\n    public long Timestamp { get; }\n    public Akka.Cluster.UniqueAddress UpdatedBy { get; }\n    public T Value { get; }\n    public bool Equals(Akka.DistributedData.LWWRegister<T> other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public Akka.DistributedData.LWWRegister<T> Merge(Akka.DistributedData.LWWRegister<T> other) { }\n    public Akka.DistributedData.IReplicatedData Merge(Akka.DistributedData.IReplicatedData other) { }\n    public override string ToString() { }\n    public Akka.DistributedData.LWWRegister<T> WithValue(Akka.Cluster.UniqueAddress node, T value, Akka.DistributedData.Clock<T> clock = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic IReplicatedData Interface in C#\nDESCRIPTION: This snippet defines the generic `IReplicatedData<T>` interface, which inherits from `IReplicatedData`. It provides a type-safe `Merge` method that operates on instances of the specific replicated data type `T`.  The type parameter `T` is constrained to be an `IReplicatedData`.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\n    public interface IReplicatedData<T> : Akka.DistributedData.IReplicatedData\n        where T : Akka.DistributedData.IReplicatedData\n    {\n        T Merge(T other);\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Implementing State Transitions in Akka.NET FSM\nDESCRIPTION: This code demonstrates how to handle state transitions in the FSM actor, specifically sending batched messages when transitioning from Active to Idle state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/finite-state-machine.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/core/Akka.Docs.Tests/Actors/FiniteStateMachine/ExampleFSMActor.cs?name=TransitionHandler)]\n```\n\n----------------------------------------\n\nTITLE: Defining IShardAllocationStrategy Interface in Akka.NET Sharding\nDESCRIPTION: This interface defines the methods for allocating shards to actor refs and rebalancing shards across the cluster.  It is used by the ShardCoordinator to manage shard distribution.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n    public interface IShardAllocationStrategy : Akka.Actor.INoSerializationVerificationNeeded\n    {\n        System.Threading.Tasks.Task<Akka.Actor.IActorRef> AllocateShard(Akka.Actor.IActorRef requester, string shardId, System.Collections.Immutable.IImmutableDictionary<Akka.Actor.IActorRef, System.Collections.Immutable.IImmutableList<string>> currentShardAllocations);\n        System.Threading.Tasks.Task<System.Collections.Immutable.IImmutableSet<string>> Rebalance(System.Collections.Immutable.IImmutableDictionary<Akka.Actor.IActorRef, System.Collections.Immutable.IImmutableList<string>> currentShardAllocations, System.Collections.Immutable.IImmutableSet<string> rebalanceInProgress);\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing AppVersion Class for Version Comparison in C#\nDESCRIPTION: Defines an AppVersion class that implements IComparable and IEquatable interfaces. It provides methods for version comparison and equality checking.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_217\n\nLANGUAGE: C#\nCODE:\n```\npublic class AppVersion : System.IComparable<Akka.Util.AppVersion>, System.IEquatable<Akka.Util.AppVersion>\n{\n    public static readonly Akka.Util.AppVersion Zero;\n    public string Version { get; }\n    public int CompareTo(Akka.Util.AppVersion other) { }\n    public static Akka.Util.AppVersion Create(string version) { }\n    public bool Equals(Akka.Util.AppVersion other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n    public static bool ==(Akka.Util.AppVersion first, Akka.Util.AppVersion second) { }\n    public static bool !=(Akka.Util.AppVersion first, Akka.Util.AppVersion second) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Cluster Core Type: Cluster Management Class\nDESCRIPTION: Represents the main cluster management class in Akka.NET, providing methods for joining, leaving, and monitoring cluster state. Includes key operations for cluster membership and event subscription.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Cluster : Akka.Actor.IExtension\n{\n    public void Join(Akka.Actor.Address address) { }\n    public void Leave(Akka.Actor.Address address) { }\n    public void Subscribe(Akka.Actor.IActorRef subscriber, params System.Type[] to) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TypeExtensions Static Class in C#\nDESCRIPTION: Extension methods for Type objects to check for interface implementations and get qualified type names.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_239\n\nLANGUAGE: C#\nCODE:\n```\npublic class static TypeExtensions\n{\n    public static bool Implements<T>(this System.Type type) { }\n    public static bool Implements(this System.Type type, System.Type moreGeneralType) { }\n    [Akka.Annotations.InternalApiAttribute()]\n    public static string TypeQualifiedName(this System.Type type) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MemoryJournal Class for Akka.NET Persistence\nDESCRIPTION: This class implements an in-memory journal for Akka.NET persistence, providing methods for reading, writing, and managing persistent messages in memory.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\npublic class MemoryJournal : Akka.Persistence.Journal.AsyncWriteJournal\n{\n    public MemoryJournal() { }\n    protected virtual System.Collections.Concurrent.ConcurrentDictionary<string, System.Collections.Generic.LinkedList<Akka.Persistence.IPersistentRepresentation>> Messages { get; }\n    public System.Collections.Generic.IDictionary<string, System.Collections.Generic.LinkedList<Akka.Persistence.IPersistentRepresentation>> Add(Akka.Persistence.IPersistentRepresentation persistent) { }\n    public System.Collections.Generic.IDictionary<string, System.Collections.Generic.LinkedList<Akka.Persistence.IPersistentRepresentation>> Delete(string pid, long seqNr) { }\n    protected override System.Threading.Tasks.Task DeleteMessagesToAsync(string persistenceId, long toSequenceNr) { }\n    public long HighestSequenceNr(string pid) { }\n    public System.Collections.Generic.IEnumerable<Akka.Persistence.IPersistentRepresentation> Read(string pid, long fromSeqNr, long toSeqNr, long max) { }\n    public override System.Threading.Tasks.Task<long> ReadHighestSequenceNrAsync(string persistenceId, long fromSequenceNr) { }\n    public override System.Threading.Tasks.Task ReplayMessagesAsync(Akka.Actor.IActorContext context, string persistenceId, long fromSequenceNr, long toSequenceNr, long max, System.Action<Akka.Persistence.IPersistentRepresentation> recoveryCallback) { }\n    public System.Collections.Generic.IDictionary<string, System.Collections.Generic.LinkedList<Akka.Persistence.IPersistentRepresentation>> Update(string pid, long seqNr, System.Func<Akka.Persistence.IPersistentRepresentation, Akka.Persistence.IPersistentRepresentation> updater) { }\n    protected override System.Threading.Tasks.Task<System.Collections.Immutable.IImmutableList<System.Exception>> WriteMessagesAsync(System.Collections.Generic.IEnumerable<Akka.Persistence.AtomicWrite> messages) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Metrics Listener in C#\nDESCRIPTION: Demonstrates how to implement a custom metrics listener actor to subscribe to metrics events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-metrics.md#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n[!code-csharp[MetricsListenerSample](../../../src/core/Akka.Docs.Tests/Cluster.Metrics/MetricsListenerSample.cs)]\n```\n\n----------------------------------------\n\nTITLE: Message Production in Akka.Delivery\nDESCRIPTION: Demonstrates the message production flow in Akka.Delivery, showing how to handle RequestNext messages and implement back-pressure handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/reliable-delivery.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nprivate void OnRequestNext(ProducerController.RequestNext<IDeliveryMessage> next)\n{\n    var message = new Message1(\"example\");\n    next.SendNextTo.Tell(message);\n}\n```\n\n----------------------------------------\n\nTITLE: Killing an Actor with Kill Message in C#\nDESCRIPTION: Demonstrates how to terminate an actor by sending a Kill message, which triggers an ActorKilledException and initiates the supervision process.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_29\n\nLANGUAGE: csharp\nCODE:\n```\n// kill the 'victim' actor\nvictim.Tell(Akka.Actor.Kill.Instance, ActorRef.NoSender);\n```\n\n----------------------------------------\n\nTITLE: Testing Device Actor Temperature Reading in C# with xUnit\nDESCRIPTION: Demonstrates a unit test for the device actor's temperature reading functionality using xUnit and Akka.NET TestKit.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-2.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[Fact]\npublic void Device_actor_must_reply_with_empty_reading_if_no_temperature_is_known()\n{\n    var probe = CreateTestProbe();\n    var deviceActor = Sys.ActorOf(Props.Create<Device>(\"group\", \"device\"));\n\n    deviceActor.Tell(new ReadTemperature(requestId: 42), probe.Ref);\n    var response = probe.ExpectMsg<RespondTemperature>();\n    Assert.Equal(42, response.RequestId);\n    Assert.Null(response.Value);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RouterConfig Abstract Class in C#\nDESCRIPTION: Definition of the RouterConfig abstract class which serves as a base for all router configurations. It provides common functionality for router creation, management, and serialization support through the ISurrogated interface.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_194\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class RouterConfig : Akka.Util.ISurrogated, System.IEquatable<Akka.Routing.RouterConfig>\n{\n    protected RouterConfig() { }\n    protected RouterConfig(string routerDispatcher) { }\n    public virtual string RouterDispatcher { get; }\n    public virtual bool StopRouterWhenAllRouteesRemoved { get; }\n    public abstract Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system);\n    [Akka.Annotations.InternalApiAttribute()]\n    public abstract Akka.Actor.ActorBase CreateRouterActor();\n    public bool Equals(Akka.Routing.RouterConfig other) { }\n    public override bool Equals(object obj) { }\n    public virtual bool IsManagementMessage(object message) { }\n    public virtual Akka.Actor.Props RoutingLogicController(Akka.Routing.RoutingLogic routingLogic) { }\n    public abstract Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system);\n    public virtual void VerifyConfig(Akka.Actor.ActorPath path) { }\n    public virtual Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Default Serializer IDs in HOCON Configuration\nDESCRIPTION: This snippet demonstrates how to override default serializer IDs in the HOCON configuration. It shows the modification of the original default serializer ID and the declaration of a custom serializer using the original ID.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/serialization/serialization.md#2025-04-16_snippet_4\n\nLANGUAGE: hocon\nCODE:\n```\nserialization-identifiers {\n  \"Akka.Serialization.NewtonSoftJsonSerializer, Akka\" : 1000001\n  \"MyAssembly.MyDefaultSerializer, SomeAssembly\" : 1\n}\n```\n\n----------------------------------------\n\nTITLE: Reusing Values Downstream in Akka.NET Stream\nDESCRIPTION: This code demonstrates how to reuse the most recently emitted element downstream. The `ReuseLatest` operation is typically used with fan-in stages like `Zip` to ensure that the latest value is always available for downstream processes. Dependencies required include the Akka.Streams library.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/builtinstages.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[ReuseLatest](../../../src/core/Akka.Streams.Tests/Dsl/ReuseLatestSpec.cs?name=RepeatPrevious)]\n```\n\n----------------------------------------\n\nTITLE: Defining an Actor with Mixed Injected and Non-Injected Dependencies\nDESCRIPTION: This example shows an actor that accepts both injected dependencies and regular constructor parameters that are not provided via DI.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/dependency-injection.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[NonDiActor](../../../src/contrib/dependencyinjection/Akka.DependencyInjection.Tests/ActorServiceProviderPropsWithScopesSpecs.cs?name=NonDiArgsActor)]\n```\n\n----------------------------------------\n\nTITLE: Implementing Failure Detection Classes in C# for Akka.NET Remote Module\nDESCRIPTION: Defines various failure detection classes (DeadlineFailureDetector, PhiAccrualFailureDetector) and related interfaces for monitoring remote actor health in Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class DeadlineFailureDetector : Akka.Remote.FailureDetector\n{\n    [System.ObsoleteAttribute(\"Use DeadlineFailureDetector(acceptableHeartbeatPause, heartbeatInterval, clock) instead. [1.1.2]\")]\n    public DeadlineFailureDetector(System.TimeSpan acceptableHeartbeatPause, Akka.Remote.Clock clock = null) { }\n    public DeadlineFailureDetector(System.TimeSpan acceptableHeartbeatPause, System.TimeSpan heartbeatInterval, Akka.Remote.Clock clock = null) { }\n    public DeadlineFailureDetector(Akka.Configuration.Config config, Akka.Event.EventStream eventStream) { }\n    public override bool IsAvailable { get; }\n    public override bool IsMonitoring { get; }\n    public override void HeartBeat() { }\n}\n\npublic class PhiAccrualFailureDetector : Akka.Remote.FailureDetector\n{\n    public PhiAccrualFailureDetector(double threshold, int maxSampleSize, System.TimeSpan minStdDeviation, System.TimeSpan acceptableHeartbeatPause, System.TimeSpan firstHeartbeatEstimate, Akka.Remote.Clock clock = null) { }\n    public PhiAccrualFailureDetector(Akka.Configuration.Config config, Akka.Event.EventStream ev) { }\n    protected PhiAccrualFailureDetector(Akka.Remote.Clock clock) { }\n    public string Address { get; set; }\n    public override bool IsAvailable { get; }\n    public override bool IsMonitoring { get; }\n    public override void HeartBeat() { }\n}\n\npublic abstract class FailureDetector\n{\n    public static readonly Akka.Remote.Clock DefaultClock;\n    protected FailureDetector() { }\n    public abstract bool IsAvailable { get; }\n    public abstract bool IsMonitoring { get; }\n    public abstract void HeartBeat();\n}\n\npublic interface IFailureDetectorRegistry<in T>\n{\n    void Heartbeat(T resource);\n    bool IsAvailable(T resource);\n    bool IsMonitoring(T resource);\n    void Remove(T resource);\n    void Reset();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ConcurrentSet<T> Class for Thread-Safe Set Operations in C#\nDESCRIPTION: Defines a ConcurrentSet<T> class that implements ICollection<T> and provides thread-safe set operations. It includes methods for adding, removing, and checking containment of elements.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_219\n\nLANGUAGE: C#\nCODE:\n```\npublic class ConcurrentSet<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable\n{\n    public ConcurrentSet() { }\n    public ConcurrentSet(System.Collections.Generic.IEnumerable<T> collection) { }\n    public ConcurrentSet(System.Collections.Generic.IEqualityComparer<T> comparer) { }\n    public ConcurrentSet(System.Collections.Generic.IEnumerable<T> collection, System.Collections.Generic.IEqualityComparer<T> comparer) { }\n    public ConcurrentSet(int concurrencyLevel, int capacity) { }\n    public ConcurrentSet(int concurrencyLevel, System.Collections.Generic.IEnumerable<T> collection, System.Collections.Generic.IEqualityComparer<T> comparer) { }\n    public ConcurrentSet(int concurrencyLevel, int capacity, System.Collections.Generic.IEqualityComparer<T> comparer) { }\n    public int Count { get; }\n    public bool IsEmpty { get; }\n    public void Clear() { }\n    public bool Contains(T item) { }\n    public bool TryAdd(T item) { }\n    public bool TryRemove(T item) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ConfigurationFactory Class in C#\nDESCRIPTION: This snippet defines the ConfigurationFactory class with static methods for creating and parsing configuration objects from various sources, including objects, resources, and HOCON strings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_73\n\nLANGUAGE: C#\nCODE:\n```\npublic class ConfigurationFactory\n{\n    public ConfigurationFactory() { }\n    public static Akka.Configuration.Config Empty { get; }\n    public static Akka.Configuration.Config Default() { }\n    public static Akka.Configuration.Config FromObject(object source) { }\n    public static Akka.Configuration.Config FromResource(string resourceName, object instanceInAssembly) { }\n    public static Akka.Configuration.Config FromResource<TAssembly>(string resourceName) { }\n    public static Akka.Configuration.Config FromResource(string resourceName, System.Reflection.Assembly assembly) { }\n    public static Akka.Configuration.Config Load() { }\n    public static Akka.Configuration.Config ParseString(string hocon, System.Func<string, Akka.Configuration.Hocon.HoconRoot> includeCallback) { }\n    public static Akka.Configuration.Config ParseString(string hocon) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Deployer System with Remote Actor Deployment in C#\nDESCRIPTION: Sets up a deployer system that creates actors both locally and remotely on the target system. Includes a HelloActor that regularly sends messages to the remotely deployed EchoActors and processes their responses.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/remoting/deployment.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nclass Program\n{\n    class SayHello { }\n\n    class HelloActor : ReceiveActor\n    {\n        private IActorRef _remoteActor;\n        private int _helloCounter;\n        private ICancelable _helloTask;\n\n        public HelloActor(IActorRef remoteActor)\n        {\n            _remoteActor = remoteActor;\n            Receive<Hello>(hello =>\n            {\n                Console.WriteLine(\"Received {1} from {0}\", Sender, hello.Message);\n            });\n\n            Receive<SayHello>(sayHello =>\n            {\n                _remoteActor.Tell(new Hello(\"hello\"+_helloCounter++));\n            });\n        }\n\n        protected override void PreStart()\n        {\n            _helloTask = Context.System.Scheduler.ScheduleTellRepeatedlyCancelable(TimeSpan.FromSeconds(1),\n                TimeSpan.FromSeconds(1), Context.Self, new SayHello(), ActorRefs.NoSender);\n        }\n\n        protected override void PostStop()\n        {\n            _helloTask.Cancel();\n        }\n    }\n\n    static void Main(string[] args)\n    {\n        using (var system = ActorSystem.Create(\"Deployer\", ConfigurationFactory.ParseString(@\"\n            akka {  \n                actor{\n                    provider = remote\n                    deployment {\n                        /remoteecho {\n                            remote = \"\"akka.tcp://DeployTarget@localhost:8090\"\"\n                        }\n                    }\n                }\n                remote {\n                    dot-netty.tcp {\n                        port = 0\n                        hostname = localhost\n                    }\n                }\n            }\")));\n        {\n            var remoteAddress = Address.Parse(\"akka.tcp://DeployTarget@localhost:8090\");\n            //deploy remotely via config\n            var remoteEcho1 = system.ActorOf(Props.Create(() => new EchoActor()), \"remoteecho\");\n \n            //deploy remotely via code\n            var remoteEcho2 =\n                system.ActorOf(\n                    Props.Create(() => new EchoActor())\n                        .WithDeploy(Deploy.None.WithScope(new RemoteScope(remoteAddress))), \"coderemoteecho\"); \n                        \n\n            system.ActorOf(Props.Create(() => new HelloActor(remoteEcho1)));\n            system.ActorOf(Props.Create(() => new HelloActor(remoteEcho2)));\n\n            Console.ReadKey();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing ActorSystem and ActorMaterializer for Akka.NET Streams\nDESCRIPTION: Sets up the basic environment for Akka.NET Streams by creating an ActorSystem and ActorMaterializer. These are required for materializing and running streams.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/reactivetweets.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing (var sys = ActorSystem.Create(\"Reactive-Tweets\"))\n{\n    using (var mat = sys.Materializer())\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: MemberStatus Enum Definition\nDESCRIPTION: This snippet defines an enum `MemberStatus` representing the possible states of a member within an Akka cluster. The possible values are Joining, Up, Leaving, Exiting, Down, Removed, and WeaklyUp.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum MemberStatus\n{\n    Joining = 0,\n    Up = 1,\n    Leaving = 2,\n    Exiting = 3,\n    Down = 4,\n    Removed = 5,\n    WeaklyUp = 6,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Adaptive Load Balancing Group in Akka.Cluster\nDESCRIPTION: This snippet defines an AdaptiveLoadBalancingGroup class that extends Akka.Routing.Group and is responsible for creating a router that uses metrics for load balancing decisions. It includes methods to create a router, get paths, and define routing logic. There are dependencies on Akka.Cluster.Metrics and Akka.Routing for the routing logic.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.DotNet.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class AdaptiveLoadBalancingGroup : Akka.Routing.Group\n{\n    public AdaptiveLoadBalancingGroup(Akka.Cluster.Metrics.IMetricsSelector metricsSelector = null, System.Collections.Generic.IEnumerable<string> paths = null, string routerDispatcher = null) { }\n    public AdaptiveLoadBalancingGroup(Akka.Configuration.Config config) { }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }\n    public override Akka.Actor.Props RoutingLogicController(Akka.Routing.RoutingLogic routingLogic) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Cluster.Metrics.AdaptiveLoadBalancingGroup WithDispatcher(string dispatcherId) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ConsistentHash<T> Class in C#\nDESCRIPTION: Defines a generic ConsistentHash<T> class with methods for adding, removing, and retrieving nodes. It includes operator overloads and a nested ConsistentHashingGroupSurrogate<T> class.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_170\n\nLANGUAGE: C#\nCODE:\n```\npublic class ConsistentHash<T>\n{\n    public ConsistentHash(System.Collections.Generic.SortedDictionary<int, T> nodes, int virtualNodesFactor) { }\n    public bool IsEmpty { get; }\n    public Akka.Routing.ConsistentHash<T> Add(T node) { }\n    public T NodeFor(byte[] key) { }\n    public T NodeFor(string key) { }\n    public Akka.Routing.ConsistentHash<T> Remove(T node) { }\n    public static Akka.Routing.ConsistentHash<T> +(Akka.Routing.ConsistentHash<T> hash, T node) { }\n    public static Akka.Routing.ConsistentHash<T> -(Akka.Routing.ConsistentHash<T> hash, T node) { }\n    public class ConsistentHashingGroupSurrogate<T> : Akka.Util.ISurrogate\n    {\n        public ConsistentHashingGroupSurrogate() { }\n        public string[] Paths { get; set; }\n        public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Object Merging in HOCON\nDESCRIPTION: Shows how duplicate keys with object values are merged recursively in HOCON. Fields with the same path are combined, with later declarations overriding earlier ones for non-object values.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/hocon.md#2025-04-16_snippet_0\n\nLANGUAGE: hocon\nCODE:\n```\n{\n    \"foo\" : { \"a\" : 42 },\n    \"foo\" : { \"b\" : 43 }\n}\n```\n\n----------------------------------------\n\nTITLE: Using CallingThreadDispatcher in Akka.NET\nDESCRIPTION: Shows how to configure an actor to use the CallingThreadDispatcher for testing purposes\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/testing-actor-systems.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nSys.ActorOf(Props.Create<MyActor>().WithDispatcher(CallingThreadDispatcher.Id));\n```\n\n----------------------------------------\n\nTITLE: Implementing BoundedMessageQueue Class in C#\nDESCRIPTION: This class implements a bounded message queue with a specified capacity and push timeout. It provides methods for enqueueing and dequeuing messages, as well as cleaning up the queue.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_104\n\nLANGUAGE: C#\nCODE:\n```\npublic class BoundedMessageQueue : Akka.Dispatch.IBoundedMessageQueueSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.MessageQueues.IMessageQueue\n{\n    public BoundedMessageQueue(Akka.Configuration.Config config) { }\n    public BoundedMessageQueue(int boundedCapacity, System.TimeSpan pushTimeOut) { }\n    public int Count { get; }\n    public bool HasMessages { get; }\n    public System.TimeSpan PushTimeOut { get; set; }\n    public void CleanUp(Akka.Actor.IActorRef owner, Akka.Dispatch.MessageQueues.IMessageQueue deadletters) { }\n    public void Enqueue(Akka.Actor.IActorRef receiver, Akka.Actor.Envelope envelope) { }\n    public bool TryDequeue(out Akka.Actor.Envelope envelope) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Journal Table Schemas for SQLite in Akka.Persistence\nDESCRIPTION: SQL schema definition for the Journal tables in a SQLite database for Akka.Persistence. The schema includes tables for storing persistent events with sequence numbers and persistence IDs.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/custom-persistence-provider.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic const string Schema = @\"\n    CREATE TABLE IF NOT EXISTS journal\n    (\n        persistence_id VARCHAR(255) NOT NULL,\n        sequence_nr BIGINT NOT NULL,\n        is_deleted BOOLEAN NOT NULL,\n        manifest VARCHAR(255) NULL,\n        payload BLOB NOT NULL,\n        tags VARCHAR(255) NULL,\n        created_at BIGINT NOT NULL,\n        PRIMARY KEY(persistence_id, sequence_nr)\n    );\n    \n    CREATE TABLE IF NOT EXISTS metadata\n    (\n        persistence_id VARCHAR(255) NOT NULL,\n        sequence_nr BIGINT NOT NULL,\n        PRIMARY KEY(persistence_id, sequence_nr)\n    );\n    \n    CREATE INDEX IF NOT EXISTS journal_sequence_nr_idx ON journal(sequence_nr);\n    CREATE INDEX IF NOT EXISTS journal_created_at_idx ON journal(created_at);\"\n```\n\n----------------------------------------\n\nTITLE: Logging Debug Message in Akka.NET\nDESCRIPTION: This code snippet shows how to log a debug message using the previously initialized logger in an Akka.NET actor. It utilizes the Debug method of the ILoggingAdapter to send a debug level log.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/logging.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n_log.Debug(\"Some message\");\n```\n\n----------------------------------------\n\nTITLE: Creating ForwardActor for Akka.NET Testing\nDESCRIPTION: An actor that forwards all received messages to a specified target actor. This test actor is useful for message routing and forwarding scenarios in Akka.NET tests.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_52\n\nLANGUAGE: C#\nCODE:\n```\npublic class ForwardActor : Akka.Actor.ReceiveActor\n{\n    public ForwardActor(Akka.Actor.IActorRef target) { }\n    public static Akka.Actor.Props Props(Akka.Actor.IActorRef target) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Logging for Unhandled Messages in Akka.NET\nDESCRIPTION: This configuration example demonstrates how to log unhandled messages in an Akka.NET actor system. By enabling debugging for unhandled messages, developers can track messages that the actor does not process.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/logging.md#2025-04-16_snippet_5\n\nLANGUAGE: hocon\nCODE:\n```\nakka {\n    actor.debug.unhandled = on\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Props Class for Actor Creation in Akka.NET\nDESCRIPTION: Defines the Props class, which is used to create and configure actors. It includes methods for specifying actor types, arguments, deployment options, and supervision strategies.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\npublic class Props : Akka.Util.ISurrogated, System.IEquatable<Akka.Actor.Props>\n{\n    public static readonly Akka.Actor.Props None;\n    protected Props() { }\n    protected Props(Akka.Actor.Props copy) { }\n    public Props(System.Type type, object[] args) { }\n    public Props(System.Type type) { }\n    public Props(System.Type type, Akka.Actor.SupervisorStrategy supervisorStrategy, System.Collections.Generic.IEnumerable<object> args) { }\n    public Props(System.Type type, Akka.Actor.SupervisorStrategy supervisorStrategy, params object[] args) { }\n    public Props(Akka.Actor.Deploy deploy, System.Type type, System.Collections.Generic.IEnumerable<object> args) { }\n    public Props(Akka.Actor.Deploy deploy, System.Type type, params object[] args) { }\n    // ... (additional properties and methods)\n}\n```\n\n----------------------------------------\n\nTITLE: Cluster Router Group Configuration in C#\nDESCRIPTION: Implements a cluster router group for distributed routing of actor messages across a cluster with configurable settings\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic ClusterRouterGroup(Akka.Routing.Group local, Akka.Cluster.Routing.ClusterRouterGroupSettings settings) { }\n```\n\n----------------------------------------\n\nTITLE: Sending Message to Sibling Actor Using Relative Path in Akka.NET\nDESCRIPTION: This code demonstrates how to send a message to a sibling actor using a relative path with ActorContext.ActorSelection in Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/concepts/addressing.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nContext.ActorSelection(\"../brother\").Tell(msg);\n```\n\n----------------------------------------\n\nTITLE: Programmatically Configuring Remote Deployment in C#\nDESCRIPTION: Code snippet showing how to configure remote deployment programmatically using Props and Deploy objects. This approach allows for dynamic configuration of remote deployment at runtime.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/remoting/deployment.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nProps.Create(() => new EchoActor()).WithDeploy(Deploy.None.WithScope(new RemoteScope(remoteAddress)))\n```\n\n----------------------------------------\n\nTITLE: Configuring Resizable Router Pool in HOCON\nDESCRIPTION: This snippet demonstrates how to configure a dynamically resizable router pool using HOCON configuration. It sets up a round-robin pool with resizer settings including enabled status, lower bound, and upper bound.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_26\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.deployment {\n    /my-router {\n        router = round-robin-pool\n        resizer {\n            enabled = on\n            lower-bound = 1\n            upper-bound = 10\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Option<T> Struct in C#\nDESCRIPTION: A value type that represents an optional value, similar to Maybe or Optional in other languages. Provides methods for transforming, mapping, and unwrapping optional values with functional programming patterns.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_246\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalStableApiAttribute()]\n[System.Runtime.CompilerServices.IsReadOnlyAttribute()]\npublic struct Option<T>\n{\n    public static readonly Akka.Util.Option<T> None;\n    [System.ObsoleteAttribute(\"Use Option<T>.Create() instead\")]\n    public Option(T value) { }\n    public bool HasValue { get; }\n    public bool IsEmpty { get; }\n    public T Value { get; }\n    public static Akka.Util.Option<T> Create(T value) { }\n    public bool Equals(Akka.Util.Option<T> other) { }\n    public override bool Equals(object obj) { }\n    public Akka.Util.Option<TNew> FlatSelect<TNew>(System.Func<T, Akka.Util.Option<TNew>> mapper) { }\n    public override int GetHashCode() { }\n    public T GetOrElse(T fallbackValue) { }\n    public void OnSuccess(System.Action<T> action) { }\n    public Akka.Util.Option<TNew> Select<TNew>(System.Func<T, TNew> selector) { }\n    public override string ToString() { }\n    public static bool ==(Akka.Util.Option<T> left, Akka.Util.Option<T> right) { }\n    public static Akka.Util.Option<T> op_Implicit(T value) { }\n    public static bool !=(Akka.Util.Option<T> left, Akka.Util.Option<T> right) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Stopped Device Actor - C#\nDESCRIPTION: This snippet checks the behavior of the query actor when a device actor stops responding before providing a temperature reading. It assesses error handling in this scenario.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-4.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[DeviceGroupQuerySpec.cs](../../../../src/core/Akka.Docs.Tutorials/Tutorial4/DeviceGroupQuerySpec.cs?name=query-test-stopped)]\n```\n\n----------------------------------------\n\nTITLE: Implementing Metric Class for Node Metrics in C# for Akka.NET\nDESCRIPTION: This class represents a single metric with its name, value, and optional EWMA. It includes methods for creating, comparing, and manipulating metrics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Net.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Metric : System.IEquatable<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric>\n{\n    public Metric(string name, Akka.Cluster.Metrics.Helpers.AnyNumber value, [System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})] Akka.Util.Option<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA> average) { }\n    [System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})]\n    public Akka.Util.Option<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA> Average { get; }\n    public bool IsSmooth { get; }\n    public string Name { get; }\n    public double SmoothValue { get; }\n    public Akka.Cluster.Metrics.Helpers.AnyNumber Value { get; }\n    public Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric Add(Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric latest) { }\n    [Akka.Annotations.InternalApiAttribute()]\n    public static Akka.Util.Either<long, double> ConvertNumber(Akka.Cluster.Metrics.Helpers.AnyNumber number) { }\n    [return: System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})]\n    public static Akka.Util.Option<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric> Create(string name, Akka.Cluster.Metrics.Helpers.AnyNumber value) { }\n    [return: System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})]\n    public static Akka.Util.Option<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric> Create([System.Runtime.CompilerServices.NullableAttribute(1)] string name, Akka.Cluster.Metrics.Helpers.AnyNumber value, Akka.Util.Option<double> decayFactor) { }\n    [return: System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})]\n    public static Akka.Util.Option<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric> Create(string name, Akka.Util.Try<Akka.Cluster.Metrics.Helpers.AnyNumber> value, [System.Runtime.CompilerServices.NullableAttribute(0)] Akka.Util.Option<double> decayFactor) { }\n    [return: System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})]\n    public static Akka.Util.Option<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA> CreateEWMA(Akka.Cluster.Metrics.Helpers.AnyNumber value, Akka.Util.Option<double> decayFactor) { }\n    [Akka.Annotations.InternalApiAttribute()]\n    public static bool Defined(Akka.Cluster.Metrics.Helpers.AnyNumber value) { }\n    public bool Equals(Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public bool SameAs(Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric that) { }\n    public static Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric +(Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric m1, Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric m2) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Buffer Management with Different Overflow Strategies\nDESCRIPTION: Examples of implementing different buffer overflow strategies including backpressure, dropping elements, and failure handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/buffersandworkingwithrate.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\njobs.buffer(1000, OverflowStrategy.backpressure);\n```\n\nLANGUAGE: csharp\nCODE:\n```\njobs.buffer(1000, OverflowStrategy.dropTail)\n```\n\nLANGUAGE: csharp\nCODE:\n```\njobs.buffer(1000, OverflowStrategy.dropNew)\n```\n\nLANGUAGE: csharp\nCODE:\n```\njobs.buffer(1000, OverflowStrategy.dropHead)\n```\n\nLANGUAGE: csharp\nCODE:\n```\njobs.buffer(1000, OverflowStrategy.dropBuffer)\n```\n\nLANGUAGE: csharp\nCODE:\n```\njobs.buffer(1000, OverflowStrategy.fail)\n```\n\n----------------------------------------\n\nTITLE: Actor Inbox Implementation in C#\nDESCRIPTION: Implements the Inbox class which provides a way to send and receive messages to/from actors outside the actor system. Includes methods for receiving messages synchronously and asynchronously with timeout capabilities.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\npublic class Inbox : Akka.Actor.ICanWatch, Akka.Actor.IInboxable, System.IDisposable\n{\n    public Akka.Actor.IActorRef Receiver { get; }\n    public static Akka.Actor.Inbox Create(Akka.Actor.ActorSystem system) { }\n    public void Dispose() { }\n    protected virtual void Dispose(bool disposing) { }\n    public object Receive() { }\n    public object Receive(System.TimeSpan timeout) { }\n    public System.Threading.Tasks.Task<object> ReceiveAsync() { }\n    public System.Threading.Tasks.Task<object> ReceiveAsync(System.TimeSpan timeout) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cluster Singleton with Billing Role\nDESCRIPTION: HOCON configuration for deploying Cluster Singleton on nodes with the 'billing' role, ensuring only one instance runs across the cluster to prevent duplicate billing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/member-roles.md#2025-04-16_snippet_8\n\nLANGUAGE: hocon\nCODE:\n```\nakka\n{\n  cluster\n  {\n    roles = [\"billing\"]\n    singleton \n    {\n      role = \"billing\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PNCounter Class for Akka.NET\nDESCRIPTION: Implementation of a Positive-Negative Counter (PNCounter) that supports distributed increment and decrement operations. Includes methods for merging counters across cluster nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class PNCounter : Akka.DistributedData.IDeltaReplicatedData, Akka.DistributedData.IDeltaReplicatedData<Akka.DistributedData.PNCounter, Akka.DistributedData.PNCounter>, Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IRemovedNodePruning<Akka.DistributedData.PNCounter>, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.PNCounter>, Akka.DistributedData.IReplicatedDelta, System.IEquatable<Akka.DistributedData.PNCounter>\n```\n\n----------------------------------------\n\nTITLE: Implementing BackoffSupervisorBase Abstract Class in Akka.NET\nDESCRIPTION: Base class for backoff supervisor implementations. Provides common properties and methods for managing child actors with backoff patterns on failures or stops.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_193\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class BackoffSupervisorBase : Akka.Actor.ActorBase\n{\n    protected Akka.Actor.IActorRef Child { get; set; }\n    protected string ChildName { get; }\n    protected Akka.Actor.Props ChildProps { get; }\n    protected System.Func<object, bool> FinalStopMessage { get; }\n    protected bool FinalStopMessageReceived { get; set; }\n    protected object ReplyWhileStopped { get; }\n    protected Akka.Pattern.IBackoffReset Reset { get; }\n    protected int RestartCountN { get; set; }\n    protected bool HandleBackoff(object message) { }\n    protected override void PreStart() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing ByteString Lines with Framing in C#\nDESCRIPTION: Shows how to parse lines from a ByteString stream using the Framing helper to handle delimited messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/cookbook.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar rawData = Source.Empty<ByteString>();\nvar linesStream = rawData\n    .Via(Framing.Delimiter(delimiter: ByteString.FromString(\"\\r\\n\"), maximumFrameLength: 10, allowTruncation: true))\n    .Select(b => b.DecodeString());\n```\n\n----------------------------------------\n\nTITLE: Testing Streams with TestSource.Probe in C#\nDESCRIPTION: This example shows how to use TestSource.Probe from Akka.Streams.Testkit to test a stream, allowing assertions on demand and control over stream completion or error conditions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/testingstreams.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar sinkUnderTest = Sink.Cancelled<int>();\n\nthis.SourceProbe<int>()\n    .ToMaterialized(sinkUnderTest, Keep.Left)\n    .Run(materializer)\n    .ExpectCancellation();\n```\n\n----------------------------------------\n\nTITLE: Implementing ScatterGatherFirstCompletedGroup Class in C#\nDESCRIPTION: Definition of ScatterGatherFirstCompletedGroup which routes messages to all routees and returns the first response received. It extends the Group class to create a group router that sends requests to a predefined set of actor paths.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_197\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ScatterGatherFirstCompletedGroup : Akka.Routing.Group\n{\n    public ScatterGatherFirstCompletedGroup(Akka.Configuration.Config config) { }\n    public ScatterGatherFirstCompletedGroup(System.TimeSpan within, params string[] paths) { }\n    public ScatterGatherFirstCompletedGroup(System.Collections.Generic.IEnumerable<string> paths, System.TimeSpan within) { }\n    public ScatterGatherFirstCompletedGroup(System.Collections.Generic.IEnumerable<string> paths, System.TimeSpan within, string routerDispatcher) { }\n    public System.TimeSpan Within { get; }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Routing.ScatterGatherFirstCompletedGroup WithDispatcher(string dispatcher) { }\n    public class ScatterGatherFirstCompletedGroupSurrogate : Akka.Util.ISurrogate\n    {\n        public ScatterGatherFirstCompletedGroupSurrogate() { }\n        public System.Collections.Generic.IEnumerable<string> Paths { get; set; }\n        public string RouterDispatcher { get; set; }\n        public System.TimeSpan Within { get; set; }\n        public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LoggingAdapterBase Abstract Class in C#\nDESCRIPTION: Base implementation of ILoggingAdapter that provides common functionality for logging. It handles log level checks and formatting while delegating the actual notification to derived classes through the abstract NotifyLog method.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_132\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class LoggingAdapterBase : Akka.Event.ILoggingAdapter\n{\n    protected LoggingAdapterBase(Akka.Event.ILogMessageFormatter logMessageFormatter) { }\n    public Akka.Event.ILogMessageFormatter Formatter { get; }\n    public abstract bool IsDebugEnabled { get; }\n    public abstract bool IsErrorEnabled { get; }\n    public abstract bool IsInfoEnabled { get; }\n    public abstract bool IsWarningEnabled { get; }\n    public bool IsEnabled(Akka.Event.LogLevel logLevel) { }\n    public void Log(Akka.Event.LogLevel logLevel, System.Exception cause, Akka.Event.LogMessage message) { }\n    public void Log(Akka.Event.LogLevel logLevel, System.Exception cause, string format) { }\n    protected abstract void NotifyLog(Akka.Event.LogLevel logLevel, object message, System.Exception cause = null);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Actor with Computation Expression\nDESCRIPTION: Creates an actor using F#'s computation expression with a self-invoking recursive function pattern. This functional approach defines actor behavior that handles incoming messages and maintains the actor lifecycle.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.FSharp/README.md#2025-04-16_snippet_1\n\nLANGUAGE: F#\nCODE:\n```\nlet aref =\n    spawn system \"my-actor\"\n        (fun mailbox ->\n            let rec loop() = actor {\n                let! message = mailbox.Receive()\n                // handle an incoming message\n                return! loop()\n            }\n            loop())\n```\n\n----------------------------------------\n\nTITLE: Implementing TestKitBase Abstract Class in C#\nDESCRIPTION: Base class for test kit functionality providing actor creation, assertion handling, and test environment management. Implements IActorRefFactory interface.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class TestKitBase : Akka.Actor.IActorRefFactory\n{\n    protected TestKitBase(Akka.TestKit.ITestKitAssertions assertions, Akka.Actor.ActorSystem system = null, string testActorName = null) { }\n    protected TestKitBase(Akka.TestKit.ITestKitAssertions assertions, Akka.Actor.Setup.ActorSystemSetup setup, string actorSystemName = null, string testActorName = null) { }\n    protected TestKitBase(Akka.TestKit.ITestKitAssertions assertions, Akka.Configuration.Config config, string actorSystemName = null, string testActorName = null) { }\n    protected TestKitBase(Akka.TestKit.ITestKitAssertions assertions, Akka.Actor.ActorSystem system, Akka.Actor.Setup.ActorSystemSetup config, string actorSystemName, string testActorName) { }\n    // Properties and methods implementation...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SQL Transaction Isolation Level in Akka Persistence (HOCON)\nDESCRIPTION: These HOCON settings configure the transaction isolation level for read and write operations within Akka Persistence's journal and snapshot store plugins. The settings allow fine-grained control over transaction isolation, which is useful for managing concurrency and data consistency in SQL-based persistence.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/RELEASE_NOTES.md#2025-04-16_snippet_4\n\nLANGUAGE: hocon\nCODE:\n```\n\"akka.persistence.journal.{plugin-name}.read-isolation-level\"\n\n```\n\nLANGUAGE: hocon\nCODE:\n```\n\"akka.persistence.journal.{plugin-name}.write-isolation-level\"\n\n```\n\nLANGUAGE: hocon\nCODE:\n```\n\"akka.persistence.snapshot-store.{plugin-name}.read-isolation-level\"\n\n```\n\nLANGUAGE: hocon\nCODE:\n```\n\"akka.persistence.snapshot-store.{plugin-name}.write-isolation-level\"\n\n```\n\n----------------------------------------\n\nTITLE: Defining Snapshot Store Interceptor Interface in C#\nDESCRIPTION: Defines the interface for a snapshot store interceptor used in the TestSnapshotStore. The interceptor allows customization of snapshot store behavior during testing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistence-testing.md#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface ISnapshotStoreInterceptor\n{\n    Task InterceptAsync(string persistenceId, SnapshotSelectionCriteria criteria);\n}\n```\n\n----------------------------------------\n\nTITLE: Application Code Child Actor Creation\nDESCRIPTION: Shows how to create a child actor in application code using a maker function\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/testing-actor-systems.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nFunc<IUntypedActorContext, IActorRef> maker = (ctx) => ctx.ActorOf(Props.Create<Child>())\nvar parent = Sys.ActorOf(Props.Create<GenericDependentParent>(maker));\n```\n\n----------------------------------------\n\nTITLE: Configuring Akka.Cluster Failure Detector in HOCON\nDESCRIPTION: This HOCON configuration snippet defines the settings for Akka.Cluster's failure detector, including heartbeat intervals, threshold values, and monitoring parameters. It's crucial for controlling how the cluster detects and responds to node failures.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/deployment/akkacluster-troubleshooting.md#2025-04-16_snippet_0\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster.failure-detector {\n\n  # FQCN of the failure detector implementation.\n  # It must implement akka.remote.FailureDetector and have\n  # a public constructor with a com.typesafe.config.Config and\n  # akka.actor.EventStream parameter.\n  implementation-class = \"Akka.Remote.PhiAccrualFailureDetector, Akka.Remote\"\n\n  # How often keep-alive heartbeat messages should be sent to each connection.\n  heartbeat-interval = 1 s\n\n  # Defines the failure detector threshold.\n  # A low threshold is prone to generate many wrong suspicions but ensures\n  # a quick detection in the event of a real crash. Conversely, a high\n  # threshold generates fewer mistakes but needs more time to detect\n  # actual crashes.\n  threshold = 8.0\n\n  # Number of the samples of inter-heartbeat arrival times to adaptively\n  # calculate the failure timeout for connections.\n  max-sample-size = 1000\n\n  # Minimum standard deviation to use for the normal distribution in\n  # AccrualFailureDetector. Too low standard deviation might result in\n  # too much sensitivity for sudden, but normal, deviations in heartbeat\n  # inter arrival times.\n  min-std-deviation = 100 ms\n\n  # Number of potentially lost/delayed heartbeats that will be\n  # accepted before considering it to be an anomaly.\n  # This margin is important to be able to survive sudden, occasional,\n  # pauses in heartbeat arrivals, due to for example garbage collect or\n  # network drop.\n  acceptable-heartbeat-pause = 3 s\n\n  # Number of member nodes that each member will send heartbeat messages to,\n  # i.e. each node will be monitored by this number of other nodes.\n  monitored-by-nr-of-members = 9\n\n  # After the heartbeat request has been sent the first failure detection\n  # will start after this period, even though no heartbeat mesage has\n  # been received.\n  expected-response-after = 1 s\n\n}\n```\n\n----------------------------------------\n\nTITLE: Actor Routing Classes in C#\nDESCRIPTION: Defines routing mechanisms for Akka.NET actors including ActorRefRoutee and ActorSelectionRoutee. Implements message routing and actor selection functionality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_166\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ActorRefRoutee : Akka.Routing.Routee\n{\n    public ActorRefRoutee(Akka.Actor.IActorRef actor) { }\n    public Akka.Actor.IActorRef Actor { get; }\n    public override System.Threading.Tasks.Task<object> Ask(object message, System.Nullable<System.TimeSpan> timeout) { }\n    public override void Send(object message, Akka.Actor.IActorRef sender) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Materializing Akka.NET Stream with Integer Counting in C#\nDESCRIPTION: This snippet shows how to set up an Akka.NET stream to count tweets as they pass through the flow. It uses `Flow.Create` to convert tweets into integer 1 values and `Sink.Aggregate` to sum these integers, materializing the stream to obtain the total count. The use of `Keep.Right` ensures only the materialized value of the rightmost stage is kept. Dependencies: Akka.NET library. Inputs: Tweet stream. Output: Total count of tweets.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/reactivetweets.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar count = Flow.Create<ITweet>().Select(_ => 1);\n\nvar sumSink = Sink.Aggregate<int, int>(0, (agg, i) => agg + i);\n\nvar counterGraph = tweetSource.Via(count).ToMaterialized(sumSink, Keep.Right);\n\nvar sum = counterGraph.Run(mat).Result;\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterRouterPoolSettings Class in C#\nDESCRIPTION: Defines settings for ClusterRouterPool, including total instances, max instances per node, and local routee allowance. This class is used to configure the behavior of a ClusterRouterPool.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Core.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterRouterPoolSettings : Akka.Cluster.Routing.ClusterRouterSettingsBase\n{\n    public ClusterRouterPoolSettings(int totalInstances, int maxInstancesPerNode, bool allowLocalRoutees, string useRole = null) { }\n    public int MaxInstancesPerNode { get; }\n    public override bool Equals(object obj) { }\n    public static Akka.Cluster.Routing.ClusterRouterPoolSettings FromConfig(Akka.Configuration.Config config) { }\n    public override int GetHashCode() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving Graph Deadlock with MergePreferred - Akka.Net\nDESCRIPTION: This code snippet resolves a potential deadlock in an Akka.Net graph by replacing a Merge with a MergePreferred. MergePreferred ensures that feedback elements are processed first, allowing continuous processing even with feedback loops.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithgraphs.md#2025-04-16_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\n// WARNING! The graph below stops consuming from \"source\" after a few steps\nRunnableGraph.FromGraph(GraphDsl.Create(b =>\n{\n    var merge = b.Add(new MergePreferred<int>(1));\n    var broadcast = b.Add(new Broadcast<int>(2));\n    var print = Flow.Create<int>().Select(s =>\n    {\n        Console.WriteLine(s);\n        return s;\n    });\n\n    var sink = Sink.Ignore<int>().MapMaterializedValue(_ => NotUsed.Instance);\n    b.From(source).Via(merge).Via(print).Via(broadcast).To(sink);\n    b.To(merge.Preferred).From(broadcast);\n\n    return ClosedShape.Instance;\n}));\n```\n\n----------------------------------------\n\nTITLE: Cluster Management Class Implementation in C#\nDESCRIPTION: Defines the Cluster class with methods for joining, leaving, and managing distributed actor system cluster operations\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.DotNet.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Cluster : Akka.Actor.IExtension\n{\n    public void Join(Akka.Actor.Address address) { }\n    public void Leave(Akka.Actor.Address address) { }\n    public static Akka.Cluster.Cluster Get(Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Stopping FSM with Result State in C#\nDESCRIPTION: Shows how to stop an FSM by specifying a result state with reason and state data.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/finite-state-machine.md#2025-04-16_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nStop(reason, stateData);\n```\n\n----------------------------------------\n\nTITLE: Implementing ScatterGatherFirstCompletedPool Class in C#\nDESCRIPTION: Definition of ScatterGatherFirstCompletedPool which creates and manages a pool of routees that implement the scatter-gather pattern. It extends the Pool class to dynamically create actor instances under the router's supervision.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_198\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ScatterGatherFirstCompletedPool : Akka.Routing.Pool\n{\n    public ScatterGatherFirstCompletedPool(Akka.Configuration.Config config) { }\n    public ScatterGatherFirstCompletedPool(int nrOfInstances) { }\n    public ScatterGatherFirstCompletedPool(int nrOfInstances, System.TimeSpan within) { }\n    public ScatterGatherFirstCompletedPool(int nrOfInstances, Akka.Routing.Resizer resizer, System.TimeSpan within, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False) { }\n    public System.TimeSpan Within { get; }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Routing.ScatterGatherFirstCompletedPool WithDispatcher(string dispatcher) { }\n    public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n    public Akka.Routing.ScatterGatherFirstCompletedPool WithResizer(Akka.Routing.Resizer resizer) { }\n    public Akka.Routing.ScatterGatherFirstCompletedPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }\n    public class ScatterGatherFirstCompletedPoolSurrogate : Akka.Util.ISurrogate\n    {\n        public ScatterGatherFirstCompletedPoolSurrogate() { }\n        public int NrOfInstances { get; set; }\n        public Akka.Routing.Resizer Resizer { get; set; }\n        public string RouterDispatcher { get; set; }\n        public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }\n        public bool UsePoolDispatcher { get; set; }\n        public System.TimeSpan Within { get; set; }\n        public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AtomicCounterLong Class\nDESCRIPTION: An atomic counter implementation for 64-bit integers that provides thread-safe operations for incrementing, decrementing and other operations. Useful for high-volume counters or when the value might exceed integer range.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_226\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.Util.Internal\n{\n    public class AtomicCounterLong : Akka.Util.Internal.IAtomicCounter<long>\n    {\n        public AtomicCounterLong(long value) { }\n        public AtomicCounterLong() { }\n        public long Current { get; }\n        public long AddAndGet(long amount) { }\n        public bool CompareAndSet(long expected, long newValue) { }\n        public long DecrementAndGet() { }\n        public long GetAndAdd(long amount) { }\n        public long GetAndIncrement() { }\n        public long GetAndSet(long value) { }\n        public long IncrementAndGet() { }\n        public long Next() { }\n        public void Reset() { }\n        public override string ToString() { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Message Expectation Methods in Akka.NET TestKit\nDESCRIPTION: Collection of methods for expecting and verifying messages in actor tests. Includes type-safe message expectations with custom predicates and assertions, supporting both individual and multiple message verification.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic T ExpectMsg<T>(System.Nullable<System.TimeSpan> duration = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Collections.Generic.IReadOnlyCollection<T> ExpectMsgAllOf<T>(params T[] messages) { }\npublic System.Threading.Tasks.ValueTask<T> ExpectMsgAsync<T>(T message, System.Nullable<System.TimeSpan> timeout = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Defining IJournalPlugin Interface\nDESCRIPTION: This snippet defines the `IJournalPlugin` interface, representing a plugin for interacting with a persistence journal in Akka.Persistence. It includes properties for accessing the default configuration and the journal path, enabling customization of the journal's behavior and storage location.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\n\"public interface IJournalPlugin\n    {\n        Akka.Configuration.Config DefaultConfig { get; }\n        string JournalPath { get; }\n    }\"\n```\n\n----------------------------------------\n\nTITLE: Per-Role Minimum Size Configuration\nDESCRIPTION: Configuration example demonstrating how to set minimum node counts for specific cluster roles using HOCON format.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-configuration.md#2025-04-16_snippet_3\n\nLANGUAGE: xml\nCODE:\n```\nakka {\n   actor.provider = cluster\n    remote {\n        dot-netty.tcp {\n            port = 8081\n            hostname = localhost\n        }\n    }\n    cluster {\n       seed-nodes = [\"akka.tcp://ClusterSystem@localhost:8081\"]\n       roles = [\"crawlerV1\", \"crawlerV2\"]\n       role.[\"crawlerV1\"].min-nr-of-members = 3\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ConsistentHashing Router with Hash Mapper\nDESCRIPTION: Example showing how to configure a ConsistentHashingPool with a custom hash mapping delegate using WithHashMapper method.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\nnew ConsistentHashingPool(5).WithHashMapping(o =>\n{\n    if (o is IHasCustomKey)\n        return ((IHasCustomKey)o).Key;\n\n    return null;\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing SupervisorStrategy Abstract Class in C#\nDESCRIPTION: Defines the abstract SupervisorStrategy class with methods for handling actor failures and child termination. It includes abstract and virtual methods for customization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class SupervisorStrategy : Akka.Util.ISurrogated\n{\n    public static Akka.Actor.IDecider DefaultDecider;\n    public static readonly Akka.Actor.SupervisorStrategy DefaultStrategy;\n    public static readonly Akka.Actor.OneForOneStrategy StoppingStrategy;\n    protected SupervisorStrategy() { }\n    public abstract Akka.Actor.IDecider Decider { get; }\n    protected bool LoggingEnabled { get; set; }\n    protected abstract Akka.Actor.Directive Handle(Akka.Actor.IActorRef child, System.Exception exception);\n    public abstract void HandleChildTerminated(Akka.Actor.IActorContext actorContext, Akka.Actor.IActorRef child, System.Collections.Generic.IEnumerable<Akka.Actor.IInternalActorRef> children);\n    // ... (other methods)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Tagged Event Adapter in C#\nDESCRIPTION: Example of an event adapter that wraps events with tags using ImmutableHashSet for color-based tagging. Implements IWriteEventAdapter interface to add tags to string events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistence-query.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyTaggingEventAdapter : IWriteEventAdapter\n{\n    private ImmutableHashSet<string> colors = ImmutableHashSet.Create(\"green\", \"black\", \"blue\");\n\n    public string Manifest(object evt)\n    {\n        return string.Empty;\n    }\n\n    public object ToJournal(object evt)\n    {\n        var str = evt as string;\n        if (str != null)\n        {\n            var tags = colors.Aggregate(\n                ImmutableHashSet<string>.Empty,\n                (acc, c) => str.Equals(c) ? acc.Add(c): acc);\n            if (tags.IsEmpty)\n                return evt;\n            else\n                return new Tagged(evt, tags);\n        }\n        else\n        {\n            return evt;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Router Class in C#\nDESCRIPTION: Definition of the Router class which handles message routing using a specified routing logic. It provides methods to add and remove routees, route messages, and manage the router's configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_193\n\nLANGUAGE: C#\nCODE:\n```\npublic class Router\n{\n    [Akka.Annotations.InternalApiAttribute()]\n    public Router(Akka.Routing.RoutingLogic logic, Akka.Actor.IActorRef routee, params Akka.Actor.IActorRef[] routees) { }\n    public Router(Akka.Routing.RoutingLogic logic, params Akka.Routing.Routee[] routees) { }\n    public System.Collections.Generic.IEnumerable<Akka.Routing.Routee> Routees { get; }\n    public Akka.Routing.RoutingLogic RoutingLogic { get; }\n    public virtual Akka.Routing.Router AddRoutee(Akka.Routing.Routee routee) { }\n    public Akka.Routing.Router AddRoutee(Akka.Actor.IActorRef routee) { }\n    public Akka.Routing.Router AddRoutee(Akka.Actor.ActorSelection routee) { }\n    public virtual Akka.Routing.Router RemoveRoutee(Akka.Routing.Routee routee) { }\n    public Akka.Routing.Router RemoveRoutee(Akka.Actor.IActorRef routee) { }\n    public Akka.Routing.Router RemoveRoutee(Akka.Actor.ActorSelection routee) { }\n    public virtual void Route(object message, Akka.Actor.IActorRef sender) { }\n    protected virtual void Send(Akka.Routing.Routee routee, object message, Akka.Actor.IActorRef sender) { }\n    protected object UnWrap(object message) { }\n    public virtual Akka.Routing.Router WithRoutees(params Akka.Routing.Routee[] routees) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Logging Interfaces and Filters in Akka.NET\nDESCRIPTION: Defines interfaces and classes for Akka.NET's logging system, including message formatting, log filtering, and adapter interfaces. These components enable flexible and configurable logging throughout the actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_139\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ILogMessageFormatter\n{\n    string Format(string format, params object[] args);\n    string Format(string format, System.Collections.Generic.IEnumerable<object> args);\n}\n\npublic interface ILoggingAdapter\n{\n    Akka.Event.ILogMessageFormatter Formatter { get; }\n    bool IsDebugEnabled { get; }\n    bool IsErrorEnabled { get; }\n    bool IsInfoEnabled { get; }\n    bool IsWarningEnabled { get; }\n    bool IsEnabled(Akka.Event.LogLevel logLevel);\n    void Log(Akka.Event.LogLevel logLevel, System.Exception cause, string format);\n    void Log(Akka.Event.LogLevel logLevel, System.Exception cause, Akka.Event.LogMessage message);\n}\n\npublic abstract class LogFilterBase : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression\n{\n    protected LogFilterBase() { }\n    public abstract Akka.Event.LogFilterType FilterType { get; }\n    public abstract Akka.Event.LogFilterDecision ShouldKeepMessage(Akka.Event.LogEvent content, [System.Runtime.CompilerServices.NullableAttribute(2)] string expandedMessage = null);\n}\n\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class ExactMatchLogSourceFilter : Akka.Event.LogFilterBase\n{\n    public ExactMatchLogSourceFilter(string source, System.StringComparison comparison = 5) { }\n    public override Akka.Event.LogFilterType FilterType { get; }\n    public override Akka.Event.LogFilterDecision ShouldKeepMessage(Akka.Event.LogEvent content, [System.Runtime.CompilerServices.NullableAttribute(2)] string expandedMessage = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DefaultResizer in C#\nDESCRIPTION: Resizer implementation for dynamically adjusting the number of routees based on pressure and capacity. Configurable with various thresholds and rates.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_202\n\nLANGUAGE: C#\nCODE:\n```\npublic class DefaultResizer : Akka.Routing.Resizer, System.IEquatable<Akka.Routing.DefaultResizer>\n{\n    public DefaultResizer(int lower, int upper, int pressureThreshold = 1, double rampupRate = 0.2, double backoffThreshold = 0.3, double backoffRate = 0.1, int messagesPerResize = 10) { }\n    public double BackoffRate { get; }\n    public double BackoffThreshold { get; }\n    public int LowerBound { get; set; }\n    public int MessagesPerResize { get; }\n    public int PressureThreshold { get; }\n    public double RampupRate { get; }\n    public int UpperBound { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Default HOCON Configuration for Akka.Persistence\nDESCRIPTION: The default configuration settings for the Akka.Persistence package in HOCON format. These settings define the base behavior and parameters for persistence operations in Akka.NET applications.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/modules/akka.persistence.md#2025-04-16_snippet_0\n\nLANGUAGE: hocon\nCODE:\n```\n[!code[Akka.Persistence.dll HOCON Configuration](../../../../src/core/Akka.Persistence/persistence.conf)]\n```\n\n----------------------------------------\n\nTITLE: Akka.NET Child Actor Container Interface\nDESCRIPTION: Interface defining methods and properties for managing child actors within the actor system, including adding, removing, and tracking child actor states.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_57\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IChildrenContainer\n{\n    System.Collections.Generic.IReadOnlyCollection<Akka.Actor.IInternalActorRef> Children { get; }\n    bool IsNormal { get; }\n    bool IsTerminating { get; }\n    System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> Stats { get; }\n    Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats);\n    bool Contains(Akka.Actor.IActorRef actor);\n    Akka.Actor.Internal.IChildrenContainer Remove(Akka.Actor.IActorRef child);\n    Akka.Actor.Internal.IChildrenContainer Reserve(string name);\n    Akka.Actor.Internal.IChildrenContainer ShallDie(Akka.Actor.IActorRef actor);\n    bool TryGetByName(string name, out Akka.Actor.Internal.IChildStats stats);\n    bool TryGetByRef(Akka.Actor.IActorRef actor, out Akka.Actor.Internal.ChildRestartStats stats);\n    Akka.Actor.Internal.IChildrenContainer Unreserve(string name);\n}\n```\n\n----------------------------------------\n\nTITLE: Using ActorSelection in Akka.NET C#\nDESCRIPTION: Demonstrates how to use Context.ActorSelection to look up actors by their logical paths. This method can be used for both absolute and relative path lookups.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n// will look up this absolute path\nContext.ActorSelection(\"/user/serviceA/actor\");\n\n// will look up sibling beneath same supervisor\nContext.ActorSelection(\"../joe\");\n```\n\n----------------------------------------\n\nTITLE: Implementing ActorTaskScheduler Class in C#\nDESCRIPTION: The ActorTaskScheduler extends TaskScheduler to integrate .NET Tasks with Akka.NET's actor model. It provides methods for running tasks within the actor context and manages task execution within the actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_80\n\nLANGUAGE: C#\nCODE:\n```\npublic class ActorTaskScheduler : System.Threading.Tasks.TaskScheduler\n{\n    public object CurrentMessage { get; }\n    public override int MaximumConcurrencyLevel { get; }\n    protected override System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> GetScheduledTasks() { }\n    protected virtual void OnAfterTaskCompleted() { }\n    protected virtual void OnBeforeTaskStarted() { }\n    protected override void QueueTask(System.Threading.Tasks.Task task) { }\n    public static void RunTask(System.Action action) { }\n    public static void RunTask(System.Func<System.Threading.Tasks.Task> asyncAction) { }\n    protected override bool TryExecuteTaskInline(System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Mailbox Class in C#\nDESCRIPTION: Class that implements the message queue for actors, containing the actual message queue and methods for handling messages. Provides the core functionality for actor message processing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_93\n\nLANGUAGE: C#\nCODE:\n```\npublic class Mailbox : Akka.Dispatch.IRunnable, System.Threading.IThreadPoolWorkItem\n{\n    public Mailbox(Akka.Dispatch.MessageQueues.IMessageQueue messageQueue) { }\n    public Akka.Dispatch.MessageDispatcher Dispatcher { get; }\n    public Akka.Dispatch.MessageQueues.IMessageQueue MessageQueue { get; }\n    public virtual void CleanUp() { }\n    [System.Diagnostics.ConditionalAttribute(\"MAILBOXDEBUG\")]\n    public static void DebugPrint(string message, params object[] args) { }\n    public void Execute() { }\n    public void Run() { }\n    public virtual void SetActor(Akka.Actor.ActorCell actorCell) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Using WindsorDependencyResolver with Akka.NET ActorSystem in C#\nDESCRIPTION: This code snippet demonstrates how to set up CastleWindsor, create an ActorSystem, and use the WindsorDependencyResolver to register and create actors. It also shows how to create a router and send a message to it using the dependency injection setup.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/di-core.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// Setup CastleWindsor\nIWindsorContainer container = new WindsorContainer();\ncontainer.Register(Component.For<IWorkerService>().ImplementedBy<WorkerService>());\ncontainer.Register(Component.For<TypedWorker>().Named(\"TypedWorker\").LifestyleTransient());\n\n// Create the ActorSystem\nusing (var system = ActorSystem.Create(\"MySystem\"))\n{\n    // Create the dependency resolver\n    IDependencyResolver resolver = new WindsorDependencyResolver(container, system);\n\n    // Register the actors with the system\n    system.ActorOf(system.DI().Props<TypedWorker>(), \"Worker1\");\n    system.ActorOf(system.DI().Props<TypedWorker>(), \"Worker2\");\n\n    // Create the router\n    IActorRef router = system.ActorOf(Props.Empty.WithRouter(new ConsistentHashingGroup(config)));\n\n    // Create the message to send\n    TypedActorMessage message = new TypedActorMessage\n    {\n       Id = 1,\n       Name = Guid.NewGuid().ToString()\n    };\n\n    // Send the message to the router\n    router.Tell(message);\n}\n```\n\n----------------------------------------\n\nTITLE: Tracking Drift Between Producer and Consumer using Expand\nDESCRIPTION: This snippet uses `Expand` to track and report a drift between a fast consumer and a slow producer. It keeps state between demand requests and reports the difference between expected and actual elements. The flow reports a drift of zero if the producer is fast enough, or a larger drift otherwise.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/buffersandworkingwithrate.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nvar driftFlow = Flow.Create<int>()\n    .Expand(i => Enumerable.Repeat(0, int.MaxValue).Select(n => new {i, n}).GetEnumerator());\n```\n\n----------------------------------------\n\nTITLE: Implementing PersistentFSM Concrete Class in C#\nDESCRIPTION: Concrete implementation of PersistentFSMBase that requires states to implement the IFsmState interface. Adds event application, recovery handling, and snapshot capabilities.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class PersistentFSM<TState, TData, TEvent> : Akka.Persistence.Fsm.PersistentFSMBase<TState, TData, TEvent>\n    where TState : Akka.Persistence.Fsm.PersistentFSM.IFsmState\n{\n    protected PersistentFSM() { }\n    protected abstract TData ApplyEvent(TEvent domainEvent, TData currentData);\n    protected override void ApplyState(Akka.Persistence.Fsm.PersistentFSM.State<TState, TData, TEvent> nextState) { }\n    protected virtual void OnRecoveryCompleted() { }\n    protected override bool ReceiveRecover(object message) { }\n    public void SaveStateSnapshot() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing REPL Client with Akka Streams TCP\nDESCRIPTION: This snippet demonstrates how to create a Read Evaluate Print Loop (REPL) client over TCP using Akka Streams. It connects to a server and handles the interaction.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithstreamingio.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar connection = Tcp.Get(system).OutgoingConnection(\"127.0.0.1\", 8888);\n\nvar repl = Flow.Create<ByteString>()\n    .Via(Framing.Delimiter(\n        ByteString.FromString(\"\\n\"),\n        maximumFrameLength: 256,\n        allowTruncation: true))\n    .Select(text =>\n    {\n        Console.WriteLine(\"Server: \" + text.DecodeString());\n        Console.Write(\"Client: \");\n        return ByteString.FromString(Console.ReadLine() + \"\\n\");\n    });\n\nvar task = Source.Repeat(ByteString.Empty)\n    .Via(connection)\n    .Join(repl)\n    .Run(materializer);\n\nawait task;\n```\n\n----------------------------------------\n\nTITLE: Implementing Hashed Wheel Timer Scheduler for Akka.NET in C#\nDESCRIPTION: Defines a HashedWheelTimerScheduler class that implements scheduling functionality for Akka.NET using a hashed wheel timer algorithm. It provides methods for scheduling one-time and repeated actions and messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class HashedWheelTimerScheduler : Akka.Actor.SchedulerBase, Akka.Actor.IDateTimeOffsetNowTimeProvider, Akka.Actor.ITimeProvider, System.IDisposable\n{\n    public HashedWheelTimerScheduler(Akka.Configuration.Config scheduler, Akka.Event.ILoggingAdapter log) { }\n    public override System.TimeSpan HighResMonotonicClock { get; }\n    public override System.TimeSpan MonotonicClock { get; }\n    protected override System.DateTimeOffset TimeNow { get; }\n    public void Dispose() { }\n    protected override void InternalScheduleOnce(System.TimeSpan delay, System.Action action, Akka.Actor.ICancelable cancelable) { }\n    protected override void InternalScheduleOnce(System.TimeSpan delay, Akka.Dispatch.IRunnable action, Akka.Actor.ICancelable cancelable) { }\n    protected override void InternalScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action, Akka.Actor.ICancelable cancelable) { }\n    protected override void InternalScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Dispatch.IRunnable action, Akka.Actor.ICancelable cancelable) { }\n    protected override void InternalScheduleTellOnce(System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable) { }\n    protected override void InternalScheduleTellRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Snapshot Asynchronously with Akka.Persistence and C#\nDESCRIPTION: This method asynchronously loads a snapshot based on the given 'persistenceId' and selection criteria. It ensures safe access through the use of a circuit breaker, facilitating reliable retrieval of snapshot data as part of the Akka.Persistence framework, which manages stateful actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/custom-persistence-provider.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nTask<SelectedSnapshot> LoadAsync(string persistenceId, SnapshotSelectionCriteria criteria)\n\n```\n\n----------------------------------------\n\nTITLE: Implementing LogFilterBuilder Class in C#\nDESCRIPTION: A builder class that provides a fluent interface for constructing log filter configurations. It supports adding various filter types for source and message content filtering.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_135\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class LogFilterBuilder\n{\n    public LogFilterBuilder() { }\n    public Akka.Event.LogFilterBuilder Add(Akka.Event.LogFilterBase filter) { }\n    public Akka.Event.LogFilterBuilder AddRange(System.Collections.Generic.IEnumerable<Akka.Event.LogFilterBase> filters) { }\n    public Akka.Event.LogFilterSetup Build() { }\n    public Akka.Event.LogFilterBuilder ExcludeMessageContaining(string messagePart) { }\n    public Akka.Event.LogFilterBuilder ExcludeMessageRegex(System.Text.RegularExpressions.Regex regex) { }\n    public Akka.Event.LogFilterBuilder ExcludeSourceContaining(string sourcePart) { }\n    public Akka.Event.LogFilterBuilder ExcludeSourceEndingWith(string sourceEnd) { }\n    public Akka.Event.LogFilterBuilder ExcludeSourceExactly(string source, System.StringComparison comparison = 5) { }\n    public Akka.Event.LogFilterBuilder ExcludeSourceRegex(System.Text.RegularExpressions.Regex regex) { }\n    public Akka.Event.LogFilterBuilder ExcludeSourceStartingWith(string sourceStart) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Problematic Context.Materializer() Usage in Akka.NET Actor\nDESCRIPTION: This code snippet demonstrates the incorrect pattern that triggers the AK2002 warning, where Context.Materializer() is called directly inside the actor's message handling code, potentially creating multiple materializer instances.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK2002.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Actor;\nusing Akka.Streams;\nusing Akka.Streams.Dsl;\n\npublic sealed class MyActor : ReceiveActor\n{\n    public MyActor()\n    {\n        ReceiveAsync<string>(\n            s => s == \"hello\",\n            async _ =>\n            {\n                await Source.Single(1)\n                    .Select(x => x + 1)\n                    .ToMaterialized(Sink.ForEach<int>(_ => { }), Keep.Right)\n                    .Run(Context.Materializer());\n            });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cluster Routers in Akka.NET C#\nDESCRIPTION: Defined classes for configuring cluster routers using group and pool patterns, including settings for cluster routing and creation of routing logic. Classes such as `ClusterRouterGroup` and `ClusterRouterPool` allow distributed routing, leveraging Akka's powerful clustering capabilities. Key parameters allow local routees, total instances, and max instances per node. Dependencies include Akka.Routing and Akka.Cluster namespaces.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.DotNet.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterRouterGroup : Akka.Routing.Group { public ClusterRouterGroup(Akka.Routing.Group local, Akka.Cluster.Routing.ClusterRouterGroupSettings settings) { } public Akka.Routing.Group Local { get; } public override string RouterDispatcher { get; } public Akka.Cluster.Routing.ClusterRouterGroupSettings Settings { get; } public override bool StopRouterWhenAllRouteesRemoved { get; } public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { } public override Akka.Actor.ActorBase CreateRouterActor() { } public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { } public override bool IsManagementMessage(object message) { } public override Akka.Actor.Props RoutingLogicController(Akka.Routing.RoutingLogic routingLogic) { } public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { } public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { } }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterRouterGroupSettings : Akka.Cluster.Routing.ClusterRouterSettingsBase { public ClusterRouterGroupSettings(int totalInstances, System.Collections.Generic.IEnumerable<string> routeesPaths, bool allowLocalRoutees, string useRole = null) { } public System.Collections.Generic.IEnumerable<string> RouteesPaths { get; } public static Akka.Cluster.Routing.ClusterRouterGroupSettings FromConfig(Akka.Configuration.Config config) { } }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterRouterPool : Akka.Routing.Pool { public ClusterRouterPool(Akka.Routing.Pool local, Akka.Cluster.Routing.ClusterRouterPoolSettings settings) { } public Akka.Routing.Pool Local { get; } public override string RouterDispatcher { get; } public Akka.Cluster.Routing.ClusterRouterPoolSettings Settings { get; } public override bool StopRouterWhenAllRouteesRemoved { get; } public override Akka.Actor.SupervisorStrategy SupervisorStrategy { get; } public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { } public override Akka.Actor.ActorBase CreateRouterActor() { } public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { } public override bool IsManagementMessage(object message) { } public override Akka.Actor.Props RoutingLogicController(Akka.Routing.RoutingLogic routingLogic) { } public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { } public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { } }\n```\n\n----------------------------------------\n\nTITLE: Specifying Snapshot Selection Criteria for Recovery\nDESCRIPTION: Demonstrates how to configure the Recovery property to select specific snapshots using SnapshotSelectionCriteria with sequence number and timestamp constraints.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/snapshots.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic override Recovery Recovery => new Recovery(fromSnapshot: new SnapshotSelectionCriteria(maxSequenceNr: 457L, maxTimeStamp: DateTime.UtcNow));\n```\n\n----------------------------------------\n\nTITLE: Defining RouterConfig Abstract Class in C#\nDESCRIPTION: This snippet defines the RouterConfig abstract class, which provides a base for router configurations with methods for creating routers, verifying configs, and handling management messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_187\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class RouterConfig : Akka.Util.ISurrogated, System.IEquatable<Akka.Routing.RouterConfig>\n{\n    protected RouterConfig() { }\n    protected RouterConfig(string routerDispatcher) { }\n    public virtual string RouterDispatcher { get; }\n    public virtual bool StopRouterWhenAllRouteesRemoved { get; }\n    public abstract Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system);\n    [Akka.Annotations.InternalApiAttribute()]\n    public abstract Akka.Actor.ActorBase CreateRouterActor();\n    public bool Equals(Akka.Routing.RouterConfig other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public virtual bool IsManagementMessage(object message) { }\n    public virtual Akka.Actor.Props RoutingLogicController(Akka.Routing.RoutingLogic routingLogic) { }\n    public abstract Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system);\n    public virtual void VerifyConfig(Akka.Actor.ActorPath path) { }\n    public virtual Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterShardingSettings Class in C#\nDESCRIPTION: This class represents configuration settings for Akka.NET cluster sharding. It includes properties for state store mode, tuning parameters, and methods for creating and modifying settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic readonly Akka.Cluster.Sharding.StateStoreMode StateStoreMode;\npublic readonly Akka.Cluster.Sharding.TuningParameters TuningParameters;\npublic ClusterShardingSettings(string role, bool rememberEntities, string journalPluginId, string snapshotPluginId, System.TimeSpan passivateIdleEntityAfter, Akka.Cluster.Sharding.StateStoreMode stateStoreMode, Akka.Cluster.Sharding.TuningParameters tuningParameters, Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings coordinatorSingletonSettings) { }\n// ... additional constructors and methods\n```\n\n----------------------------------------\n\nTITLE: Implementing Info Extension Methods for ILoggingAdapter in Akka.NET\nDESCRIPTION: Defines extension methods for info-level logging with various generic type parameters. These methods extend ILoggingAdapter to provide strongly-typed logging capabilities with format strings and exception causes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_136\n\nLANGUAGE: C#\nCODE:\n```\npublic static void Info(this Akka.Event.ILoggingAdapter log, string format) { }\npublic static void Info(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format) { }\npublic static void Info<T1>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1) { }\npublic static void Info<T1>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1) { }\npublic static void Info<T1, T2>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2) { }\npublic static void Info<T1, T2>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2) { }\npublic static void Info<T1, T2, T3>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3) { }\npublic static void Info<T1, T2, T3>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3) { }\npublic static void Info<T1, T2, T3, T4>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4) { }\npublic static void Info<T1, T2, T3, T4>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4) { }\npublic static void Info<T1, T2, T3, T4, T5>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) { }\npublic static void Info<T1, T2, T3, T4, T5>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) { }\npublic static void Info<T1, T2, T3, T4, T5, T6>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) { }\npublic static void Info<T1, T2, T3, T4, T5, T6>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) { }\npublic static void Info(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, object[] args) { }\npublic static void Info(this Akka.Event.ILoggingAdapter log, string format, object[] args) { }\n```\n\n----------------------------------------\n\nTITLE: RepointableActorRef Implementation in Akka.NET (C#)\nDESCRIPTION: An actor reference implementation that can change its underlying cell, useful for actor restart scenarios and actor redeployment. Manages actor lifecycle operations and message routing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\npublic class RepointableActorRef : Akka.Actor.ActorRefWithCell, Akka.Actor.IActorRefScope, Akka.Actor.IRepointableRef\n{\n    protected readonly Akka.Dispatch.MessageDispatcher Dispatcher;\n    protected readonly Akka.Actor.Props Props;\n    protected readonly Akka.Actor.IInternalActorRef Supervisor;\n    protected readonly Akka.Actor.Internal.ActorSystemImpl System;\n    protected readonly Akka.Actor.ActorPath _path;\n    public RepointableActorRef(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.Props props, Akka.Dispatch.MessageDispatcher dispatcher, Akka.Dispatch.MailboxType mailboxType, Akka.Actor.IInternalActorRef supervisor, Akka.Actor.ActorPath path) { }\n    public override System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> Children { get; }\n    public override bool IsLocal { get; }\n    public bool IsStarted { get; }\n    public override bool IsTerminated { get; }\n    public Akka.Actor.ICell Lookup { get; }\n    public override Akka.Actor.IInternalActorRef Parent { get; }\n    public override Akka.Actor.ActorPath Path { get; }\n    public override Akka.Actor.IActorRefProvider Provider { get; }\n    public override Akka.Actor.ICell Underlying { get; }\n    public override Akka.Actor.IActorRef GetChild(System.Collections.Generic.IReadOnlyList<string> name) { }\n    public override Akka.Actor.IInternalActorRef GetSingleChild(string name) { }\n    public Akka.Actor.RepointableActorRef Initialize(bool async) { }\n    protected virtual Akka.Actor.ActorCell NewCell() { }\n    public void Point() { }\n    public override void Restart(System.Exception cause) { }\n    public override void Resume(System.Exception causedByFailure = null) { }\n    public override void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message) { }\n    public override void Start() { }\n    public override void Stop() { }\n    public override void Suspend() { }\n    public void SwapUnderlying(Akka.Actor.ICell cell) { }\n    protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }\n}\n```\n\n----------------------------------------\n\nTITLE: PostStop Hook in Akka.NET\nDESCRIPTION: This snippet shows how to override the `PostStop` method to perform cleanup operations when an actor is stopped. The `PostStop` method is invoked after the actor has fully terminated.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_25\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override void PostStop()\n{\n    // clean up resources here ...\n}\n```\n\n----------------------------------------\n\nTITLE: TestKit Settings Configuration in Akka.NET\nDESCRIPTION: Settings class for configuring TestKit behavior. Contains properties for timeouts, logging settings, and time dilation factors used in testing Akka.NET applications.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestKitSettings : Akka.Actor.IExtension\n{\n    public TestKitSettings(Akka.Configuration.Config config) { }\n    public System.TimeSpan DefaultTimeout { get; }\n    public bool LogTestKitCalls { get; }\n    public System.TimeSpan SingleExpectDefault { get; }\n    public System.TimeSpan TestEventFilterLeeway { get; }\n    public System.TimeSpan TestKitStartupTimeout { get; }\n    public double TestTimeFactor { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HashCodeMessageExtractor Abstract Class in C#\nDESCRIPTION: This abstract class provides a base implementation for message extractors used in cluster sharding. It includes methods for extracting entity IDs and shard IDs based on message content.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class HashCodeMessageExtractor : Akka.Cluster.Sharding.IMessageExtractor\n{\n    public readonly int MaxNumberOfShards;\n    protected HashCodeMessageExtractor(int maxNumberOfShards) { }\n    public static Akka.Cluster.Sharding.HashCodeMessageExtractor Create(int maxNumberOfShards, System.Func<object, string> entityIdExtractor, System.Func<object, object> messageExtractor = null) { }\n    // ... additional methods\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LocalActorRefProvider Class in C#\nDESCRIPTION: Defines a LocalActorRefProvider class that manages local actor references and provides methods for creating and resolving actors within the local system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class LocalActorRefProvider : Akka.Actor.IActorRefProvider\n{\n    public LocalActorRefProvider(string systemName, Akka.Actor.Settings settings, Akka.Event.EventStream eventStream) { }\n    public LocalActorRefProvider(string systemName, Akka.Actor.Settings settings, Akka.Event.EventStream eventStream, Akka.Actor.Deployer deployer, System.Func<Akka.Actor.ActorPath, Akka.Actor.IInternalActorRef> deadLettersFactory) { }\n    public Akka.Actor.IActorRef DeadLetters { get; }\n    public Akka.Actor.Address DefaultAddress { get; }\n    public Akka.Actor.Deployer Deployer { get; }\n    public Akka.Event.EventStream EventStream { get; }\n    public Akka.Actor.LocalActorRef Guardian { get; }\n    public Akka.Actor.IActorRef IgnoreRef { get; }\n    public Akka.Event.ILoggingAdapter Log { get; }\n    public Akka.Actor.IInternalActorRef RootGuardian { get; }\n    public Akka.Actor.ActorPath RootPath { get; }\n    public Akka.Serialization.Information SerializationInformation { get; }\n    public Akka.Actor.Settings Settings { get; }\n    public Akka.Actor.LocalActorRef SystemGuardian { get; }\n    public Akka.Actor.IInternalActorRef TempContainer { get; }\n    public System.Threading.Tasks.Task TerminationTask { get; }\n    public Akka.Actor.IInternalActorRef ActorOf(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.Props props, Akka.Actor.IInternalActorRef supervisor, Akka.Actor.ActorPath path, bool systemService, Akka.Actor.Deploy deploy, bool lookupDeploy, bool async) { }\n    public Akka.Actor.FutureActorRef<T> CreateFutureRef<T>(System.Threading.Tasks.TaskCompletionSource<T> tcs) { }\n    public Akka.Actor.Address GetExternalAddressFor(Akka.Actor.Address address) { }\n    public void Init(Akka.Actor.Internal.ActorSystemImpl system) { }\n    public void RegisterExtraName(string name, Akka.Actor.IInternalActorRef actor) { }\n    public void RegisterTempActor(Akka.Actor.IInternalActorRef actorRef, Akka.Actor.ActorPath path) { }\n    public Akka.Actor.IActorRef ResolveActorRef(string path) { }\n    public Akka.Actor.IActorRef ResolveActorRef(Akka.Actor.ActorPath path) { }\n    public Akka.Actor.IActorRef RootGuardianAt(Akka.Actor.Address address) { }\n    public Akka.Actor.ActorPath TempPath() { }\n    public void UnregisterTempActor(Akka.Actor.ActorPath path) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Saving State Snapshots in PersistentFSM\nDESCRIPTION: Example of using SaveStateSnapshot() to persist a snapshot of state data. On recovery, state is initialized from the latest snapshot before remaining events are replayed.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistent-fsm.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nStop().Applying(OrderDiscarded.Instance).AndThen(cart =>\n{\n    reportActor.Tell(ShoppingCardDiscarded.Instance);\n    SaveStateSnapshot();\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring ChannelExecutor in HOCON for Akka.NET Dispatchers\nDESCRIPTION: Example HOCON configuration for enabling the ChannelExecutor as the dispatcher for various components of an Akka.NET ActorSystem. The configuration demonstrates how to apply ChannelExecutor to the default-dispatcher, internal-dispatcher, default-remote-dispatcher, and backoff-remote-dispatcher with appropriate parallelism settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/dispatchers.md#2025-04-16_snippet_9\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.default-dispatcher = {\n    executor = channel-executor\n    fork-join-executor { #channelexecutor will re-use these settings\n      parallelism-min = 2\n      parallelism-factor = 1\n      parallelism-max = 64\n    }\n}\n\nakka.actor.internal-dispatcher = {\n    executor = channel-executor\n    throughput = 5\n    fork-join-executor {\n      parallelism-min = 4\n      parallelism-factor = 1.0\n      parallelism-max = 64\n    }\n}\n\nakka.remote.default-remote-dispatcher {\n    type = Dispatcher\n    executor = channel-executor\n    fork-join-executor {\n      parallelism-min = 2\n      parallelism-factor = 0.5\n      parallelism-max = 16\n    }\n}\n\nakka.remote.backoff-remote-dispatcher {\n  executor = channel-executor\n  fork-join-executor {\n    parallelism-min = 2\n    parallelism-max = 2\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WriteAll Class for Write Consistency in C#\nDESCRIPTION: This class implements the IWriteConsistency interface and represents a write consistency level where all nodes must acknowledge the write operation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_55\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class WriteAll : Akka.DistributedData.IWriteConsistency, System.IEquatable<Akka.DistributedData.WriteAll>\n{\n    public WriteAll(System.TimeSpan timeout) { }\n    public System.TimeSpan Timeout { get; }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.DistributedData.WriteAll other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: AllForOneStrategy Supervisor Implementation\nDESCRIPTION: Implementation of the AllForOneStrategy supervisor strategy for actor fault tolerance. Handles child actor failures and restart policies.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic class AllForOneStrategy : Akka.Actor.SupervisorStrategy, System.IEquatable<Akka.Actor.AllForOneStrategy>\n{\n    public AllForOneStrategy(System.Nullable<int> maxNrOfRetries, System.Nullable<System.TimeSpan> withinTimeRange, System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider) { }\n    public AllForOneStrategy(System.Nullable<int> maxNrOfRetries, System.Nullable<System.TimeSpan> withinTimeRange, Akka.Actor.IDecider decider) { }\n    public AllForOneStrategy(int maxNrOfRetries, int withinTimeMilliseconds, System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider, bool loggingEnabled = True) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dispatchers Management Class in Akka.NET\nDESCRIPTION: Manages all dispatchers in the actor system, providing lookup and registration capabilities. It includes predefined dispatcher IDs and maintains dispatcher configurations. This class is the central registry for all message dispatchers in the system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_85\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Dispatchers\n    {\n        public const string DefaultBlockingDispatcherId = \"akka.actor.default-blocking-io-dispatcher\";\n        public const string DefaultDispatcherId = \"akka.actor.default-dispatcher\";\n        public const string SynchronizedDispatcherId = \"akka.actor.synchronized-dispatcher\";\n        public Dispatchers(Akka.Actor.ActorSystem system, Akka.Dispatch.IDispatcherPrerequisites prerequisites, Akka.Event.ILoggingAdapter logger) { }\n        public Akka.Configuration.Config DefaultDispatcherConfig { get; }\n        public Akka.Dispatch.MessageDispatcher DefaultGlobalDispatcher { get; }\n        public Akka.Dispatch.IDispatcherPrerequisites Prerequisites { get; }\n        [Akka.Annotations.InternalApiAttribute()]\n        public static Akka.Configuration.Config GetConfig(Akka.Configuration.Config config, string id, int depth = 0) { }\n        public bool HasDispatcher(string id) { }\n        public Akka.Dispatch.MessageDispatcher Lookup(string dispatcherName) { }\n        public bool RegisterConfigurator(string id, Akka.Dispatch.MessageDispatcherConfigurator configurator) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Actor Lifecycle Management Interface Methods\nDESCRIPTION: Core methods for managing actor lifecycle including pre-restart, pre-start, and message receiving capabilities with support for generic and async handlers.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_56\n\nLANGUAGE: C#\nCODE:\n```\nvoid DefaultPreRestart(System.Exception reason, object message);\nvoid DefaultPreStart();\nvoid Receive<T>(System.Action<T, Akka.Actor.IActorContext> handler);\nvoid Receive<T>(System.Predicate<T> shouldHandle, System.Action<T, Akka.Actor.IActorContext> handler);\nvoid Receive<T>(System.Action<T, Akka.Actor.IActorContext> handler, System.Predicate<T> shouldHandle);\nvoid ReceiveAny(System.Action<object, Akka.Actor.IActorContext> handler);\nvoid ReceiveAnyAsync(System.Func<object, Akka.Actor.IActorContext, System.Threading.Tasks.Task> handler);\nvoid ReceiveAsync<T>(System.Func<T, Akka.Actor.IActorContext, System.Threading.Tasks.Task> handler, System.Predicate<T> shouldHandle = null);\nvoid ReceiveAsync<T>(System.Predicate<T> shouldHandle, System.Func<T, Akka.Actor.IActorContext, System.Threading.Tasks.Task> handler);\nvoid UnbecomeStacked();\n```\n\n----------------------------------------\n\nTITLE: Declaring a Subscriber for Author Storage in C#\nDESCRIPTION: Example of a library providing an ISubscriber implementation that stores Author objects.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nISubscriber<Author> Storage\n```\n\n----------------------------------------\n\nTITLE: Implementing ConsistentHashingPool Router in C#\nDESCRIPTION: Pool-based router implementation using consistent hashing for message distribution. Supports configuration of instances, resizer, supervisor strategy and virtual nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_201\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ConsistentHashingPool : Akka.Routing.Pool\n{\n    public ConsistentHashingPool(int nrOfInstances) { }\n    public ConsistentHashingPool(Akka.Configuration.Config config) { }\n    public ConsistentHashingPool(int nrOfInstances, Akka.Routing.ConsistentHashMapping hashMapping) { }\n    public ConsistentHashingPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False, int virtualNodesFactor = 0, Akka.Routing.ConsistentHashMapping hashMapping = null) { }\n    public int VirtualNodesFactor { get; }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Composing Complex Graph with Source, Flow, and Sink in C#\nDESCRIPTION: This snippet shows how to compose a complex graph using both the graph DSL and the fluid DSL. It demonstrates creating a custom Source, using a partial graph as a Flow, and constructing a Sink with a nested Flow.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/modularitycomposition.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n// Convert the partial graph of FlowShape to a Flow to get\n// access to the fluid DSL (for example to be able to call .Where())\nvar flow = Flow.FromGraph(partial);\n\n// Simple way to create a graph backed Source\nvar source = Source.FromGraph(GraphDsl.Create(b =>\n{\n    var merge = b.Add(new Merge<int>(2));\n\n    b.From(Source.Single(0)).To(merge);\n    b.From(Source.From(new[] {2, 3, 4})).To(merge);\n\n    // Exposing exactly one output port\n    return new SourceShape<int>(merge.Out);\n}));\n\n// Building a Sink with a nested Flow, using the fluid DSL\nvar nestedFlow = Flow.Create<int>().Select(x => x*2).Skip(10).Named(\"nestedFlow\");\nvar sink = nestedFlow.To(Sink.First<int>());\n\n// Putting all together\nvar closed = source.Via(flow.Where(x => x > 1)).To(sink);\n```\n\n----------------------------------------\n\nTITLE: Implementing TailChoppingGroup Router in C#\nDESCRIPTION: Defines the TailChoppingGroup class for Akka.NET routing. It includes constructors, properties for interval and timeout, and methods for creating routers and managing paths.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_221\n\nLANGUAGE: C#\nCODE:\n```\npublic class TailChoppingGroup : Akka.Routing.Group\n{\n    public TailChoppingGroup(Akka.Configuration.Config config) { }\n    public TailChoppingGroup(System.Collections.Generic.IEnumerable<string> routeePaths, System.TimeSpan within, System.TimeSpan interval) { }\n    public TailChoppingGroup(System.Collections.Generic.IEnumerable<string> routeePaths, System.TimeSpan within, System.TimeSpan interval, string routerDispatcher) { }\n    public System.TimeSpan Interval { get; }\n    public System.TimeSpan Within { get; }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Routing.TailChoppingGroup WithDispatcher(string dispatcher) { }\n    // ... (TailChoppingGroupSurrogate class omitted for brevity)\n}\n```\n\n----------------------------------------\n\nTITLE: Using PoisonPill for Actor Termination in C#\nDESCRIPTION: Demonstrates how to send a PoisonPill message to gracefully terminate an actor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\nmyActor.Tell(PoisonPill.Instance, Sender);\n```\n\n----------------------------------------\n\nTITLE: Creating Daemon Proxies for ShardedDaemonProcess in C#\nDESCRIPTION: This snippet demonstrates how to create daemon proxies for interacting with ShardedDaemonProcess from nodes that don't share the same Akka.Cluster role. It uses ShardedDaemonProcess.InitProxy to create a proxy that forwards messages to the actual daemon process.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-sharded-daemon-process.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar shardedDaemon = ShardedDaemonProcess.Get(system);\nvar proxy = shardedDaemon.InitProxy<Command>(\n    \"daemon\",\n    role,\n    new MessageExtractor());\n```\n\n----------------------------------------\n\nTITLE: DistributedData Extension Class for Akka Actor System\nDESCRIPTION: Extension class that provides access to the distributed data functionality. It exposes methods for async CRUD operations on distributed data and provides access to the replicator actor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class DistributedData : Akka.Actor.IExtension\n{\n    public DistributedData(Akka.Actor.ExtendedActorSystem system) { }\n    public bool IsDurable { get; }\n    public bool IsTerminated { get; }\n    public Akka.Actor.IActorRef Replicator { get; }\n    public static Akka.Configuration.Config DefaultConfig() { }\n    public System.Threading.Tasks.Task DeleteAsync<T>(Akka.DistributedData.IKey<T> key, Akka.DistributedData.IWriteConsistency consistency = null, System.Threading.CancellationToken cancellation = null)\n        where T : Akka.DistributedData.IReplicatedData<T> { }\n    public static Akka.DistributedData.DistributedData Get(Akka.Actor.ActorSystem system) { }\n    public System.Threading.Tasks.Task<T> GetAsync<T>(Akka.DistributedData.IKey<T> key, Akka.DistributedData.IReadConsistency consistency = null, System.Threading.CancellationToken cancellation = null)\n        where T :  class, Akka.DistributedData.IReplicatedData<T> { }\n    public System.Threading.Tasks.Task<System.Collections.Immutable.IImmutableSet<string>> GetKeysAsync(System.Threading.CancellationToken cancellation = null) { }\n    public System.Threading.Tasks.Task UpdateAsync<T>(Akka.DistributedData.IKey<T> key, T replica, Akka.DistributedData.IWriteConsistency consistency = null, System.Threading.CancellationToken cancellation = null)\n        where T : Akka.DistributedData.IReplicatedData<T> { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MultiNodeConfig for Cluster Restart Test in C#\nDESCRIPTION: This code snippet defines a configuration class for a multi-node test that sets up a two-node cluster and configures it for a node restart scenario. It specifies role names, common configuration, and enables the test transport for simulating network conditions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/testing/multi-node-testing.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class RestartNode2SpecConfig : MultiNodeConfig\n{\n    public RoleName Seed1 { get; }\n    public RoleName Seed2 { get; }\n\n    public RestartNode2SpecConfig()\n    {\n        Seed1 = Role(\"seed1\");\n        Seed2 = Role(\"seed2\");\n\n        CommonConfig = ConfigurationFactory.ParseString(@\"\"\"\n            akka.cluster.auto-down-unreachable-after = 0s\n            akka.cluster.retry-unsuccessful-join-after = 3s\n            akka.remote.log-remote-lifecycle-events = off\n            akka.cluster.jmx.enabled = off\n            \"\"\").WithFallback(MultiNodeClusterSpec.ClusterConfigWithFailureDetectorPuppet());\n\n        TestTransport = true;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Message Using Absolute Path in Akka.NET\nDESCRIPTION: This snippet shows how to send a message to an actor using an absolute path with ActorContext.ActorSelection in Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/concepts/addressing.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nContext.ActorSelection(\"/user/serviceA\").Tell(msg);\n```\n\n----------------------------------------\n\nTITLE: Custom Serializer Implementation\nDESCRIPTION: Example showing how to create a custom serializer by inheriting from Akka.Serialization.Serializer\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/serialization/serialization.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MySerializer : Serializer\n{\n    public MySerializer(ExtendedActorSystem system) : base(system)\n    {\n    }\n\n    public override int Identifier\n    {\n        get { return 1234567; }\n    }\n\n    public override bool IncludeManifest\n    {\n        get { return false; }\n    }\n\n    public override byte[] ToBinary(object obj)\n    {\n        // TODO: Implement serialization logic here\n        throw new NotImplementedException();\n    }\n\n    public override object FromBinary(byte[] bytes, Type type)\n    {\n        // TODO: Implement deserialization logic here\n        throw new NotImplementedException();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Resumable Projections with Actors - C#\nDESCRIPTION: This snippet illustrates how to create resumable projections in Akka.NET using Actors. It shows how to save and use a sequence number (or offset) to continue processing events from where the last projection left off. Includes an Actor implementation to handle complex state logic before saving. Dependencies include Akka core and Akka Streams for reactive processing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistence-query.md#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nvar timeout = new Timeout(TimeSpan.FromSeconds(3));\n \nvar bidProjection = new MyResumableProjection(\"bid\");\n \nvar writerProps = Props.Create(typeof(TheOneWhoWritesToQueryJournal), \"bid\");\nvar writer = system.ActorOf(writerProps, \"bid-projection-writer\");\n \nreadJournal\n  .EventsByTag(\"bid\", bidProjection.LatestOffset ?? 0L)\n  .SelectAsync(8, envelope => writer.Ask(envelope.Event, timeout).ContinueWith(t => envelope.Offset, TaskContinuationOptions.OnlyOnRanToCompletion))\n  .SelectAsync(1, offset => bidProjection.saveProgress(offset))\n  .RunWith(Sink.Ignore<object>(), mat);\n\npublic class TheOneWhoWritesToQueryJournal(id: String) : ActorBase\n{\n  public TheOneWhoWritesToQueryJournal(string id) {}\n\n  private DummyStore _store = new DummyStore();\n \n  private ComplexState _state = ComplexState();\n \n  protected override bool Receive(object message) {\n    _state = UpdateState(_state, message);\n    if (_state.IsReadyToSave())\n      _store.Save(new Record(_state));\n    return true;\n  }\n \n  private ComplexState UpdateState(ComplexState state, object msg)\n  {\n    // some complicated aggregation logic here ...\n    return state;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Lease Majority Strategy in Akka.NET\nDESCRIPTION: Configuration for the lease-majority strategy which keeps nodes that can acquire an Akka.Coordination.Lease. This strategy uses an external arbiter (Kubernetes CRD or Azure Blob Storage) to make downing decisions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/split-brain-resolver.md#2025-04-16_snippet_8\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster.split-brain-resolver.lease-majority {\n  lease-implementation = \"\"\n\n  # This delay is used on the minority side before trying to acquire the lease,\n  # as an best effort to try to keep the majority side.\n  acquire-lease-delay-for-minority = 2s\n\n  # If the 'role' is defined the majority/minority is based only on members with that 'role'.\n  role = \"\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BroadcastHub in Akka.NET Streams\nDESCRIPTION: Example of using BroadcastHub to consume elements from a common producer by a dynamic set of consumers. The rate of the producer is automatically adapted to the slowest consumer.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/stream-dynamic.md#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n[!code-csharp[HubsDocTests.cs](../../../src/core/Akka.Docs.Tests/Streams/HubsDocTests.cs?name=broadcast-hub)]\n```\n\n----------------------------------------\n\nTITLE: Advanced Pipelining and Parallelism in Akka Streams (C#)\nDESCRIPTION: Demonstrates a more complex setup combining pipelining and parallelism. It creates two parallel stages, each with two workers, and then connects these stages in a pipeline.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/pipeliningandparallelism.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar pancakeChefs1 = Flow.FromGraph(GraphDsl.Create(b =>\n{\n    var dispatchBatter = b.Add(new Balance<ScoopOfBatter>(2));\n    var mergeHalfPancakes = b.Add(new Merge<HalfCookedPancake>(2));\n\n    // Two chefs work with one frying pan for each, half-frying the pancakes then putting\n    // them into a common pool\n    b.From(dispatchBatter.Out(0)).Via(fryingPan1.Async()).To(mergeHalfPancakes.In(0));\n    b.From(dispatchBatter.Out(1)).Via(fryingPan1.Async()).To(mergeHalfPancakes.In(1));\n\n    return new FlowShape<ScoopOfBatter, HalfCookedPancake>(dispatchBatter.In, mergeHalfPancakes.Out);\n}));\n\nvar pancakeChefs2 = Flow.FromGraph(GraphDsl.Create(b =>\n{\n    var dispatchHalfPancakes = b.Add(new Balance<HalfCookedPancake>(2));\n    var mergePancakes = b.Add(new Merge<Pancake>(2));\n\n    // Two chefs work with one frying pan for each, finishing the pancakes then putting\n    // them into a common pool\n    b.From(dispatchHalfPancakes.Out(0)).Via(fryingPan2.Async()).To(mergePancakes.In(0));\n    b.From(dispatchHalfPancakes.Out(1)).Via(fryingPan2.Async()).To(mergePancakes.In(1));\n\n    return new FlowShape<HalfCookedPancake, Pancake>(dispatchHalfPancakes.In, mergePancakes.Out);\n}));\n\nvar kitchen = pancakeChefs1.Via(pancakeChefs2);\n```\n\n----------------------------------------\n\nTITLE: Implementing Backoff Pattern in C# for Akka.NET\nDESCRIPTION: This snippet defines classes and methods for implementing the Backoff pattern in Akka.NET. It includes BackoffOptions, BackoffSupervisor, and related classes for managing actor restart strategies.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_164\n\nLANGUAGE: C#\nCODE:\n```\npublic class static Backoff\n{\n    public static Akka.Pattern.BackoffOptions OnFailure(Akka.Actor.Props childProps, string childName, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor, int maxNrOfRetries) { }\n    // ... (other methods)\n}\n\npublic abstract class BackoffOptions\n{\n    protected BackoffOptions() { }\n    public abstract Akka.Pattern.BackoffOptions WithAutoReset(System.TimeSpan resetBackoff);\n    // ... (other methods)\n}\n\npublic sealed class BackoffSupervisor : Akka.Pattern.BackoffSupervisorBase\n{\n    public BackoffSupervisor(Akka.Actor.Props childProps, string childName, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor) { }\n    // ... (other methods and nested classes)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Logger in an Actor\nDESCRIPTION: Example showing how to create and use a custom logging adapter within an Akka.NET actor. This pattern can be replaced by the global formatter configuration in 1.5.0-beta1 and later versions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/RELEASE_NOTES.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nprivate readonly ILoggingAdapter _logger = Context.GetLogger<SerilogLoggingAdapter>();\n```\n\n----------------------------------------\n\nTITLE: Creating BroadcastPool Router in C# Code\nDESCRIPTION: Shows how to create a broadcast pool router directly in C# code with 5 worker instances. Messages sent to this router will be delivered to all workers.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nvar router = system.ActorOf(Props.Create<Worker>().WithRouter(new BroadcastPool(5)), \"some-pool\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Eventsourced abstract class in C#\nDESCRIPTION: This abstract class provides the base implementation for event-sourced actors in Akka.NET. It includes methods for persisting events, deleting messages and snapshots, and handling recovery.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Eventsourced : Akka.Actor.ActorBase, Akka.Actor.IActorStash, Akka.Actor.IWithUnboundedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics>, Akka.Persistence.IPersistenceRecovery, Akka.Persistence.IPersistenceStash, Akka.Persistence.IPersistentIdentity\n{\n    public static readonly System.Func<Akka.Actor.Envelope, bool> UnstashFilterPredicate;\n    protected Eventsourced() { }\n    protected Akka.Persistence.PersistenceExtension Extension { get; }\n    public virtual Akka.Persistence.IStashOverflowStrategy InternalStashOverflowStrategy { get; }\n    public bool IsRecovering { get; }\n    public bool IsRecoveryFinished { get; }\n    public Akka.Actor.IActorRef Journal { get; }\n    public string JournalPluginId { get; set; }\n    public long LastSequenceNr { get; }\n    protected virtual Akka.Event.ILoggingAdapter Log { get; }\n    public abstract string PersistenceId { get; }\n    public virtual Akka.Persistence.Recovery Recovery { get; }\n    public string SnapshotPluginId { get; set; }\n    public long SnapshotSequenceNr { get; }\n    public Akka.Actor.IActorRef SnapshotStore { get; }\n    public string SnapshotterId { get; }\n    public Akka.Actor.IStash Stash { get; set; }\n    public override void AroundPostRestart(System.Exception reason, object message) { }\n    public override void AroundPostStop() { }\n    public override void AroundPreRestart(System.Exception cause, object message) { }\n    public override void AroundPreStart() { }\n    protected override bool AroundReceive(Akka.Actor.Receive receive, object message) { }\n    public void DeferAsync<TEvent>(TEvent evt, System.Action<TEvent> handler) { }\n    public void DeleteMessages(long toSequenceNr) { }\n    public void DeleteSnapshot(long sequenceNr) { }\n    public void DeleteSnapshots(Akka.Persistence.SnapshotSelectionCriteria criteria) { }\n    public void LoadSnapshot(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria, long toSequenceNr) { }\n    protected virtual void OnPersistFailure(System.Exception cause, object @event, long sequenceNr) { }\n    protected virtual void OnPersistRejected(System.Exception cause, object @event, long sequenceNr) { }\n    protected virtual void OnRecoveryFailure(System.Exception reason, object message = null) { }\n    protected virtual void OnReplaySuccess() { }\n    public void Persist<TEvent>(TEvent @event, System.Action<TEvent> handler) { }\n    public void PersistAll<TEvent>(System.Collections.Generic.IEnumerable<TEvent> events, System.Action<TEvent> handler) { }\n    public void PersistAllAsync<TEvent>(System.Collections.Generic.IEnumerable<TEvent> events, System.Action<TEvent> handler) { }\n    public void PersistAsync<TEvent>(TEvent @event, System.Action<TEvent> handler) { }\n    protected abstract bool ReceiveCommand(object message);\n    protected abstract bool ReceiveRecover(object message);\n    protected void RunTask(System.Func<System.Threading.Tasks.Task> action) { }\n    public void SaveSnapshot(object snapshot) { }\n    protected override void Unhandled(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StandardOutLogger Class in Akka.NET\nDESCRIPTION: A logger implementation that writes log messages to the console standard output with optional color support. It extends MinimalLogger and provides customizable colors for different log levels.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_141\n\nLANGUAGE: C#\nCODE:\n```\npublic class StandardOutLogger : Akka.Event.MinimalLogger\n{\n    public StandardOutLogger() { }\n    public static System.ConsoleColor DebugColor { get; set; }\n    public static System.ConsoleColor ErrorColor { get; set; }\n    public static System.ConsoleColor InfoColor { get; set; }\n    public static bool UseColors { get; set; }\n    public static System.ConsoleColor WarningColor { get; set; }\n    protected override void Log(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ActorBase Abstract Class in Akka.NET\nDESCRIPTION: The abstract base class for all actors in Akka.NET. It implements the IInternalActor interface and provides core actor lifecycle methods including PreStart, PostStop, PreRestart, and PostRestart. The class requires implementing the Receive method for message handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.Actor\n{\n    public abstract class ActorBase : Akka.Actor.IInternalActor\n    {\n        protected ActorBase() { }\n        protected static Akka.Actor.IActorContext Context { get; }\n        protected static Akka.Actor.Receive EmptyReceive { get; }\n        protected Akka.Actor.IActorRef Self { get; }\n        protected Akka.Actor.IActorRef Sender { get; }\n        public virtual void AroundPostRestart(System.Exception cause, object message) { }\n        public virtual void AroundPostStop() { }\n        public virtual void AroundPreRestart(System.Exception cause, object message) { }\n        public virtual void AroundPreStart() { }\n        protected virtual bool AroundReceive(Akka.Actor.Receive receive, object message) { }\n        protected void Become(Akka.Actor.Receive receive) { }\n        protected void BecomeStacked(Akka.Actor.Receive receive) { }\n        protected virtual void PostRestart(System.Exception reason) { }\n        protected virtual void PostStop() { }\n        protected virtual void PreRestart(System.Exception reason, object message) { }\n        protected virtual void PreStart() { }\n        protected abstract bool Receive(object message);\n        protected void SetReceiveTimeout(System.Nullable<System.TimeSpan> timeout) { }\n        protected virtual Akka.Actor.SupervisorStrategy SupervisorStrategy() { }\n        protected void UnbecomeStacked() { }\n        protected virtual void Unhandled(object message) { }\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterClientMessageSerializer in C#\nDESCRIPTION: Defines a serializer for cluster client messages. It extends SerializerWithStringManifest and provides methods for serialization and deserialization of objects.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterClientMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public ClusterClientMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object o) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PinnedDispatcher Class in C#\nDESCRIPTION: Sealed class that implements a dedicated thread dispatcher for actors, providing a one-to-one mapping between actors and threads. Used when actors need exclusive thread access.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_98\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class PinnedDispatcher : Akka.Dispatch.Dispatcher\n{\n    public PinnedDispatcher(Akka.Dispatch.MessageDispatcherConfigurator configurator, string id, int throughput, System.Nullable<long> throughputDeadlineTime, Akka.Dispatch.ExecutorServiceFactory executorServiceFactory, System.TimeSpan shutdownTimeout) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Actor System Class Implementation\nDESCRIPTION: Core actor system class that manages actor lifecycle, extensions, and system-wide functionality including scheduling and serialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ActorSystem : Akka.Actor.IActorRefFactory, System.IDisposable\n{\n    protected ActorSystem() { }\n    public abstract Akka.Actor.IActorRef DeadLetters { get; }\n    public abstract Akka.Dispatch.Dispatchers Dispatchers { get; }\n    public abstract Akka.Event.EventStream EventStream { get; }\n    public abstract Akka.Actor.IActorRef IgnoreRef { get; }\n    public abstract Akka.Event.ILoggingAdapter Log { get; }\n    public abstract Akka.Dispatch.Mailboxes Mailboxes { get; }\n    public abstract string Name { get; }\n    public abstract Akka.Actor.IScheduler Scheduler { get; }\n    public abstract Akka.Serialization.Serialization Serialization { get; }\n    public abstract Akka.Actor.Settings Settings { get; }\n    public System.TimeSpan StartTime { get; }\n    public System.TimeSpan Uptime { get; }\n    public abstract System.Threading.Tasks.Task WhenTerminated { get; }\n    public abstract Akka.Actor.IActorRef ActorOf(Akka.Actor.Props props, string name = null);\n    public abstract Akka.Actor.ActorSelection ActorSelection(Akka.Actor.ActorPath actorPath);\n    public abstract Akka.Actor.ActorSelection ActorSelection(string actorPath);\n    public static Akka.Actor.ActorSystem Create(string name, Akka.Configuration.Config config) { }\n    public static Akka.Actor.ActorSystem Create(string name, Akka.Actor.BootstrapSetup setup) { }\n    public static Akka.Actor.ActorSystem Create(string name, Akka.Actor.Setup.ActorSystemSetup setup) { }\n    public static Akka.Actor.ActorSystem Create(string name) { }\n    public void Dispose() { }\n    public abstract object GetExtension(Akka.Actor.IExtensionId extensionId);\n    public abstract T GetExtension<T>()\n        where T :  class, Akka.Actor.IExtension;\n    public abstract bool HasExtension(System.Type type);\n    public abstract bool HasExtension<T>()\n        where T :  class, Akka.Actor.IExtension;\n    public abstract object RegisterExtension(Akka.Actor.IExtensionId extension);\n    public abstract void RegisterOnTermination(System.Action code);\n    public abstract void Stop(Akka.Actor.IActorRef actor);\n    public abstract System.Threading.Tasks.Task Terminate();\n    public abstract bool TryGetExtension(System.Type extensionType, out object extension);\n    public abstract bool TryGetExtension<T>(out T extension)\n        where T :  class, Akka.Actor.IExtension;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Right<T> Class in C#\nDESCRIPTION: A class representing the right side of an Either type, typically used in functional programming for success cases.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_228\n\nLANGUAGE: C#\nCODE:\n```\npublic class Right<T>\n{\n    public Right(T value) { }\n    public bool IsLeft { get; }\n    public bool IsRight { get; }\n    public T Value { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Settings class in C# for Akka.NET\nDESCRIPTION: This class represents the configuration settings for an Akka.NET actor system. It includes various properties for controlling system behavior, logging, and performance.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_49\n\nLANGUAGE: C#\nCODE:\n```\npublic class Settings\n{\n    public Settings(Akka.Actor.ActorSystem system, Akka.Configuration.Config config) { }\n    public Settings(Akka.Actor.ActorSystem system, Akka.Configuration.Config config, Akka.Actor.Setup.ActorSystemSetup setup) { }\n    public bool AddLoggingReceive { get; }\n    public System.TimeSpan AskTimeout { get; }\n    public Akka.Configuration.Config Config { get; }\n    public string ConfigVersion { get; }\n    public bool CoordinatedShutdownRunByActorSystemTerminate { get; }\n    public bool CoordinatedShutdownTerminateActorSystem { get; }\n    public System.TimeSpan CreationTimeout { get; }\n    public bool DebugAutoReceive { get; }\n    public bool DebugEventStream { get; }\n    public bool DebugLifecycle { get; }\n    public bool DebugRouterMisconfiguration { get; }\n    public bool DebugTimerScheduler { get; }\n    public bool DebugUnhandledMessage { get; }\n    public int DefaultVirtualNodesFactor { get; }\n    public bool EmitActorTelemetry { get; }\n    public bool FsmDebugEvent { get; }\n    public bool HasCluster { get; }\n    public string Home { get; }\n    public bool LogConfigOnStart { get; }\n    public int LogDeadLetters { get; }\n    public bool LogDeadLettersDuringShutdown { get; }\n    public System.TimeSpan LogDeadLettersSuspendDuration { get; }\n    public Akka.Event.LogFilterEvaluator LogFilter { get; }\n    public Akka.Event.ILogMessageFormatter LogFormatter { get; }\n    public string LogLevel { get; }\n    public bool LogSerializerOverrideOnStart { get; }\n    public bool LoggerAsyncStart { get; }\n    public System.TimeSpan LoggerStartTimeout { get; }\n    public System.Collections.Generic.IList<string> Loggers { get; }\n    public string LoggersDispatcher { get; }\n    public string ProviderClass { get; }\n    public Akka.Actor.ProviderSelection ProviderSelectionType { get; }\n    public string SchedulerClass { get; }\n    public System.TimeSpan SchedulerShutdownTimeout { get; }\n    public bool SerializeAllCreators { get; }\n    public bool SerializeAllMessages { get; }\n    public Akka.Actor.Setup.ActorSystemSetup Setup { get; }\n    public string StdoutLogLevel { get; }\n    public Akka.Event.MinimalLogger StdoutLogger { get; }\n    public string SupervisorStrategyClass { get; }\n    public Akka.Actor.ActorSystem System { get; }\n    public System.TimeSpan UnstartedPushTimeout { get; }\n    public void InjectTopLevelFallback(Akka.Configuration.Config config) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AtomicReference<T> Class in C#\nDESCRIPTION: A generic thread-safe reference wrapper for class types that provides atomic operations. Offers methods for atomic updates and reference comparison with implicit conversion support.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_231\n\nLANGUAGE: C#\nCODE:\n```\npublic class AtomicReference<T>\n    where T :  class\n{\n    protected T atomicValue;\n    public AtomicReference(T originalValue) { }\n    public AtomicReference() { }\n    public T Value { get; set; }\n    public bool CompareAndSet(T expected, T newValue) { }\n    public T GetAndSet(T newValue) { }\n    public static T op_Implicit(Akka.Util.AtomicReference<T> atomicReference) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LocalActorRef Class in C#\nDESCRIPTION: Defines the LocalActorRef class which extends ActorRefWithCell and implements IActorRefScope. It represents a local actor reference with various properties and methods for actor management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\npublic class LocalActorRef : Akka.Actor.ActorRefWithCell, Akka.Actor.IActorRefScope\n{\n    public LocalActorRef(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.Props props, Akka.Dispatch.MessageDispatcher dispatcher, Akka.Dispatch.MailboxType mailboxType, Akka.Actor.IInternalActorRef supervisor, Akka.Actor.ActorPath path) { }\n    public Akka.Actor.ActorCell Cell { get; }\n    public override System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> Children { get; }\n    protected Akka.Dispatch.MessageDispatcher Dispatcher { get; }\n    public override bool IsLocal { get; }\n    public override bool IsTerminated { get; }\n    protected Akka.Dispatch.MailboxType MailboxType { get; }\n    public override Akka.Actor.IInternalActorRef Parent { get; }\n    public override Akka.Actor.ActorPath Path { get; }\n    protected Akka.Actor.Props Props { get; }\n    public override Akka.Actor.IActorRefProvider Provider { get; }\n    protected Akka.Actor.IInternalActorRef Supervisor { get; }\n    protected Akka.Actor.ActorSystem System { get; }\n    public override Akka.Actor.ICell Underlying { get; }\n    public override Akka.Actor.IActorRef GetChild(System.Collections.Generic.IReadOnlyList<string> name) { }\n    public override Akka.Actor.IInternalActorRef GetSingleChild(string name) { }\n    protected virtual Akka.Actor.ActorCell NewActorCell(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.IInternalActorRef self, Akka.Actor.Props props, Akka.Dispatch.MessageDispatcher dispatcher, Akka.Actor.IInternalActorRef supervisor) { }\n    public override void Restart(System.Exception cause) { }\n    public override void Resume(System.Exception causedByFailure = null) { }\n    public override void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message) { }\n    public override void Start() { }\n    public override void Stop() { }\n    public override void Suspend() { }\n    protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Contact Auto-Discovery With Akka.Discovery.KubernetesApi in C#\nDESCRIPTION: Demonstrates how to configure ClusterClient with Kubernetes-based discovery for auto-discovery of contact points. This snippet shows the client-side implementation including configuration of discovery options, service name, and port settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-client.md#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nservices.AddAkka(\"ClusterClientSys\", (builder, provider) => {\n  builder\n    // This code sets up ClusterClient that works using Akka.Discovery\n    .WithClusterClientDiscovery<MyClusterClientActorKey>(options => {\n      // This is the Discovery plugin that will be used with ClusterClientDiscovery.\n      options.DiscoveryOptions = new KubernetesDiscoveryOptions {\n        // IMPORTANT:\n        // This signals Akka.Hosting that this plugin **should not** be used for ClusterBootstrap\n        IsDefaultPlugin = false,\n      \n        // IMPORTANT:\n        // The ConfigPath property has to be different than the default discovery ConfigPath.\n        // The actual name does not matter, but it has to be different than the default name \"kubernetes-api\"\n        ConfigPath = \"kubernetes-api-cluster-client\",\n      \n        // IMPORTANT:\n        // The PodLabelSelector property has to be different than the default k8s discovery \n        // PodLabelSelector, which defaults to \"app={0}\". The \"{0}\" is important because \n        // it will be used inside a String.Format()\n        PodLabelSelector = \"discovery={0}\";\n      };\n      \n      // This has to match the Kubernetes metadata label that we'll set in YAML\n      options.ServiceName = \"initial-contact\";\n\n      // his has to match the Kubernetes port name for the Akka.Management port\n      options.PortName = \"management\";\n    });\n```\n\n----------------------------------------\n\nTITLE: Implementing Serialization Manager Class in C#\nDESCRIPTION: The main serialization manager class that handles registration and lookup of serializers. Provides methods for serializing/deserializing objects, finding appropriate serializers for object types, and managing transport information.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_213\n\nLANGUAGE: C#\nCODE:\n```\npublic class Serialization\n    {\n        public Serialization(Akka.Actor.ExtendedActorSystem system) { }\n        public Akka.Actor.ExtendedActorSystem System { get; }\n        public void AddSerializationMap(System.Type type, Akka.Serialization.Serializer serializer) { }\n        [System.ObsoleteAttribute(\"No longer supported. Use the AddSerializer(name, serializer) overload instead.\", true)]\n        public void AddSerializer(Akka.Serialization.Serializer serializer) { }\n        public void AddSerializer(string name, Akka.Serialization.Serializer serializer) { }\n        public object Deserialize(byte[] bytes, int serializerId, System.Type type) { }\n        public object Deserialize(byte[] bytes, int serializerId, string manifest) { }\n        public Akka.Serialization.Serializer FindSerializerFor(object obj, string defaultSerializerName = null) { }\n        public Akka.Serialization.Serializer FindSerializerForType(System.Type objectType, string defaultSerializerName = null) { }\n        public static Akka.Serialization.Information GetCurrentTransportInformation() { }\n        public static string ManifestFor(Akka.Serialization.Serializer s, object msg) { }\n        public byte[] Serialize(object o) { }\n        public static string SerializedActorPath(Akka.Actor.IActorRef actorRef) { }\n        [System.ObsoleteAttribute(\"Obsolete. Use the SerializeWithTransport<T>(ExtendedActorSystem) method instead.\")]\n        public static T WithTransport<T>(Akka.Actor.ActorSystem system, Akka.Actor.Address address, System.Func<T> action) { }\n        public static T WithTransport<T>(Akka.Actor.ExtendedActorSystem system, System.Func<T> action) { }\n        public static T WithTransport<TState, T>(Akka.Actor.ExtendedActorSystem system, TState state, System.Func<TState, T> action) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Flow-Level Supervision Strategy Implementation\nDESCRIPTION: Demonstrates applying a supervision strategy to an entire flow, handling division by zero exceptions by dropping problematic elements\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/error-handling.md#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nDecider decider = cause => cause is DivideByZeroException\n    ? Directive.Resume\n    : Directive.Stop;\n\nvar flow = Flow.Create<int>()\n    .Where(x => 100 / x < 50)\n    .Select(x => 100 / (5 - x))\n    .WithAttributes(ActorAttributes.CreateSupervisionStrategy(decider));\n```\n\n----------------------------------------\n\nTITLE: Configuring Durable ShardingProducerController with EventSourcedProducerQueue in C#\nDESCRIPTION: Shows how to set up a durable ShardingProducerController using EventSourcedProducerQueue from Akka.Persistence. This ensures that unacknowledged messages are saved to the Akka.Persistence Journal and SnapshotStore for reliability.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-sharding-delivery.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar producerController = Context.Spawn(\n    ShardingProducerController.Create<MessageEnvelope>(\n        Akka.Actor.Props.Empty,\n        \"shopping-cart\",\n        new ShardingMessageExtractor(1000),\n        new ShardingProducerController.Settings(Context.System),\n        durableQueue: true),\n    \"producer-controller\");\n```\n\n----------------------------------------\n\nTITLE: Handling Ask Pattern Exceptions\nDESCRIPTION: Example of proper exception handling in Ask pattern responses, showing how to complete Tasks with success or failure.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\ntry\n{\n    var result = operation();\n    Sender.Tell(result, Self);\n}\ncatch (Exception e)\n{\n    Sender.Tell(new Akka.Actor.Status.Failure(e), Self);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Persistent Actor Classes in C#\nDESCRIPTION: Abstract base classes for persistent actors in Akka.NET that implement event sourcing functionality. Includes PersistentActor and ReceivePersistentActor with command handling capabilities.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class PersistentActor : Akka.Persistence.Eventsourced\n{\n    protected PersistentActor() { }\n    protected override bool Receive(object message) { }\n}\n\npublic abstract class ReceivePersistentActor : Akka.Persistence.UntypedPersistentActor, Akka.Actor.Internal.IInitializableActor\n{\n    protected ReceivePersistentActor() { }\n    protected void Become(System.Action configure) { }\n    protected void BecomeStacked(System.Action configure) { }\n    protected void Command<T>(System.Action<T> handler, System.Predicate<T> shouldHandle = null) { }\n    protected void Command<T>(System.Predicate<T> shouldHandle, System.Action<T> handler) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Actor Selection Methods in C#\nDESCRIPTION: Static methods for creating actor selections either using a path and system or an anchor actor reference.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic static Akka.Actor.ActorSelection ActorSelection(string path, Akka.Actor.ActorSystem system, Akka.Actor.IActorRef lookupRoot) { }\npublic static Akka.Actor.ActorSelection ActorSelection(Akka.Actor.IActorRef anchorActorRef, string path) { }\n```\n\n----------------------------------------\n\nTITLE: Using AndThen for Side Effects in PersistentFSM\nDESCRIPTION: Example of using the AndThen method to define actions executed after event persistence. This is useful for side effects like sending messages or logging, which aren't executed during recovery.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistent-fsm.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nGoTo(Paid.Instance).Applying(OrderExecuted.Instance).AndThen(cart =>\n{\n    if (cart is NonEmptyShoppingCart nonShoppingCart)\n    {\n        reportActor.Tell(new PurchaseWasMade(nonShoppingCart.Items));\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Adapter in C#\nDESCRIPTION: Basic implementation of an IEventAdapter interface showing identity transformation of events. The adapter includes methods for manifest handling, converting events to journal format, and reconstructing events from journal data.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/event-adapters.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyEventAdapter : IEventAdapter\n{\n    public string Manifest(object evt)\n    {\n        return string.Empty; // when no manifest needed, return \"\"\n    }\n\n    public object ToJournal(object evt)\n    {\n        return evt; // identity\n    }\n\n    public IEventSequence FromJournal(object evt, string manifest)\n    {\n        return EventSequence.Single(evt); // identity\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ClusterClientSettings Configuration Class\nDESCRIPTION: The ClusterClientSettings class holds configuration parameters for ClusterClient connectivity. It manages settings for initial contacts, heartbeat intervals, buffer sizes, reconnection policies, and discovery settings with immutable builder-style methods for configuration changes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class ClusterClientSettings : Akka.Actor.INoSerializationVerificationNeeded\n{\n    [System.ObsoleteAttribute(\"Use constructor with useLegacySerialization argument instead. Since 1.5.15\")]\n    public ClusterClientSettings(System.Collections.Immutable.IImmutableSet<Akka.Actor.ActorPath> initialContacts, System.TimeSpan establishingGetContactsInterval, System.TimeSpan refreshContactsInterval, System.TimeSpan heartbeatInterval, System.TimeSpan acceptableHeartbeatPause, int bufferSize, System.Nullable<System.TimeSpan> reconnectTimeout = null) { }\n    [System.ObsoleteAttribute(\"Use constructor with useInitialContactsDiscovery and discoverySettings argument i\" +\n        \"nstead. Since 1.5.25\")]\n    public ClusterClientSettings(System.Collections.Immutable.IImmutableSet<Akka.Actor.ActorPath> initialContacts, System.TimeSpan establishingGetContactsInterval, System.TimeSpan refreshContactsInterval, System.TimeSpan heartbeatInterval, System.TimeSpan acceptableHeartbeatPause, int bufferSize, bool useLegacySerialization, System.Nullable<System.TimeSpan> reconnectTimeout = null) { }\n    public ClusterClientSettings(System.Collections.Immutable.IImmutableSet<Akka.Actor.ActorPath> initialContacts, System.TimeSpan establishingGetContactsInterval, System.TimeSpan refreshContactsInterval, System.TimeSpan heartbeatInterval, System.TimeSpan acceptableHeartbeatPause, int bufferSize, bool useLegacySerialization, bool useInitialContactsDiscovery, [System.Runtime.CompilerServices.NullableAttribute(2)] Akka.Cluster.Tools.Client.ClusterClientDiscoverySettings discoverySettings = null, System.Nullable<System.TimeSpan> reconnectTimeout = null, bool verboseLogging = False) { }\n    public System.TimeSpan AcceptableHeartbeatPause { get; }\n    public int BufferSize { get; }\n    public Akka.Cluster.Tools.Client.ClusterClientDiscoverySettings DiscoverySettings { get; }\n    public System.TimeSpan EstablishingGetContactsInterval { get; }\n    public System.TimeSpan HeartbeatInterval { get; }\n    public System.Collections.Immutable.IImmutableSet<Akka.Actor.ActorPath> InitialContacts { get; }\n    public System.Nullable<System.TimeSpan> ReconnectTimeout { get; }\n    public System.TimeSpan RefreshContactsInterval { get; }\n    public bool UseInitialContactDiscovery { get; }\n    public bool UseLegacySerialization { get; }\n    public bool VerboseLogging { get; }\n    public static Akka.Cluster.Tools.Client.ClusterClientSettings Create(Akka.Actor.ActorSystem system) { }\n    public static Akka.Cluster.Tools.Client.ClusterClientSettings Create(Akka.Configuration.Config config) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithBufferSize(int bufferSize) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithEstablishingGetContactsInterval(System.TimeSpan value) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithHeartbeatInterval(System.TimeSpan value) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithInitialContacts(System.Collections.Immutable.IImmutableSet<Akka.Actor.ActorPath> initialContacts) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithInitialContactsDiscovery(bool useInitialContactsDiscovery, [System.Runtime.CompilerServices.NullableAttribute(2)] Akka.Cluster.Tools.Client.ClusterClientDiscoverySettings discoverySettings = null) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithReconnectTimeout(System.Nullable<System.TimeSpan> reconnectTimeout) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithRefreshContactsInterval(System.TimeSpan value) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithUseLegacySerialization(bool useLegacySerialization) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Materializing SourceRef in C#\nDESCRIPTION: This snippet shows how to materialize a received SourceRef on the remote side. It demonstrates running the source into a Sink and handling the materialized value.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/streamrefs.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nISourceRef<int> sourceRef = // received from the origin actor\n\nsourceRef.Source.RunWith(Sink.Seq<int>(), Materializer)\n    .ContinueWith(task =>\n    {\n        if (task.IsFaulted)\n            Console.WriteLine($\"[Consumer] Stream failed: {task.Exception.Message}\");\n        else\n            Console.WriteLine($\"[Consumer] Received {task.Result.Count} elements.\");\n    });\n```\n\n----------------------------------------\n\nTITLE: Actor Lifecycle Methods\nDESCRIPTION: Shows the default implementation of actor lifecycle hook methods that can be overridden for custom behavior.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override void PreStart()\n{\n}\n\nprotected override void PreRestart(Exception reason, object message)\n{\n    foreach (IActorRef each in Context.GetChildren())\n    {\n      Context.Unwatch(each);\n      Context.Stop(each);\n    }\n    PostStop();\n}\n\nprotected override void PostRestart(Exception reason)\n{\n    PreStart();\n}\n\nprotected override void PostStop()\n{\n}\n```\n\n----------------------------------------\n\nTITLE: RoundRobinPool Class in Akka.NET Routing\nDESCRIPTION: Implements a pool router with round-robin selection strategy. It creates and manages a pool of routee actors and routes messages in a round-robin fashion, ensuring even distribution of messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_189\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class RoundRobinPool : Akka.Routing.Pool\n{\n    public RoundRobinPool(Akka.Configuration.Config config) { }\n    public RoundRobinPool(int nrOfInstances) { }\n    public RoundRobinPool(int nrOfInstances, Akka.Routing.Resizer resizer) { }\n    public RoundRobinPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False) { }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override int GetNrOfInstances(Akka.Actor.ActorSystem sys) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Routing.RoundRobinPool WithDispatcher(string dispatcher) { }\n    public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n    public Akka.Routing.RoundRobinPool WithResizer(Akka.Routing.Resizer resizer) { }\n    public Akka.Routing.RoundRobinPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }\n    public class RoundRobinPoolSurrogate : Akka.Util.ISurrogate\n    {\n        public RoundRobinPoolSurrogate() { }\n        public int NrOfInstances { get; set; }\n        public Akka.Routing.Resizer Resizer { get; set; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IReplicatedData Interface in C#\nDESCRIPTION: Defines the core IReplicatedData interface with a Merge method for combining replicated data instances, which is the foundation for all distributed data types in Akka.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IReplicatedData\n{\n    Akka.DistributedData.IReplicatedData Merge(Akka.DistributedData.IReplicatedData other);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PersistentFSM Classes for Finite State Machines in Akka.NET\nDESCRIPTION: The PersistentFSM namespace contains classes for creating persistent finite state machines. These include IFsmState interface, PersistentFSMSnapshot class, StateChangeEvent class, and State class for managing FSM states.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_48\n\nLANGUAGE: C#\nCODE:\n```\npublic class static PersistentFSM\n{\n    public interface IFsmState\n    {\n        string Identifier { get; }\n    }\n    public class PersistentFSMSnapshot<TD> : Akka.Persistence.Serialization.IMessage\n    {\n        public PersistentFSMSnapshot(string stateIdentifier, TD data, System.Nullable<System.TimeSpan> timeout) { }\n        public TD Data { get; }\n        public string StateIdentifier { get; }\n        public System.Nullable<System.TimeSpan> Timeout { get; }\n        protected bool Equals(Akka.Persistence.Fsm.PersistentFSM.PersistentFSMSnapshot<TD> other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n    }\n    public class StateChangeEvent : Akka.Persistence.Serialization.IMessage\n    {\n        public StateChangeEvent(string stateIdentifier, System.Nullable<System.TimeSpan> timeout) { }\n        public string StateIdentifier { get; }\n        public System.Nullable<System.TimeSpan> Timeout { get; }\n    }\n    public class State<TS, TD, TE>\n    {\n        public State(TS stateName, TD stateData, System.Nullable<System.TimeSpan> timeout = null, Akka.Actor.FSMBase.Reason stopReason = null, System.Collections.Generic.IReadOnlyList<object> replies = null, System.Collections.Generic.IReadOnlyList<TE> domainEvents = null, System.Action<TD> afterTransitionDo = null, bool notifies = True) { }\n        public System.Action<TD> AfterTransitionDo { get; }\n        public System.Collections.Generic.IReadOnlyList<TE> DomainEvents { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Actors and Router Instances in C#\nDESCRIPTION: C# code for creating actor instances and corresponding router instances that use the cluster-aware router configurations to distribute messages across the cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/member-roles.md#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nvar web = system.ActorOf<Web>(\"web\");\nvar fraud = system.ActorOf<Fraud>(\"fraud\");\nvar order = system.ActorOf<Order>(\"order\");\nvar billing = system.ActorOf<Billing>(\"billing\");\nvar storage = system.ActorOf<Storage>(\"storage\");\n\nvar webRouter = system.ActorOf(Props.Empty.WithRouter(FromConfig.Instance),\"webdispatcher\");\nvar fraudRouter = system.ActorOf(Props.Empty.WithRouter(FromConfig.Instance),\"frauddispatcher\");\nvar orderRouter = system.ActorOf(Props.Empty.WithRouter(FromConfig.Instance),\"orderdispatcher\");\nvar billingRouter = system.ActorOf(Props.Empty.WithRouter(FromConfig.Instance),\"billingdispatcher\");\nvar storageRouter = system.ActorOf(Props.Empty.WithRouter(FromConfig.Instance),\"storagedispatcher\");\n```\n\n----------------------------------------\n\nTITLE: Defining ShardAllocationStrategy Static Class in Akka.NET Sharding\nDESCRIPTION: This class contains static methods for creating shard allocation strategies, such as `LeastShardAllocationStrategy`.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\n    public class static ShardAllocationStrategy\n    {\n        public static Akka.Cluster.Sharding.IShardAllocationStrategy LeastShardAllocationStrategy(int absoluteLimit, double relativeLimit) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: ClusterClientReceptionist Configuration Reference\nDESCRIPTION: Reference configuration for the ClusterClientReceptionist extension and ClusterReceptionistSettings, showing all available configuration properties.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-client.md#2025-04-16_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n[!code-json[ConfigReference](../../../src/contrib/cluster/Akka.Cluster.Tools/Client/reference.conf)]\n```\n\n----------------------------------------\n\nTITLE: DotNettySslSetup Class Implementation for SSL Configuration (C#)\nDESCRIPTION: Setup class for configuring SSL/TLS settings for DotNetty transport, including certificate and validation options. Extends the Setup class for actor system setup.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DotNettySslSetup : Akka.Actor.Setup.Setup\n{\n    public DotNettySslSetup(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate, bool suppressValidation) { }\n    public System.Security.Cryptography.X509Certificates.X509Certificate2 Certificate { get; }\n    public bool SuppressValidation { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UniqueAddress in C#\nDESCRIPTION: Defines the UniqueAddress class which extends a regular Address with a unique identifier to distinguish between different incarnations of a node at the same network address. Essential for proper cluster membership tracking.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.DotNet.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic class UniqueAddress : System.IComparable, System.IComparable<Akka.Cluster.UniqueAddress>, System.IEquatable<Akka.Cluster.UniqueAddress>\n{\n    public UniqueAddress(Akka.Actor.Address address, int uid) { }\n    public Akka.Actor.Address Address { get; }\n    public int Uid { get; }\n    public int CompareTo(Akka.Cluster.UniqueAddress uniqueAddress) { }\n    public bool Equals(Akka.Cluster.UniqueAddress other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n    public static bool ==(Akka.Cluster.UniqueAddress left, Akka.Cluster.UniqueAddress right) { }\n    public static bool !=(Akka.Cluster.UniqueAddress left, Akka.Cluster.UniqueAddress right) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Task Piping Extensions for Actor Communication in C#\nDESCRIPTION: Extension methods for piping Task results to actors. Provides methods to handle both successful and failed task completions with custom message transformations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\npublic class static PipeToSupport\n{\n    public static System.Threading.Tasks.Task PipeTo<T>(this System.Threading.Tasks.Task<T> taskToPipe, Akka.Actor.ICanTell recipient, Akka.Actor.IActorRef sender = null, System.Func<T, object> success = null, System.Func<System.Exception, object> failure = null) { }\n    public static System.Threading.Tasks.Task PipeTo<T>(this System.Threading.Tasks.ValueTask<T> taskToPipe, Akka.Actor.ICanTell recipient, Akka.Actor.IActorRef sender = null, System.Func<T, object> success = null, System.Func<System.Exception, object> failure = null) { }\n    public static System.Threading.Tasks.Task PipeTo<T>(this System.Threading.Tasks.Task<T> taskToPipe, Akka.Actor.ICanTell recipient, bool useConfigureAwait, Akka.Actor.IActorRef sender = null, System.Func<T, object> success = null, System.Func<System.Exception, object> failure = null) { }\n    public static System.Threading.Tasks.Task PipeTo<T>(this System.Threading.Tasks.ValueTask<T> taskToPipe, Akka.Actor.ICanTell recipient, bool useConfigureAwait, Akka.Actor.IActorRef sender = null, System.Func<T, object> success = null, System.Func<System.Exception, object> failure = null) { }\n    public static System.Threading.Tasks.Task PipeTo(this System.Threading.Tasks.Task taskToPipe, Akka.Actor.ICanTell recipient, Akka.Actor.IActorRef sender = null, System.Func<object> success = null, System.Func<System.Exception, object> failure = null) { }\n    public static System.Threading.Tasks.Task PipeTo(this System.Threading.Tasks.ValueTask taskToPipe, Akka.Actor.ICanTell recipient, Akka.Actor.IActorRef sender = null, System.Func<object> success = null, System.Func<System.Exception, object> failure = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NewtonSoftJsonSerializer in Akka.NET\nDESCRIPTION: Defines a JSON serializer using Newtonsoft.Json for Akka.NET with different initialization options. It handles serialization and deserialization of objects to and from JSON format with configurable settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_194\n\nLANGUAGE: csharp\nCODE:\n```\npublic class NewtonSoftJsonSerializer : Akka.Serialization.Serializer\n{\n    public NewtonSoftJsonSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public NewtonSoftJsonSerializer(Akka.Actor.ExtendedActorSystem system, Akka.Configuration.Config config) { }\n    public NewtonSoftJsonSerializer(Akka.Actor.ExtendedActorSystem system, Akka.Serialization.NewtonSoftJsonSerializerSettings settings) { }\n    public override bool IncludeManifest { get; }\n    public object Serializer { get; }\n    public Newtonsoft.Json.JsonSerializerSettings Settings { get; }\n    public override object FromBinary(byte[] bytes, System.Type type) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Actor Message Scheduling Interfaces in C#\nDESCRIPTION: Defines interfaces for scheduling messages and tasks within the actor system, including IRunnableScheduler and ITellScheduler. These interfaces provide timing and scheduling capabilities for actor communication.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IRunnableScheduler\n{\n    void ScheduleOnce(System.TimeSpan delay, Akka.Dispatch.IRunnable action, Akka.Actor.ICancelable cancelable);\n    void ScheduleOnce(System.TimeSpan delay, Akka.Dispatch.IRunnable action);\n    void ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Dispatch.IRunnable action, Akka.Actor.ICancelable cancelable);\n    void ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Dispatch.IRunnable action);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Flow with Materialized Value - Akka.Net\nDESCRIPTION: This code snippet demonstrates how to create a Flow using Akka.Net's Graph DSL that includes a materialized value. The flow aggregates integers and utilizes a task to handle the asynchronous processing of those values. This approach is useful for processing streams with steps that need to be executed asynchronously.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithgraphs.md#2025-04-16_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\nvar aggregateFlow = Flow.FromGraph(GraphDsl.Create(Sink.Aggregate<int, int>(0, (sum, i) => sum + i), (b, aggregate) =>\n{\n    var outlet = b.From(b.MaterializedValue)\n        .Via(Flow.Create<Task<int>>().SelectAsync(4, x => x))\n        .Out;\n    return new FlowShape<int, int>(aggregate.Inlet, outlet);\n}));\n```\n\n----------------------------------------\n\nTITLE: RoundRobinGroup Class in Akka.NET Routing\nDESCRIPTION: Implements a group router with round-robin selection strategy. It routes messages to actors identified by paths in a round-robin fashion, distributing load evenly across all routees.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_188\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class RoundRobinGroup : Akka.Routing.Group\n{\n    public RoundRobinGroup(Akka.Configuration.Config config) { }\n    public RoundRobinGroup(params string[] paths) { }\n    public RoundRobinGroup(System.Collections.Generic.IEnumerable<string> paths) { }\n    public RoundRobinGroup(System.Collections.Generic.IEnumerable<string> paths, string routerDispatcher) { }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Routing.Group WithDispatcher(string dispatcherId) { }\n    public class RoundRobinGroupSurrogate : Akka.Util.ISurrogate\n    {\n        public RoundRobinGroupSurrogate() { }\n        public System.Collections.Generic.IEnumerable<string> Paths { get; set; }\n        public string RouterDispatcher { get; set; }\n        public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Durable Producer Queue with EventSourcedProducerQueue in Akka.Delivery\nDESCRIPTION: Example demonstrating how to set up a ProducerController with a durable EventSourcedProducerQueue for persistent message storage. This ensures messages are saved to the Akka.Persistence journal before delivery.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/reliable-delivery.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar producerId = \"p1\";\nvar durableQueueProps = EventSourcedProducerQueue.Props(producerId);\nvar producerController = system.ActorOf(\n    ProducerController.Props(producerId, durableQueueProps, \n        ProducerController.Settings.Create(system)), \"producerController\");\n```\n\n----------------------------------------\n\nTITLE: Implementing SmallestMailboxRoutingLogic in Akka.NET\nDESCRIPTION: Routing logic implementation for the SmallestMailbox strategy. Selects the routee with the fewest messages in its mailbox to achieve better load distribution across actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_218\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SmallestMailboxRoutingLogic : Akka.Routing.RoutingLogic\n{\n    public SmallestMailboxRoutingLogic() { }\n    public SmallestMailboxRoutingLogic(int next) { }\n    public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterReceptionist in C#\nDESCRIPTION: This class represents a ClusterReceptionist in Akka.NET, which handles cluster client interactions. It includes methods for initialization, stopping, and message handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Net.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterReceptionist : Akka.Actor.ActorBase\n{\n    public ClusterReceptionist(Akka.Actor.IActorRef pubSubMediator, Akka.Cluster.Tools.Client.ClusterReceptionistSettings settings) { }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n    public static Akka.Actor.Props Props(Akka.Actor.IActorRef pubSubMediator, Akka.Cluster.Tools.Client.ClusterReceptionistSettings settings) { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Cluster Settings Configuration in C#\nDESCRIPTION: Defines the ClusterSettings class that manages configuration parameters for the Akka.NET cluster including timeouts, intervals, and operational settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterSettings\n{\n    public ClusterSettings(Akka.Configuration.Config config, string systemName) { }\n    public bool AllowWeaklyUpMembers { get; }\n    public Akka.Util.AppVersion AppVersion { get; }\n    public System.Nullable<System.TimeSpan> AutoDownUnreachableAfter { get; }\n    public System.TimeSpan DownRemovalMargin { get; }\n    public System.Type DowningProviderType { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IntentionalRestart Singleton in C#\nDESCRIPTION: Declares a static Instance property for the IntentionalRestart class and overrides the ToString method.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\npublic static Akka.Actor.IntentionalRestart Instance { get; }\npublic override string ToString() { }\n```\n\n----------------------------------------\n\nTITLE: Correct Akka.NET Actor Implementation with Proper Closure in C#\nDESCRIPTION: A fixed implementation that properly closes over the Sender and Self properties by capturing them in local variables before using them in the asynchronous callback, preventing the NotSupportedException.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK1005.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing System.Threading.Tasks;\nusing Akka.Actor;\nusing ThirdPartyApi;\n\nnamespace MyApplication.Actors;\n\npublic sealed class MyActor : ReceiveActor\n{\n    private readonly JobManager _jobManager = new();\n    \n    public MyActor()\n    {\n        ReceiveAsync<string>(async job => {\n            // Store Context.Sender and Self inside local variable\n            var sender = Context.Sender;\n            var self = Self;\n            \n            _jobManager.SubmitJobAsync(job, async () => \n            {\n                // Use local variables instead of accessing Context directly\n                sender.Tell($\"{job} submitted.\", self);\n            })\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly Metadata Configuration in C#\nDESCRIPTION: Assembly-level metadata attributes configuring repository URL, internal visibility, COM interop settings, and target framework for Akka.NET persistence module.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Persistence.TCK\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Persistence.Tests\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"e3bcba88-003c-4cda-8a60-f0c2553fe3c8\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Test Assertions Interface\nDESCRIPTION: ITestKitAssertions interface defining core assertion methods for test verification including equality checks and condition validation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ITestKitAssertions\n{\n    void AssertEqual<T>(T expected, T actual, string format = \"\", params object[] args);\n    void AssertEqual<T>(T expected, T actual, System.Func<T, T, bool> comparer, string format = \"\", params object[] args);\n    void AssertFalse(bool condition, string format = \"\", params object[] args);\n    void AssertTrue(bool condition, string format = \"\", params object[] args);\n    void Fail(string format = \"\", params object[] args);\n}\n```\n\n----------------------------------------\n\nTITLE: Abstract Actor Reference Base Class\nDESCRIPTION: Base class for actor references with cell implementation, providing access to children and underlying cell.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ActorRefWithCell : Akka.Actor.InternalActorRefBase\n{\n    protected ActorRefWithCell() { }\n    public abstract System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> Children { get; }\n    public abstract Akka.Actor.ICell Underlying { get; }\n    public abstract Akka.Actor.IInternalActorRef GetSingleChild(string name);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BroadcastGroup Router in C#\nDESCRIPTION: BroadcastGroup class for Akka.NET routing. It creates a router that broadcasts messages to all routees. The constructor takes a configuration or a list of actor paths.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_198\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class BroadcastGroup : Akka.Routing.Group\n{\n    public BroadcastGroup(Akka.Configuration.Config config) { }\n    public BroadcastGroup(params string[] paths) { }\n    public BroadcastGroup(System.Collections.Generic.IEnumerable<string> paths) { }\n    public BroadcastGroup(System.Collections.Generic.IEnumerable<string> paths, string routerDispatcher) { }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Routing.Group WithDispatcher(string dispatcher) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Stacked Behavior with BecomeStacked/UnbecomeStacked in Akka.NET\nDESCRIPTION: This example demonstrates how to use `BecomeStacked` and `UnbecomeStacked` for layering actor behaviors. The `Swapper` actor pushes a new behavior onto the stack using `BecomeStacked` and then pops it off using `UnbecomeStacked` when a `Swap` message is received.  This allows for temporary behavior modifications without permanently replacing the original behavior.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_23\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Swapper : UntypedActor\n{\n    public class Swap\n    {\n        public static Swap Instance = new Swap();\n        private Swap() { }\n    }\n\n    private ILoggingAdapter log = Context.GetLogger();\n\n    protected override void OnReceive(object message)\n    {\n        switch (message)\n        {\n            case Swap s:\n                log.Info(\"Hi\");\n\n                BecomeStacked((msg) =>\n                {\n                    if (msg is Swap)\n                    {\n                        log.Info(\"Ho\");\n                        UnbecomeStacked();\n                    }\n                });\n                break;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract UnboundedStablePriorityMailbox Class in C#\nDESCRIPTION: Abstract class for implementing stable priority-based mailboxes that maintain FIFO ordering within the same priority level. Provides the base implementation for priority queues that preserve message order.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_105\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class UnboundedStablePriorityMailbox : Akka.Dispatch.MailboxType, Akka.Dispatch.IProducesMessageQueue<Akka.Dispatch.MessageQueues.UnboundedStablePriorityMessageQueue>\n{\n    public const int DefaultCapacity = 11;\n    protected UnboundedStablePriorityMailbox(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }\n    public int InitialCapacity { get; }\n    public virtual Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }\n    protected abstract int PriorityGenerator(object message);\n}\n```\n\n----------------------------------------\n\nTITLE: Persistence Actor Class Definitions in C#\nDESCRIPTION: Core class definitions for Akka.NET persistence including AsyncHandlerInvocation, AtLeastOnceDeliveryActor, and related classes implementing persistence and delivery semantics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class AsyncHandlerInvocation : Akka.Persistence.IPendingHandlerInvocation\n{\n    public AsyncHandlerInvocation(object evt, System.Action<object> handler) { }\n    public object Event { get; }\n    public System.Action<object> Handler { get; }\n}\n\npublic abstract class AtLeastOnceDeliveryActor : Akka.Persistence.PersistentActor\n{\n    protected AtLeastOnceDeliveryActor() { }\n    protected AtLeastOnceDeliveryActor(Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings settings) { }\n    protected AtLeastOnceDeliveryActor(System.Func<Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings, Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings> overrideSettings) { }\n    // ... additional members omitted for brevity ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AsyncWriteJournal Abstract Class in C#\nDESCRIPTION: Abstract class for asynchronous journal writing operations in Akka.NET persistence\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AsyncWriteJournal : Akka.Persistence.Journal.WriteJournalBase, Akka.Persistence.Journal.IAsyncRecovery\n{\n    protected readonly bool CanPublish;\n    protected AsyncWriteJournal() { }\n    protected abstract System.Threading.Tasks.Task DeleteMessagesToAsync(string persistenceId, long toSequenceNr);\n    public abstract System.Threading.Tasks.Task<long> ReadHighestSequenceNrAsync(string persistenceId, long fromSequenceNr);\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Akka.Discovery Extension in C#\nDESCRIPTION: Shows how to load the Akka.Discovery extension in C# code and access the default service discovery implementation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/discovery/index.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Actor;\nusing Akka.Discovery;\n\n...\n\nvar system = ActorSystem.Create(\"example\");\nvar serviceDiscovery = Discovery.Get(system).Default;\n```\n\n----------------------------------------\n\nTITLE: Defining ShardRegion Actor in C#\nDESCRIPTION: This class represents a shard region actor in Akka.NET Cluster Sharding, managing entity actors and their lifecycle.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Core.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ShardRegion : Akka.Actor.ActorBase, Akka.Actor.IWithTimers\n{\n    public ShardRegion(string typeName, System.Func<string, Akka.Actor.Props> entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, string coordinatorPath, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId, object handOffStopMessage, Akka.Cluster.Sharding.Internal.IRememberEntitiesProvider rememberEntitiesProvider) { }\n    public Akka.Actor.ITimerScheduler Timers { get; set; }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Cluster Singleton Components in Akka.NET\nDESCRIPTION: Defines management classes for cluster singleton actors in Akka.NET, including ClusterSingleton, ClusterSingletonManager, and ClusterSingletonProxy. These classes handle creation, configuration, and lifecycle management of singleton actors in a clustered environment.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Net.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.DoNotInheritAttribute()]\npublic class ClusterSingleton : Akka.Actor.IExtension\n{\n    public ClusterSingleton(Akka.Actor.ExtendedActorSystem system) { }\n    public static Akka.Configuration.Config DefaultConfig() { }\n    public static Akka.Cluster.Tools.Singleton.ClusterSingleton Get(Akka.Actor.ActorSystem system) { }\n    [System.ObsoleteAttribute(@\"This convenience method is deprecated and will be removed in v1.6, please use ClusterSingletonManager.Props and ClusterSingletonProxy.Props directly instead. See https://getakka.net/community/whats-new/akkadotnet-v1.5-upgrade-advisories.html#upgrading-to-akkanet-v1532. Since 1.5.32.\")]\n    public Akka.Actor.IActorRef Init(Akka.Cluster.Tools.Singleton.SingletonActor singleton) { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n        0,\n        1})]\npublic sealed class ClusterSingletonManager : Akka.Actor.FSM<Akka.Cluster.Tools.Singleton.ClusterSingletonState, Akka.Cluster.Tools.Singleton.IClusterSingletonData>\n{\n    public ClusterSingletonManager(Akka.Actor.Props singletonProps, object terminationMessage, Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings settings) { }\n    [System.ObsoleteAttribute(\"Deprecated and will be removed in v1.6, please use ClusterSingleton.DefaultConfig\" +\n        \"() instead. Since 1.5.32.\")]\n    public static Akka.Configuration.Config DefaultConfig() { }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n    public static Akka.Actor.Props Props(Akka.Actor.Props singletonProps, Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings settings) { }\n    public static Akka.Actor.Props Props(Akka.Actor.Props singletonProps, object terminationMessage, Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings settings) { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class ClusterSingletonManagerIsStuckException : Akka.Actor.AkkaException\n{\n    public ClusterSingletonManagerIsStuckException(string message) { }\n    public ClusterSingletonManagerIsStuckException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterSingletonManagerSettings : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public ClusterSingletonManagerSettings(string singletonName, string role, System.TimeSpan removalMargin, System.TimeSpan handOverRetryInterval, bool considerAppVersion) { }\n    public ClusterSingletonManagerSettings(string singletonName, string role, System.TimeSpan removalMargin, System.TimeSpan handOverRetryInterval, Akka.Coordination.LeaseUsageSettings leaseSettings, bool considerAppVersion) { }\n    [System.ObsoleteAttribute(\"ConsiderAppVersion is not used anymore and will be removed in future versions.\")]\n    public bool ConsiderAppVersion { get; }\n    public System.TimeSpan HandOverRetryInterval { get; }\n    public Akka.Coordination.LeaseUsageSettings LeaseSettings { get; }\n    public System.TimeSpan RemovalMargin { get; }\n    public string Role { get; }\n    public string SingletonName { get; }\n    public static Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings Create(Akka.Actor.ActorSystem system) { }\n    public static Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings Create(Akka.Configuration.Config config) { }\n    public Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings WithHandOverRetryInterval(System.TimeSpan handOverRetryInterval) { }\n    public Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings WithLeaseSettings(Akka.Coordination.LeaseUsageSettings leaseSettings) { }\n    public Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings WithRemovalMargin(System.TimeSpan removalMargin) { }\n    public Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings WithRole(string role) { }\n    public Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings WithSingletonName(string singletonName) { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterSingletonProvider : Akka.Actor.ExtensionIdProvider<Akka.Cluster.Tools.Singleton.ClusterSingleton>\n{\n    public ClusterSingletonProvider() { }\n    public override Akka.Cluster.Tools.Singleton.ClusterSingleton CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterSingletonProxy : Akka.Actor.ReceiveActor, Akka.Actor.IWithTimers\n{\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Stop Message for Graceful Entity Shutdown in C#\nDESCRIPTION: Illustrates the implementation of a custom stop message type for sharded entity actors during re-balancing. This allows entities to intercept shutdown events and perform cleanup operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-sharding.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Stop Message](../../../src/contrib/cluster/Akka.Cluster.Sharding.Tests.MultiNode/ClusterShardingGracefulShutdownOldestSpec.cs?name=StopMessage)]\n```\n\n----------------------------------------\n\nTITLE: Creating Resizable Router Pool Programmatically in C#\nDESCRIPTION: This code snippet shows how to create a resizable router pool programmatically in C#. It creates a RoundRobinPool with an initial size of 5 and a DefaultResizer with lower and upper bounds.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_27\n\nLANGUAGE: csharp\nCODE:\n```\nnew RoundRobinPool(5, new DefaultResizer(1, 10))\n```\n\n----------------------------------------\n\nTITLE: Defining Improved Read Protocol Messages with Query ID in C#\nDESCRIPTION: Enhances the read protocol messages by adding a query ID field to correlate requests with responses, improving flexibility for retries and multiple actor queries.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-2.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class ReadTemperature\n{\n    public ReadTemperature(long requestId)\n    {\n        RequestId = requestId;\n    }\n\n    public long RequestId { get; }\n}\n\npublic sealed class RespondTemperature\n{\n    public RespondTemperature(long requestId, double? value)\n    {\n        RequestId = requestId;\n        Value = value;\n    }\n\n    public long RequestId { get; }\n    public double? Value { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Dispatcher Configuration in HOCON\nDESCRIPTION: Defines a custom dispatcher configuration named 'my-dispatcher' with specific throughput settings using HOCON syntax.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/dispatchers.md#2025-04-16_snippet_0\n\nLANGUAGE: hocon\nCODE:\n```\nmy-dispatcher {\n    type = Dispatcher\n    throughput = 100\n    throughput-deadline-time = 0ms\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SQL Journal Base Class in C#\nDESCRIPTION: Abstract base class for SQL-based journal implementations in Akka.NET. Handles event persistence, replay, and deletion operations with database connectivity.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Core.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class SqlJournal : Akka.Persistence.Journal.AsyncWriteJournal, Akka.Actor.IActorStash, Akka.Actor.IWithUnboundedStash, Akka.Actor.IWithUnrestrictedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics> {\n    protected SqlJournal(Akka.Configuration.Config journalConfig) { }\n    protected abstract string JournalConfigPath { get; }\n    protected Akka.Event.ILoggingAdapter Log { get; }\n    public abstract Akka.Persistence.Sql.Common.Journal.IJournalQueryExecutor QueryExecutor { get; }\n    // Additional methods omitted for brevity\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ClusterClient Legacy Serialization in HOCON\nDESCRIPTION: Configuration snippet to enable legacy serialization behavior for ClusterClient in Akka.NET v1.5.15. This setting helps maintain wire compatibility during upgrades by reverting to the previous serialization method for Send, SendToAll, and Publish operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/RELEASE_NOTES.md#2025-04-16_snippet_2\n\nLANGUAGE: hocon\nCODE:\n```\n# re-enable legacy serialization\nakka.cluster.client.use-legacy-serialization = on\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterEvent Classes in C#\nDESCRIPTION: Defines event classes for cluster membership changes including MemberUp, MemberWeaklyUp, and ReachabilityEvent classes. These events are used to monitor and react to changes in cluster state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.DotNet.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class MemberUp : Akka.Cluster.ClusterEvent.MemberStatusChange\n{\n    public MemberUp(Akka.Cluster.Member member) { }\n}\npublic sealed class MemberWeaklyUp : Akka.Cluster.ClusterEvent.MemberStatusChange\n{\n    public MemberWeaklyUp(Akka.Cluster.Member member) { }\n}\npublic abstract class ReachabilityEvent : Akka.Cluster.ClusterEvent.IClusterDomainEvent, Akka.Cluster.ClusterEvent.IReachabilityEvent, Akka.Event.IDeadLetterSuppression\n{\n    protected ReachabilityEvent(Akka.Cluster.Member member) { }\n    public Akka.Cluster.Member Member { get; }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Transport Adapter Provider Interface in Akka.NET\nDESCRIPTION: Defines the ITransportAdapterProvider interface which creates transport adapters by wrapping an existing transport implementation within a modified one, allowing for transport composition patterns.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ITransportAdapterProvider\n{\n    Akka.Remote.Transport.Transport Create(Akka.Remote.Transport.Transport wrappedTransport, Akka.Actor.ExtendedActorSystem system);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Vector Clock in C#\nDESCRIPTION: Implements a Vector Clock system for tracking causality and ordering of events in distributed systems. Includes methods for comparing, merging and manipulating vector timestamps.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class VectorClock\n{\n    public System.Collections.Immutable.ImmutableSortedDictionary<Akka.Cluster.VectorClock.Node, long> Versions { get; }\n    public Akka.Cluster.VectorClock.Ordering CompareTo(Akka.Cluster.VectorClock that) { }\n    public static Akka.Cluster.VectorClock Create() { }\n    public Akka.Cluster.VectorClock Increment(Akka.Cluster.VectorClock.Node node) { }\n    public bool IsAfter(Akka.Cluster.VectorClock that) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Logger in Akka.NET\nDESCRIPTION: This snippet demonstrates how to create and initialize a logger within an Akka.NET actor. It uses the ILoggingAdapter system to facilitate logging interactions for the actor instance.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/logging.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nprivate readonly ILoggingAdapter _log = Logging.GetLogger(Context);\n```\n\n----------------------------------------\n\nTITLE: Implementing UdpConnectedExt and UdpExt Classes in C# for Akka.NET\nDESCRIPTION: This snippet defines UdpConnectedExt and UdpExt classes, which extend IOExtension. These classes handle UDP-related functionality in the Akka.NET framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_163\n\nLANGUAGE: C#\nCODE:\n```\npublic class UdpConnectedExt : Akka.IO.IOExtension, Akka.Actor.INoSerializationVerificationNeeded\n{\n    public UdpConnectedExt(Akka.Actor.ExtendedActorSystem system) { }\n    public UdpConnectedExt(Akka.Actor.ExtendedActorSystem system, Akka.IO.UdpSettings settings) { }\n    public override Akka.Actor.IActorRef Manager { get; }\n}\n\npublic class UdpExt : Akka.IO.IOExtension\n{\n    public UdpExt(Akka.Actor.ExtendedActorSystem system) { }\n    public UdpExt(Akka.Actor.ExtendedActorSystem system, Akka.IO.UdpSettings settings) { }\n    public override Akka.Actor.IActorRef Manager { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PNCounterDictionary in C# for Akka.NET Distributed Data\nDESCRIPTION: Defines a distributed PN-Counter dictionary data type that implements various interfaces for replication, delta operations, and node pruning. It provides methods for incrementing, decrementing, and merging counters across distributed nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class PNCounterDictionary<TKey> : Akka.DistributedData.IDeltaReplicatedData, Akka.DistributedData.IDeltaReplicatedData<Akka.DistributedData.PNCounterDictionary<TKey>, Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.PNCounter>.IDeltaOperation>, Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IRemovedNodePruning<Akka.DistributedData.PNCounterDictionary<TKey>>, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.PNCounterDictionary<TKey>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, System.Numerics.BigInteger>>, System.Collections.IEnumerable, System.IEquatable<Akka.DistributedData.PNCounterDictionary<TKey>>\n{\n    public static readonly Akka.DistributedData.PNCounterDictionary<TKey> Empty;\n    public PNCounterDictionary(Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.PNCounter> underlying) { }\n    public int Count { get; }\n    public Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.PNCounter>.IDeltaOperation Delta { get; }\n    public System.Collections.Immutable.IImmutableDictionary<TKey, System.Numerics.BigInteger> Entries { get; }\n    public bool IsEmpty { get; }\n    public System.Numerics.BigInteger this[TKey key] { get; }\n    public System.Type KeyType { get; }\n    public System.Collections.Generic.IEnumerable<TKey> Keys { get; }\n    public System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.UniqueAddress> ModifiedByNodes { get; }\n    public System.Collections.Generic.IEnumerable<System.Numerics.BigInteger> Values { get; }\n    public bool ContainsKey(TKey key) { }\n    public Akka.DistributedData.PNCounterDictionary<TKey> Decrement(Akka.Cluster.Cluster node, TKey key, long delta = 1) { }\n    public Akka.DistributedData.PNCounterDictionary<TKey> Decrement(Akka.Cluster.UniqueAddress node, TKey key, long delta = 1) { }\n    public bool Equals(Akka.DistributedData.PNCounterDictionary<TKey> other) { }\n    public override bool Equals(object obj) { }\n    public System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, System.Numerics.BigInteger>> GetEnumerator() { }\n    public override int GetHashCode() { }\n    public Akka.DistributedData.PNCounterDictionary<TKey> Increment(Akka.Cluster.Cluster node, TKey key, long delta = 1) { }\n    public Akka.DistributedData.PNCounterDictionary<TKey> Increment(Akka.Cluster.UniqueAddress node, TKey key, long delta = 1) { }\n    public Akka.DistributedData.PNCounterDictionary<TKey> Merge(Akka.DistributedData.PNCounterDictionary<TKey> other) { }\n    public Akka.DistributedData.IReplicatedData Merge(Akka.DistributedData.IReplicatedData other) { }\n    public Akka.DistributedData.PNCounterDictionary<TKey> MergeDelta(Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.PNCounter>.IDeltaOperation delta) { }\n    public bool NeedPruningFrom(Akka.Cluster.UniqueAddress removedNode) { }\n    public Akka.DistributedData.PNCounterDictionary<TKey> Prune(Akka.Cluster.UniqueAddress removedNode, Akka.Cluster.UniqueAddress collapseInto) { }\n    public Akka.DistributedData.PNCounterDictionary<TKey> PruningCleanup(Akka.Cluster.UniqueAddress removedNode) { }\n    public Akka.DistributedData.PNCounterDictionary<TKey> Remove(Akka.Cluster.Cluster node, TKey key) { }\n    public Akka.DistributedData.PNCounterDictionary<TKey> Remove(Akka.Cluster.UniqueAddress node, TKey key) { }\n    public Akka.DistributedData.PNCounterDictionary<TKey> ResetDelta() { }\n    public override string ToString() { }\n    public bool TryGetValue(TKey key, out System.Numerics.BigInteger value) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IMessageExtractor Interface in C#\nDESCRIPTION: Defines the IMessageExtractor interface with methods for extracting entity ID, entity message, and shard ID from messages. It includes nullable attributes and an obsolete method.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Net.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IMessageExtractor\n{\n    [return: System.Runtime.CompilerServices.NullableAttribute(2)]\n    string EntityId(object message);\n    [return: System.Runtime.CompilerServices.NullableAttribute(2)]\n    object EntityMessage(object message);\n    [System.ObsoleteAttribute(\"Use ShardId(EntityId, object) instead.\")]\n    [return: System.Runtime.CompilerServices.NullableAttribute(2)]\n    string ShardId(object message);\n    string ShardId(string entityId, [System.Runtime.CompilerServices.NullableAttribute(2)] object messageHint = null);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Node Pruning Interfaces for Distributed Data\nDESCRIPTION: Defines interfaces for handling node removal in distributed data structures. These interfaces provide methods to prune data when nodes are removed from the cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IRemovedNodePruning : Akka.DistributedData.IReplicatedData\n{\n    System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.UniqueAddress> ModifiedByNodes { get; }\n    bool NeedPruningFrom(Akka.Cluster.UniqueAddress removedNode);\n    Akka.DistributedData.IReplicatedData Prune(Akka.Cluster.UniqueAddress removedNode, Akka.Cluster.UniqueAddress collapseInto);\n    Akka.DistributedData.IReplicatedData PruningCleanup(Akka.Cluster.UniqueAddress removedNode);\n}\npublic interface IRemovedNodePruning<T> : Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedData<T>\n    where T : Akka.DistributedData.IReplicatedData\n{\n    T Prune(Akka.Cluster.UniqueAddress removedNode, Akka.Cluster.UniqueAddress collapseInto);\n    T PruningCleanup(Akka.Cluster.UniqueAddress removedNode);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Actor Event Bus and Dead Letter System in Akka.NET\nDESCRIPTION: Defines the base classes for Akka's event bus system and dead letter handling. Includes ActorEventBus for routing events to actors, and AllDeadLetters and related classes for tracking undelivered messages in the actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_136\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ActorEventBus<TEvent, TClassifier> : Akka.Event.EventBus<TEvent, TClassifier, Akka.Actor.IActorRef>\n{\n    protected ActorEventBus() { }\n}\npublic abstract class AllDeadLetters : Akka.Actor.IWrappedMessage\n{\n    protected AllDeadLetters(object message, Akka.Actor.IActorRef sender, Akka.Actor.IActorRef recipient) { }\n    public object Message { get; }\n    public Akka.Actor.IActorRef Recipient { get; }\n    public Akka.Actor.IActorRef Sender { get; }\n    public override string ToString() { }\n}\npublic sealed class DeadLetter : Akka.Event.AllDeadLetters\n{\n    public DeadLetter(object message, Akka.Actor.IActorRef sender, Akka.Actor.IActorRef recipient) { }\n}\npublic sealed class Dropped : Akka.Event.AllDeadLetters\n{\n    public Dropped(object message, string reason, Akka.Actor.IActorRef sender, Akka.Actor.IActorRef recipient) { }\n    public Dropped(object message, string reason, Akka.Actor.IActorRef recipient) { }\n    public string Reason { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: SQL Journal Query Executor Interface Definition in C#\nDESCRIPTION: Defines the IJournalQueryExecutor interface which handles database operations for Akka.NET persistence journals. It includes methods for creating tables, inserting and deleting events, and querying events by various criteria.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IJournalQueryExecutor\n{\n    Akka.Persistence.Sql.Common.Journal.QueryConfiguration Configuration { get; }\n    System.Threading.Tasks.Task CreateTablesAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken);\n    System.Threading.Tasks.Task DeleteBatchAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string persistenceId, long toSequenceNr);\n    System.Threading.Tasks.Task InsertBatchAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, Akka.Persistence.Sql.Common.Journal.WriteJournalBatch write);\n    System.Threading.Tasks.Task<long> SelectAllEventsAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, long fromOffset, long toOffset, long max, System.Action<Akka.Persistence.Sql.Common.Journal.ReplayedEvent> callback);\n    System.Threading.Tasks.Task<System.Collections.Immutable.ImmutableArray<string>> SelectAllPersistenceIdsAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, long offset);\n    System.Threading.Tasks.Task SelectByPersistenceIdAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string persistenceId, long fromSequenceNr, long toSequenceNr, long max, System.Action<Akka.Persistence.IPersistentRepresentation> callback);\n    System.Threading.Tasks.Task<long> SelectByTagAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string tag, long fromOffset, long toOffset, long max, System.Action<Akka.Persistence.Sql.Common.Journal.ReplayedTaggedMessage> callback);\n    System.Threading.Tasks.Task<long> SelectHighestSequenceNrAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string persistenceId);\n    System.Threading.Tasks.Task<long> SelectHighestSequenceNrAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken);\n}\n```\n\n----------------------------------------\n\nTITLE: RemoteActorRefProvider Class Implementation in C#\nDESCRIPTION: Main provider class for remote actor functionality that implements IActorRefProvider and IRemoteActorRefProvider interfaces. Handles creation and management of remote actor references, addressing, and deployment.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class RemoteActorRefProvider : Akka.Actor.IActorRefProvider, Akka.Remote.IRemoteActorRefProvider\n{\n    public RemoteActorRefProvider(string systemName, Akka.Actor.Settings settings, Akka.Event.EventStream eventStream) { }\n    public Akka.Actor.IActorRef DeadLetters { get; }\n    public Akka.Actor.Address DefaultAddress { get; }\n    // Additional properties and methods...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Message Commands for Producer-Consumer Communication\nDESCRIPTION: Defines command classes for producer-consumer interaction in Akka.Delivery, including registering consumers, requesting next messages, and sending messages with confirmation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_77\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IProducerCommand<T> { }\n\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class MessageWithConfirmation<[System.Runtime.CompilerServices.NullableAttribute(2)]  T> : Akka.Delivery.ProducerController.IProducerCommand<T>\n{\n    public MessageWithConfirmation(T message, Akka.Actor.IActorRef replyTo) { }\n    public T Message { get; }\n    public Akka.Actor.IActorRef ReplyTo { get; }\n}\n\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class RegisterConsumer<[System.Runtime.CompilerServices.NullableAttribute(2)]  T> : Akka.Delivery.Internal.IDeliverySerializable, Akka.Delivery.ProducerController.IProducerCommand<T>, System.IEquatable<Akka.Delivery.ProducerController.RegisterConsumer<T>>\n{\n    public RegisterConsumer(Akka.Actor.IActorRef ConsumerController) { }\n    public Akka.Actor.IActorRef ConsumerController { get; set; }\n}\n\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class RequestNext<[System.Runtime.CompilerServices.NullableAttribute(2)]  T> : Akka.Actor.INoSerializationVerificationNeeded, Akka.Delivery.ProducerController.IProducerCommand<T>\n{\n    public RequestNext(string producerId, long currentSeqNr, long confirmedSeqNr, Akka.Actor.IActorRef sendNextTo) { }\n    public long ConfirmedSeqNr { get; }\n    public long CurrentSeqNr { get; }\n    public string ProducerId { get; }\n    public Akka.Actor.IActorRef SendNextTo { get; }\n    public System.Threading.Tasks.Task<long> AskNextTo(T msg, System.Threading.CancellationToken cancellationToken = null) { }\n    public void AskNextTo(Akka.Delivery.ProducerController.MessageWithConfirmation<T> msgWithConfirmation) { }\n}\n\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class Start<[System.Runtime.CompilerServices.NullableAttribute(2)]  T> : Akka.Delivery.ProducerController.IProducerCommand<T>\n{\n    public Start(Akka.Actor.IActorRef producer) { }\n    public Akka.Actor.IActorRef Producer { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Injecting Initial Element in Balanced Graph Cycle - Akka.Net\nDESCRIPTION: This snippet resolves a chicken-and-egg problem by injecting an initial element into a balanced graph cycle using Source.Single. This technique kick-starts the cycle, ensuring continuous processing within Akka.Net's graph structure.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithgraphs.md#2025-04-16_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\nRunnableGraph.FromGraph(GraphDsl.Create(b =>\n{\n    var zip = b.Add(ZipWith.Apply<int, int, int>(Keep.Right));\n    var broadcast = b.Add(new Broadcast<int>(2));\n    var concat = b.Add(new Concat<int, int>().Async());\n    var start = Source.Single(0);\n    var print = Flow.Create<int>().Select(s =>\n    {\n        Console.WriteLine(s);\n        return s;\n    });\n    var sink = Sink.Ignore<int>().MapMaterializedValue(_ => NotUsed.Instance);\n\n    b.From(source).To(zip.In0);\n    b.From(zip.Out).Via(print).Via(broadcast).To(sink);\n\n    b.To(zip.In1).Via(concat).From(start);\n                 b.To(concat).From(broadcast);\n\n    return ClosedShape.Instance;\n}));\n```\n\n----------------------------------------\n\nTITLE: Triggering Flow with ZipWith Operation in Akka.NET Streams\nDESCRIPTION: This snippet demonstrates how to trigger the flow of elements using `ZipWith` in Akka.NET Streams. `ZipWith` avoids creating a tuple by directly applying a function that returns the desired output when a message and trigger are available.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/cookbook.md#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nvar graph = RunnableGraph.FromGraph(GraphDsl.Create(b =>\n{\n    var zip = b.Add(ZipWith.Apply((Message msg, Trigger trigger) => msg));\n\n    b.From(elements).To(zip.In0);\n    b.From(triggerSource).To(zip.In1);\n    b.From(zip.Out).To(sink);\n\n    return ClosedShape.Instance;\n}));\n```\n\n----------------------------------------\n\nTITLE: Defining RoutingLogic Abstract Class in Akka.NET\nDESCRIPTION: Abstract base class for all routing logic implementations that determines how messages are routed to routees. Contains the core Select method that must be implemented by concrete routing strategies.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_212\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class RoutingLogic : Akka.Actor.INoSerializationVerificationNeeded\n{\n    protected RoutingLogic() { }\n    public abstract Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees);\n}\n```\n\n----------------------------------------\n\nTITLE: Shard Allocation Strategy Implementation in C#\nDESCRIPTION: Implements abstract least shard allocation strategy for Akka.NET cluster sharding. Provides core logic for shard distribution and rebalancing across cluster nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AbstractLeastShardAllocationStrategy : Akka.Actor.INoSerializationVerificationNeeded, Akka.Cluster.Sharding.IActorSystemDependentAllocationStrategy, Akka.Cluster.Sharding.IShardAllocationStrategy\n{\n    protected AbstractLeastShardAllocationStrategy() { }\n    protected virtual Akka.Cluster.ClusterEvent.CurrentClusterState ClusterState { get; }\n    protected virtual Akka.Cluster.Member SelfMember { get; }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> AllocateShard(Akka.Actor.IActorRef requester, string shardId, System.Collections.Immutable.IImmutableDictionary<Akka.Actor.IActorRef, System.Collections.Immutable.IImmutableList<string>> currentShardAllocations) { }\n    protected bool IsAGoodTimeToRebalance(System.Collections.Generic.IEnumerable<Akka.Cluster.Sharding.Internal.AbstractLeastShardAllocationStrategy.RegionEntry> regionEntries) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EventEnvelope Class for Akka.NET Persistence\nDESCRIPTION: Sealed class definition for EventEnvelope that handles event metadata including offset, persistence ID, sequence number, timestamp and tags. Includes constructors, properties and object comparison methods.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceQuery.DotNet.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class EventEnvelope : System.IEquatable<Akka.Persistence.Query.EventEnvelope>\n{\n    [System.ObsoleteAttribute(\"For binary compatibility with previous releases. Since 1.4.14\")]\n    public EventEnvelope(Akka.Persistence.Query.Offset offset, string persistenceId, long sequenceNr, object @event) { }\n    [System.ObsoleteAttribute(\"For binary compatibility with previous releases. Since 1.5.11\")]\n    public EventEnvelope(Akka.Persistence.Query.Offset offset, string persistenceId, long sequenceNr, object @event, long timestamp) { }\n    public EventEnvelope(Akka.Persistence.Query.Offset offset, string persistenceId, long sequenceNr, object @event, long timestamp, string[] tags) { }\n    public object Event { get; }\n    public Akka.Persistence.Query.Offset Offset { get; }\n    public string PersistenceId { get; }\n    public long SequenceNr { get; }\n    public string[] Tags { get; }\n    public long Timestamp { get; }\n    public bool Equals(Akka.Persistence.Query.EventEnvelope other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Failure Detectors in Akka.Remote C#\nDESCRIPTION: This code snippet introduces the FailureDetectorLoader class, responsible for dynamically loading failure detectors during runtime. It uses fully qualified class names (fqcn) and configuration settings to integrate detectors into the actor system. This enables flexible monitoring by allowing various detection strategies based on runtime conditions. An extension method supports loading detectors via an actor context.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic class static FailureDetectorLoader\n{\n    public static Akka.Remote.FailureDetector Load(string fqcn, Akka.Configuration.Config config, Akka.Actor.ActorSystem system) { }\n    public static Akka.Remote.FailureDetector LoadFailureDetector(this Akka.Actor.IActorContext context, string fqcn, Akka.Configuration.Config config) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DeleteSnapshots Class\nDESCRIPTION: This snippet defines the `DeleteSnapshots` class, which is used to request the deletion of multiple snapshots based on specific criteria in Akka.Persistence. It implements interfaces such as `INoSerializationVerificationNeeded`, `IPersistenceMessage`, `ISnapshotMessage`, `ISnapshotRequest`, and `IEquatable<DeleteSnapshots>`. The class contains information about the persistence ID and the snapshot selection criteria.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\n\"public sealed class DeleteSnapshots : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage, Akka.Persistence.ISnapshotRequest, System.IEquatable<Akka.Persistence.DeleteSnapshots>\n    {\n        public DeleteSnapshots(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria) { }\n        public Akka.Persistence.SnapshotSelectionCriteria Criteria { get; }\n        public string PersistenceId { get; }\n        public bool Equals(Akka.Persistence.DeleteSnapshots other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n    }\"\n```\n\n----------------------------------------\n\nTITLE: Implementing ORDictionary Class for Convergent Replicated Data - C#\nDESCRIPTION: Definition of ORDictionary (Observed-Remove Dictionary) class, a convergent replicated data type for distributed dictionaries. This class provides methods for adding, updating, and removing entries across a cluster with automatic conflict resolution and supports delta propagation for efficiency.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ORDictionary<TKey, TValue> : Akka.DistributedData.IDeltaReplicatedData, Akka.DistributedData.IDeltaReplicatedData<Akka.DistributedData.ORDictionary<TKey, TValue>, Akka.DistributedData.ORDictionary<TKey, TValue>.IDeltaOperation>, Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IRemovedNodePruning<Akka.DistributedData.ORDictionary<TKey, TValue>>, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.ORDictionary<TKey, TValue>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable, System.IEquatable<Akka.DistributedData.ORDictionary<TKey, TValue>>\n    where TValue : Akka.DistributedData.IReplicatedData<TValue>\n{\n    public static readonly Akka.DistributedData.ORDictionary<TKey, TValue> Empty;\n    public ORDictionary(Akka.DistributedData.ORSet<TKey> keySet, System.Collections.Immutable.IImmutableDictionary<TKey, TValue> valueMap) { }\n    public int Count { get; }\n    public Akka.DistributedData.ORDictionary<TKey, TValue>.IDeltaOperation Delta { get; }\n    public System.Collections.Immutable.IImmutableDictionary<TKey, TValue> Entries { get; }\n    public bool IsEmpty { get; }\n    public TValue this[TKey key] { get; }\n    public System.Type KeyType { get; }\n    public System.Collections.Generic.IEnumerable<TKey> Keys { get; }\n    public System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.UniqueAddress> ModifiedByNodes { get; }\n    public System.Type ValueType { get; }\n    public System.Collections.Generic.IEnumerable<TValue> Values { get; }\n    public Akka.DistributedData.ORDictionary<TKey, TValue> AddOrUpdate(Akka.Cluster.Cluster node, TKey key, TValue initial, System.Func<TValue, TValue> modify) { }\n    public Akka.DistributedData.ORDictionary<TKey, TValue> AddOrUpdate(Akka.Cluster.UniqueAddress node, TKey key, TValue initial, System.Func<TValue, TValue> modify) { }\n    public bool ContainsKey(TKey key) { }\n    public bool Equals(Akka.DistributedData.ORDictionary<TKey, TValue> other) { }\n    public override bool Equals(object obj) { }\n    public System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> GetEnumerator() { }\n    public override int GetHashCode() { }\n    public Akka.DistributedData.ORDictionary<TKey, TValue> Merge(Akka.DistributedData.ORDictionary<TKey, TValue> other) { }\n    public Akka.DistributedData.IReplicatedData Merge(Akka.DistributedData.IReplicatedData other) { }\n    public Akka.DistributedData.ORDictionary<TKey, TValue> MergeDelta(Akka.DistributedData.ORDictionary<TKey, TValue>.IDeltaOperation delta) { }\n    public bool NeedPruningFrom(Akka.Cluster.UniqueAddress removedNode) { }\n    public Akka.DistributedData.ORDictionary<TKey, TValue> Prune(Akka.Cluster.UniqueAddress removedNode, Akka.Cluster.UniqueAddress collapseInto) { }\n    public Akka.DistributedData.ORDictionary<TKey, TValue> PruningCleanup(Akka.Cluster.UniqueAddress removedNode) { }\n    public Akka.DistributedData.ORDictionary<TKey, TValue> Remove(Akka.Cluster.Cluster node, TKey key) { }\n    public Akka.DistributedData.ORDictionary<TKey, TValue> Remove(Akka.Cluster.UniqueAddress node, TKey key) { }\n    public Akka.DistributedData.ORDictionary<TKey, TValue> ResetDelta() { }\n    public Akka.DistributedData.ORDictionary<TKey, TValue> SetItem(Akka.Cluster.Cluster node, TKey key, TValue value) { }\n    public Akka.DistributedData.ORDictionary<TKey, TValue> SetItem(Akka.Cluster.UniqueAddress node, TKey key, TValue value) { }\n    public override string ToString() { }\n    public bool TryGetValue(TKey key, out TValue value) { }\n    public interface IDeltaOperation<TKey, TValue> : Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedDelta, Akka.DistributedData.IRequireCausualDeliveryOfDeltas, System.IEquatable<Akka.DistributedData.ORDictionary<TKey, TValue>.IDeltaOperation>\n        where TValue : Akka.DistributedData.IReplicatedData<TValue> { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Clustered Pool Router in HOCON\nDESCRIPTION: HOCON configuration for a clustered Pool router that uses a round-robin strategy. This setup deploys a maximum of 10 routees across nodes with the 'crawler' role, with no more than 1 routee per node.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-routing.md#2025-04-16_snippet_1\n\nLANGUAGE: xml\nCODE:\n```\nakka {\n   actor{\n      provider = cluster\n      deployment {\n        /api/myClusterPoolRouter {\n          router = round-robin-pool # routing strategy\n          nr-of-instances = 10 # max number of total routees\n          cluster {\n             enabled = on\n             allow-local-routees = on\n             use-role = crawler\n             max-nr-of-instances-per-node = 1\n          }\n        }\n      }\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Logging and Event Classes in Akka.NET\nDESCRIPTION: Defines classes for Akka's logging system, including different log levels (Debug, Info, Error), log events, and formatters. These classes provide the foundation for Akka's structured logging capabilities.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_137\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class BusLogging : Akka.Event.LoggingAdapterBase\n{\n    public BusLogging(Akka.Event.LoggingBus bus, string logSource, System.Type logClass, Akka.Event.ILogMessageFormatter logMessageFormatter) { }\n    public Akka.Event.LoggingBus Bus { get; }\n    public override bool IsDebugEnabled { get; }\n    public override bool IsErrorEnabled { get; }\n    public override bool IsInfoEnabled { get; }\n    public override bool IsWarningEnabled { get; }\n    public System.Type LogClass { get; }\n    public string LogSource { get; }\n    protected override void NotifyLog(Akka.Event.LogLevel logLevel, object message, System.Exception cause = null) { }\n}\n\npublic class Debug : Akka.Event.LogEvent\n{\n    public Debug(string logSource, System.Type logClass, object message) { }\n    public Debug(System.Exception cause, string logSource, System.Type logClass, object message) { }\n    public override Akka.Event.LogLevel LogLevel() { }\n}\n\npublic class Info : Akka.Event.LogEvent\n{\n    public Info(string logSource, System.Type logClass, object message) { }\n    public Info(System.Exception cause, string logSource, System.Type logClass, object message) { }\n    public override Akka.Event.LogLevel LogLevel() { }\n}\n\npublic class Error : Akka.Event.LogEvent\n{\n    public Error(System.Exception cause, string logSource, System.Type logClass, object message) { }\n    public override Akka.Event.LogLevel LogLevel() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SerializerWithStringManifest in Akka.NET\nDESCRIPTION: Defines an abstract base class for serializers that use string manifests instead of Type objects. Provides an implementation of FromBinary that delegates to a string-manifest version.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_203\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class SerializerWithStringManifest : Akka.Serialization.Serializer\n{\n    protected SerializerWithStringManifest(Akka.Actor.ExtendedActorSystem system) { }\n    public virtual bool IncludeManifest { get; }\n    public virtual object FromBinary(byte[] bytes, System.Type type) { }\n    public abstract object FromBinary(byte[] bytes, string manifest);\n```\n\n----------------------------------------\n\nTITLE: Implementing ILoggingAdapter Extension Methods in C#\nDESCRIPTION: These extension methods provide various overloads for logging at different levels (Info, Warning, Log) with support for formatted messages, exceptions, and generic type parameters. They extend the ILoggingAdapter interface in Akka.NET to offer flexible logging options.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_153\n\nLANGUAGE: C#\nCODE:\n```\npublic static void Info(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format) { }\npublic static void Info<T1>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1) { }\npublic static void Info<T1>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1) { }\n// ... (more Info overloads) ...\npublic static void Log(this Akka.Event.ILoggingAdapter log, Akka.Event.LogLevel level, string format) { }\n// ... (more Log overloads) ...\npublic static void Warning(this Akka.Event.ILoggingAdapter log, string format) { }\n// ... (more Warning overloads) ...\n```\n\n----------------------------------------\n\nTITLE: Defining DistributedPubSubSettings Class in C#\nDESCRIPTION: Implements a sealed class DistributedPubSubSettings with configuration options for distributed publish-subscribe. It includes methods for creating and modifying settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DistributedPubSubSettings : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public DistributedPubSubSettings(string role, Akka.Routing.RoutingLogic routingLogic, System.TimeSpan gossipInterval, System.TimeSpan removedTimeToLive, int maxDeltaElements, bool sendToDeadLettersWhenNoSubscribers) { }\n    public System.TimeSpan GossipInterval { get; }\n    public int MaxDeltaElements { get; }\n    public System.TimeSpan RemovedTimeToLive { get; }\n    public string Role { get; }\n    public Akka.Routing.RoutingLogic RoutingLogic { get; }\n    public bool SendToDeadLettersWhenNoSubscribers { get; }\n    public static Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings Create(Akka.Actor.ActorSystem system) { }\n    public static Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings Create(Akka.Configuration.Config config) { }\n    public Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings WithGossipInterval(System.TimeSpan gossipInterval) { }\n    public Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings WithMaxDeltaElements(int maxDeltaElements) { }\n    public Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings WithRemovedTimeToLive(System.TimeSpan removedTtl) { }\n    public Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings WithRole(string role) { }\n    public Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings WithRoutingLogic(Akka.Routing.RoutingLogic routingLogic) { }\n    public Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings WithSendToDeadLettersWhenNoSubscribers(bool sendToDeadLetterWhenNoSubscribers) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BroadcastGroup Router in HOCON Configuration\nDESCRIPTION: Shows how to define a broadcast group router in HOCON configuration that will send messages to all specified actor paths.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_9\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.deployment {\n  /some-group {\n    router = broadcast-group\n    routees.paths = [\"/user/a1\", \"/user/a2\", \"/user/a3\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ListenerSupport Class in C#\nDESCRIPTION: Defines a class that manages a set of listeners and provides methods for adding, removing, and notifying them.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_204\n\nLANGUAGE: C#\nCODE:\n```\npublic class ListenerSupport\n{\n    protected readonly System.Collections.Generic.HashSet<Akka.Actor.IActorRef> Listeners;\n    public ListenerSupport() { }\n    public Akka.Actor.Receive ListenerReceive { get; }\n    public void Add(Akka.Actor.IActorRef actor) { }\n    public void Gossip(object message) { }\n    public void Gossip(object message, Akka.Actor.IActorRef sender) { }\n    public void Remove(Akka.Actor.IActorRef actor) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Contact Auto-Discovery With Akka.Discovery.Azure (Client Side)\nDESCRIPTION: Demonstrates how to configure ClusterClient with Azure-based discovery for auto-discovery of contact points. This snippet shows the client-side implementation with AzureDiscovery-specific configuration options.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-client.md#2025-04-16_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nservices.AddAkka(\"ClusterClientSys\", (builder, provider) => {\n  builder\n    // This code sets up ClusterClient that works using Akka.Discovery\n    .WithClusterClientDiscovery<MyClusterClientActorKey>(options => {\n      // This is the Discovery plugin that will be used with ClusterClientDiscovery.\n      options.DiscoveryOptions = new AkkaDiscoveryOptions {\n        // IMPORTANT:\n        // This signals Akka.Hosting that this plugin **should not** be used for ClusterBootstrap\n        IsDefaultPlugin = false,\n      \n        // IMPORTANT:\n        // The ConfigPath property has to be different than the default discovery ConfigPath.\n        // The actual name does not matter, but it has to be different than the default name \"azure\"\n        ConfigPath = \"azure-cluster-client\",\n        \n        // IMPORTANT:\n        // This discovery plugin **should not** participate in updating the Azure cluster member table\n        ReadOnly = true,\n        \n        // IMPORTANT:\n        // All service names for cluster client discovery should be the same.\n        // If you're also using ClusterBootstrap, make sure that this name does not collide.  \n        ServiceName = \"cluster-client\",\n        \n        // IMPORTANT:\n        // All table names for cluster client discovery should be the same.\n        // If you're also using ClusterBootstrap, make sure that this table name does not collide.  \n        TableName = \"akkaclusterreceptionists\",\n      };\n      \n      // This has to match the name we set inside the discovery options\n      options.ServiceName = \"cluster-client\";\n    })\n      \n    // If you're not using ClusterBootstrap in the cluster client side, you will need to add\n    // these code\n    .AddStartup(async (system, registry) => {\n      await AkkaManagement.Get(system).Start();\n    });\n```\n\n----------------------------------------\n\nTITLE: Implementing Supervisor Strategies in Akka.NET\nDESCRIPTION: Classes for supervision strategies that handle actor failures. Includes StoppingSupervisorStrategy and the abstract SupervisorStrategy base class with methods for handling exceptions and child termination.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_50\n\nLANGUAGE: C#\nCODE:\n```\npublic class StoppingSupervisorStrategy : Akka.Actor.SupervisorStrategyConfigurator\n    {\n        public StoppingSupervisorStrategy() { }\n        public override Akka.Actor.SupervisorStrategy Create() { }\n    }\n    public abstract class SupervisorStrategy : Akka.Util.ISurrogated\n    {\n        public static Akka.Actor.IDecider DefaultDecider;\n        public static readonly Akka.Actor.SupervisorStrategy DefaultStrategy;\n        public static readonly Akka.Actor.OneForOneStrategy StoppingStrategy;\n        protected SupervisorStrategy() { }\n        public abstract Akka.Actor.IDecider Decider { get; }\n        protected bool LoggingEnabled { get; set; }\n        protected abstract Akka.Actor.Directive Handle(Akka.Actor.IActorRef child, System.Exception exception);\n        public abstract void HandleChildTerminated(Akka.Actor.IActorContext actorContext, Akka.Actor.IActorRef child, System.Collections.Generic.IEnumerable<Akka.Actor.IInternalActorRef> children);\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Adapters in Akka.NET Persistence\nDESCRIPTION: Defines event adapter classes including CombinedReadEventAdapter for combining multiple adapters and IdentityEventAdapter as a no-op adapter that passes events through unchanged.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_46\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class CombinedReadEventAdapter : Akka.Persistence.Journal.IEventAdapter, Akka.Persistence.Journal.IReadEventAdapter, Akka.Persistence.Journal.IWriteEventAdapter\n{\n    public CombinedReadEventAdapter(System.Collections.Generic.IEnumerable<Akka.Persistence.Journal.IEventAdapter> adapters) { }\n    public System.Collections.Generic.IEnumerable<Akka.Persistence.Journal.IEventAdapter> Adapters { get; }\n    public Akka.Persistence.Journal.IEventSequence FromJournal(object evt, string manifest) { }\n    public string Manifest(object evt) { }\n    public object ToJournal(object evt) { }\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class IdentityEventAdapter : Akka.Persistence.Journal.IEventAdapter, Akka.Persistence.Journal.IReadEventAdapter, Akka.Persistence.Journal.IWriteEventAdapter\n{\n    public static Akka.Persistence.Journal.IdentityEventAdapter Instance { get; }\n    public Akka.Persistence.Journal.IEventSequence FromJournal(object evt, string manifest) { }\n    public string Manifest(object evt) { }\n    public object ToJournal(object evt) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Using PoisonPill in Akka.NET\nDESCRIPTION: This snippet demonstrates how to use the `PoisonPill` message to stop an actor.  `PoisonPill` is enqueued as an ordinary message and will be handled after messages that were already queued in the mailbox.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_26\n\nLANGUAGE: csharp\nCODE:\n```\nmyActor.Tell(PoisonPill.Instance, Sender);\n```\n\n----------------------------------------\n\nTITLE: Implementing Warning Extension Methods for ILoggingAdapter in Akka.NET\nDESCRIPTION: Defines extension methods for warning-level logging with various generic type parameters. These methods extend ILoggingAdapter to provide strongly-typed logging capabilities with format strings and exception causes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_138\n\nLANGUAGE: C#\nCODE:\n```\npublic static void Warning(this Akka.Event.ILoggingAdapter log, string format) { }\npublic static void Warning(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format) { }\npublic static void Warning<T1>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1) { }\npublic static void Warning<T1>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1) { }\npublic static void Warning<T1, T2>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2) { }\npublic static void Warning<T1, T2>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2) { }\npublic static void Warning<T1, T2, T3>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3) { }\npublic static void Warning<T1, T2, T3>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3) { }\npublic static void Warning<T1, T2, T3, T4>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4) { }\npublic static void Warning<T1, T2, T3, T4>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4) { }\npublic static void Warning<T1, T2, T3, T4, T5>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) { }\npublic static void Warning<T1, T2, T3, T4, T5>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) { }\npublic static void Warning<T1, T2, T3, T4, T5, T6>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) { }\npublic static void Warning<T1, T2, T3, T4, T5, T6>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) { }\npublic static void Warning(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, object[] args) { }\npublic static void Warning(this Akka.Event.ILoggingAdapter log, string format, object[] args) { }\n```\n\n----------------------------------------\n\nTITLE: Defining LeastShardAllocationStrategy Class in C#\nDESCRIPTION: A class implementing a least shard allocation strategy for cluster sharding, with configurable rebalance threshold and maximum simultaneous rebalance.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic class LeastShardAllocationStrategy : Akka.Cluster.Sharding.Internal.AbstractLeastShardAllocationStrategy\n{\n    public LeastShardAllocationStrategy(int rebalanceThreshold, int maxSimultaneousRebalance) { }\n    public override System.Threading.Tasks.Task<System.Collections.Immutable.IImmutableSet<string>> Rebalance(System.Collections.Immutable.IImmutableDictionary<Akka.Actor.IActorRef, System.Collections.Immutable.IImmutableList<string>> currentShardAllocations, System.Collections.Immutable.IImmutableSet<string> rebalanceInProgress) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LWWDictionary<TKey, TValue> Class in C#\nDESCRIPTION: Implements a Last-Write-Wins dictionary, a conflict-free replicated dictionary data structure that resolves conflicts by timestamps. Supports delta operations, pruning, and enumeration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class LWWDictionary<TKey, TValue> : Akka.DistributedData.IDeltaReplicatedData, Akka.DistributedData.IDeltaReplicatedData<Akka.DistributedData.LWWDictionary<TKey, TValue>, Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.LWWRegister<TValue>>.IDeltaOperation>, Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IRemovedNodePruning<Akka.DistributedData.LWWDictionary<TKey, TValue>>, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.LWWDictionary<TKey, TValue>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable, System.IEquatable<Akka.DistributedData.LWWDictionary<TKey, TValue>>\n{\n    public static readonly Akka.DistributedData.LWWDictionary<TKey, TValue> Empty;\n    public LWWDictionary(Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.LWWRegister<TValue>> underlying) { }\n    public int Count { get; }\n    public Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.LWWRegister<TValue>>.IDeltaOperation Delta { get; }\n    public System.Collections.Immutable.IImmutableDictionary<TKey, TValue> Entries { get; }\n    public bool IsEmpty { get; }\n    public TValue this[TKey key] { get; }\n    public System.Type KeyType { get; }\n    public System.Collections.Generic.IEnumerable<TKey> Keys { get; }\n    public System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.UniqueAddress> ModifiedByNodes { get; }\n    public System.Type ValueType { get; }\n    public System.Collections.Generic.IEnumerable<TValue> Values { get; }\n    public bool ContainsKey(TKey key) { }\n    public bool Equals(Akka.DistributedData.LWWDictionary<TKey, TValue> other) { }\n    public override bool Equals(object obj) { }\n    public System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> GetEnumerator() { }\n    public override int GetHashCode() { }\n    public Akka.DistributedData.LWWDictionary<TKey, TValue> Merge(Akka.DistributedData.LWWDictionary<TKey, TValue> other) { }\n    public Akka.DistributedData.IReplicatedData Merge(Akka.DistributedData.IReplicatedData other) { }\n    public Akka.DistributedData.LWWDictionary<TKey, TValue> MergeDelta(Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.LWWRegister<TValue>>.IDeltaOperation delta) { }\n    public bool NeedPruningFrom(Akka.Cluster.UniqueAddress removedNode) { }\n    public Akka.DistributedData.LWWDictionary<TKey, TValue> Prune(Akka.Cluster.UniqueAddress removedNode, Akka.Cluster.UniqueAddress collapseInto) { }\n    public Akka.DistributedData.LWWDictionary<TKey, TValue> PruningCleanup(Akka.Cluster.UniqueAddress removedNode) { }\n    public Akka.DistributedData.LWWDictionary<TKey, TValue> Remove(Akka.Cluster.Cluster node, TKey key) { }\n    public Akka.DistributedData.LWWDictionary<TKey, TValue> Remove(Akka.Cluster.UniqueAddress node, TKey key) { }\n    public Akka.DistributedData.LWWDictionary<TKey, TValue> ResetDelta() { }\n    public Akka.DistributedData.LWWDictionary<TKey, TValue> SetItem(Akka.Cluster.Cluster node, TKey key, TValue value, Akka.DistributedData.Clock<TValue> clock = null) { }\n    public Akka.DistributedData.LWWDictionary<TKey, TValue> SetItem(Akka.Cluster.UniqueAddress node, TKey key, TValue value, Akka.DistributedData.Clock<TValue> clock = null) { }\n    public override string ToString() { }\n    public bool TryGetValue(TKey key, out TValue value) { }\n}\n```\n\n----------------------------------------\n\nTITLE: SchedulerBase Abstract Class in Akka.NET (C#)\nDESCRIPTION: Base class for implementing schedulers in Akka.NET. Provides functionality for scheduling one-time and recurring actions or messages with configurable delays and intervals.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_46\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class SchedulerBase : Akka.Actor.IActionScheduler, Akka.Actor.IAdvancedScheduler, Akka.Actor.IRunnableScheduler, Akka.Actor.IScheduler, Akka.Actor.ITellScheduler, Akka.Actor.ITimeProvider\n{\n    protected readonly Akka.Event.ILoggingAdapter Log;\n    protected readonly Akka.Configuration.Config SchedulerConfig;\n    protected SchedulerBase(Akka.Configuration.Config scheduler, Akka.Event.ILoggingAdapter log) { }\n    public abstract System.TimeSpan HighResMonotonicClock { get; }\n    public abstract System.TimeSpan MonotonicClock { get; }\n    protected abstract System.DateTimeOffset TimeNow { get; }\n    protected abstract void InternalScheduleOnce(System.TimeSpan delay, System.Action action, Akka.Actor.ICancelable cancelable);\n    protected abstract void InternalScheduleOnce(System.TimeSpan delay, Akka.Dispatch.IRunnable action, Akka.Actor.ICancelable cancelable);\n    protected abstract void InternalScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action, Akka.Actor.ICancelable cancelable);\n    protected abstract void InternalScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Dispatch.IRunnable action, Akka.Actor.ICancelable cancelable);\n    protected abstract void InternalScheduleTellOnce(System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable);\n    protected abstract void InternalScheduleTellRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable);\n    public void ScheduleOnce(System.TimeSpan delay, Akka.Dispatch.IRunnable action, Akka.Actor.ICancelable cancelable) { }\n    public void ScheduleOnce(System.TimeSpan delay, Akka.Dispatch.IRunnable action) { }\n    public void ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Dispatch.IRunnable action, Akka.Actor.ICancelable cancelable) { }\n    public void ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Dispatch.IRunnable action) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SmallestMailboxPool Class in C#\nDESCRIPTION: Definition of SmallestMailboxPool which routes messages to the routee with the fewest messages in its mailbox. This pool router creates actors under its supervision and implements the smallest-mailbox routing strategy.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_201\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SmallestMailboxPool : Akka.Routing.Pool\n{\n    public SmallestMailboxPool(Akka.Configuration.Config config) { }\n    public SmallestMailboxPool(int nrOfInstances) { }\n    public SmallestMailboxPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False) { }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Routing.SmallestMailboxPool WithDispatcher(string dispatcher) { }\n    public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n    public Akka.Routing.SmallestMailboxPool WithResizer(Akka.Routing.Resizer resizer) { }\n    public Akka.Routing.SmallestMailboxPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }\n    public class SmallestMailboxPoolSurrogate : Akka.Util.ISurrogate\n    {\n        public SmallestMailboxPoolSurrogate() { }\n        public int NrOfInstances { get; set; }\n        public Akka.Routing.Resizer Resizer { get; set; }\n        public string RouterDispatcher { get; set; }\n        public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }\n        public bool UsePoolDispatcher { get; set; }\n        public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Stream Class in C#\nDESCRIPTION: Defines the EventStream class which extends LoggingBus. It provides methods for subscribing and unsubscribing actors to event channels and initializes an unsubscriber for the actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_126\n\nLANGUAGE: C#\nCODE:\n```\npublic class EventStream : Akka.Event.LoggingBus\n{\n    public EventStream(bool debug) { }\n    public void StartUnsubscriber(Akka.Actor.Internal.ActorSystemImpl system) { }\n    public override bool Subscribe(Akka.Actor.IActorRef subscriber, System.Type channel) { }\n    public override bool Unsubscribe(Akka.Actor.IActorRef subscriber, System.Type channel) { }\n    public override bool Unsubscribe(Akka.Actor.IActorRef subscriber) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining State Class for Finite State Machines in C#\nDESCRIPTION: This class represents a state in a Finite State Machine, containing properties for state name, data, timeout, and other relevant information. It includes methods for equality comparison and state manipulation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class State<TS, TD> : System.IEquatable<Akka.Actor.FSMBase.State<TS, TD>>\n{\n    public State(TS stateName, TD stateData, System.Nullable<System.TimeSpan> timeout = null, Akka.Actor.FSMBase.Reason stopReason = null, System.Collections.Generic.IReadOnlyList<object> replies = null, bool notifies = True) { }\n    public System.Collections.Generic.IReadOnlyList<object> Replies { get; }\n    public TD StateData { get; }\n    public TS StateName { get; }\n    public Akka.Actor.FSMBase.Reason StopReason { get; }\n    public System.Nullable<System.TimeSpan> Timeout { get; }\n    public bool Equals(Akka.Actor.FSMBase.State<TS, TD> other) { }\n    public override bool Equals(object obj) { }\n    public Akka.Actor.FSMBase.State<TS, TD> ForMax(System.TimeSpan timeout) { }\n    public override int GetHashCode() { }\n    public Akka.Actor.FSMBase.State<TS, TD> Replying(object replyValue) { }\n    public override string ToString() { }\n    public Akka.Actor.FSMBase.State<TS, TD> Using(TD nextStateData) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Result Static Class in C#\nDESCRIPTION: A static class related to the Result pattern in Akka.NET. The class declaration shows nullable attribute annotations that indicate this class works with nullable reference types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_247\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic class static Result\n{\n    [return: System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})]\n\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterSingletonProxy Actor for Akka in C#\nDESCRIPTION: Defines a proxy actor that forwards messages to the singleton instance in the cluster. Implements ReceiveActor and IWithTimers for handling messages and timeout operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_29\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class ClusterSingletonProxy : Akka.Actor.ReceiveActor, Akka.Actor.IWithTimers\n{\n```\n\n----------------------------------------\n\nTITLE: DeleteSnapshot Class Definition in Akka.Persistence\nDESCRIPTION: Class representing a request to delete a specific snapshot, identified by its metadata, used as a command sent to the snapshot store.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DeleteSnapshot : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage, Akka.Persistence.ISnapshotRequest, System.IEquatable<Akka.Persistence.DeleteSnapshot>\n{\n    public DeleteSnapshot(Akka.Persistence.SnapshotMetadata metadata) { }\n    public Akka.Persistence.SnapshotMetadata Metadata { get; }\n```\n\n----------------------------------------\n\nTITLE: Configuring BackoffSupervisor with Auto Reset and Custom Supervision Strategy\nDESCRIPTION: Shows BackoffSupervisor setup with automatic reset after 10 seconds of successful operation and custom supervision strategy for handling specific exceptions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/concepts/supervision.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar supervisor = BackoffSupervisor.Props(\n    Backoff.OnStop(\n        childProps,\n        childName: \"myEcho\",\n        minBackoff: TimeSpan.FromSeconds(3),\n        maxBackoff: TimeSpan.FromSeconds(30),\n        randomFactor: 0.2)\n        .WithAutoReset(TimeSpan.FromSeconds(10))\n        .WithSupervisorStrategy(new OneForOneStrategy(exception =>\n        {\n            if (exception is MyException)\n                return Directive.Restart;\n            return Directive.Escalate;\n        })));\n```\n\n----------------------------------------\n\nTITLE: Implementing LoggingBus event bus for Akka.NET\nDESCRIPTION: The LoggingBus class extends ActorEventBus to provide a specialized event bus for logging. It manages log level filtering and event classification, and includes methods to start a standard output logger and set the system log level.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_147\n\nLANGUAGE: C#\nCODE:\n```\npublic class LoggingBus : Akka.Event.ActorEventBus<object, System.Type>\n{\n    public LoggingBus() { }\n    public Akka.Event.LogLevel LogLevel { get; }\n    protected override bool Classify(object @event, System.Type classifier) { }\n    protected override System.Type GetClassifier(object @event) { }\n    protected override bool IsSubClassification(System.Type parent, System.Type child) { }\n    protected override void Publish(object @event, Akka.Actor.IActorRef subscriber) { }\n    public void SetLogLevel(Akka.Event.LogLevel logLevel) { }\n    public void StartStdoutLogger(Akka.Actor.Settings config) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing an Infinite Stream Source in C#\nDESCRIPTION: This example shows how to test a source that produces an infinite stream of elements by asserting that the first arbitrary number of elements meet a certain condition using the Grouped combinator and Sink.First.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/testingstreams.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar sourceUnderTest = Source.Repeat(1).Select(x => x*2);\n\nvar task = sourceUnderTest.Grouped(10).RunWith(Sink.First<IEnumerable<int>>(), materializer);\ntask.Wait(TimeSpan.FromMilliseconds(500)).Should().BeTrue();\ntask.Result.ShouldAllBeEquivalentTo(Enumerable.Repeat(2, 10));\n```\n\n----------------------------------------\n\nTITLE: Implementing Bounded Deque Message Queue in Akka.NET\nDESCRIPTION: Defines a bounded double-ended queue implementation for actor messages that implements multiple interface semantics including bounded and deque-based message queue semantics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_107\n\nLANGUAGE: C#\nCODE:\n```\npublic class BoundedDequeMessageQueue : Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue, Akka.Dispatch.IBoundedDequeBasedMessageQueueSemantics, Akka.Dispatch.IBoundedMessageQueueSemantics, Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics\n{\n    public BoundedDequeMessageQueue(int boundedCapacity, System.TimeSpan pushTimeOut) { }\n    public System.TimeSpan PushTimeOut { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Actor Provider for Cluster Client in HOCON\nDESCRIPTION: Configuration required to change the actor provider from the default LocalActorRefProvider to the ClusterActorRefProvider for cluster client usage.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-client.md#2025-04-16_snippet_0\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.provider = \"Akka.Cluster.ClusterActorRefProvider, Akka.Cluster\"\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterSettings in C#\nDESCRIPTION: Implements the ClusterSettings class which encapsulates all configuration settings for an Akka.NET cluster. This includes timeouts, intervals, and behavior parameters that control cluster operation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.DotNet.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterSettings\n{\n    public ClusterSettings(Akka.Configuration.Config config, string systemName) { }\n    public bool AllowWeaklyUpMembers { get; }\n    public Akka.Util.AppVersion AppVersion { get; }\n    [System.ObsoleteAttribute(\"Deprecated as of Akka.NET v1.5.2 - clustering defaults to using KeepMajority SBR \" +\n        \"instead\")]\n    public System.Nullable<System.TimeSpan> AutoDownUnreachableAfter { get; }\n    public System.Type DowningProviderType { get; }\n    public Akka.Configuration.Config FailureDetectorConfig { get; }\n    public string FailureDetectorImplementationClass { get; }\n    public double GossipDifferentViewProbability { get; }\n    public System.TimeSpan GossipInterval { get; }\n    public System.TimeSpan GossipTimeToLive { get; }\n    public System.TimeSpan HeartbeatExpectedResponseAfter { get; }\n    public System.TimeSpan HeartbeatInterval { get; }\n    public System.TimeSpan LeaderActionsInterval { get; }\n    public bool LogInfo { get; }\n    public bool LogInfoVerbose { get; }\n    public int MinNrOfMembers { get; }\n    public System.Collections.Immutable.ImmutableDictionary<string, int> MinNrOfMembersOfRole { get; }\n    public int MonitoredByNrOfMembers { get; }\n    public System.TimeSpan PeriodicTasksInitialDelay { get; }\n    public System.Nullable<System.TimeSpan> PublishStatsInterval { get; }\n    public int ReduceGossipDifferentViewProbability { get; }\n    public System.Nullable<System.TimeSpan> RetryUnsuccessfulJoinAfter { get; }\n    public System.Collections.Immutable.ImmutableHashSet<string> Roles { get; }\n    public bool RunCoordinatedShutdownWhenDown { get; }\n    public System.TimeSpan SchedulerTickDuration { get; }\n    public int SchedulerTicksPerWheel { get; }\n    public System.TimeSpan SeedNodeTimeout { get; }\n    public System.Collections.Immutable.ImmutableList<Akka.Actor.Address> SeedNodes { get; }\n    public System.Nullable<System.TimeSpan> ShutdownAfterUnsuccessfulJoinSeedNodes { get; }\n    public System.TimeSpan UnreachableNodesReaperInterval { get; }\n    public string UseDispatcher { get; }\n    public bool UseLegacyHeartbeatMessage { get; }\n    public bool VerboseGossipReceivedLogging { get; }\n    public bool VerboseHeartbeatLogging { get; }\n    public System.TimeSpan WeaklyUpAfter { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Split Brain Resolver in Akka.NET HOCON\nDESCRIPTION: Minimal configuration for enabling the Split Brain Resolver in Akka.NET cluster. It sets the downing provider class and specifies an active strategy.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/split-brain-resolver.md#2025-04-16_snippet_0\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster {\n  downing-provider-class = \"Akka.Cluster.SBR.SplitBrainResolverProvider, Akka.Cluster\"\n  split-brain-resolver {\n    active-strategy = <your-strategy>\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DNS Provider and Resolver in Akka.NET\nDESCRIPTION: Classes for DNS resolution in Akka.NET. These include the DNS provider, resolver actor, and a simple cache implementation for storing resolved addresses.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_152\n\nLANGUAGE: C#\nCODE:\n```\npublic class InetAddressDnsProvider : Akka.IO.IDnsProvider\n{\n    public InetAddressDnsProvider() { }\n    public System.Type ActorClass { get; }\n    public Akka.IO.DnsBase Cache { get; }\n    public System.Type ManagerClass { get; }\n}\npublic class InetAddressDnsResolver : Akka.Actor.ActorBase\n{\n    public InetAddressDnsResolver(Akka.IO.SimpleDnsCache cache, Akka.Configuration.Config config) { }\n    protected override bool Receive(object message) { }\n}\npublic class SimpleDnsCache : Akka.IO.DnsBase\n{\n    public SimpleDnsCache() { }\n    public override Akka.IO.Dns.Resolved Cached(string name) { }\n    public void CleanUp() { }\n    protected virtual long Clock() { }\n}\npublic class SimpleDnsManager : Akka.Actor.ActorBase, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedMessageQueueSemantics>\n{\n    public SimpleDnsManager(Akka.IO.DnsExt ext) { }\n    protected override void PostStop() { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Backoff Pattern Implementation in C#\nDESCRIPTION: Implements backoff supervision pattern for actor restart strategies. Includes options for failure handling, stop conditions, and retry configurations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_174\n\nLANGUAGE: C#\nCODE:\n```\npublic static class Backoff\n{\n    [System.ObsoleteAttribute(\"Use the overloaded one which accepts maxNrOfRetries instead.\")]\n    public static Akka.Pattern.BackoffOptions OnFailure(Akka.Actor.Props childProps, string childName, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor) { }\n    public static Akka.Pattern.BackoffOptions OnFailure(Akka.Actor.Props childProps, string childName, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor, int maxNrOfRetries) { }\n}\n```\n\n----------------------------------------\n\nTITLE: AtLeastOnceDeliveryReceiveActor Class Definition in Akka.Persistence\nDESCRIPTION: A receive-style persistent actor with at-least-once delivery semantics. This class provides the same delivery guarantees as AtLeastOnceDeliveryActor but uses the receive actor pattern for message handling rather than the command pattern.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AtLeastOnceDeliveryReceiveActor : Akka.Persistence.ReceivePersistentActor\n{\n    protected AtLeastOnceDeliveryReceiveActor() { }\n    protected AtLeastOnceDeliveryReceiveActor(Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings settings) { }\n    protected AtLeastOnceDeliveryReceiveActor(System.Func<Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings, Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings> overrideSettings) { }\n    public int MaxUnconfirmedMessages { get; }\n    public System.TimeSpan RedeliverInterval { get; }\n    public int RedeliveryBurstLimit { get; }\n    public int UnconfirmedCount { get; }\n    public int WarnAfterNumberOfUnconfirmedAttempts { get; }\n    public override void AroundPostStop() { }\n    public override void AroundPreRestart(System.Exception cause, object message) { }\n    protected override bool AroundReceive(Akka.Actor.Receive receive, object message) { }\n    public bool ConfirmDelivery(long deliveryId) { }\n    public void Deliver(Akka.Actor.ActorPath destination, System.Func<long, object> deliveryMessageMapper) { }\n    public void Deliver(Akka.Actor.ActorSelection destination, System.Func<long, object> deliveryMessageMapper) { }\n    public Akka.Persistence.AtLeastOnceDeliverySnapshot GetDeliverySnapshot() { }\n    protected override void OnReplaySuccess() { }\n    public void SetDeliverySnapshot(Akka.Persistence.AtLeastOnceDeliverySnapshot snapshot) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Subscriber Actor in Akka.NET Cluster\nDESCRIPTION: Example of an actor that subscribes to a named topic (\"content\") in the DistributedPubSub system. It handles subscription confirmation and processes messages from the topic.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/distributed-publish-subscribe.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Subscriber : ReceiveActor\n{\n    private readonly IActorRef _mediator;\n\n    public Subscriber()\n    {\n        // Get a reference to the mediator\n        _mediator = DistributedPubSub.Get(Context.System).Mediator;\n\n        // subscribe to the topic named \"content\"\n        _mediator.Tell(new Subscribe(\"content\", Self));\n\n        Receive<string>(s => \n        {\n            Console.WriteLine($\"Got {s}\");\n        });\n\n        Receive<SubscribeAck>(subscribeAck => \n        {\n            Console.WriteLine($\"subscribing to {subscribeAck.Subscribe.Topic}\");\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ActorPath Class in C#\nDESCRIPTION: Implements the ActorPath class, which represents the address of an actor in the actor system. It includes methods for parsing, comparing, and manipulating actor paths.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ActorPath : Akka.Util.ISurrogated, System.IComparable<Akka.Actor.ActorPath>, System.IEquatable<Akka.Actor.ActorPath>\n{\n    public const string ValidSymbols = \"\\\"-_.*$+:@&=,!~';()\";\n    protected ActorPath(Akka.Actor.Address address, string name) { }\n    protected ActorPath(Akka.Actor.ActorPath parentPath, string name, long uid) { }\n    public Akka.Actor.Address Address { get; }\n    public int Depth { get; }\n    public System.Collections.Generic.IReadOnlyList<string> Elements { get; }\n    public string Name { get; }\n    public Akka.Actor.ActorPath Parent { get; }\n    [Newtonsoft.Json.JsonIgnoreAttribute()]\n    public Akka.Actor.ActorPath Root { get; }\n    public long Uid { get; }\n    // ... (other methods)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating CircuitBreaker with Static Factory Method in C#\nDESCRIPTION: Static factory method to create a CircuitBreaker instance with basic parameters including scheduler, max failures, call timeout, and reset timeout.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_196\n\nLANGUAGE: C#\nCODE:\n```\npublic static Akka.Pattern.CircuitBreaker Create(Akka.Actor.IScheduler scheduler, int maxFailures, System.TimeSpan callTimeout, System.TimeSpan resetTimeout) { }\n```\n\n----------------------------------------\n\nTITLE: Logging Stream Elements with Select in C#\nDESCRIPTION: Demonstrates how to log elements flowing through a stream using Select and Console.WriteLine for basic debugging.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/cookbook.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar mySource = Source.Empty<string>();\n\nvar loggedSource = mySource.Select(element =>\n{\n  Console.WriteLine(element);\n  return element;\n});\n```\n\n----------------------------------------\n\nTITLE: Test Actor and Probe Creation Methods\nDESCRIPTION: Utility methods for creating test actors, probes, barriers and latches for testing actor systems.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic Akka.Actor.IActorRef CreateTestActor(string name) { }\npublic virtual Akka.TestKit.TestProbe CreateTestProbe(string name = null) { }\npublic virtual Akka.TestKit.TestLatch CreateTestLatch(int count = 1) { }\n```\n\n----------------------------------------\n\nTITLE: Simulating Unplanned Node Crashes with TestConductor.Exit in C#\nDESCRIPTION: This snippet shows how to use TestConductor.Exit to simulate an unplanned shutdown (crash) of a node. After exiting, the node will no longer participate in barriers or data collection in the test.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/testing/multi-node-testing-old.md#2025-04-16_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\nRunOn(() => {\n    TestConductor.Exit(_config.Third, 0).Wait();\n}, _config.First);\n```\n\n----------------------------------------\n\nTITLE: Implementing IShardAllocationStrategy Interface in C#\nDESCRIPTION: Defines the IShardAllocationStrategy interface with methods for allocating shards and rebalancing. It inherits from INoSerializationVerificationNeeded.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Net.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IShardAllocationStrategy : Akka.Actor.INoSerializationVerificationNeeded\n{\n    System.Threading.Tasks.Task<Akka.Actor.IActorRef> AllocateShard(Akka.Actor.IActorRef requester, string shardId, System.Collections.Immutable.IImmutableDictionary<Akka.Actor.IActorRef, System.Collections.Immutable.IImmutableList<string>> currentShardAllocations);\n    System.Threading.Tasks.Task<System.Collections.Immutable.IImmutableSet<string>> Rebalance(System.Collections.Immutable.IImmutableDictionary<Akka.Actor.IActorRef, System.Collections.Immutable.IImmutableList<string>> currentShardAllocations, System.Collections.Immutable.IImmutableSet<string> rebalanceInProgress);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ClusterSingletonProxy in Akka.Net using HOCON\nDESCRIPTION: HOCON configuration for ClusterSingletonProxySettings which is passed to the ClusterSingletonProxy.props factory method. These settings control proxy behavior including singleton actor name reference, role targeting, resolution interval, and message buffering capabilities.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-singleton.md#2025-04-16_snippet_5\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster.singleton-proxy {\n  # The actor name of the singleton actor that is started by the ClusterSingletonManager\n  singleton-name = ${akka.cluster.singleton.singleton-name}\n  \n  # The role of the cluster nodes where the singleton can be deployed. \n  # If the role is not specified then any node will do.\n  role = \"\"\n  \n  # Interval at which the proxy will try to resolve the singleton instance.\n  singleton-identification-interval = 1s\n  \n  # If the location of the singleton is unknown the proxy will buffer this\n  # number of messages and deliver them when the singleton is identified. \n  # When the buffer is full old messages will be dropped when new messages are\n  # sent via the proxy.\n  # Use 0 to disable buffering, i.e. messages will be dropped immediately if\n  # the location of the singleton is unknown.\n  # Maximum allowed buffer size is 10000.\n  buffer-size = 1000 \n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NewtonSoftJsonSerializer in C#\nDESCRIPTION: Serializer implementation that uses Newtonsoft.Json to convert objects to and from JSON. Supports configurable serialization settings including type name handling and object reference preservation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_209\n\nLANGUAGE: C#\nCODE:\n```\npublic class NewtonSoftJsonSerializer : Akka.Serialization.Serializer\n    {\n        public NewtonSoftJsonSerializer(Akka.Actor.ExtendedActorSystem system) { }\n        public NewtonSoftJsonSerializer(Akka.Actor.ExtendedActorSystem system, Akka.Configuration.Config config) { }\n        public NewtonSoftJsonSerializer(Akka.Actor.ExtendedActorSystem system, Akka.Serialization.NewtonSoftJsonSerializerSettings settings) { }\n        public override bool IncludeManifest { get; }\n        public object Serializer { get; }\n        public Newtonsoft.Json.JsonSerializerSettings Settings { get; }\n        public override object FromBinary(byte[] bytes, System.Type type) { }\n        public override byte[] ToBinary(object obj) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Disabling XUnit Parallelization with Configuration File\nDESCRIPTION: Provides a JSON configuration for XUnit that disables test collection parallelization. This file should be named 'xunit.runner.json' and copied to the output directory during build.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/testing/multi-node-testing.md#2025-04-16_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n   \"parallelizeTestCollections\" : false,\n   \"parallelizeAssembly\" : false\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Persistent Class in Akka.NET Persistence\nDESCRIPTION: This code defines the `Persistent` class, which represents a persistent message in Akka.NET persistence. It implements the `IPersistentRepresentation` interface and provides properties for the payload, sequence number, persistence ID, manifest, sender, writer GUID, timestamp and deletion status. The `Persistent` class includes methods for updating the message with new sequence numbers, persistence IDs, or other metadata.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic class Persistent : Akka.Persistence.IPersistentRepresentation, Akka.Persistence.Serialization.IMessage, System.IEquatable<Akka.Persistence.IPersistentRepresentation>\n{\n    public Persistent(object payload, long sequenceNr = 0, string persistenceId = null, string manifest = null, bool isDeleted = False, Akka.Actor.IActorRef sender = null, string writerGuid = null, long timestamp = 0) { }\n    public bool IsDeleted { get; }\n    public string Manifest { get; }\n    public object Payload { get; }\n    public string PersistenceId { get; }\n    public Akka.Actor.IActorRef Sender { get; }\n    public long SequenceNr { get; }\n    public long Timestamp { get; }\n    public static string Undefined { get; }\n    public string WriterGuid { get; }\n    public bool Equals(Akka.Persistence.IPersistentRepresentation other) { }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.Persistence.Persistent other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n    public Akka.Persistence.IPersistentRepresentation Update(long sequenceNr, string persistenceId, bool isDeleted, Akka.Actor.IActorRef sender, string writerGuid) { }\n    public Akka.Persistence.IPersistentRepresentation WithManifest(string manifest) { }\n    public Akka.Persistence.IPersistentRepresentation WithPayload(object payload) { }\n    public Akka.Persistence.IPersistentRepresentation WithTimestamp(long newTimestamp) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ORSet in C# for Akka.NET\nDESCRIPTION: This class implements an Observed-Remove Set, a distributed set data structure for Akka.NET. It provides methods for adding, removing, and merging set elements across distributed nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ORSet<T> : FastMerge<ORSet<T>>, IDeltaReplicatedData, IRemovedNodePruning, IReplicatedData, IEnumerable<T>, IEquatable<ORSet<T>>\n{\n    public static readonly ORSet<T> Empty;\n    public ORSet() { }\n    public ORSet(ImmutableDictionary<T, VersionVector> elementsMap, VersionVector versionVector) { }\n    \n    public int Count { get; }\n    public IDeltaOperation Delta { get; }\n    public IImmutableSet<T> Elements { get; }\n    public bool IsEmpty { get; }\n    public ImmutableHashSet<UniqueAddress> ModifiedByNodes { get; }\n    public System.Type SetType { get; }\n    \n    // Method implementations...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DistributedPubSubMediator in C#\nDESCRIPTION: This class implements a DistributedPubSubMediator for Akka.NET, handling publish-subscribe operations in a distributed environment. It includes initialization, logging, and versioning functionality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Net.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class DistributedPubSubMediator : Akka.Actor.ReceiveActor\n{\n    public DistributedPubSubMediator(Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings settings) { }\n    public Akka.Event.ILoggingAdapter Log { get; }\n    public System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, long> OwnVersions { get; }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n    public static Akka.Actor.Props Props(Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings settings) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Multiple Subscribers in C#\nDESCRIPTION: Example showing multiple ISubscriber declarations for implementing fan-out with Reactive Streams.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\nISubscriber<Author> Storage\nISubscriber<Author> Alert\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Persistent Counter Actor in C#\nDESCRIPTION: Initial implementation of a persistent actor that maintains a counter value but lacks proper persistence handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistence-testing.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class CounterActor : UntypedPersistentActor\n{\n    public CounterActor(string id)\n    {\n        PersistenceId = id;\n    }\n\n    private int value = 0;\n\n    public override string PersistenceId { get; }\n\n    protected override void OnCommand(object message)\n    {\n        switch (message as string)\n        {\n            case \"inc\":\n                value++;\n                break;\n\n            case \"dec\":\n                value++;\n                break;\n\n            case \"read\":\n                Sender.Tell(value);\n            \n            default:\n                return;\n        }\n    }\n\n    protected override void OnRecover(object message)\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Switching Handlers at Runtime with Become in C#\nDESCRIPTION: This snippet demonstrates using Become to switch handlers at runtime within an Akka.NET actor, allowing for state transitions such as changing moods. Handlers are defined for different moods, and their transitions upon receiving specific string messages are shown.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka/Util/MatchHandler/README.md#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class MoodActor : ReceiveActor\n{\n  public MoodActor()\n  {\n    Receive<string>(s => s == \"Mood?\", _ => Sender.Tell(\"I'm neutral\"));\n    Receive<string>(s => s == \"Happy\", _ => Become(Happy));\n    Receive<string>(s => s == \"Angry\", _ => Become(Angry));\n  }\n\n  private void Happy()\n  {\n    Receive<string>(s => s == \"Mood?\", _ => Sender.Tell(\"I'm happy\"));\n    Receive<string>(s => s == \"Happy\", _ => Sender.Tell(\"I'm already happy!\", Self));\n    Receive<string>(s => s == \"Angry\", _ => Become(Angry));\n  }\n\n  private void Angry()\n  {\n    Receive<string>(s => s == \"Mood?\", _ => Sender.Tell(\"I'm angry\"));\n    Receive<string>(s => s == \"Angry\", _ => Sender.Tell(\"I'm already angry!\", Self));\n    Receive<string>(s => s == \"Happy\", _ => Become(Happy));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BoundedMailbox in Akka.Dispatch\nDESCRIPTION: The BoundedMailbox class implements a mailbox with a fixed capacity. It provides timeout semantics for handling message overflow conditions and integrates with the Akka.NET messaging infrastructure.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_82\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class BoundedMailbox : Akka.Dispatch.MailboxType, Akka.Dispatch.IProducesMessageQueue<Akka.Dispatch.MessageQueues.BoundedMessageQueue>, Akka.Dispatch.IProducesPushTimeoutSemanticsMailbox\n{\n    public BoundedMailbox(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IChildrenContainer Interface in C#\nDESCRIPTION: This interface defines methods for managing child actors within the Akka.NET actor system. It includes operations for adding, removing, and reserving child actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_59\n\nLANGUAGE: C#\nCODE:\n```\nbool TryGetByRef(Akka.Actor.IActorRef actor, [System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] [System.Runtime.CompilerServices.NullableAttribute(2)] out Akka.Actor.Internal.ChildRestartStats stats);\nAkka.Actor.Internal.IChildrenContainer Unreserve(string name);\n```\n\n----------------------------------------\n\nTITLE: Configuring ShardRegion Message Extractor in C#\nDESCRIPTION: Demonstrates how to set up a message extractor for the ShardRegion to handle SequencedMessage types wrapped in ShardingEnvelopes. This is crucial for the ProducerController to send messages over the wire in a sharded cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-sharding-delivery.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class MessageExtractor : HashCodeMessageExtractor\n{\n    public MessageExtractor(int maxNumberOfShards) : base(maxNumberOfShards)\n    {\n    }\n\n    public override string EntityId(object message)\n    {\n        switch (message)\n        {\n            case ShardingEnvelope env:\n                return env.EntityId;\n            case IConsumerMessage msg:\n                return msg.EntityId;\n            default:\n                return null;\n        }\n    }\n\n    public override object EntityMessage(object message)\n    {\n        switch (message)\n        {\n            case ShardingEnvelope env:\n                return env.Message;\n            default:\n                return message;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Remember Entities Store with Event Sourcing in HOCON\nDESCRIPTION: HOCON configuration for setting up event sourced storage for remembered entities in Akka.NET Cluster Sharding using MongoDB as the persistence backend.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-sharding.md#2025-04-16_snippet_6\n\nLANGUAGE: hocon\nCODE:\n```\nakka.persistence {\n    journal {\n        plugin = \"akka.persistence.journal.mongodb\"\n        mongodb {\n            class = \"Akka.Persistence.MongoDb.Journal.MongoDbJournal, Akka.Persistence.MongoDb\"\n            connection-string = \"\"\n            collection = \"EventJournal\"\n            metadata-collection = \"Metadata\"\n        }\n        sharding {\n            class = \"Akka.Persistence.MongoDb.Journal.MongoDbJournal, Akka.Persistence.MongoDb\"\n            connection-string = \"\"\n            collection = \"EventJournalSharding\"\n            metadata-collection = \"MetadataSharding\"\n        }\n    }\n    snapshot-store {\n        plugin = \"akka.persistence.snapshot-store.mongodb\"\n        mongodb {\n            class = \"Akka.Persistence.MongoDb.Snapshot.MongoDbSnapshotStore, Akka.Persistence.MongoDb\"\n            connection-string = \"\"\n            collection = \"SnapshotStore\"\n        }\n        sharding {\n            class = \"Akka.Persistence.MongoDb.Snapshot.MongoDbSnapshotStore, Akka.Persistence.MongoDb\"\n            connection-string = \"\"\n            collection = \"SnapshotStoreSharding\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fan-In Stream Stages in Akka.NET\nDESCRIPTION: Documentation of stream stages that combine multiple input streams into a single output stream using various merging strategies\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/builtinstages.md#2025-04-16_snippet_12\n\nLANGUAGE: markdown\nCODE:\n```\n### Merge\n\nMerge multiple sources. Picks elements randomly if all sources has elements ready.\n```\n\nLANGUAGE: markdown\nCODE:\n```\n### MergeSorted\n\nMerge multiple sources. Waits for one element to be ready from each input stream and emits the\nsmallest element.\n```\n\n----------------------------------------\n\nTITLE: Implementing ByteString Chunker in C# for Akka.NET Streams\nDESCRIPTION: This code defines a Chunker GraphStage that splits incoming ByteStrings into smaller chunks of a specified size. It's useful for processing large ByteStrings in manageable pieces.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/cookbook.md#2025-04-16_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Chunker : GraphStage<FlowShape<ByteString, ByteString>>\n{\n    private sealed class Logic : GraphStageLogic\n    {\n        private readonly Chunker _chunker;\n        private ByteString _buffer = ByteString.Empty;\n\n        public Logic(Chunker chunker) : base(chunker.Shape)\n        {\n            _chunker = chunker;\n\n            SetHandler(chunker.Out, onPull: () =>\n            {\n                if (IsClosed(chunker.In))\n                    EmitChunk();\n                else\n                    Pull(chunker.In);\n            });\n\n            SetHandler(chunker.In, onPush: () =>\n            {\n                var element = Grab(chunker.In);\n                _buffer += element;\n                EmitChunk();\n            }, onUpstreamFinish: () =>\n            {\n                if(_buffer.IsEmpty)\n                    CompleteStage();\n                // elements left in buffer, keep accepting downstream pulls\n                // and push from buffer until buffer is emitted\n            });\n        }\n\n        private void EmitChunk()\n        {\n            if (_buffer.IsEmpty)\n            {\n                if (IsClosed(_chunker.In))\n                    CompleteStage();\n                else\n                    Pull(_chunker.In);\n            }\n            else\n            {\n                var t = _buffer.SplitAt(_chunker._chunkSize);\n                var chunk = t.Item1;\n                var nextBuffer = t.Item2;\n\n                _buffer = nextBuffer;\n                Push(_chunker.Out, chunk);\n            }\n        }\n    }\n\n    private readonly int _chunkSize;\n\n    public Chunker(int chunkSize)\n    {\n        _chunkSize = chunkSize;\n        Shape = new FlowShape<ByteString, ByteString>(In, Out);\n    }\n\n    public Inlet<ByteString> In { get; }= new Inlet<ByteString>(\"Chunker.in\");\n\n    public Outlet<ByteString> Out { get; } = new Outlet<ByteString>(\"Chunker.out\");\n\n    public override FlowShape<ByteString, ByteString> Shape { get; }\n\n    protected override GraphStageLogic CreateLogic(Attributes inheritedAttributes) => new Logic(this);\n}\n\nvar rawBytes = Source.Empty<ByteString>();\nvar chunkStream = rawBytes.Via(new Chunker(ChunkLimit));\n```\n\n----------------------------------------\n\nTITLE: Implementing Logging Extension Methods in C#\nDESCRIPTION: Static extension methods for ILoggingAdapter that provide convenient overloads for debug and error logging with various numbers of parameters. These methods simplify logging calls by providing type-safe methods with different parameter counts.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_134\n\nLANGUAGE: C#\nCODE:\n```\npublic class static LoggingExtensions\n{\n    public static void Debug(this Akka.Event.ILoggingAdapter log, string format) { }\n    public static void Debug(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format) { }\n    public static void Debug<T1>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1) { }\n    public static void Debug<T1>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1) { }\n    public static void Debug<T1, T2>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2) { }\n    public static void Debug<T1, T2>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2) { }\n    public static void Debug<T1, T2, T3>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3) { }\n    public static void Debug<T1, T2, T3>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3) { }\n    public static void Debug<T1, T2, T3, T4>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4) { }\n    public static void Debug<T1, T2, T3, T4>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4) { }\n    public static void Debug<T1, T2, T3, T4, T5>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) { }\n    public static void Debug<T1, T2, T3, T4, T5>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) { }\n    public static void Debug<T1, T2, T3, T4, T5, T6>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) { }\n    public static void Debug<T1, T2, T3, T4, T5, T6>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) { }\n    public static void Debug(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, object[] args) { }\n    public static void Debug(this Akka.Event.ILoggingAdapter log, string format, object[] args) { }\n    public static void Error(this Akka.Event.ILoggingAdapter log, string format) { }\n    public static void Error(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format) { }\n    public static void Error<T1>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1) { }\n    public static void Error<T1>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Throttling Mechanisms in Akka.NET Remote\nDESCRIPTION: Classes for throttling network traffic. ThrottleMode is an abstract base class for throttling strategies, TokenBucket implements a token bucket rate limiting algorithm, and ThrottleTransportAdapter applies throttling to remote transport.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ThrottleMode : Akka.Actor.INoSerializationVerificationNeeded\n{\n    protected ThrottleMode() { }\n    public abstract System.TimeSpan TimeToAvailable(long currentNanoTime, int tokens);\n    public abstract System.ValueTuple<Akka.Remote.Transport.ThrottleMode, bool> TryConsumeTokens(long nanoTimeOfSend, int tokens);\n}\n\npublic sealed class TokenBucket : Akka.Remote.Transport.ThrottleMode\n{\n    public TokenBucket(int capacity, double tokensPerSecond, long nanoTimeOfLastSend, int availableTokens) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override System.TimeSpan TimeToAvailable(long currentNanoTime, int tokens) { }\n    public override System.ValueTuple<Akka.Remote.Transport.ThrottleMode, bool> TryConsumeTokens(long nanoTimeOfSend, int tokens) { }\n}\n\npublic class ThrottleTransportAdapter : Akka.Remote.Transport.ActorTransportAdapter\n{\n    public const string Scheme = \"trttl\";\n    public static readonly Akka.Util.Internal.AtomicCounter UniqueId;\n    public ThrottleTransportAdapter(Akka.Remote.Transport.Transport wrappedTransport, Akka.Actor.ActorSystem system) { }\n    protected override string ManagerName { get; }\n    protected override Akka.Actor.Props ManagerProps { get; }\n    protected override Akka.Remote.Transport.SchemeAugmenter SchemeAugmenter { get; }\n    public override System.Threading.Tasks.Task<bool> ManagementCommand(object message) { }\n    public enum Direction\n    {\n        Send = 0,\n        Receive = 1,\n        Both = 2,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Bounded Message Queue in Akka.NET\nDESCRIPTION: Defines a bounded message queue for actors with capacity constraints and timeout functionality. Provides methods for enqueueing and dequeueing messages with bounded capacity semantics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_108\n\nLANGUAGE: C#\nCODE:\n```\npublic class BoundedMessageQueue : Akka.Dispatch.IBoundedMessageQueueSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.MessageQueues.IMessageQueue\n{\n    public BoundedMessageQueue(Akka.Configuration.Config config) { }\n    public BoundedMessageQueue(int boundedCapacity, System.TimeSpan pushTimeOut) { }\n    public int Count { get; }\n    public bool HasMessages { get; }\n    public System.TimeSpan PushTimeOut { get; set; }\n    public void CleanUp(Akka.Actor.IActorRef owner, Akka.Dispatch.MessageQueues.IMessageQueue deadletters) { }\n    public void Enqueue(Akka.Actor.IActorRef receiver, Akka.Actor.Envelope envelope) { }\n    public bool TryDequeue(out Akka.Actor.Envelope envelope) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EventAdapters Factory in Akka.NET\nDESCRIPTION: Defines an EventAdapters factory class for creating and managing event adapters in Akka.NET persistence, with methods for adapter creation and type-based adapter retrieval.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_50\n\nLANGUAGE: csharp\nCODE:\n```\npublic class EventAdapters\n{\n    protected EventAdapters(System.Collections.Concurrent.ConcurrentDictionary<System.Type, Akka.Persistence.Journal.IEventAdapter> map, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.Type, Akka.Persistence.Journal.IEventAdapter>> bindings, Akka.Event.ILoggingAdapter log) { }\n    public static Akka.Persistence.Journal.EventAdapters Create(Akka.Actor.ExtendedActorSystem system, Akka.Configuration.Config config) { }\n    public Akka.Persistence.Journal.IEventAdapter Get<T>() { }\n    public virtual Akka.Persistence.Journal.IEventAdapter Get(System.Type type) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ORSet Class for Akka.NET\nDESCRIPTION: Implementation of an Observed-Remove Set (ORSet) that supports distributed operations. Includes methods for adding, removing elements and merging sets across cluster nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ORSet<T> : Akka.DistributedData.FastMerge<Akka.DistributedData.ORSet<T>>, Akka.DistributedData.IDeltaReplicatedData, Akka.DistributedData.IDeltaReplicatedData<Akka.DistributedData.ORSet<T>, Akka.DistributedData.ORSet<T>.IDeltaOperation>, Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IRemovedNodePruning<Akka.DistributedData.ORSet<T>>, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.ORSet<T>>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.IEquatable<Akka.DistributedData.ORSet<T>>\n```\n\n----------------------------------------\n\nTITLE: Testing Akka.NET FSM Actor\nDESCRIPTION: This code provides a unit test for the Buncher FSM actor, verifying its behavior with various message sequences and state transitions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/finite-state-machine.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/core/Akka.Docs.Tests/Actors/FiniteStateMachine/ExampleFSMActorTests.cs?name=FSMTest)]\n```\n\n----------------------------------------\n\nTITLE: Implementing System Messages for Akka.NET Actor Management in C#\nDESCRIPTION: A collection of system message classes used for internal actor communication, lifecycle management, and supervision. These messages handle operations like actor creation, termination, and error handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_111\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.Dispatch.SysMsg\n{\n    public sealed class ActorTask : Akka.Dispatch.SysMsg.SystemMessage\n    {\n        public ActorTask(System.Threading.Tasks.Task task) { }\n        public System.Threading.Tasks.Task Task { get; }\n    }\n    public sealed class Create : Akka.Dispatch.SysMsg.SystemMessage\n    {\n        public Create(Akka.Actor.ActorInitializationException failure = null) { }\n        public Akka.Actor.ActorInitializationException Failure { get; }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n    }\n    public sealed class DeathWatchNotification : Akka.Dispatch.SysMsg.SystemMessage, Akka.Event.IDeadLetterSuppression\n    {\n        public DeathWatchNotification(Akka.Actor.IActorRef actor, bool existenceConfirmed, bool addressTerminated) { }\n        public Akka.Actor.IActorRef Actor { get; }\n        public bool AddressTerminated { get; }\n        public bool ExistenceConfirmed { get; }\n        public override string ToString() { }\n    }\n    public sealed class Escalate : Akka.Dispatch.SysMsg.SystemMessage\n    {\n        public Escalate(System.Exception reason) { }\n        public System.Exception Reason { get; }\n        public override string ToString() { }\n    }\n    [Akka.Annotations.InternalApiAttribute()]\n    public sealed class Failed : Akka.Dispatch.SysMsg.SystemMessage\n    {\n        public Failed(Akka.Actor.IActorRef child, System.Exception cause, long uid) { }\n        public System.Exception Cause { get; }\n        public Akka.Actor.IActorRef Child { get; }\n        public long Uid { get; }\n        public override string ToString() { }\n    }\n    public interface ISystemMessage : Akka.Actor.INoSerializationVerificationNeeded { }\n    public sealed class NoMessage : Akka.Dispatch.SysMsg.SystemMessage\n    {\n        public NoMessage() { }\n        public override string ToString() { }\n    }\n    public sealed class Recreate : Akka.Dispatch.SysMsg.SystemMessage\n    {\n        public Recreate(System.Exception cause) { }\n        public System.Exception Cause { get; }\n        public override string ToString() { }\n    }\n    public sealed class RegisterTerminationHook\n    {\n        public static Akka.Dispatch.SysMsg.RegisterTerminationHook Instance { get; }\n        public override string ToString() { }\n    }\n    public sealed class Resume : Akka.Dispatch.SysMsg.SystemMessage\n    {\n        public Resume(System.Exception causedByFailure) { }\n        public System.Exception CausedByFailure { get; set; }\n        public override string ToString() { }\n    }\n    public sealed class Stop : Akka.Dispatch.SysMsg.SystemMessage\n    {\n        public Stop() { }\n        public override string ToString() { }\n    }\n    public sealed class StopChild\n    {\n        public StopChild(Akka.Actor.IActorRef child) { }\n        public Akka.Actor.IActorRef Child { get; }\n        public override string ToString() { }\n    }\n    public sealed class Supervise : Akka.Dispatch.SysMsg.SystemMessage\n    {\n        public Supervise(Akka.Actor.IActorRef child, bool async) { }\n        public bool Async { get; }\n        public Akka.Actor.IActorRef Child { get; }\n        public override string ToString() { }\n    }\n    public sealed class Suspend : Akka.Dispatch.SysMsg.SystemMessage\n    {\n        public Suspend() { }\n        public override string ToString() { }\n    }\n    [Akka.Annotations.InternalStableApiAttribute()]\n    public abstract class SystemMessage : Akka.Actor.INoSerializationVerificationNeeded, Akka.Dispatch.SysMsg.ISystemMessage\n    {\n        protected SystemMessage() { }\n        public bool Unlinked { get; }\n        public void Unlink() { }\n    }\n    public sealed class Terminate : Akka.Dispatch.SysMsg.SystemMessage, Akka.Actor.IPossiblyHarmful, Akka.Event.IDeadLetterSuppression\n    {\n        public Terminate() { }\n        public override string ToString() { }\n    }\n    public sealed class TerminationHook\n    {\n        public static Akka.Dispatch.SysMsg.TerminationHook Instance { get; }\n        public override string ToString() { }\n    }\n    public sealed class TerminationHookDone\n    {\n        public static Akka.Dispatch.SysMsg.TerminationHookDone Instance { get; }\n        public override string ToString() { }\n    }\n    public sealed class Unwatch : Akka.Dispatch.SysMsg.SystemMessage\n    {\n        public Unwatch(Akka.Actor.IInternalActorRef watchee, Akka.Actor.IInternalActorRef watcher) { }\n        public Akka.Actor.IInternalActorRef Watchee { get; }\n        public Akka.Actor.IInternalActorRef Watcher { get; }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n    }\n    public class Watch : Akka.Dispatch.SysMsg.SystemMessage\n    {\n        public Watch(Akka.Actor.IInternalActorRef watchee, Akka.Actor.IInternalActorRef watcher) { }\n        public Akka.Actor.IInternalActorRef Watchee { get; }\n        public Akka.Actor.IInternalActorRef Watcher { get; }\n        protected bool Equals(Akka.Dispatch.SysMsg.Watch other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fishing for Messages in Akka.NET TestKitBase\nDESCRIPTION: These methods allow for searching for specific messages within a time limit. They support both synchronous and asynchronous operations with optional conditions and cancellation tokens.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\npublic object FishForMessage(System.Predicate<object> isMessage, System.Nullable<System.TimeSpan> max = null, string hint = \"\", System.Threading.CancellationToken cancellationToken = null) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic T FishForMessage<T>(System.Predicate<T> isMessage, System.Nullable<System.TimeSpan> max = null, string hint = \"\", System.Threading.CancellationToken cancellationToken = null) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic System.Threading.Tasks.ValueTask<object> FishForMessageAsync(System.Predicate<object> isMessage, System.Nullable<System.TimeSpan> max = null, string hint = \"\", System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Abstract SnapshotStore Class Implementation in C#\nDESCRIPTION: Defines the base abstract class for snapshot storage in Akka.NET with core methods for saving, loading, and deleting snapshots. Includes abstract methods that must be implemented by concrete classes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_54\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class SnapshotStore : Akka.Actor.ActorBase {\n    protected SnapshotStore() { }\n    protected abstract System.Threading.Tasks.Task DeleteAsync(Akka.Persistence.SnapshotMetadata metadata);\n    protected abstract System.Threading.Tasks.Task DeleteAsync(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria);\n    protected abstract System.Threading.Tasks.Task<Akka.Persistence.SelectedSnapshot> LoadAsync(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria);\n    protected virtual bool Receive(object message) { }\n    protected virtual bool ReceivePluginInternal(object message) { }\n    protected abstract System.Threading.Tasks.Task SaveAsync(Akka.Persistence.SnapshotMetadata metadata, object snapshot);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LoggingAdapterBase abstract class\nDESCRIPTION: Abstract base class for logging adapters that provides common implementation of the ILoggingAdapter interface. It includes methods for checking log levels and logging messages with formatted output, while delegating specific notification behaviors to derived classes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_146\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class LoggingAdapterBase : Akka.Event.ILoggingAdapter\n{\n    protected LoggingAdapterBase(Akka.Event.ILogMessageFormatter logMessageFormatter) { }\n    public Akka.Event.ILogMessageFormatter Formatter { get; }\n    public abstract bool IsDebugEnabled { get; }\n    public abstract bool IsErrorEnabled { get; }\n    public abstract bool IsInfoEnabled { get; }\n    public abstract bool IsWarningEnabled { get; }\n    public bool IsEnabled(Akka.Event.LogLevel logLevel) { }\n    public void Log(Akka.Event.LogLevel logLevel, System.Exception cause, Akka.Event.LogMessage message) { }\n    public void Log(Akka.Event.LogLevel logLevel, System.Exception cause, string format) { }\n    protected abstract void NotifyLog(Akka.Event.LogLevel logLevel, object message, System.Exception cause = null);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Network Partitions with TestConductor.Blackhole in C#\nDESCRIPTION: This snippet demonstrates how to create a network partition between two nodes using the TestConductor.Blackhole method. It creates 100% packet loss between nodes named 'First' and 'Second', preventing them from communicating over Akka.Remote.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/testing/multi-node-testing-old.md#2025-04-16_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nRunOn(() =>\n{\n    TestConductor.Blackhole(_config.First, _config.Second, \n        ThrottleTransportAdapter.Direction.Both).Wait();\n}, _config.First);\nEnterBarrier(\"blackhole-2\");\n```\n\n----------------------------------------\n\nTITLE: RelativeActorPath Utility in Akka.NET (C#)\nDESCRIPTION: Static utility class for working with relative actor paths, providing methods to parse and manipulate actor path addresses.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\npublic class static RelativeActorPath\n{\n    public static System.Collections.Generic.IEnumerable<string> Unapply(string addr) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Task with PipeTo Method in C#\nDESCRIPTION: Extends the Task class with a PipeTo method to pipe task results to an actor. It allows specifying success and failure handlers, as well as configuring the sender and await behavior.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\npublic static System.Threading.Tasks.Task PipeTo(this System.Threading.Tasks.Task taskToPipe, Akka.Actor.ICanTell recipient, bool useConfigureAwait, Akka.Actor.IActorRef sender = null, System.Func<object> success = null, System.Func<System.Exception, object> failure = null) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing AsyncWriteJournal in C#\nDESCRIPTION: Defines the abstract AsyncWriteJournal class that extends WriteJournalBase and implements IAsyncRecovery. This class provides the framework for asynchronous journal operations in Akka.NET Persistence, including message replay and persistence.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_52\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AsyncWriteJournal : Akka.Persistence.Journal.WriteJournalBase, Akka.Persistence.Journal.IAsyncRecovery\n{\n    protected readonly bool CanPublish;\n    protected AsyncWriteJournal() { }\n    protected abstract System.Threading.Tasks.Task DeleteMessagesToAsync(string persistenceId, long toSequenceNr);\n    public abstract System.Threading.Tasks.Task<long> ReadHighestSequenceNrAsync(string persistenceId, long fromSequenceNr);\n    protected virtual bool Receive(object message) { }\n    protected virtual bool ReceivePluginInternal(object message) { }\n    protected bool ReceiveWriteJournal(object message) { }\n    public abstract System.Threading.Tasks.Task ReplayMessagesAsync(Akka.Actor.IActorContext context, string persistenceId, long fromSequenceNr, long toSequenceNr, long max, System.Action<Akka.Persistence.IPersistentRepresentation> recoveryCallback);\n    protected static System.Exception TryUnwrapException(System.Exception e) { }\n    protected abstract System.Threading.Tasks.Task<System.Collections.Immutable.IImmutableList<System.Exception>> WriteMessagesAsync(System.Collections.Generic.IEnumerable<Akka.Persistence.AtomicWrite> messages);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract Transport Adapter in C#\nDESCRIPTION: Base class for transport adapters in Akka.NET remote system. Provides core functionality for associating with remote addresses and handling transport-level operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AbstractTransportAdapter : Akka.Remote.Transport.Transport\n{\n    protected Akka.Remote.Transport.Transport WrappedTransport;\n    protected AbstractTransportAdapter(Akka.Remote.Transport.Transport wrappedTransport) { }\n    public override long MaximumPayloadBytes { get; }\n    protected abstract Akka.Remote.Transport.SchemeAugmenter SchemeAugmenter { get; }\n    public override string SchemeIdentifier { get; }\n    public override System.Threading.Tasks.Task<Akka.Remote.Transport.AssociationHandle> Associate(Akka.Actor.Address remoteAddress) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Using SelectAsyncUnordered with SometimesSlowService in C#\nDESCRIPTION: This snippet illustrates the use of SelectAsyncUnordered with the SometimesSlowService, enabling the processing of tasks while not preserving the input order in the output. The code demonstrates how the results can complete out of order.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar service = new SometimesSlowService(_output);\nvar settings = ActorMaterializerSettings.Create(sys).WithInputBuffer(4, 4);\nvar materializer = sys.Materializer(settings);\n\nvar result = Source.From(new[] {\"a\", \"B\", \"C\", \"D\", \"e\", \"F\", \"g\", \"H\", \"i\", \"J\"})\n    .Select(x => {\n        Console.WriteLine($\"before {x}\");\n        return x;\n    })\n    .SelectAsyncUnordered(4, service.Convert)\n    .RunForeach(x => Console.WriteLine($\"after: {x}\"), materializer);\n```\n\n----------------------------------------\n\nTITLE: Implementing HOCON Parser Class in C#\nDESCRIPTION: The Parser class provides functionality for parsing HOCON configuration text into a structured object model. It includes methods for parsing arrays and values, with support for including external configuration files.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_74\n\nLANGUAGE: C#\nCODE:\n```\npublic class Parser\n{\n    public Parser() { }\n    public static Akka.Configuration.Hocon.HoconRoot Parse(string text, System.Func<string, Akka.Configuration.Hocon.HoconRoot> includeCallback) { }\n    public Akka.Configuration.Hocon.HoconArray ParseArray(string currentPath) { }\n    public void ParseValue(Akka.Configuration.Hocon.HoconValue owner, string currentPath) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing HoldWithInitial GraphStage in Akka.NET\nDESCRIPTION: Custom GraphStage implementation that repeats the last seen element with an initial value. Handles backpressure by immediately pulling from upstream and pushing the current value downstream.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/cookbook.md#2025-04-16_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class HoldWithInitial<T> : GraphStage<FlowShape<T, T>>\n{\n    private sealed class Logic : GraphStageLogic\n    {\n        private readonly HoldWithInitial<T> _holder;\n        private T _currentValue;\n  \n        public Logic(HoldWithInitial<T> holder) : base(holder.Shape)\n        {\n            _holder = holder;\n            _currentValue = holder._initial;\n  \n            SetHandler(holder.In, onPush: () =>\n            {\n                _currentValue = Grab(holder.In);\n                Pull(holder.In);\n            });\n  \n            SetHandler(holder.Out, onPull: () => Push(holder.Out, _currentValue));\n        }\n  \n        public override void PreStart() => Pull(_holder.In);\n    }\n  \n    private readonly T _initial;\n  \n    public HoldWithInitial(T initial)\n    {\n        _initial = initial;\n        Shape = new FlowShape<T, T>(In, Out);\n    }\n  \n    public Inlet<T> In { get; } = new Inlet<T>(\"HoldWithInitial.in\");\n  \n    public Outlet<T> Out { get; } = new Outlet<T>(\"HoldWithInitial.out\");\n  \n    public override FlowShape<T, T> Shape { get; }\n  \n    protected override GraphStageLogic CreateLogic(Attributes inheritedAttributes) => new Logic(this);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Akka.NET TestScheduler Class\nDESCRIPTION: Defines a TestScheduler class that implements multiple Akka.NET scheduler interfaces for testing purposes. Provides methods for scheduling one-time and repeated actions with configurable delays and intervals.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestScheduler : Akka.Actor.IActionScheduler, Akka.Actor.IAdvancedScheduler, Akka.Actor.IRunnableScheduler, Akka.Actor.IScheduler, Akka.Actor.ITellScheduler, Akka.Actor.ITimeProvider\n{\n    public TestScheduler(Akka.Configuration.Config schedulerConfig, Akka.Event.ILoggingAdapter log) { }\n    public Akka.Actor.IAdvancedScheduler Advanced { get; }\n    public System.TimeSpan HighResMonotonicClock { get; }\n    public System.TimeSpan MonotonicClock { get; }\n    public System.DateTimeOffset Now { get; }\n    protected System.DateTimeOffset TimeNow { get; }\n    public void Advance(System.TimeSpan offset) { }\n    public void AdvanceTo(System.DateTimeOffset when) { }\n    public void ScheduleOnce(System.TimeSpan delay, System.Action action, Akka.Actor.ICancelable cancelable) { }\n    public void ScheduleOnce(System.TimeSpan delay, System.Action action) { }\n    public void ScheduleOnce(System.TimeSpan delay, Akka.Dispatch.IRunnable action, Akka.Actor.ICancelable cancelable) { }\n    public void ScheduleOnce(System.TimeSpan delay, Akka.Dispatch.IRunnable action) { }\n    public void ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action, Akka.Actor.ICancelable cancelable) { }\n    public void ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action) { }\n    public void ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Dispatch.IRunnable action, Akka.Actor.ICancelable cancelable) { }\n    public void ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Dispatch.IRunnable action) { }\n    public void ScheduleTellOnce(System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender) { }\n    public void ScheduleTellOnce(System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable) { }\n    public void ScheduleTellRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender) { }\n    public void ScheduleTellRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TestProbe Class for Akka.NET Testing\nDESCRIPTION: The TestProbe class provides methods for creating and interacting with test actors in Akka.NET. It includes methods for sending messages, creating child actors, and comparing probes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestProbe : IComparable\n{\n    public Akka.Actor.IActorRef Ref { get; }\n    public Akka.Actor.IActorRef Sender { get; }\n    public Akka.Actor.IActorRef ChildActorOf<T>(string name, Akka.Actor.SupervisorStrategy supervisorStrategy, System.Threading.CancellationToken cancellationToken = null)\n        where T : Akka.Actor.ActorBase { }\n    public Akka.Actor.IActorRef ChildActorOf<T>(Akka.Actor.SupervisorStrategy supervisorStrategy, System.Threading.CancellationToken cancellationToken = null)\n        where T : Akka.Actor.ActorBase { }\n    public Akka.Actor.IActorRef ChildActorOf<T>(string name, System.Threading.CancellationToken cancellationToken = null)\n        where T : Akka.Actor.ActorBase { }\n    public Akka.Actor.IActorRef ChildActorOf<T>(System.Threading.CancellationToken cancellationToken = null)\n        where T : Akka.Actor.ActorBase { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> ChildActorOfAsync<T>(string name, Akka.Actor.SupervisorStrategy supervisorStrategy, System.Threading.CancellationToken cancellationToken = null)\n        where T : Akka.Actor.ActorBase { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> ChildActorOfAsync<T>(Akka.Actor.SupervisorStrategy supervisorStrategy, System.Threading.CancellationToken cancellationToken = null)\n        where T : Akka.Actor.ActorBase { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> ChildActorOfAsync<T>(string name, System.Threading.CancellationToken cancellationToken = null)\n        where T : Akka.Actor.ActorBase { }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> ChildActorOfAsync<T>(System.Threading.CancellationToken cancellationToken = null)\n        where T : Akka.Actor.ActorBase { }\n    public int CompareTo(object obj) { }\n    [System.ObsoleteAttribute(\"Cannot create a TestProbe from a TestProbe\", true)]\n    public override Akka.TestKit.TestProbe CreateTestProbe(string name = null) { }\n    public override bool Equals(object obj) { }\n    public void Forward(Akka.Actor.IActorRef actor, object message) { }\n    public void Forward(Akka.Actor.IActorRef actor) { }\n    public override int GetHashCode() { }\n    public void Reply(object message) { }\n    public void Send(Akka.Actor.IActorRef actor, object message) { }\n    public void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message, Akka.Actor.IActorRef sender) { }\n    public void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: ByteString Class Definition in Akka.NET\nDESCRIPTION: Defines an immutable sequence of bytes with various methods for creation, manipulation, and conversion. ByteString provides efficient byte buffer handling with operations for concatenation, slicing, searching, and converting to/from different formats.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_153\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ByteString : System.Collections.Generic.IEnumerable<byte>, System.Collections.IEnumerable, System.IEquatable<Akka.IO.ByteString>\n    {\n        public int Count { get; }\n        public static Akka.IO.ByteString Empty { get; }\n        public bool IsCompact { get; }\n        public bool IsEmpty { get; }\n        public byte this[int index] { get; }\n        public Akka.IO.ByteString Compact() { }\n        public Akka.IO.ByteString Concat(Akka.IO.ByteString other) { }\n        public static Akka.IO.ByteString CopyFrom(byte[] array) { }\n        public static Akka.IO.ByteString CopyFrom(System.ArraySegment<byte> buffer) { }\n        public static Akka.IO.ByteString CopyFrom(byte[] array, int offset, int count) { }\n        public static Akka.IO.ByteString CopyFrom(System.Memory<byte> memory) { }\n        public static Akka.IO.ByteString CopyFrom(System.Memory<byte> memory, int offset, int count) { }\n        public static Akka.IO.ByteString CopyFrom(System.Span<byte> span) { }\n        public static Akka.IO.ByteString CopyFrom(System.Span<byte> span, int offset, int count) { }\n        public static Akka.IO.ByteString CopyFrom(System.Collections.Generic.IEnumerable<System.ArraySegment<byte>> buffers) { }\n        public int CopyTo(byte[] buffer, int index, int count) { }\n        public int CopyTo(ref System.Memory<byte> buffer) { }\n        public int CopyTo(ref System.Memory<byte> buffer, int index, int count) { }\n        public int CopyTo(ref System.Span<byte> buffer) { }\n        public int CopyTo(ref System.Span<byte> buffer, int index, int count) { }\n        public override bool Equals(object obj) { }\n        public bool Equals(Akka.IO.ByteString other) { }\n        public static Akka.IO.ByteString FromBytes(byte[] array) { }\n        public static Akka.IO.ByteString FromBytes(System.ArraySegment<byte> buffer) { }\n        public static Akka.IO.ByteString FromBytes(byte[] array, int offset, int count) { }\n        public static Akka.IO.ByteString FromBytes(System.Collections.Generic.IEnumerable<System.ArraySegment<byte>> buffers) { }\n        public static Akka.IO.ByteString FromString(string str) { }\n        public static Akka.IO.ByteString FromString(string str, System.Text.Encoding encoding) { }\n        public System.Collections.Generic.IEnumerator<byte> GetEnumerator() { }\n        public override int GetHashCode() { }\n        public bool HasSubstring(Akka.IO.ByteString other, int index) { }\n        public int IndexOf(byte b) { }\n        public int IndexOf(byte b, int from) { }\n        public Akka.IO.ByteString Slice(int index) { }\n        public Akka.IO.ByteString Slice(int index, int count) { }\n        public byte[] ToArray() { }\n        public System.ReadOnlySpan<byte> ToReadOnlySpan() { }\n        public override string ToString() { }\n        public string ToString(System.Text.Encoding encoding) { }\n        public void WriteTo(System.IO.Stream stream) { }\n        public System.Threading.Tasks.Task WriteToAsync(System.IO.Stream stream) { }\n        public static Akka.IO.ByteString +(Akka.IO.ByteString x, Akka.IO.ByteString y) { }\n        public static bool ==(Akka.IO.ByteString x, Akka.IO.ByteString y) { }\n        public static Akka.IO.ByteString op_Explicit(byte[] bytes) { }\n        public static byte[] op_Explicit(Akka.IO.ByteString byteString) { }\n        public static bool !=(Akka.IO.ByteString x, Akka.IO.ByteString y) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing DeadLetterListener Class in C#\nDESCRIPTION: An actor class that listens for and handles dead letter messages. It implements the actor lifecycle methods and the Receive method for processing dead letter messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_116\n\nLANGUAGE: C#\nCODE:\n```\npublic class DeadLetterListener : Akka.Actor.ActorBase\n{\n    public DeadLetterListener() { }\n    protected override void PostRestart(System.Exception reason) { }\n    protected override void PostStop() { }\n    protected override void PreRestart(System.Exception reason, object message) { }\n    protected override void PreStart() { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: System Guardian Actor Implementation\nDESCRIPTION: Implementation of the system guardian actor that requires unbounded message queue semantics\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_52\n\nLANGUAGE: C#\nCODE:\n```\npublic class SystemGuardianActor : Akka.Actor.ActorBase, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedMessageQueueSemantics>\n{\n    public SystemGuardianActor(Akka.Actor.IActorRef userGuardian) { }\n    protected override void PreRestart(System.Exception reason, object message) { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IDeadLetterSuppression Interface in C#\nDESCRIPTION: A marker interface used to identify objects that should not generate dead letter notifications when undelivered.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_127\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IDeadLetterSuppression { }\n```\n\n----------------------------------------\n\nTITLE: Defining Delegate Types for Entity and Shard ID Extraction in C#\nDESCRIPTION: Delegate types for extracting entity ID and shard ID from messages in Akka.NET cluster sharding.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic delegate Akka.Util.Option<System.ValueTuple<string, object>> ExtractEntityId(object message);\npublic delegate string ExtractShardId(object message);\n```\n\n----------------------------------------\n\nTITLE: Journal Exception Class in C#\nDESCRIPTION: Defines the JournalBufferOverflowException class which is thrown when the journal buffer is full. It inherits from AkkaException and provides a singleton instance.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic class JournalBufferOverflowException : Akka.Actor.AkkaException\n{\n    public static readonly Akka.Persistence.Sql.Common.Journal.JournalBufferOverflowException Instance;\n    public JournalBufferOverflowException() { }\n    protected JournalBufferOverflowException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ConcurrentSet for Thread-Safe Set Operations in C#\nDESCRIPTION: Defines the ConcurrentSet<T> class for thread-safe set operations in Akka.NET. It implements ICollection<T> and IEnumerable<T> interfaces, providing methods for adding, removing, and checking elements concurrently.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_207\n\nLANGUAGE: C#\nCODE:\n```\npublic class ConcurrentSet<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable\n{\n    public ConcurrentSet() { }\n    public ConcurrentSet(System.Collections.Generic.IEnumerable<T> collection) { }\n    public ConcurrentSet(System.Collections.Generic.IEqualityComparer<T> comparer) { }\n    public ConcurrentSet(System.Collections.Generic.IEnumerable<T> collection, System.Collections.Generic.IEqualityComparer<T> comparer) { }\n    public ConcurrentSet(int concurrencyLevel, int capacity) { }\n    public ConcurrentSet(int concurrencyLevel, System.Collections.Generic.IEnumerable<T> collection, System.Collections.Generic.IEqualityComparer<T> comparer) { }\n    public ConcurrentSet(int concurrencyLevel, int capacity, System.Collections.Generic.IEqualityComparer<T> comparer) { }\n    public int Count { get; }\n    public bool IsEmpty { get; }\n    public void Clear() { }\n    public bool Contains(T item) { }\n    public bool TryAdd(T item) { }\n    public bool TryRemove(T item) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DefaultLogger Actor in C#\nDESCRIPTION: An actor that processes log events and prints them to an output. It implements IRequiresMessageQueue to specify message queue semantics for the logger.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_119\n\nLANGUAGE: C#\nCODE:\n```\npublic class DefaultLogger : Akka.Actor.ActorBase, Akka.Dispatch.IRequiresMessageQueue<Akka.Event.ILoggerMessageQueueSemantics>\n{\n    public DefaultLogger() { }\n    protected virtual void Print(Akka.Event.LogEvent logEvent) { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GSet Class in C# for Akka.NET Distributed Data\nDESCRIPTION: Defines the GSet class, a grow-only set for distributed systems. It implements various interfaces for replicated data and includes methods for adding elements, merging, and delta-based operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class GSet<T> : Akka.DistributedData.FastMerge<Akka.DistributedData.GSet<T>>, Akka.DistributedData.IDeltaReplicatedData, Akka.DistributedData.IDeltaReplicatedData<Akka.DistributedData.GSet<T>, Akka.DistributedData.GSet<T>>, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.GSet<T>>, Akka.DistributedData.IReplicatedDelta, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.IEquatable<Akka.DistributedData.GSet<T>>\n{\n    public static readonly Akka.DistributedData.GSet<T> Empty;\n    public GSet() { }\n    public GSet(System.Collections.Immutable.IImmutableSet<T> elements) { }\n    public GSet(System.Collections.Immutable.IImmutableSet<T> elements, Akka.DistributedData.GSet<T> delta) { }\n    public int Count { get; }\n    public Akka.DistributedData.GSet<T> Delta { get; }\n    public System.Collections.Immutable.IImmutableSet<T> Elements { get; }\n    public bool IsEmpty { get; }\n    public System.Type SetType { get; }\n    public Akka.DistributedData.GSet<T> Add(T element) { }\n    public bool Contains(T element) { }\n    public bool Equals(Akka.DistributedData.GSet<T> other) { }\n    public override bool Equals(object obj) { }\n    public System.Collections.Generic.IEnumerator<T> GetEnumerator() { }\n    public override int GetHashCode() { }\n    public override Akka.DistributedData.GSet<T> Merge(Akka.DistributedData.GSet<T> other) { }\n    public Akka.DistributedData.GSet<T> MergeDelta(Akka.DistributedData.GSet<T> delta) { }\n    public Akka.DistributedData.GSet<T> ResetDelta() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Translator Actor for Stream Processing in C#\nDESCRIPTION: This code snippet shows how to implement an actor that processes messages from a stream and sends replies. It demonstrates the actor-side implementation for the Ask pattern used in streams.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Translator : ReceiveActor\n{\n    public Translator()\n    {\n        Receive<string>(word => {\n            // ... process message\n            string reply = word.ToUpper();\n            // reply to the ask\n            Sender.Tell(reply, Self);\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Terminated Class for Actor Termination in C#\nDESCRIPTION: Defines the Terminated class to represent a terminated actor. It implements various interfaces and provides properties related to actor termination.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Terminated : Akka.Actor.IAutoReceivedMessage, Akka.Actor.INoSerializationVerificationNeeded, Akka.Actor.IPossiblyHarmful, Akka.Event.IDeadLetterSuppression, System.IEquatable<Akka.Actor.Terminated>\n{\n    public Terminated(Akka.Actor.IActorRef actorRef, bool existenceConfirmed, bool addressTerminated) { }\n    public Akka.Actor.IActorRef ActorRef { get; }\n    public bool AddressTerminated { get; }\n    public bool ExistenceConfirmed { get; }\n    public bool Equals(Akka.Actor.Terminated other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Reusing Runnable Graph to Count Retweets in C#\nDESCRIPTION: Explains setting up a reusable Akka.NET stream graph to count retweets within a defined timeframe. A `Sink.Aggregate` is used for summing, and `IRunnableGraph` instances can be reused and materialized multiple times. Shows materialization of the stream both in the morning and evening to get different outputs. Dependencies: Akka.NET library. Inputs: Stream of tweets within a minute. Expected output: Different retweet counts for different times.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/reactivetweets.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nvar sumSink = Sink.Aggregate<int, int>(0, (agg, i) => agg + i);\n\nvar counterRunnableGraph = tweetsInMinuteFromNow\n    .Where(tweet => tweet.IsRetweet)\n    .Select(_ => 1)\n    .ToMaterialized(sumSink, Keep.Right);\n    \n// materialize the stream once in the morning\nvar morningTweetsCount = counterGraph.Run(mat);\n// and once in the evening, reusing the flow\nvar eveningTweetsCount = counterGraph.Run(mat);\n```\n\n----------------------------------------\n\nTITLE: Scheduling Repeated Messages in Akka.NET\nDESCRIPTION: Demonstrates how to schedule a message to be sent repeatedly to an actor using the Akka.NET scheduler. This example shows scheduling a message every 5 seconds with an initial delay of 0 seconds.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/scheduler.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar system = ActorSystem.Create(\"MySystem\");\nvar someActor = system.ActorOf<SomeActor>(\"someActor\");\nvar someMessage = new SomeMessage() {...};\nsystem\n   .Scheduler\n   .ScheduleTellRepeatedly(TimeSpan.FromSeconds(0),\n             TimeSpan.FromSeconds(5),\n             someActor, someMessage, ActorRefs.NoSender); //or ActorRefs.Nobody or something else\n```\n\n----------------------------------------\n\nTITLE: Creating Initial Contact Points for ClusterClient in C#\nDESCRIPTION: Example showing how to create a collection of initial contact points for the ClusterClient by parsing actor paths and configuring the ClusterClientSettings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-client.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar initialContacts = new List<ActorPath>()\n{\n    ActorPath.Parse(\"akka.tcp://OtherSys@host1:2552/system/receptionist\"),\n    ActorPath.Parse(\"akka.tcp://OtherSys@host2:2552/system/receptionist\")\n};\n\nvar settings = ClusterClientSettings.Create(Sys).WithInitialContacts(initialContacts);\n```\n\n----------------------------------------\n\nTITLE: File IO Operations in Akka.NET Streams\nDESCRIPTION: File input/output operations for Akka.NET streams, including FromFile and ToFile operations that work with ByteStrings and materialize into Tasks with IOResult.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/builtinstages.md#2025-04-16_snippet_5\n\n\n\n----------------------------------------\n\nTITLE: Outlining the Query Actor Structure in Akka.NET\nDESCRIPTION: Basic structure of a query actor that collects temperature data from device actors with timeout functionality. It initializes with device references, request ID, requester reference, and timeout parameter.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-4.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DeviceGroupQuery : UntypedActor\n{\n    private ICancelable queryTimeoutTimer;\n\n    public DeviceGroupQuery(\n        Dictionary<string, IActorRef> actorToDeviceId,\n        long requestId,\n        IActorRef requester,\n        TimeSpan timeout)\n    {\n        ActorToDeviceId = actorToDeviceId;\n        RequestId = requestId;\n        Requester = requester;\n        Timeout = timeout;\n\n        queryTimeoutTimer = Context.System.Scheduler.ScheduleTellOnceCancelable(\n            timeout,\n            Self,\n            new CollectionTimeout(),\n            Self);\n\n        foreach (var deviceActor in ActorToDeviceId.Values)\n        {\n            Context.Watch(deviceActor);\n            deviceActor.Tell(new ReadTemperature(0L));\n        }\n    }\n\n    protected override void OnReceive(object message)\n    {\n        // Will delegate to WaitingForReplies\n    }\n\n    protected override void PostStop()\n    {\n        queryTimeoutTimer.Cancel();\n    }\n\n    public Dictionary<string, IActorRef> ActorToDeviceId { get; }\n    public long RequestId { get; }\n    public IActorRef Requester { get; }\n    public TimeSpan Timeout { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Discovery Extension Class\nDESCRIPTION: This code defines the `Discovery` class, an Akka.NET extension for service discovery. It provides access to the default service discovery method and allows loading service discovery implementations based on configuration.  It also defines `DiscoveryProvider` for creating the extension.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.Core.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace Akka.Discovery\n{\n    public class Discovery : Akka.Actor.IExtension\n    {\n        public Discovery(Akka.Actor.ExtendedActorSystem system) { }\n        public Akka.Discovery.ServiceDiscovery Default { get; }\n        public static Akka.Discovery.Discovery Get(Akka.Actor.ActorSystem system) { }\n        public Akka.Discovery.ServiceDiscovery LoadServiceDiscovery(string method) { }\n    }\n    public class DiscoveryProvider : Akka.Actor.ExtensionIdProvider<Akka.Discovery.Discovery>\n    {\n        public DiscoveryProvider() { }\n        public override Akka.Discovery.Discovery CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n        public static Akka.Configuration.Config DefaultConfiguration() { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Streams with Source.ActorRef in C#\nDESCRIPTION: This example shows how to test a stream using Source.ActorRef, providing full control over elements sent to the stream and allowing for custom element injection and completion signaling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/testingstreams.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar sinkUnderTest = Flow.Create<int>()\n    .Select(x => x.ToString())\n    .ToMaterialized(Sink.Aggregate<string, string>(\"\", (s, s1) => s + s1), Keep.Right);\n\nvar t = Source.ActorRef<int>(8, OverflowStrategy.Fail)\n    .ToMaterialized(sinkUnderTest, Keep.Both)\n    .Run(materializer);\n\nvar actorRef = t.Item1;\nvar task = t.Item2;\n\nactorRef.Tell(1);\nactorRef.Tell(2);\nactorRef.Tell(3);\nactorRef.Tell(new Status.Success(\"done\"));\n\ntask.Wait(TimeSpan.FromMilliseconds(500)).Should().BeTrue();\ntask.Result.Should().Be(\"123\");\n```\n\n----------------------------------------\n\nTITLE: TestKit Core Classes Implementation in C#\nDESCRIPTION: Implementation of core TestKit classes including TestKitBase, TestKitExtension, TestKitSettings, TestLatch and TestProbe for testing Akka.NET actor systems. Provides methods for message handling, timing control and actor lifecycle management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestKitExtension : Akka.Actor.ExtensionIdProvider<Akka.TestKit.TestKitSettings>\n{\n    public TestKitExtension() { }\n    public override Akka.TestKit.TestKitSettings CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n    public static Akka.TestKit.TestKitSettings For(Akka.Actor.ActorSystem system) { }\n}\n\npublic class TestKitSettings : Akka.Actor.IExtension\n{\n    public TestKitSettings(Akka.Configuration.Config config) { }\n    public System.TimeSpan DefaultTimeout { get; }\n    public bool LogTestKitCalls { get; }\n    public System.TimeSpan SingleExpectDefault { get; }\n    public System.TimeSpan TestEventFilterLeeway { get; }\n    public System.TimeSpan TestKitStartupTimeout { get; }\n    public double TestTimeFactor { get; }\n}\n\npublic class TestLatch\n{\n    [System.ObsoleteAttribute(\"This field will be removed. TestKitSettings.DefaultTimeout is an alternative.\")]\n    public static readonly System.TimeSpan DefaultTimeout;\n    public TestLatch() { }\n    public TestLatch(int count) { }\n    public TestLatch(int count, System.TimeSpan defaultTimeout) { }\n    protected TestLatch(System.Func<System.TimeSpan, System.TimeSpan> dilate, System.TimeSpan defaultTimeout, int count) { }\n    public bool IsOpen { get; }\n    public void CountDown() { }\n    public void Open() { }\n    public void Ready(System.TimeSpan timeout) { }\n    public void Ready() { }\n    public void Reset() { }\n}\n\npublic class TestProbe : Akka.TestKit.TestKitBase, Akka.Actor.IActorRef, Akka.Actor.IActorRefScope, Akka.Actor.ICanTell, Akka.Actor.IInternalActorRef, Akka.TestKit.INoImplicitSender, Akka.Util.ISurrogated, System.IComparable, System.IComparable<Akka.Actor.IActorRef>, System.IEquatable<Akka.Actor.IActorRef>\n{\n    public TestProbe(Akka.Actor.ActorSystem system, Akka.TestKit.ITestKitAssertions assertions, string testProbeName = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Integer Source Stream\nDESCRIPTION: Creates a source stream that emits integers from 1 to 100\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/quickstart.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nSource<T, NotUsed> source = Source.From(Enumerable.Range(1,100))\n```\n\n----------------------------------------\n\nTITLE: Implementing Pre-Start Initialization for a SQLite Snapshot Store in Akka.NET\nDESCRIPTION: Code showing how to implement the pre-start sequence for a SQLite snapshot store, which includes stashing incoming messages while initializing database tables.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/custom-persistence-provider.md#2025-04-16_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override void PreStart()\n{\n    base.PreStart();\n\n    // check if we need to initialize the database\n    var autoInitializationMessage = new GetSqlSettingsMessage(\"snapshot\");\n    var task = Self.Ask<SqlSettingsMessage>(autoInitializationMessage, TimeSpan.FromSeconds(10));\n\n    task.ContinueWith(tr =>\n    {\n        var result = tr.Result;\n        var initDb = result.Settings.GetBoolean(\"auto-initialize\");\n        var connectionString = result.Settings.GetString(\"connection-string\");\n        var sqlDatabase = SqlDatabaseOrDefault(result.Settings);\n\n        if (initDb)\n        {\n            // we don't want to process any messages until we've auto-initialized the database\n            var initialize = new InitializeDatabaseMessage(connectionString, _settings.SchemaName, sqlDatabase);\n            Become(message => Stash());\n\n            var init = Self.Ask<DatabaseInitializationResult>(initialize, TimeSpan.FromSeconds(10));\n            init.ContinueWith(t =>\n            {\n                Become(message => Process(message));\n\n                // now process all stashed messages\n                Stash.UnstashAll();\n            });\n        }\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Actor Path Management\nDESCRIPTION: Provides an abstract base class for managing actor paths, including parsing, serialization, and comparison methods for actor addressing\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class ActorPath : Akka.Util.ISurrogated, System.IComparable<Akka.Actor.ActorPath>, System.IEquatable<Akka.Actor.ActorPath> { }\n```\n\n----------------------------------------\n\nTITLE: Exception Message from Problematic Implementation\nDESCRIPTION: The error message generated when the problematic code is executed, indicating that there is no active ActorContext available due to the use of async operations within the actor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK1005.md#2025-04-16_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nNotSupportedException\nThere is no active ActorContext, this is most likely due to use of async operations from within this actor.\n  at MyApplication.Actors.MyActor`1<>c__DisplayClass48_0.<<InvokeTestMethodAsync>b__1>d.MoveNext() in \\src\\MyApplication.Actors\\MyActor.cs:line 16\n```\n\n----------------------------------------\n\nTITLE: Defining Eventsourced Base Class in C#\nDESCRIPTION: This snippet describes the Eventsourced abstract class, providing a framework for Akka actors to support persistence and message handling. This class manages state recovery, persistence operations, and governs the lifecycle of persistent actors, making it central to Akka's persistence capabilities.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class Eventsourced : Akka.Actor.ActorBase, Akka.Actor.IActorStash, Akka.Actor.IWithUnboundedStash, Akka.Actor.IWithUnrestrictedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics>, Akka.Persistence.IPersistenceRecovery, Akka.Persistence.IPersistenceStash, Akka.Persistence.IPersistentIdentity\n{\n    public static readonly System.Func<Akka.Actor.Envelope, bool> UnstashFilterPredicate;\n    protected Eventsourced() { }\n    protected Akka.Persistence.PersistenceExtension Extension { get; }\n    public virtual Akka.Persistence.IStashOverflowStrategy InternalStashOverflowStrategy { get; }\n    public bool IsRecovering { get; }\n    public bool IsRecoveryFinished { get; }\n    public Akka.Actor.IActorRef Journal { get; }\n    public string JournalPluginId { get; set; }\n    public long LastSequenceNr { get; }\n    protected virtual Akka.Event.ILoggingAdapter Log { get; }\n    public abstract string PersistenceId { get; }\n    public virtual Akka.Persistence.Recovery Recovery { get; }\n    public string SnapshotPluginId { get; set; }\n    public long SnapshotSequenceNr { get; }\n    public Akka.Actor.IActorRef SnapshotStore { get; }\n    public string SnapshotterId { get; }\n    public Akka.Actor.IStash Stash { get; set; }\n    public override void AroundPostRestart(System.Exception reason, object message) { }\n    public override void AroundPostStop() { }\n    public override void AroundPreRestart(System.Exception cause, object message) { }\n    public override void AroundPreStart() { }\n    protected override bool AroundReceive(Akka.Actor.Receive receive, object message) { }\n    public void DeferAsync<TEvent>(TEvent evt, System.Action<TEvent> handler) { }\n    public void DeleteMessages(long toSequenceNr) { }\n    public void DeleteSnapshot(long sequenceNr) { }\n    public void DeleteSnapshots(Akka.Persistence.SnapshotSelectionCriteria criteria) { }\n    public void LoadSnapshot(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria, long toSequenceNr) { }\n    protected virtual void OnPersistFailure(System.Exception cause, object @event, long sequenceNr) { }\n    protected virtual void OnPersistRejected(System.Exception cause, object @event, long sequenceNr) { }\n    protected virtual void OnRecoveryFailure(System.Exception reason, object message = null) { }\n    protected virtual void OnReplaySuccess() { }\n    public void Persist<TEvent>(TEvent @event, System.Action<TEvent> handler) { }\n    public void PersistAll<TEvent>(System.Collections.Generic.IEnumerable<TEvent> events, System.Action<TEvent> handler) { }\n    public void PersistAllAsync<TEvent>(System.Collections.Generic.IEnumerable<TEvent> events, System.Action<TEvent> handler) { }\n    public void PersistAsync<TEvent>(TEvent @event, System.Action<TEvent> handler) { }\n    protected abstract bool ReceiveCommand(object message);\n    protected abstract bool ReceiveRecover(object message);\n    protected void RunTask(System.Func<System.Threading.Tasks.Task> action) { }\n    public void SaveSnapshot(object snapshot) { }\n    protected override void Unhandled(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterShardingStats Class in C#\nDESCRIPTION: This sealed class represents statistics for cluster sharding. It contains a dictionary of shard region stats keyed by actor addresses and implements equality comparison.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterShardingStats : Akka.Cluster.Sharding.IClusterShardingSerializable, System.IEquatable<Akka.Cluster.Sharding.ClusterShardingStats>\n{\n    public readonly System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, Akka.Cluster.Sharding.ShardRegionStats> Regions;\n    public ClusterShardingStats(System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, Akka.Cluster.Sharding.ShardRegionStats> regions) { }\n    // ... additional methods\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Result<T> Struct in C#\nDESCRIPTION: A value type that represents the result of an operation which can be either a success with a value or a failure with an exception.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_227\n\nLANGUAGE: C#\nCODE:\n```\npublic struct Result<T> : System.IEquatable<Akka.Util.Result<T>>\n{\n    public readonly System.Exception Exception;\n    public readonly bool IsSuccess;\n    public readonly T Value;\n    public Result(T value) { }\n    public Result(System.Exception exception) { }\n    public bool Equals(Akka.Util.Result<T> other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n    public static bool ==(Akka.Util.Result<T> left, Akka.Util.Result<T> right) { }\n    public static bool !=(Akka.Util.Result<T> left, Akka.Util.Result<T> right) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Stream Error Handling with TestSource.Probe in C#\nDESCRIPTION: This snippet demonstrates how to test stream error handling by injecting exceptions using TestSource.Probe and asserting on the sink's behavior under error conditions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/testingstreams.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nvar sinkUnderTest = Sink.First<int>();\n\nvar t = this.SourceProbe<int>()\n    .ToMaterialized(sinkUnderTest, Keep.Both)\n    .Run(materializer);\nvar probe = t.Item1;\nvar task = t.Item2;\n\nprobe.SendError(new Exception(\"boom\"));\n\ntask.Wait(TimeSpan.FromMilliseconds(500)).Should().BeTrue();\ntask.Exception.Message.Should().Be(\"boom\");\n```\n\n----------------------------------------\n\nTITLE: Implementing StableListPriorityQueue Class\nDESCRIPTION: A priority queue implementation for Akka.Actor.Envelope objects. It maintains a stable order using a list and custom priority calculation function, providing standard queue operations like Enqueue, Dequeue, and Peek.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_213\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class StableListPriorityQueue\n{\n    public StableListPriorityQueue(int initialCapacity, System.Func<object, int> priorityCalculator) { }\n    public int Count() { }\n    public Akka.Actor.Envelope Dequeue() { }\n    public void Enqueue(Akka.Actor.Envelope item) { }\n    public bool IsConsistent() { }\n    public Akka.Actor.Envelope Peek() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract SnapshotStore Class in C#\nDESCRIPTION: Abstract base class for implementing snapshot stores in Akka.NET. It defines abstract methods for deleting, loading, and saving snapshots, as well as virtual methods for message handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class SnapshotStore : Akka.Actor.ActorBase\n{\n    protected SnapshotStore() { }\n    protected abstract System.Threading.Tasks.Task DeleteAsync(Akka.Persistence.SnapshotMetadata metadata);\n    protected abstract System.Threading.Tasks.Task DeleteAsync(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria);\n    protected abstract System.Threading.Tasks.Task<Akka.Persistence.SelectedSnapshot> LoadAsync(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria);\n    protected virtual bool Receive(object message) { }\n    protected virtual bool ReceivePluginInternal(object message) { }\n    protected abstract System.Threading.Tasks.Task SaveAsync(Akka.Persistence.SnapshotMetadata metadata, object snapshot);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Router Props with FromConfig in C#\nDESCRIPTION: Simple C# code for creating router properties that use the HOCON configuration to set up cluster-aware routing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/member-roles.md#2025-04-16_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nvar routerProps = Props.Empty.WithRouter(FromConfig.Instance);\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterJoinFailedException in C#\nDESCRIPTION: Implements a custom exception for handling cluster join failures. This exception is thrown when a node cannot successfully join the cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.DotNet.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterJoinFailedException : Akka.Actor.AkkaException\n{\n    public ClusterJoinFailedException(string message) { }\n    protected ClusterJoinFailedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Expecting Messages from Specific Senders in Akka.NET TestKitBase\nDESCRIPTION: These methods are used to expect and assert messages from specific senders in Akka.NET tests. They offer both synchronous and asynchronous versions with various overloads for different assertion scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic T ExpectMsgFrom<T>(Akka.Actor.IActorRef sender, System.Nullable<System.TimeSpan> duration = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic T ExpectMsgFrom<T>(Akka.Actor.IActorRef sender, T message, System.Nullable<System.TimeSpan> timeout = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic T ExpectMsgFrom<T>(Akka.Actor.IActorRef sender, System.Predicate<T> isMessage, System.Nullable<System.TimeSpan> timeout = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic T ExpectMsgFrom<T>(System.Predicate<Akka.Actor.IActorRef> isSender, System.Predicate<T> isMessage, System.Nullable<System.TimeSpan> timeout = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic T ExpectMsgFrom<T>(Akka.Actor.IActorRef sender, System.Action<T> assertMessage, System.Nullable<System.TimeSpan> timeout = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic T ExpectMsgFrom<T>(System.Action<Akka.Actor.IActorRef> assertSender, System.Action<T> assertMessage, System.Nullable<System.TimeSpan> timeout = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Materialized Values in a GraphStage Flow (C#)\nDESCRIPTION: This example shows how to create a custom GraphStage flow with a materialized value. The FirstValue stage returns a Task containing the first element to go through the stream as its materialized value.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/custom-stream-processing.md#2025-04-16_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\nclass FirstValue<T> : GraphStageWithMaterializedValue<FlowShape<T, T>, Task<T>>\n{\n    private sealed class Logic : GraphStageLogic\n    {\n        public Logic(FirstValue<T> first, TaskCompletionSource<T> completion) : base(first.Shape)\n        {\n            SetHandler(first.In, onPush: () =>\n            {\n                var element = Grab(first.In);\n                completion.SetResult(element);\n                Push(first.Out, element);\n\n                // replace handler with one just forwarding\n                SetHandler(first.In, onPush: () => Push(first.Out, Grab(first.In)));\n            });\n\n            SetHandler(first.Out, onPull: () => Pull(first.In));\n        }\n    }\n    \n    public FirstValue( )\n    {\n        Shape = new FlowShape<T, T>(In, Out);\n    }\n\n    public Inlet<T> In { get; } = new Inlet<T>(\"FirstValue.in\");\n\n    public Outlet<T> Out { get; } = new Outlet<T>(\"FirstValue.out\");\n\n    public override FlowShape<T, T> Shape { get; }\n\n    public override ILogicAndMaterializedValue<Task<T>> CreateLogicAndMaterializedValue(Attributes inheritedAttributes)\n    {\n        var completion = new TaskCompletionSource<T>();\n        var logic = new Logic(this, completion);\n        return new LogicAndMaterializedValue<Task<T>>(logic, completion.Task);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Subscribe Message Class for Akka Distributed PubSub in C#\nDESCRIPTION: Defines a sealed Subscribe message class used to subscribe an actor to a specific topic in Akka's distributed publish-subscribe system. Supports optional group parameter for shared subscriptions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class Subscribe : System.IEquatable<Akka.Cluster.Tools.PublishSubscribe.Subscribe>\n{\n    public Subscribe(string topic, Akka.Actor.IActorRef @ref, string group = null) { }\n    public string Group { get; }\n    public Akka.Actor.IActorRef Ref { get; }\n    public string Topic { get; }\n    public bool Equals(Akka.Cluster.Tools.PublishSubscribe.Subscribe other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TCP Extension and Manager in Akka.NET\nDESCRIPTION: The Tcp class serves as an extension provider for the TcpExt extension. It provides static methods for accessing the TCP manager and defines a connection supervisor strategy.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_153\n\nLANGUAGE: C#\nCODE:\n```\npublic class Tcp : Akka.Actor.ExtensionIdProvider<Akka.IO.TcpExt>\n{\n    public static readonly Akka.Actor.SupervisorStrategy ConnectionSupervisorStrategy;\n    public static readonly Akka.IO.Tcp Instance;\n    public Tcp() { }\n    public override Akka.IO.TcpExt CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n    public static Akka.Actor.IActorRef Manager(Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Fishing for Messages in Akka.NET TestKitBase\nDESCRIPTION: These methods are used to search for specific messages in the received message queue in Akka.NET tests. They provide both synchronous and asynchronous versions with options for timeout, cancellation, and custom predicates.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic object FishForMessage(System.Predicate<object> isMessage, System.Nullable<System.TimeSpan> max = null, string hint = \"\", System.Threading.CancellationToken cancellationToken = null) { }\npublic T FishForMessage<T>(System.Predicate<T> isMessage, System.Nullable<System.TimeSpan> max = null, string hint = \"\", System.Threading.CancellationToken cancellationToken = null) { }\npublic T FishForMessage<T>(System.Predicate<T> isMessage, System.Collections.ArrayList allMessages, System.Nullable<System.TimeSpan> max = null, string hint = \"\", System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.ValueTask<object> FishForMessageAsync(System.Predicate<object> isMessage, System.Nullable<System.TimeSpan> max = null, string hint = \"\", System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.ValueTask<T> FishForMessageAsync<T>(System.Predicate<T> isMessage, System.Nullable<System.TimeSpan> max = null, string hint = \"\", System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.ValueTask<T> FishForMessageAsync<T>(System.Predicate<T> isMessage, System.Collections.ArrayList allMessages, System.Nullable<System.TimeSpan> max = null, string hint = \"\", System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Router Methods in C#\nDESCRIPTION: This snippet shows the abstract Router class with methods for adding and removing routees, routing messages, and managing the router configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_186\n\nLANGUAGE: C#\nCODE:\n```\npublic virtual Akka.Routing.Router AddRoutee(Akka.Routing.Routee routee) { }\npublic Akka.Routing.Router AddRoutee(Akka.Actor.IActorRef routee) { }\npublic Akka.Routing.Router AddRoutee(Akka.Actor.ActorSelection routee) { }\npublic virtual Akka.Routing.Router RemoveRoutee(Akka.Routing.Routee routee) { }\npublic Akka.Routing.Router RemoveRoutee(Akka.Actor.IActorRef routee) { }\npublic Akka.Routing.Router RemoveRoutee(Akka.Actor.ActorSelection routee) { }\npublic virtual void Route(object message, Akka.Actor.IActorRef sender) { }\nprotected virtual void Send(Akka.Routing.Routee routee, object message, Akka.Actor.IActorRef sender) { }\nprotected object UnWrap(object message) { }\npublic virtual Akka.Routing.Router WithRoutees(params Akka.Routing.Routee[] routees) { }\n```\n\n----------------------------------------\n\nTITLE: Remote Actor Provider Class Definition in C#\nDESCRIPTION: Defines the RemoteActorRefProvider class that implements IActorRefProvider and IRemoteActorRefProvider interfaces. Handles creation and management of remote actor references.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class RemoteActorRefProvider : Akka.Actor.IActorRefProvider, Akka.Remote.IRemoteActorRefProvider\n{\n    public RemoteActorRefProvider(string systemName, Akka.Actor.Settings settings, Akka.Event.EventStream eventStream) { }\n    public Akka.Actor.IActorRef DeadLetters { get; }\n    public Akka.Actor.Address DefaultAddress { get; }\n    public Akka.Actor.Deployer Deployer { get; set; }\n    // ... additional properties and methods\n}\n```\n\n----------------------------------------\n\nTITLE: Local Actor Reference Provider Implementation in C#\nDESCRIPTION: Core implementation of IActorRefProvider for local actor system operations. Handles actor creation, management and resolution within a single process.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class LocalActorRefProvider : Akka.Actor.IActorRefProvider\n{\n    public LocalActorRefProvider(string systemName, Akka.Actor.Settings settings, Akka.Event.EventStream eventStream) { }\n    public LocalActorRefProvider(string systemName, Akka.Actor.Settings settings, Akka.Event.EventStream eventStream, Akka.Actor.Deployer deployer, System.Func<Akka.Actor.ActorPath, Akka.Actor.IInternalActorRef> deadLettersFactory) { }\n    public Akka.Actor.IActorRef DeadLetters { get; }\n    public Akka.Actor.Address DefaultAddress { get; }\n    public Akka.Actor.Deployer Deployer { get; }\n    public Akka.Event.EventStream EventStream { get; }\n    public Akka.Actor.LocalActorRef Guardian { get; }\n    public Akka.Actor.IActorRef IgnoreRef { get; }\n    public Akka.Event.ILoggingAdapter Log { get; }\n    public Akka.Actor.IInternalActorRef RootGuardian { get; }\n    public Akka.Actor.ActorPath RootPath { get; }\n    public Akka.Serialization.Information SerializationInformation { get; }\n    public Akka.Actor.Settings Settings { get; }\n    public Akka.Actor.LocalActorRef SystemGuardian { get; }\n    public Akka.Actor.IInternalActorRef TempContainer { get; }\n    public System.Threading.Tasks.Task TerminationTask { get; }\n    public Akka.Actor.IInternalActorRef ActorOf(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.Props props, Akka.Actor.IInternalActorRef supervisor, Akka.Actor.ActorPath path, bool systemService, Akka.Actor.Deploy deploy, bool lookupDeploy, bool async) { }\n    public Akka.Actor.FutureActorRef<T> CreateFutureRef<T>(System.Threading.Tasks.TaskCompletionSource<T> tcs) { }\n    public Akka.Actor.Address GetExternalAddressFor(Akka.Actor.Address address) { }\n    public void Init(Akka.Actor.Internal.ActorSystemImpl system) { }\n    public void RegisterExtraName(string name, Akka.Actor.IInternalActorRef actor) { }\n    public void RegisterTempActor(Akka.Actor.IInternalActorRef actorRef, Akka.Actor.ActorPath path) { }\n    public Akka.Actor.IActorRef ResolveActorRef(string path) { }\n    public Akka.Actor.IActorRef ResolveActorRef(Akka.Actor.ActorPath path) { }\n    public Akka.Actor.IActorRef RootGuardianAt(Akka.Actor.Address address) { }\n    public Akka.Actor.ActorPath TempPath() { }\n    public void UnregisterTempActor(Akka.Actor.ActorPath path) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Unsubscribing from Cluster Events in Akka.NET\nDESCRIPTION: Shows how to unsubscribe from cluster event notifications. There are two approaches - unsubscribing from all events or from specific event types only.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-extension.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nCluster.Unsubscribe(Self); // unsub from ALL events\nCluster.Unsubscribe(Self, typeof(IMemberEvent)); // unsub from just IMemberEvent\n```\n\n----------------------------------------\n\nTITLE: Implementing Cluster Sharding Serialization in C#\nDESCRIPTION: Serializer implementation for cluster sharding messages in Akka.NET, handling binary conversion and manifest management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Net.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterShardingMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public ClusterShardingMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object o) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Publisher with Fan-out Support in Akka Streams C#\nDESCRIPTION: This snippet demonstrates how to create a Publisher with fan-out support in Akka Streams. This is necessary when broadcast behavior is needed for interoperability with other Reactive Streams implementations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/designprinciples.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nSink.AsPublisher<T>(true)\n```\n\n----------------------------------------\n\nTITLE: Restart Strategy with Stateful Processing\nDESCRIPTION: Illustrates the Restart directive which resets accumulated state when an exception occurs, useful for stateful stream processing\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/error-handling.md#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nDecider decider = cause => cause is ArgumentException\n    ? Directive.Restart\n    : Directive.Stop;\n\nvar flow = Flow.Create<int>()\n    .Scan(0, (acc, x) => {\n      if(x < 0)\n            throw new ArgumentException(\"negative not allowed\");\n        return acc + x;\n    })\n    .WithAttributes(ActorAttributes.CreateSupervisionStrategy(decider));\n```\n\n----------------------------------------\n\nTITLE: Pool Abstract Class in Akka.NET Routing\nDESCRIPTION: Defines the abstract base class for pool-based routers. It maintains configuration for the number of routee instances, supervisor strategy, and dispatcher, with support for equality comparison.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_181\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Pool : Akka.Routing.RouterConfig, System.IEquatable<Akka.Routing.Pool>\n{\n    protected Pool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher) { }\n    public static Akka.Actor.SupervisorStrategy DefaultSupervisorStrategy { get; }\n    public int NrOfInstances { get; }\n    public virtual Akka.Routing.Resizer Resizer { get; }\n    public override bool StopRouterWhenAllRouteesRemoved { get; }\n    public virtual Akka.Actor.SupervisorStrategy SupervisorStrategy { get; }\n    public virtual bool UsePoolDispatcher { get; }\n    public override Akka.Actor.ActorBase CreateRouterActor() { }\n    public bool Equals(Akka.Routing.Pool other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public abstract int GetNrOfInstances(Akka.Actor.ActorSystem system);\n    public Akka.Actor.Props Props(Akka.Actor.Props routeeProps) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterClientReceptionist in Akka.NET\nDESCRIPTION: The server-side component that handles client connections in an Akka Cluster. It allows registering services and topic subscribers that can be accessed by external ClusterClient instances, and provides methods for service management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Net.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterClientReceptionist : Akka.Actor.IExtension\n{\n    public ClusterClientReceptionist(Akka.Actor.ExtendedActorSystem system) { }\n    public bool IsTerminated { get; }\n    public Akka.Actor.IActorRef Underlying { get; }\n    public static Akka.Configuration.Config DefaultConfig() { }\n    public static Akka.Cluster.Tools.Client.ClusterClientReceptionist Get(Akka.Actor.ActorSystem system) { }\n    public void RegisterService(Akka.Actor.IActorRef actorRef) { }\n    public void RegisterSubscriber(string topic, Akka.Actor.IActorRef actorRef) { }\n    public void UnregisterService(Akka.Actor.IActorRef actorRef) { }\n    public void UnregisterSubscriber(string topic, Akka.Actor.IActorRef actorRef) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FutureActor and Message Queue Interfaces in C#\nDESCRIPTION: Implements a FutureActor class and defines interfaces for various message queue semantics used in Akka.NET. These interfaces provide contracts for implementing different types of message queues with specific behaviors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_99\n\nLANGUAGE: C#\nCODE:\n```\npublic class FutureActor : Akka.Actor.ActorBase\n{\n    public FutureActor() { }\n    public FutureActor(System.Threading.Tasks.TaskCompletionSource<object> completionSource, Akka.Actor.IActorRef respondTo) { }\n    protected override bool Receive(object message) { }\n}\npublic interface IBlockingMessageQueueSemantics : Akka.Dispatch.IMultipleConsumerSemantics, Akka.Dispatch.ISemantics\n{\n    System.TimeSpan BlockTimeOut { get; set; }\n}\npublic interface IBoundedDequeBasedMessageQueueSemantics : Akka.Dispatch.IBoundedMessageQueueSemantics, Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics { }\npublic interface IBoundedMessageQueueSemantics : Akka.Dispatch.ISemantics\n{\n    System.TimeSpan PushTimeOut { get; }\n}\npublic interface IDequeBasedMessageQueueSemantics : Akka.Dispatch.ISemantics\n{\n    void EnqueueFirst(Akka.Actor.Envelope envelope);\n}\npublic interface IDispatcherPrerequisites\n{\n    Akka.Event.EventStream EventStream { get; }\n    Akka.Dispatch.Mailboxes Mailboxes { get; }\n    Akka.Actor.IScheduler Scheduler { get; }\n    Akka.Actor.Settings Settings { get; }\n}\npublic interface IMultipleConsumerSemantics : Akka.Dispatch.ISemantics { }\npublic interface IProducesMessageQueue<TQueue>\n```\n\n----------------------------------------\n\nTITLE: Implementing Unbounded Deque Message Queue in Akka.NET\nDESCRIPTION: Defines an unbounded double-ended queue implementation for actor messages. Leverages the DequeWrapperMessageQueue to implement multiple interfaces for unbounded and deque-based queue semantics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_111\n\nLANGUAGE: C#\nCODE:\n```\npublic class UnboundedDequeMessageQueue : Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue, Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics, Akka.Dispatch.IUnboundedMessageQueueSemantics\n{\n    public UnboundedDequeMessageQueue() { }\n}\n```\n\n----------------------------------------\n\nTITLE: LeaseProvider Extension for Akka.NET in C#\nDESCRIPTION: Implements the IExtension interface to provide lease management functionality as an Akka extension. Allows retrieval of lease instances based on configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.DotNet.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class LeaseProvider : Akka.Actor.IExtension\n{\n    public LeaseProvider(Akka.Actor.ExtendedActorSystem system) { }\n    public static Akka.Configuration.Config DefaultConfig() { }\n    public static Akka.Coordination.LeaseProvider Get(Akka.Actor.ActorSystem system) { }\n    public Akka.Coordination.Lease GetLease(string leaseName, string configPath, string ownerName) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract MailboxType Class in C#\nDESCRIPTION: Abstract base class for all mailbox types in Akka.NET. Provides the foundation for creating message queues with configuration settings and requires subclasses to implement the Create method.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_94\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class MailboxType\n{\n    protected readonly Akka.Configuration.Config Config;\n    protected readonly Akka.Actor.Settings Settings;\n    protected MailboxType(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }\n    public abstract Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system);\n}\n```\n\n----------------------------------------\n\nTITLE: Generic EventBus Implementation in Akka.NET\nDESCRIPTION: Abstract base class for all event buses, providing publish/subscribe functionality with generic type parameters for events, classifiers, and subscribers. Includes methods for subscription management and event publication.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_125\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class EventBus<TEvent, TClassifier, TSubscriber>\n{\n    protected EventBus() { }\n    protected abstract bool Classify(TEvent @event, TClassifier classifier);\n    protected abstract TClassifier GetClassifier(TEvent @event);\n    protected abstract bool IsSubClassification(TClassifier parent, TClassifier child);\n    protected abstract void Publish(TEvent @event, TSubscriber subscriber);\n    public virtual void Publish(TEvent @event) { }\n    protected string SimpleName(object source) { }\n    protected string SimpleName(System.Type source) { }\n    public virtual bool Subscribe(TSubscriber subscriber, TClassifier classifier) { }\n    public virtual bool Unsubscribe(TSubscriber subscriber) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StandardOutLogger Class in C# for Akka.NET\nDESCRIPTION: The StandardOutLogger class extends MinimalLogger and provides console-based logging functionality for Akka.NET. It includes properties for customizing console colors for different log levels and a method for actual logging implementation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_156\n\nLANGUAGE: C#\nCODE:\n```\npublic class StandardOutLogger : Akka.Event.MinimalLogger\n{\n    public StandardOutLogger() { }\n    public static System.ConsoleColor DebugColor { get; set; }\n    public static System.ConsoleColor ErrorColor { get; set; }\n    public static System.ConsoleColor InfoColor { get; set; }\n    public static bool UseColors { get; set; }\n    public static System.ConsoleColor WarningColor { get; set; }\n    protected override void Log(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: ORMultiValueDictionary Implementation\nDESCRIPTION: Implements a specialized dictionary that allows multiple values per key with observed-remove semantics for distributed scenarios. Supports delta-based replication and node pruning.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ORMultiValueDictionary<TKey, TValue> : Akka.DistributedData.IDeltaReplicatedData, Akka.DistributedData.IDeltaReplicatedData<Akka.DistributedData.ORMultiValueDictionary<TKey, TValue>, Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.ORSet<TValue>>.IDeltaOperation>, Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IRemovedNodePruning<Akka.DistributedData.ORMultiValueDictionary<TKey, TValue>>, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.ORMultiValueDictionary<TKey, TValue>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, System.Collections.Immutable.IImmutableSet<TValue>>>, System.Collections.IEnumerable, System.IEquatable<Akka.DistributedData.ORMultiValueDictionary<TKey, TValue>>\n{\n    public static readonly Akka.DistributedData.ORMultiValueDictionary<TKey, TValue> Empty;\n    public static readonly Akka.DistributedData.ORMultiValueDictionary<TKey, TValue> EmptyWithValueDeltas;\n    public int Count { get; }\n    public Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.ORSet<TValue>>.IDeltaOperation Delta { get; }\n    public bool DeltaValues { get; }\n    public System.Collections.Immutable.IImmutableDictionary<TKey, System.Collections.Immutable.IImmutableSet<TValue>> Entries { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Remote Actor Reference Provider Class Implementation in C#\nDESCRIPTION: Core class implementing IActorRefProvider and IRemoteActorRefProvider interfaces to handle remote actor references in Akka.NET. Manages actor creation, resolution, and system coordination across remote nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class RemoteActorRefProvider : Akka.Actor.IActorRefProvider, Akka.Remote.IRemoteActorRefProvider {\n    public RemoteActorRefProvider(string systemName, Akka.Actor.Settings settings, Akka.Event.EventStream eventStream) { }\n    public Akka.Actor.IActorRef DeadLetters { get; }\n    public Akka.Actor.Address DefaultAddress { get; }\n    // ... additional properties and methods omitted for brevity\n}\n```\n\n----------------------------------------\n\nTITLE: Defining StandardMetrics Class in Akka.NET Cluster Metrics\nDESCRIPTION: Defines a static class that holds standard metric constants and utility methods for extracting CPU and memory metrics from node data. It provides a standardized way to access common performance metrics across a cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class static StandardMetrics\n{\n    public const string CpuProcessUsage = \"CpuProcessUsage\";\n    public const string CpuTotalUsage = \"CpuTotalUsage\";\n    public const string MaxMemoryRecommended = \"MaxMemoryRecommended\";\n    public const string MemoryAvailable = \"MemoryAvailable\";\n    public const string MemoryUsed = \"MemoryUsed\";\n    public const string Processors = \"Processors\";\n    public static Akka.Util.Option<Akka.Cluster.Metrics.StandardMetrics.Cpu> ExtractCpu(Akka.Cluster.Metrics.Serialization.NodeMetrics nodeMetrics) { }\n    public static Akka.Util.Option<Akka.Cluster.Metrics.StandardMetrics.Memory> ExtractMemory(Akka.Cluster.Metrics.Serialization.NodeMetrics nodeMetrics) { }\n    public sealed class Cpu\n    {\n        public Cpu(Akka.Actor.Address address, long timestamp, double cpuProcessUsage, double cpuTotalUsage, int processorsNumber) { }\n        public Akka.Actor.Address Address { get; }\n        public double ProcessUsage { get; }\n        public int ProcessorsNumber { get; }\n        public long Timestamp { get; }\n        public double TotalUsage { get; }\n        [return: System.Runtime.CompilerServices.TupleElementNamesAttribute(new string[] {\n                \"Address\",\n                \"Timestamp\",\n                \"CpuProcessUsage\",\n                \"CpuTotalUsage\",\n                \"Processors\"})]\n        public static Akka.Util.Option<System.ValueTuple<Akka.Actor.Address, long, double, double, int>> Decompose(Akka.Cluster.Metrics.Serialization.NodeMetrics nodeMetrics) { }\n    }\n    public sealed class Memory\n    {\n        public Memory(Akka.Actor.Address address, long timestamp, double used, double available, Akka.Util.Option<double> max) { }\n        public Akka.Actor.Address Address { get; }\n        public double Available { get; }\n        public Akka.Util.Option<double> MaxRecommended { get; }\n        public long Timestamp { get; }\n        public double Used { get; }\n        [return: System.Runtime.CompilerServices.TupleElementNamesAttribute(new string[] {\n                \"Address\",\n                \"Timestamp\",\n                \"UsedSmoothValue\",\n                \"AvailableSmoothValue\",\n                \"MaxRecommendedSmoothValue\"})]\n        public static Akka.Util.Option<System.ValueTuple<Akka.Actor.Address, long, double, double, Akka.Util.Option<double>>> Decompose(Akka.Cluster.Metrics.Serialization.NodeMetrics nodeMetrics) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: AtLeastOnceDeliveryActor Class Definition in Akka.Persistence\nDESCRIPTION: An abstract persistent actor that provides at-least-once delivery semantics for messages. It ensures that messages are delivered to their destinations at least once, even in the face of failures, by tracking unconfirmed deliveries and redelivering when necessary.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AtLeastOnceDeliveryActor : Akka.Persistence.PersistentActor\n{\n    protected AtLeastOnceDeliveryActor() { }\n    protected AtLeastOnceDeliveryActor(Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings settings) { }\n    protected AtLeastOnceDeliveryActor(System.Func<Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings, Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings> overrideSettings) { }\n    public int MaxUnconfirmedMessages { get; }\n    public System.TimeSpan RedeliverInterval { get; }\n    public int RedeliveryBurstLimit { get; }\n    public int UnconfirmedCount { get; }\n    public int WarnAfterNumberOfUnconfirmedAttempts { get; }\n    public override void AroundPostStop() { }\n    public override void AroundPreRestart(System.Exception cause, object message) { }\n    protected override bool AroundReceive(Akka.Actor.Receive receive, object message) { }\n    public bool ConfirmDelivery(long deliveryId) { }\n    public void Deliver(Akka.Actor.ActorPath destination, System.Func<long, object> deliveryMessageMapper) { }\n    public void Deliver(Akka.Actor.ActorSelection destination, System.Func<long, object> deliveryMessageMapper) { }\n    public Akka.Persistence.AtLeastOnceDeliverySnapshot GetDeliverySnapshot() { }\n    protected override void OnReplaySuccess() { }\n    public void SetDeliverySnapshot(Akka.Persistence.AtLeastOnceDeliverySnapshot snapshot) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SerializerWithStringManifest Class in C#\nDESCRIPTION: Defines an abstract SerializerWithStringManifest class that extends the Serializer class. It adds methods for serialization and deserialization using string manifests.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_216\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class SerializerWithStringManifest : Akka.Serialization.Serializer\n{\n    protected SerializerWithStringManifest(Akka.Actor.ExtendedActorSystem system) { }\n    public virtual bool IncludeManifest { get; }\n    public virtual object FromBinary(byte[] bytes, System.Type type) { }\n    public abstract object FromBinary(byte[] bytes, string manifest);\n    public abstract string Manifest(object o);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ShardingConsumerController for Akka.NET\nDESCRIPTION: Static class defining consumer controller creation and settings for Akka.NET cluster sharding. Includes configuration for buffer size and bypass settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\npublic class static ShardingConsumerController\n{\n    public static Akka.Actor.Props Create<T>(System.Func<Akka.Actor.IActorRef, Akka.Actor.Props> consumerProps, Settings settings) { }\n    \n    public sealed class Settings : System.IEquatable<Settings>\n    {\n        public bool AllowBypass { get; set; }\n        public int BufferSize { get; set; }\n        public Akka.Delivery.ConsumerController.Settings ConsumerControllerSettings { get; set; }\n        public static Settings Create(Akka.Actor.ActorSystem system) { }\n        public override string ToString() { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ClusterReceptionistSettings Configuration in C#\nDESCRIPTION: Settings class that configures the behavior of the ClusterReceptionist, including roles, heartbeat intervals, and failure detection parameters. It uses a builder pattern for configuration modifications.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Core.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterReceptionistSettings : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public ClusterReceptionistSettings(string role, int numberOfContacts, System.TimeSpan responseTunnelReceiveTimeout, System.TimeSpan heartbeatInterval, System.TimeSpan acceptableHeartbeatPause, System.TimeSpan failureDetectionInterval) { }\n    public System.TimeSpan AcceptableHeartbeatPause { get; }\n    public System.TimeSpan FailureDetectionInterval { get; }\n    public System.TimeSpan HeartbeatInterval { get; }\n    public int NumberOfContacts { get; }\n    public System.TimeSpan ResponseTunnelReceiveTimeout { get; }\n    public string Role { get; }\n    public static Akka.Cluster.Tools.Client.ClusterReceptionistSettings Create(Akka.Actor.ActorSystem system) { }\n    public static Akka.Cluster.Tools.Client.ClusterReceptionistSettings Create(Akka.Configuration.Config config) { }\n    public Akka.Cluster.Tools.Client.ClusterReceptionistSettings WithHeartbeat(System.TimeSpan heartbeatInterval, System.TimeSpan acceptableHeartbeatPause, System.TimeSpan failureDetectionInterval) { }\n    public Akka.Cluster.Tools.Client.ClusterReceptionistSettings WithNumberOfContacts(int numberOfContacts) { }\n    public Akka.Cluster.Tools.Client.ClusterReceptionistSettings WithResponseTunnelReceiveTimeout(System.TimeSpan responseTunnelReceiveTimeout) { }\n    public Akka.Cluster.Tools.Client.ClusterReceptionistSettings WithRole(string role) { }\n    public Akka.Cluster.Tools.Client.ClusterReceptionistSettings WithoutRole() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing VectorClock in C#\nDESCRIPTION: Defines the VectorClock class which implements a vector clock algorithm for tracking causal relationships between events in a distributed system. Used for gossip protocol and conflict resolution in the cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.DotNet.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class VectorClock\n{\n    public System.Collections.Immutable.ImmutableSortedDictionary<Akka.Cluster.VectorClock.Node, long> Versions { get; }\n    public Akka.Cluster.VectorClock.Ordering CompareTo(Akka.Cluster.VectorClock that) { }\n    public static Akka.Cluster.VectorClock Create() { }\n    public static Akka.Cluster.VectorClock Create(System.Collections.Immutable.ImmutableSortedDictionary<Akka.Cluster.VectorClock.Node, long> seedValues) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public Akka.Cluster.VectorClock Increment(Akka.Cluster.VectorClock.Node node) { }\n    public bool IsAfter(Akka.Cluster.VectorClock that) { }\n    public bool IsBefore(Akka.Cluster.VectorClock that) { }\n    public bool IsConcurrentWith(Akka.Cluster.VectorClock that) { }\n    public bool IsSameAs(Akka.Cluster.VectorClock that) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Result Generic Struct in C#\nDESCRIPTION: Defines a Result<T> struct used for operation outcomes that can represent either success with a value or failure with an exception. The struct provides methods for creating results and includes nullable annotations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_248\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.IsReadOnlyAttribute()]\npublic struct Result<[System.Runtime.CompilerServices.NullableAttribute(2)]  T> : System.IEquatable<Akka.Util.Result<T>>\n{\n    [System.Runtime.CompilerServices.NullableAttribute(2)]\n    public readonly System.Exception Exception;\n    public readonly bool IsSuccess;\n    [System.Runtime.CompilerServices.NullableAttribute(2)]\n    public readonly T Value;\n    public Result(T value) { }\n    public Result(System.Exception exception) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Actor System Management in Akka.NET TestKit\nDESCRIPTION: Methods for managing actor system lifecycle and behavior during tests. Includes autopilot configuration and shutdown operations with verification options.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\npublic void SetAutoPilot(Akka.TestKit.AutoPilot pilot) { }\npublic virtual void Shutdown(System.Nullable<System.TimeSpan> duration = null, bool verifySystemShutdown = False) { }\nprotected virtual void Shutdown(Akka.Actor.ActorSystem system, System.Nullable<System.TimeSpan> duration = null, bool verifySystemShutdown = False) { }\n```\n\n----------------------------------------\n\nTITLE: Defining Query Classes for Cluster Sharding in C#\nDESCRIPTION: Classes representing various queries for cluster sharding, including getting stats, current regions, entity locations, and shard region states.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class GetClusterShardingStats : Akka.Cluster.Sharding.IClusterShardingSerializable, Akka.Cluster.Sharding.IShardRegionQuery, System.IEquatable<Akka.Cluster.Sharding.GetClusterShardingStats>\n{\n    public readonly System.TimeSpan Timeout;\n    public GetClusterShardingStats(System.TimeSpan timeout) { }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.Cluster.Sharding.GetClusterShardingStats other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n\npublic sealed class GetCurrentRegions : Akka.Cluster.Sharding.IClusterShardingSerializable, Akka.Cluster.Sharding.IShardRegionQuery\n{\n    public static readonly Akka.Cluster.Sharding.GetCurrentRegions Instance;\n    public override string ToString() { }\n}\n\npublic sealed class GetEntityLocation : Akka.Cluster.Sharding.IShardRegionQuery\n{\n    public GetEntityLocation(string entityId, System.TimeSpan timeout) { }\n    public string EntityId { get; }\n    public System.TimeSpan Timeout { get; }\n}\n\npublic sealed class GetShardRegionState : Akka.Cluster.Sharding.IClusterShardingSerializable, Akka.Cluster.Sharding.IShardRegionQuery\n{\n    public static readonly Akka.Cluster.Sharding.GetShardRegionState Instance;\n    public override string ToString() { }\n}\n\npublic sealed class GetShardRegionStats : Akka.Cluster.Sharding.IClusterShardingSerializable, Akka.Cluster.Sharding.IShardRegionQuery\n{\n    public static readonly Akka.Cluster.Sharding.GetShardRegionStats Instance;\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Console Host for Akka.NET Application in C#\nDESCRIPTION: Creates a console host for the Akka.NET application. It sets up the ActorSystem, creates a GreetingActor, sends a Greet message, and handles the application lifecycle.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/deployment/console.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nclass Program\n{\n    static async Task Main(string[] args)\n    {\n        var system = ActorSystem.Create(\"MySystem\");\n        try\n        {\n            Console.WriteLine(\"Actor system created\");\n\n            var props = Props.Create<GreetingActor>();\n            var greeter = system.ActorOf(props, \"greeter\");\n\n            greeter.Tell(new Greet(\"World\"));\n\n            Console.WriteLine(\"Press any key to exit\");\n            Console.ReadLine();\n        }\n        finally\n        {\n            await system.Terminate();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UnboundedMailbox Class in C#\nDESCRIPTION: This sealed class implements an unbounded mailbox type in Akka.NET. It creates an unbounded message queue for actors and implements the IProducesMessageQueue interface.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_103\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class UnboundedMailbox : Akka.Dispatch.MailboxType, Akka.Dispatch.IProducesMessageQueue<Akka.Dispatch.MessageQueues.UnboundedMessageQueue>\n{\n    public UnboundedMailbox() { }\n    public UnboundedMailbox(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }\n    public override Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Recovery for Persistent Actor in C#\nDESCRIPTION: This example demonstrates how to disable the recovery process for a persistent actor by returning Recovery.None.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/event-sourcing.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic override Recovery Recovery => Recovery.None;\n```\n\n----------------------------------------\n\nTITLE: DeleteMessages Classes for Persistence Operations in Akka.Persistence\nDESCRIPTION: A set of classes used for deleting persisted messages and handling the results of delete operations. These classes manage message deletion requests, success notifications, and failure reporting.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DeleteMessagesFailure : Akka.Actor.INoSerializationVerificationNeeded, System.IEquatable<Akka.Persistence.DeleteMessagesFailure>\n{\n    public DeleteMessagesFailure(System.Exception cause, long toSequenceNr) { }\n    public System.Exception Cause { get; }\n    public long ToSequenceNr { get; }\n    public bool Equals(Akka.Persistence.DeleteMessagesFailure other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n\npublic sealed class DeleteMessagesSuccess : System.IEquatable<Akka.Persistence.DeleteMessagesSuccess>\n{\n    public DeleteMessagesSuccess(long toSequenceNr) { }\n    public long ToSequenceNr { get; }\n    public bool Equals(Akka.Persistence.DeleteMessagesSuccess other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n\npublic sealed class DeleteMessagesTo : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IJournalMessage, Akka.Persistence.IJournalRequest, Akka.Persistence.IPersistenceMessage, System.IEquatable<Akka.Persistence.DeleteMessagesTo>\n{\n    public DeleteMessagesTo(string persistenceId, long toSequenceNr, Akka.Actor.IActorRef persistentActor) { }\n    public string PersistenceId { get; }\n    public Akka.Actor.IActorRef PersistentActor { get; }\n    public long ToSequenceNr { get; }\n    public bool Equals(Akka.Persistence.DeleteMessagesTo other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: AtLeastOnceDeliveryActor Class Definition in Akka.Persistence\nDESCRIPTION: Abstract class extending PersistentActor with at-least-once message delivery guarantees, providing methods for delivering and confirming messages to destinations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AtLeastOnceDeliveryActor : Akka.Persistence.PersistentActor\n{\n    protected AtLeastOnceDeliveryActor() { }\n    protected AtLeastOnceDeliveryActor(Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings settings) { }\n    protected AtLeastOnceDeliveryActor(System.Func<Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings, Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings> overrideSettings) { }\n    public int MaxUnconfirmedMessages { get; }\n    public System.TimeSpan RedeliverInterval { get; }\n    public int RedeliveryBurstLimit { get; }\n    public int UnconfirmedCount { get; }\n    public int WarnAfterNumberOfUnconfirmedAttempts { get; }\n    public override void AroundPostStop() { }\n    public override void AroundPreRestart(System.Exception cause, object message) { }\n    protected override bool AroundReceive(Akka.Actor.Receive receive, object message) { }\n    public bool ConfirmDelivery(long deliveryId) { }\n    public void Deliver(Akka.Actor.ActorPath destination, System.Func<long, object> deliveryMessageMapper) { }\n    public void Deliver(Akka.Actor.ActorSelection destination, System.Func<long, object> deliveryMessageMapper) { }\n    public Akka.Persistence.AtLeastOnceDeliverySnapshot GetDeliverySnapshot() { }\n    protected override void OnReplaySuccess() { }\n    public void SetDeliverySnapshot(Akka.Persistence.AtLeastOnceDeliverySnapshot snapshot) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Composing Sources with Materialized Values in Akka.NET Streams\nDESCRIPTION: This snippet demonstrates creating a composite Source where the materialized value of the inner source is propagated to the composite using Keep.Left. The nested source materializes to TaskCompletionSource<int>.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/modularitycomposition.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n// Materializes to TaskCompletionSource<int>      (red)\nvar source = Source.Maybe<int>();\n\n// Materializes to NotUsed                        (black)\nvar flow = Flow.Create<int>().Take(100);\n\n// Materializes to TaskCompletionSource<int>      (red)\nvar nestedSource = source.ViaMaterialized(flow, Keep.Left).Named(\"nestedSource\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Vector Utility in C#\nDESCRIPTION: Provides a Vector static class with methods for creating and manipulating collections, like filling a list with values generated by a function. This adds functional-style collection operations to the framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_260\n\nLANGUAGE: C#\nCODE:\n```\npublic class static Vector\n{\n    public static System.Func<System.Func<T>, System.Collections.Generic.IList<T>> Fill<T>(int number) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SchedulerBase Abstract Class in C#\nDESCRIPTION: Abstract base class for implementing schedulers in Akka.NET. Provides core scheduling functionality including one-time and repeated task scheduling with support for cancellation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class SchedulerBase : Akka.Actor.IActionScheduler, Akka.Actor.IAdvancedScheduler, Akka.Actor.IRunnableScheduler, Akka.Actor.IScheduler, Akka.Actor.ITellScheduler, Akka.Actor.ITimeProvider\n{\n    protected readonly Akka.Event.ILoggingAdapter Log;\n    protected readonly Akka.Configuration.Config SchedulerConfig;\n    protected SchedulerBase(Akka.Configuration.Config scheduler, Akka.Event.ILoggingAdapter log) { }\n    public abstract System.TimeSpan HighResMonotonicClock { get; }\n    public abstract System.TimeSpan MonotonicClock { get; }\n    protected abstract System.DateTimeOffset TimeNow { get; }\n    protected abstract void InternalScheduleOnce(System.TimeSpan delay, System.Action action, Akka.Actor.ICancelable cancelable);\n    protected abstract void InternalScheduleOnce(System.TimeSpan delay, Akka.Dispatch.IRunnable action, Akka.Actor.ICancelable cancelable);\n    protected abstract void InternalScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action, Akka.Actor.ICancelable cancelable);\n    protected abstract void InternalScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Dispatch.IRunnable action, Akka.Actor.ICancelable cancelable);\n    protected abstract void InternalScheduleTellOnce(System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable);\n    protected abstract void InternalScheduleTellRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable);\n    public void ScheduleOnce(System.TimeSpan delay, Akka.Dispatch.IRunnable action, Akka.Actor.ICancelable cancelable) { }\n    public void ScheduleOnce(System.TimeSpan delay, Akka.Dispatch.IRunnable action) { }\n    public void ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Dispatch.IRunnable action, Akka.Actor.ICancelable cancelable) { }\n    public void ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Dispatch.IRunnable action) { }\n    protected static void ValidateDelay(System.TimeSpan delay, string parameterName) { }\n    protected static void ValidateInterval(System.TimeSpan interval, string parameterName) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating ASP.NET Core Controller with Akka.NET Integration\nDESCRIPTION: Demonstrates how to interact with Akka.NET actors from an ASP.NET Core controller using the IActorBridge. The controller sends messages to actors and awaits responses using the Ask pattern.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/deployment/aspnet-core.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class AkkaController : ControllerBase\n{\n    private readonly IActorBridge _bridge;\n    private readonly ILogger<AkkaController> _logger;\n\n    // We'll ask for an instance of the AkkaService, which implements IActorBridge\n    public AkkaController(IActorBridge bridge, ILogger<AkkaController> logger)\n    {\n        _bridge = bridge;\n        _logger = logger;\n    }\n\n    [HttpGet]\n    public async Task<IActionResult> Get(string message, CancellationToken ct)\n    {\n        var actor = _bridge.ActorSelection(\"/user/example\");\n\n        // need to explicitly specify ct in both Ask overloads here\n        var response = await actor.Ask<Response>(new Request(message), ct);\n\n        return Ok(response);\n    }\n\n    [HttpGet(\"createactor\")]\n    public IActionResult CreateActor(string actorName)\n    {\n        var actorRef = _bridge.ActorOf(Props.Create(() => new ExampleActor()), actorName);\n        return Ok($\"Actor [{actorRef}] created\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TCP Commands and Events in C#\nDESCRIPTION: Defines various TCP command and event classes including SuspendReading, Unbind, Unbound, and Write. These classes are part of Akka.NET's TCP API for controlling socket operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_164\n\nLANGUAGE: C#\nCODE:\n```\npublic class SuspendReading : Akka.IO.Tcp.Command\n{\n    public static readonly Akka.IO.Tcp.SuspendReading Instance;\n}\npublic class Unbind : Akka.IO.Tcp.Command\n{\n    public static readonly Akka.IO.Tcp.Unbind Instance;\n}\npublic class Unbound : Akka.IO.Tcp.Event\n{\n    public static readonly Akka.IO.Tcp.Unbound Instance;\n}\npublic class Write : Akka.IO.Tcp.SimpleWriteCommand\n{\n    public static readonly Akka.IO.Tcp.Write Empty;\n    public override Akka.IO.Tcp.Event Ack { get; }\n    public Akka.IO.ByteString Data { get; }\n    public static Akka.IO.Tcp.Write Create(Akka.IO.ByteString data) { }\n    public static Akka.IO.Tcp.Write Create(Akka.IO.ByteString data, Akka.IO.Tcp.Event ack) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Stream Logging with Log() in C#\nDESCRIPTION: Shows how to use the Log() operation with custom log levels and adapters for more advanced logging capabilities.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/cookbook.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// customize log levels\nmySource.Log(\"before-select\")\n    .WithAttributes(Attributes.CreateLogLevels(onElement: LogLevel.WarningLevel))\n    .Select(Analyse);\n\n// or provide custom logging adapter\nmySource.Log(\"custom\", null, Logging.GetLogger(sys, \"customLogger\"));\n```\n\n----------------------------------------\n\nTITLE: Implementing ChannelTaskScheduler Class in Akka.NET\nDESCRIPTION: Defines a TaskScheduler extension that provides different priority-based task schedulers (High, Normal, Low, Idle) for the actor system. It implements IExtension and IDisposable interfaces to integrate with Akka's extension system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_83\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ChannelTaskScheduler : Akka.Actor.IExtension, System.IDisposable\n    {\n        public ChannelTaskScheduler(Akka.Actor.ExtendedActorSystem system) { }\n        public System.Threading.Tasks.TaskScheduler High { get; }\n        public System.Threading.Tasks.TaskScheduler Idle { get; }\n        public System.Threading.Tasks.TaskScheduler Low { get; }\n        public System.Threading.Tasks.TaskScheduler Normal { get; }\n        public void Dispose() { }\n        public static Akka.Dispatch.ChannelTaskScheduler Get(Akka.Actor.ActorSystem system) { }\n        public System.Threading.Tasks.TaskScheduler GetScheduler(Akka.Dispatch.TaskSchedulerPriority priority) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Configuring Log Filtering in Akka.NET\nDESCRIPTION: This snippet outlines the process of setting up log filtering rules in Akka.NET to manage logged output effectively. It can help maintain a cleaner log file by excluding unnecessary messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/logging.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nActorSystemSetup completeSetup = CustomLoggerSetup();\n\n// start the ActorSystem with the LogFilterBuilder rules enabled\nActorSystem mySystem = ActorSystem.Create(\"MySys\", completeSetup);\n```\n\n----------------------------------------\n\nTITLE: Implementing Actor Address Class in C#\nDESCRIPTION: Implementation of the Address class which handles actor system addressing, including protocol, system, host and port information. Implements multiple interfaces for comparison and cloning functionality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Address : Akka.Util.ISurrogated, System.ICloneable, System.IComparable, System.IComparable<Akka.Actor.Address>, System.IEquatable<Akka.Actor.Address>\n{\n    public static readonly Akka.Actor.Address AllSystems;\n    public static readonly System.Collections.Generic.IComparer<Akka.Actor.Address> Comparer;\n    public Address(string protocol, string system, string host = null, System.Nullable<int> port = null) { }\n    public bool HasGlobalScope { get; }\n    public bool HasLocalScope { get; }\n    public string Host { get; }\n    public System.Nullable<int> Port { get; }\n    public string Protocol { get; }\n    public string System { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Sender Actor in Akka.NET Cluster\nDESCRIPTION: Example of an actor that sends point-to-point messages to a specific path using the DistributedPubSubMediator. Messages will be routed to one of the actors registered with that path across the cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/distributed-publish-subscribe.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Sender : ReceiveActor\n{\n    private readonly IActorRef _mediator;\n    private readonly ICancelable _task;\n\n    private int _count = 0;\n\n    public class Tick { }\n\n    public Sender()\n    {\n        // activate the extension\n        _mediator = DistributedPubSub.Get(Context.System).Mediator;\n\n        Receive<Tick>(_ => \n        {\n            var msg = $\"Message #{_count++}\";\n            // send to the path\n            _mediator.Tell(new Send(\"/user/destination\", msg));\n            Console.WriteLine($\"Sent {msg}\");\n        });\n\n        // publishes a message every second\n        _task = Context.System.Scheduler.ScheduleTellRepeatedlyCancelable(\n            TimeSpan.FromSeconds(1),\n            TimeSpan.FromSeconds(1),\n            Self, new Tick(), Self);\n    }\n\n    protected override void PostStop()\n    {\n        // clean up resources\n        _task.Cancel();\n\n        base.PostStop();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating UnhandledMessageActor for Akka.NET Testing\nDESCRIPTION: An actor that leaves all messages unhandled. This test actor is useful for testing the unhandled message behavior of an Akka.NET actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_54\n\nLANGUAGE: C#\nCODE:\n```\npublic class UnhandledMessageActor : Akka.Actor.ReceiveActor\n{\n    public UnhandledMessageActor() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Stateful Round-Robin Function in PartitionHub Using C#\nDESCRIPTION: This snippet provides an example of a stateful partition function using a StatefulSink. It shows how to maintain state across different materializations and route elements in a round-robin fashion while holding state specific to each consumer.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/stream-dynamic.md#2025-04-16_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[HubsDocTests.cs](../../../src/core/Akka.Docs.Tests/Streams/HubsDocTests.cs?name=partition-hub-stateful)]\n```\n\n----------------------------------------\n\nTITLE: Peeking and Receiving Messages in Akka.NET TestKitBase\nDESCRIPTION: These methods allow for peeking at and receiving messages from the actor system. They support both synchronous and asynchronous operations with optional timeouts and cancellation tokens.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\npublic object PeekOne(System.Nullable<System.TimeSpan> max = null, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic System.Threading.Tasks.ValueTask<object> PeekOneAsync(System.Nullable<System.TimeSpan> max = null, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic System.Collections.Generic.IReadOnlyCollection<object> ReceiveN(int numberOfMessages, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.AsyncIteratorStateMachineAttribute(typeof(Akka.TestKit.TestKitBase.<ReceiveNAsync>d__212))]\npublic System.Collections.Generic.IAsyncEnumerable<object> ReceiveNAsync(int numberOfMessages, [System.Runtime.CompilerServices.EnumeratorCancellationAttribute()] System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract Least Shard Allocation Strategy in C#\nDESCRIPTION: Abstract class implementing core shard allocation logic with methods for rebalancing and region management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AbstractLeastShardAllocationStrategy : Akka.Actor.INoSerializationVerificationNeeded, Akka.Cluster.Sharding.IActorSystemDependentAllocationStrategy, Akka.Cluster.Sharding.IShardAllocationStrategy\n{\n    protected AbstractLeastShardAllocationStrategy() { }\n    protected virtual Akka.Cluster.ClusterEvent.CurrentClusterState ClusterState { get; }\n    protected virtual Akka.Cluster.Member SelfMember { get; }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> AllocateShard(Akka.Actor.IActorRef requester, string shardId, System.Collections.Immutable.IImmutableDictionary<Akka.Actor.IActorRef, System.Collections.Immutable.IImmutableList<string>> currentShardAllocations) { }\n    protected bool IsAGoodTimeToRebalance(System.Collections.Generic.IEnumerable<Akka.Cluster.Sharding.Internal.AbstractLeastShardAllocationStrategy.RegionEntry> regionEntries) { }\n    public abstract System.Threading.Tasks.Task<System.Collections.Immutable.IImmutableSet<string>> Rebalance(System.Collections.Immutable.IImmutableDictionary<Akka.Actor.IActorRef, System.Collections.Immutable.IImmutableList<string>> currentShardAllocations, System.Collections.Immutable.IImmutableSet<string> rebalanceInProgress);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Factorial Stream with File Output\nDESCRIPTION: Transforms the integer source into factorial numbers and writes them to a file\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/quickstart.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar factorials = source.Scan(new BigInteger(1), (acc, next) => acc * next);\nvar result =\n    factorials\n        .Select(num => ByteString.FromString($\"{num}\\n\"))\n        .RunWith(FileIO.ToFile(new FileInfo(\"factorials.txt\")), materializer);\n```\n\n----------------------------------------\n\nTITLE: Implementing Guardian Actor for Akka.NET in C#\nDESCRIPTION: Defines a GuardianActor class that serves as a top-level actor in the Akka.NET actor system. It implements basic lifecycle methods and message handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic class GuardianActor : Akka.Actor.ActorBase, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedMessageQueueSemantics>\n{\n    public GuardianActor() { }\n    protected override void PreStart() { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Update and Update Responses in Akka.NET Distributed Data\nDESCRIPTION: These classes represent update operations and their responses in Akka.NET's Distributed Data module. They include classes for update requests, successful updates, and update timeouts, with properties for keys, consistency, and modification functions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Update : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public Update(Akka.DistributedData.IKey key, Akka.DistributedData.IWriteConsistency consistency, System.Func<Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedData> modify, object request = null) { }\n    public Update(Akka.DistributedData.IKey key, Akka.DistributedData.IReplicatedData initial, Akka.DistributedData.IWriteConsistency consistency, System.Func<Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedData> modify, object request = null) { }\n    public Akka.DistributedData.IWriteConsistency Consistency { get; }\n    public Akka.DistributedData.IKey Key { get; }\n    public System.Func<Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedData> Modify { get; }\n    public object Request { get; }\n    public override string ToString() { }\n}\n\npublic sealed class UpdateSuccess : Akka.Actor.INoSerializationVerificationNeeded, Akka.DistributedData.IUpdateResponse, System.IEquatable<Akka.DistributedData.UpdateSuccess>\n{\n    public UpdateSuccess(Akka.DistributedData.IKey key, object request) { }\n    public bool IsSuccessful { get; }\n    public Akka.DistributedData.IKey Key { get; }\n    public object Request { get; }\n    public bool Equals(Akka.DistributedData.UpdateSuccess other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public void ThrowOnFailure() { }\n    public override string ToString() { }\n}\n\npublic sealed class UpdateTimeout : Akka.Actor.INoSerializationVerificationNeeded, Akka.DistributedData.IUpdateFailure, Akka.DistributedData.IUpdateResponse, System.IEquatable<Akka.DistributedData.UpdateTimeout>\n{\n    public UpdateTimeout(Akka.DistributedData.IKey key, object request) { }\n    public System.Exception Cause { get; }\n    public bool IsSuccessful { get; }\n    public Akka.DistributedData.IKey Key { get; }\n    public object Request { get; }\n    public bool Equals(Akka.DistributedData.UpdateTimeout other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public void ThrowOnFailure() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Complete DeviceGroupQuery Implementation in Akka.NET\nDESCRIPTION: Full implementation of the DeviceGroupQuery actor that collects temperature readings from device actors with timeout handling, response tracking, and result aggregation. It uses Context.Become() for state management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-4.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DeviceGroupQuery : UntypedActor\n{\n    private ICancelable queryTimeoutTimer;\n\n    public DeviceGroupQuery(\n        Dictionary<string, IActorRef> actorToDeviceId,\n        long requestId,\n        IActorRef requester,\n        TimeSpan timeout)\n    {\n        ActorToDeviceId = actorToDeviceId;\n        RequestId = requestId;\n        Requester = requester;\n        Timeout = timeout;\n\n        queryTimeoutTimer = Context.System.Scheduler.ScheduleTellOnceCancelable(\n            timeout,\n            Self,\n            new CollectionTimeout(),\n            Self);\n\n        foreach (var deviceActor in ActorToDeviceId.Values)\n        {\n            Context.Watch(deviceActor);\n            deviceActor.Tell(new ReadTemperature(0L));\n        }\n    }\n\n    protected override void OnReceive(object message)\n    {\n        var repliesSoFar = new Dictionary<string, TemperatureReading>();\n        var stillWaiting = new HashSet<IActorRef>(ActorToDeviceId.Values);\n\n        Context.Become(WaitingForReplies(repliesSoFar, stillWaiting));\n\n        // We need the first handler to be active immediately as there might be responses arriving\n        // even before we get scheduled to run the first time, so we manually call the handler\n        Receive(message);\n    }\n\n    private UntypedReceive WaitingForReplies(\n        Dictionary<string, TemperatureReading> repliesSoFar,\n        HashSet<IActorRef> stillWaiting)\n    {\n        return message =>\n        {\n            if (message is RespondTemperature response)\n            {\n                var deviceActor = Sender;\n                ReceivedResponse(deviceActor, response.RequestId, response.Temperature, repliesSoFar, stillWaiting);\n            }\n            else if (message is Terminated t)\n            {\n                var deviceActor = t.ActorRef;\n                ReceivedResponse(deviceActor, 0L, null, repliesSoFar, stillWaiting);\n            }\n            else if (message is CollectionTimeout)\n            {\n                var replies = new Dictionary<string, TemperatureReading>(repliesSoFar);\n                foreach (var deviceActor in stillWaiting)\n                {\n                    var deviceId = ActorToDeviceId[deviceActor];\n                    replies.Add(deviceId, TemperatureNotAvailable.Instance);\n                }\n\n                Requester.Tell(new RespondAllTemperatures(RequestId, replies));\n                Context.Stop(Self);\n            }\n        };\n    }\n\n    private void ReceivedResponse(\n        IActorRef deviceActor,\n        long requestId,\n        double? temperature,\n        Dictionary<string, TemperatureReading> repliesSoFar,\n        HashSet<IActorRef> stillWaiting)\n    {\n        Context.Unwatch(deviceActor);\n        var deviceId = ActorToDeviceId[deviceActor];\n\n        stillWaiting.Remove(deviceActor);\n\n        TemperatureReading reading;\n        if (temperature.HasValue)\n        {\n            reading = new Temperature(temperature.Value);\n        }\n        else\n        {\n            reading = DeviceNotAvailable.Instance;\n        }\n\n        repliesSoFar.Add(deviceId, reading);\n\n        if (stillWaiting.Count == 0)\n        {\n            Requester.Tell(new RespondAllTemperatures(RequestId, repliesSoFar));\n            Context.Stop(Self);\n        }\n        else\n        {\n            Context.Become(WaitingForReplies(repliesSoFar, stillWaiting));\n        }\n    }\n\n    protected override void PostStop()\n    {\n        queryTimeoutTimer.Cancel();\n    }\n\n    public Dictionary<string, IActorRef> ActorToDeviceId { get; }\n    public long RequestId { get; }\n    public IActorRef Requester { get; }\n    public TimeSpan Timeout { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WriteMessages Class in Akka.NET\nDESCRIPTION: The WriteMessages class represents a request to write multiple messages to the journal. It contains the messages, the persistent actor reference, and the actor instance ID.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_45\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class WriteMessages : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IJournalMessage, Akka.Persistence.IJournalRequest, Akka.Persistence.IPersistenceMessage, System.IEquatable<Akka.Persistence.WriteMessages>\n{\n    public WriteMessages(System.Collections.Generic.IEnumerable<Akka.Persistence.IPersistentEnvelope> messages, Akka.Actor.IActorRef persistentActor, int actorInstanceId) { }\n    public int ActorInstanceId { get; }\n    public System.Collections.Generic.IEnumerable<Akka.Persistence.IPersistentEnvelope> Messages { get; }\n    public Akka.Actor.IActorRef PersistentActor { get; }\n    public bool Equals(Akka.Persistence.WriteMessages other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing External Shard Allocation in C#\nDESCRIPTION: Defines the external shard allocation system for Akka.NET clusters, including client timeout handling, allocation strategy, and location management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Net.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ExternalShardAllocation : Akka.Actor.IExtension\n{\n    public ExternalShardAllocation(Akka.Actor.ExtendedActorSystem system) { }\n    public Akka.Cluster.Sharding.External.IExternalShardAllocationClient ClientFor(string typeName) { }\n    public static Akka.Cluster.Sharding.External.ExternalShardAllocation Get(Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Message Types and Interfaces for Cluster Client Communication in C#\nDESCRIPTION: Collection of interfaces and message types that define the communication protocol between cluster clients and the cluster. Includes interfaces for client interactions, contact point changes, and subscription management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Core.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class GetClusterClients\n{\n    public static Akka.Cluster.Tools.Client.GetClusterClients Instance { get; }\n}\n\npublic sealed class GetContactPoints : Akka.Cluster.Tools.Client.IGetContactPoints\n{\n    public static readonly Akka.Cluster.Tools.Client.GetContactPoints Instance;\n}\n\npublic interface IClusterClientInteraction\n{\n    Akka.Actor.IActorRef ClusterClient { get; }\n}\n\npublic interface IClusterClientMessage { }\n\npublic interface IContactPointChange\n{\n    Akka.Actor.ActorPath ContactPoint { get; }\n}\n\npublic interface IGetContactPoints { }\n\npublic interface ISubscribeContactPoints { }\n\npublic interface IUnsubscribeContactPoints { }\n\npublic sealed class SubscribeClusterClients\n{\n    public static Akka.Cluster.Tools.Client.SubscribeClusterClients Instance { get; }\n}\n\npublic sealed class SubscribeContactPoints : Akka.Cluster.Tools.Client.ISubscribeContactPoints\n{\n    public static readonly Akka.Cluster.Tools.Client.SubscribeContactPoints Instance;\n}\n\npublic sealed class UnsubscribeClusterClients\n{\n    public static Akka.Cluster.Tools.Client.UnsubscribeClusterClients Instance { get; }\n}\n\npublic sealed class UnsubscribeContactPoints : Akka.Cluster.Tools.Client.IUnsubscribeContactPoints\n{\n    public static readonly Akka.Cluster.Tools.Client.UnsubscribeContactPoints Instance;\n}\n```\n\n----------------------------------------\n\nTITLE: StopChild Message for Actor Child Termination\nDESCRIPTION: Message for stopping a specific child actor. Contains a reference to the child actor that should be stopped.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_104\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class StopChild\n{\n    public StopChild(Akka.Actor.IActorRef child) { }\n    public Akka.Actor.IActorRef Child { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: ReachabilityEvent Abstract Class\nDESCRIPTION: This snippet defines an abstract class `ReachabilityEvent` that implements multiple interfaces related to cluster events and dead letter suppression.  It represents events related to the reachability of cluster members.  It contains a `Member` property and overrides `Equals`, `GetHashCode`, and `ToString`.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class ReachabilityEvent : Akka.Cluster.ClusterEvent.IClusterDomainEvent, Akka.Cluster.ClusterEvent.IReachabilityEvent, Akka.Event.IDeadLetterSuppression\n{\n    protected ReachabilityEvent(Akka.Cluster.Member member) { }\n    public Akka.Cluster.Member Member { get; }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing a Custom Sink in C#\nDESCRIPTION: This snippet demonstrates how to test a custom sink by attaching a source that emits elements from a predefined collection, running a test flow, and asserting on the results produced by the sink.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/testingstreams.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar sinkUnderTest = Flow.Create<int>()\n    .Select(x => x*2)\n    .ToMaterialized(Sink.Aggregate<int, int>(0, (sum, i) => sum + i), Keep.Right);\n\nvar task = Source.From(Enumerable.Range(1, 4)).RunWith(sinkUnderTest, materializer);\ntask.Wait(TimeSpan.FromMilliseconds(500)).Should().BeTrue();\ntask.Result.Should().Be(20);\n```\n\n----------------------------------------\n\nTITLE: Discovery Extension Class Definition in C#\nDESCRIPTION: Defines the main Discovery extension for Akka.NET that provides access to service discovery mechanisms. This class acts as the primary entry point for service discovery functionality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.DotNet.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic class Discovery : Akka.Actor.IExtension\n{\n    public Discovery(Akka.Actor.ExtendedActorSystem system) { }\n    public Akka.Discovery.ServiceDiscovery Default { get; }\n    public static Akka.Discovery.Discovery Get(Akka.Actor.ActorSystem system) { }\n    public Akka.Discovery.ServiceDiscovery LoadServiceDiscovery(string method) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Collection and Object Extension Methods in C#\nDESCRIPTION: Provides Extensions static class with various extension methods for collections and objects. These include methods for dictionary operations, collection transformations, and time span comparisons.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_264\n\nLANGUAGE: C#\nCODE:\n```\npublic class static Extensions\n{\n    public static System.Collections.Generic.IDictionary<TKey, TValue> AddAndReturn<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> hash, TKey key, TValue value) { }\n    [System.ObsoleteAttribute(\"Use the dictionary setter directly\")]\n    public static void AddOrSet<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> hash, TKey key, TValue value) { }\n    public static T AsInstanceOf<T>(this object self) { }\n    public static string BetweenDoubleQuotes(this string self) { }\n    public static System.Collections.Generic.IEnumerable<T> Concat<[System.Runtime.CompilerServices.NullableAttribute(2)]  T>([System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            2,\n            1})] this System.Collections.Generic.IEnumerable<T> enumerable, T item) { }\n    public static System.Collections.Generic.IEnumerable<T> Drop<T>(this System.Collections.Generic.IEnumerable<T> self, int count) { }\n    public static void ForEach<T>(this System.Collections.Generic.IEnumerable<T> source, System.Action<T> action) { }\n    public static TValue GetOrElse<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> hash, TKey key, TValue elseValue) { }\n    public static T Head<T>(this System.Collections.Generic.IEnumerable<T> self) { }\n    public static string Join(this System.Collections.Generic.IEnumerable<string> self, string separator) { }\n    public static System.TimeSpan Max(this System.TimeSpan @this, System.TimeSpan other) { }\n    public static System.TimeSpan Min(this System.TimeSpan @this, System.TimeSpan other) { }\n    public static System.Collections.Generic.IEnumerable<string> SplitDottedPathHonouringQuotes(this string path) { }\n    public static System.Collections.Generic.IEnumerable<T> TakeRight<T>(this System.Collections.Generic.IEnumerable<T> self, int n) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Message Reception with ReceiveAny\nDESCRIPTION: Demonstrates use of ReceiveAny for handling messages of any type as a catch-all handler.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\nReceive<string>(s => Console.WriteLine(\"Received string: \" + s);\nReceiveAny(o => Console.WriteLine(\"Received object: \" + o);\n```\n\nLANGUAGE: csharp\nCODE:\n```\nReceiveAny(o => Console.WriteLine(\"Received object: \" + o);\nReceive<string>(s => Console.WriteLine(\"Received string: \" + s);  //This will cause an exception\n```\n\nLANGUAGE: csharp\nCODE:\n```\nReceiveAny(o => Console.WriteLine(\"Received object: \" + o);\nReceive<object>(o => Console.WriteLine(\"Received object: \" + o);\n```\n\n----------------------------------------\n\nTITLE: Implementing Cluster Sharding Message Serialization in C#\nDESCRIPTION: Serializer implementation for cluster sharding messages in Akka.NET with binary conversion support.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Core.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterShardingMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public ClusterShardingMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object o) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Message Protocol for Akka.Delivery\nDESCRIPTION: Demonstrates how to organize messages into protocol groups using interfaces for type-safety in Akka.Delivery. Shows the definition of a common interface and implementing message classes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/reliable-delivery.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IDeliveryMessage { }\n\npublic class Message1 : IDeliveryMessage\n{\n    public string Data { get; }\n    public Message1(string data) => Data = data;\n}\n\npublic class Message2 : IDeliveryMessage\n{\n    public int Number { get; }\n    public Message2(int number) => Number = number;\n}\n```\n\n----------------------------------------\n\nTITLE: Summing Tweet Counts with RunWith in C#\nDESCRIPTION: Demonstrates a one-liner Akka.NET stream setup using `RunWith` that counts the number of tweets processed. This method is analogous to using `Keep.Right` and takes a source, processes it through a flow into a sink, and directly materializes the result. Dependencies: Akka.NET library. Inputs: Tweet source stream. Output: Total count of tweets in a single materialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/reactivetweets.md#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nvar sum = tweetSource.Select(_ => 1).RunWith(sumSink, mat);\n```\n\n----------------------------------------\n\nTITLE: Implementing ExternalShardAllocation Class in C#\nDESCRIPTION: Defines classes for external shard allocation including the main ExternalShardAllocation class and its strategy implementation. Handles allocation of shards across nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ExternalShardAllocation : Akka.Actor.IExtension\n{\n    public ExternalShardAllocation(Akka.Actor.ExtendedActorSystem system) { }\n    public Akka.Cluster.Sharding.External.IExternalShardAllocationClient ClientFor(string typeName) { }\n    public static Akka.Cluster.Sharding.External.ExternalShardAllocation Get(Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DeadLetter Handling in C#\nDESCRIPTION: Specialized actor reference implementation for handling undelivered messages in the actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic class DeadLetterActorRef : Akka.Actor.EmptyLocalActorRef\n{\n    public DeadLetterActorRef(Akka.Actor.IActorRefProvider provider, Akka.Actor.ActorPath path, Akka.Event.EventStream eventStream) { }\n    protected override bool SpecialHandle(object message, Akka.Actor.IActorRef sender) { }\n    protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing HashCodeMessageExtractor in C#\nDESCRIPTION: An abstract class for extracting entity and shard IDs from messages using hash codes, with a maximum number of shards.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Core.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class HashCodeMessageExtractor : Akka.Cluster.Sharding.IMessageExtractor\n{\n    public readonly int MaxNumberOfShards;\n    protected HashCodeMessageExtractor(int maxNumberOfShards) { }\n    public static Akka.Cluster.Sharding.HashCodeMessageExtractor Create(int maxNumberOfShards, System.Func<object, string> entityIdExtractor, System.Func<object, object> messageExtractor = null) { }\n    public abstract string EntityId(object message);\n    public virtual object EntityMessage(object message) { }\n    public virtual string ShardId(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating LocalSnapshotStore Class in C#\nDESCRIPTION: Implements a LocalSnapshotStore class that extends SnapshotStore. It provides methods for saving, loading, and deleting snapshots using the local file system. The class includes functionality for serialization and file management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_53\n\nLANGUAGE: C#\nCODE:\n```\npublic class LocalSnapshotStore : Akka.Persistence.Snapshot.SnapshotStore\n{\n    public LocalSnapshotStore() { }\n    protected override System.Threading.Tasks.Task DeleteAsync(Akka.Persistence.SnapshotMetadata metadata) { }\n    protected override System.Threading.Tasks.Task DeleteAsync(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria) { }\n    protected System.IO.FileInfo GetSnapshotFileForWrite(Akka.Persistence.SnapshotMetadata metadata, string extension = \"\") { }\n    protected override System.Threading.Tasks.Task<Akka.Persistence.SelectedSnapshot> LoadAsync(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria) { }\n    protected override void PreStart() { }\n    protected override bool ReceivePluginInternal(object message) { }\n    protected virtual void Save(Akka.Persistence.SnapshotMetadata metadata, object snapshot) { }\n    protected override System.Threading.Tasks.Task SaveAsync(Akka.Persistence.SnapshotMetadata metadata, object snapshot) { }\n    protected void Serialize(System.IO.Stream stream, Akka.Persistence.Serialization.Snapshot snapshot) { }\n    protected System.IO.FileInfo WithOutputStream(Akka.Persistence.SnapshotMetadata metadata, System.Action<System.IO.Stream> p) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LWWRegister Class in C#\nDESCRIPTION: This snippet defines a sealed class `LWWRegister<T>` that implements the `IReplicatedData` interface. It represents a Last-Write-Wins (LWW) register, a replicated data structure where the latest write wins in case of conflicts. It stores a value, a timestamp, and the unique address of the node that last updated the value.  Constructors allow for initialization with a provided clock or using default clock.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\n    public sealed class LWWRegister<T> : Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.LWWRegister<T>>, System.IEquatable<Akka.DistributedData.LWWRegister<T>>\n    {\n        public static readonly Akka.DistributedData.Clock<T> DefaultClock;\n        public static readonly Akka.DistributedData.Clock<T> ReverseClock;\n        public LWWRegister(Akka.Cluster.UniqueAddress node, T initial) { }\n        public LWWRegister(Akka.Cluster.UniqueAddress node, T value, long timestamp) { }\n        public LWWRegister(Akka.Cluster.UniqueAddress node, T initial, Akka.DistributedData.Clock<T> clock) { }\n        public System.Type RegisterType { get; }\n        public long Timestamp { get; }\n        public Akka.Cluster.UniqueAddress UpdatedBy { get; }\n        public T Value { get; }\n        public bool Equals(Akka.DistributedData.LWWRegister<T> other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n        public Akka.DistributedData.LWWRegister<T> Merge(Akka.DistributedData.LWWRegister<T> other) { }\n        public Akka.DistributedData.IReplicatedData Merge(Akka.DistributedData.IReplicatedData other) { }\n        public override string ToString() { }\n        public Akka.DistributedData.LWWRegister<T> WithValue(Akka.Cluster.UniqueAddress node, T value, Akka.DistributedData.Clock<T> clock = null) { }\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Decider Pattern in C#\nDESCRIPTION: Static class implementing the Decider pattern for handling actor failures and supervision in Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic class static Decider\n{\n    public static Akka.Actor.DeployableDecider From(Akka.Actor.Directive defaultDirective, params System.Collections.Generic.KeyValuePair<, >[] pairs) { }\n    public static Akka.Actor.DeployableDecider From(Akka.Actor.Directive defaultDirective, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.Type, Akka.Actor.Directive>> pairs) { }\n    public static Akka.Actor.LocalOnlyDecider From(System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider) { }\n}\n```\n\n----------------------------------------\n\nTITLE: C# Actor System Exception Classes\nDESCRIPTION: Defines custom exception classes for actor-related errors including IntentionalActorRestartException, InvalidActorNameException, InvalidMessageException, and LoggerInitializationException.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class IntentionalActorRestartException : Akka.Actor.AkkaException\n{\n    public IntentionalActorRestartException() { }\n}\n```\n\n----------------------------------------\n\nTITLE: RandomGroup Class in Akka.NET Routing\nDESCRIPTION: Implements a group router with random selection strategy. It routes messages to a randomly selected actor from a predefined set of actor paths with various constructors for different initialization scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_182\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class RandomGroup : Akka.Routing.Group\n{\n    public RandomGroup(Akka.Configuration.Config config) { }\n    public RandomGroup(params string[] paths) { }\n    public RandomGroup(System.Collections.Generic.IEnumerable<string> paths) { }\n    public RandomGroup(System.Collections.Generic.IEnumerable<string> paths, string routerDispatcher) { }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Routing.RandomGroup WithDispatcher(string dispatcher) { }\n    public class RandomGroupSurrogate : Akka.Util.ISurrogate\n    {\n        public RandomGroupSurrogate() { }\n        public System.Collections.Generic.IEnumerable<string> Paths { get; set; }\n        public string RouterDispatcher { get; set; }\n        public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DistributedPubSub Extension in C#\nDESCRIPTION: Implements the DistributedPubSub extension for Akka.NET, providing a mediator for distributed publish-subscribe operations across a cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Core.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DistributedPubSub : Akka.Actor.IExtension\n{\n    public DistributedPubSub(Akka.Actor.ExtendedActorSystem system) { }\n    public bool IsTerminated { get; }\n    public Akka.Actor.IActorRef Mediator { get; }\n    public static Akka.Configuration.Config DefaultConfig() { }\n    public static Akka.Cluster.Tools.PublishSubscribe.DistributedPubSub Get(Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TokenBucket Abstract Class in C#\nDESCRIPTION: An abstract base class for token bucket rate limiters with methods to initialize and consume tokens at controlled rates.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_237\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic abstract class TokenBucket\n{\n    protected TokenBucket(long capacity, long ticksBetweenTokens) { }\n    public abstract long CurrentTime { get; }\n    public void Init() { }\n    public long Offer(long cost) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SmallestMailboxRoutingLogic in C#\nDESCRIPTION: Defines a routing logic implementation that selects the routee with the smallest mailbox. This logic is useful for load balancing in Akka.NET actor systems.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_202\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SmallestMailboxRoutingLogic : Akka.Routing.RoutingLogic\n    {\n        public SmallestMailboxRoutingLogic() { }\n        public SmallestMailboxRoutingLogic(int next) { }\n        public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing PropsSurrogate Class for Props Serialization\nDESCRIPTION: Provides serialization support for Props objects by implementing the ISurrogate interface. Stores actor constructor arguments to enable serialization and deserialization of Props instances.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\npublic class PropsSurrogate : Akka.Util.ISurrogate\n{\n    public PropsSurrogate() { }\n    public object[] Arguments { get; set; }\n```\n\n----------------------------------------\n\nTITLE: Implementing GCounter Class in C# for Akka.NET Distributed Data\nDESCRIPTION: Defines the GCounter class, a grow-only counter for distributed systems. It implements various interfaces for replicated data and includes methods for incrementing, merging, and pruning.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class GCounter : Akka.DistributedData.FastMerge<Akka.DistributedData.GCounter>, Akka.DistributedData.IDeltaReplicatedData, Akka.DistributedData.IDeltaReplicatedData<Akka.DistributedData.GCounter, Akka.DistributedData.GCounter>, Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IRemovedNodePruning<Akka.DistributedData.GCounter>, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.GCounter>, Akka.DistributedData.IReplicatedDelta, System.IEquatable<Akka.DistributedData.GCounter>\n{\n    public GCounter() { }\n    public Akka.DistributedData.GCounter Delta { get; }\n    public static Akka.DistributedData.GCounter Empty { get; }\n    public System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.UniqueAddress> ModifiedByNodes { get; }\n    public System.Collections.Immutable.ImmutableDictionary<Akka.Cluster.UniqueAddress, ulong> State { get; }\n    public ulong Value { get; }\n    public bool Equals(Akka.DistributedData.GCounter other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public Akka.DistributedData.GCounter Increment(Akka.Cluster.Cluster node, ulong delta = 1) { }\n    public Akka.DistributedData.GCounter Increment(Akka.Cluster.UniqueAddress node, ulong n = 1) { }\n    public override Akka.DistributedData.GCounter Merge(Akka.DistributedData.GCounter other) { }\n    public Akka.DistributedData.GCounter MergeDelta(Akka.DistributedData.GCounter delta) { }\n    public bool NeedPruningFrom(Akka.Cluster.UniqueAddress removedNode) { }\n    public Akka.DistributedData.GCounter Prune(Akka.Cluster.UniqueAddress removedNode, Akka.Cluster.UniqueAddress collapseInto) { }\n    public Akka.DistributedData.GCounter PruningCleanup(Akka.Cluster.UniqueAddress removedNode) { }\n    public Akka.DistributedData.GCounter ResetDelta() { }\n    public override string ToString() { }\n    public static ulong op_Implicit(Akka.DistributedData.GCounter counter) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Random Router Implementation Classes\nDESCRIPTION: Implementation of random routing logic including both pool and group router variants. Provides random selection of routees for message distribution.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_184\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class RandomLogic : Akka.Routing.RoutingLogic\n{\n    public RandomLogic() { }\n    public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }\n}\n\npublic sealed class RandomPool : Akka.Routing.Pool\n{\n    public RandomPool(int nrOfInstances) { }\n    public RandomPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False) { }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Looking up Remote Actor Addresses in Akka.NET C#\nDESCRIPTION: Shows how to use ActorSelection to look up remote actor addresses when remoting is enabled in Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nContext.ActorSelection(\"akka.tcp://app@otherhost:1234/user/serviceB\");\n```\n\n----------------------------------------\n\nTITLE: Declarative API for Simplifying Event Handling - Scala\nDESCRIPTION: This snippet introduces operations such as `Emit(out, elem)` and `Read(in, andThen, onClose)` which provide a declarative way of managing events for output and input ports. It simplifies the control flow in stream processing but comes with the caveat of requiring careful management of the handlers during operation execution.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/custom-stream-processing.md#2025-04-16_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nEmit(out, elem)\nRead(in, andThen, onClose)\n```\n\n----------------------------------------\n\nTITLE: PNCounter Dictionary Implementation in C#\nDESCRIPTION: Comprehensive implementation of a distributed PN-Counter dictionary with support for delta-based replication, node pruning, and data serialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class PNCounterDictionary<TKey> : Akka.DistributedData.IDeltaReplicatedData, Akka.DistributedData.IDeltaReplicatedData<Akka.DistributedData.PNCounterDictionary<TKey>, Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.PNCounter>.IDeltaOperation>, Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IRemovedNodePruning<Akka.DistributedData.PNCounterDictionary<TKey>>, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.PNCounterDictionary<TKey>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, System.Numerics.BigInteger>>, System.Collections.IEnumerable, System.IEquatable<Akka.DistributedData.PNCounterDictionary<TKey>>\n{\n    public static readonly Akka.DistributedData.PNCounterDictionary<TKey> Empty;\n    public PNCounterDictionary(Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.PNCounter> underlying) { }\n    public int Count { get; }\n    public Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.PNCounter>.IDeltaOperation Delta { get; }\n    public System.Collections.Immutable.IImmutableDictionary<TKey, System.Numerics.BigInteger> Entries { get; }\n    public bool IsEmpty { get; }\n    public System.Numerics.BigInteger this[TKey key] { get; }\n    public System.Type KeyType { get; }\n    public System.Collections.Generic.IEnumerable<TKey> Keys { get; }\n    public System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.UniqueAddress> ModifiedByNodes { get; }\n    public System.Collections.Generic.IEnumerable<System.Numerics.BigInteger> Values { get; }\n    // Additional methods...\n```\n\n----------------------------------------\n\nTITLE: Implementing Cluster Settings Configuration\nDESCRIPTION: Defines the ClusterSettings class that contains all configuration parameters for an Akka.NET cluster including timeouts, intervals, and member requirements.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Core.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterSettings\n{\n    public ClusterSettings(Akka.Configuration.Config config, string systemName) { }\n    public bool AllowWeaklyUpMembers { get; }\n    public Akka.Util.AppVersion AppVersion { get; }\n    public System.Nullable<System.TimeSpan> AutoDownUnreachableAfter { get; }\n    public System.Type DowningProviderType { get; }\n    public Akka.Configuration.Config FailureDetectorConfig { get; }\n    public string FailureDetectorImplementationClass { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: DefaultLogMessageFormatter in Akka.NET\nDESCRIPTION: Implementation of ILogMessageFormatter for formatting log messages. Provides a singleton instance and methods for formatting strings with arguments.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_120\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DefaultLogMessageFormatter : Akka.Event.ILogMessageFormatter\n{\n    public static readonly Akka.Event.DefaultLogMessageFormatter Instance;\n    public string Format(string format, params object[] args) { }\n    public string Format(string format, System.Collections.Generic.IEnumerable<object> args) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TCP Connection, Binding, and Data Operations in Akka.NET\nDESCRIPTION: Classes for establishing TCP connections, binding to local addresses, and handling data transfer. These include Connect, Bind, and Register commands, as well as Connected and Received events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_156\n\nLANGUAGE: C#\nCODE:\n```\npublic class Bind : Akka.IO.Tcp.Command\n{\n    public Bind(Akka.Actor.IActorRef handler, System.Net.EndPoint localAddress, int backlog = 100, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options = null, bool pullMode = False) { }\n    public int Backlog { get; }\n    public Akka.Actor.IActorRef Handler { get; }\n    public System.Net.EndPoint LocalAddress { get; }\n    public System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> Options { get; }\n    public bool PullMode { get; }\n    public override string ToString() { }\n}\npublic class Bound : Akka.IO.Tcp.Event\n{\n    public Bound(System.Net.EndPoint localAddress) { }\n    public System.Net.EndPoint LocalAddress { get; }\n    public override string ToString() { }\n}\npublic class Connect : Akka.IO.Tcp.Command\n{\n    public Connect(System.Net.EndPoint remoteAddress, System.Net.EndPoint localAddress = null, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options = null, System.Nullable<System.TimeSpan> timeout = null, bool pullMode = False) { }\n    public System.Net.EndPoint LocalAddress { get; }\n    public System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> Options { get; }\n    public bool PullMode { get; }\n    public System.Net.EndPoint RemoteAddress { get; }\n    public System.Nullable<System.TimeSpan> Timeout { get; }\n    public override string ToString() { }\n}\npublic sealed class Connected : Akka.IO.Tcp.Event\n{\n    public Connected(System.Net.EndPoint remoteAddress, System.Net.EndPoint localAddress) { }\n    public System.Net.EndPoint LocalAddress { get; }\n    public System.Net.EndPoint RemoteAddress { get; }\n    public override string ToString() { }\n}\npublic class Register : Akka.IO.Tcp.Command\n{\n    public Register(Akka.Actor.IActorRef handler, bool keepOpenOnPeerClosed = False, bool useResumeWriting = True) { }\n    public Akka.Actor.IActorRef Handler { get; }\n    public bool KeepOpenOnPeerClosed { get; }\n}\npublic sealed class Received : Akka.IO.Tcp.Event\n{\n    public Received(Akka.IO.ByteString data) { }\n    public Akka.IO.ByteString Data { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: BusLogging Implementation in Akka.NET\nDESCRIPTION: Sealed class that extends LoggingAdapterBase to provide logging via an event bus. Includes logging level checks and a notification mechanism for publishing log events to the bus.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_116\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class BusLogging : Akka.Event.LoggingAdapterBase\n{\n    public BusLogging(Akka.Event.LoggingBus bus, string logSource, System.Type logClass, Akka.Event.ILogMessageFormatter logMessageFormatter) { }\n    public override bool IsDebugEnabled { get; }\n    public override bool IsErrorEnabled { get; }\n    public override bool IsInfoEnabled { get; }\n    public override bool IsWarningEnabled { get; }\n    protected override void NotifyLog(Akka.Event.LogLevel logLevel, object message, System.Exception cause = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DistributedPubSubSettings in C#\nDESCRIPTION: Implements settings for the distributed pub-sub system, including configuration options for roles, routing logic, and timing parameters. It provides methods for creating and modifying settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DistributedPubSubSettings : Akka.Actor.INoSerializationVerificationNeeded\n{\n    [System.ObsoleteAttribute(\"Obsolete - please us the full constructor instead. This constructor only exists for backwards API compatibility.\")]\n    public DistributedPubSubSettings(string role, Akka.Routing.RoutingLogic routingLogic, System.TimeSpan gossipInterval, System.TimeSpan removedTimeToLive, int maxDeltaElements) { }\n    public DistributedPubSubSettings(string role, Akka.Routing.RoutingLogic routingLogic, System.TimeSpan gossipInterval, System.TimeSpan removedTimeToLive, int maxDeltaElements, bool sendToDeadLettersWhenNoSubscribers) { }\n    public System.TimeSpan GossipInterval { get; }\n    public int MaxDeltaElements { get; }\n    public System.TimeSpan RemovedTimeToLive { get; }\n    public string Role { get; }\n    public Akka.Routing.RoutingLogic RoutingLogic { get; }\n    public bool SendToDeadLettersWhenNoSubscribers { get; }\n    public static Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings Create(Akka.Actor.ActorSystem system) { }\n    public static Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings Create(Akka.Configuration.Config config) { }\n    public Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings WithGossipInterval(System.TimeSpan gossipInterval) { }\n    public Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings WithMaxDeltaElements(int maxDeltaElements) { }\n    public Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings WithRemovedTimeToLive(System.TimeSpan removedTtl) { }\n    public Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings WithRole(string role) { }\n    public Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings WithRoutingLogic(Akka.Routing.RoutingLogic routingLogic) { }\n    public Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings WithSendToDeadLettersWhenNoSubscribers(bool sendToDeadLetterWhenNoSubscribers) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Actor System Core Classes in C#\nDESCRIPTION: Core class definitions for Akka.NET actor system components. Includes classes for actor references, paths, scheduling, and actor selection mechanisms. These classes form the foundation of the Akka.NET actor system implementation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class RootActorPath : Akka.Actor.ActorPath\n{\n    public RootActorPath(Akka.Actor.Address address, string name = \"\") { }\n}\n\npublic abstract class SchedulerBase : Akka.Actor.IActionScheduler, Akka.Actor.IAdvancedScheduler, Akka.Actor.IRunnableScheduler, Akka.Actor.IScheduler, Akka.Actor.ITellScheduler, Akka.Actor.ITimeProvider\n{\n    protected readonly Akka.Event.ILoggingAdapter Log;\n    protected readonly Akka.Configuration.Config SchedulerConfig;\n    protected SchedulerBase(Akka.Configuration.Config scheduler, Akka.Event.ILoggingAdapter log) { }\n    public abstract System.TimeSpan HighResMonotonicClock { get; }\n    public abstract System.TimeSpan MonotonicClock { get; }\n    protected abstract System.DateTimeOffset TimeNow { get; }\n}\n\npublic class SelectChildName : Akka.Actor.SelectionPathElement\n{\n    public SelectChildName(string name) { }\n    public string Name { get; }\n    protected bool Equals(Akka.Actor.SelectChildName other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UntypedPersistentActor Abstract Class in Akka.NET\nDESCRIPTION: The UntypedPersistentActor class provides a base class for creating untyped persistent actors. It extends Eventsourced and provides methods for handling commands and recovery messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class UntypedPersistentActor : Akka.Persistence.Eventsourced\n{\n    protected UntypedPersistentActor() { }\n    protected static Akka.Actor.IUntypedActorContext Context { get; }\n    protected void Become(Akka.Actor.UntypedReceive receive) { }\n    protected void BecomeStacked(Akka.Actor.UntypedReceive receive) { }\n    protected abstract void OnCommand(object message);\n    protected abstract void OnRecover(object message);\n    protected override bool Receive(object message) { }\n    protected virtual bool ReceiveCommand(object message) { }\n    protected virtual bool ReceiveRecover(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Option for Nullable Value Handling in C#\nDESCRIPTION: Defines the Option<T> struct for handling nullable values in Akka.NET. It provides methods for creating, mapping, and accessing optional values safely.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_209\n\nLANGUAGE: C#\nCODE:\n```\npublic struct Option<T>\n{\n    public static readonly Akka.Util.Option<T> None;\n    [System.ObsoleteAttribute(\"Use Option<T>.Create() instead\")]\n    public Option(T value) { }\n    public bool HasValue { get; }\n    public bool IsEmpty { get; }\n    public T Value { get; }\n    public static Akka.Util.Option<T> Create(T value) { }\n    public bool Equals(Akka.Util.Option<T> other) { }\n    public override bool Equals(object obj) { }\n    public Akka.Util.Option<TNew> FlatSelect<TNew>(System.Func<T, Akka.Util.Option<TNew>> mapper) { }\n    public override int GetHashCode() { }\n    public T GetOrElse(T fallbackValue) { }\n    public void OnSuccess(System.Action<T> action) { }\n    public Akka.Util.Option<TNew> Select<TNew>(System.Func<T, TNew> selector) { }\n    public override string ToString() { }\n    public static bool ==(Akka.Util.Option<T> left, Akka.Util.Option<T> right) { }\n    public static Akka.Util.Option<T> op_Implicit(T value) { }\n    public static bool !=(Akka.Util.Option<T> left, Akka.Util.Option<T> right) { }\n}\n```\n\n----------------------------------------\n\nTITLE: ClusterShardingSettings Class Definition in C#\nDESCRIPTION: Defines configuration settings for Akka.NET Cluster Sharding, including options for entity passivation, persistence, and coordination. It implements INoSerializationVerificationNeeded interface, indicating it should not be serialized.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Net.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n    public sealed class ClusterShardingSettings : Akka.Actor.INoSerializationVerificationNeeded\n    {\n        public readonly Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings CoordinatorSingletonSettings;\n        public readonly string JournalPluginId;\n        public readonly Akka.Coordination.LeaseUsageSettings LeaseSettings;\n        public readonly System.TimeSpan PassivateIdleEntityAfter;\n        public readonly bool RememberEntities;\n        public readonly Akka.Cluster.Sharding.RememberEntitiesStore RememberEntitiesStore;\n        public readonly string Role;\n        public readonly System.TimeSpan ShardRegionQueryTimeout;\n        public readonly string SnapshotPluginId;\n    }\n```\n\n----------------------------------------\n\nTITLE: Configuring Periodical Snapshots in PersistentFSM with HOCON\nDESCRIPTION: HOCON configuration to enable periodical SaveStateSnapshot() calls in PersistentFSM. This setting causes snapshots to be automatically saved after a specified number of events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistent-fsm.md#2025-04-16_snippet_9\n\nLANGUAGE: hocon\nCODE:\n```\nakka.persistence.fsm.snapshot-after = 1000\n```\n\n----------------------------------------\n\nTITLE: Implementing ApplyEvent for Persistent FSM in C#\nDESCRIPTION: Implementation of the ApplyEvent method to define how state data is affected by domain events. This method is crucial for updating the state data based on persisted events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistent-fsm.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Subscribe Class Definition in C#\nDESCRIPTION: Implements a subscription message class for Akka.NET's distributed data replicator. This class enables actors to subscribe to updates for a specific distributed data key.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_47\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Subscribe : Akka.DistributedData.IReplicatorMessage, System.IEquatable<Akka.DistributedData.Subscribe>\n{\n    public Subscribe(Akka.DistributedData.IKey key, Akka.Actor.IActorRef subscriber) { }\n    public Akka.DistributedData.IKey Key { get; }\n    public Akka.Actor.IActorRef Subscriber { get; }\n    public bool Equals(Akka.DistributedData.Subscribe other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Gracefully Shutting Down a Node in Akka.NET Multi-Node Tests\nDESCRIPTION: Demonstrates how to gracefully terminate an ActorSystem in a multi-node test, simulating a planned node shutdown. The code executes the shutdown on the specified node and uses a barrier to ensure other nodes are aware of the shutdown.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/testing/multi-node-testing.md#2025-04-16_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\n// shutdown seed1System\nRunOn(() =>\n{\n    Shutdown(seed1System.Value, RemainingOrDefault);\n}, _config.Seed1);\nEnterBarrier(\"seed1-shutdown\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Frame Parsing with GraphStage\nDESCRIPTION: Implements a custom frame parser using GraphStage to handle message framing protocol. Includes both the frame parser implementation and the creation of a bidirectional flow for framing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithgraphs.md#2025-04-16_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\npublic static ByteString AddLengthHeader(ByteString bytes, ByteOrder order)\n    => new ByteStringBuilder().PutInt(bytes.Count, order).Append(bytes).Result();\n    \npublic class FrameParser : GraphStage<FlowShape<ByteString, ByteString>>\n{\n    private sealed class Logic : GraphStageLogic\n    {\n        private readonly FrameParser _parser;\n        // this holds the received but not yet parsed bytes\n        private ByteString _stash;\n        // this holds the current message length or -1 if at a boundary\n        private int _needed = -1;\n\n        public Logic(FrameParser parser) : base(parser.Shape)\n        {\n            _parser = parser;\n            _stash = ByteString.Empty;\n\n            SetHandler(parser.Out, onPull: () =>\n            {\n                if (IsClosed(parser.In))\n                    Run();\n                else\n                    Pull(parser.In);\n            });\n\n            SetHandler(parser.In, onPush: () =>\n            {\n                var bytes = Grab(parser.In);\n                _stash += bytes;\n                Run();\n            }, onUpstreamFinish: () =>\n            {\n                if(_stash.IsEmpty)\n                    CompleteStage();\n                // wait with completion and let Run() complete when the\n                // rest of the stash has been sent downstream\n            });\n        }\n\n        private void Run()\n        {\n            if (_needed == -1)\n            { \n                // are we at a boundary? then figure out next length\n                if (_stash.Count < 4)\n                {\n                    if (IsClosed(_parser.In))\n                        CompleteStage();\n                    else\n                        Pull(_parser.In);\n                }\n                else\n                {\n                    _needed = _stash.Iterator().GetInt(_parser._order);\n                    _stash = _stash.Drop(4);\n                    Run(); // cycle back to possibly already emit the next chunk\n                }\n            }\n            else if (_stash.Count < _needed)\n            {\n                // we are in the middle of a message, need more bytes,\n                // or have to stop if input closed\n                if (IsClosed(_parser.In))\n                    CompleteStage();\n                else\n                    Pull(_parser.In);\n            }\n            else\n            {\n                // we have enough to emit at least one message, so do it\n                var emit = _stash.Take(_needed);\n                _stash = _stash.Drop(_needed);\n                _needed = -1;\n                Push(_parser.Out, emit);\n            }\n        }\n    }\n\n    private readonly ByteOrder _order;\n\n    public FrameParser(ByteOrder order)\n    {\n        _order = order;\n        Shape = new FlowShape<ByteString, ByteString>(In, Out);\n    }\n\n    public Inlet<ByteString> In { get; } = new Inlet<ByteString>(\"FrameParser.in\");\n\n    public Outlet<ByteString> Out { get; } = new Outlet<ByteString>(\"FrameParser.out\");\n\n    public override FlowShape<ByteString, ByteString> Shape { get; }\n\n    protected override GraphStageLogic CreateLogic(Attributes inheritedAttributes) => new Logic(this);\n}\n\nvar framing =\n    BidiFlow.FromGraph(\n        GraphDsl.Create(b =>\n        {\n            var order = ByteOrder.LittleEndian;\n\n            var outbound = b.Add(Flow.Create<ByteString>().Select(bytes => AddLengthHeader(bytes, order)));\n            var inbound = b.Add(Flow.Create<ByteString>().Via(new FrameParser(order)));\n\n            return BidiShape.FromFlows(outbound, inbound);\n        }));\n```\n\n----------------------------------------\n\nTITLE: Remote Watcher Event Classes in C#\nDESCRIPTION: Classes representing various remoting lifecycle events including errors, shutdown, and quarantine events. These classes help monitor and manage the state of remote actor systems.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class RemotingErrorEvent : Akka.Remote.RemotingLifecycleEvent\n{\n    public RemotingErrorEvent(System.Exception cause) { }\n    public System.Exception Cause { get; }\n    public override Akka.Event.LogLevel LogLevel() { }\n    public override string ToString() { }\n}\n\npublic sealed class RemotingShutdownEvent : Akka.Remote.RemotingLifecycleEvent\n{\n    public RemotingShutdownEvent() { }\n    public override Akka.Event.LogLevel LogLevel() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Multi-Node Test Specification in C#\nDESCRIPTION: Complete implementation of a multi-node test specification that tests cluster node restart scenarios. Includes test setup, execution flow, and assertions for verifying cluster behavior.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/testing/multi-node-testing-old.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class RestartNode2Spec : MultiNodeClusterSpec\n{\n    private readonly RestartNode2SpecConfig _config;\n\n    public RestartNode2Spec() : this(new RestartNode2SpecConfig()) { }\n\n    protected RestartNode2Spec(RestartNode2SpecConfig config) : base(config)\n    {\n        _config = config;\n    }\n\n    private ImmutableList<Address> SeedNodes\n    {\n        get { return ImmutableList.Create(GetAddress(_config.Seed1), GetAddress(_config.Seed2)); }\n    }\n\n    [MultiNodeFact]\n    public void Some_test_name()\n    {\n        RunOn(() =>\n        {\n            Cluster.JoinSeedNodes(SeedNodes);\n            Within(TimeSpan.FromSeconds(15), () =>\n            {\n                AwaitAssert(() =>\n                {\n                    Assert.Equal(2, Cluster.State.Members.Count);\n                    Assert.Equal(MemberStatus.Up, Cluster.State.Members.First().Status);\n                    Assert.Equal(MemberStatus.Up, Cluster.State.Members.Skip(1).First().Status);\n                });\n            });\n        }, _config.Seed2);\n\n        RunOn(() =>\n        {\n            Cluster.JoinSeedNodes(SeedNodes);\n            Within(TimeSpan.FromSeconds(15), () =>\n            {\n                AwaitAssert(() =>\n                {\n                    Assert.Equal(2, Cluster.State.Members.Count);\n                    Assert.Equal(MemberStatus.Up, Cluster.State.Members.First().Status);\n                    Assert.Equal(MemberStatus.Up, Cluster.State.Members.Skip(1).First().Status);\n                });\n            });\n        }, _config.Seed1);\n\n        EnterBarrier(\"cluster started\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Persistence Actor Classes in C#\nDESCRIPTION: Abstract classes for persistent actors including PersistentActor and ReceivePersistentActor with command handling functionality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class PersistentActor : Akka.Persistence.Eventsourced\n{\n    protected PersistentActor() { }\n    protected override bool Receive(object message) { }\n}\n\npublic abstract class ReceivePersistentActor : Akka.Persistence.UntypedPersistentActor, Akka.Actor.Internal.IInitializableActor\n{\n    protected ReceivePersistentActor() { }\n    protected void Become(System.Action configure) { }\n    protected void BecomeStacked(System.Action configure) { }\n    protected void Command<T>(System.Action<T> handler, System.Predicate<T> shouldHandle = null) { }\n    protected void Command<T>(System.Predicate<T> shouldHandle, System.Action<T> handler) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract SnapshotStore Class in C#\nDESCRIPTION: This snippet defines an abstract SnapshotStore class that inherits from Akka.Actor.ActorBase. It includes abstract methods for deleting, loading, and saving snapshots, as well as virtual methods for message handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_64\n\nLANGUAGE: C#\nCODE:\n```\n    public abstract class SnapshotStore : Akka.Actor.ActorBase\n    {\n        protected SnapshotStore() { }\n        protected abstract System.Threading.Tasks.Task DeleteAsync(Akka.Persistence.SnapshotMetadata metadata);\n        protected abstract System.Threading.Tasks.Task DeleteAsync(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria);\n        protected abstract System.Threading.Tasks.Task<Akka.Persistence.SelectedSnapshot> LoadAsync(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria);\n        protected virtual bool Receive(object message) { }\n        protected virtual bool ReceivePluginInternal(object message) { }\n        protected abstract System.Threading.Tasks.Task SaveAsync(Akka.Persistence.SnapshotMetadata metadata, object snapshot);\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Vector Clock for Cluster Synchronization\nDESCRIPTION: Implements a Vector Clock system for maintaining causality and ordering of events in distributed systems. Provides methods for comparing, merging and incrementing vector timestamps.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Core.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class VectorClock\n{\n    public System.Collections.Immutable.ImmutableSortedDictionary<Akka.Cluster.VectorClock.Node, long> Versions { get; }\n    public Akka.Cluster.VectorClock.Ordering CompareTo(Akka.Cluster.VectorClock that) { }\n    public static Akka.Cluster.VectorClock Create() { }\n    public static Akka.Cluster.VectorClock Create(System.Collections.Immutable.ImmutableSortedDictionary<Akka.Cluster.VectorClock.Node, long> seedValues) { }\n    public Akka.Cluster.VectorClock Increment(Akka.Cluster.VectorClock.Node node) { }\n    public bool IsAfter(Akka.Cluster.VectorClock that) { }\n    public bool IsBefore(Akka.Cluster.VectorClock that) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Configuration-based Discovery Method\nDESCRIPTION: HOCON configuration for enabling the Configuration-based discovery method in Akka.Discovery.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/discovery/index.md#2025-04-16_snippet_3\n\nLANGUAGE: hocon\nCODE:\n```\nakka {\n  discovery.method = config\n}\n```\n\n----------------------------------------\n\nTITLE: AtLeastOnceDeliverySemantic Class and Nested Types in Akka.Persistence\nDESCRIPTION: Implements the core functionality for at-least-once message delivery. This class manages the tracking, delivery, and redelivery of messages, along with supporting nested types for delivery tracking and redelivery scheduling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class AtLeastOnceDeliverySemantic\n{\n    public AtLeastOnceDeliverySemantic(Akka.Actor.IActorContext context, Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings settings) { }\n    public int MaxUnconfirmedMessages { get; }\n    public System.TimeSpan RedeliverInterval { get; }\n    public int RedeliveryBurstLimit { get; }\n    public int UnconfirmedCount { get; }\n    public int WarnAfterNumberOfUnconfirmedAttempts { get; }\n    public bool AroundReceive(Akka.Actor.Receive receive, object message) { }\n    public void Cancel() { }\n    public bool ConfirmDelivery(long deliveryId) { }\n    public void Deliver(Akka.Actor.ActorPath destination, System.Func<long, object> deliveryMessageMapper, bool isRecovering) { }\n    public Akka.Persistence.AtLeastOnceDeliverySnapshot GetDeliverySnapshot() { }\n    public void OnReplaySuccess() { }\n    public void SetDeliverySnapshot(Akka.Persistence.AtLeastOnceDeliverySnapshot snapshot) { }\n    public sealed class Delivery : System.IEquatable<Akka.Persistence.AtLeastOnceDeliverySemantic.Delivery>\n    {\n        public Delivery(Akka.Actor.ActorPath destination, object message, System.DateTime timestamp, int attempt) { }\n        public int Attempt { get; }\n        public Akka.Actor.ActorPath Destination { get; }\n        public object Message { get; }\n        public System.DateTime Timestamp { get; }\n        public bool Equals(Akka.Persistence.AtLeastOnceDeliverySemantic.Delivery other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n        public Akka.Persistence.AtLeastOnceDeliverySemantic.Delivery IncrementedCopy() { }\n        public override string ToString() { }\n    }\n    public sealed class RedeliveryTick : Akka.Actor.INotInfluenceReceiveTimeout, Akka.Event.IDeadLetterSuppression\n    {\n        public static Akka.Persistence.AtLeastOnceDeliverySemantic.RedeliveryTick Instance { get; }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ShardingEnvelope Class in C# for Wrapped Messages\nDESCRIPTION: Implements the \"ShardingEnvelope\" class for wrapping messages with associated entity IDs in Akka.NET, facilitating message routing through sharding by packing both entity identity and message.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Core.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ShardingEnvelope : Akka.Actor.IWrappedMessage {\n        public ShardingEnvelope(string entityId, object message) { }\n        public string EntityId { get; }\n        public object Message { get; }\n    }\n```\n\n----------------------------------------\n\nTITLE: ForEachAsync Sink Operation in Akka.NET\nDESCRIPTION: Asynchronously processes each stream element with configurable parallelism. Materializes into Task<Done>. Requires thread-safe handling of shared state mutations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/builtinstages.md#2025-04-16_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Implementing CallingThreadDispatcher in Akka.NET\nDESCRIPTION: This class inherits from Akka.Dispatch.MessageDispatcher to execute tasks on the calling thread, useful for synchronous testing. Key dependencies are the Akka.Dispatch namespace and its configurator. It overrides task execution and shutdown.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class CallingThreadDispatcher : Akka.Dispatch.MessageDispatcher\n{\n    public static string Id;\n    public CallingThreadDispatcher(Akka.Dispatch.MessageDispatcherConfigurator configurator) { }\n    protected override void ExecuteTask(Akka.Dispatch.IRunnable run) { }\n    protected override void Shutdown() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GCounter Class in Akka.NET DistributedData (C#)\nDESCRIPTION: Defines the GCounter (Grow-only Counter) class, which is a distributed counter that can only be incremented. It implements various interfaces for replication, delta updates, and node pruning.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class GCounter : Akka.DistributedData.FastMerge<Akka.DistributedData.GCounter>, Akka.DistributedData.IDeltaReplicatedData, Akka.DistributedData.IDeltaReplicatedData<Akka.DistributedData.GCounter, Akka.DistributedData.GCounter>, Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IRemovedNodePruning<Akka.DistributedData.GCounter>, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.GCounter>, Akka.DistributedData.IReplicatedDelta, System.IEquatable<Akka.DistributedData.GCounter>\n{\n    public GCounter() { }\n    public Akka.DistributedData.GCounter Delta { get; }\n    public static Akka.DistributedData.GCounter Empty { get; }\n    public System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.UniqueAddress> ModifiedByNodes { get; }\n    public System.Collections.Immutable.ImmutableDictionary<Akka.Cluster.UniqueAddress, ulong> State { get; }\n    public ulong Value { get; }\n    public bool Equals(Akka.DistributedData.GCounter other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public Akka.DistributedData.GCounter Increment(Akka.Cluster.Cluster node, ulong delta = 1) { }\n    public Akka.DistributedData.GCounter Increment(Akka.Cluster.UniqueAddress node, ulong n = 1) { }\n    public override Akka.DistributedData.GCounter Merge(Akka.DistributedData.GCounter other) { }\n    public Akka.DistributedData.GCounter MergeDelta(Akka.DistributedData.GCounter delta) { }\n    public bool NeedPruningFrom(Akka.Cluster.UniqueAddress removedNode) { }\n    public Akka.DistributedData.GCounter Prune(Akka.Cluster.UniqueAddress removedNode, Akka.Cluster.UniqueAddress collapseInto) { }\n    public Akka.DistributedData.GCounter PruningCleanup(Akka.Cluster.UniqueAddress removedNode) { }\n    public Akka.DistributedData.GCounter ResetDelta() { }\n    public override string ToString() { }\n    public static ulong op_Implicit(Akka.DistributedData.GCounter counter) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RecoverWithRetries in C#\nDESCRIPTION: Shows how to use RecoverWithRetries to replace a failed upstream with a new source. The example demonstrates recovery from ArithmeticException with a backup data source.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/error-handling.md#2025-04-16_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nvar planB = Source.From(new List<string> {\"five\", \"six\", \"seven\", \"eight\"});\n\nSource.From(Enumerable.Range(0, 10)).Select(n =>\n    {\n        if (n < 5)\n            return n.ToString();\n\n        throw new ArithmeticException(\"Boom!\");\n    })\n    .RecoverWithRetries(attempts: 1, partialFunc: exception =>\n    {\n        if (exception is ArithmeticException)\n            return planB;\n        return null;\n    })\n    .RunForeach(Console.WriteLine, materializer);\n```\n\n----------------------------------------\n\nTITLE: Defining Journal Settings in C# for Akka.NET SQL Persistence\nDESCRIPTION: The JournalSettings class encapsulates configuration settings for SQL-based journals in Akka.NET. It includes properties for connection strings, table names, and other journal-specific settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic class JournalSettings\n{\n    public JournalSettings(Akka.Configuration.Config config) { }\n    public bool AutoInitialize { get; }\n    public string ConnectionString { get; }\n    public string ConnectionStringName { get; }\n    public System.TimeSpan ConnectionTimeout { get; }\n    public string JournalTableName { get; }\n    public string MetaTableName { get; }\n    public string SchemaName { get; }\n    public string TimestampProvider { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Replicator Settings Configuration in C#\nDESCRIPTION: Configuration class for Akka.NET distributed data replicator settings including gossip intervals, pruning settings, and durable storage options.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ReplicatorSettings\n{\n    public ReplicatorSettings(string role, System.TimeSpan gossipInterval, System.TimeSpan notifySubscribersInterval, int maxDeltaElements, string dispatcher, System.TimeSpan pruningInterval, System.TimeSpan maxPruningDissemination, System.Collections.Immutable.IImmutableSet<string> durableKeys, Akka.Actor.Props durableStoreProps, System.TimeSpan pruningMarkerTimeToLive, System.TimeSpan durablePruningMarkerTimeToLive, int maxDeltaSize, bool restartReplicatorOnFailure, bool preferOldest, bool verboseDebugLogging) { }\n    // Properties and methods...\n```\n\n----------------------------------------\n\nTITLE: Configuring Global ILogMessageFormatter in HOCON\nDESCRIPTION: Example showing how to configure a custom ILogMessageFormatter globally in Akka.NET using HOCON configuration. This allows using custom log formatters like Serilog without needing to specify them in individual actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/RELEASE_NOTES.md#2025-04-16_snippet_5\n\nLANGUAGE: hocon\nCODE:\n```\nakka { \n    loglevel=INFO,\n    loggers=[\"Akka.Logger.Serilog.SerilogLogger, Akka.Logger.Serilog\"]\n    logger-formatter=\"Akka.Logger.Serilog.SerilogLogMessageFormatter, Akka.Logger.Serilog\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GetSuccess Response in Akka.NET DistributedData (C#)\nDESCRIPTION: Defines the GetSuccess class, which represents a successful response to a Get request. It includes properties for the key, request, and retrieved data.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class GetSuccess : Akka.Actor.INoSerializationVerificationNeeded, Akka.DistributedData.IGetResponse, Akka.DistributedData.IReplicatorMessage, System.IEquatable<Akka.DistributedData.GetSuccess>\n{\n    public GetSuccess(Akka.DistributedData.IKey key, object request, Akka.DistributedData.IReplicatedData data) { }\n    public Akka.DistributedData.IReplicatedData Data { get; }\n    public bool IsFailure { get; }\n    public bool IsFound { get; }\n    public bool IsSuccessful { get; }\n    public Akka.DistributedData.IKey Key { get; }\n    public object Request { get; }\n    public bool Equals(Akka.DistributedData.GetSuccess other) { }\n    public override bool Equals(object obj) { }\n    public T Get<T>(Akka.DistributedData.IKey<T> key)\n        where T : Akka.DistributedData.IReplicatedData { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: IJournalQueryExecutor Interface Definition in C#\nDESCRIPTION: Defines the contract for SQL journal query execution with methods for creating tables, inserting and deleting batches, and selecting events by various criteria. Forms the foundation for database operations in Akka.Persistence SQL implementations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.DotNet.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IJournalQueryExecutor\n{\n    Akka.Persistence.Sql.Common.Journal.QueryConfiguration Configuration { get; }\n    System.Threading.Tasks.Task CreateTablesAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken);\n    System.Threading.Tasks.Task DeleteBatchAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string persistenceId, long toSequenceNr);\n    System.Threading.Tasks.Task InsertBatchAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, Akka.Persistence.Sql.Common.Journal.WriteJournalBatch write);\n    System.Threading.Tasks.Task<long> SelectAllEventsAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, long fromOffset, long toOffset, long max, System.Action<Akka.Persistence.Sql.Common.Journal.ReplayedEvent> callback);\n    System.Threading.Tasks.Task<System.Collections.Immutable.ImmutableArray<string>> SelectAllPersistenceIdsAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, long offset);\n    System.Threading.Tasks.Task SelectByPersistenceIdAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string persistenceId, long fromSequenceNr, long toSequenceNr, long max, System.Action<Akka.Persistence.IPersistentRepresentation> callback);\n    System.Threading.Tasks.Task<long> SelectByTagAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string tag, long fromOffset, long toOffset, long max, System.Action<Akka.Persistence.Sql.Common.Journal.ReplayedTaggedMessage> callback);\n    System.Threading.Tasks.Task<long> SelectHighestSequenceNrAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string persistenceId);\n    System.Threading.Tasks.Task<long> SelectHighestSequenceNrAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WriteJournalBase Abstract Class in C#\nDESCRIPTION: Defines an abstract class WriteJournalBase that inherits from ActorBase. It includes methods for adapting and preparing persistent representations for journaling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_61\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class WriteJournalBase : Akka.Actor.ActorBase\n{\n    protected WriteJournalBase() { }\n    [Akka.Annotations.InternalApiAttribute()]\n    protected System.Collections.Generic.IEnumerable<Akka.Persistence.IPersistentRepresentation> AdaptFromJournal(Akka.Persistence.IPersistentRepresentation representation) { }\n    protected Akka.Persistence.IPersistentRepresentation AdaptToJournal(Akka.Persistence.IPersistentRepresentation representation) { }\n    protected System.Collections.Generic.IEnumerable<Akka.Persistence.AtomicWrite> PreparePersistentBatch(System.Collections.Generic.IEnumerable<Akka.Persistence.IPersistentEnvelope> resequenceables) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Update Response Interfaces for Distributed Data Operations\nDESCRIPTION: Interfaces for handling responses to update operations in Akka.NET's distributed data. These interfaces support success/failure handling and error propagation in distributed update operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IUpdateFailure : Akka.Actor.INoSerializationVerificationNeeded, Akka.DistributedData.IUpdateResponse\n{\n    System.Exception Cause { get; }\n}\npublic interface IUpdateResponse : Akka.Actor.INoSerializationVerificationNeeded\n{\n    bool IsSuccessful { get; }\n    Akka.DistributedData.IKey Key { get; }\n    object Request { get; }\n    void ThrowOnFailure();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TCP Extension and Message Classes in Akka.IO\nDESCRIPTION: Implements the Tcp extension and various message classes used for TCP communication in Akka.IO, including commands, events, and connection state management classes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_162\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Tcp : Akka.Actor.ExtensionIdProvider<Akka.IO.TcpExt>\n{\n    public static readonly Akka.Actor.SupervisorStrategy ConnectionSupervisorStrategy;\n    public static readonly Akka.IO.Tcp Instance;\n    public Tcp() { }\n    public override Akka.IO.TcpExt CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n    public static Akka.Actor.IActorRef Manager(Akka.Actor.ActorSystem system) { }\n    public class Abort : Akka.IO.Tcp.CloseCommand\n    {\n        public static readonly Akka.IO.Tcp.Abort Instance;\n        public override Akka.IO.Tcp.ConnectionClosed Event { get; }\n    }\n    public class Aborted : Akka.IO.Tcp.ConnectionClosed\n    {\n        public static readonly Akka.IO.Tcp.Aborted Instance;\n        public override bool IsAborted { get; }\n    }\n    public class Bind : Akka.IO.Tcp.Command\n    {\n        public Bind(Akka.Actor.IActorRef handler, System.Net.EndPoint localAddress, int backlog = 100, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options = null, bool pullMode = False) { }\n        public int Backlog { get; }\n        public Akka.Actor.IActorRef Handler { get; }\n        public System.Net.EndPoint LocalAddress { get; }\n        public System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> Options { get; }\n        public bool PullMode { get; }\n        public override string ToString() { }\n    }\n    public class Bound : Akka.IO.Tcp.Event\n    {\n        public Bound(System.Net.EndPoint localAddress) { }\n        public System.Net.EndPoint LocalAddress { get; }\n        public override string ToString() { }\n    }\n    public class Close : Akka.IO.Tcp.CloseCommand\n    {\n        public static readonly Akka.IO.Tcp.Close Instance;\n        public override Akka.IO.Tcp.ConnectionClosed Event { get; }\n    }\n    public abstract class CloseCommand : Akka.IO.Tcp.Command, Akka.Event.IDeadLetterSuppression\n    {\n        protected CloseCommand() { }\n        public abstract Akka.IO.Tcp.ConnectionClosed Event { get; }\n    }\n    public class Closed : Akka.IO.Tcp.ConnectionClosed\n    {\n        public static readonly Akka.IO.Tcp.Closed Instance;\n    }\n    public abstract class Command : Akka.IO.Tcp.Message\n    {\n        protected Command() { }\n        public Akka.IO.Tcp.CommandFailed FailureMessage { get; }\n    }\n    public sealed class CommandFailed : Akka.IO.Tcp.Event\n    {\n        public CommandFailed(Akka.IO.Tcp.Command cmd) { }\n        public Akka.Util.Option<System.Exception> Cause { get; }\n        [Akka.Annotations.InternalApiAttribute()]\n        public string CauseString { get; }\n        public Akka.IO.Tcp.Command Cmd { get; }\n        public override string ToString() { }\n        [Akka.Annotations.InternalApiAttribute()]\n        public Akka.IO.Tcp.CommandFailed WithCause(System.Exception cause) { }\n    }\n    public class CompoundWrite : Akka.IO.Tcp.WriteCommand, System.Collections.Generic.IEnumerable<Akka.IO.Tcp.SimpleWriteCommand>, System.Collections.IEnumerable\n    {\n        public CompoundWrite(Akka.IO.Tcp.SimpleWriteCommand head, Akka.IO.Tcp.WriteCommand tailCommand) { }\n        public Akka.IO.Tcp.SimpleWriteCommand Head { get; }\n        public Akka.IO.Tcp.WriteCommand TailCommand { get; }\n        public System.Collections.Generic.IEnumerator<Akka.IO.Tcp.SimpleWriteCommand> GetEnumerator() { }\n        public override string ToString() { }\n    }\n    public class ConfirmedClose : Akka.IO.Tcp.CloseCommand\n    {\n        public static readonly Akka.IO.Tcp.ConfirmedClose Instance;\n        public override Akka.IO.Tcp.ConnectionClosed Event { get; }\n    }\n    public class ConfirmedClosed : Akka.IO.Tcp.ConnectionClosed\n    {\n        public static readonly Akka.IO.Tcp.ConfirmedClosed Instance;\n        public override bool IsConfirmed { get; }\n    }\n    public class Connect : Akka.IO.Tcp.Command\n    {\n        public Connect(System.Net.EndPoint remoteAddress, System.Net.EndPoint localAddress = null, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options = null, System.Nullable<System.TimeSpan> timeout = null, bool pullMode = False) { }\n        public System.Net.EndPoint LocalAddress { get; }\n        public System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> Options { get; }\n        public bool PullMode { get; }\n        public System.Net.EndPoint RemoteAddress { get; }\n        public System.Nullable<System.TimeSpan> Timeout { get; }\n        public override string ToString() { }\n    }\n    public sealed class Connected : Akka.IO.Tcp.Event\n    {\n        public Connected(System.Net.EndPoint remoteAddress, System.Net.EndPoint localAddress) { }\n        public System.Net.EndPoint LocalAddress { get; }\n        public System.Net.EndPoint RemoteAddress { get; }\n        public override string ToString() { }\n    }\n    public class ConnectionClosed : Akka.IO.Tcp.Event, Akka.Event.IDeadLetterSuppression\n    {\n        public ConnectionClosed() { }\n        public virtual string Cause { get; }\n        public virtual bool IsAborted { get; }\n        public virtual bool IsConfirmed { get; }\n        public virtual bool IsErrorClosed { get; }\n        public virtual bool IsPeerClosed { get; }\n    }\n    public sealed class ErrorClosed : Akka.IO.Tcp.ConnectionClosed\n    {\n        public ErrorClosed(string cause) { }\n        public override string Cause { get; }\n        public override bool IsErrorClosed { get; }\n        public override string ToString() { }\n    }\n    public class Event : Akka.IO.Tcp.Message\n    {\n        public Event() { }\n    }\n    public class Message : Akka.Actor.INoSerializationVerificationNeeded\n    {\n        public Message() { }\n    }\n    public class NoAck : Akka.IO.Tcp.Event\n    {\n        public static readonly Akka.IO.Tcp.NoAck Instance;\n        public NoAck(object token) { }\n        public object Token { get; }\n        public override string ToString() { }\n    }\n    public class PeerClosed : Akka.IO.Tcp.ConnectionClosed\n    {\n        public static readonly Akka.IO.Tcp.PeerClosed Instance;\n        public override bool IsPeerClosed { get; }\n    }\n    public sealed class Received : Akka.IO.Tcp.Event\n    {\n        public Received(Akka.IO.ByteString data) { }\n        public Akka.IO.ByteString Data { get; }\n        public override string ToString() { }\n    }\n    public class Register : Akka.IO.Tcp.Command\n    {\n        public Register(Akka.Actor.IActorRef handler, bool keepOpenOnPeerClosed = False, bool useResumeWriting = True) { }\n        public Akka.Actor.IActorRef Handler { get; }\n        public bool KeepOpenOnPeerClosed { get; }\n        public bool UseResumeWriting { get; }\n        public override string ToString() { }\n    }\n    public class ResumeAccepting : Akka.IO.Tcp.Command\n    {\n        public ResumeAccepting(int batchSize) { }\n        public int BatchSize { get; }\n        public override string ToString() { }\n    }\n    public class ResumeReading : Akka.IO.Tcp.Command\n    {\n        public static readonly Akka.IO.Tcp.ResumeReading Instance;\n    }\n    public class ResumeWriting : Akka.IO.Tcp.Command\n    {\n        public static readonly Akka.IO.Tcp.ResumeWriting Instance;\n    }\n    public abstract class SimpleWriteCommand : Akka.IO.Tcp.WriteCommand\n    {\n        protected SimpleWriteCommand() { }\n\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterSingletonProxy Class\nDESCRIPTION: Core class for managing cluster singleton proxy functionality with timer scheduling and lifecycle methods\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Net.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic ClusterSingletonProxy(string singletonManagerPath, Akka.Cluster.Tools.Singleton.ClusterSingletonProxySettings settings) { }\npublic Akka.Actor.ITimerScheduler Timers { get; set; }\npublic static Akka.Configuration.Config DefaultConfig() { }\nprotected override void PostStop() { }\nprotected override void PreStart() { }\npublic static Akka.Actor.Props Props(string singletonManagerPath, Akka.Cluster.Tools.Singleton.ClusterSingletonProxySettings settings) { }\n```\n\n----------------------------------------\n\nTITLE: Config Class Method Declarations\nDESCRIPTION: Public interface methods for the Config class including getters for various data types and configuration manipulation methods.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_65\n\nLANGUAGE: C#\nCODE:\n```\npublic virtual System.Collections.Generic.IList<float> GetFloatList(string path) { }\npublic virtual int GetInt(string path, int default = 0) { }\npublic virtual System.Collections.Generic.IList<int> GetIntList(string path) { }\npublic virtual long GetLong(string path, long default = 0) { }\npublic virtual System.Collections.Generic.IList<long> GetLongList(string path) { }\npublic virtual string GetString(string path, string default = null) { }\npublic virtual System.Collections.Generic.IList<string> GetStringList(string path) { }\npublic virtual System.Collections.Generic.IList<string> GetStringList(string path, string[] defaultPaths) { }\npublic virtual System.TimeSpan GetTimeSpan(string path, System.Nullable<System.TimeSpan> default = null, bool allowInfinite = True) { }\n```\n\n----------------------------------------\n\nTITLE: Integrating Akka.Streams with C# Event Handlers\nDESCRIPTION: This snippet shows how to create a source for an Akka stream from C# events using Source.FromEvent. It handles click events from a button and demonstrates the optional parameters for configuring the buffering strategy.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nSource.FromEvent<RoutedEventArgs>(\n    addHandler: h => button.Click += h, \n    removeHandler: h => button.Click -= h,\n    maxBufferCapacity: 128,\n    overflowStrategy: OverflowStrategy.DropHead)\n    .RunForEach(e => Console.WriteLine($\"Captured click from {e.Source}\"), materializer);\n\n// using custom delegate adapter\nSource.FromEvent<EventHandler<RoutedEventArgs>, RoutedEventArgs>(\n    conversion: onNext => (sender, eventArgs) => onNext(eventArgs),\n    addHandler: h => button.Click += h, \n    removeHandler: h => button.Click -= h)\n    .RunForEach(e => Console.WriteLine($\"Captured click from {e.Source}\"), materializer);\n```\n\n----------------------------------------\n\nTITLE: Deadline and Failure Detection in Akka.Remote C#\nDESCRIPTION: The snippet defines Deadline and DeadlineFailureDetector classes handling time-based operations to determine remote actor availability. With methods to calculate time left and check overdue status, these components facilitate reliable remote communication. Failures are detected based on configurable heartbeat intervals and pauses, ensuring robust remote system monitoring.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Deadline\n{\n    public Deadline(System.DateTime when) { }\n    public bool HasTimeLeft { get; }\n    public bool IsOverdue { get; }\n    public static Akka.Remote.Deadline Now { get; }\n    public System.TimeSpan TimeLeft { get; }\n    public System.DateTime When { get; }\n}\npublic class DeadlineFailureDetector : Akka.Remote.FailureDetector\n{\n    public DeadlineFailureDetector(System.TimeSpan acceptableHeartbeatPause, System.TimeSpan heartbeatInterval, Akka.Remote.Clock clock = null) { }\n    public override bool IsAvailable { get; }\n    public override bool IsMonitoring { get; }\n    public override void HeartBeat() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ReplayMessagesAsync Method for Akka.Persistence Journal\nDESCRIPTION: Implementation of the ReplayMessagesAsync method for a SQLite-based Akka.Persistence journal. This method retrieves and replays persistent messages for a specified actor within given sequence number bounds.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/custom-persistence-provider.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override async Task ReplayMessagesAsync(IActorContext context, string persistenceId, long fromSequenceNr, long toSequenceNr, long max, Action<IPersistentRepresentation> recoveryCallback)\n{\n    using (var connection = await _connectionFactory.CreateConnection())\n    using (var command = connection.CreateCommand())\n    {\n        command.CommandText = ByPersistenceIdSql;\n        command.Parameters.AddWithValue(\"@PersistenceId\", persistenceId);\n        command.Parameters.AddWithValue(\"@FromSequenceNr\", fromSequenceNr);\n        command.Parameters.AddWithValue(\"@ToSequenceNr\", toSequenceNr);\n        command.Parameters.AddWithValue(\"@MaxCount\", max);\n\n        using (var reader = await command.ExecuteReaderAsync())\n        {\n            var persistentMessages = new List<KeyValuePair<Exception, IPersistentRepresentation>>();\n            while (await reader.ReadAsync())\n            {\n                try\n                {\n                    var deleted = reader.GetBoolean(reader.GetOrdinal(\"IsDeleted\"));\n                    var pr = new Persistent(\n                        deleted ? DeletedMarker : ReadPayload(reader, 4),\n                        reader.GetInt64(reader.GetOrdinal(\"SequenceNr\")),\n                        reader.GetString(reader.GetOrdinal(\"PersistenceId\")),\n                        reader.IsDBNull(reader.GetOrdinal(\"Manifest\")) ? string.Empty : reader.GetString(reader.GetOrdinal(\"Manifest\")),\n                        deleted,\n                        ActorRefs.NoSender,\n                        string.Empty,\n                        reader.GetInt64(reader.GetOrdinal(\"Timestamp\")));\n\n                    // Journal recovery happens while persistent actor is suspended, so we can just\n                    // directly invoke their persist-actor handler\n                    try\n                    {\n                        recoveryCallback(pr);\n                    }\n                    catch (Exception ex)\n                    {\n                        persistentMessages.Add(new KeyValuePair<Exception, IPersistentRepresentation>(ex, pr));\n                    }\n                }\n                catch (Exception e)\n                {\n                    _log.Error(e, \"Error while reading and replaying event for persistenceId {0}\", persistenceId);\n                    throw;\n                }\n            }\n            if (persistentMessages.Count == 0) return;\n            \n            throw new ReplayMessagesException(\"Error during replay of the following messages:\", persistentMessages);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Abstract Lease Class Definition in C#\nDESCRIPTION: Defines the abstract Lease class that provides methods for acquiring, checking, and releasing leases in a distributed coordination system. Requires LeaseSettings for configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.DotNet.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Lease\n{\n    public Lease(Akka.Coordination.LeaseSettings settings) { }\n    public Akka.Coordination.LeaseSettings Settings { get; }\n    public abstract System.Threading.Tasks.Task<bool> Acquire();\n    public abstract System.Threading.Tasks.Task<bool> Acquire(System.Action<System.Exception> leaseLostCallback);\n    public abstract bool CheckLease();\n    public abstract System.Threading.Tasks.Task<bool> Release();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DeadLetter Class in C#\nDESCRIPTION: A sealed class representing a dead letter in the actor system. Dead letters are messages that couldn't be delivered to their recipients, stored with sender and recipient information.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_115\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DeadLetter : Akka.Event.AllDeadLetters\n{\n    public DeadLetter(object message, Akka.Actor.IActorRef sender, Akka.Actor.IActorRef recipient) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GetSuccess Class in C# for Akka.NET Distributed Data\nDESCRIPTION: Defines the GetSuccess class, representing a successful response to a Get request. It includes properties for the key, request, and retrieved data.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class GetSuccess : Akka.Actor.INoSerializationVerificationNeeded, Akka.DistributedData.IGetResponse, Akka.DistributedData.IReplicatorMessage, System.IEquatable<Akka.DistributedData.GetSuccess>\n{\n    public GetSuccess(Akka.DistributedData.IKey key, object request, Akka.DistributedData.IReplicatedData data) { }\n    public Akka.DistributedData.IReplicatedData Data { get; }\n    public bool IsFailure { get; }\n    public bool IsFound { get; }\n    public bool IsSuccessful { get; }\n    public Akka.DistributedData.IKey Key { get; }\n    public object Request { get; }\n    public bool Equals(Akka.DistributedData.GetSuccess other) { }\n    public override bool Equals(object obj) { }\n    public T Get<T>(Akka.DistributedData.IKey<T> key)\n        where T : Akka.DistributedData.IReplicatedData { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NewtonSoftJsonSerializerSettings in Akka.NET\nDESCRIPTION: Defines configuration settings for NewtonSoftJsonSerializer with options for type encoding, reference preservation, custom converters, and string builder pooling. Includes a factory method to create settings from Akka configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_195\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class NewtonSoftJsonSerializerSettings\n{\n    public static readonly Akka.Serialization.NewtonSoftJsonSerializerSettings Default;\n    public NewtonSoftJsonSerializerSettings(bool encodeTypeNames, bool preserveObjectReferences, System.Collections.Generic.IEnumerable<System.Type> converters, bool usePooledStringBuilder, int stringBuilderMinSize, int stringBuilderMaxSize) { }\n    public System.Collections.Generic.IEnumerable<System.Type> Converters { get; }\n    public bool EncodeTypeNames { get; }\n    public bool PreserveObjectReferences { get; }\n    public int StringBuilderMaxSize { get; }\n    public int StringBuilderMinSize { get; }\n    public bool UsePooledStringBuilder { get; }\n    public static Akka.Serialization.NewtonSoftJsonSerializerSettings Create(Akka.Configuration.Config config) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterRouterPool Class in C#\nDESCRIPTION: Defines a ClusterRouterPool class that extends Akka.Routing.Pool. This class manages routing in a cluster environment using a pool of actors, including creating routers and handling management messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Core.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterRouterPool : Akka.Routing.Pool\n{\n    public ClusterRouterPool(Akka.Routing.Pool local, Akka.Cluster.Routing.ClusterRouterPoolSettings settings) { }\n    public Akka.Routing.Pool Local { get; }\n    public override string RouterDispatcher { get; }\n    public Akka.Cluster.Routing.ClusterRouterPoolSettings Settings { get; }\n    public override bool StopRouterWhenAllRouteesRemoved { get; }\n    public override Akka.Actor.SupervisorStrategy SupervisorStrategy { get; }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override Akka.Actor.ActorBase CreateRouterActor() { }\n    public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }\n    public override bool IsManagementMessage(object message) { }\n    public override Akka.Actor.Props RoutingLogicController(Akka.Routing.RoutingLogic routingLogic) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Metric Class in Akka.NET using C#\nDESCRIPTION: The Metric class represents a quantifiable measurement within the Akka.NET framework, featuring functionality to create and combine metrics. It works with Optional types to handle nullable values and supports the conversion and smoothing of numerical values. Dependencies include Akka.Cluster, Akka.Util libraries, and System.Runtime.CompilerServices for handling nullable types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.DotNet.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class Metric : System.IEquatable<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric> {\n    public Metric(string name, Akka.Cluster.Metrics.Helpers.AnyNumber value, [System.Runtime.CompilerServices.NullableAttribute(new byte[] { 0, 1})] Akka.Util.Option<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA> average) { }\n    [System.Runtime.CompilerServices.NullableAttribute(new byte[] { 0, 1})]\n    public Akka.Util.Option<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA> Average { get; }\n    public bool IsSmooth { get; }\n    public string Name { get; }\n    public double SmoothValue { get; }\n    public Akka.Cluster.Metrics.Helpers.AnyNumber Value { get; }\n    public Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric Add(Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric latest) { }\n    [Akka.Annotations.InternalApiAttribute()]\n    public static Akka.Util.Either<long, double> ConvertNumber(Akka.Cluster.Metrics.Helpers.AnyNumber number) { }\n    [return: System.Runtime.CompilerServices.NullableAttribute(new byte[] { 0, 1})]\n    public static Akka.Util.Option<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric> Create(string name, Akka.Cluster.Metrics.Helpers.AnyNumber value) { }\n    [return: System.Runtime.CompilerServices.NullableAttribute(new byte[] { 0, 1})]\n    public static Akka.Util.Option<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric> Create([System.Runtime.CompilerServices.NullableAttribute(1)] string name, Akka.Cluster.Metrics.Helpers.AnyNumber value, Akka.Util.Option<double> decayFactor) { }\n    [return: System.Runtime.CompilerServices.NullableAttribute(new byte[] { 0, 1})]\n    public static Akka.Util.Option<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric> Create(string name, Akka.Util.Try<Akka.Cluster.Metrics.Helpers.AnyNumber> value, [System.Runtime.CompilerServices.NullableAttribute(0)] Akka.Util.Option<double> decayFactor) { }\n    [return: System.Runtime.CompilerServices.NullableAttribute(new byte[] { 0, 1})]\n    public static Akka.Util.Option<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA> CreateEWMA(Akka.Cluster.Metrics.Helpers.AnyNumber value, Akka.Util.Option<double> decayFactor) { }\n    [Akka.Annotations.InternalApiAttribute()]\n    public static bool Defined(Akka.Cluster.Metrics.Helpers.AnyNumber value) { }\n    public bool Equals(Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public bool SameAs(Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric that) { }\n    public static Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric +(Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric m1, Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric m2) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Flattening Sequences in Akka.NET Streams\nDESCRIPTION: Shows how to use SelectMany to flatten a stream of tweets into a stream of hashtags, similar to how SelectMany works on .NET Collections.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/reactivetweets.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nSource<IHashtagEntity, NotUsed> hashTags = tweetSource.SelectMany(tweet => tweet.Hashtags);\n```\n\n----------------------------------------\n\nTITLE: Message Expectation Methods\nDESCRIPTION: Methods for expecting and asserting messages received by test actors with various timeout and cancellation options.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic T ExpectMsg<T>(System.Nullable<System.TimeSpan> duration = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic T ExpectMsg<T>(T message, System.Nullable<System.TimeSpan> timeout = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Actor Reference Extensions\nDESCRIPTION: Provides extension methods for actor references, offering utility functions for actor selection, creation, and null checking\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class ActorRefExtensions { \n    public static bool IsNobody(this Akka.Actor.IActorRef actorRef) { } \n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Deploy Configuration in C#\nDESCRIPTION: Class handling deployment configuration for Akka.NET actors, including router config, dispatcher settings and mailbox configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic class Deploy : Akka.Util.ISurrogated, System.IEquatable<Akka.Actor.Deploy>\n{\n    public static readonly Akka.Actor.Deploy Local;\n    public static readonly string NoDispatcherGiven;\n    public static readonly string NoMailboxGiven;\n    public static readonly Akka.Actor.Scope NoScopeGiven;\n    public static readonly Akka.Actor.Deploy None;\n    public Deploy() { }\n    public Deploy(string path, Akka.Actor.Scope scope) { }\n    public Deploy(Akka.Actor.Scope scope) { }\n    public Deploy(Akka.Routing.RouterConfig routerConfig, Akka.Actor.Scope scope) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NewtonSoftJsonSerializerSettings Configuration in C#\nDESCRIPTION: Configuration settings class for the NewtonSoftJsonSerializer. Provides options for type name encoding, object reference preservation, custom converters, and string builder pooling for efficient JSON serialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_210\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class NewtonSoftJsonSerializerSettings\n    {\n        public static readonly Akka.Serialization.NewtonSoftJsonSerializerSettings Default;\n        public NewtonSoftJsonSerializerSettings(bool encodeTypeNames, bool preserveObjectReferences, System.Collections.Generic.IEnumerable<System.Type> converters, bool usePooledStringBuilder, int stringBuilderMinSize, int stringBuilderMaxSize) { }\n        public System.Collections.Generic.IEnumerable<System.Type> Converters { get; }\n        public bool EncodeTypeNames { get; }\n        public bool PreserveObjectReferences { get; }\n        public int StringBuilderMaxSize { get; }\n        public int StringBuilderMinSize { get; }\n        public bool UsePooledStringBuilder { get; }\n        public static Akka.Serialization.NewtonSoftJsonSerializerSettings Create(Akka.Configuration.Config config) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing AtomicCounter Class in C#\nDESCRIPTION: A thread-safe counter implementation with atomic operations for incrementing, decrementing, and manipulating counter values.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_243\n\nLANGUAGE: C#\nCODE:\n```\npublic class AtomicCounter : Akka.Util.Internal.IAtomicCounter<int>\n{\n    public AtomicCounter(int initialValue) { }\n    public AtomicCounter() { }\n    public int Current { get; }\n    public int AddAndGet(int amount) { }\n    public bool CompareAndSet(int expected, int newValue) { }\n    public int Decrement() { }\n    public int DecrementAndGet() { }\n    public int GetAndAdd(int amount) { }\n    public int GetAndDecrement() { }\n    public int GetAndIncrement() { }\n    public int GetAndSet(int value) { }\n    public int IncrementAndGet() { }\n    public int Next() { }\n    public void Reset() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TailChoppingPool Router Class in Akka.NET\nDESCRIPTION: Defines a TailChoppingPool router class that distributes messages using a tail-chopping strategy. It includes configuration options for timing parameters, resizer, and supervisor strategy, along with methods for creating customized instances.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_190\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class TailChoppingPool : Akka.Routing.Pool\n{\n    public TailChoppingPool(Akka.Configuration.Config config) { }\n    public TailChoppingPool(int nrOfInstances, System.TimeSpan within, System.TimeSpan interval) { }\n    public TailChoppingPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, System.TimeSpan within, System.TimeSpan interval, bool usePoolDispatcher = False) { }\n    public System.TimeSpan Interval { get; }\n    public System.TimeSpan Within { get; }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Routing.TailChoppingPool WithDispatcher(string dispatcher) { }\n    public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n    public Akka.Routing.TailChoppingPool WithResizer(Akka.Routing.Resizer resizer) { }\n    public Akka.Routing.TailChoppingPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }\n    public class TailChoppingPoolSurrogate : Akka.Util.ISurrogate\n    {\n        public TailChoppingPoolSurrogate() { }\n        public System.TimeSpan Interval { get; set; }\n        public int NrOfInstances { get; set; }\n        public Akka.Routing.Resizer Resizer { get; set; }\n        public string RouterDispatcher { get; set; }\n        public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }\n        public bool UsePoolDispatcher { get; set; }\n        public System.TimeSpan Within { get; set; }\n        public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Pool Base Class for Router Configuration\nDESCRIPTION: Abstract base class for pool-based router configurations that manage a pool of routee instances. Includes functionality for supervisor strategy and pool dispatcher settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_183\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Pool : Akka.Routing.RouterConfig, System.IEquatable<Akka.Routing.Pool>\n{\n    protected Pool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher) { }\n    public static Akka.Actor.SupervisorStrategy DefaultSupervisorStrategy { get; }\n    public int NrOfInstances { get; }\n    public virtual Akka.Routing.Resizer Resizer { get; }\n    public override bool StopRouterWhenAllRouteesRemoved { get; }\n    public virtual Akka.Actor.SupervisorStrategy SupervisorStrategy { get; }\n    public virtual bool UsePoolDispatcher { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FastLazy<T> Class in C#\nDESCRIPTION: A lazy initialization utility that provides performance-optimized lazy loading. Creates values on demand and caches them for future use, with methods to check if the value has been created.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_238\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class FastLazy<T>\n{\n    public FastLazy(System.Func<T> producer) { }\n    public T Value { get; }\n    public bool IsValueCreated() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating RandomPool Router in C# Code\nDESCRIPTION: Shows how to create a random pool router directly in C# code with 5 worker instances. Messages will be distributed randomly to the workers.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nvar router = system.ActorOf(Props.Create<Worker>().WithRouter(new RandomPool(5)), \"some-pool\");\n```\n\n----------------------------------------\n\nTITLE: Implementing ListPriorityQueue Class in C#\nDESCRIPTION: A priority queue implementation for Akka.Actor.Envelope objects. Uses a priority calculator function to determine the order of elements and provides methods for enqueueing and dequeueing items.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_244\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ListPriorityQueue\n{\n    public ListPriorityQueue(int initialCapacity, System.Func<object, int> priorityCalculator) { }\n    public int Count() { }\n    public Akka.Actor.Envelope Dequeue() { }\n    public void Enqueue(Akka.Actor.Envelope item) { }\n    public bool IsConsistent() { }\n    public Akka.Actor.Envelope Peek() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TestTransport for Akka.NET Remote Testing\nDESCRIPTION: Test transport implementation that provides controllable behaviors for associations, disassociations, listening, and writing. Uses SwitchableLoggedBehavior to allow customization of transport behavior during tests.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestTransport : Akka.Remote.Transport.Transport\n{\n    public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<Akka.Actor.Address, Akka.Remote.Transport.AssociationHandle> AssociateBehavior;\n    public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<Akka.Remote.Transport.TestAssociationHandle, bool> DisassociateBehavior;\n    public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<bool, System.ValueTuple<Akka.Actor.Address, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.IAssociationEventListener>>> ListenBehavior;\n    public readonly Akka.Actor.Address LocalAddress;\n    public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<bool, bool> ShutdownBehavior;\n    public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<System.ValueTuple<Akka.Remote.Transport.TestAssociationHandle, Google.Protobuf.ByteString>, bool> WriteBehavior;\n    public TestTransport(Akka.Actor.ActorSystem system, Akka.Configuration.Config conf) { }\n    public TestTransport(Akka.Actor.Address localAddress, Akka.Remote.Transport.AssociationRegistry registry, long maximumPayloadBytes = 32000, string schemeIdentifier = \"test\") { }\n    public override System.Threading.Tasks.Task<Akka.Remote.Transport.AssociationHandle> Associate(Akka.Actor.Address remoteAddress) { }\n    public System.Threading.Tasks.Task<bool> DefaultDisassociate(Akka.Remote.Transport.TestAssociationHandle handle) { }\n    public System.Threading.Tasks.Task<System.ValueTuple<Akka.Actor.Address, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.IAssociationEventListener>>> DefaultListen() { }\n    public System.Threading.Tasks.Task Disassociate(Akka.Remote.Transport.TestAssociationHandle handle) { }\n    public override bool IsResponsibleFor(Akka.Actor.Address remote) { }\n    public override System.Threading.Tasks.Task<System.ValueTuple<Akka.Actor.Address, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.IAssociationEventListener>>> Listen() { }\n    public override System.Threading.Tasks.Task<bool> Shutdown() { }\n    public System.Threading.Tasks.Task<bool> Write(Akka.Remote.Transport.TestAssociationHandle handle, Google.Protobuf.ByteString payload) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LoggerMailbox for Akka.NET messaging\nDESCRIPTION: LoggerMailbox class extends Mailbox and implements various mailbox semantics interfaces. This specialized mailbox is used for logger actors in Akka.NET to ensure proper message handling for logging.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_144\n\nLANGUAGE: C#\nCODE:\n```\npublic class LoggerMailbox : Akka.Dispatch.Mailbox, Akka.Dispatch.ISemantics, Akka.Dispatch.IUnboundedMessageQueueSemantics, Akka.Dispatch.MessageQueues.IMessageQueue, Akka.Event.ILoggerMessageQueueSemantics\n{\n    public LoggerMailbox(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SQL Read Journal in Akka.NET C#\nDESCRIPTION: The SqlReadJournal class implements multiple interfaces to provide various querying capabilities for events. It uses Akka streams to return event sources and identifier strings for specific persistence IDs and tags. The class requires an Akka actor system and configuration upon initialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommonQuery.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\\\"RepositoryUrl\\\", \\\"https://github.com/akkadotnet/akka.net\\\")]\\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\\n[assembly: System.Runtime.InteropServices.GuidAttribute(\\\"3cbd3880-0655-44cc-ad81-77e8cadfcc3e\\\")]\\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\\\".NETStandard,Version=v2.0\\\", FrameworkDisplayName=\\\"\\\")]\\nnamespace Akka.Persistence.Query.Sql\\n{\\n    public class SqlReadJournal : Akka.Persistence.Query.IAllEventsQuery, Akka.Persistence.Query.ICurrentAllEventsQuery, Akka.Persistence.Query.ICurrentEventsByPersistenceIdQuery, Akka.Persistence.Query.ICurrentEventsByTagQuery, Akka.Persistence.Query.ICurrentPersistenceIdsQuery, Akka.Persistence.Query.IEventsByPersistenceIdQuery, Akka.Persistence.Query.IEventsByTagQuery, Akka.Persistence.Query.IPersistenceIdsQuery, Akka.Persistence.Query.IReadJournal\\n    {\\n        public static string Identifier;\\n        public SqlReadJournal(Akka.Actor.ExtendedActorSystem system, Akka.Configuration.Config config) { }\\n        public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> AllEvents(Akka.Persistence.Query.Offset offset = null) { }\\n        public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentAllEvents(Akka.Persistence.Query.Offset offset) { }\\n        public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentEventsByPersistenceId(string persistenceId, long fromSequenceNr, long toSequenceNr) { }\\n        public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentEventsByTag(string tag, Akka.Persistence.Query.Offset offset = null) { }\\n        public Akka.Streams.Dsl.Source<string, Akka.NotUsed> CurrentPersistenceIds() { }\\n        public static Akka.Configuration.Config DefaultConfiguration() { }\\n        public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> EventsByPersistenceId(string persistenceId, long fromSequenceNr, long toSequenceNr) { }\\n        public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> EventsByTag(string tag, Akka.Persistence.Query.Offset offset = null) { }\\n        public Akka.Streams.Dsl.Source<string, Akka.NotUsed> PersistenceIds() { }\\n    }\\n    public class SqlReadJournalProvider : Akka.Persistence.Query.IReadJournalProvider\\n    {\\n        public SqlReadJournalProvider(Akka.Actor.ExtendedActorSystem system, Akka.Configuration.Config config) { }\\n        public Akka.Persistence.Query.IReadJournal GetReadJournal() { }\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Message Reply Pattern\nDESCRIPTION: Example of replying to messages using Sender reference in Akka.NET actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\nReceive<string>(() => \n{\n    var result = calculateResult();\n\n    // do not forget the second argument!\n    Sender.Tell(result, Self);\n})\n```\n\n----------------------------------------\n\nTITLE: Actor Reference Factory Extensions\nDESCRIPTION: Static methods for creating actors and actor selections using factory interfaces\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class static ActorRefFactoryExtensions { \n    public static Akka.Actor.IActorRef ActorOf<TActor>(this Akka.Actor.IActorRefFactory factory, string name = null) \n        where TActor : Akka.Actor.ActorBase, new () { } \n    public static Akka.Actor.ActorSelection ActorSelection(this Akka.Actor.IActorRefFactory factory, Akka.Actor.IActorRef anchorRef, string actorPath) { } \n}\n```\n\n----------------------------------------\n\nTITLE: Defining Core Snapshot Interfaces in C#\nDESCRIPTION: Core interface definitions for snapshot functionality in Akka.NET, including ISnapshotMessage, ISnapshotRequest, and ISnapshotResponse interfaces.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ISnapshotMessage : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage { }\npublic interface ISnapshotRequest : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage { }\npublic interface ISnapshotResponse : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage { }\n```\n\n----------------------------------------\n\nTITLE: Implementing TimeSpan Extensions in C#\nDESCRIPTION: Static extension methods for TimeSpan to handle common timespan operations and validations in testing scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\npublic class static TimeSpanExtensions\n{\n    public static void EnsureIsPositiveFinite(this System.TimeSpan timeSpan, string parameterName) { }\n    public static bool IsInfinite(this System.TimeSpan timeSpan) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterMetricsSettings Class in C#\nDESCRIPTION: Configuration settings class for Akka.NET Cluster Metrics. Provides access to various configuration properties for metrics collection, sampling intervals, and supervisor settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.DotNet.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterMetricsSettings\n{\n    public ClusterMetricsSettings(Akka.Configuration.Config config) { }\n    public bool CollectorEnabled { get; }\n    public bool CollectorFallback { get; }\n    public System.TimeSpan CollectorGossipInterval { get; }\n    public System.TimeSpan CollectorMovingAverageHalfLife { get; }\n    public string CollectorProvider { get; }\n    public System.TimeSpan CollectorSampleInterval { get; }\n    public string MetricsDispatcher { get; }\n    public System.TimeSpan PeriodicTasksInitialDelay { get; }\n    public string SupervisorName { get; }\n    public Akka.Configuration.Config SupervisorStrategyConfiguration { get; }\n    public string SupervisorStrategyProvider { get; }\n    public static Akka.Cluster.Metrics.Configuration.ClusterMetricsSettings Create(Akka.Configuration.Config config) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BusLogging Class in C#\nDESCRIPTION: A sealed class that extends LoggingAdapterBase to provide logging functionality through a bus system. It handles different log levels and manages the routing of log messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_114\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class BusLogging : Akka.Event.LoggingAdapterBase\n{\n    public BusLogging(Akka.Event.LoggingBus bus, string logSource, System.Type logClass, Akka.Event.ILogMessageFormatter logMessageFormatter) { }\n    public Akka.Event.LoggingBus Bus { get; }\n    public override bool IsDebugEnabled { get; }\n    public override bool IsErrorEnabled { get; }\n    public override bool IsInfoEnabled { get; }\n    public override bool IsWarningEnabled { get; }\n    public System.Type LogClass { get; }\n    public string LogSource { get; }\n    protected override void NotifyLog(Akka.Event.LogLevel logLevel, object message, System.Exception cause = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Lease Lifecycle Management\nDESCRIPTION: Implementation of lease lifecycle management within actor lifecycle methods PreStart and PostStop.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/lease.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override void PreStart()\n{\n    AcquireLease();\n    base.PreStart();\n}\n\nprotected override void PostStop()\n{\n    _lease?.Release();\n    base.PostStop();\n}\n```\n\n----------------------------------------\n\nTITLE: ConsumerController Start Command in C#\nDESCRIPTION: Command class used to start a ConsumerController with a specified destination actor for message delivery in the reliable delivery system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_87\n\nLANGUAGE: C#\nCODE:\n```\n    [System.Runtime.CompilerServices.NullableAttribute(0)]\n    public sealed class Start<[System.Runtime.CompilerServices.NullableAttribute(2)]  T> : Akka.Delivery.ConsumerController.IConsumerCommand<T>\n    {\n        public Start(Akka.Actor.IActorRef deliverTo) { }\n        public Akka.Actor.IActorRef DeliverTo { get; }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing LocalActorRef Class in C#\nDESCRIPTION: Defines a LocalActorRef class that represents a local actor reference with methods for managing actor lifecycle and message passing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\npublic class LocalActorRef : Akka.Actor.ActorRefWithCell, Akka.Actor.IActorRefScope\n{\n    public LocalActorRef(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.Props props, Akka.Dispatch.MessageDispatcher dispatcher, Akka.Dispatch.MailboxType mailboxType, Akka.Actor.IInternalActorRef supervisor, Akka.Actor.ActorPath path) { }\n    public Akka.Actor.ActorCell Cell { get; }\n    public override System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> Children { get; }\n    protected Akka.Dispatch.MessageDispatcher Dispatcher { get; }\n    public override bool IsLocal { get; }\n    public override bool IsTerminated { get; }\n    protected Akka.Dispatch.MailboxType MailboxType { get; }\n    public override Akka.Actor.IInternalActorRef Parent { get; }\n    public override Akka.Actor.ActorPath Path { get; }\n    protected Akka.Actor.Props Props { get; }\n    public override Akka.Actor.IActorRefProvider Provider { get; }\n    protected Akka.Actor.IInternalActorRef Supervisor { get; }\n    protected Akka.Actor.ActorSystem System { get; }\n    public override Akka.Actor.ICell Underlying { get; }\n    public override Akka.Actor.IActorRef GetChild(System.Collections.Generic.IReadOnlyList<string> name) { }\n    public override Akka.Actor.IInternalActorRef GetSingleChild(string name) { }\n    protected virtual Akka.Actor.ActorCell NewActorCell(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.IInternalActorRef self, Akka.Actor.Props props, Akka.Dispatch.MessageDispatcher dispatcher, Akka.Actor.IInternalActorRef supervisor) { }\n    public override void Restart(System.Exception cause) { }\n    public override void Resume(System.Exception causedByFailure = null) { }\n    public override void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message) { }\n    public override void Start() { }\n    public override void Stop() { }\n    public override void Suspend() { }\n    protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting and Inheriting Attributes in Akka.NET Stream Components\nDESCRIPTION: This code shows how to set attributes on stream components using WithAttributes() and Named() methods. It demonstrates how attributes like InputBuffer are inherited by nested modules unless explicitly overridden.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/modularitycomposition.md#2025-04-16_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nvar nestedSource = Source.Single(0)\n    .Select(x => x + 1)\n    .Named(\"nestedSource\"); // Wrap, no inputBuffer set\n\nvar nestedFlow =\n    Flow.Create<int>()\n        .Where(x => x != 0)\n        .Via(Flow.Create<int>().Select(x => x - 2).WithAttributes(Attributes.CreateInputBuffer(4, 4)))\n        // override\n        .Named(\"nestedFlow\"); // Wrap, no inputBuffer set\n\nvar nestedSink = nestedFlow\n    .To(Sink.Aggregate<int, int>(0, (sum, i) => sum + i)) // wire an atomic sink to the nestedFlow\n    .WithAttributes(Attributes.CreateName(\"nestedSink\").And(Attributes.CreateInputBuffer(3, 3))); // override\n```\n\n----------------------------------------\n\nTITLE: Registering Producer with ShardingProducerController in C#\nDESCRIPTION: Demonstrates how to register a Producer actor with a ShardingProducerController, including setting up the necessary Props and sending the Start message.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-sharding-delivery.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar producerId = \"shopping-cart-producer\";\nvar producerControllerSettings = ProducerController.Create(system);\nvar producerController = system.ActorOf(\n    ShardingProducerController.Props(\n        producerId,\n        producerControllerSettings,\n        shardRegion,\n        new ShardingMessageExtractor()),\n    \"producer-controller\");\n\nvar producer = system.ActorOf(Props.Create(() => new ShoppingCartProducer(producerController)), \"producer\");\nproducerController.Tell(new ShardingProducerController.Start<IConfirmableMessage>(producer));\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterClientDiscovery in Akka.NET\nDESCRIPTION: The ClusterClientDiscovery class provides service discovery functionality for the ClusterClient, allowing it to dynamically find contact points to the cluster. It implements several interfaces for actor functionality including stashing, timers and message queue semantics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Net.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic class ClusterClientDiscovery : Akka.Actor.UntypedActor, Akka.Actor.IActorStash, Akka.Actor.IWithTimers, Akka.Actor.IWithUnboundedStash, Akka.Actor.IWithUnrestrictedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics>\n{\n    public ClusterClientDiscovery(Akka.Cluster.Tools.Client.ClusterClientSettings settings) { }\n    public Akka.Actor.IStash Stash { get; set; }\n    public Akka.Actor.ITimerScheduler Timers { get; set; }\n    protected override void OnReceive(object message) { }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UnboundedDequeBasedMailbox Class in C#\nDESCRIPTION: Sealed class implementing a mailbox type that uses an unbounded deque (double-ended queue) for message storage. Allows both FIFO message processing and priority message insertion at the front of the queue.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_102\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class UnboundedDequeBasedMailbox : Akka.Dispatch.MailboxType, Akka.Dispatch.IProducesMessageQueue<Akka.Dispatch.MessageQueues.UnboundedDequeMessageQueue>\n{\n    public UnboundedDequeBasedMailbox(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }\n    public override Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Consistent Hashing Router Implementation in C#\nDESCRIPTION: Implements consistent hashing functionality for distributing messages across actor nodes. Supports virtual nodes and hash-based routing decisions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_178\n\nLANGUAGE: C#\nCODE:\n```\npublic class ConsistentHash<T>\n{\n    public ConsistentHash(System.Collections.Generic.SortedDictionary<int, T> nodes, int virtualNodesFactor) { }\n    public bool IsEmpty { get; }\n    public Akka.Routing.ConsistentHash<T> Add(T node) { }\n    public T NodeFor(byte[] key) { }\n    public T NodeFor(string key) { }\n    public Akka.Routing.ConsistentHash<T> Remove(T node) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Surrogates in HOCON for Hyperion Serialization\nDESCRIPTION: This HOCON snippet configures the Hyperion serializer to use a custom surrogate for the complex class `Foo`, detailing how to bind the serializers with surrogate types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/serialization/serialization.md#2025-04-16_snippet_12\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor {\n    serializers.hyperion = \"\"Akka.Serialization.HyperionSerializer, Akka.Serialization.Hyperion\"\"\n    serialization-bindings {\n        \"\"System.Object\"\" = hyperion\n    }\n    serialization-settings.hyperion {\n        surrogates = [\n            \"\"MyAssembly.FooHyperionSurrogate, MyAssembly\"\"\n        ]\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ClusterClient Class Definition in C#\nDESCRIPTION: A sealed class that implements the client side of cluster communication, allowing an external system to interact with an Akka cluster. It provides methods for sending and publishing messages to actors within the cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Core.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterClient : Akka.Actor.ActorBase\n{\n    public ClusterClient(Akka.Cluster.Tools.Client.ClusterClientSettings settings) { }\n    protected override void PostStop() { }\n    public static Akka.Actor.Props Props(Akka.Cluster.Tools.Client.ClusterClientSettings settings) { }\n    protected override bool Receive(object message) { }\n    public sealed class Publish\n    {\n        public Publish(string topic, object message) { }\n        public object Message { get; }\n        public string Topic { get; }\n    }\n    public sealed class Send\n    {\n        public Send(string path, object message, bool localAffinity = False) { }\n        public bool LocalAffinity { get; }\n        public object Message { get; }\n        public string Path { get; }\n    }\n    public sealed class SendToAll\n    {\n        public SendToAll(string path, object message) { }\n        public object Message { get; }\n        public string Path { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ByteString Implementation\nDESCRIPTION: Implements ByteString class for efficient byte array handling with methods for concatenation, copying, and conversion. Includes comparison operators and utility methods.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_147\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ByteString : System.Collections.Generic.IEnumerable<byte>, System.Collections.IEnumerable, System.IEquatable<Akka.IO.ByteString>\n{\n    public int Count { get; }\n    public static Akka.IO.ByteString Empty { get; }\n    public bool IsCompact { get; }\n    public bool IsEmpty { get; }\n    public byte this[int index] { get; }\n    // Methods omitted for brevity...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TailChopping Routing Logic in Akka.NET\nDESCRIPTION: Routing logic implementation for the TailChopping strategy. Sends messages to routees sequentially with a time delay between each send until a response is received or timeout occurs.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_219\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class TailChopping : Akka.Routing.RoutingLogic\n{\n    public TailChopping(Akka.Actor.IScheduler scheduler, System.TimeSpan within, System.TimeSpan interval) { }\n    public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Values with Fallbacks from HOCON in Akka.NET\nDESCRIPTION: Example of retrieving a value that relies on fallback configurations in HOCON.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/config.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar c = yourConfig.GetString(\"c\");\n```\n\n----------------------------------------\n\nTITLE: Implementing SimpleDnsCache Class in C#\nDESCRIPTION: Provides a simple DNS cache implementation. It inherits from DnsBase and includes methods for caching and cleaning up DNS resolutions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_164\n\nLANGUAGE: C#\nCODE:\n```\npublic class SimpleDnsCache : Akka.IO.DnsBase\n{\n    public SimpleDnsCache() { }\n    public override Akka.IO.Dns.Resolved Cached(string name) { }\n    public void CleanUp() { }\n    protected virtual long Clock() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Mailboxes Management Class in C#\nDESCRIPTION: Class responsible for the creation and lookup of mailbox types in an Akka.NET system. Manages the registration and retrieval of mailbox implementations based on configuration and actor requirements.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_95\n\nLANGUAGE: C#\nCODE:\n```\npublic class Mailboxes\n{\n    public static readonly string DefaultMailboxId;\n    public static readonly string NoMailboxRequirement;\n    public Mailboxes(Akka.Actor.ActorSystem system) { }\n    public Akka.Actor.DeadLetterMailbox DeadLetterMailbox { get; }\n    public Akka.Dispatch.MailboxType GetMailboxType(Akka.Actor.Props props, Akka.Configuration.Config dispatcherConfig) { }\n    public System.Type GetRequiredType(System.Type actorType) { }\n    public bool HasRequiredType(System.Type actorType) { }\n    public Akka.Dispatch.MailboxType Lookup(string id) { }\n    public Akka.Dispatch.MailboxType LookupByQueueType(System.Type queueType) { }\n    public bool ProducesMessageQueue(System.Type mailboxType) { }\n    [Akka.Annotations.InternalApiAttribute()]\n    public int StashCapacity(string dispatcher, string mailbox) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Getting a Reference to the Cluster Extension in Akka.NET\nDESCRIPTION: Shows how to obtain a direct reference to the Cluster extension from within an actor. This is typically the first step when working with Akka.Cluster functionality directly.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-extension.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Actor;\nusing Akka.Cluster;\nusing Akka.Event;\n\nnamespace Samples.Cluster.Simple\n{\n    public class SimpleClusterListener : UntypedActor\n    {\n        // get direct reference to the Cluster extension\n        protected Akka.Cluster.Cluster Cluster = Akka.Cluster.Cluster.Get(Context.System);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Stream Composition in C#\nDESCRIPTION: Demonstrates basic linear composition of stream processing stages using Source, Select, Where operations and Sink aggregation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/modularitycomposition.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nSource.Single(0)\n    .Select(x => x + 1)\n    .Where(x => x != 0)\n    .Select(x => x - 2)\n    .To(Sink.Aggregate<int, int>(0, (sum, x) => sum + x));\n```\n\n----------------------------------------\n\nTITLE: Defining TCP Connection Management Classes in Akka.NET\nDESCRIPTION: Classes representing different connection states and commands for managing TCP connections, including connection closure and termination options.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_154\n\nLANGUAGE: C#\nCODE:\n```\npublic class Abort : Akka.IO.Tcp.CloseCommand\n{\n    public static readonly Akka.IO.Tcp.Abort Instance;\n    public override Akka.IO.Tcp.ConnectionClosed Event { get; }\n}\npublic class Aborted : Akka.IO.Tcp.ConnectionClosed\n{\n    public static readonly Akka.IO.Tcp.Aborted Instance;\n    public override bool IsAborted { get; }\n}\npublic class Close : Akka.IO.Tcp.CloseCommand\n{\n    public static readonly Akka.IO.Tcp.Close Instance;\n    public override Akka.IO.Tcp.ConnectionClosed Event { get; }\n}\npublic abstract class CloseCommand : Akka.IO.Tcp.Command, Akka.Event.IDeadLetterSuppression\n{\n    protected CloseCommand() { }\n    public abstract Akka.IO.Tcp.ConnectionClosed Event { get; }\n}\npublic class Closed : Akka.IO.Tcp.ConnectionClosed\n{\n    public static readonly Akka.IO.Tcp.Closed Instance;\n}\npublic class ConfirmedClose : Akka.IO.Tcp.CloseCommand\n{\n    public static readonly Akka.IO.Tcp.ConfirmedClose Instance;\n    public override Akka.IO.Tcp.ConnectionClosed Event { get; }\n}\npublic class ConfirmedClosed : Akka.IO.Tcp.ConnectionClosed\n{\n    public static readonly Akka.IO.Tcp.ConfirmedClosed Instance;\n    public override bool IsConfirmed { get; }\n}\npublic class ConnectionClosed : Akka.IO.Tcp.Event, Akka.Event.IDeadLetterSuppression\n{\n    public ConnectionClosed() { }\n    public virtual string Cause { get; }\n    public virtual bool IsAborted { get; }\n    public virtual bool IsConfirmed { get; }\n    public virtual bool IsErrorClosed { get; }\n    public virtual bool IsPeerClosed { get; }\n}\npublic sealed class ErrorClosed : Akka.IO.Tcp.ConnectionClosed\n{\n    public ErrorClosed(string cause) { }\n    public override string Cause { get; }\n    public override bool IsErrorClosed { get; }\n    public override string ToString() { }\n}\npublic class PeerClosed : Akka.IO.Tcp.ConnectionClosed\n{\n    public static readonly Akka.IO.Tcp.PeerClosed Instance;\n    public override bool IsPeerClosed { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Hyperion Type Filter in C#\nDESCRIPTION: Demonstrates how to set up a type filter for Hyperion serialization in Akka.NET to allow specific types during deserialization for security purposes. It uses the TypeFilterBuilder to include allowed classes and applies the filter to the HyperionSerializerSetup.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/RELEASE_NOTES.md#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nvar typeFilter = TypeFilterBuilder.Create()\n    .Include<AllowedClassA>()\n    .Include<AllowedClassB>()\n    .Build();\nvar setup = HyperionSerializerSetup.Default\n    .WithTypeFilter(typeFilter);\n```\n\n----------------------------------------\n\nTITLE: Implementing State class for PersistentFSM in C#\nDESCRIPTION: Defines the State class with methods for handling state transitions and event processing in PersistentFSM. It includes functions for managing state data, applying events, setting timeouts, and managing replies.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_51\n\nLANGUAGE: C#\nCODE:\n```\npublic System.Collections.Generic.IReadOnlyList<object> Replies { get; set; }\npublic TD StateData { get; }\npublic TS StateName { get; }\npublic Akka.Actor.FSMBase.Reason StopReason { get; }\npublic System.Nullable<System.TimeSpan> Timeout { get; }\npublic Akka.Persistence.Fsm.PersistentFSM.State<TS, TD, TE> AndThen(System.Action<TD> handler) { }\npublic Akka.Persistence.Fsm.PersistentFSM.State<TS, TD, TE> Applying(params TE[] events) { }\npublic Akka.Persistence.Fsm.PersistentFSM.State<TS, TD, TE> ForMax(System.TimeSpan timeout) { }\npublic Akka.Persistence.Fsm.PersistentFSM.State<TS, TD, TE> Replying(object replyValue) { }\npublic override string ToString() { }\n[System.ObsoleteAttribute(\"Internal API easily to be confused with regular FSM\\'s using. Use regular events (\" +\n    \"`Applying`). Internally, `copy` can be used instead.\")]\npublic Akka.Persistence.Fsm.PersistentFSM.State<TS, TD, TE> Using(TD nextStateData) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ReplicatedDataSerializer for Akka.NET in C#\nDESCRIPTION: This class implements a serializer for replicated data in Akka.NET. It extends SerializerWithStringManifest and provides methods for serialization and deserialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_57\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ReplicatedDataSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public ReplicatedDataSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object o) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IPersistentIdentity Interface\nDESCRIPTION: This snippet defines the `IPersistentIdentity` interface, which is used to identify persistent actors and their associated journal and snapshot plugins in Akka.Persistence. It defines properties for the journal plugin ID, persistence ID, and snapshot plugin ID. This information is crucial for correctly storing and retrieving persistent state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\n\"public interface IPersistentIdentity\n    {\n        string JournalPluginId { get; }\n        string PersistenceId { get; }\n        string SnapshotPluginId { get; }\n    }\"\n```\n\n----------------------------------------\n\nTITLE: Implementing PersistenceQuery Class in C#\nDESCRIPTION: Defines the PersistenceQuery class, which is an Akka.NET extension for managing read journals. It provides methods for obtaining read journals and default configurations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceQuery.Net.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class PersistenceQuery : Akka.Actor.IExtension\n{\n    public PersistenceQuery(Akka.Actor.ExtendedActorSystem system) { }\n    public Akka.Event.ILoggingAdapter Log { get; }\n    public static Akka.Persistence.Query.PersistenceQuery Get(Akka.Actor.ActorSystem system) { }\n    public static Akka.Configuration.Config GetDefaultConfig<TJournal>() { }\n    public TJournal ReadJournalFor<TJournal>(string readJournalPluginId)\n        where TJournal : Akka.Persistence.Query.IReadJournal { }\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting Snapshots with Criteria Asynchronously in Akka.Persistence and C#\nDESCRIPTION: This method asynchronously deletes snapshots that match specified criteria for a given persistence ID. It is safeguarded by a circuit breaker to ensure robustness against transient failures that may occur during deletion operations in a persistence context.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/custom-persistence-provider.md#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nTask DeleteAsync(string persistenceId, SnapshotSelectionCriteria criteria);\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Write Journal\nDESCRIPTION: Abstract class providing asynchronous journal writing capabilities for persistence, including message replay and deletion functionality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AsyncWriteJournal : Akka.Persistence.Journal.WriteJournalBase, Akka.Persistence.Journal.IAsyncRecovery\n{\n    protected readonly bool CanPublish;\n    protected AsyncWriteJournal() { }\n    protected abstract System.Threading.Tasks.Task DeleteMessagesToAsync(string persistenceId, long toSequenceNr);\n    public abstract System.Threading.Tasks.Task<long> ReadHighestSequenceNrAsync(string persistenceId, long fromSequenceNr);\n    // Additional methods omitted for brevity\n}\n```\n\n----------------------------------------\n\nTITLE: Creating HOCON Config with Fallbacks in Akka.NET\nDESCRIPTION: Demonstrates how to create a HOCON configuration with multiple fallback layers, allowing for configuration inheritance and overrides.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/config.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar f0 = ConfigurationFactory.ParseString(\"a = bar\");\nvar f1 = ConfigurationFactory.ParseString(\"b = biz\");\nvar f2 = ConfigurationFactory.ParseString(\"c = baz\");\nvar f3 = ConfigurationFactory.ParseString(\"a = foo\");\n\nvar yourConfig = f0.WithFallback(f1)\n                   .WithFallback(f2)\n                   .WithFallback(f3);\n```\n\n----------------------------------------\n\nTITLE: Conditional Actor Deployment Based on Node Role in C#\nDESCRIPTION: C# code that checks if the current node has a specific role ('fraud') and conditionally creates an actor only on nodes with that role.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/member-roles.md#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nvar selfMember = Cluster.Get(_actorSystem).SelfMember;\nif (selfMember.HasRole(\"fraud\"))\n{\n    context.ActorOf(Billing.Prop(), \"bill-gate\");\n}\nelse\n{\n    //sleep, probably!\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Serialization Transformations with HyperionSerializerSetup\nDESCRIPTION: This C# snippet demonstrates how to configure the Hyperion serializer with package name overrides during the creation of an ActorSystem using compiler directives for cross-platform safety.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/serialization/serialization.md#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n#if NETFRAMEWORK\nvar hyperionSetup = HyperionSerializerSetup.Empty\n    .WithPackageNameOverrides(new Func<string, string>[]\n    {\n        str => str.Contains(\"System.Private.CoreLib,%core%\")\n            ? str.Replace(\"System.Private.CoreLib,%core%\", \"mscorlib,%core%\") : str\n    }\n#elif NETCOREAPP\nvar hyperionSetup = HyperionSerializerSetup.Empty\n    .WithPackageNameOverrides(new Func<string, string>[]\n    {\n        str => str.Contains(\"mscorlib,%core%\")\n            ? str.Replace(\"mscorlib,%core%\", \"System.Private.CoreLib,%core%\") : str\n    }\n#endif\n\nvar bootstrap = BootstrapSetup.Create().And(hyperionSetup);\nvar system = ActorSystem.Create(\"actorSystem\", bootstrap);\n```\n\n----------------------------------------\n\nTITLE: Implementing ChildrenContainerBase Abstract Class in C#\nDESCRIPTION: Base implementation for containers that manage child actors, including methods for adding, removing, and querying child actors in the hierarchy.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_51\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ChildrenContainerBase : Akka.Actor.Internal.IChildrenContainer\n{\n    protected ChildrenContainerBase(System.Collections.Immutable.IImmutableDictionary<string, Akka.Actor.Internal.IChildStats> children) { }\n    public System.Collections.Generic.IReadOnlyCollection<Akka.Actor.IInternalActorRef> Children { get; }\n    protected System.Collections.Immutable.IImmutableDictionary<string, Akka.Actor.Internal.IChildStats> InternalChildren { get; }\n    public virtual bool IsNormal { get; }\n    public virtual bool IsTerminating { get; }\n    public System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> Stats { get; }\n    public abstract Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats);\n    protected void ChildStatsAppender(System.Text.StringBuilder sb, System.Collections.Generic.KeyValuePair<string, Akka.Actor.Internal.IChildStats> kvp, int index) { }\n    public bool Contains(Akka.Actor.IActorRef actor) { }\n    public abstract Akka.Actor.Internal.IChildrenContainer Remove(Akka.Actor.IActorRef child);\n    public abstract Akka.Actor.Internal.IChildrenContainer Reserve(string name);\n    public abstract Akka.Actor.Internal.IChildrenContainer ShallDie(Akka.Actor.IActorRef actor);\n    public bool TryGetByName(string name, out Akka.Actor.Internal.IChildStats stats) { }\n    public bool TryGetByRef(Akka.Actor.IActorRef actor, out Akka.Actor.Internal.ChildRestartStats childRestartStats) { }\n    public abstract Akka.Actor.Internal.IChildrenContainer Unreserve(string name);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ShardingEnvelope Class in Akka.NET Sharding\nDESCRIPTION: This class encapsulates a message with its associated entity ID. It ensures that the message is routed to the correct entity instance. It is used to wrap the actual messages sent to the shard region.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_24\n\nLANGUAGE: csharp\nCODE:\n```\n    [System.Runtime.CompilerServices.NullableAttribute(0)]\n    public sealed class ShardingEnvelope : Akka.Actor.IWrappedMessage, Akka.Cluster.Sharding.IClusterShardingSerializable, System.IEquatable<Akka.Cluster.Sharding.ShardingEnvelope>\n    {\n        public ShardingEnvelope(string entityId, object message) { }\n        public string EntityId { get; }\n        public object Message { get; }\n        public bool Equals(Akka.Cluster.Sharding.ShardingEnvelope other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: External Shard Allocation Classes in C#\nDESCRIPTION: Defines classes for external shard allocation including ClientTimeoutException, ExternalShardAllocation extension, and related implementation classes. Provides functionality for external control of shard allocation in Akka.NET clusters.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.Cluster.Sharding.External\n{\n    public class ClientTimeoutException : System.Exception\n    {\n        public ClientTimeoutException(string message) { }\n        public ClientTimeoutException(string message, System.Exception innerEx) { }\n        protected ClientTimeoutException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n    }\n    public sealed class ExternalShardAllocation : Akka.Actor.IExtension\n    {\n        public ExternalShardAllocation(Akka.Actor.ExtendedActorSystem system) { }\n        public Akka.Cluster.Sharding.External.IExternalShardAllocationClient ClientFor(string typeName) { }\n        public static Akka.Cluster.Sharding.External.ExternalShardAllocation Get(Akka.Actor.ActorSystem system) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Stopping Child Actors in C#\nDESCRIPTION: Shows how to implement actor stopping logic including handling child actor termination.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyStoppingActor : UntypedActor\n{\n    private IActorRef child;\n\n    protected override void OnReceive(object message)\n    {\n        switch (message)\n        {\n            case \"interrupt-child\":\n                Context.Stop(child);\n                break;\n            case \"done\":\n                Context.Stop(Self);\n                break;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: RootGuardianActorRef Implementation in Akka.NET (C#)\nDESCRIPTION: Internal implementation of the root guardian actor, which is the top-level actor in an actor system. Handles special actor name lookups and system management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic class RootGuardianActorRef : Akka.Actor.LocalActorRef\n{\n    public RootGuardianActorRef(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.Props props, Akka.Dispatch.MessageDispatcher dispatcher, Akka.Dispatch.MailboxType mailboxType, Akka.Actor.IInternalActorRef supervisor, Akka.Actor.ActorPath path, Akka.Actor.IInternalActorRef deadLetters, System.Collections.Generic.IReadOnlyDictionary<string, Akka.Actor.IInternalActorRef> extraNames) { }\n    public override Akka.Actor.IInternalActorRef Parent { get; }\n    public override Akka.Actor.IInternalActorRef GetSingleChild(string name) { }\n    public void SetTempContainer(Akka.Actor.IInternalActorRef tempContainer) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Breaking Back-Pressure Cycles in Akka Streams TCP\nDESCRIPTION: This snippet shows how to break back-pressure cycles in client-server scenarios by injecting an initial message from the server side.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithstreamingio.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar welcomeMessage = Source.Single(ByteString.FromString(\"Welcome to the Akka TCP Server!\\n\"));\n\nvar commandHandler = Flow.Create<ByteString>()\n    .Merge(welcomeMessage)\n    .Via(Framing.Delimiter(\n        ByteString.FromString(\"\\n\"),\n        256,\n        allowTruncation: true))\n    .TakeWhile(text => !text.ToString().Contains(\"BYE\"))\n    .Concat(Source.Single(ByteString.FromString(\"BYE\\n\")))\n    .Map(text => ByteString.FromString(\"Server: \" + text + \"\\n\"));\n\nvar serverLogic = Sink.ForEach<Tcp.IncomingConnection>(connection =>\n    connection.HandleWith(commandHandler, materializer));\n\nvar binding = Tcp.Get(system).Bind(endpoint).RunWith(serverLogic, materializer);\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterSingletonManager FSM Class\nDESCRIPTION: Finite state machine implementation for managing singleton actors in an Akka.NET cluster. Handles lifecycle events and singleton actor instantiation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterSingletonManager : Akka.Actor.FSM<Akka.Cluster.Tools.Singleton.ClusterSingletonState, Akka.Cluster.Tools.Singleton.IClusterSingletonData>\n{\n    public ClusterSingletonManager(Akka.Actor.Props singletonProps, object terminationMessage, Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings settings) { }\n    public static Akka.Configuration.Config DefaultConfig() { }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n    public static Akka.Actor.Props Props(Akka.Actor.Props singletonProps, Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings settings) { }\n    public static Akka.Actor.Props Props(Akka.Actor.Props singletonProps, object terminationMessage, Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings settings) { }\n}\n```\n\n----------------------------------------\n\nTITLE: TcpSettings Configuration in Akka.NET\nDESCRIPTION: This snippet defines the TcpSettings class that controls TCP connection behavior in Akka.NET. It includes properties for configuring buffer pools, socket event arguments, timeouts, and other network-related settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_169\n\nLANGUAGE: csharp\nCODE:\n```\n    public class TcpSettings\n    {\n        public TcpSettings(string bufferPoolConfigPath, int initialSocketAsyncEventArgs, bool traceLogging, int batchAcceptLimit, System.Nullable<System.TimeSpan> registerTimeout, int receivedMessageSizeLimit, string managementDispatcher, string fileIoDispatcher, int transferToLimit, int finishConnectRetries, bool outgoingSocketForceIpv4, int writeCommandsQueueMaxSize) { }\n        public int BatchAcceptLimit { get; }\n        public string BufferPoolConfigPath { get; }\n        public string FileIODispatcher { get; }\n        public int FinishConnectRetries { get; }\n        public int InitialSocketAsyncEventArgs { get; }\n        public string ManagementDispatcher { get; }\n        public bool OutgoingSocketForceIpv4 { get; }\n        public int ReceivedMessageSizeLimit { get; }\n        public System.Nullable<System.TimeSpan> RegisterTimeout { get; }\n        public bool TraceLogging { get; }\n        public int TransferToLimit { get; set; }\n        public int WriteCommandsQueueMaxSize { get; }\n        public static Akka.IO.TcpSettings Create(Akka.Actor.ActorSystem system) { }\n        public static Akka.IO.TcpSettings Create(Akka.Configuration.Config config) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Collecting Missed Ticks using ConflateWithSeed in Akka.NET\nDESCRIPTION: Implements a flow that counts missed ticks using ConflateWithSeed. The flow maintains a counter of missed events when downstream processing is slower than upstream production.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/cookbook.md#2025-04-16_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nvar missed = Flow.Create<Tick>()\n  .ConflateWithSeed(seed: _ => 0, aggregate: (missedTicks, tick) => missedTicks + 1);\n```\n\n----------------------------------------\n\nTITLE: Implementing Escalate System Message in Akka.NET\nDESCRIPTION: Defines a system message that escalates an exception to a parent supervisor. Used in the actor supervision hierarchy to handle failures that need to be managed at a higher level.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_118\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Escalate : Akka.Dispatch.SysMsg.SystemMessage\n{\n    public Escalate(System.Exception reason) { }\n    public System.Exception Reason { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Base Actor Reference Implementation\nDESCRIPTION: Abstract base class defining core actor reference functionality including path management, equality comparison, and message telling capabilities.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ActorRefBase : Akka.Actor.IActorRef, Akka.Actor.ICanTell, Akka.Util.ISurrogated, System.IComparable, System.IComparable<Akka.Actor.IActorRef>, System.IEquatable<Akka.Actor.IActorRef>\n{\n    protected ActorRefBase() { }\n    public abstract Akka.Actor.ActorPath Path { get; }\n    public int CompareTo(object obj) { }\n    public int CompareTo(Akka.Actor.IActorRef other) { }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.Actor.IActorRef other) { }\n    public override int GetHashCode() { }\n    public void Tell(object message, Akka.Actor.IActorRef sender) { }\n    protected abstract void TellInternal(object message, Akka.Actor.IActorRef sender);\n    public override string ToString() { }\n    public virtual Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public class Surrogate : Akka.Util.ISurrogate\n    {\n        public Surrogate(string path) { }\n        public string Path { get; }\n        public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: DNS Implementation\nDESCRIPTION: Implements DNS resolution functionality including the Dns class, DnsExt extension, and related command classes for name resolution.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_148\n\nLANGUAGE: C#\nCODE:\n```\npublic class Dns : Akka.Actor.ExtensionIdProvider<Akka.IO.DnsExt>\n{\n    public static readonly Akka.IO.Dns Instance;\n    public Dns() { }\n    public static Akka.IO.Dns.Resolved Cached(string name, Akka.Actor.ActorSystem system) { }\n    public override Akka.IO.DnsExt CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n    // Additional methods omitted...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Actor Lifecycle Methods in C#\nDESCRIPTION: This snippet defines core methods for managing actor lifecycles, including becoming, receiving messages, and handling restarts.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_55\n\nLANGUAGE: C#\nCODE:\n```\nvoid Become(System.Action<object, Akka.Actor.IActorContext> handler);\nvoid BecomeStacked(System.Action<object, Akka.Actor.IActorContext> handler);\nvoid DefaultPostRestart(System.Exception reason);\nvoid DefaultPostStop();\nvoid DefaultPreRestart(System.Exception reason, object message);\nvoid DefaultPreStart();\nvoid Receive<T>(System.Action<T, Akka.Actor.IActorContext> handler);\nvoid Receive<T>(System.Predicate<T> shouldHandle, System.Action<T, Akka.Actor.IActorContext> handler);\nvoid Receive<T>(System.Action<T, Akka.Actor.IActorContext> handler, System.Predicate<T> shouldHandle);\nvoid ReceiveAny(System.Action<object, Akka.Actor.IActorContext> handler);\nvoid ReceiveAnyAsync(System.Func<object, Akka.Actor.IActorContext, System.Threading.Tasks.Task> handler);\nvoid ReceiveAsync<T>(System.Func<T, Akka.Actor.IActorContext, System.Threading.Tasks.Task> handler, System.Predicate<T> shouldHandle = null);\nvoid ReceiveAsync<T>(System.Predicate<T> shouldHandle, System.Func<T, Akka.Actor.IActorContext, System.Threading.Tasks.Task> handler);\nvoid UnbecomeStacked();\n```\n\n----------------------------------------\n\nTITLE: Implementing UnboundedDequeMessageQueue in C# for Akka.NET\nDESCRIPTION: An unbounded deque-based message queue implementation that inherits from DequeWrapperMessageQueue. It provides both FIFO and LIFO operations with no capacity constraints.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_107\n\nLANGUAGE: C#\nCODE:\n```\npublic class UnboundedDequeMessageQueue : Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue, Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics, Akka.Dispatch.IUnboundedMessageQueueSemantics\n{\n    public UnboundedDequeMessageQueue() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LWWDictionaryKey Class in C#\nDESCRIPTION: This snippet defines a sealed class `LWWDictionaryKey<TKey, TValue>` that inherits from `Key<LWWDictionary<TKey, TValue>>`. It represents a key specifically for LWWDictionary replicated data types. It includes properties for accessing the key and value types of the dictionary.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\n    public sealed class LWWDictionaryKey<TKey, TValue> : Akka.DistributedData.Key<Akka.DistributedData.LWWDictionary<TKey, TValue>>\n    {\n        public LWWDictionaryKey(string id) { }\n        public System.Type KeyType { get; }\n        public System.Type ValueType { get; }\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Hocon Parser Class Definition in C#\nDESCRIPTION: Class responsible for parsing Hocon configuration strings into object representation, with methods for handling arrays and values within a configuration path.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_80\n\nLANGUAGE: C#\nCODE:\n```\npublic class Parser\n{\n    public Parser() { }\n    public static Akka.Configuration.Hocon.HoconRoot Parse(string text, System.Func<string, Akka.Configuration.Hocon.HoconRoot> includeCallback) { }\n    public Akka.Configuration.Hocon.HoconArray ParseArray(string currentPath) { }\n    public void ParseValue(Akka.Configuration.Hocon.HoconValue owner, string currentPath) { }\n}\n```\n\n----------------------------------------\n\nTITLE: HOCON Configuration for Serilog\nDESCRIPTION: HOCON configuration settings for integrating Serilog with Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/serilog.md#2025-04-16_snippet_5\n\nLANGUAGE: hocon\nCODE:\n```\nakka { \n    loglevel=INFO,\n    loggers=[\"Akka.Logger.Serilog.SerilogLogger, Akka.Logger.Serilog\"]\n    logger-formatter=\"Akka.Logger.Serilog.SerilogLogMessageFormatter, Akka.Logger.Serilog\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ConfigExtensions Class in C#\nDESCRIPTION: This snippet defines the static ConfigExtensions class with methods for checking if a config is null or empty and safely applying fallback configurations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_71\n\nLANGUAGE: C#\nCODE:\n```\npublic class static ConfigExtensions\n{\n    public static bool IsNullOrEmpty(this Akka.Configuration.Config config) { }\n    public static Akka.Configuration.Config SafeWithFallback(this Akka.Configuration.Config config, Akka.Configuration.Config fallback) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ChannelTaskScheduler in C#\nDESCRIPTION: An actor system extension that provides TaskScheduler instances with different priority levels. It implements IExtension and IDisposable, with methods to obtain schedulers based on priority levels: High, Normal, Low, and Idle.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_84\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class ChannelTaskScheduler : Akka.Actor.IExtension, System.IDisposable\n{\n    public ChannelTaskScheduler(Akka.Actor.ExtendedActorSystem system) { }\n    public System.Threading.Tasks.TaskScheduler High { get; }\n    public System.Threading.Tasks.TaskScheduler Idle { get; }\n    public System.Threading.Tasks.TaskScheduler Low { get; }\n    public System.Threading.Tasks.TaskScheduler Normal { get; }\n    public void Dispose() { }\n    public static Akka.Dispatch.ChannelTaskScheduler Get(Akka.Actor.ActorSystem system) { }\n    public System.Threading.Tasks.TaskScheduler GetScheduler(Akka.Dispatch.TaskSchedulerPriority priority) { }\n}\n\npublic sealed class ChannelTaskSchedulerProvider : Akka.Actor.ExtensionIdProvider<Akka.Dispatch.ChannelTaskScheduler>\n{\n    public ChannelTaskSchedulerProvider() { }\n    public override Akka.Dispatch.ChannelTaskScheduler CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BatchingSqlJournal for Akka.NET Persistence in C#\nDESCRIPTION: Defines an abstract base class for batching SQL journal implementation in Akka.NET Persistence. Uses generic type parameters for database connection and command types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.DotNet.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class BatchingSqlJournal<TConnection, TCommand> : Akka.Persistence.Journal.WriteJournalBase\n    where TConnection : System.Data.Common.DbConnection\n    where TCommand : System.Data.Common.DbCommand\n{\n    protected readonly bool CanPublish;\n    protected const int IsDeletedIndex = 3;\n    protected readonly Akka.Event.ILoggingAdapter Log;\n    protected const int ManifestIndex = 4;\n    protected const int OrderingIndex = 7;\n    protected const int PayloadIndex = 5;\n    protected const int PersistenceIdIndex = 0;\n    protected const int SequenceNrIndex = 1;\n    protected const int SerializerIdIndex = 6;\n    // ... (additional members)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Lease Abstract Class in C#\nDESCRIPTION: Abstract base class that defines the core lease management functionality in Akka.NET. It provides methods for acquiring, checking, and releasing leases with support for callback on lease loss.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.Core.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Lease\n{\n    public Lease(Akka.Coordination.LeaseSettings settings) { }\n    public Akka.Coordination.LeaseSettings Settings { get; }\n    public abstract System.Threading.Tasks.Task<bool> Acquire();\n    public abstract System.Threading.Tasks.Task<bool> Acquire(System.Action<System.Exception> leaseLostCallback);\n    public abstract bool CheckLease();\n    public abstract System.Threading.Tasks.Task<bool> Release();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Utility Types for Akka.NET in C#\nDESCRIPTION: Utility singleton types for Akka.NET to represent completion (Done) and placeholder (NotUsed) values. These are commonly used in Akka.NET APIs where a return type is required but no meaningful value needs to be returned.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_112\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka\n{\n    public sealed class Done\n    {\n        public static readonly Akka.Done Instance;\n    }\n    public sealed class NotUsed : System.IComparable<Akka.NotUsed>, System.IEquatable<Akka.NotUsed>\n    {\n        public static readonly Akka.NotUsed Instance;\n        public int CompareTo(Akka.NotUsed other) { }\n        public override bool Equals(object obj) { }\n        public bool Equals(Akka.NotUsed other) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Status Classes for Actor Responses in Akka.NET\nDESCRIPTION: Status classes representing success and failure responses from actors. The Status abstract class serves as a base for Success and Failure subclasses that encapsulate operation results.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_49\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Status\n    {\n        protected Status() { }\n        public sealed class Failure : Akka.Actor.Status\n        {\n            public readonly System.Exception Cause;\n            public readonly object State;\n            public Failure(System.Exception cause) { }\n            public Failure(System.Exception cause, object state) { }\n            public override string ToString() { }\n        }\n        public sealed class Success : Akka.Actor.Status\n        {\n            public static readonly Akka.Actor.Status.Success Instance;\n            public readonly object Status;\n            public Success(object status) { }\n            public override string ToString() { }\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Transforming and Filtering Tweet Stream in Akka.NET\nDESCRIPTION: Demonstrates how to filter a stream of tweets to only retweets and then format them. This shows basic stream operations like Where and Select.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/reactivetweets.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nSource<string, NotUsed> formattedRetweets = tweetSource\n  .Where(tweet => tweet.IsRetweet)\n  .Select(FormatTweet);\n```\n\n----------------------------------------\n\nTITLE: Snapshot Store Interceptor Interface Definition\nDESCRIPTION: Interface definition for implementing custom snapshot store interceptors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistence-testing.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface ISnapshotStoreInterceptor\n{\n    Task InterceptAsync(string persistenceId, SnapshotSelectionCriteria criteria);\n}\n```\n\n----------------------------------------\n\nTITLE: AtLeastOnceDeliveryReceiveActor Class Definition in Akka.Persistence\nDESCRIPTION: Abstract class extending ReceivePersistentActor with at-least-once message delivery semantics, similar to AtLeastOnceDeliveryActor but based on the receive pattern actor model.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AtLeastOnceDeliveryReceiveActor : Akka.Persistence.ReceivePersistentActor\n{\n    protected AtLeastOnceDeliveryReceiveActor() { }\n    protected AtLeastOnceDeliveryReceiveActor(Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings settings) { }\n    protected AtLeastOnceDeliveryReceiveActor(System.Func<Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings, Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings> overrideSettings) { }\n    public int MaxUnconfirmedMessages { get; }\n    public System.TimeSpan RedeliverInterval { get; }\n    public int RedeliveryBurstLimit { get; }\n    public int UnconfirmedCount { get; }\n    public int WarnAfterNumberOfUnconfirmedAttempts { get; }\n    public override void AroundPostStop() { }\n    public override void AroundPreRestart(System.Exception cause, object message) { }\n    protected override bool AroundReceive(Akka.Actor.Receive receive, object message) { }\n    public bool ConfirmDelivery(long deliveryId) { }\n    public void Deliver(Akka.Actor.ActorPath destination, System.Func<long, object> deliveryMessageMapper) { }\n    public void Deliver(Akka.Actor.ActorSelection destination, System.Func<long, object> deliveryMessageMapper) { }\n    public Akka.Persistence.AtLeastOnceDeliverySnapshot GetDeliverySnapshot() { }\n    protected override void OnReplaySuccess() { }\n    public void SetDeliverySnapshot(Akka.Persistence.AtLeastOnceDeliverySnapshot snapshot) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing CircuitBreakerSettings Class in C#\nDESCRIPTION: A sealed class for configuring circuit breaker settings in Akka.NET persistence. It allows specification of max failures, call timeout, and reset timeout parameters to control fault tolerance behavior.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class CircuitBreakerSettings\n{\n    public CircuitBreakerSettings(Akka.Configuration.Config config) { }\n    public CircuitBreakerSettings(int maxFailures, System.TimeSpan callTimeout, System.TimeSpan resetTimeout) { }\n    public System.TimeSpan CallTimeout { get; }\n    public int MaxFailures { get; }\n    public System.TimeSpan ResetTimeout { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TailChoppingGroup Router Configuration in C#\nDESCRIPTION: Defines a router group configuration for the TailChopping routing strategy which uses actor paths instead of creating actors. It specifies time intervals for message forwarding and supports configuration-based initialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_204\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class TailChoppingGroup : Akka.Routing.Group\n    {\n        public TailChoppingGroup(Akka.Configuration.Config config) { }\n        public TailChoppingGroup(System.Collections.Generic.IEnumerable<string> routeePaths, System.TimeSpan within, System.TimeSpan interval) { }\n        public TailChoppingGroup(System.Collections.Generic.IEnumerable<string> routeePaths, System.TimeSpan within, System.TimeSpan interval, string routerDispatcher) { }\n        public System.TimeSpan Interval { get; }\n        public System.TimeSpan Within { get; }\n        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n        public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }\n        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n        public Akka.Routing.TailChoppingGroup WithDispatcher(string dispatcher) { }\n        public class TailChoppingGroupSurrogate : Akka.Util.ISurrogate\n        {\n            public TailChoppingGroupSurrogate() { }\n            public System.TimeSpan Interval { get; set; }\n            public System.Collections.Generic.IEnumerable<string> Paths { get; set; }\n            public string RouterDispatcher { get; set; }\n            public System.TimeSpan Within { get; set; }\n            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: NoDowning Class Definition\nDESCRIPTION: This snippet defines a sealed class `NoDowning` that implements `Akka.Cluster.IDowningProvider`. It represents a downing strategy where no nodes are automatically removed from the cluster. The `DownRemovalMargin` and `DowningActorProps` properties are defined, but the implementation details are not shown.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class NoDowning : Akka.Cluster.IDowningProvider\n{\n    public NoDowning(Akka.Actor.ActorSystem system, Akka.Cluster.Cluster cluster) { }\n    public System.TimeSpan DownRemovalMargin { get; }\n    public Akka.Actor.Props DowningActorProps { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Hyperion Surrogates Programmatically in C#\nDESCRIPTION: Shows how to set up Hyperion serialization surrogates using HyperionSerializerSetup and integrate it with ActorSystem initialization. The code demonstrates creating surrogate mappings between Foo and FooSurrogate types with conversion functions, and applies the configuration during system bootstrap.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/serialization/serialization.md#2025-04-16_snippet_13\n\nLANGUAGE: c#\nCODE:\n```\nvar hyperionSetup = HyperionSerializerSetup.Empty\n    .WithSurrogates(new [] { Surrogate.Create<Foo, FooSurrogate>(\n        foo => new FooSurrogate(foo.Bar), \n        surrogate => new Foo(surrogate.Bar))\n    });\n\nvar bootstrap = BootstrapSetup.Create().And(hyperionSetup);\nvar system = ActorSystem.Create(\"actorSystem\", bootstrap);\n```\n\n----------------------------------------\n\nTITLE: Read Consistency Models Implementation in C#\nDESCRIPTION: Set of classes implementing different read consistency models including ReadAll, ReadFrom, ReadLocal, ReadMajority, and ReadMajorityPlus.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ReadAll : Akka.DistributedData.IReadConsistency, System.IEquatable<Akka.DistributedData.ReadAll>\n{\n    public ReadAll(System.TimeSpan timeout) { }\n    public System.TimeSpan Timeout { get; }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.DistributedData.ReadAll other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Sources Using the Simplified API in Akka.NET (C#)\nDESCRIPTION: This snippet describes how to combine multiple sources into one using the simplified API in Akka.NET. It merges two sources into a single stream and aggregates their values. Akka.NET dependencies and a materializer are necessary for running the combined stream.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithgraphs.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar sourceOne = Source.Single(1);\nvar sourceTwo = Source.Single(2);\nvar merged = Source.Combine(sourceOne, sourceTwo, i => new Merge<int, int>(i));\n\nvar mergedResult = merged.RunWith(Sink.Aggregate<int, int>(0, (agg, i) => agg + i), materializer);\n```\n\n----------------------------------------\n\nTITLE: Creating Sources and Sinks in Akka.NET Streams\nDESCRIPTION: Demonstrates various ways to create sources and sinks using the Akka.NET Streams API. Examples include creating sources from collections, tasks, and single elements, as well as sinks for aggregation, element retrieval, and side effects.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/basics.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// Create a source from an Iterable\nSource.From(new List<int> {1, 2, 3});\n\n// Create a source from a Task\nSource.FromTask(Task.FromResult(\"Hello Streams!\"));\n\n// Create a source from a single element\nSource.Single(\"only one element\")\n\n// an empty source\nSource.Empty<int>();\n\n// Sink that aggregates over the stream and returns a Task\n// of the final result as its materialized value\nSink.Aggregate<int, int>(0, (sum, i) => sum + i);\n\n// Sink that returns a Task as its materialized value,\n// containing the first element of the stream\nSink.First<int>();\n\n// A Sink that consumes a stream without doing anything with the elements\nSink.Ignore<int>();\n\n// A Sink that executes a side-effecting call for every element of the stream\nSink.ForEach<string>(Console.WriteLine);\n```\n\n----------------------------------------\n\nTITLE: Defining the AutoDowning class in Akka.Cluster\nDESCRIPTION: This code defines the `AutoDowning` class, which implements the `IDowningProvider` interface. It's responsible for automatically removing unreachable nodes from the cluster after a specified margin. It depends on `Akka.Actor.ActorSystem` and `Akka.Cluster.Cluster`.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Core.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.Cluster\n{\n    public sealed class AutoDowning : Akka.Cluster.IDowningProvider\n    {\n        public AutoDowning(Akka.Actor.ActorSystem system, Akka.Cluster.Cluster cluster) { }\n        public System.TimeSpan DownRemovalMargin { get; }\n        public Akka.Actor.Props DowningActorProps { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AutoPilot Class in Akka TestKit\nDESCRIPTION: This abstract class defines the AutoPilot concept for automated testing in Akka.NET. It contains static properties for running and no-op configurations and an abstract method for processing actor messages. Dependencies include references to Akka classes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AutoPilot\n{\n    protected AutoPilot() { }\n    public static Akka.TestKit.KeepRunning KeepRunning { get; }\n    public static Akka.TestKit.NoAutoPilot NoAutoPilot { get; }\n    public abstract Akka.TestKit.AutoPilot Run(Akka.Actor.IActorRef sender, object message);\n}\n```\n\n----------------------------------------\n\nTITLE: Problematic Akka.NET Actor Implementation in C#\nDESCRIPTION: Example of incorrect usage of Sender and Self in an asynchronous callback within an Akka.NET actor, which will throw a NotSupportedException at runtime because the actor context is lost.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK1005.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing System.Threading.Tasks;\nusing Akka.Actor;\nusing ThirdPartyApi;\n\nnamespace MyApplication.Actors;\n\npublic sealed class MyActor : ReceiveActor\n{\n    private readonly JobManager _jobManager = new();\n    \n    public MyActor()\n    {\n        ReceiveAsync<string>(async job => {\n            _jobManager.SubmitJobAsync(job, async () => \n            {\n                // This callback will not work\n                Context.Sender.Tell($\"{job} submitted.\", Self);\n            })\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Task Dispatcher Configuration\nDESCRIPTION: Configuration for a custom dispatcher that uses TPL (Task Parallel Library) infrastructure.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/dispatchers.md#2025-04-16_snippet_4\n\nLANGUAGE: hocon\nCODE:\n```\ncustom-task-dispatcher {\n  type = TaskDispatcher\n  throughput = 100\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SmallestMailboxPool in Akka.NET\nDESCRIPTION: Router configuration for SmallestMailbox strategy that creates and manages a pool of actor instances. Routes messages to the actor with the fewest messages in its mailbox for better load balancing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_217\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SmallestMailboxPool : Akka.Routing.Pool\n{\n    public SmallestMailboxPool(Akka.Configuration.Config config) { }\n    public SmallestMailboxPool(int nrOfInstances) { }\n    public SmallestMailboxPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False) { }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Routing.SmallestMailboxPool WithDispatcher(string dispatcher) { }\n    public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n    public Akka.Routing.SmallestMailboxPool WithResizer(Akka.Routing.Resizer resizer) { }\n    public Akka.Routing.SmallestMailboxPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }\n    public class SmallestMailboxPoolSurrogate : Akka.Util.ISurrogate\n    {\n        public SmallestMailboxPoolSurrogate() { }\n        public int NrOfInstances { get; set; }\n        public Akka.Routing.Resizer Resizer { get; set; }\n        public string RouterDispatcher { get; set; }\n        public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }\n        public bool UsePoolDispatcher { get; set; }\n        public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Test Probe for Akka.NET Actor Testing\nDESCRIPTION: A specialized actor reference used for testing actor interactions. TestProbe implements IActorRef and provides additional testing capabilities for verifying actor behavior.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestProbe : Akka.TestKit.TestKitBase, Akka.Actor.IActorRef, Akka.Actor.IActorRefScope, Akka.Actor.ICanTell, Akka.Actor.IInternalActorRef, Akka.TestKit.INoImplicitSender, Akka.Util.ISurrogated, System.IComparable, System.IComparable<Akka.Actor.IActorRef>, System.IEquatable<Akka.Actor.IActorRef>\n{\n    public TestProbe(Akka.Actor.ActorSystem system, Akka.TestKit.ITestKitAssertions assertions, string testProbeName = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Static Get Method for Akka.NET Extensions\nDESCRIPTION: Static method implementation for retrieving an instance of the SQLite persistence extension, following the recommended pattern for Akka.NET extensions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/custom-persistence-provider.md#2025-04-16_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\npublic static SqlitePersistence Get(ActorSystem system)\n{\n    return system.WithExtension<SqlitePersistence, SqlitePersistenceProvider>();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterShardingSettings Class for Configuration in Akka.NET\nDESCRIPTION: A configuration class that holds settings for cluster sharding behavior including remember entities settings, passivation timeout, journal plugins, and lease settings. It implements INoSerializationVerificationNeeded to bypass serialization checks.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n    public sealed class ClusterShardingSettings : Akka.Actor.INoSerializationVerificationNeeded\n    {\n        public readonly Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings CoordinatorSingletonSettings;\n        public readonly string JournalPluginId;\n        public readonly Akka.Coordination.LeaseUsageSettings LeaseSettings;\n        public readonly System.TimeSpan PassivateIdleEntityAfter;\n        public readonly bool RememberEntities;\n        public readonly Akka.Cluster.Sharding.RememberEntitiesStore RememberEntitiesStore;\n        public readonly string Role;\n        public readonly System.TimeSpan ShardRegionQueryTimeout;\n        public readonly string SnapshotPluginId;\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing ActorSystemImpl for Akka.NET Actor System in C#\nDESCRIPTION: This class provides the core implementation of the Akka.NET actor system, including methods for creating actors, managing extensions, and system lifecycle.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_57\n\nLANGUAGE: C#\nCODE:\n```\npublic class ActorSystemImpl : Akka.Actor.ExtendedActorSystem\n{\n    public ActorSystemImpl(string name) { }\n    public ActorSystemImpl(string name, Akka.Configuration.Config config, Akka.Actor.Setup.ActorSystemSetup setup, System.Nullable<Akka.Util.Option<Akka.Actor.Props>> guardianProps = null) { }\n    public override Akka.Actor.ActorProducerPipelineResolver ActorPipelineResolver { get; }\n    public override Akka.Actor.IActorRef DeadLetters { get; }\n    public override Akka.Dispatch.Dispatchers Dispatchers { get; }\n    public override Akka.Event.EventStream EventStream { get; }\n    public override Akka.Actor.IInternalActorRef Guardian { get; }\n    public Akka.Util.Option<Akka.Actor.Props> GuardianProps { get; }\n    public override Akka.Actor.IActorRef IgnoreRef { get; }\n    public override Akka.Event.ILoggingAdapter Log { get; }\n    public override Akka.Actor.IInternalActorRef LookupRoot { get; }\n    public override Akka.Dispatch.Mailboxes Mailboxes { get; }\n    public override string Name { get; }\n    public override Akka.Actor.IActorRefProvider Provider { get; }\n    public override Akka.Actor.IScheduler Scheduler { get; }\n    public override Akka.Serialization.Serialization Serialization { get; }\n    public override Akka.Actor.Settings Settings { get; }\n    public override Akka.Actor.IInternalActorRef SystemGuardian { get; }\n    public override System.Threading.Tasks.Task WhenTerminated { get; }\n    public override void Abort() { }\n    public override Akka.Actor.IActorRef ActorOf(Akka.Actor.Props props, string name = null) { }\n    public override Akka.Actor.ActorSelection ActorSelection(Akka.Actor.ActorPath actorPath) { }\n    public override Akka.Actor.ActorSelection ActorSelection(string actorPath) { }\n    public override object GetExtension(Akka.Actor.IExtensionId extensionId) { }\n    public override T GetExtension<T>()\n        where T :  class, Akka.Actor.IExtension { }\n    public override bool HasExtension(System.Type type) { }\n    public override bool HasExtension<T>()\n        where T :  class, Akka.Actor.IExtension { }\n    public override string PrintTree() { }\n    public override object RegisterExtension(Akka.Actor.IExtensionId extension) { }\n    public override void RegisterOnTermination(System.Action code) { }\n    public void Start() { }\n    public override void Stop(Akka.Actor.IActorRef actor) { }\n    public override Akka.Actor.IActorRef SystemActorOf(Akka.Actor.Props props, string name = null) { }\n    public override Akka.Actor.IActorRef SystemActorOf<TActor>(string name = null)\n        where TActor : Akka.Actor.ActorBase, new () { }\n    public override System.Threading.Tasks.Task Terminate() { }\n    public override string ToString() { }\n    public override bool TryGetExtension(System.Type extensionType, out object extension) { }\n    public override bool TryGetExtension<T>(out T extension)\n        where T :  class, Akka.Actor.IExtension { }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Serilog Configuration with Akka.NET\nDESCRIPTION: Initializing Serilog logger and creating ActorSystem with Serilog configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/serilog.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar logger = new LoggerConfiguration()\n    .WriteTo.Console()\n    .MinimumLevel.Information()\n    .CreateLogger();\n\nSerilog.Log.Logger = logger;\n\nvar system = ActorSystem.Create(\"my-test-system\", \"akka { loglevel=INFO,  loggers=[\\\"Akka.Logger.Serilog.SerilogLogger, Akka.Logger.Serilog\\\"]}\")\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterClientUnreachable Class in C#\nDESCRIPTION: Defines a sealed class ClusterClientUnreachable that implements IClusterClientInteraction interface. It represents a state where a cluster client is unreachable.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterClientUnreachable : Akka.Cluster.Tools.Client.IClusterClientInteraction\n{\n    public ClusterClientUnreachable(Akka.Actor.IActorRef clusterClient) { }\n    public Akka.Actor.IActorRef ClusterClient { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing HoldWithWait GraphStage in Akka.NET\nDESCRIPTION: Alternative GraphStage implementation that waits for the first element before emitting downstream. Handles initial element availability without requiring a default value.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/cookbook.md#2025-04-16_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class HoldWithWait<T> : GraphStage<FlowShape<T, T>>\n{\n    private sealed class Logic : GraphStageLogic\n    {\n        private readonly HoldWithWait<T> _holder;\n        private T _currentValue;\n        private bool _waitingFirstValue = true;\n\n        public Logic(HoldWithWait<T> holder) : base(holder.Shape)\n        {\n            _holder = holder;\n\n            SetHandler(holder.In, onPush: () =>\n            {\n                _currentValue = Grab(holder.In);\n                if (_waitingFirstValue)\n                {\n                    _waitingFirstValue = false;\n                    if(IsAvailable(holder.Out))\n                        Push(holder.Out, _currentValue);\n                }\n                Pull(holder.In);\n            });\n\n            SetHandler(holder.Out, onPull: () =>\n            {\n                if(!_waitingFirstValue)\n                    Push(holder.Out, _currentValue);\n            });\n        }\n\n        public override void PreStart() => Pull(_holder.In);\n    }\n    \n    public HoldWithWait()\n    {\n        Shape = new FlowShape<T, T>(In, Out);\n    }\n\n    public Inlet<T> In { get; } = new Inlet<T>(\"HoldWithWait.in\");\n\n    public Outlet<T> Out { get; } = new Outlet<T>(\"HoldWithWait.out\");\n\n    public override FlowShape<T, T> Shape { get; }\n\n    protected override GraphStageLogic CreateLogic(Attributes inheritedAttributes) => new Logic(this);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Push-Based Communication with ShardedDaemonProcess in C#\nDESCRIPTION: This code snippet shows how to use push-based communication with ShardedDaemonProcess. It initializes the process and returns an IActorRef that can be used to send messages to the worker instances in a round-robin fashion.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-sharded-daemon-process.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar shardedDaemon = ShardedDaemonProcess.Get(system);\nvar proxy = shardedDaemon.Init<Command>(\n    \"daemon\",\n    numberOfInstances,\n    id => Props.Create(() => new Worker(id)),\n    ShardedDaemonProcessSettings.Create(system),\n    new MessageExtractor());\n```\n\n----------------------------------------\n\nTITLE: Defining IPersistenceStash Interface\nDESCRIPTION: This snippet defines the `IPersistenceStash` interface, which combines stash functionality with persistence features in Akka. It inherits from standard Akka stash interfaces (`IActorStash`, `IWithUnboundedStash`, `IWithUnrestrictedStash`) and requires a message queue (`IRequiresMessageQueue`). Additionally, it includes a property for an internal stash overflow strategy (`InternalStashOverflowStrategy`).\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\n\"public interface IPersistenceStash : Akka.Actor.IActorStash, Akka.Actor.IWithUnboundedStash, Akka.Actor.IWithUnrestrictedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics>\n    {\n        Akka.Persistence.IStashOverflowStrategy InternalStashOverflowStrategy { get; }\n    }\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Failure Injection Transport Adapter in C#\nDESCRIPTION: Defines a transport adapter that can inject failures into network communications for testing purposes. Includes functionality for dropping messages and managing associations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic class FailureInjectorTransportAdapter : Akka.Remote.Transport.AbstractTransportAdapter, Akka.Remote.Transport.IAssociationEventListener\n{\n    public readonly Akka.Actor.ExtendedActorSystem ExtendedActorSystem;\n    public const string FailureInjectorSchemeIdentifier = \"gremlin\";\n    protected int MaximumOverhead;\n    public FailureInjectorTransportAdapter(Akka.Remote.Transport.Transport wrappedTransport, Akka.Actor.ExtendedActorSystem extendedActorSystem) { }\n    protected override Akka.Remote.Transport.SchemeAugmenter SchemeAugmenter { get; }\n    protected override void InterceptAssociate(Akka.Actor.Address remoteAddress, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.AssociationHandle> statusPromise) { }\n    protected override System.Threading.Tasks.Task<Akka.Remote.Transport.IAssociationEventListener> InterceptListen(Akka.Actor.Address listenAddress, System.Threading.Tasks.Task<Akka.Remote.Transport.IAssociationEventListener> listenerTask) { }\n    public override System.Threading.Tasks.Task<bool> ManagementCommand(object message) { }\n    public void Notify(Akka.Remote.Transport.IAssociationEvent ev) { }\n    public bool ShouldDropInbound(Akka.Actor.Address remoteAddress, object instance, string debugMessage) { }\n    public bool ShouldDropOutbound(Akka.Actor.Address remoteAddress, object instance, string debugMessage) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Extension Methods for ILoggingAdapter in Akka.NET\nDESCRIPTION: Defines extension methods for error logging with various generic type parameters. These methods extend ILoggingAdapter to provide strongly-typed logging capabilities with format strings and exception causes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_135\n\nLANGUAGE: C#\nCODE:\n```\npublic static void Error<T1, T2>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2) { }\npublic static void Error<T1, T2>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2) { }\npublic static void Error<T1, T2, T3>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3) { }\npublic static void Error<T1, T2, T3>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3) { }\npublic static void Error<T1, T2, T3, T4>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4) { }\npublic static void Error<T1, T2, T3, T4>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4) { }\npublic static void Error<T1, T2, T3, T4, T5>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) { }\npublic static void Error<T1, T2, T3, T4, T5>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) { }\npublic static void Error<T1, T2, T3, T4, T5, T6>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) { }\npublic static void Error<T1, T2, T3, T4, T5, T6>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) { }\npublic static void Error(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, object[] args) { }\npublic static void Error(this Akka.Event.ILoggingAdapter log, string format, object[] args) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ORMultiValueDictionary Class for Akka.NET Distributed Data in C#\nDESCRIPTION: Defines the ORMultiValueDictionary class, an observed-remove multi-value dictionary for distributed data. It includes properties for accessing dictionary contents and delta operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ORMultiValueDictionary<TKey, TValue> : Akka.DistributedData.IDeltaReplicatedData, Akka.DistributedData.IDeltaReplicatedData<Akka.DistributedData.ORMultiValueDictionary<TKey, TValue>, Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.ORSet<TValue>>.IDeltaOperation>, Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IRemovedNodePruning<Akka.DistributedData.ORMultiValueDictionary<TKey, TValue>>, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.ORMultiValueDictionary<TKey, TValue>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, System.Collections.Immutable.IImmutableSet<TValue>>>, System.Collections.IEnumerable, System.IEquatable<Akka.DistributedData.ORMultiValueDictionary<TKey, TValue>>\n{\n    public static readonly Akka.DistributedData.ORMultiValueDictionary<TKey, TValue> Empty;\n    public static readonly Akka.DistributedData.ORMultiValueDictionary<TKey, TValue> EmptyWithValueDeltas;\n    public int Count { get; }\n    public Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.ORSet<TValue>>.IDeltaOperation Delta { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SqlReadJournal in Akka.NET C#\nDESCRIPTION: The SqlReadJournal class implements multiple interfaces for querying events in Akka.NET using SQL databases. It provides methods such as AllEvents, CurrentAllEvents, CurrentEventsByPersistenceId, and others for streaming event data, requiring an Akka actor system and configuration. This class is primarily used to query persisted events based on different criteria like tags and persistence IDs.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommonQuery.DotNet.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.Persistence.Query.Sql\n{\n    public class SqlReadJournal : Akka.Persistence.Query.IAllEventsQuery, Akka.Persistence.Query.ICurrentAllEventsQuery, Akka.Persistence.Query.ICurrentEventsByPersistenceIdQuery, Akka.Persistence.Query.ICurrentEventsByTagQuery, Akka.Persistence.Query.ICurrentPersistenceIdsQuery, Akka.Persistence.Query.IEventsByPersistenceIdQuery, Akka.Persistence.Query.IEventsByTagQuery, Akka.Persistence.Query.IPersistenceIdsQuery, Akka.Persistence.Query.IReadJournal\n    {\n        public const string Identifier = \"akka.persistence.query.journal.sql\";\n        public SqlReadJournal(Akka.Actor.ExtendedActorSystem system, Akka.Configuration.Config config) { }\n        public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> AllEvents(Akka.Persistence.Query.Offset offset = null) { }\n        public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentAllEvents(Akka.Persistence.Query.Offset offset) { }\n        public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentEventsByPersistenceId(string persistenceId, long fromSequenceNr, long toSequenceNr) { }\n        public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentEventsByTag(string tag, Akka.Persistence.Query.Offset offset = null) { }\n        public Akka.Streams.Dsl.Source<string, Akka.NotUsed> CurrentPersistenceIds() { }\n        public static Akka.Configuration.Config DefaultConfiguration() { }\n        public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> EventsByPersistenceId(string persistenceId, long fromSequenceNr, long toSequenceNr) { }\n        public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> EventsByTag(string tag, Akka.Persistence.Query.Offset offset = null) { }\n        public Akka.Streams.Dsl.Source<string, Akka.NotUsed> PersistenceIds() { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Thread-Local Random Generator in C#\nDESCRIPTION: Provides a ThreadLocalRandom static class with a thread-safe random number generator. This helps prevent concurrency issues with System.Random across multiple threads in the actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_256\n\nLANGUAGE: C#\nCODE:\n```\npublic class static ThreadLocalRandom\n{\n    public static System.Random Current { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Cluster Singleton Instances in C#\nDESCRIPTION: The code defines several classes and interfaces for managing cluster singleton instances in an Akka.NET environment. Key functionalities include initialization, proxy and manager settings, state management, and custom exception handling. Dependencies include Akka.Actor and Akka.Cluster.Tools.Singleton namespaces.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Core.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic ClusterSingleton(Akka.Actor.ExtendedActorSystem system) { }\npublic static Akka.Cluster.Tools.Singleton.ClusterSingleton Get(Akka.Actor.ActorSystem system) { }\npublic Akka.Actor.IActorRef Init(Akka.Cluster.Tools.Singleton.SingletonActor singleton) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterSingletonManager : Akka.Actor.FSM<Akka.Cluster.Tools.Singleton.ClusterSingletonState, Akka.Cluster.Tools.Singleton.IClusterSingletonData>\n{\n    public ClusterSingletonManager(Akka.Actor.Props singletonProps, object terminationMessage, Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings settings) { }\n    public static Akka.Configuration.Config DefaultConfig() { }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n    public static Akka.Actor.Props Props(Akka.Actor.Props singletonProps, Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings settings) { }\n    public static Akka.Actor.Props Props(Akka.Actor.Props singletonProps, object terminationMessage, Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings settings) { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterSingletonManagerIsStuckException : Akka.Actor.AkkaException\n{\n    public ClusterSingletonManagerIsStuckException(string message) { }\n    public ClusterSingletonManagerIsStuckException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterSingletonManagerSettings : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public ClusterSingletonManagerSettings(string singletonName, string role, System.TimeSpan removalMargin, System.TimeSpan handOverRetryInterval, bool considerAppVersion) { }\n    public ClusterSingletonManagerSettings(string singletonName, string role, System.TimeSpan removalMargin, System.TimeSpan handOverRetryInterval, Akka.Coordination.LeaseUsageSettings leaseSettings, bool considerAppVersion) { }\n    public bool ConsiderAppVersion { get; }\n    public System.TimeSpan HandOverRetryInterval { get; }\n    public Akka.Coordination.LeaseUsageSettings LeaseSettings { get; }\n    public System.TimeSpan RemovalMargin { get; }\n    public string Role { get; }\n    public string SingletonName { get; }\n    public static Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings Create(Akka.Actor.ActorSystem system) { }\n    public static Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings Create(Akka.Configuration.Config config) { }\n    public Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings WithHandOverRetryInterval(System.TimeSpan handOverRetryInterval) { }\n    public Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings WithLeaseSettings(Akka.Coordination.LeaseUsageSettings leaseSettings) { }\n    public Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings WithRemovalMargin(System.TimeSpan removalMargin) { }\n    public Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings WithRole(string role) { }\n    public Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings WithSingletonName(string singletonName) { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterSingletonProvider : Akka.Actor.ExtensionIdProvider<Akka.Cluster.Tools.Singleton.ClusterSingleton>\n{\n    public ClusterSingletonProvider() { }\n    public override Akka.Cluster.Tools.Singleton.ClusterSingleton CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterSingletonProxy : Akka.Actor.ReceiveActor\n{\n    public ClusterSingletonProxy(string singletonManagerPath, Akka.Cluster.Tools.Singleton.ClusterSingletonProxySettings settings) { }\n    public static Akka.Configuration.Config DefaultConfig() { }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n    public static Akka.Actor.Props Props(string singletonManagerPath, Akka.Cluster.Tools.Singleton.ClusterSingletonProxySettings settings) { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterSingletonProxySettings : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public ClusterSingletonProxySettings(string singletonName, string role, System.TimeSpan singletonIdentificationInterval, int bufferSize, bool considerAppVersion) { }\n    public int BufferSize { get; }\n    public bool ConsiderAppVersion { get; }\n    public string Role { get; }\n    public System.TimeSpan SingletonIdentificationInterval { get; }\n    public string SingletonName { get; }\n    public static Akka.Cluster.Tools.Singleton.ClusterSingletonProxySettings Create(Akka.Actor.ActorSystem system) { }\n    public static Akka.Cluster.Tools.Singleton.ClusterSingletonProxySettings Create(Akka.Configuration.Config config, bool considerAppVersion) { }\n    public Akka.Cluster.Tools.Singleton.ClusterSingletonProxySettings WithBufferSize(int bufferSize) { }\n    public Akka.Cluster.Tools.Singleton.ClusterSingletonProxySettings WithRole(string role) { }\n    public Akka.Cluster.Tools.Singleton.ClusterSingletonProxySettings WithSingletonIdentificationInterval(System.TimeSpan singletonIdentificationInterval) { }\n    public Akka.Cluster.Tools.Singleton.ClusterSingletonProxySettings WithSingletonName(string singletonName) { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterSingletonSettings : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public int BufferSize { get; }\n    public bool ConsiderAppVersion { get; }\n    public System.TimeSpan HandOverRetryInterval { get; }\n    public Akka.Coordination.LeaseUsageSettings LeaseSettings { get; }\n    public System.TimeSpan RemovalMargin { get; }\n    public string Role { get; }\n    public System.TimeSpan SingletonIdentificationInterval { get; }\n    public static Akka.Cluster.Tools.Singleton.ClusterSingletonSettings Create(Akka.Actor.ActorSystem system) { }\n    public static Akka.Cluster.Tools.Singleton.ClusterSingletonSettings Create(Akka.Configuration.Config config) { }\n    public override string ToString() { }\n    public Akka.Cluster.Tools.Singleton.ClusterSingletonSettings WithHandOverRetryInterval(System.TimeSpan handOverRetryInterval) { }\n    public Akka.Cluster.Tools.Singleton.ClusterSingletonSettings WithLeaseSettings(Akka.Coordination.LeaseUsageSettings leaseSettings) { }\n    public Akka.Cluster.Tools.Singleton.ClusterSingletonSettings WithRemovalMargin(System.TimeSpan removalMargin) { }\n    public Akka.Cluster.Tools.Singleton.ClusterSingletonSettings WithRole(string role) { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic enum ClusterSingletonState\n{\n    Start = 0,\n    AcquiringLease = 1,\n    Oldest = 2,\n    Younger = 3,\n    BecomingOldest = 4,\n    WasOldest = 5,\n    HandingOver = 6,\n    TakeOver = 7,\n    Stopping = 8,\n    End = 9,\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IClusterSingletonData { }\npublic interface IClusterSingletonMessage { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class SingletonActor\n{\n    public string Name { get; }\n    public Akka.Actor.Props Props { get; }\n    public Akka.Util.Option<Akka.Cluster.Tools.Singleton.ClusterSingletonSettings> Settings { get; }\n    public Akka.Util.Option<object> StopMessage { get; }\n    public static Akka.Cluster.Tools.Singleton.SingletonActor Create(Akka.Actor.Props props, string name) { }\n    public Akka.Cluster.Tools.Singleton.SingletonActor WithProps(Akka.Actor.Props props) { }\n    public Akka.Cluster.Tools.Singleton.SingletonActor WithSettings(Akka.Cluster.Tools.Singleton.ClusterSingletonSettings settings) { }\n    public Akka.Cluster.Tools.Singleton.SingletonActor WithStopMessage(object stopMessage) { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterSingletonMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public ClusterSingletonMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object o) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Stream Elements with Bounded Collection in C#\nDESCRIPTION: Shows how to safely collect stream elements into a bounded collection using Sink.Seq with Limit or Take operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/cookbook.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar MAX_ALLOWED_SIZE = 100;\n\n// OK. Task will fail with a `StreamLimitReachedException`\n// if the number of incoming elements is larger than max\nvar limited = mySource.Limit(MAX_ALLOWED_SIZE).RunWith(Sink.Seq<string>(), materializer);\n\n// OK. Collect up until max-th elements only, then cancel upstream\nvar ignoreOverflow = mySource.Take(MAX_ALLOWED_SIZE).RunWith(Sink.Seq<string>(), materializer);\n```\n\n----------------------------------------\n\nTITLE: C# Local Actor Implementation\nDESCRIPTION: LocalActorRef and LocalActorRefProvider classes that implement local actor functionality including creation, message dispatch, and lifecycle management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\npublic class LocalActorRef : Akka.Actor.ActorRefWithCell, Akka.Actor.IActorRefScope\n{\n    public LocalActorRef(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.Props props, Akka.Dispatch.MessageDispatcher dispatcher, Akka.Dispatch.MailboxType mailboxType, Akka.Actor.IInternalActorRef supervisor, Akka.Actor.ActorPath path) { }\n    public Akka.Actor.ActorCell Cell { get; }\n    public override System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> Children { get; }\n    public override bool IsLocal { get; }\n    public override bool IsTerminated { get; }\n    public override Akka.Actor.IInternalActorRef Parent { get; }\n    public override Akka.Actor.ActorPath Path { get; }\n    public override Akka.Actor.IActorRefProvider Provider { get; }\n    public override Akka.Actor.ICell Underlying { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom GraphStage Source in Akka.NET Streams\nDESCRIPTION: Demonstrates how to use the custom NumbersSource by converting it to a proper Source and running stream operations. Shows aggregation examples with different stream lengths.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/custom-stream-processing.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n// A GraphStage is a proper Graph, just like what GraphDSL.Create would return\nvar sourceGraph = new NumbersSource();\n\n// Create a Source from the Graph to access the DSL\nvar mySource = Source.FromGraph(sourceGraph);\n\n// Returns 55\nvar result1Task = mySource.Take(10).RunAggregate(0, (sum, next) => sum + next, materializer);\n\n// Returns 5050\nvar result2Task = mySource.Take(100).RunAggregate(0, (sum, next) => sum + next, materializer);\n```\n\n----------------------------------------\n\nTITLE: Implementing GSet Class in Akka.NET DistributedData (C#)\nDESCRIPTION: Defines the GSet (Grow-only Set) class, which is a distributed set that only allows additions. It implements various interfaces for replication, delta updates, and enumeration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class GSet<T> : Akka.DistributedData.FastMerge<Akka.DistributedData.GSet<T>>, Akka.DistributedData.IDeltaReplicatedData, Akka.DistributedData.IDeltaReplicatedData<Akka.DistributedData.GSet<T>, Akka.DistributedData.GSet<T>>, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.GSet<T>>, Akka.DistributedData.IReplicatedDelta, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.IEquatable<Akka.DistributedData.GSet<T>>\n{\n    public static readonly Akka.DistributedData.GSet<T> Empty;\n    public GSet() { }\n    public GSet(System.Collections.Immutable.IImmutableSet<T> elements) { }\n    public GSet(System.Collections.Immutable.IImmutableSet<T> elements, Akka.DistributedData.GSet<T> delta) { }\n    public int Count { get; }\n    public Akka.DistributedData.GSet<T> Delta { get; }\n    public System.Collections.Immutable.IImmutableSet<T> Elements { get; }\n    public bool IsEmpty { get; }\n    public System.Type SetType { get; }\n    public Akka.DistributedData.GSet<T> Add(T element) { }\n    public bool Contains(T element) { }\n    public bool Equals(Akka.DistributedData.GSet<T> other) { }\n    public override bool Equals(object obj) { }\n    public System.Collections.Generic.IEnumerator<T> GetEnumerator() { }\n    public override int GetHashCode() { }\n    public override Akka.DistributedData.GSet<T> Merge(Akka.DistributedData.GSet<T> other) { }\n    public Akka.DistributedData.GSet<T> MergeDelta(Akka.DistributedData.GSet<T> delta) { }\n    public Akka.DistributedData.GSet<T> ResetDelta() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SQL Snapshot Store Base Class in C#\nDESCRIPTION: Abstract base class for SQL-based snapshot storage implementation in Akka.NET. Provides core functionality for saving, loading, and deleting snapshots with SQL database integration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Core.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class SqlSnapshotStore : Akka.Persistence.Snapshot.SnapshotStore, Akka.Actor.IActorStash, Akka.Actor.IWithUnboundedStash, Akka.Actor.IWithUnrestrictedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics>\n{\n    protected SqlSnapshotStore(Akka.Configuration.Config config) { }\n    protected Akka.Event.ILoggingAdapter Log { get; }\n    public abstract Akka.Persistence.Sql.Common.Snapshot.ISnapshotQueryExecutor QueryExecutor { get; }\n    public Akka.Actor.IStash Stash { get; set; }\n    protected abstract System.Data.Common.DbConnection CreateDbConnection(string connectionString);\n    public System.Data.Common.DbConnection CreateDbConnection() { }\n    protected override System.Threading.Tasks.Task DeleteAsync(Akka.Persistence.SnapshotMetadata metadata) { }\n    protected override System.Threading.Tasks.Task DeleteAsync(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria) { }\n    protected virtual string GetConnectionString() { }\n    protected override System.Threading.Tasks.Task<Akka.Persistence.SelectedSnapshot> LoadAsync(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria) { }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n    protected override System.Threading.Tasks.Task SaveAsync(Akka.Persistence.SnapshotMetadata metadata, object snapshot) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TuningParameters Class for Akka.NET Cluster Sharding\nDESCRIPTION: Defines configuration parameters and methods for tuning Akka.NET cluster sharding behavior. Includes timeout settings, recovery strategies, and allocation limits with fluent interface for parameter modification.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\npublic readonly int CoordinatorStateWriteMajorityPlus;\npublic readonly System.TimeSpan EntityRecoveryConstantRateStrategyFrequency;\npublic readonly int EntityRecoveryConstantRateStrategyNumberOfEntities;\npublic readonly string EntityRecoveryStrategy;\npublic readonly System.TimeSpan EntityRestartBackoff;\n// ... additional parameters\n\npublic TuningParameters(\n    System.TimeSpan coordinatorFailureBackoff,\n    System.TimeSpan retryInterval,\n    int bufferSize,\n    // ... additional parameters\n) { }\n```\n\n----------------------------------------\n\nTITLE: LeaseSettings Class Definition in C#\nDESCRIPTION: Defines the configuration settings for a lease, including lease name, owner, timeout settings, and lease-specific configuration. Provides factory methods and immutable modification capabilities.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.DotNet.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class LeaseSettings\n{\n    public LeaseSettings(string leaseName, string ownerName, Akka.Coordination.TimeoutSettings timeoutSettings, Akka.Configuration.Config leaseConfig) { }\n    public Akka.Configuration.Config LeaseConfig { get; }\n    public string LeaseName { get; }\n    public string OwnerName { get; }\n    public Akka.Coordination.TimeoutSettings TimeoutSettings { get; }\n    public static Akka.Coordination.LeaseSettings Create(Akka.Configuration.Config config, string leaseName, string ownerName) { }\n    public override string ToString() { }\n    public Akka.Coordination.LeaseSettings WithTimeoutSettings(Akka.Coordination.TimeoutSettings timeoutSettings) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TestScheduler for Akka.NET Time Control\nDESCRIPTION: The TestScheduler class provides methods for controlling time in Akka.NET tests. It allows advancing time and scheduling actions at specific intervals.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestScheduler : Akka.Actor.IActionScheduler, Akka.Actor.IAdvancedScheduler, Akka.Actor.IRunnableScheduler, Akka.Actor.IScheduler, Akka.Actor.ITellScheduler, Akka.Actor.ITimeProvider\n{\n    public TestScheduler(Akka.Configuration.Config schedulerConfig, Akka.Event.ILoggingAdapter log) { }\n    public Akka.Actor.IAdvancedScheduler Advanced { get; }\n    public System.TimeSpan HighResMonotonicClock { get; }\n    public System.TimeSpan MonotonicClock { get; }\n    public System.DateTimeOffset Now { get; }\n    protected System.DateTimeOffset TimeNow { get; }\n    public void Advance(System.TimeSpan offset) { }\n    public void AdvanceTo(System.DateTimeOffset when) { }\n    public void ScheduleOnce(System.TimeSpan delay, System.Action action, Akka.Actor.ICancelable cancelable) { }\n    public void ScheduleOnce(System.TimeSpan delay, System.Action action) { }\n    public void ScheduleOnce(System.TimeSpan delay, Akka.Dispatch.IRunnable action, Akka.Actor.ICancelable cancelable) { }\n    public void ScheduleOnce(System.TimeSpan delay, Akka.Dispatch.IRunnable action) { }\n    public void ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action, Akka.Actor.ICancelable cancelable) { }\n    public void ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action) { }\n    public void ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Dispatch.IRunnable action, Akka.Actor.ICancelable cancelable) { }\n    public void ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Dispatch.IRunnable action) { }\n    public void ScheduleTellOnce(System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender) { }\n    public void ScheduleTellOnce(System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable) { }\n    public void ScheduleTellRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender) { }\n    public void ScheduleTellRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Dispatcher Types in C#\nDESCRIPTION: Defines various dispatcher types including CurrentSynchronizationContextDispatcher, DefaultDispatcherPrerequisites, and Dispatcher. These classes handle message dispatching and execution within the Akka.NET framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_97\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class CurrentSynchronizationContextDispatcher : Akka.Dispatch.Dispatcher\n{\n    public CurrentSynchronizationContextDispatcher(Akka.Dispatch.MessageDispatcherConfigurator configurator, string id, int throughput, System.Nullable<long> throughputDeadlineTime, Akka.Dispatch.ExecutorServiceFactory executorServiceFactory, System.TimeSpan shutdownTimeout) { }\n}\npublic sealed class DefaultDispatcherPrerequisites : Akka.Dispatch.IDispatcherPrerequisites\n{\n    public DefaultDispatcherPrerequisites(Akka.Event.EventStream eventStream, Akka.Actor.IScheduler scheduler, Akka.Actor.Settings settings, Akka.Dispatch.Mailboxes mailboxes) { }\n    public Akka.Event.EventStream EventStream { get; }\n    public Akka.Dispatch.Mailboxes Mailboxes { get; }\n    public Akka.Actor.IScheduler Scheduler { get; }\n    public Akka.Actor.Settings Settings { get; }\n}\npublic class Dispatcher : Akka.Dispatch.MessageDispatcher\n{\n    public Dispatcher(Akka.Dispatch.MessageDispatcherConfigurator configurator, string id, int throughput, System.Nullable<long> throughputDeadlineTime, Akka.Dispatch.ExecutorServiceFactory executorServiceFactory, System.TimeSpan shutdownTimeout) { }\n    protected override void ExecuteTask(Akka.Dispatch.IRunnable run) { }\n    [Akka.Annotations.InternalApiAttribute()]\n    protected override void Shutdown() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Receiving Messages Asynchronously in Akka.NET TestKit\nDESCRIPTION: Methods for asynchronously receiving messages from actors with various timeout options. These methods enable testing actor message patterns with control over timing constraints and cancellation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic System.Collections.Generic.IAsyncEnumerable<object> ReceiveNAsync(int numberOfMessages, System.TimeSpan max, [System.Runtime.CompilerServices.EnumeratorCancellationAttribute()] System.Threading.CancellationToken cancellationToken = null) { }\npublic object ReceiveOne(System.Nullable<System.TimeSpan> max = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.ValueTask<object> ReceiveOneAsync(System.Nullable<System.TimeSpan> max = null, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Customizing Recovery with SnapshotSelectionCriteria in C#\nDESCRIPTION: This example demonstrates how to customize the recovery process by skipping snapshot loading and replaying all events using SnapshotSelectionCriteria.None.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/event-sourcing.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic override Recovery Recovery => new Recovery(fromSnapshot: SnapshotSelectionCriteria.None)\n```\n\n----------------------------------------\n\nTITLE: Message Inspection in Akka.NET TestKit\nDESCRIPTION: Methods for non-destructively checking messages in actor mailboxes. These methods allow peeking at messages without removing them, with both synchronous and asynchronous variants.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\npublic bool TryPeekOne(out Akka.TestKit.MessageEnvelope envelope, System.Nullable<System.TimeSpan> max, System.Threading.CancellationToken cancellationToken) { }\n[return: System.Runtime.CompilerServices.TupleElementNamesAttribute(new string[] {\n        \"success\",\n        \"envelope\"})]\npublic System.Threading.Tasks.ValueTask<System.ValueTuple<bool, Akka.TestKit.MessageEnvelope>> TryPeekOneAsync(System.Nullable<System.TimeSpan> max, System.Threading.CancellationToken cancellationToken) { }\npublic bool TryReceiveOne(out Akka.TestKit.MessageEnvelope envelope, System.Nullable<System.TimeSpan> max = null, System.Threading.CancellationToken cancellationToken = null) { }\n[return: System.Runtime.CompilerServices.TupleElementNamesAttribute(new string[] {\n        \"success\",\n        \"envelope\"})]\npublic System.Threading.Tasks.ValueTask<System.ValueTuple<bool, Akka.TestKit.MessageEnvelope>> TryReceiveOneAsync(System.Nullable<System.TimeSpan> max, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterRouterGroup Class in C#\nDESCRIPTION: Defines a ClusterRouterGroup class that extends Akka.Routing.Group. This class is responsible for managing routing in a cluster environment, including creating routers and handling management messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Core.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterRouterGroup : Akka.Routing.Group\n{\n    public ClusterRouterGroup(Akka.Routing.Group local, Akka.Cluster.Routing.ClusterRouterGroupSettings settings) { }\n    public Akka.Routing.Group Local { get; }\n    public override string RouterDispatcher { get; }\n    public Akka.Cluster.Routing.ClusterRouterGroupSettings Settings { get; }\n    public override bool StopRouterWhenAllRouteesRemoved { get; }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override Akka.Actor.ActorBase CreateRouterActor() { }\n    public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }\n    public override bool IsManagementMessage(object message) { }\n    public override Akka.Actor.Props RoutingLogicController(Akka.Routing.RoutingLogic routingLogic) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Write Consistency Classes in C# for Akka.NET Distributed Data\nDESCRIPTION: This snippet defines several sealed classes implementing IWriteConsistency interface, each representing different write consistency models for Akka.NET Distributed Data. These classes include WriteAll, WriteLocal, WriteMajority, WriteMajorityPlus, and WriteTo, each with their specific properties and methods.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_51\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class WriteAll : Akka.DistributedData.IWriteConsistency, System.IEquatable<Akka.DistributedData.WriteAll>\n{\n    public WriteAll(System.TimeSpan timeout) { }\n    public System.TimeSpan Timeout { get; }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.DistributedData.WriteAll other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n\npublic sealed class WriteLocal : Akka.DistributedData.IWriteConsistency\n{\n    public static readonly Akka.DistributedData.WriteLocal Instance;\n    public System.TimeSpan Timeout { get; }\n    public override bool Equals(object obj) { }\n    public override string ToString() { }\n}\n\npublic sealed class WriteMajority : Akka.DistributedData.IWriteConsistency, System.IEquatable<Akka.DistributedData.WriteMajority>\n{\n    public WriteMajority(System.TimeSpan timeout, int minCapacity = 0) { }\n    public int MinCapacity { get; }\n    public System.TimeSpan Timeout { get; }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.DistributedData.WriteMajority other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n\npublic sealed class WriteMajorityPlus : Akka.DistributedData.IWriteConsistency, System.IEquatable<Akka.DistributedData.WriteMajorityPlus>\n{\n    public WriteMajorityPlus(System.TimeSpan timeout, int additional, int minCapacity = 0) { }\n    public int Additional { get; }\n    public int MinCapacity { get; }\n    public System.TimeSpan Timeout { get; }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.DistributedData.WriteMajorityPlus other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n\npublic sealed class WriteTo : Akka.DistributedData.IWriteConsistency, System.IEquatable<Akka.DistributedData.WriteTo>\n{\n    public WriteTo(int count, System.TimeSpan timeout) { }\n    public int Count { get; }\n    public System.TimeSpan Timeout { get; }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.DistributedData.WriteTo other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Index<TKey, TValue> Collection in C#\nDESCRIPTION: A generic multi-map collection that maps keys to collections of comparable values. Provides methods for adding, removing, and querying values by key with support for predicates.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_241\n\nLANGUAGE: C#\nCODE:\n```\npublic class Index<TKey, TValue>\n    where TValue : System.IComparable<TValue>\n{\n    public Index() { }\n    public bool IsEmpty { get; }\n    public System.Collections.Generic.IEnumerable<TValue> this[TKey index] { get; }\n    public System.Collections.Generic.ICollection<TKey> Keys { get; }\n    public System.Collections.Generic.HashSet<TValue> Values { get; }\n    public void Clear() { }\n    public TValue FindValue(TKey key, System.Func<TValue, bool> predicate) { }\n    public void ForEach(System.Action<TKey, TValue> fun) { }\n    public bool Put(TKey key, TValue value) { }\n    public bool Remove(TKey key, TValue value) { }\n    public System.Collections.Generic.IEnumerable<TValue> Remove(TKey key) { }\n    public void RemoveValue(TValue value) { }\n}\n```\n\n----------------------------------------\n\nTITLE: SystemMessage Base Class Implementation in Akka.NET\nDESCRIPTION: Abstract base class for all system messages in Akka.NET. Implements INoSerializationVerificationNeeded and ISystemMessage, providing basic functionality for unlinking messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_93\n\nLANGUAGE: csharp\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic abstract class SystemMessage : Akka.Actor.INoSerializationVerificationNeeded, Akka.Dispatch.SysMsg.ISystemMessage\n{\n    protected SystemMessage() { }\n    public bool Unlinked { get; }\n    public void Unlink() { }\n}\n```\n\n----------------------------------------\n\nTITLE: TimeoutSettings Class Definition in C#\nDESCRIPTION: Defines timeout-related settings for lease operations including heartbeat interval, heartbeat timeout, and operation timeout. Provides factory methods and immutable modification capabilities.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class TimeoutSettings\n{\n    public TimeoutSettings(System.TimeSpan heartbeatInterval, System.TimeSpan heartbeatTimeout, System.TimeSpan operationTimeout) { }\n    public System.TimeSpan HeartbeatInterval { get; }\n    public System.TimeSpan HeartbeatTimeout { get; }\n    public System.TimeSpan OperationTimeout { get; }\n    public static Akka.Coordination.TimeoutSettings Create(Akka.Configuration.Config config) { }\n    public override string ToString() { }\n    public Akka.Coordination.TimeoutSettings WithHeartbeatInterval(System.TimeSpan heartbeatInterval) { }\n    public Akka.Coordination.TimeoutSettings WithHeartbeatTimeout(System.TimeSpan heartbeatTimeout) { }\n    public Akka.Coordination.TimeoutSettings withOperationTimeout(System.TimeSpan operationTimeout) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Capacity Metrics Selector for Akka.Cluster Metrics\nDESCRIPTION: The snippet describes a CapacityMetricsSelector abstract class used to select metrics for load balancing within Akka.Cluster. This class uses metrics to compute capacities and weights of nodes, affecting routing decisions. It relies on Akka.Cluster.Metrics and immutable collections for its operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.DotNet.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class CapacityMetricsSelector : Akka.Cluster.Metrics.IMetricsSelector\n{\n    protected CapacityMetricsSelector() { }\n    public abstract System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, double> Capacity(System.Collections.Immutable.IImmutableSet<Akka.Cluster.Metrics.Serialization.NodeMetrics> nodeMetrics);\n    public System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, int> Weights(System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, double> capacity) { }\n    public System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, int> Weights(System.Collections.Immutable.IImmutableSet<Akka.Cluster.Metrics.Serialization.NodeMetrics> nodeMetrics) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Expecting Actor Termination in Akka.NET TestKitBase\nDESCRIPTION: These methods are used to expect the termination of a specific actor. They support both synchronous and asynchronous operations with optional timeouts and cancellation tokens.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic Akka.Actor.Terminated ExpectTerminated(Akka.Actor.IActorRef target, System.Nullable<System.TimeSpan> timeout = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic System.Threading.Tasks.ValueTask<Akka.Actor.Terminated> ExpectTerminatedAsync(Akka.Actor.IActorRef target, System.Nullable<System.TimeSpan> timeout = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Using SharedKillSwitch for Abort in Akka.NET Streams\nDESCRIPTION: Example of using SharedKillSwitch to control the completion of multiple Graphs of FlowShape. This snippet demonstrates aborting multiple streams.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/stream-dynamic.md#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n[!code-csharp[KillSwitchDocTests.cs](../../../src/core/Akka.Docs.Tests/Streams/KillSwitchDocTests.cs?name=shared-abort)]\n```\n\n----------------------------------------\n\nTITLE: Snapshot Store Implementations in C#\nDESCRIPTION: Various implementations of snapshot stores including local file system, memory-based, and null implementations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_48\n\nLANGUAGE: C#\nCODE:\n```\npublic class LocalSnapshotStore : Akka.Persistence.Snapshot.SnapshotStore\n{\n    public LocalSnapshotStore() { }\n    protected override System.Threading.Tasks.Task DeleteAsync(Akka.Persistence.SnapshotMetadata metadata) { }\n    protected override System.Threading.Tasks.Task DeleteAsync(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria) { }\n    protected System.IO.FileInfo GetSnapshotFileForWrite(Akka.Persistence.SnapshotMetadata metadata, string extension = \"\") { }\n    protected override System.Threading.Tasks.Task<Akka.Persistence.SelectedSnapshot> LoadAsync(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria) { }\n    protected override void PreStart() { }\n    protected override bool ReceivePluginInternal(object message) { }\n    protected virtual void Save(Akka.Persistence.SnapshotMetadata metadata, object snapshot) { }\n    protected override System.Threading.Tasks.Task SaveAsync(Akka.Persistence.SnapshotMetadata metadata, object snapshot) { }\n    protected void Serialize(System.IO.Stream stream, Akka.Persistence.Serialization.Snapshot snapshot) { }\n    protected System.IO.FileInfo WithOutputStream(Akka.Persistence.SnapshotMetadata metadata, System.Action<System.IO.Stream> p) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EventAdapters Class for Akka.NET Persistence\nDESCRIPTION: This class manages event adapters for Akka.NET persistence, providing methods to create and retrieve adapters based on configuration and types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\npublic class EventAdapters\n{\n    protected EventAdapters(System.Collections.Concurrent.ConcurrentDictionary<System.Type, Akka.Persistence.Journal.IEventAdapter> map, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.Type, Akka.Persistence.Journal.IEventAdapter>> bindings, Akka.Event.ILoggingAdapter log) { }\n    public static Akka.Persistence.Journal.EventAdapters Create(Akka.Actor.ExtendedActorSystem system, Akka.Configuration.Config config) { }\n    public Akka.Persistence.Journal.IEventAdapter Get<T>() { }\n    public virtual Akka.Persistence.Journal.IEventAdapter Get(System.Type type) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Cluster Member Class in C#\nDESCRIPTION: Defines the Member class for Akka.NET clustering that represents a cluster node with properties for address, roles, status and comparison capabilities.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Core.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic class Member : System.IComparable, System.IComparable<Akka.Cluster.Member>\n{\n    public static readonly System.Collections.Generic.IComparer<Akka.Actor.Address> AddressOrdering;\n    public static readonly System.Collections.Generic.IComparer<Akka.Cluster.Member> AgeOrdering;\n    public Akka.Actor.Address Address { get; }\n    public Akka.Util.AppVersion AppVersion { get; }\n    public System.Collections.Immutable.ImmutableHashSet<string> Roles { get; }\n    public Akka.Cluster.MemberStatus Status { get; }\n    public Akka.Cluster.UniqueAddress UniqueAddress { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating ExtensionIdProvider Generic Abstract Class in C#\nDESCRIPTION: Defines the ExtensionIdProvider abstract class for creating and managing extensions in Akka.NET. It implements IExtensionId and IExtensionId<T> interfaces and includes methods for applying and creating extensions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ExtensionIdProvider<T> : Akka.Actor.IExtensionId, Akka.Actor.IExtensionId<T>\n    where T : Akka.Actor.IExtension\n{\n    protected ExtensionIdProvider() { }\n    public System.Type ExtensionType { get; }\n    public T Apply(Akka.Actor.ActorSystem system) { }\n    public abstract T CreateExtension(Akka.Actor.ExtendedActorSystem system);\n    public override bool Equals(object obj) { }\n    public T Get(Akka.Actor.ActorSystem system) { }\n    public override int GetHashCode() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IHandleEventListener Interface in Akka.NET Remote Transport\nDESCRIPTION: An interface for listeners that need to be notified of handle events in Akka.NET's remote transport system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IHandleEventListener\n{\n    void Notify(Akka.Remote.Transport.IHandleEvent ev);\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Subscriber Actors in Akka.NET Cluster\nDESCRIPTION: Code for creating and starting subscriber actors that will receive messages published to the \"content\" topic from anywhere in the cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/distributed-publish-subscribe.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nsystem.ActorOf(Props.Create(() => new Subscriber()), \"subscriber1\");\nsystem.ActorOf(Props.Create(() => new Subscriber()), \"subscriber2\");\nsystem.ActorOf(Props.Create(() => new Subscriber()), \"subscriber3\");\n```\n\n----------------------------------------\n\nTITLE: EWMA (Exponentially Weighted Moving Average) Implementation\nDESCRIPTION: Nested EWMA class for calculating exponentially weighted moving averages of metrics with protobuf serialization support.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Core.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class EWMA : Google.Protobuf.IDeepCloneable<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA>, Google.Protobuf.IMessage, Google.Protobuf.IMessage<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA>, System.IEquatable<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA>\n{\n    public const int AlphaFieldNumber = 2;\n    public const int ValueFieldNumber = 1;\n    public EWMA() { }\n    public EWMA(Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA other) { }\n    public EWMA(double value, double alpha) { }\n    public double Alpha { get; set; }\n    public static Google.Protobuf.Reflection.MessageDescriptor Descriptor { get; }\n    public static Google.Protobuf.MessageParser<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA> Parser { get; }\n    public double Value { get; set; }\n    // Additional methods...\n}\n```\n\n----------------------------------------\n\nTITLE: Actor Unwatch System Message in Akka.NET\nDESCRIPTION: System message for removing a death watch. Contains references to both the watchee (actor being watched) and the watcher (actor doing the watching).\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_110\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class Unwatch : Akka.Dispatch.SysMsg.SystemMessage\n{\n    public Unwatch(Akka.Actor.IInternalActorRef watchee, Akka.Actor.IInternalActorRef watcher) { }\n    public Akka.Actor.IInternalActorRef Watchee { get; }\n    public Akka.Actor.IInternalActorRef Watcher { get; }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AllForOneStrategy Class in C#\nDESCRIPTION: Defines a supervisor strategy that applies the same directive to all children when one fails. Includes constructors for different initialization options and methods for handling child actor failures.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic class AllForOneStrategy : Akka.Actor.SupervisorStrategy, System.IEquatable<Akka.Actor.AllForOneStrategy>\n{\n    public AllForOneStrategy(System.Nullable<int> maxNrOfRetries, System.Nullable<System.TimeSpan> withinTimeRange, System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider) { }\n    public AllForOneStrategy(System.Nullable<int> maxNrOfRetries, System.Nullable<System.TimeSpan> withinTimeRange, Akka.Actor.IDecider decider) { }\n    public AllForOneStrategy(int maxNrOfRetries, int withinTimeMilliseconds, System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider, bool loggingEnabled = True) { }\n    // Additional members omitted for brevity\n}\n```\n\n----------------------------------------\n\nTITLE: Program Configuration for Akka.NET Windows Service\nDESCRIPTION: Main program setup for configuring and running an Akka.NET Windows Service. Includes service hosting configuration and dependency injection setup.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/deployment/windows-service.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/examples/WindowsService/AkkaWindowsService/Program.cs?name=akka-windows-service-program)]\n```\n\n----------------------------------------\n\nTITLE: Implementing Socket Option Classes in Akka.NET\nDESCRIPTION: These classes extend the SocketOption abstract class to provide specific socket configuration options. They override various methods to modify socket behavior at different connection stages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_150\n\nLANGUAGE: C#\nCODE:\n```\npublic class ReuseAddress : Akka.IO.Inet.SocketOption\n{\n    public ReuseAddress(bool on) { }\n    public override void BeforeConnect(System.Net.Sockets.Socket s) { }\n    public override void BeforeDatagramBind(System.Net.Sockets.Socket ds) { }\n    public override void BeforeServerSocketBind(System.Net.Sockets.Socket ss) { }\n}\npublic class SendBufferSize : Akka.IO.Inet.SocketOption\n{\n    public SendBufferSize(int size) { }\n    public override void AfterConnect(System.Net.Sockets.Socket s) { }\n}\npublic class TrafficClass : Akka.IO.Inet.SocketOption\n{\n    public TrafficClass(int tc) { }\n    public override void AfterConnect(System.Net.Sockets.Socket s) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterSingletonProxy Class\nDESCRIPTION: Proxy actor implementation for communicating with singleton instances in the cluster. Handles message routing and singleton location.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.verified.txt#2025-04-16_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterSingletonProxy : Akka.Actor.ReceiveActor\n{\n    public ClusterSingletonProxy(string singletonManagerPath, Akka.Cluster.Tools.Singleton.ClusterSingletonProxySettings settings) { }\n    public static Akka.Configuration.Config DefaultConfig() { }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n    public static Akka.Actor.Props Props(string singletonManagerPath, Akka.Cluster.Tools.Singleton.ClusterSingletonProxySettings settings) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Destination Actors in Akka.NET Cluster\nDESCRIPTION: Code for creating and starting destination actors that register themselves with the DistributedPubSubMediator to receive point-to-point messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/distributed-publish-subscribe.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nsystem.ActorOf(Props.Create(() => new Destination()), \"destination\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Bus and DeadLetter Handling for Akka.NET in C#\nDESCRIPTION: Partial implementation of Akka.NET's event bus system and dead letter handling. These classes enable actor-based event subscriptions and provide a mechanism for tracking undelivered messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_113\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.Event\n{\n    public abstract class ActorEventBus<TEvent, TClassifier> : Akka.Event.EventBus<TEvent, TClassifier, Akka.Actor.IActorRef>\n    {\n        protected ActorEventBus() { }\n    }\n    public abstract class AllDeadLetters : Akka.Actor.IWrappedMessage\n    {\n        protected AllDeadLetters(object message, Akka.Actor.IActorRef sender, Akka.Actor.IActorRef recipient) { }\n        public object Message { get; }\n        public Akka.Actor.IActorRef Recipient { get; }\n        public Akka.Actor.IActorRef Sender { get; }\n        public override string ToString() { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Selecting Actors by Path\nDESCRIPTION: Demonstrates how to select actors using their path with the select function. This allows referencing actors without having their ActorRef directly, using the actor's address in the actor system hierarchy.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.FSharp/README.md#2025-04-16_snippet_6\n\nLANGUAGE: F#\nCODE:\n```\nlet aref = spawn system \"my-actor\" (actorOf2 (fun mailbox m -> printfn \"%A said %s\" (mailbox.Self.Path) m))\naref <! \"one\"\nlet aref2 = select \"akka://my-system/user/my-actor\" system\naref2 <! \"two\"\n```\n\n----------------------------------------\n\nTITLE: Flag Class Implementation in Akka.NET\nDESCRIPTION: Implementation of a boolean flag type for distributed data that supports replication and comparison operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Flag : Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.Flag>, System.IComparable, System.IComparable<Akka.DistributedData.Flag>, System.IEquatable<Akka.DistributedData.Flag>\n{\n    public static readonly Akka.DistributedData.Flag False;\n    public static readonly Akka.DistributedData.Flag True;\n    public Flag() { }\n    public Flag(bool enabled) { }\n    public bool Enabled { get; }\n    public int CompareTo(object obj) { }\n    public int CompareTo(Akka.DistributedData.Flag other) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a ClusterClientReceptionist Event Listener in C#\nDESCRIPTION: Implementation of an actor that subscribes to and receives notifications when cluster clients contact a ClusterClientReceptionist. Shows how to track which clients are connected.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-client.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/core/Akka.Docs.Tests/Networking/ClusterClient/ReceptionistListener.cs?name=ReceptionistListener)]\n```\n\n----------------------------------------\n\nTITLE: Defining EWMA Class in Akka.NET using C#\nDESCRIPTION: The EWMA class calculates the Exponentially Weighted Moving Average of node metrics, which is critical for smoothing out metric values over time. It includes properties for Alpha and Value, methods for comparison, and an overload for operator '+'. Dependencies include Akka.Cluster.Metrics.Serialization and System libraries.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.DotNet.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class EWMA : System.IEquatable<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA> {\n    public EWMA(double value, double alpha) { }\n    public double Alpha { get; }\n    public double Value { get; }\n    public bool Equals(Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA other) { }\n    public override bool Equals(object obj) { }\n    public static double GetAlpha(System.TimeSpan halfLife, System.TimeSpan collectInterval) { }\n    public override int GetHashCode() { }\n    public static Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA +(Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA current, double xn) { }\n}\n```\n\n----------------------------------------\n\nTITLE: ForkJoin Dispatcher Configuration\nDESCRIPTION: Configuration for a dispatcher that uses a dedicated thread pool with specific settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/dispatchers.md#2025-04-16_snippet_6\n\nLANGUAGE: hocon\nCODE:\n```\ndefault-fork-join-dispatcher {\n  type = ForkJoinDispatcher\n  throughput = 30\n  dedicated-thread-pool {\n      thread-count = 3\n      deadlock-timeout = 3s\n      threadtype = background\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PNCounter in C# for Akka.NET\nDESCRIPTION: This class implements a Positive-Negative Counter, a distributed counter data structure for Akka.NET. It provides methods for incrementing, decrementing, and merging counter values across distributed nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class PNCounter : IDeltaReplicatedData, IRemovedNodePruning, IReplicatedData, IEquatable<PNCounter>\n{\n    public static readonly PNCounter Empty;\n    public PNCounter() { }\n    public PNCounter(GCounter increments, GCounter decrements) { }\n    \n    public GCounter Decrements { get; }\n    public PNCounter Delta { get; }\n    public GCounter Increments { get; }\n    public ImmutableHashSet<UniqueAddress> ModifiedByNodes { get; }\n    public BigInteger Value { get; }\n    \n    // Method implementations...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Task Extensions for Testing\nDESCRIPTION: Extension methods for Task objects to support testing scenarios with timeouts and assertions. Includes methods for awaiting task completion within timeouts and verifying expected exceptions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\npublic class static TaskExtensions\n{\n    public static System.Threading.Tasks.Task<bool> AwaitWithTimeout(this System.Threading.Tasks.Task parentTask, System.TimeSpan timeout, System.Threading.CancellationToken cancellationToken = null) { }\n    public static System.Threading.Tasks.Task ShouldCompleteWithin<T>(this System.Threading.Tasks.Task<T> task, T expected, System.TimeSpan timeout, string because = \"\", params object[] becauseArgs) { }\n    public static System.Threading.Tasks.Task<T> ShouldCompleteWithin<T>(this System.Threading.Tasks.Task<T> task, System.TimeSpan timeout, string because = \"\", params object[] becauseArgs) { }\n    public static System.Threading.Tasks.Task ShouldCompleteWithin(this System.Threading.Tasks.Task task, System.TimeSpan timeout, string because = \"\", params object[] becauseArgs) { }\n    public static System.Threading.Tasks.Task ShouldThrowWithin<T>(this System.Threading.Tasks.Task task, T expected, System.TimeSpan timeout, string because = \"\", params object[] becauseArgs)\n        where T : System.Exception { }\n    public static System.Threading.Tasks.Task<T> ShouldThrowWithin<T>(this System.Threading.Tasks.Task task, System.TimeSpan timeout, string because = \"\", params object[] becauseArgs)\n        where T : System.Exception { }\n    public static System.Threading.Tasks.Task<T> WithTimeout<T>(this System.Threading.Tasks.Task<T> parentTask, System.TimeSpan timeout, System.Threading.CancellationToken cancellationToken = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dispatcher Class in Akka.NET\nDESCRIPTION: Core implementation of the message dispatcher that handles actor message execution. It manages throughput, task execution, and resource cleanup. This class is responsible for scheduling actor message processing via the executor service.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_84\n\nLANGUAGE: C#\nCODE:\n```\npublic class Dispatcher : Akka.Dispatch.MessageDispatcher\n    {\n        public Dispatcher(Akka.Dispatch.MessageDispatcherConfigurator configurator, string id, int throughput, System.Nullable<long> throughputDeadlineTime, Akka.Dispatch.ExecutorServiceFactory executorServiceFactory, System.TimeSpan shutdownTimeout) { }\n        protected override void ExecuteTask(Akka.Dispatch.IRunnable run) { }\n        [Akka.Annotations.InternalApiAttribute()]\n        protected override void Shutdown() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Accessing Built-in Sink Stages in Akka.NET Streams\nDESCRIPTION: Demonstrates how to access the built-in sink stages in Akka.NET Streams. These stages are available from the Akka.Stream.DSL.Sink class.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/builtinstages.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nAkka.Stream.DSL.Sink\n```\n\n----------------------------------------\n\nTITLE: Defining IJournalMessage Interface in C#\nDESCRIPTION: This snippet defines the IJournalMessage interface, integral to the Akka persistence framework. It ensures that all journal messages conform to the serialization verification needed for persistence operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IJournalMessage : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Extensions Static Class in C#\nDESCRIPTION: A collection of extension methods for common operations on collections, strings, and other types, enhancing the standard library functionality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_245\n\nLANGUAGE: C#\nCODE:\n```\npublic class static Extensions\n{\n    public static System.Collections.Generic.IDictionary<TKey, TValue> AddAndReturn<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> hash, TKey key, TValue value) { }\n    public static void AddOrSet<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> hash, TKey key, TValue value) { }\n    public static T AsInstanceOf<T>(this object self) { }\n    public static string BetweenDoubleQuotes(this string self) { }\n    public static System.Collections.Generic.IEnumerable<T> Concat<T>(this System.Collections.Generic.IEnumerable<T> enumerable, T item) { }\n    public static System.Collections.Generic.IEnumerable<T> Drop<T>(this System.Collections.Generic.IEnumerable<T> self, int count) { }\n    public static void ForEach<T>(this System.Collections.Generic.IEnumerable<T> source, System.Action<T> action) { }\n    public static TValue GetOrElse<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> hash, TKey key, TValue elseValue) { }\n    public static T Head<T>(this System.Collections.Generic.IEnumerable<T> self) { }\n    public static string Join(this System.Collections.Generic.IEnumerable<string> self, string separator) { }\n    public static System.TimeSpan Max(this System.TimeSpan @this, System.TimeSpan other) { }\n    public static System.TimeSpan Min(this System.TimeSpan @this, System.TimeSpan other) { }\n    public static System.Collections.Generic.IEnumerable<string> SplitDottedPathHonouringQuotes(this string path) { }\n    public static System.Collections.Generic.IEnumerable<T> TakeRight<T>(this System.Collections.Generic.IEnumerable<T> self, int n) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DNS Resolution in Akka.NET with C#\nDESCRIPTION: The Dns class provides methods for DNS resolution in Akka.NET. It includes functionality for caching and resolving DNS names asynchronously.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_158\n\nLANGUAGE: C#\nCODE:\n```\npublic class Dns : Akka.Actor.ExtensionIdProvider<Akka.IO.DnsExt>\n{\n    public static readonly Akka.IO.Dns Instance;\n    public Dns() { }\n    public static Akka.IO.Dns.Resolved Cached(string name, Akka.Actor.ActorSystem system) { }\n    public override Akka.IO.DnsExt CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n    public static Akka.IO.Dns.Resolved ResolveName(string name, Akka.Actor.ActorSystem system, Akka.Actor.IActorRef sender) { }\n    // ... (nested classes)\n}\n```\n\n----------------------------------------\n\nTITLE: Listen Method Implementation (C#)\nDESCRIPTION: Override method that starts listening for incoming connections, returning the local address and a task completion source for the association event listener.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\npublic override System.Threading.Tasks.Task<System.ValueTuple<Akka.Actor.Address, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.IAssociationEventListener>>> Listen() { }\n```\n\n----------------------------------------\n\nTITLE: Creating Reusable Line Sink\nDESCRIPTION: Defines a reusable sink that converts strings to ByteString and writes them to a file\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/quickstart.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic static Sink<string, Task<IOResult>> LineSink(string filename) {\n return Flow.Create<string>()\n   .Select(s => ByteString.FromString($\"{s}\\n\"))\n   .ToMaterialized(FileIO.ToFile(new FileInfo(filename)), Keep.Right);\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Sinks Using the Simplified API in Akka.NET (C#)\nDESCRIPTION: This example demonstrates combining multiple sinks into one using the simplified API in Akka.NET. It defines a broadcast sink that sends items to an arbitrary actor and processes each item locally. The snippet requires Akka.NET components and a materializer to execute.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithgraphs.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar sendRemotely = Sink.ActorRef<int>(actorRef, \"Done\");\nvar localProcessing = Sink.ForEach<int>(_ => { /* do something usefull */ })\n    .MapMaterializedValue(_=> NotUsed.Instance);\n\nvar sink = Sink.Combine(i => new Broadcast<int>(i), sendRemotely, localProcessing);\n\nSource.From(new[] {0, 1, 2}).RunWith(sink, materializer);\n```\n\n----------------------------------------\n\nTITLE: Internal Failed Message for Actor Failure Handling\nDESCRIPTION: Internal API system message representing a child actor failure. Contains the failed child reference, the cause of failure, and a unique identifier.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_97\n\nLANGUAGE: csharp\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic sealed class Failed : Akka.Dispatch.SysMsg.SystemMessage\n{\n    public Failed(Akka.Actor.IActorRef child, System.Exception cause, long uid) { }\n    public System.Exception Cause { get; }\n    public Akka.Actor.IActorRef Child { get; }\n    public long Uid { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Cluster Message Serialization in C#\nDESCRIPTION: Implements a custom serializer for cluster-related messages, supporting binary conversion and manifest generation\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\npublic ClusterMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing BackoffSupervisor Actor in Akka.NET\nDESCRIPTION: Supervisor actor that implements the backoff pattern for child actor restart. Provides various constructors and factory methods for different backoff configurations and supervision strategies.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_192\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class BackoffSupervisor : Akka.Pattern.BackoffSupervisorBase\n{\n    public BackoffSupervisor(Akka.Actor.Props childProps, string childName, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor) { }\n    public BackoffSupervisor(Akka.Actor.Props childProps, string childName, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, Akka.Pattern.IBackoffReset reset, double randomFactor, Akka.Actor.SupervisorStrategy strategy, object replyWhileStopped = null, System.Func<object, bool> finalStopMessage = null) { }\n    public static Akka.Actor.Props Props(Akka.Actor.Props childProps, string childName, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor) { }\n    public static Akka.Actor.Props Props(Akka.Actor.Props childProps, string childName, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor, int maxNrOfRetries) { }\n    public static Akka.Actor.Props Props(Akka.Pattern.BackoffOptions options) { }\n    public static Akka.Actor.Props PropsWithSupervisorStrategy(Akka.Actor.Props childProps, string childName, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor, Akka.Actor.SupervisorStrategy strategy) { }\n    protected override bool Receive(object message) { }\n    protected override Akka.Actor.SupervisorStrategy SupervisorStrategy() { }\n    public sealed class CurrentChild\n    {\n        public CurrentChild(Akka.Actor.IActorRef @ref) { }\n        public Akka.Actor.IActorRef Ref { get; }\n    }\n    public sealed class GetCurrentChild\n    {\n        public static readonly Akka.Pattern.BackoffSupervisor.GetCurrentChild Instance;\n    }\n    public sealed class GetRestartCount\n    {\n        public static readonly Akka.Pattern.BackoffSupervisor.GetRestartCount Instance;\n    }\n    public sealed class Reset\n    {\n        public static readonly Akka.Pattern.BackoffSupervisor.Reset Instance;\n    }\n    public sealed class ResetRestartCount : Akka.Event.IDeadLetterSuppression\n    {\n        public ResetRestartCount(int current) { }\n        public int Current { get; }\n    }\n    public sealed class RestartCount\n    {\n        public RestartCount(int count) { }\n        public int Count { get; }\n    }\n    public sealed class StartChild : Akka.Event.IDeadLetterSuppression\n    {\n        public static readonly Akka.Pattern.BackoffSupervisor.StartChild Instance;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Stream Transformation Operations in Akka.NET\nDESCRIPTION: Collection of stream transformation operations including Select, SelectMany, and Where. These operations modify stream elements while maintaining proper backpressure behavior.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/builtinstages.md#2025-04-16_snippet_4\n\n\n\n----------------------------------------\n\nTITLE: Implementing ActorProducerPipeline and Related Classes in C#\nDESCRIPTION: These classes manage the pipeline for producing actors, including plugins that can modify actor behavior before and after incarnation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class ActorProducerPipeline : System.Collections.Generic.IEnumerable<Akka.Actor.IActorProducerPlugin>, System.Collections.IEnumerable\n{\n    // ... (constructor and methods)\n}\n\npublic class ActorProducerPipelineResolver\n{\n    // ... (constructor and methods)\n}\n\npublic abstract class ActorProducerPluginBase : Akka.Actor.IActorProducerPlugin\n{\n    // ... (methods)\n}\n\npublic abstract class ActorProducerPluginBase<TActor> : Akka.Actor.IActorProducerPlugin\n    where TActor : Akka.Actor.ActorBase\n{\n    // ... (methods)\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Message Reception in Akka.NET TestKit\nDESCRIPTION: Methods for receiving messages while a condition holds true. These methods support filtering and conditional processing of messages with timeout constraints and cancellation support.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic System.Collections.Generic.IReadOnlyList<T> ReceiveWhile<T>(System.Nullable<System.TimeSpan> max, System.Func<object, T> filter, int msgs = 2147483647, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Collections.Generic.IReadOnlyList<T> ReceiveWhile<T>(System.Nullable<System.TimeSpan> max, System.Nullable<System.TimeSpan> idle, System.Func<object, T> filter, int msgs = 2147483647, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Collections.Generic.IReadOnlyList<T> ReceiveWhile<T>(System.Func<object, T> filter, System.Nullable<System.TimeSpan> max = null, System.Nullable<System.TimeSpan> idle = null, int msgs = 2147483647, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Collections.Generic.IReadOnlyList<T> ReceiveWhile<T>(System.Predicate<T> shouldContinue, System.Nullable<System.TimeSpan> max = null, System.Nullable<System.TimeSpan> idle = null, int msgs = 2147483647, bool shouldIgnoreOtherMessageTypes = True, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Priority Message Queue in Akka.NET\nDESCRIPTION: Defines a priority-based unbounded message queue that processes messages according to their priority. Uses a priority generator function to determine message ordering.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_113\n\nLANGUAGE: C#\nCODE:\n```\npublic class UnboundedPriorityMessageQueue : Akka.Dispatch.MessageQueues.BlockingMessageQueue, Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics, Akka.Dispatch.IUnboundedMessageQueueSemantics\n{\n    public UnboundedPriorityMessageQueue(System.Func<object, int> priorityGenerator, int initialCapacity) { }\n    protected override int LockedCount { get; }\n    public void EnqueueFirst(Akka.Actor.Envelope envelope) { }\n    protected override void LockedEnqueue(Akka.Actor.Envelope envelope) { }\n    protected override bool LockedTryDequeue(out Akka.Actor.Envelope envelope) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Akka.Management on Receptionist Side\nDESCRIPTION: Code for starting Akka.Management on the ClusterClient receptionist side when not using ClusterBootstrap. This is required for discovery mechanisms to work properly.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-client.md#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nservices.AddAkka(\"ReceptionistSys\", (builder, provider) => {\n  builder.AddStartup(async (system, registry) => {\n    await AkkaManagement.Get(system).Start();\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing SendToAll Message Class for Akka Distributed PubSub in C#\nDESCRIPTION: Defines a sealed SendToAll message class used to broadcast messages to all actors subscribed to a path in Akka's distributed publish-subscribe system. Includes option to exclude the sender from receiving the message.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class SendToAll : Akka.Actor.IWrappedMessage, Akka.Cluster.Tools.PublishSubscribe.IDistributedPubSubMessage, System.IEquatable<Akka.Cluster.Tools.PublishSubscribe.SendToAll>\n{\n    public SendToAll(string path, object message, bool excludeSelf = False) { }\n    public bool ExcludeSelf { get; }\n    public object Message { get; }\n    public string Path { get; }\n    public bool Equals(Akka.Cluster.Tools.PublishSubscribe.SendToAll other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterMessageSerializer in C#\nDESCRIPTION: Defines a serializer for cluster messages in Akka.NET. This class is responsible for converting cluster-related objects to and from binary format for network transmission.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Core.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic class ClusterMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public ClusterMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object o) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting a Sender Actor in Akka.NET Cluster\nDESCRIPTION: Code for creating and starting a sender actor that will send point-to-point messages to the \"/user/destination\" path, which will be routed to one of the registered destination actors across the cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/distributed-publish-subscribe.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nsystem.ActorOf(Props.Create(() => new Sender()), \"sender\");\n```\n\n----------------------------------------\n\nTITLE: Implementing MixMetricsSelectorBase Abstract Class in C#\nDESCRIPTION: Abstract base class that combines multiple capacity metrics selectors. Provides functionality to calculate node capacity based on a collection of capacity metrics selectors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.DotNet.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class MixMetricsSelectorBase : Akka.Cluster.Metrics.CapacityMetricsSelector\n{\n    protected MixMetricsSelectorBase(System.Collections.Immutable.ImmutableArray<Akka.Cluster.Metrics.CapacityMetricsSelector> selectors) { }\n    public System.Collections.Immutable.ImmutableArray<Akka.Cluster.Metrics.CapacityMetricsSelector> Selectors { get; }\n    public override System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, double> Capacity(System.Collections.Immutable.IImmutableSet<Akka.Cluster.Metrics.Serialization.NodeMetrics> nodeMetrics) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Failure Injection Transport Adapter in C#\nDESCRIPTION: Defines a transport adapter that can inject network failures and manipulate message delivery. Includes support for dropping messages and forcing disassociations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic class FailureInjectorTransportAdapter : Akka.Remote.Transport.AbstractTransportAdapter, Akka.Remote.Transport.IAssociationEventListener\n{\n    public readonly Akka.Actor.ExtendedActorSystem ExtendedActorSystem;\n    public const string FailureInjectorSchemeIdentifier = \"gremlin\";\n    protected int MaximumOverhead;\n    public FailureInjectorTransportAdapter(Akka.Remote.Transport.Transport wrappedTransport, Akka.Actor.ExtendedActorSystem extendedActorSystem) { }\n    protected override Akka.Remote.Transport.SchemeAugmenter SchemeAugmenter { get; }\n    protected override void InterceptAssociate(Akka.Actor.Address remoteAddress, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.AssociationHandle> statusPromise) { }\n    protected override System.Threading.Tasks.Task<Akka.Remote.Transport.IAssociationEventListener> InterceptListen(Akka.Actor.Address listenAddress, System.Threading.Tasks.Task<Akka.Remote.Transport.IAssociationEventListener> listenerTask) { }\n    public override System.Threading.Tasks.Task<bool> ManagementCommand(object message) { }\n    public void Notify(Akka.Remote.Transport.IAssociationEvent ev) { }\n    public bool ShouldDropInbound(Akka.Actor.Address remoteAddress, object instance, string debugMessage) { }\n    public bool ShouldDropOutbound(Akka.Actor.Address remoteAddress, object instance, string debugMessage) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Journal Settings Configuration in C#\nDESCRIPTION: Configuration class for SQL journal settings including connection strings, table names, isolation levels and initialization options.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.DotNet.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic class JournalSettings {\n    public JournalSettings(Akka.Configuration.Config config) { }\n    public bool AutoInitialize { get; }\n    public string ConnectionString { get; }\n    public string ConnectionStringName { get; }\n    public System.TimeSpan ConnectionTimeout { get; }\n    public string JournalTableName { get; }\n    public string MetaTableName { get; }\n    public System.Data.IsolationLevel ReadIsolationLevel { get; }\n    public string SchemaName { get; }\n    public string TimestampProvider { get; set; }\n    public System.Data.IsolationLevel WriteIsolationLevel { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: DnsBase Abstract Class for DNS Resolution Implementation\nDESCRIPTION: Defines the base functionality for DNS resolution in Akka.NET with methods for caching and resolution. This abstract class provides the foundation for concrete DNS resolver implementations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_156\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class DnsBase\n    {\n        protected DnsBase() { }\n        public virtual Akka.IO.Dns.Resolved Cached(string name) { }\n        public virtual Akka.IO.Dns.Resolved Resolve(string name, Akka.Actor.ActorSystem system, Akka.Actor.IActorRef sender) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing ScatterGatherFirstCompletedRoutingLogic in Akka.NET\nDESCRIPTION: Routing logic implementation for the ScatterGatherFirstCompleted strategy. Broadcasts messages to all routees and returns a SeveralRoutees instance that represents all the targets.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_215\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ScatterGatherFirstCompletedRoutingLogic : Akka.Routing.RoutingLogic\n{\n    public ScatterGatherFirstCompletedRoutingLogic(System.TimeSpan within) { }\n    public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }\n}\n```\n\n----------------------------------------\n\nTITLE: ListenerSupport Class in Akka.NET Routing\nDESCRIPTION: Implements support for listener registration and gossip messaging. Maintains a collection of listener actors and provides methods to add, remove, and notify listeners.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_179\n\nLANGUAGE: C#\nCODE:\n```\npublic class ListenerSupport\n{\n    protected readonly System.Collections.Generic.HashSet<Akka.Actor.IActorRef> Listeners;\n    public ListenerSupport() { }\n    public Akka.Actor.Receive ListenerReceive { get; }\n    public void Add(Akka.Actor.IActorRef actor) { }\n    public void Gossip(object message) { }\n    public void Gossip(object message, Akka.Actor.IActorRef sender) { }\n    public void Remove(Akka.Actor.IActorRef actor) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Supervise System Message in Akka.NET\nDESCRIPTION: Defines a system message that instructs an actor to supervise a child actor. Includes whether supervision should be performed asynchronously.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_127\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Supervise : Akka.Dispatch.SysMsg.SystemMessage\n{\n    public Supervise(Akka.Actor.IActorRef child, bool async) { }\n    public bool Async { get; }\n    public Akka.Actor.IActorRef Child { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HoconValue Class in C#\nDESCRIPTION: This snippet shows the HoconValue class, which represents a value in the HOCON (Human-Optimized Config Object Notation) format. It includes methods for appending values, getting various data types, and working with child objects.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_76\n\nLANGUAGE: C#\nCODE:\n```\npublic class HoconValue : Akka.Configuration.Hocon.IMightBeAHoconObject\n{\n    public HoconValue() { }\n    public HoconValue(System.Collections.Generic.List<Akka.Configuration.Hocon.IHoconElement> values, bool adoptedFromFallback = True) { }\n    public bool IsEmpty { get; }\n    public System.Collections.Generic.List<Akka.Configuration.Hocon.IHoconElement> Values { get; }\n    public void AppendValue(Akka.Configuration.Hocon.IHoconElement value) { }\n    public Akka.Configuration.Config AtKey(string key) { }\n    public void Clear() { }\n    public System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray() { }\n    public bool GetBoolean() { }\n    public System.Collections.Generic.IList<bool> GetBooleanList() { }\n    public byte GetByte() { }\n    public System.Collections.Generic.IList<byte> GetByteList() { }\n    public System.Nullable<long> GetByteSize() { }\n    public Akka.Configuration.Hocon.HoconValue GetChildObject(string key) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SerializationSetup for Actor System Configuration in C#\nDESCRIPTION: A setup class for configuring serializers at actor system startup. Provides a factory method for creating serializer details sets to be used during system initialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_214\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SerializationSetup : Akka.Actor.Setup.Setup\n    {\n        public System.Func<Akka.Actor.ExtendedActorSystem, System.Collections.Immutable.ImmutableHashSet<Akka.Serialization.SerializerDetails>> CreateSerializers { get; }\n        public static Akka.Serialization.SerializationSetup Create(System.Func<Akka.Actor.ExtendedActorSystem, System.Collections.Immutable.ImmutableHashSet<Akka.Serialization.SerializerDetails>> createSerializers) { }\n```\n\n----------------------------------------\n\nTITLE: ClusterClientReceptionist Extension Implementation\nDESCRIPTION: The ClusterClientReceptionist implements the Akka.NET extension mechanism to handle incoming connections from cluster clients. It provides methods for registering and unregistering services and subscribers within the cluster that can be contacted by external clients.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterClientReceptionist : Akka.Actor.IExtension\n{\n    public ClusterClientReceptionist(Akka.Actor.ExtendedActorSystem system) { }\n    public bool IsTerminated { get; }\n    public Akka.Actor.IActorRef Underlying { get; }\n    public static Akka.Configuration.Config DefaultConfig() { }\n    public static Akka.Cluster.Tools.Client.ClusterClientReceptionist Get(Akka.Actor.ActorSystem system) { }\n    public void RegisterService(Akka.Actor.IActorRef actorRef) { }\n    public void RegisterSubscriber(string topic, Akka.Actor.IActorRef actorRef) { }\n    public void UnregisterService(Akka.Actor.IActorRef actorRef) { }\n    public void UnregisterSubscriber(string topic, Akka.Actor.IActorRef actorRef) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DurableProducerQueue Command Types\nDESCRIPTION: Defines command types used by the durable producer queue to store and track messages, including StoreMessageSent and StoreMessageConfirmed, which are essential for at-least-once delivery guarantees.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_78\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class StoreMessageConfirmed : Akka.Delivery.DurableProducerQueue.IDurableProducerQueueCommand, System.IEquatable<Akka.Delivery.DurableProducerQueue.StoreMessageConfirmed>\n{\n    public StoreMessageConfirmed(long SeqNr, string ConfirmationQualifier, long Timestamp) { }\n    public string ConfirmationQualifier { get; set; }\n    public long SeqNr { get; set; }\n    public long Timestamp { get; set; }\n}\n\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class StoreMessageSentAck : System.IEquatable<Akka.Delivery.DurableProducerQueue.StoreMessageSentAck>\n{\n    public StoreMessageSentAck(long StoredSeqNo) { }\n    public long StoredSeqNo { get; set; }\n}\n\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class StoreMessageSent<[System.Runtime.CompilerServices.NullableAttribute(2)]  T> : Akka.Delivery.DurableProducerQueue.IDurableProducerQueueCommand, System.IEquatable<Akka.Delivery.DurableProducerQueue.StoreMessageSent<T>>\n{\n    public StoreMessageSent(Akka.Delivery.DurableProducerQueue.MessageSent<T> MessageSent, Akka.Actor.IActorRef ReplyTo) { }\n    public Akka.Delivery.DurableProducerQueue.MessageSent<T> MessageSent { get; set; }\n    public Akka.Actor.IActorRef ReplyTo { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ThrottleMode Abstract Class in Akka.NET\nDESCRIPTION: Abstract ThrottleMode class for managing throttling in Akka.NET remote transport. It provides methods to check token availability and consume tokens for rate limiting.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ThrottleMode : Akka.Actor.INoSerializationVerificationNeeded\n{\n    protected ThrottleMode() { }\n    public abstract System.TimeSpan TimeToAvailable(long currentNanoTime, int tokens);\n    public abstract System.ValueTuple<Akka.Remote.Transport.ThrottleMode, bool> TryConsumeTokens(long nanoTimeOfSend, int tokens);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ShardRegionStats for Sharding State Tracking in C#\nDESCRIPTION: Defines \"ShardRegionStats\", providing a snapshot of shard statistics including failed shards. It serializes data and uses collections from the \"System.Collections.Immutable\" namespace for immutable shard state management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Core.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ShardRegionStats : Akka.Cluster.Sharding.IClusterShardingSerializable, System.IEquatable<Akka.Cluster.Sharding.ShardRegionStats> {\n        public readonly System.Collections.Immutable.IImmutableSet<string> Failed;\n        public readonly System.Collections.Immutable.IImmutableDictionary<string, int> Stats;\n        [System.ObsoleteAttribute(\"Use constructor with `failed` argument. Obsolete since 1.5.0-alpha1\")]\n        public ShardRegionStats(System.Collections.Immutable.IImmutableDictionary<string, int> stats) { }\n        public ShardRegionStats(System.Collections.Immutable.IImmutableDictionary<string, int> stats, System.Collections.Immutable.IImmutableSet<string> failed) { }\n        public override bool Equals(object obj) { }\n        public bool Equals(Akka.Cluster.Sharding.ShardRegionStats other) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Remote Lifecycle Event Classes in C#\nDESCRIPTION: Defines event classes for tracking remote actor system lifecycle events including errors, listening, shutdown and quarantine states.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class RemotingLifecycleEvent\n{\n    protected RemotingLifecycleEvent() { }\n    public abstract Akka.Event.LogLevel LogLevel();\n}\n\npublic sealed class RemotingErrorEvent : Akka.Remote.RemotingLifecycleEvent\n{\n    public RemotingErrorEvent(System.Exception cause) { }\n    public System.Exception Cause { get; }\n    public override Akka.Event.LogLevel LogLevel() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Cluster Events and Member State Management\nDESCRIPTION: Defines a comprehensive set of cluster event types for tracking member lifecycle, including joining, leaving, up, down, and removal events. Provides detailed state tracking for distributed system membership.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ClusterEvent\n{\n    public sealed class MemberJoined : MemberStatusChange { }\n    public sealed class MemberLeft : MemberStatusChange { }\n    public sealed class MemberUp : MemberStatusChange { }\n    public sealed class MemberDowned : MemberStatusChange { }\n}\n```\n\n----------------------------------------\n\nTITLE: ClusterShardingSettings Class Definition in C#\nDESCRIPTION: Configures behavior of Akka.NET's cluster sharding. Contains settings for remember entities, passivation, persistence, state store mode, and performance tuning. Also includes methods for creating instances from configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterShardingSettings : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public readonly Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings CoordinatorSingletonSettings;\n    public readonly string JournalPluginId;\n    public readonly Akka.Coordination.LeaseUsageSettings LeaseSettings;\n    public readonly System.TimeSpan PassivateIdleEntityAfter;\n    public readonly bool RememberEntities;\n    public readonly Akka.Cluster.Sharding.RememberEntitiesStore RememberEntitiesStore;\n    public readonly string Role;\n    public readonly System.TimeSpan ShardRegionQueryTimeout;\n    public readonly string SnapshotPluginId;\n    public readonly Akka.Cluster.Sharding.StateStoreMode StateStoreMode;\n    public readonly Akka.Cluster.Sharding.TuningParameters TuningParameters;\n    public ClusterShardingSettings(string role, bool rememberEntities, string journalPluginId, string snapshotPluginId, System.TimeSpan passivateIdleEntityAfter, Akka.Cluster.Sharding.StateStoreMode stateStoreMode, Akka.Cluster.Sharding.TuningParameters tuningParameters, Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings coordinatorSingletonSettings) { }\n    public ClusterShardingSettings(string role, bool rememberEntities, string journalPluginId, string snapshotPluginId, System.TimeSpan passivateIdleEntityAfter, Akka.Cluster.Sharding.StateStoreMode stateStoreMode, Akka.Cluster.Sharding.TuningParameters tuningParameters, Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings coordinatorSingletonSettings, Akka.Coordination.LeaseUsageSettings leaseSettings) { }\n    public ClusterShardingSettings(string role, bool rememberEntities, string journalPluginId, string snapshotPluginId, System.TimeSpan passivateIdleEntityAfter, Akka.Cluster.Sharding.StateStoreMode stateStoreMode, Akka.Cluster.Sharding.RememberEntitiesStore rememberEntitiesStore, System.TimeSpan shardRegionQueryTimeout, Akka.Cluster.Sharding.TuningParameters tuningParameters, Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings coordinatorSingletonSettings, Akka.Coordination.LeaseUsageSettings leaseSettings) { }\n    public static Akka.Cluster.Sharding.ClusterShardingSettings Create(Akka.Actor.ActorSystem system) { }\n    public static Akka.Cluster.Sharding.ClusterShardingSettings Create(Akka.Configuration.Config config, Akka.Configuration.Config singletonConfig) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterSingletonManagerSettings Class\nDESCRIPTION: Configuration settings class for ClusterSingletonManager with properties for singleton name, role, removal margin, and handover retry intervals.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterSingletonManagerSettings : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public ClusterSingletonManagerSettings(string singletonName, string role, System.TimeSpan removalMargin, System.TimeSpan handOverRetryInterval) { }\n    public ClusterSingletonManagerSettings(string singletonName, string role, System.TimeSpan removalMargin, System.TimeSpan handOverRetryInterval, Akka.Coordination.LeaseUsageSettings leaseSettings) { }\n    public System.TimeSpan HandOverRetryInterval { get; }\n    public Akka.Coordination.LeaseUsageSettings LeaseSettings { get; }\n    public System.TimeSpan RemovalMargin { get; }\n    public string Role { get; }\n    public string SingletonName { get; }\n    public static Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings Create(Akka.Actor.ActorSystem system) { }\n    public static Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings Create(Akka.Configuration.Config config) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Remote Transport Abstract Class in C#\nDESCRIPTION: Abstract base class for implementing remote transport functionality. Handles network communication between remote actor systems.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class RemoteTransport\n{\n    protected RemoteTransport(Akka.Actor.ExtendedActorSystem system, Akka.Remote.RemoteActorRefProvider provider) { }\n    public abstract System.Collections.Generic.ISet<Akka.Actor.Address> Addresses { get; }\n    public abstract Akka.Actor.Address DefaultAddress { get; }\n    // ... additional members\n}\n```\n\n----------------------------------------\n\nTITLE: Wiring Up Stream Components in Akka.NET\nDESCRIPTION: Illustrates different methods for connecting sources, sinks, and flows in Akka.NET Streams. Examples show explicit wiring, starting from a source or sink, and broadcasting to multiple sinks.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/basics.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// Explicitly creating and wiring up a Source, Sink and Flow\nSource.From(Enumerable.Range(1, 6))\n    .Via(Flow.Create<int>().Select(x => x*2))\n    .To(Sink.ForEach<int>(x => Console.WriteLine(x.ToString())));\n    \n// Starting from a Source\nvar source = Source.From(Enumerable.Range(1, 6)).Select(x => x * 2);\n    source.To(Sink.ForEach<int>(x => Console.WriteLine(x.ToString())));\n    \n// Starting from a Sink\nvar sink = Flow.Create<int>()\n    .Select(x => x*2)\n    .To(Sink.ForEach<int>(x => Console.WriteLine(x.ToString())));\nSource.From(Enumerable.Range(1, 6)).To(sink);\n\n// Broadcast to a sink inline\nvar sink = Sink.ForEach<int>(x => Console.WriteLine(x.ToString()))\n    .MapMaterializedValue(_ => NotUsed.Instance);\nvar otherSink = Flow.Create<int>().AlsoTo(sink).To(Sink.Ignore<int>());\nSource.From(Enumerable.Range(1, 6)).To(otherSink);\n```\n\n----------------------------------------\n\nTITLE: Implementing Priority Queue for Actor Messages in C#\nDESCRIPTION: Defines a StableListPriorityQueue class that implements a priority queue specifically for Akka actor envelopes. It provides methods for enqueuing, dequeuing, and peeking at messages with a specified priority calculation function.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_252\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class StableListPriorityQueue\n{\n    public StableListPriorityQueue(int initialCapacity, System.Func<object, int> priorityCalculator) { }\n    public int Count() { }\n    public Akka.Actor.Envelope Dequeue() { }\n    public void Enqueue(Akka.Actor.Envelope item) { }\n    public bool IsConsistent() { }\n    public Akka.Actor.Envelope Peek() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Resize Class in Akka.NET Routing\nDESCRIPTION: Defines a message used to trigger resizing of a resizable router. It extends RouterManagementMessage and is used to signal when a router should evaluate and adjust its pool size.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_186\n\nLANGUAGE: C#\nCODE:\n```\npublic class Resize : Akka.Routing.RouterManagementMessage\n{\n    public Resize() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IStringMatcher Interface in Akka.NET TestKit\nDESCRIPTION: Definition of the IStringMatcher interface which provides a contract for matching strings using different strategies. This interface is used by various string matcher implementations in the Akka.NET TestKit.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IStringMatcher\n{\n    bool IsMatch(string s);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NormalChildrenContainer Class in C#\nDESCRIPTION: This class extends ChildrenContainerBase and provides implementations for adding, removing, and managing child actors in a normal (non-terminating) state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_62\n\nLANGUAGE: C#\nCODE:\n```\npublic class NormalChildrenContainer : Akka.Actor.Internal.ChildrenContainerBase\n{\n    public override Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats) { }\n    public static Akka.Actor.Internal.IChildrenContainer Create(System.Collections.Immutable.IImmutableDictionary<string, Akka.Actor.Internal.IChildStats> children) { }\n    public override Akka.Actor.Internal.IChildrenContainer Remove(Akka.Actor.IActorRef child) { }\n    public override Akka.Actor.Internal.IChildrenContainer Reserve(string name) { }\n    public override Akka.Actor.Internal.IChildrenContainer ShallDie(Akka.Actor.IActorRef actor) { }\n    public override string ToString() { }\n    public override Akka.Actor.Internal.IChildrenContainer Unreserve(string name) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IReplicatorMessage Marker Interface in C#\nDESCRIPTION: Defines an empty marker interface used to identify messages that can be sent to and processed by the Replicator actor in the distributed data system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IReplicatorMessage { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Snapshot Management Classes in C#\nDESCRIPTION: Defines classes for managing snapshots in Akka.NET persistence, including SnapshotOffer and SnapshotSelectionCriteria for snapshot metadata handling and selection.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SnapshotOffer : System.IEquatable<Akka.Persistence.SnapshotOffer>\n{\n    public SnapshotOffer(Akka.Persistence.SnapshotMetadata metadata, object snapshot) { }\n    public Akka.Persistence.SnapshotMetadata Metadata { get; }\n    public object Snapshot { get; }\n    public bool Equals(Akka.Persistence.SnapshotOffer other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Info Log Level Class in C#\nDESCRIPTION: A class representing info-level log events in the Akka.NET logging system. It contains the log message, source, class, and optional exception cause.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_131\n\nLANGUAGE: C#\nCODE:\n```\npublic class Info : Akka.Event.LogEvent\n{\n    public Info(string logSource, System.Type logClass, object message) { }\n    public Info(System.Exception cause, string logSource, System.Type logClass, object message) { }\n    public override Akka.Event.LogLevel LogLevel() { }\n}\n```\n\n----------------------------------------\n\nTITLE: RemoteWatcher Actor Implementation in C#\nDESCRIPTION: Actor class that monitors remote actor connections and handles failure detection. Implements IRequiresMessageQueue for unbounded message processing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class RemoteWatcher : Akka.Actor.UntypedActor, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedMessageQueueSemantics>\n{\n    protected readonly Akka.Event.ILoggingAdapter Log;\n    protected readonly System.Collections.Generic.Dictionary<Akka.Actor.Address, System.Collections.Generic.HashSet<Akka.Actor.IInternalActorRef>> WatcheeByNodes;\n    protected readonly System.Collections.Generic.Dictionary<Akka.Actor.IInternalActorRef, System.Collections.Generic.HashSet<Akka.Actor.IInternalActorRef>> Watching;\n    // Additional members...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Transport Protocols Simultaneously in HOCON\nDESCRIPTION: Configuration example demonstrating how to enable and configure multiple transport protocols (TCP and HTTP) simultaneously within a single ActorSystem. Each transport uses a different port and can be addressed with its own protocol scheme.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/remoting/transports.md#2025-04-16_snippet_2\n\nLANGUAGE: xml\nCODE:\n```\nakka{\n    remote {\n        enabled-transports = [\"akka.remote.dot-netty.tcp\", \"akka.remote.magic.http\"]\n        dot-netty.tcp {\n            port = 8081\n            hostname = localhost\n        }\n        magic.http {\n            port = 8082 # needs to be on a different port or IP than TCP\n            hostname = localhost\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CurrentShardRegionState Class in C#\nDESCRIPTION: A sealed class representing the current state of a shard region, including sets of shard states and failed shards, with methods for equality comparison and string representation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class CurrentShardRegionState : Akka.Cluster.Sharding.IClusterShardingSerializable, System.IEquatable<Akka.Cluster.Sharding.CurrentShardRegionState>\n{\n    public readonly System.Collections.Immutable.IImmutableSet<string> Failed;\n    public readonly System.Collections.Immutable.IImmutableSet<Akka.Cluster.Sharding.ShardState> Shards;\n    [System.ObsoleteAttribute()]\n    public CurrentShardRegionState(System.Collections.Immutable.IImmutableSet<Akka.Cluster.Sharding.ShardState> shards) { }\n    public CurrentShardRegionState(System.Collections.Immutable.IImmutableSet<Akka.Cluster.Sharding.ShardState> shards, System.Collections.Immutable.IImmutableSet<string> failed) { }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.Cluster.Sharding.CurrentShardRegionState other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ShardingProducerController for Akka.NET\nDESCRIPTION: Static class implementing producer controller functionality for Akka.NET cluster sharding with message confirmation and request handling capabilities.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\npublic class static ShardingProducerController\n{\n    public static Akka.Actor.Props Create<T>(string producerId, Akka.Actor.IActorRef shardRegion, Akka.Util.Option<Akka.Actor.Props> durableQueue, Settings settings) { }\n    \n    public interface IShardingProducerControllerCommand<T> { }\n    \n    public sealed class MessageWithConfirmation<T> : IShardingProducerControllerCommand<T>\n    {\n        public string EntityId { get; set; }\n        public T Message { get; set; }\n        public Akka.Actor.IActorRef ReplyTo { get; set; }\n    }\n    \n    // Additional nested classes and implementations\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Remote Deployment with HOCON in Akka.NET\nDESCRIPTION: HOCON configuration snippet that defines remote deployment settings. This configuration tells the actor system to deploy actors with the specified path to the remote target system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/remoting/deployment.md#2025-04-16_snippet_3\n\nLANGUAGE: xml\nCODE:\n```\ndeployment {\n    /remoteecho {\n        remote = \"akka.tcp://DeployTarget@localhost:8090\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Router Configuration and Management in C#\nDESCRIPTION: Defines base classes and interfaces for router configuration including CustomRouterConfig, Group, and router management messages. Handles router setup and message routing configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_180\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class CustomRouterConfig : Akka.Routing.RouterConfig\n{\n    protected CustomRouterConfig() { }\n    protected CustomRouterConfig(string routerDispatcher) { }\n    public override Akka.Actor.ActorBase CreateRouterActor() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ProducerController Message Handling in C#\nDESCRIPTION: Implementation of message handling types for the ProducerController including MessageWithConfirmation, RegisterConsumer, and RequestNext. Handles message routing and confirmation between producers and consumers.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_90\n\nLANGUAGE: C#\nCODE:\n```\npublic class static ProducerController {\n    public static Props Create<T>(IActorRefFactory actorRefFactory, string producerId, Option<Props> durableProducerQueue, Settings settings = null, Action<SequencedMessage<T>> sendAdapter = null) { }\n    \n    public sealed class MessageWithConfirmation<T> : IProducerCommand<T> {\n        public MessageWithConfirmation(T message, IActorRef replyTo) { }\n        public T Message { get; }\n        public IActorRef ReplyTo { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ShardRegion Class in C#\nDESCRIPTION: Implements the ShardRegion class, which extends ActorBase and implements IWithTimers. It manages shard regions and handles entity-related messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Net.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalStableApiAttribute()]\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class ShardRegion : Akka.Actor.ActorBase, Akka.Actor.IWithTimers\n{\n    public ShardRegion(string typeName, [System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            2,\n            1,\n            1})] System.Func<string, Akka.Actor.Props> entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, string coordinatorPath, Akka.Cluster.Sharding.IMessageExtractor messageExtractor, object handOffStopMessage, [System.Runtime.CompilerServices.NullableAttribute(2)] Akka.Cluster.Sharding.Internal.IRememberEntitiesProvider rememberEntitiesProvider) { }\n    public Akka.Actor.ITimerScheduler Timers { get; set; }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n    protected override bool Receive(object message) { }\n    // ... (StartEntity inner class omitted for brevity)\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Timer Registration in PostRestart Method\nDESCRIPTION: The proper implementation showing timer registration in the PostRestart method. This ensures the timer will be correctly registered after the actor has been restarted.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK1007.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing Akka.Actor;\n\npublic sealed class MyActor : ReceiveActor, IWithTimers\n{\n    private sealed class TimerKey\n    {\n        public static readonly TimerKey Instance = new();\n        private TimerKey() { }\n    }\n    \n    private sealed class TimerMessage\n    {\n        public static readonly TimerMessage Instance = new();\n        private TimerMessage() { }\n    }\n\n    public MyActor()\n    {\n        Receive<TimerMessage>(_ =>\n        {\n            // Timer callback code\n        });\n    }\n    \n    public ITimerScheduler Timers { get; set; }\n    \n    protected override void PostRestart(Exception reason)\n    {\n        base.PostRestart(reason);\n        \n        // Timer registration moved to here\n        Timers.StartSingleTimer(\n            key: TimerKey.Instance, \n            msg: TimerMessage.Instance, \n            timeout: TimeSpan.FromSeconds(3));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Complex C# Singleton Implementation\nDESCRIPTION: Demonstrates a complete C# singleton implementation with equality and string representation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/porting-guide.md#2025-04-16_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\npublic sealed class RecoveryCompleted\n{\n    public static RecoveryCompleted Instance { get; } = new RecoveryCompleted();\n\n    private RecoveryCompleted() {}\n    public override bool Equals(object obj) => !ReferenceEquals(obj, null) && obj is RecoveryCompleted;\n    public override int GetHashCode() => nameof(RecoveryCompleted).GetHashCode();\n    public override string ToString() => nameof(RecoveryCompleted);\n}\n```\n\n----------------------------------------\n\nTITLE: DNS Resolution System in Akka.NET IO Module\nDESCRIPTION: Implements DNS resolution capabilities in Akka.NET with commands for resolving hostnames, response handling, and caching. The class provides both synchronous and asynchronous DNS resolution with IPv4/IPv6 support.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_155\n\nLANGUAGE: C#\nCODE:\n```\npublic class Dns : Akka.Actor.ExtensionIdProvider<Akka.IO.DnsExt>\n    {\n        public static readonly Akka.IO.Dns Instance;\n        public Dns() { }\n        public static Akka.IO.Dns.Resolved Cached(string name, Akka.Actor.ActorSystem system) { }\n        public override Akka.IO.DnsExt CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n        public static Akka.IO.Dns.Resolved ResolveName(string name, Akka.Actor.ActorSystem system, Akka.Actor.IActorRef sender) { }\n        public abstract class Command : Akka.Actor.INoSerializationVerificationNeeded\n        {\n            protected Command() { }\n        }\n        public class Resolve : Akka.IO.Dns.Command, Akka.Routing.IConsistentHashable\n        {\n            public Resolve(string name) { }\n            public object ConsistentHashKey { get; }\n            public string Name { get; }\n        }\n        public class Resolved : Akka.IO.Dns.Command\n        {\n            public Resolved(string name, System.Exception ex) { }\n            public Resolved(string name, System.Collections.Generic.IEnumerable<System.Net.IPAddress> ipv4, System.Collections.Generic.IEnumerable<System.Net.IPAddress> ipv6) { }\n            public System.Net.IPAddress Addr { get; }\n            public System.Exception Exception { get; }\n            public System.Collections.Generic.IEnumerable<System.Net.IPAddress> Ipv4 { get; }\n            public System.Collections.Generic.IEnumerable<System.Net.IPAddress> Ipv6 { get; }\n            public bool IsSuccess { get; }\n            public string Name { get; }\n            public static Akka.IO.Dns.Resolved Create(string name, System.Collections.Generic.IEnumerable<System.Net.IPAddress> addresses) { }\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining Eventsourced Abstract Class\nDESCRIPTION: This snippet defines the abstract class `Eventsourced`, the base class for actors that maintain persistent state through event sourcing in Akka.NET Persistence. It inherits from `ActorBase` and implements several interfaces related to stashing, persistence recovery, and persistent identity, defining properties and methods for persisting events, saving snapshots, and recovering from persisted state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\n\"public abstract class Eventsourced : Akka.Actor.ActorBase, Akka.Actor.IActorStash, Akka.Actor.IWithUnboundedStash, Akka.Actor.IWithUnrestrictedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics>, Akka.Persistence.IPersistenceRecovery, Akka.Persistence.IPersistenceStash, Akka.Persistence.IPersistentIdentity\n    {\n        public static readonly System.Func<Akka.Actor.Envelope, bool> UnstashFilterPredicate;\n        protected Eventsourced() { }\n        protected Akka.Persistence.PersistenceExtension Extension { get; }\n        public virtual Akka.Persistence.IStashOverflowStrategy InternalStashOverflowStrategy { get; }\n        public bool IsRecovering { get; }\n        public bool IsRecoveryFinished { get; }\n        public Akka.Actor.IActorRef Journal { get; }\n        public string JournalPluginId { get; set; }\n        public long LastSequenceNr { get; }\n        protected virtual Akka.Event.ILoggingAdapter Log { get; }\n        public abstract string PersistenceId { get; }\n        public virtual Akka.Persistence.Recovery Recovery { get; }\n        public string SnapshotPluginId { get; set; }\n        public long SnapshotSequenceNr { get; }\n        public Akka.Actor.IActorRef SnapshotStore { get; }\n        public string SnapshotterId { get; }\n        public Akka.Actor.IStash Stash { get; set; }\n        public override void AroundPostRestart(System.Exception reason, object message) { }\n        public override void AroundPostStop() { }\n        public override void AroundPreRestart(System.Exception cause, object message) { }\n        public override void AroundPreStart() { }\n        protected override bool AroundReceive(Akka.Actor.Receive receive, object message) { }\n        public void DeferAsync<TEvent>(TEvent evt, System.Action<TEvent> handler) { }\n        public void DeleteMessages(long toSequenceNr) { }\n        public void DeleteSnapshot(long sequenceNr) { }\n        public void DeleteSnapshots(Akka.Persistence.SnapshotSelectionCriteria criteria) { }\n        public void LoadSnapshot(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria, long toSequenceNr) { }\n        protected virtual void OnPersistFailure(System.Exception cause, object @event, long sequenceNr) { }\n        protected virtual void OnPersistRejected(System.Exception cause, object @event, long sequenceNr) { }\n        protected virtual void OnRecoveryFailure(System.Exception reason, object message = null) { }\n        protected virtual void OnReplaySuccess() { }\n        public void Persist<TEvent>(TEvent @event, System.Action<TEvent> handler) { }\n        public void PersistAll<TEvent>(System.Collections.Generic.IEnumerable<TEvent> events, System.Action<TEvent> handler) { }\n        public void PersistAllAsync<TEvent>(System.Collections.Generic.IEnumerable<TEvent> events, System.Action<TEvent> handler) { }\n        public void PersistAsync<TEvent>(TEvent @event, System.Action<TEvent> handler) { }\n        protected abstract bool ReceiveCommand(object message);r\n        protected abstract bool ReceiveRecover(object message);\n        protected void RunTask(System.Func<System.Threading.Tasks.Task> action) { }\n        public void SaveSnapshot(object snapshot) { }\n        protected override void Unhandled(object message) { }\n    }\"\n```\n\n----------------------------------------\n\nTITLE: Implementing TypeExtensions Static Class\nDESCRIPTION: Static extension methods for System.Type to simplify type checking and reflection operations. It provides methods to check if a type implements a given interface or base type.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_221\n\nLANGUAGE: C#\nCODE:\n```\npublic class static TypeExtensions\n{\n    public static bool Implements<T>(this System.Type type) { }\n    public static bool Implements(this System.Type type, System.Type moreGeneralType) { }\n    [Akka.Annotations.InternalApiAttribute()]\n    public static string TypeQualifiedName(this System.Type type) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StandardOutWriter Static Class\nDESCRIPTION: Static utility class for writing formatted output to the console. It provides methods to write messages with optional foreground and background colors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_214\n\nLANGUAGE: C#\nCODE:\n```\npublic class static StandardOutWriter\n{\n    public static void Write(string message, System.Nullable<System.ConsoleColor> foregroundColor = null, System.Nullable<System.ConsoleColor> backgroundColor = null) { }\n    public static void WriteLine(string message, System.Nullable<System.ConsoleColor> foregroundColor = null, System.Nullable<System.ConsoleColor> backgroundColor = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AtomicCounterLong Class in C#\nDESCRIPTION: A thread-safe counter implementation for long values with atomic operations for incrementing, decrementing, and manipulating counter values.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_244\n\nLANGUAGE: C#\nCODE:\n```\npublic class AtomicCounterLong : Akka.Util.Internal.IAtomicCounter<long>\n{\n    public AtomicCounterLong(long value) { }\n    public AtomicCounterLong() { }\n    public long Current { get; }\n    public long AddAndGet(long amount) { }\n    public bool CompareAndSet(long expected, long newValue) { }\n    public long DecrementAndGet() { }\n    public long GetAndAdd(long amount) { }\n    public long GetAndIncrement() { }\n    public long GetAndSet(long value) { }\n    public long IncrementAndGet() { }\n    public long Next() { }\n    public void Reset() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IUpdateResponse Interface for Replicator Responses in C#\nDESCRIPTION: Defines an interface for responses to update operations in the distributed data system, including success status, key information, and error handling capabilities.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IUpdateResponse : Akka.Actor.INoSerializationVerificationNeeded\n{\n    bool IsSuccessful { get; }\n    Akka.DistributedData.IKey Key { get; }\n    object Request { get; }\n    void ThrowOnFailure();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Right<T> Class in C#\nDESCRIPTION: Defines a Right<T> class that represents the right side of an Either monad pattern. It encapsulates a value and provides properties to check if it's the left or right side.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_210\n\nLANGUAGE: C#\nCODE:\n```\npublic class Right<T>\n{\n    public Right(T value) { }\n    public bool IsLeft { get; }\n    public bool IsRight { get; }\n    public T Value { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: HOCON Configuration Elements in C#\nDESCRIPTION: Classes for handling HOCON (Human-Optimized Config Object Notation) configuration format in Akka.NET. Includes implementations for arrays, objects, and literals.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_67\n\nLANGUAGE: C#\nCODE:\n```\npublic class HoconArray : System.Collections.Generic.List<Akka.Configuration.Hocon.HoconValue>, Akka.Configuration.Hocon.IHoconElement\n{\n    public HoconArray() { }\n    public System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray() { }\n    public string GetString() { }\n    public bool IsArray() { }\n    public bool IsString() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Job Management ActorPublisher in C#\nDESCRIPTION: Implements a stream publisher using ActorPublisher that manages job submissions based on demand from subscribers. Includes buffer management and backpressure handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class Job\n{\n    public Job(string payload)\n    {\n        Payload = payload;\n    }\n\n    public string Payload { get; }\n}\n\npublic sealed class JobAccepted\n{\n    public static JobAccepted Instance { get; } = new JobAccepted();\n\n    private JobAccepted() { }\n}\n\npublic sealed class JobDenied\n{\n    public static JobDenied Instance { get; } = new JobDenied();\n\n    private JobDenied() { }\n}\n\npublic class JobManager : Actors.ActorPublisher<Job>\n{\n    public static Props Props { get; } = Props.Create<JobManager>();\n    \n    private List<Job> _buffer;\n    private const int MaxBufferSize = 100;\n\n    public JobManager()\n    {\n        _buffer = new List<Job>();\n    }\n\n    protected override bool Receive(object message)\n    {\n        return message.Match()\n            .With<Job>(job =>\n            {\n                if (_buffer.Count == MaxBufferSize)\n                    Sender.Tell(JobDenied.Instance);\n                else\n                {\n                    Sender.Tell(JobAccepted.Instance);\n                    if (_buffer.Count == 0 && TotalDemand > 0)\n                        OnNext(job);\n                    else\n                    {\n                        _buffer.Add(job);\n                        DeliverBuffer();\n                    }\n                }\n            })\n            .With<Request>(DeliverBuffer)\n            .With<Cancel>(() => Context.Stop(Self))\n            .WasHandled;\n    }\n\n    private void DeliverBuffer()\n    {\n        if (TotalDemand > 0)\n        {\n            // totalDemand is a Long and could be larger than\n            // what _buffer.Take and Skip can accept\n            if (TotalDemand < int.MaxValue)\n            {\n                var use = _buffer.Take((int) TotalDemand).ToList();\n                _buffer = _buffer.Skip((int) TotalDemand).ToList();\n                use.ForEach(OnNext);\n            }\n            else\n            {\n                var use = _buffer.Take(int.MaxValue).ToList();\n                _buffer = _buffer.Skip(int.MaxValue).ToList();\n                use.ForEach(OnNext);\n                DeliverBuffer();\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing InternalActorRefBase Abstract Class in C#\nDESCRIPTION: Defines an abstract base class for internal actor references with various methods and properties for actor lifecycle management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic abstract class InternalActorRefBase : Akka.Actor.ActorRefBase, Akka.Actor.IActorRef, Akka.Actor.IActorRefScope, Akka.Actor.ICanTell, Akka.Actor.IInternalActorRef, Akka.Util.ISurrogated, System.IComparable, System.IComparable<Akka.Actor.IActorRef>, System.IEquatable<Akka.Actor.IActorRef>\n{\n    protected InternalActorRefBase() { }\n    public abstract bool IsLocal { get; }\n    public abstract bool IsTerminated { get; }\n    public abstract Akka.Actor.IInternalActorRef Parent { get; }\n    public abstract Akka.Actor.IActorRefProvider Provider { get; }\n    public abstract Akka.Actor.IActorRef GetChild(System.Collections.Generic.IReadOnlyList<string> name);\n    public abstract void Restart(System.Exception cause);\n    public abstract void Resume(System.Exception causedByFailure = null);\n    [System.ObsoleteAttribute(\"Use SendSystemMessage(message) instead [1.1.0]\")]\n    public void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message, Akka.Actor.IActorRef sender) { }\n    public abstract void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message);\n    public abstract void Start();\n    public abstract void Stop();\n    public abstract void Suspend();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DiscardConfigurator Class\nDESCRIPTION: This snippet defines the `DiscardConfigurator` class, implementing the `IStashOverflowStrategyConfigurator` interface in Akka.Persistence. This configurator is responsible for creating a stash overflow strategy that discards messages when the stash is full. The `Create` method (not shown) likely returns an instance of a `DiscardToDeadLetterStrategy`.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\n\"public sealed class DiscardConfigurator : Akka.Persistence.IStashOverflowStrategyConfigurator\n    {\n        public DiscardConfigurator() { }\n        public Akka.Persistence.IStashOverflowStrategy Create(Akka.Configuration.Config config) { }\n    }\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Order Role in Akka.NET Cluster\nDESCRIPTION: HOCON configuration for setting up a cluster node with the 'order' role, which will handle customer order processing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/member-roles.md#2025-04-16_snippet_3\n\nLANGUAGE: hocon\nCODE:\n```\nakka\n{\n  cluster\n  {\n    roles = [\"order\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: UDP Extension and Message Types in Akka.NET\nDESCRIPTION: This snippet shows the Udp class and its related nested types including commands and events for UDP communication. It defines the core UDP messaging infrastructure for sending and receiving datagrams in Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_170\n\nLANGUAGE: csharp\nCODE:\n```\n    public class Udp : Akka.Actor.ExtensionIdProvider<Akka.IO.UdpExt>\n    {\n        public static readonly Akka.IO.Udp Instance;\n        public Udp() { }\n        public override Akka.IO.UdpExt CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n        public static Akka.Actor.IActorRef Manager(Akka.Actor.ActorSystem system) { }\n        public sealed class Bind : Akka.IO.Udp.Command\n        {\n            public Bind(Akka.Actor.IActorRef handler, System.Net.EndPoint localAddress, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options = null) { }\n            public Akka.Actor.IActorRef Handler { get; }\n            public System.Net.EndPoint LocalAddress { get; }\n            public System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> Options { get; }\n            public override string ToString() { }\n        }\n        public sealed class Bound : Akka.IO.Udp.Event\n        {\n            public Bound(System.Net.EndPoint localAddress) { }\n            public System.Net.EndPoint LocalAddress { get; }\n            public override string ToString() { }\n        }\n        public abstract class Command : Akka.IO.Udp.Message\n        {\n            protected Command() { }\n            public object FailureMessage { get; }\n        }\n        public sealed class CommandFailed : Akka.IO.Udp.Event\n        {\n            public CommandFailed(Akka.IO.Udp.Command cmd) { }\n            public Akka.IO.Udp.Command Cmd { get; }\n            public override string ToString() { }\n        }\n        public abstract class Event : Akka.IO.Udp.Message\n        {\n            protected Event() { }\n        }\n        public abstract class Message : Akka.Actor.INoSerializationVerificationNeeded\n        {\n            protected Message() { }\n        }\n        public sealed class NoAck : Akka.IO.Udp.Event\n        {\n            public static readonly Akka.IO.Udp.NoAck Instance;\n            public NoAck(object token) { }\n            public object Token { get; }\n            public override string ToString() { }\n        }\n        public sealed class Received : Akka.IO.Udp.Event\n        {\n            public Received(Akka.IO.ByteString data, System.Net.EndPoint sender) { }\n            public Akka.IO.ByteString Data { get; }\n            public System.Net.EndPoint Sender { get; }\n            public override string ToString() { }\n        }\n        public sealed class ResumeReading : Akka.IO.Udp.Command\n        {\n            public static readonly Akka.IO.Udp.ResumeReading Instance;\n        }\n        public sealed class SO : Akka.IO.Inet.SoForwarders\n        {\n            public SO() { }\n            public sealed class Broadcast : Akka.IO.Inet.SocketOption\n            {\n                public Broadcast(bool on) { }\n                public bool On { get; }\n                public override void BeforeDatagramBind(System.Net.Sockets.Socket s) { }\n            }\n        }\n        public sealed class Send : Akka.IO.Udp.Command\n        {\n            public Send(Akka.IO.ByteString payload, System.Net.EndPoint target, Akka.IO.Udp.Event ack) { }\n            public Akka.IO.Udp.Event Ack { get; }\n            public Akka.IO.ByteString Payload { get; }\n            public System.Net.EndPoint Target { get; }\n            public bool WantsAck { get; }\n            public static Akka.IO.Udp.Send Create(Akka.IO.ByteString data, System.Net.EndPoint target) { }\n            public override string ToString() { }\n        }\n        public sealed class SimpleSender : Akka.IO.Udp.Command\n        {\n            public static readonly Akka.IO.Udp.SimpleSender Instance;\n            public SimpleSender(System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options = null) { }\n            public System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> Options { get; }\n        }\n        public sealed class SimpleSenderReady : Akka.IO.Udp.Event\n        {\n            public static readonly Akka.IO.Udp.SimpleSenderReady Instance;\n        }\n        public sealed class SuspendReading : Akka.IO.Udp.Command\n        {\n            public static readonly Akka.IO.Udp.SuspendReading Instance;\n        }\n        public sealed class Unbind : Akka.IO.Udp.Command\n        {\n            public static readonly Akka.IO.Udp.Unbind Instance;\n        }\n        public sealed class Unbound\n        {\n            public static readonly Akka.IO.Udp.Unbound Instance;\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Abstract Lease Class Definition in C#\nDESCRIPTION: Defines the abstract Lease class for acquiring, checking, and releasing distributed leases. Provides the base functionality for lease-based coordination implementations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Lease\n{\n    public Lease(Akka.Coordination.LeaseSettings settings) { }\n    public Akka.Coordination.LeaseSettings Settings { get; }\n    public abstract System.Threading.Tasks.Task<bool> Acquire();\n    public abstract System.Threading.Tasks.Task<bool> Acquire(System.Action<System.Exception> leaseLostCallback);\n    public abstract bool CheckLease();\n    public abstract System.Threading.Tasks.Task<bool> Release();\n}\n```\n\n----------------------------------------\n\nTITLE: ByteString Digest Calculator Using GraphStage in C#\nDESCRIPTION: Implements a custom GraphStage to calculate cryptographic digests of ByteString streams using HashAlgorithm.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/cookbook.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DigestCalculator : GraphStage<FlowShape<ByteString, ByteString>>\n{\n    private readonly string _algorithm;\n\n    private sealed class Logic : GraphStageLogic\n    {\n        private readonly HashAlgorithm _digest;\n        private ByteString _bytes;\n\n        public Logic(DigestCalculator calculator) : base(calculator.Shape)\n        {\n            _digest = HashAlgorithm.Create(calculator._algorithm);\n            _bytes = ByteString.Empty;\n\n            SetHandler(calculator.Out, onPull: () => { Pull(calculator.In); });\n\n            SetHandler(calculator.In, onPush: () =>\n            {\n                _bytes += Grab(calculator.In);\n                Pull(calculator.In);\n            }, onUpstreamFinish: () =>\n            {\n                Emit(calculator.Out, ByteString.Create(_digest.ComputeHash(_bytes.ToArray())));\n                CompleteStage();\n            });\n        }\n    }\n\n    public DigestCalculator(string algorithm)\n    {\n        _algorithm = algorithm;\n        Shape = new FlowShape<ByteString, ByteString>(In, Out);\n    }\n\n    public Inlet<ByteString> In { get; } = new Inlet<ByteString>(\"DigestCalculator.in\");\n\n    public Outlet<ByteString> Out { get; } = new Outlet<ByteString>(\"DigestCalculator.out\");\n\n    public override FlowShape<ByteString, ByteString> Shape { get; }\n\n    protected override GraphStageLogic CreateLogic(Attributes inheritedAttributes) => new Logic(this);\n}\n  \nvar data = Source.Empty<ByteString>();\nvar digest = data.Via(new DigestCalculator(\"SHA-256\"));\n```\n\n----------------------------------------\n\nTITLE: Defining Routee and Routees Classes in Akka.NET\nDESCRIPTION: Defines the Routee class which represents a destination for routed messages, along with the Routees collection class that manages multiple routee instances. Includes methods for sending messages and asking for responses.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_208\n\nLANGUAGE: C#\nCODE:\n```\npublic Routee() { }\npublic virtual System.Threading.Tasks.Task<object> Ask(object message, System.Nullable<System.TimeSpan> timeout) { }\npublic static Akka.Routing.Routee FromActorRef(Akka.Actor.IActorRef actorRef) { }\npublic virtual void Send(object message, Akka.Actor.IActorRef sender) { }\n\npublic sealed class Routees\n{\n    public Routees(System.Collections.Generic.IEnumerable<Akka.Routing.Routee> routees) { }\n    public System.Collections.Generic.IEnumerable<Akka.Routing.Routee> Members { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dispatchers Registry in C#\nDESCRIPTION: A registry for message dispatchers in the Akka.NET system. This class manages the lookup, registration, and configuration of dispatchers, including default dispatchers. It provides methods to verify dispatcher existence and retrieve dispatcher instances.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_86\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class Dispatchers\n{\n    public const string DefaultBlockingDispatcherId = \"akka.actor.default-blocking-io-dispatcher\";\n    public const string DefaultDispatcherId = \"akka.actor.default-dispatcher\";\n    public const string SynchronizedDispatcherId = \"akka.actor.synchronized-dispatcher\";\n    public Dispatchers(Akka.Actor.ActorSystem system, Akka.Dispatch.IDispatcherPrerequisites prerequisites, Akka.Event.ILoggingAdapter logger) { }\n    public Akka.Configuration.Config DefaultDispatcherConfig { get; }\n    public Akka.Dispatch.MessageDispatcher DefaultGlobalDispatcher { get; }\n    public Akka.Dispatch.IDispatcherPrerequisites Prerequisites { get; }\n    [Akka.Annotations.InternalApiAttribute()]\n    public static Akka.Configuration.Config GetConfig(Akka.Configuration.Config config, string id, int depth = 0) { }\n    public bool HasDispatcher(string id) { }\n    public Akka.Dispatch.MessageDispatcher Lookup(string dispatcherName) { }\n    public bool RegisterConfigurator(string id, Akka.Dispatch.MessageDispatcherConfigurator configurator) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Using UniqueKillSwitch for Abort in Akka.NET Streams\nDESCRIPTION: Example of using UniqueKillSwitch to control the completion of a single materialized Graph of FlowShape. This snippet demonstrates aborting the stream.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/stream-dynamic.md#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[!code-csharp[KillSwitchDocTests.cs](../../../src/core/Akka.Docs.Tests/Streams/KillSwitchDocTests.cs?name=unique-abort)]\n```\n\n----------------------------------------\n\nTITLE: Implementing IDependencyResolver for CastleWindsor in C#\nDESCRIPTION: This code snippet shows the implementation of the WindsorDependencyResolver class, which implements the IDependencyResolver interface for use with the CastleWindsor container in Akka.NET. It includes methods for resolving actor types, creating actor factories, and managing actor lifecycles.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/di-core.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class WindsorDependencyResolver : IDependencyResolver\n{\n    private IWindsorContainer container;\n    private ConcurrentDictionary<string, Type> typeCache;\n    private ActorSystem system;\n\n    public WindsorDependencyResolver(IWindsorContainer container, ActorSystem system)\n    {\n        if (system == null) throw new ArgumentNullException(\"system\");\n        if (container == null) throw new ArgumentNullException(\"container\");\n        this.container = container;\n        typeCache = new ConcurrentDictionary<string, Type>(StringComparer.InvariantCultureIgnoreCase);\n        this.system = system;\n        this.system.AddDependencyResolver(this);\n    }\n\n    public Type GetType(string actorName)\n    {\n        typeCache.TryAdd(actorName, actorName.GetTypeValue() ??\n            container.Kernel\n              .GetAssignableHandlers(typeof(object))\n              .Where(handler => handler.ComponentModel.Name.Equals(actorName, StringComparison.InvariantCultureIgnoreCase))\n              .Select(handler => handler.ComponentModel.Implementation)\n              .FirstOrDefault());\n\n        return typeCache[actorName];\n    }\n\n    public Func<ActorBase> CreateActorFactory(Type actorType)\n    {\n        return () => (ActorBase)container.Resolve(actorType);\n    }\n\n    public Props Create<TActor>() where TActor : ActorBase\n    {\n        return system.GetExtension<DIExt>().Props(typeof(TActor));\n    }\n\n    public void Release(ActorBase actor)\n    {\n        this.container.Release(actor);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IAtomicState Interface in C#\nDESCRIPTION: Interface for managing thread-safe state transitions with listener notifications and synchronized execution of operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_247\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IAtomicState\n{\n    bool HasListeners { get; }\n    void AddListener(System.Action listener);\n    void Enter();\n    System.Threading.Tasks.Task<T> Invoke<T>(System.Func<System.Threading.Tasks.Task<T>> body);\n}\n```\n\n----------------------------------------\n\nTITLE: Task Parallel Library Integration with Akka.NET\nDESCRIPTION: Example of integrating TPL async operations with Akka.NET actors using pipeTo function for file reading operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.FSharp/README.md#2025-04-16_snippet_10\n\nLANGUAGE: F#\nCODE:\n```\nopen System.IO\n    let handler (mailbox: Actor<obj>) msg =\n        match box msg with\n        | :? FileInfo as fi ->\n            let reader = new StreamReader(fi.OpenRead())\n            Async.AwaitTask (reader.ReadToEndAsync()) |!> mailbox.Self\n        | :? string as content ->\n            printfn \"File content: %s\" content\n        | _ -> mailbox.Unhandled()\n\n    let aref = spawn system \"my-actor\" (actorOf2 handler)\n    aref <! new FileInfo \"Akka.xml\"\n```\n\n----------------------------------------\n\nTITLE: VectorClock Class Definition\nDESCRIPTION: This snippet defines a sealed class `VectorClock` for tracking causality in a distributed system. It stores versions for each node and provides methods for comparing clocks, incrementing the clock for a specific node, and determining if one clock is before, after, or concurrent with another.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_23\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class VectorClock\n{\n    public System.Collections.Immutable.ImmutableSortedDictionary<Akka.Cluster.VectorClock.Node, long> Versions { get; }\n    public Akka.Cluster.VectorClock.Ordering CompareTo(Akka.Cluster.VectorClock that) { }\n    public static Akka.Cluster.VectorClock Create() { }\n    public static Akka.Cluster.VectorClock Create(System.Collections.Immutable.ImmutableSortedDictionary<Akka.Cluster.VectorClock.Node, long> seedValues) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public Akka.Cluster.VectorClock Increment(Akka.Cluster.VectorClock.Node node) { }\n    public bool IsAfter(Akka.Cluster.VectorClock that) { }\n    public bool IsBefore(Akka.Cluster.VectorClock that) { }\n    public bool IsConcurrentWith(Akka.Cluster.VectorClock that) { }\n    public bool IsSameAs(Akka.Cluster.VectorClock that) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing HoconTokenizer Class in C#\nDESCRIPTION: The HoconTokenizer class extends the base Tokenizer to provide HOCON-specific tokenization capabilities. It includes methods for identifying and pulling different token types such as arrays, objects, assignments, and comments.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_70\n\nLANGUAGE: C#\nCODE:\n```\npublic class HoconTokenizer : Akka.Configuration.Hocon.Tokenizer\n{\n    public HoconTokenizer(string text) { }\n    public bool IsArrayEnd() { }\n    public bool IsArrayStart() { }\n    public bool IsAssignment() { }\n    public bool IsComma() { }\n    public bool IsDot() { }\n    public bool IsEndOfObject() { }\n    public bool IsInclude() { }\n    public bool IsObjectStart() { }\n    public bool IsSpaceOrTab() { }\n    public bool IsStartOfComment() { }\n    public bool IsStartOfQuotedText() { }\n    public bool IsStartOfTripleQuotedText() { }\n    public bool IsStartSimpleValue() { }\n    public bool IsSubstitutionStart() { }\n    public bool IsUnquotedKey() { }\n    public bool IsUnquotedKeyStart() { }\n    public bool IsWhitespace() { }\n    public bool IsWhitespaceOrComment() { }\n    public Akka.Configuration.Hocon.Token PullArrayEnd() { }\n    public Akka.Configuration.Hocon.Token PullArrayStart() { }\n    public Akka.Configuration.Hocon.Token PullAssignment() { }\n    public Akka.Configuration.Hocon.Token PullComma() { }\n    public Akka.Configuration.Hocon.Token PullComment() { }\n    public Akka.Configuration.Hocon.Token PullDot() { }\n    public Akka.Configuration.Hocon.Token PullEndOfObject() { }\n    public Akka.Configuration.Hocon.Token PullInclude() { }\n    public Akka.Configuration.Hocon.Token PullNext() { }\n    public Akka.Configuration.Hocon.Token PullQuotedKey() { }\n    public Akka.Configuration.Hocon.Token PullQuotedText() { }\n    public string PullRestOfLine() { }\n    public Akka.Configuration.Hocon.Token PullSimpleValue() { }\n    public Akka.Configuration.Hocon.Token PullSpaceOrTab() { }\n    public Akka.Configuration.Hocon.Token PullStartOfObject() { }\n    public Akka.Configuration.Hocon.Token PullSubstitution() { }\n    public Akka.Configuration.Hocon.Token PullTripleQuotedText() { }\n    public Akka.Configuration.Hocon.Token PullUnquotedKey() { }\n    public Akka.Configuration.Hocon.Token PullValue() { }\n    public void PullWhitespaceAndComments() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Message Writing Classes in C#\nDESCRIPTION: Defines classes for handling message writing operations in Akka.NET persistence, including success, failure, and rejection scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class WriteMessageSuccess : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IJournalMessage, Akka.Persistence.IJournalResponse, Akka.Persistence.IPersistenceMessage, System.IEquatable<Akka.Persistence.WriteMessageSuccess>\n{\n    public WriteMessageSuccess(Akka.Persistence.IPersistentRepresentation persistent, int actorInstanceId) { }\n    public int ActorInstanceId { get; }\n    public Akka.Persistence.IPersistentRepresentation Persistent { get; }\n    public bool Equals(Akka.Persistence.WriteMessageSuccess other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SingleVersionVector in Akka.NET Distributed Data\nDESCRIPTION: This class implements a single-node version vector for Akka.NET's Distributed Data module. It provides methods for incrementing, merging, and pruning version vectors, as well as querying version information for specific nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\n[System.Diagnostics.DebuggerDisplayAttribute(\"VersionVector({Node}->{Version})\")]\npublic sealed class SingleVersionVector : Akka.DistributedData.VersionVector\n{\n    public SingleVersionVector(Akka.Cluster.UniqueAddress node, long version) { }\n    public override int Count { get; }\n    public override bool IsEmpty { get; }\n    public override System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.UniqueAddress> ModifiedByNodes { get; }\n    public override System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<Akka.Cluster.UniqueAddress, long>> VersionEnumerator { get; }\n    public override bool Contains(Akka.Cluster.UniqueAddress node) { }\n    public override int GetHashCode() { }\n    public override Akka.DistributedData.VersionVector Increment(Akka.Cluster.UniqueAddress node) { }\n    public override Akka.DistributedData.VersionVector Merge(Akka.DistributedData.VersionVector other) { }\n    public override bool NeedPruningFrom(Akka.Cluster.UniqueAddress removedNode) { }\n    public override Akka.DistributedData.VersionVector Prune(Akka.Cluster.UniqueAddress removedNode, Akka.Cluster.UniqueAddress collapseInto) { }\n    public override Akka.DistributedData.VersionVector PruningCleanup(Akka.Cluster.UniqueAddress removedNode) { }\n    public override string ToString() { }\n    public override long VersionAt(Akka.Cluster.UniqueAddress node) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Remote Transport Abstract Class in C#\nDESCRIPTION: Abstract base class for implementing remote transport functionality in Akka.NET. Provides core methods for message sending and system management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class RemoteTransport\n{\n    protected RemoteTransport(Akka.Actor.ExtendedActorSystem system, Akka.Remote.RemoteActorRefProvider provider) { }\n    public abstract System.Collections.Generic.ISet<Akka.Actor.Address> Addresses { get; }\n    public abstract Akka.Actor.Address DefaultAddress { get; }\n    // ... additional members\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Inbox Interface in C#\nDESCRIPTION: Implementation of the Inbox class for testing and external actor system interaction, providing synchronous and asynchronous message handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\npublic class Inbox : Akka.Actor.ICanWatch, Akka.Actor.IInboxable, System.IDisposable\n{\n    public Akka.Actor.IActorRef Receiver { get; }\n    public static Akka.Actor.Inbox Create(Akka.Actor.ActorSystem system) { }\n    public void Dispose() { }\n    protected virtual void Dispose(bool disposing) { }\n    public object Receive() { }\n    public object Receive(System.TimeSpan timeout) { }\n    public System.Threading.Tasks.Task<object> ReceiveAsync() { }\n    public System.Threading.Tasks.Task<object> ReceiveAsync(System.TimeSpan timeout) { }\n    public object ReceiveWhere(System.Predicate<object> predicate) { }\n    public object ReceiveWhere(System.Predicate<object> predicate, System.TimeSpan timeout) { }\n    public void Send(Akka.Actor.IActorRef actorRef, object message) { }\n    public Akka.Actor.IActorRef Unwatch(Akka.Actor.IActorRef subject) { }\n    public Akka.Actor.IActorRef Watch(Akka.Actor.IActorRef subject) { }\n    public Akka.Actor.IActorRef WatchWith(Akka.Actor.IActorRef subject, object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FailureInjectorTransportAdapter in C#\nDESCRIPTION: A transport adapter for injecting failures in Akka.NET remote communication. It provides methods for intercepting associations, listening, and handling management commands.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic class FailureInjectorTransportAdapter : Akka.Remote.Transport.AbstractTransportAdapter, Akka.Remote.Transport.IAssociationEventListener\n{\n    public readonly Akka.Actor.ExtendedActorSystem ExtendedActorSystem;\n    public const string FailureInjectorSchemeIdentifier = \"gremlin\";\n    protected int MaximumOverhead;\n    public FailureInjectorTransportAdapter(Akka.Remote.Transport.Transport wrappedTransport, Akka.Actor.ExtendedActorSystem extendedActorSystem) { }\n    protected override Akka.Remote.Transport.SchemeAugmenter SchemeAugmenter { get; }\n    protected override void InterceptAssociate(Akka.Actor.Address remoteAddress, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.AssociationHandle> statusPromise) { }\n    protected override System.Threading.Tasks.Task<Akka.Remote.Transport.IAssociationEventListener> InterceptListen(Akka.Actor.Address listenAddress, System.Threading.Tasks.Task<Akka.Remote.Transport.IAssociationEventListener> listenerTask) { }\n    public override System.Threading.Tasks.Task<bool> ManagementCommand(object message) { }\n    public void Notify(Akka.Remote.Transport.IAssociationEvent ev) { }\n    public bool ShouldDropInbound(Akka.Actor.Address remoteAddress, object instance, string debugMessage) { }\n    public bool ShouldDropOutbound(Akka.Actor.Address remoteAddress, object instance, string debugMessage) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UntypedPersistentActor Class in C#\nDESCRIPTION: Abstract class for untyped persistent actors in Akka.NET. Provides base implementation for command and recovery message handling with event sourcing support.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class UntypedPersistentActor : Akka.Persistence.Eventsourced\n{\n    protected UntypedPersistentActor() { }\n    protected static Akka.Actor.IUntypedActorContext Context { get; }\n    protected void Become(Akka.Actor.UntypedReceive receive) { }\n    protected void BecomeStacked(Akka.Actor.UntypedReceive receive) { }\n    protected abstract void OnCommand(object message);\n    protected abstract void OnRecover(object message);\n    protected override bool Receive(object message) { }\n    protected virtual bool ReceiveCommand(object message) { }\n    protected virtual bool ReceiveRecover(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TuningParameters Class for Akka.NET Cluster Sharding\nDESCRIPTION: Defines configuration parameters for tuning Akka.NET cluster sharding behavior including timeouts, backoff settings, and allocation limits. Includes constructor and fluent configuration methods.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Net.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic readonly int CoordinatorStateWriteMajorityPlus;\npublic readonly System.TimeSpan EntityRecoveryConstantRateStrategyFrequency;\npublic readonly int EntityRecoveryConstantRateStrategyNumberOfEntities;\npublic readonly string EntityRecoveryStrategy;\npublic readonly System.TimeSpan EntityRestartBackoff;\npublic readonly System.TimeSpan HandOffTimeout;\npublic readonly int KeepNrOfBatches;\npublic readonly int LeastShardAllocationAbsoluteLimit;\npublic readonly int LeastShardAllocationMaxSimultaneousRebalance;\npublic readonly int LeastShardAllocationRebalanceThreshold;\npublic readonly double LeastShardAllocationRelativeLimit;\npublic readonly System.TimeSpan RebalanceInterval;\npublic readonly System.TimeSpan RetryInterval;\npublic readonly System.TimeSpan ShardFailureBackoff;\npublic readonly System.TimeSpan ShardStartTimeout;\npublic readonly int SnapshotAfter;\npublic readonly System.TimeSpan UpdatingStateTimeout;\npublic readonly System.TimeSpan WaitingForStateTimeout;\n```\n\n----------------------------------------\n\nTITLE: Defining ILoggingAdapter Interface in C#\nDESCRIPTION: An interface for logging adapters that provides methods to check log level enablement and to log messages with different severity levels.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_130\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ILoggingAdapter\n{\n    Akka.Event.ILogMessageFormatter Formatter { get; }\n    bool IsDebugEnabled { get; }\n    bool IsErrorEnabled { get; }\n    bool IsInfoEnabled { get; }\n    bool IsWarningEnabled { get; }\n    bool IsEnabled(Akka.Event.LogLevel logLevel);\n    void Log(Akka.Event.LogLevel logLevel, System.Exception cause, string format);\n    void Log(Akka.Event.LogLevel logLevel, System.Exception cause, Akka.Event.LogMessage message);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining message types for DistributedPubSub in C#\nDESCRIPTION: Implements various message types used in the distributed pub-sub system, including Publish, Subscribe, Unsubscribe, and their acknowledgments. These classes define the structure of messages exchanged in the pub-sub operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Publish : Akka.Actor.IWrappedMessage, Akka.Cluster.Tools.PublishSubscribe.IDistributedPubSubMessage, System.IEquatable<Akka.Cluster.Tools.PublishSubscribe.Publish>\n{\n    public Publish(string topic, object message, bool sendOneMessageToEachGroup = False) { }\n    public object Message { get; }\n    public bool SendOneMessageToEachGroup { get; }\n    public string Topic { get; }\n    public bool Equals(Akka.Cluster.Tools.PublishSubscribe.Publish other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n\npublic sealed class Subscribe : System.IEquatable<Akka.Cluster.Tools.PublishSubscribe.Subscribe>\n{\n    public Subscribe(string topic, Akka.Actor.IActorRef @ref, string group = null) { }\n    public string Group { get; }\n    public Akka.Actor.IActorRef Ref { get; }\n    public string Topic { get; }\n    public bool Equals(Akka.Cluster.Tools.PublishSubscribe.Subscribe other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n\npublic sealed class Unsubscribe : System.IEquatable<Akka.Cluster.Tools.PublishSubscribe.Unsubscribe>\n{\n    public Unsubscribe(string topic, Akka.Actor.IActorRef @ref, string group = null) { }\n    public string Group { get; }\n    public Akka.Actor.IActorRef Ref { get; }\n    public string Topic { get; }\n    public bool Equals(Akka.Cluster.Tools.PublishSubscribe.Unsubscribe other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IKey Interface for Distributed Data in C#\nDESCRIPTION: Defines the IKey interface which extends IReplicatedDataSerialization and provides an Id property. This interface is used to identify replicated data in Akka.DistributedData.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IKey : Akka.DistributedData.IReplicatedDataSerialization\n{\n    string Id { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Shared Actor and Message Types for Remote Deployment in C#\nDESCRIPTION: Defines a shared EchoActor and Hello message type that will be used by both the deployer and target systems. The actor simply echoes back any Hello message it receives while printing the sender information.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/remoting/deployment.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n/*\n * Create an actor and a message type that gets shared between Deployer and DeployTarget\n * in a common DLL\n */\n/// <summary>\n/// Actor that just replies the message that it received earlier\n/// </summary>\npublic class EchoActor : ReceiveActor\n{\n    public EchoActor()\n    {\n        Receive<Hello>(hello =>\n        {\n            Console.WriteLine(\"[{0}]: {1}\", Sender, hello.Message);\n            Sender.Tell(hello);\n        });\n    }\n}\n\npublic class Hello\n{\n    public Hello(string message)\n    {\n        Message = message;\n    }\n\n    public string Message { get; private set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Switch State Pattern in C#\nDESCRIPTION: Defines a Switch class that implements a thread-safe on/off state with various methods to check, change, or execute actions based on the current state. This is useful for controlling features or functionality with a simple binary state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_255\n\nLANGUAGE: C#\nCODE:\n```\npublic class Switch\n{\n    public Switch(bool startAsOn = False) { }\n    public bool IsOff { get; }\n    public bool IsOn { get; }\n    public bool IfOff(System.Action action) { }\n    public bool IfOn(System.Action action) { }\n    public void Locked(System.Action action) { }\n    public bool SwitchOff(System.Action action) { }\n    public bool SwitchOff() { }\n    public bool SwitchOn(System.Action action) { }\n    public bool SwitchOn() { }\n    protected bool TranscendFrom(bool from, System.Action action) { }\n    public bool WhileOff(System.Action action) { }\n    public bool WhileOn(System.Action action) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NormalChildrenContainer Class in C#\nDESCRIPTION: Container implementation for child actors in normal operation state. Provides methods for managing the child actor hierarchy.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_59\n\nLANGUAGE: C#\nCODE:\n```\npublic class NormalChildrenContainer : Akka.Actor.Internal.ChildrenContainerBase\n{\n    public override Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats) { }\n    public static Akka.Actor.Internal.IChildrenContainer Create(System.Collections.Immutable.IImmutableDictionary<string, Akka.Actor.Internal.IChildStats> children) { }\n    public override Akka.Actor.Internal.IChildrenContainer Remove(Akka.Actor.IActorRef child) { }\n    public override Akka.Actor.Internal.IChildrenContainer Reserve(string name) { }\n    public override Akka.Actor.Internal.IChildrenContainer ShallDie(Akka.Actor.IActorRef actor) { }\n    public override string ToString() { }\n    public override Akka.Actor.Internal.IChildrenContainer Unreserve(string name) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LogEvent Abstract Base Class in C#\nDESCRIPTION: An abstract base class for all log events that provides common properties like timestamp, thread, message, and source information. It defines the interface for log level determination.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_133\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class LogEvent : Akka.Actor.INoSerializationVerificationNeeded\n{\n    protected LogEvent() { }\n    public System.Exception Cause { get; set; }\n    public System.Type LogClass { get; set; }\n    public string LogSource { get; set; }\n    public object Message { get; set; }\n    public System.Threading.Thread Thread { get; }\n    public System.DateTime Timestamp { get; }\n    public abstract Akka.Event.LogLevel LogLevel();\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TCP WriteCommand Class Methods in C#\nDESCRIPTION: Defines methods for the TCP WriteCommand abstract class including Ack property, WantsAck property, and methods for manipulating command instances. These methods are essential for TCP write operations in Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_163\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract Akka.IO.Tcp.Event Ack { get; }\npublic bool WantsAck { get; }\npublic Akka.IO.Tcp.CompoundWrite Append(Akka.IO.Tcp.WriteCommand that) { }\n```\n\n----------------------------------------\n\nTITLE: Defining EventEnvelope class in C# for Akka.NET Persistence Query\nDESCRIPTION: Implements the EventEnvelope class which represents an event in the persistence query system. It contains properties for offset, persistence ID, sequence number, event data, and timestamp.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceQuery.Core.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class EventEnvelope : System.IEquatable<Akka.Persistence.Query.EventEnvelope>\n{\n    [System.ObsoleteAttribute(\"For binary compatibility with previous releases\")]\n    public EventEnvelope(Akka.Persistence.Query.Offset offset, string persistenceId, long sequenceNr, object @event) { }\n    public EventEnvelope(Akka.Persistence.Query.Offset offset, string persistenceId, long sequenceNr, object @event, long timestamp) { }\n    public object Event { get; }\n    public Akka.Persistence.Query.Offset Offset { get; }\n    public string PersistenceId { get; }\n    public long SequenceNr { get; }\n    public long Timestamp { get; }\n    public bool Equals(Akka.Persistence.Query.EventEnvelope other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EqualsStringAndPathMatcher Class in Akka.NET TestKit\nDESCRIPTION: A specialized string matcher for comparing file paths, with an option to handle relative paths. This matcher implements IStringMatcher and is designed specifically for path-based string comparisons.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_45\n\nLANGUAGE: C#\nCODE:\n```\npublic class EqualsStringAndPathMatcher : Akka.TestKit.Internal.StringMatcher.IStringMatcher\n{\n    public EqualsStringAndPathMatcher(string path, bool canBeRelative = True) { }\n    public bool IsMatch(string path) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing Cluster Messages Using Akka.NET C#\nDESCRIPTION: The `ClusterMessageSerializer` class extends Akka's `SerializerWithStringManifest` to handle serialization of cluster-specific messages. This ensures efficient message serialization/deserialization within distributed systems. Requires `Akka.Serialization` namespace.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.DotNet.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()] public class ClusterMessageSerializer : Akka.Serialization.SerializerWithStringManifest { public ClusterMessageSerializer(Akka.Actor.ExtendedActorSystem system) { } public override object FromBinary(byte[] bytes, string manifest) { } public override string Manifest(object o) { } public override byte[] ToBinary(object obj) { } }\n```\n\n----------------------------------------\n\nTITLE: CircuitBreaker Method Implementations in C#\nDESCRIPTION: Defines core circuit breaker functionality including state management and execution patterns. Includes methods for handling open, half-open states and exponential backoff.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_176\n\nLANGUAGE: C#\nCODE:\n```\npublic Akka.Pattern.CircuitBreaker OnHalfOpen(System.Action callback) { }\npublic Akka.Pattern.CircuitBreaker OnOpen(System.Action callback) { }\npublic void Succeed() { }\npublic System.Threading.Tasks.Task<T> WithCircuitBreaker<T>(System.Func<System.Threading.Tasks.Task<T>> body) { }\n```\n\n----------------------------------------\n\nTITLE: Handling Cyclic Dependencies in Graph - Akka.Net\nDESCRIPTION: This code snippet handles cyclic dependencies in graphs using Akka.Net's Graph DSL. The example demonstrates a scenario that results in a deadlock due to feedback arcs causing the materialized task to be stuck indefinitely. The cycle prevents the aggregate operation from completing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithgraphs.md#2025-04-16_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\nvar cyclicAggregate = Source.FromGraph(GraphDsl.Create(Sink.Aggregate<int, int>(0, (sum, i) => sum + i),\n    (b, aggregate) =>\n    {\n        // - Aggregate cannot complete until its upstream SelectAsync completes\n        // - SelectAsync cannot complete until the materialized Task produced by\n        //   Aggregate completes\n        // As a result this Source will never emit anything, and its materialized\n        // Task will never complete\n        var flow = Flow.Create<Task<int>>().SelectAsync(4, x => x);\n        b.From(b.MaterializedValue).Via(flow).To(aggregate);\n        return new SourceShape<int>(b.From(b.MaterializedValue).Via(flow).Out);\n    }));\n```\n\n----------------------------------------\n\nTITLE: Implementing PreRestartException in Akka.NET\nDESCRIPTION: Defines the PreRestartException class, which is thrown before an actor is restarted. It includes information about the actor, the restart exception, and an optional message.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\npublic class PreRestartException : Akka.Actor.ActorInitializationException\n{\n    public PreRestartException(Akka.Actor.IActorRef actor, System.Exception restartException, System.Exception cause, object optionalMessage) { }\n    protected PreRestartException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n    public object OptionalMessage { get; }\n    public System.Exception RestartException { get; }\n    public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Protobuf Serialization for AdaptiveLoadBalancingPool in Akka.NET\nDESCRIPTION: Defines a serialization class for adaptive load balancing pools using Google Protobuf. This class handles serialization of router configuration including metrics selectors and dispatcher settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class AdaptiveLoadBalancingPool : Google.Protobuf.IDeepCloneable<Akka.Cluster.Metrics.Serialization.AdaptiveLoadBalancingPool>, Google.Protobuf.IMessage, Google.Protobuf.IMessage<Akka.Cluster.Metrics.Serialization.AdaptiveLoadBalancingPool>, System.IEquatable<Akka.Cluster.Metrics.Serialization.AdaptiveLoadBalancingPool>\n{\n    public const int MetricsSelectorFieldNumber = 1;\n    public const int NrOfInstancesFieldNumber = 2;\n    public const int RouterDispatcherFieldNumber = 3;\n    public const int UsePoolDispatcherFieldNumber = 4;\n    public AdaptiveLoadBalancingPool() { }\n    public AdaptiveLoadBalancingPool(Akka.Cluster.Metrics.Serialization.AdaptiveLoadBalancingPool other) { }\n    public static Google.Protobuf.Reflection.MessageDescriptor Descriptor { get; }\n    public Akka.Cluster.Metrics.Serialization.MetricsSelector MetricsSelector { get; set; }\n    public uint NrOfInstances { get; set; }\n    public static Google.Protobuf.MessageParser<Akka.Cluster.Metrics.Serialization.AdaptiveLoadBalancingPool> Parser { get; }\n    public string RouterDispatcher { get; set; }\n    public bool UsePoolDispatcher { get; set; }\n    public int CalculateSize() { }\n    public Akka.Cluster.Metrics.Serialization.AdaptiveLoadBalancingPool Clone() { }\n    public override bool Equals(object other) { }\n    public bool Equals(Akka.Cluster.Metrics.Serialization.AdaptiveLoadBalancingPool other) { }\n    public override int GetHashCode() { }\n    public void MergeFrom(Akka.Cluster.Metrics.Serialization.AdaptiveLoadBalancingPool other) { }\n    public void MergeFrom(Google.Protobuf.CodedInputStream input) { }\n    public override string ToString() { }\n    public void WriteTo(Google.Protobuf.CodedOutputStream output) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Offset Classes in C#\nDESCRIPTION: Defines abstract Offset class and its implementations: NoOffset, Sequence, and TimeBasedUuid. These classes represent different types of offsets used in event querying and implement IComparable<Offset>.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceQuery.Net.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Offset : System.IComparable<Akka.Persistence.Query.Offset>\n{\n    protected Offset() { }\n    public abstract int CompareTo(Akka.Persistence.Query.Offset other);\n    public static Akka.Persistence.Query.Offset NoOffset() { }\n    public static Akka.Persistence.Query.Offset Sequence(long value) { }\n    public static Akka.Persistence.Query.Offset TimeBasedUuid(System.Guid value) { }\n    public virtual string ToString() { }\n}\n\npublic sealed class NoOffset : Akka.Persistence.Query.Offset\n{\n    public static Akka.Persistence.Query.NoOffset Instance { get; }\n    public override int CompareTo(Akka.Persistence.Query.Offset other) { }\n    public override string ToString() { }\n}\n\n// ... Sequence and TimeBasedUuid classes\n```\n\n----------------------------------------\n\nTITLE: Removing Network Partitions with TestConductor.PassThrough in Akka.NET\nDESCRIPTION: Removes a previously created network partition between two nodes using TestConductor.PassThrough, allowing Akka.Remote to resume normal network communication. The code runs on a specific node and uses a barrier for synchronization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/testing/multi-node-testing.md#2025-04-16_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nRunOn(() =>\n{\n    TestConductor.PassThrough(_config.First, _config.Second, \n        ThrottleTransportAdapter.Direction.Both).Wait();\n}, _config.First);\nEnterBarrier(\"repair-2\");\n```\n\n----------------------------------------\n\nTITLE: Defining IPersistentRepresentation interface in C#\nDESCRIPTION: This interface represents a persistent message in Akka.NET. It includes properties for various attributes of the message and methods for updating and modifying the representation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IPersistentRepresentation : Akka.Persistence.Serialization.IMessage\n{\n    bool IsDeleted { get; }\n    string Manifest { get; }\n    object Payload { get; }\n    string PersistenceId { get; }\n    Akka.Actor.IActorRef Sender { get; }\n    long SequenceNr { get; }\n    long Timestamp { get; }\n    string WriterGuid { get; }\n    Akka.Persistence.IPersistentRepresentation Update(long sequenceNr, string persistenceId, bool isDeleted, Akka.Actor.IActorRef sender, string writerGuid);\n    Akka.Persistence.IPersistentRepresentation WithManifest(string manifest);\n    Akka.Persistence.IPersistentRepresentation WithPayload(object payload);\n    Akka.Persistence.IPersistentRepresentation WithTimestamp(long timestamp);\n}\n```\n\n----------------------------------------\n\nTITLE: SQL Journal Base Implementation in C#\nDESCRIPTION: Abstract class SqlJournal that implements AsyncWriteJournal with methods for reading/writing persistent messages and managing database connections. Handles message replay, deletion and sequence tracking.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.DotNet.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class SqlJournal : Akka.Persistence.Journal.AsyncWriteJournal, Akka.Actor.IActorStash, Akka.Actor.IWithUnboundedStash, Akka.Actor.IWithUnrestrictedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics> {\n    protected readonly Akka.Persistence.Sql.Common.JournalSettings Settings;\n    protected SqlJournal(Akka.Configuration.Config journalConfig) { }\n    protected abstract string JournalConfigPath { get; }\n    protected Akka.Event.ILoggingAdapter Log { get; }\n    public abstract Akka.Persistence.Sql.Common.Journal.IJournalQueryExecutor QueryExecutor { get; }\n    public Akka.Actor.IStash Stash { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Commands for Persistent FSM in C#\nDESCRIPTION: Example of commands used in a WebStoreCustomerFSMActor to demonstrate the contract of a PersistentFSM. Shows commands for adding items, completing purchase, leaving the store, and retrieving cart state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistent-fsm.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nAddItem sent when the customer adds an item to a shopping cart `Buy` - when the customer finishes the purchase `Leave` - when the customer leaves the store without purchasing anything `GetCurrentCart` allows to query the current state of customer's shopping cart\n```\n\n----------------------------------------\n\nTITLE: Configuring Serialization Bindings in HOCON\nDESCRIPTION: HOCON configuration showing how to bind object types to specific serializers\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/serialization/serialization.md#2025-04-16_snippet_1\n\nLANGUAGE: hocon\nCODE:\n```\nakka {\n  actor {\n     serializers {\n        json = \"Akka.Serialization.NewtonSoftJsonSerializer\"\n        bytes = \"Akka.Serialization.ByteArraySerializer\"\n        myown = \"MySampleProject.MySerializer, MyAssembly\"\n     }\n\n    serialization-bindings {\n      \"System.Byte[]\" = bytes\n      \"System.Object\" = json\n      \"MySampleProject.MyOwnSerializable, MyAssembly\" = myown\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DequeWrapperMessageQueue for Actor Message Processing in C#\nDESCRIPTION: A message queue wrapper class that implements deque-based message queue semantics. It wraps an existing message queue and provides additional functionality for handling messages in a deque (double-ended queue) manner.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_105\n\nLANGUAGE: C#\nCODE:\n```\npublic class DequeWrapperMessageQueue : Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.MessageQueues.IMessageQueue\n{\n    protected readonly Akka.Dispatch.MessageQueues.IMessageQueue MessageQueue;\n    public DequeWrapperMessageQueue(Akka.Dispatch.MessageQueues.IMessageQueue messageQueue) { }\n    public int Count { get; }\n    public bool HasMessages { get; }\n    public void CleanUp(Akka.Actor.IActorRef owner, Akka.Dispatch.MessageQueues.IMessageQueue deadletters) { }\n    public void Enqueue(Akka.Actor.IActorRef receiver, Akka.Actor.Envelope envelope) { }\n    public void EnqueueFirst(Akka.Actor.Envelope envelope) { }\n    public bool TryDequeue(out Akka.Actor.Envelope envelope) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Actor Reference Types in C#\nDESCRIPTION: Defines different types of actor references including DeadLetterActorRef and EmptyLocalActorRef for handling special message routing cases.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic class DeadLetterActorRef : Akka.Actor.EmptyLocalActorRef {\n    public DeadLetterActorRef(Akka.Actor.IActorRefProvider provider, Akka.Actor.ActorPath path, Akka.Event.EventStream eventStream) { }\n    protected override bool SpecialHandle(object message, Akka.Actor.IActorRef sender) { }\n    protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }\n}\n```\n\n----------------------------------------\n\nTITLE: AggregateServiceDiscovery Class Definition in C#\nDESCRIPTION: Defines an internal service discovery implementation that aggregates multiple discovery methods. This class provides a way to combine different service discovery mechanisms in Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.DotNet.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class AggregateServiceDiscovery : Akka.Discovery.ServiceDiscovery\n{\n    public AggregateServiceDiscovery(Akka.Actor.ExtendedActorSystem system) { }\n    public override System.Threading.Tasks.Task<Akka.Discovery.ServiceDiscovery.Resolved> Lookup(Akka.Discovery.Lookup query, System.TimeSpan resolveTimeout) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Complex C# Class Implementation with Equality\nDESCRIPTION: Demonstrates a complete C# class implementation with equality comparisons and string representation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/porting-guide.md#2025-04-16_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\npublic sealed class HandingOverData\n{\n    public HandingOverData(IActorRef singleton, string name)\n    {\n        Singleton = singleton;\n        Name = name;\n    }\n\n    public IActorRef Singleton { get; }\n\n    public string Name { get; }\n\n    private bool Equals(HandingOverData other)\n    {\n        return Equals(Singleton, other.Singleton) && string.Equals(Name, other.Name);\n    }\n\n    public override bool Equals(object obj)\n    {\n        if (ReferenceEquals(null, obj)) return false;\n        if (ReferenceEquals(this, obj)) return true;\n        return obj is HandingOverData && Equals((HandingOverData)obj);\n    }\n\n    public override int GetHashCode()\n    {\n        unchecked\n        {\n            return ((Singleton?.GetHashCode() ?? 0) * 397) ^ (Name?.GetHashCode() ?? 0);\n        }\n    }\n\n    public override string ToString() => $\"{nameof(HandingOverData)}<{nameof(Singleton)}: {Singleton}, {nameof(Name)}: {Name}>\";\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DelegatingSupervisorStrategy for Akka Actors\nDESCRIPTION: A strategy class for supervising actors that delegates decision-making to custom logic defined in Akka actor systems. It handles failures, termination, and can update supervising strategies. It requires Akka.Actor and related dependencies.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic class DelegatingSupervisorStrategy : Akka.Actor.SupervisorStrategy\n{\n    public DelegatingSupervisorStrategy() { }\n    public override Akka.Actor.IDecider Decider { get; }\n    protected override Akka.Actor.Directive Handle(Akka.Actor.IActorRef child, System.Exception exception) { }\n    public override void HandleChildTerminated(Akka.Actor.IActorContext actorContext, Akka.Actor.IActorRef child, System.Collections.Generic.IEnumerable<Akka.Actor.IInternalActorRef> children) { }\n    public override void ProcessFailure(Akka.Actor.IActorContext context, bool restart, Akka.Actor.IActorRef child, System.Exception cause, Akka.Actor.Internal.ChildRestartStats stats, System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> children) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public void Update(Akka.Actor.IActorRef child, Akka.Actor.SupervisorStrategy supervisorStrategy) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Actor Deployment Configuration in C#\nDESCRIPTION: Defines deployment configuration for Akka.NET actors including router configuration, dispatcher settings, and mailbox specifications.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic class Deploy : Akka.Util.ISurrogated, System.IEquatable<Akka.Actor.Deploy> {\n    public Deploy(string path, Akka.Configuration.Config config, Akka.Routing.RouterConfig routerConfig, Akka.Actor.Scope scope, string dispatcher, string mailbox, int stashCapacity) { }\n    public string Dispatcher { get; }\n    public string Mailbox { get; }\n    public Akka.Routing.RouterConfig RouterConfig { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EventStream Class in C#\nDESCRIPTION: A concrete implementation of LoggingBus that manages the main event stream for an actor system. It handles actor subscriptions to different event types and includes an unsubscriber mechanism.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_124\n\nLANGUAGE: C#\nCODE:\n```\npublic class EventStream : Akka.Event.LoggingBus\n{\n    public EventStream(bool debug) { }\n    public void StartUnsubscriber(Akka.Actor.Internal.ActorSystemImpl system) { }\n    public override bool Subscribe(Akka.Actor.IActorRef subscriber, System.Type channel) { }\n    public override bool Unsubscribe(Akka.Actor.IActorRef subscriber, System.Type channel) { }\n    public override bool Unsubscribe(Akka.Actor.IActorRef subscriber) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Tuning Parameters in Akka.NET C#\nDESCRIPTION: Describes \"TuningParameters\" for fine-tuning Akka.NET sharding operations such as timeouts, buffer sizes, backoff times, and rebalance intervals. These parameters are essential for customizing performance and behavior in distributed cluster environments.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Core.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic class TuningParameters {\n        public readonly int BufferSize;\n        public readonly System.TimeSpan CoordinatorFailureBackoff;\n        public readonly int CoordinatorStateReadMajorityPlus;\n        public readonly int CoordinatorStateWriteMajorityPlus;\n        public readonly System.TimeSpan EntityRecoveryConstantRateStrategyFrequency;\n        public readonly int EntityRecoveryConstantRateStrategyNumberOfEntities;\n        public readonly string EntityRecoveryStrategy;\n        public readonly System.TimeSpan EntityRestartBackoff;\n        public readonly System.TimeSpan HandOffTimeout;\n        public readonly int KeepNrOfBatches;\n        public readonly int LeastShardAllocationAbsoluteLimit;\n        public readonly int LeastShardAllocationMaxSimultaneousRebalance;\n        public readonly int LeastShardAllocationRebalanceThreshold;\n        public readonly double LeastShardAllocationRelativeLimit;\n        public readonly System.TimeSpan RebalanceInterval;\n        public readonly System.TimeSpan RetryInterval;\n        public readonly System.TimeSpan ShardFailureBackoff;\n        public readonly System.TimeSpan ShardStartTimeout;\n        public readonly int SnapshotAfter;\n        public readonly System.TimeSpan UpdatingStateTimeout;\n        public readonly System.TimeSpan WaitingForStateTimeout;\n        public TuningParameters(\n                    System.TimeSpan coordinatorFailureBackoff, \n                    System.TimeSpan retryInterval, \n                    int bufferSize, \n                    System.TimeSpan handOffTimeout, \n                    System.TimeSpan shardStartTimeout, \n                    System.TimeSpan shardFailureBackoff, \n                    System.TimeSpan entityRestartBackoff, \n                    System.TimeSpan rebalanceInterval, \n                    int snapshotAfter, \n                    int keepNrOfBatches, \n                    int leastShardAllocationRebalanceThreshold, \n                    int leastShardAllocationMaxSimultaneousRebalance, \n                    System.TimeSpan waitingForStateTimeout, \n                    System.TimeSpan updatingStateTimeout, \n                    string entityRecoveryStrategy, \n                    System.TimeSpan entityRecoveryConstantRateStrategyFrequency, \n                    int entityRecoveryConstantRateStrategyNumberOfEntities, \n                    int coordinatorStateWriteMajorityPlus, \n                    int coordinatorStateReadMajorityPlus, \n                    int leastShardAllocationAbsoluteLimit, \n                    double leastShardAllocationRelativeLimit) { }\n        public Akka.Cluster.Sharding.TuningParameters WithBufferSize(int bufferSize) { }\n        public Akka.Cluster.Sharding.TuningParameters WithCoordinatorFailureBackoff(System.TimeSpan coordinatorFailureBackoff) { }\n        public Akka.Cluster.Sharding.TuningParameters WithCoordinatorStateReadMajorityPlus(int coordinatorStateReadMajorityPlus) { }\n        public Akka.Cluster.Sharding.TuningParameters WithCoordinatorStateWriteMajorityPlus(int coordinatorStateWriteMajorityPlus) { }\n        public Akka.Cluster.Sharding.TuningParameters WithEntityRecoveryConstantRateStrategyFrequency(System.TimeSpan entityRecoveryConstantRateStrategyFrequency) { }\n        public Akka.Cluster.Sharding.TuningParameters WithEntityRecoveryConstantRateStrategyNumberOfEntities(int entityRecoveryConstantRateStrategyNumberOfEntities) { }\n        public Akka.Cluster.Sharding.TuningParameters WithEntityRecoveryStrategy(string entityRecoveryStrategy) { }\n        public Akka.Cluster.Sharding.TuningParameters WithEntityRestartBackoff(System.TimeSpan entityRestartBackoff) { }\n        public Akka.Cluster.Sharding.TuningParameters WithHandOffTimeout(System.TimeSpan handOffTimeout) { }\n        public Akka.Cluster.Sharding.TuningParameters WithKeepNrOfBatches(int keepNrOfBatches) { }\n        public Akka.Cluster.Sharding.TuningParameters WithLeastShardAllocationAbsoluteLimit(int leastShardAllocationAbsoluteLimit) { }\n        public Akka.Cluster.Sharding.TuningParameters WithLeastShardAllocationMaxSimultaneousRebalance(int leastShardAllocationMaxSimultaneousRebalance) { }\n        public Akka.Cluster.Sharding.TuningParameters WithLeastShardAllocationRebalanceThreshold(int leastShardAllocationRebalanceThreshold) { }\n        public Akka.Cluster.Sharding.TuningParameters WithLeastShardAllocationRelativeLimit(double leastShardAllocationRelativeLimit) { }\n        public Akka.Cluster.Sharding.TuningParameters WithRebalanceInterval(System.TimeSpan rebalanceInterval) { }\n        public Akka.Cluster.Sharding.TuningParameters WithRetryInterval(System.TimeSpan retryInterval) { }\n        public Akka.Cluster.Sharding.TuningParameters WithShardFailureBackoff(System.TimeSpan shardFailureBackoff) { }\n        public Akka.Cluster.Sharding.TuningParameters WithShardStartTimeout(System.TimeSpan shardStartTimeout) { }\n        public Akka.Cluster.Sharding.TuningParameters WithSnapshotAfter(int snapshotAfter) { }\n        public Akka.Cluster.Sharding.TuningParameters WithUpdatingStateTimeout(System.TimeSpan updatingStateTimeout) { }\n        public Akka.Cluster.Sharding.TuningParameters WithWaitingForStateTimeout(System.TimeSpan waitingForStateTimeout) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing StringFormat Static Class in C#\nDESCRIPTION: A utility class for safe string formatting operations, handling null values gracefully.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_233\n\nLANGUAGE: C#\nCODE:\n```\npublic class static StringFormat\n{\n    public static string SafeJoin(string separator, params object[] args) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UdpExt Extension in Akka.NET\nDESCRIPTION: Extension for unconnected UDP operations. Provides access to the UDP manager actor for connectionless communication.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_187\n\nLANGUAGE: C#\nCODE:\n```\npublic class UdpExt : Akka.IO.IOExtension\n{\n    public UdpExt(Akka.Actor.ExtendedActorSystem system) { }\n    public UdpExt(Akka.Actor.ExtendedActorSystem system, Akka.IO.UdpSettings settings) { }\n    public override Akka.Actor.IActorRef Manager { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Stash Factory and Exceptions in Akka.NET\nDESCRIPTION: Static factory methods for creating actor stashes and exception handling for stash overflow conditions. Allows actors to temporarily stash messages for later processing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_48\n\nLANGUAGE: C#\nCODE:\n```\npublic class static StashFactory\n    {\n        public static Akka.Actor.IStash CreateStash<T>(this Akka.Actor.IActorContext context)\n            where T : Akka.Actor.ActorBase { }\n        public static Akka.Actor.IStash CreateStash(this Akka.Actor.IActorContext context, Akka.Actor.IActorStash actorInstance) { }\n        public static Akka.Actor.IStash CreateStash(this Akka.Actor.IActorContext context, System.Type actorType) { }\n    }\n\n    public class StashOverflowException : Akka.Actor.AkkaException\n    {\n        public StashOverflowException(string message, System.Exception cause = null) { }\n        protected StashOverflowException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Starting Cluster Sharding with Custom Handoff Message in C#\nDESCRIPTION: Shows how to configure Akka.Cluster.Sharding to use a custom handoff stop message. This allows for custom handling of entity shutdown during shard re-balancing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-sharding.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Cluster Start](../../../src/contrib/cluster/Akka.Cluster.Sharding.Tests.MultiNode/ClusterShardingGracefulShutdownOldestSpec.cs?name=ClusterStart)]\n```\n\n----------------------------------------\n\nTITLE: Implementing ExpectOne Methods in C#\nDESCRIPTION: This snippet shows methods for expecting a single event in Akka.NET TestKit. It includes synchronous and asynchronous versions with different parameter combinations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\npublic void ExpectOne(System.Action action, System.Threading.CancellationToken cancellationToken = null) { }\npublic void ExpectOne(System.TimeSpan timeout, System.Action action, System.Threading.CancellationToken cancellationToken = null) { }\npublic T ExpectOne<T>(System.Func<T> func, System.Threading.CancellationToken cancellationToken = null) { }\npublic T ExpectOne<T>(System.TimeSpan timeout, System.Func<T> func, System.Threading.CancellationToken cancellationToken = null) { }\n[System.ObsoleteAttribute(\"Only for backwards compat. Use ExpectOneAsync(Func<Task>, CancellationToken) inst\" +\n    \"ead beginning in Akka.NET v1.5\")]\npublic System.Threading.Tasks.Task ExpectOneAsync(System.Action action, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.Task ExpectOneAsync(System.Func<System.Threading.Tasks.Task> action, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.Task ExpectOneAsync(System.TimeSpan timeout, System.Func<System.Threading.Tasks.Task> action, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.Task<T> ExpectOneAsync<T>(System.Func<System.Threading.Tasks.Task<T>> func, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.Task<T> ExpectOneAsync<T>(System.TimeSpan timeout, System.Func<System.Threading.Tasks.Task<T>> func, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Basic Message Reception in Akka.NET\nDESCRIPTION: Demonstrates basic message receiving using Receive handler for specific message types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\nReceive<string>(ms => Console.WriteLine(\"Received message: \" + msg));\n```\n\n----------------------------------------\n\nTITLE: Implementing Base Tokenizer Class in C#\nDESCRIPTION: The Tokenizer class provides the base functionality for tokenizing text. It includes methods for checking characters, matching patterns, and advancing through the input text during the tokenization process.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_77\n\nLANGUAGE: C#\nCODE:\n```\npublic class Tokenizer\n{\n    public Tokenizer(string text) { }\n    public bool EoF { get; }\n    public bool Matches(string pattern) { }\n    public bool Matches(params string[] patterns) { }\n    public char Peek() { }\n    protected string PickErrorLine(out int index) { }\n    public void Pop() { }\n    public void PullWhitespace() { }\n    public void Push() { }\n    public string Take(int length) { }\n    public char Take() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ModifyFailure Class for Distributed Data Update Errors\nDESCRIPTION: Class representing a failure in a distributed data modification operation. This class provides error information for when updates to distributed data fail.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ModifyFailure : Akka.Actor.INoSerializationVerificationNeeded, Akka.DistributedData.IUpdateFailure, Akka.DistributedData.IUpdateResponse\n{\n```\n\n----------------------------------------\n\nTITLE: Configuring Billing Role in Akka.NET Cluster\nDESCRIPTION: HOCON configuration for setting up a cluster node with the 'billing' role, which will handle customer billing operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/member-roles.md#2025-04-16_snippet_4\n\nLANGUAGE: hocon\nCODE:\n```\nakka\n{\n  cluster\n  {\n    roles = [\"billing\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: UdpConnected Extension for Connection-Oriented UDP in Akka.NET\nDESCRIPTION: This snippet defines the UdpConnected class and related types for connection-oriented UDP communication in Akka.NET. It includes commands and events specific to connected UDP sockets, providing a more stream-like interface to UDP.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_171\n\nLANGUAGE: csharp\nCODE:\n```\n    public class UdpConnected : Akka.Actor.ExtensionIdProvider<Akka.IO.UdpConnectedExt>\n    {\n        public static readonly Akka.IO.UdpConnected Instance;\n        public UdpConnected() { }\n        public override Akka.IO.UdpConnectedExt CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n        public abstract class Command : Akka.IO.UdpConnected.Message\n        {\n            protected Command() { }\n            public object FailureMessage { get; }\n        }\n        public sealed class CommandFailed : Akka.IO.UdpConnected.Event\n        {\n            public CommandFailed(Akka.IO.UdpConnected.Command cmd) { }\n            public Akka.IO.UdpConnected.Command Cmd { get; }\n        }\n        public sealed class Connect : Akka.IO.UdpConnected.Command\n        {\n            public Connect(Akka.Actor.IActorRef handler, System.Net.EndPoint remoteAddress, System.Net.EndPoint localAddress = null, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options = null) { }\n            public Akka.Actor.IActorRef Handler { get; }\n            public System.Net.EndPoint LocalAddress { get; }\n            public System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> Options { get; }\n            public System.Net.EndPoint RemoteAddress { get; }\n        }\n        public class Connected : Akka.IO.UdpConnected.Event\n        {\n```\n\n----------------------------------------\n\nTITLE: Implementing StableListPriorityQueue Class in C#\nDESCRIPTION: A priority queue implementation specifically designed for Akka.Actor.Envelope items with stable ordering for items of equal priority.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_231\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class StableListPriorityQueue\n{\n    public StableListPriorityQueue(int initialCapacity, System.Func<object, int> priorityCalculator) { }\n    public int Count() { }\n    public Akka.Actor.Envelope Dequeue() { }\n    public void Enqueue(Akka.Actor.Envelope item) { }\n    public bool IsConsistent() { }\n    public Akka.Actor.Envelope Peek() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LWWDictionary Class in C#\nDESCRIPTION: This snippet defines a sealed class `LWWDictionary<TKey, TValue>` that implements several interfaces related to replicated data, delta replication, pruning, and collections. It represents a Last-Write-Wins (LWW) dictionary, a replicated data structure that resolves conflicts by choosing the update with the latest timestamp. It provides methods for merging dictionaries, pruning data from removed nodes, and modifying the dictionary contents.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\n    public sealed class LWWDictionary<TKey, TValue> : Akka.DistributedData.IDeltaReplicatedData, Akka.DistributedData.IDeltaReplicatedData<Akka.DistributedData.LWWDictionary<TKey, TValue>, Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.LWWRegister<TValue>>.IDeltaOperation>, Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IRemovedNodePruning<Akka.DistributedData.LWWDictionary<TKey, TValue>>, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.LWWDictionary<TKey, TValue>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable, System.IEquatable<Akka.DistributedData.LWWDictionary<TKey, TValue>>\n    {\n        public static readonly Akka.DistributedData.LWWDictionary<TKey, TValue> Empty;\n        public LWWDictionary(Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.LWWRegister<TValue>> underlying) { }\n        public int Count { get; }\n        public Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.LWWRegister<TValue>>.IDeltaOperation Delta { get; }\n        public System.Collections.Immutable.IImmutableDictionary<TKey, TValue> Entries { get; }\n        public bool IsEmpty { get; }\n        public TValue this[TKey key] { get; }\n        public System.Type KeyType { get; }\n        public System.Collections.Generic.IEnumerable<TKey> Keys { get; }\n        public System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.UniqueAddress> ModifiedByNodes { get; }\n        public System.Type ValueType { get; }\n        public System.Collections.Generic.IEnumerable<TValue> Values { get; }\n        public bool ContainsKey(TKey key) { }\n        public bool Equals(Akka.DistributedData.LWWDictionary<TKey, TValue> other) { }\n        public override bool Equals(object obj) { }\n        public System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> GetEnumerator() { }\n        public override int GetHashCode() { }\n        public Akka.DistributedData.LWWDictionary<TKey, TValue> Merge(Akka.DistributedData.LWWDictionary<TKey, TValue> other) { }\n        public Akka.DistributedData.IReplicatedData Merge(Akka.DistributedData.IReplicatedData other) { }\n        public Akka.DistributedData.LWWDictionary<TKey, TValue> MergeDelta(Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.LWWRegister<TValue>>.IDeltaOperation delta) { }\n        public bool NeedPruningFrom(Akka.Cluster.UniqueAddress removedNode) { }\n        public Akka.DistributedData.LWWDictionary<TKey, TValue> Prune(Akka.Cluster.UniqueAddress removedNode, Akka.Cluster.UniqueAddress collapseInto) { }\n        public Akka.DistributedData.LWWDictionary<TKey, TValue> PruningCleanup(Akka.Cluster.UniqueAddress removedNode) { }\n        public Akka.DistributedData.LWWDictionary<TKey, TValue> Remove(Akka.Cluster.Cluster node, TKey key) { }\n        public Akka.DistributedData.LWWDictionary<TKey, TValue> Remove(Akka.Cluster.UniqueAddress node, TKey key) { }\n        public Akka.DistributedData.LWWDictionary<TKey, TValue> ResetDelta() { }\n        public Akka.DistributedData.LWWDictionary<TKey, TValue> SetItem(Akka.Cluster.Cluster node, TKey key, TValue value, Akka.DistributedData.Clock<TValue> clock = null) { }\n        public Akka.DistributedData.LWWDictionary<TKey, TValue> SetItem(Akka.Cluster.UniqueAddress node, TKey key, TValue value, Akka.DistributedData.Clock<TValue> clock = null) { }\n        public override string ToString() { }\n        public bool TryGetValue(TKey key, out TValue value) { }\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Defining Get Operation in Akka.NET DistributedData (C#)\nDESCRIPTION: Defines the Get class, which represents a request to retrieve data from the distributed data store. It includes properties for the key, consistency level, and an optional request object.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Get : Akka.DistributedData.IReplicatorMessage, System.IEquatable<Akka.DistributedData.Get>\n{\n    public Get(Akka.DistributedData.IKey key, Akka.DistributedData.IReadConsistency consistency, object request = null) { }\n    public Akka.DistributedData.IReadConsistency Consistency { get; }\n    public Akka.DistributedData.IKey Key { get; }\n    public object Request { get; }\n    public bool Equals(Akka.DistributedData.Get other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining InternalTestActorRef Class in C#\nDESCRIPTION: This snippet defines the InternalTestActorRef class, which is a special ActorRef used for testing in Akka.NET. It provides methods for creating, receiving messages, and managing the underlying actor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\npublic class InternalTestActorRef : Akka.Actor.LocalActorRef\n{\n    public object UnderlyingActor { get; }\n    public static Akka.TestKit.Internal.InternalTestActorRef Create(Akka.Actor.ActorSystem system, Akka.Actor.Props props, Akka.Actor.IActorRef supervisor = null, string name = null) { }\n    public static string CreateUniqueName() { }\n    protected Akka.TestKit.Internal.InternalTestActorRef.TestActorCell GetTestActorCell() { }\n    protected override Akka.Actor.ActorCell NewActorCell(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.IInternalActorRef self, Akka.Actor.Props props, Akka.Dispatch.MessageDispatcher dispatcher, Akka.Actor.IInternalActorRef supervisor) { }\n    public void Receive(object message, Akka.Actor.IActorRef sender = null) { }\n    public System.Threading.Tasks.Task ReceiveAsync(object message, Akka.Actor.IActorRef sender = null) { }\n    public override string ToString() { }\n    public void Unwatch(Akka.Actor.IActorRef subject) { }\n    public void Watch(Akka.Actor.IActorRef subject) { }\n    public class InternalGetActor : Akka.Actor.IAutoReceivedMessage, Akka.Actor.IPossiblyHarmful\n    {\n        public static readonly Akka.TestKit.Internal.InternalTestActorRef.InternalGetActor Instance;\n    }\n    protected class TestActorCell : Akka.Actor.ActorCell\n    {\n        public TestActorCell(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.IInternalActorRef self, Akka.Actor.Props props, Akka.Dispatch.MessageDispatcher dispatcher, Akka.Actor.IInternalActorRef parent) { }\n        public object Actor { get; }\n        public override Akka.Dispatch.ActorTaskScheduler TaskScheduler { get; }\n        protected override void AutoReceiveMessage(Akka.Actor.Envelope envelope) { }\n        public System.Threading.Tasks.Task ReceiveMessageForTestAsync(Akka.Actor.Envelope envelope) { }\n        public System.Threading.Tasks.Task UseThreadContextAsync(System.Func<System.Threading.Tasks.Task> actionAsync) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Journal Settings Class in C#\nDESCRIPTION: Configuration class for SQL journal settings including connection parameters, table names, and transaction isolation levels.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_23\n\nLANGUAGE: csharp\nCODE:\n```\npublic class JournalSettings {\n    public JournalSettings(Akka.Configuration.Config config) { }\n    public bool AutoInitialize { get; }\n    public string ConnectionString { get; }\n    public string ConnectionStringName { get; }\n    public System.TimeSpan ConnectionTimeout { get; }\n    public string JournalTableName { get; }\n    public string MetaTableName { get; }\n    public System.Data.IsolationLevel ReadIsolationLevel { get; }\n    public string SchemaName { get; }\n    public string TimestampProvider { get; set; }\n    public System.Data.IsolationLevel WriteIsolationLevel { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SnapshotOffer Class in Akka.NET Persistence\nDESCRIPTION: The SnapshotOffer class represents a snapshot of actor state that can be used during recovery. It contains metadata about the snapshot and the snapshot data itself.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SnapshotOffer : System.IEquatable<Akka.Persistence.SnapshotOffer>\n{\n    public SnapshotOffer(Akka.Persistence.SnapshotMetadata metadata, object snapshot) { }\n    public Akka.Persistence.SnapshotMetadata Metadata { get; }\n    public object Snapshot { get; }\n    public bool Equals(Akka.Persistence.SnapshotOffer other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Routees Container Class in C#\nDESCRIPTION: Definition of the Routees class which serves as a container for multiple Routee instances. It provides access to the collection of routees that a router manages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_192\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Routees\n{\n    public Routees(System.Collections.Generic.IEnumerable<Akka.Routing.Routee> routees) { }\n    public System.Collections.Generic.IEnumerable<Akka.Routing.Routee> Members { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Command Handling Methods in C#\nDESCRIPTION: Collection of protected methods for handling commands in different ways, including synchronous and async variations with optional predicates.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\nprotected void Command(System.Type messageType, System.Action<object> handler, System.Predicate<object> shouldHandle = null) { }\nprotected void Command(System.Type messageType, System.Predicate<object> shouldHandle, System.Action<object> handler) { }\nprotected void Command<T>(System.Func<T, bool> handler) { }\nprotected void Command(System.Type messageType, System.Func<object, bool> handler) { }\nprotected void Command(System.Action<object> handler) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing LeaseUsageSettings Class in C#\nDESCRIPTION: Configuration class for lease usage settings that specifies the lease implementation and retry interval. Provides immutable configuration for lease implementation details.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.Core.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class LeaseUsageSettings\n{\n    public LeaseUsageSettings(string leaseImplementation, System.TimeSpan leaseRetryInterval) { }\n    public string LeaseImplementation { get; }\n    public System.TimeSpan LeaseRetryInterval { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Child Actor Management Classes in C#\nDESCRIPTION: These classes provide implementations for managing child actors, including tracking restart statistics and maintaining child containers.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_58\n\nLANGUAGE: C#\nCODE:\n```\npublic class ChildRestartStats : Akka.Actor.Internal.IChildStats\n{\n    public ChildRestartStats(Akka.Actor.IInternalActorRef child, uint maxNrOfRetriesCount = 0, long restartTimeWindowStartTicks = 0) { }\n    public Akka.Actor.IInternalActorRef Child { get; }\n    public uint MaxNrOfRetriesCount { get; }\n    public long RestartTimeWindowStartTicks { get; }\n    public long Uid { get; }\n    public bool RequestRestartPermission(int maxNrOfRetries, int withinTimeMilliseconds) { }\n}\n\npublic abstract class ChildrenContainerBase : Akka.Actor.Internal.IChildrenContainer\n{\n    protected ChildrenContainerBase(System.Collections.Immutable.IImmutableDictionary<string, Akka.Actor.Internal.IChildStats> children) { }\n    public System.Collections.Generic.IReadOnlyCollection<Akka.Actor.IInternalActorRef> Children { get; }\n    protected System.Collections.Immutable.IImmutableDictionary<string, Akka.Actor.Internal.IChildStats> InternalChildren { get; }\n    public virtual bool IsNormal { get; }\n    public virtual bool IsTerminating { get; }\n    public System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> Stats { get; }\n    public abstract Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats);\n    public bool Contains(Akka.Actor.IActorRef actor) { }\n    public abstract Akka.Actor.Internal.IChildrenContainer Remove(Akka.Actor.IActorRef child);\n    public abstract Akka.Actor.Internal.IChildrenContainer Reserve(string name);\n    public abstract Akka.Actor.Internal.IChildrenContainer ShallDie(Akka.Actor.IActorRef actor);\n    public bool TryGetByName(string name, out Akka.Actor.Internal.IChildStats stats) { }\n    public bool TryGetByRef(Akka.Actor.IActorRef actor, [System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] [System.Runtime.CompilerServices.NullableAttribute(2)] out Akka.Actor.Internal.ChildRestartStats childRestartStats) { }\n    public abstract Akka.Actor.Internal.IChildrenContainer Unreserve(string name);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LeaseSettings Class in C#\nDESCRIPTION: Configuration class for lease settings that includes lease name, owner name, timeout settings, and additional configuration. Provides factory methods and immutable update operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.Core.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class LeaseSettings\n{\n    public LeaseSettings(string leaseName, string ownerName, Akka.Coordination.TimeoutSettings timeoutSettings, Akka.Configuration.Config leaseConfig) { }\n    public Akka.Configuration.Config LeaseConfig { get; }\n    public string LeaseName { get; }\n    public string OwnerName { get; }\n    public Akka.Coordination.TimeoutSettings TimeoutSettings { get; }\n    public static Akka.Coordination.LeaseSettings Create(Akka.Configuration.Config config, string leaseName, string ownerName) { }\n    public override string ToString() { }\n    public Akka.Coordination.LeaseSettings WithTimeoutSettings(Akka.Coordination.TimeoutSettings timeoutSettings) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IBlockingMessageQueueSemantics Interface in C#\nDESCRIPTION: An interface defining semantics for blocking message queues in Akka.NET. It extends IMultipleConsumerSemantics and ISemantics interfaces, adding a BlockTimeOut property to configure timeout behavior for queue operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_89\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IBlockingMessageQueueSemantics : Akka.Dispatch.IMultipleConsumerSemantics, Akka.Dispatch.ISemantics\n{\n    System.TimeSpan BlockTimeOut { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Group Abstract Class Implementation in Akka.NET Routing\nDESCRIPTION: Defines the abstract Group class that serves as a base for group-based routers. It maintains a collection of actor paths and provides methods to create router actors and handle equality comparison.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_174\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Group : Akka.Routing.RouterConfig, System.IEquatable<Akka.Routing.Group>\n{\n    protected readonly string[] InternalPaths;\n    protected Group(System.Collections.Generic.IEnumerable<string> paths, string routerDispatcher) { }\n    public override Akka.Actor.ActorBase CreateRouterActor() { }\n    public bool Equals(Akka.Routing.Group other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public abstract System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system);\n    public Akka.Actor.Props Props() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing InMemoryReadJournalProvider Class in C#\nDESCRIPTION: This class implements the IReadJournalProvider interface to provide an instance of the InMemoryReadJournal. It requires an ExtendedActorSystem and a Config object for initialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceInMemoryQuery.DotNet.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class InMemoryReadJournalProvider : Akka.Persistence.Query.IReadJournalProvider\n{\n    public InMemoryReadJournalProvider(Akka.Actor.ExtendedActorSystem system, Akka.Configuration.Config config) { }\n    public Akka.Persistence.Query.IReadJournal GetReadJournal() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining State Class for PersistentFSM in C#\nDESCRIPTION: Generic class representing a state in a PersistentFSM. Provides fluent API for configuring state transitions, timeouts, event persistence, and post-transition actions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\npublic class State<TS, TD, TE>\n{\n    public State(TS stateName, TD stateData, System.Nullable<System.TimeSpan> timeout = null, Akka.Actor.FSMBase.Reason stopReason = null, System.Collections.Generic.IReadOnlyList<object> replies = null, System.Collections.Generic.IReadOnlyList<TE> domainEvents = null, System.Action<TD> afterTransitionDo = null, bool notifies = True) { }\n    public System.Action<TD> AfterTransitionDo { get; }\n    public System.Collections.Generic.IReadOnlyList<TE> DomainEvents { get; }\n    public System.Collections.Generic.IReadOnlyList<object> Replies { get; set; }\n    public TD StateData { get; }\n    public TS StateName { get; }\n    public Akka.Actor.FSMBase.Reason StopReason { get; }\n    public System.Nullable<System.TimeSpan> Timeout { get; }\n    public Akka.Persistence.Fsm.PersistentFSM.State<TS, TD, TE> AndThen(System.Action<TD> handler) { }\n    public Akka.Persistence.Fsm.PersistentFSM.State<TS, TD, TE> Applying(params TE[] events) { }\n    public Akka.Persistence.Fsm.PersistentFSM.State<TS, TD, TE> ForMax(System.TimeSpan timeout) { }\n    public Akka.Persistence.Fsm.PersistentFSM.State<TS, TD, TE> Replying(object replyValue) { }\n    public override string ToString() { }\n    [System.ObsoleteAttribute(\"Internal API easily to be confused with regular FSM\\'s using. Use regular events (\" +\n        \"`Applying`). Internally, `copy` can be used instead.\")]\n    public Akka.Persistence.Fsm.PersistentFSM.State<TS, TD, TE> Using(TD nextStateData) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IScheduler Interface in C#\nDESCRIPTION: Defines the IScheduler interface which extends ITellScheduler and ITimeProvider. It provides access to an Advanced scheduler property.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IScheduler : Akka.Actor.ITellScheduler, Akka.Actor.ITimeProvider\n{\n    Akka.Actor.IAdvancedScheduler Advanced { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ShardedDaemonProcess Class in C#\nDESCRIPTION: Defines a class ShardedDaemonProcess that implements IExtension interface. Provides functionality for initializing and managing daemon processes across shards.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.ApiMayChangeAttribute()]\n[Akka.Annotations.DoNotInheritAttribute()]\npublic class ShardedDaemonProcess : Akka.Actor.IExtension\n{\n    public ShardedDaemonProcess(Akka.Actor.ExtendedActorSystem system) { }\n    public static Akka.Cluster.Sharding.ShardedDaemonProcess Get(Akka.Actor.ActorSystem system) { }\n    public void Init(string name, int numberOfInstances, System.Func<int, Akka.Actor.Props> propsFactory) { }\n    public void Init(string name, int numberOfInstances, System.Func<int, Akka.Actor.Props> propsFactory, object stopMessage) { }\n    [System.ObsoleteAttribute(\"Use the overloaded one which accepts a stopMessage instead.\")]\n    public void Init(string name, int numberOfInstances, System.Func<int, Akka.Actor.Props> propsFactory, Akka.Cluster.Sharding.ShardedDaemonProcessSettings settings) { }\n    public void Init(string name, int numberOfInstances, System.Func<int, Akka.Actor.Props> propsFactory, Akka.Cluster.Sharding.ShardedDaemonProcessSettings settings, object stopMessage) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CPU Metrics Selector in Akka.NET\nDESCRIPTION: This class `CpuMetricsSelector` extends `CapacityMetricsSelector` to implement CPU-based capacity metrics selection. It provides methods to compute node capacities based on CPU metrics. This is primarily used within metric-driven routing logic in a cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Net.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class CpuMetricsSelector : Akka.Cluster.Metrics.CapacityMetricsSelector {\n    public static readonly Akka.Cluster.Metrics.CpuMetricsSelector Instance;\n    public CpuMetricsSelector() { }\n    public override System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, double> Capacity(System.Collections.Immutable.IImmutableSet<Akka.Cluster.Metrics.Serialization.NodeMetrics> nodeMetrics) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TuningParameters Class in Akka.NET Sharding\nDESCRIPTION: This class defines tuning parameters for the ShardRegion, such as the buffer size and the coordinator failure backoff time. These parameters can be adjusted to optimize the performance of the ShardRegion.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_26\n\nLANGUAGE: csharp\nCODE:\n```\n    public class TuningParameters\n    {\n        public readonly int BufferSize;\n        public readonly System.TimeSpan CoordinatorFailureBackoff;\n        public readonly int CoordinatorStateReadMajorityPlus;\n```\n\n----------------------------------------\n\nTITLE: Implementing AtomicBoolean for Thread-Safe Boolean Operations in C#\nDESCRIPTION: Defines the AtomicBoolean class for thread-safe boolean operations in Akka.NET. It provides methods for comparing and setting values atomically.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_205\n\nLANGUAGE: C#\nCODE:\n```\npublic class AtomicBoolean\n{\n    public AtomicBoolean(bool initialValue = False) { }\n    public bool Value { get; set; }\n    public bool CompareAndSet(bool expected, bool newValue) { }\n    public bool GetAndSet(bool newValue) { }\n    public static bool op_Implicit(Akka.Util.AtomicBoolean atomicBoolean) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MemberStatus Enum in C#\nDESCRIPTION: Enumerates the possible states of a cluster member including Joining, Up, Leaving, Down, and other transitional states. This defines the lifecycle of nodes within the cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.DotNet.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic enum MemberStatus\n{\n    Joining = 0,\n    Up = 1,\n    Leaving = 2,\n    Exiting = 3,\n    Down = 4,\n    Removed = 5,\n    WeaklyUp = 6,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PoisonPill Message Class in Akka.NET\nDESCRIPTION: Defines the PoisonPill message type used to gracefully stop an actor. Implements special interfaces to mark it as an auto-received, potentially harmful message that should be suppressed in dead letter notifications.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class PoisonPill : Akka.Actor.IAutoReceivedMessage, Akka.Actor.IPossiblyHarmful, Akka.Event.IDeadLetterSuppression\n{\n    public static Akka.Actor.PoisonPill Instance { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: TCP Command Classes Implementation in C#\nDESCRIPTION: Definition of various TCP command classes for handling connection management, reading/writing and flow control. Includes classes like ResumeAccepting, ResumeReading, Write and other TCP-related commands.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_158\n\nLANGUAGE: C#\nCODE:\n```\npublic class ResumeAccepting : Akka.IO.Tcp.Command\n{\n    public ResumeAccepting(int batchSize) { }\n    public int BatchSize { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EntityLocation Class in C#\nDESCRIPTION: A sealed class representing the location of an entity in cluster sharding, including entity ID, shard ID, shard region address, and an optional entity actor reference.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class EntityLocation\n{\n    public EntityLocation(string entityId, string shardId, Akka.Actor.Address shardRegion, Akka.Util.Option<Akka.Actor.IActorRef> entityRef) { }\n    public string EntityId { get; }\n    public Akka.Util.Option<Akka.Actor.IActorRef> EntityRef { get; }\n    public string ShardId { get; }\n    public Akka.Actor.Address ShardRegion { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Tell Pattern with Circuit Breaker in Akka.NET\nDESCRIPTION: Demonstrates a custom implementation of the Tell pattern using CircuitBreaker's low-level APIs for handling remote calls that send messages back to the caller Actor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/circuit-breaker.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class CircuitBreakerActor : ReceiveActor\n{\n    private readonly CircuitBreaker _breaker;\n    private readonly IActorRef _targetActor;\n    private readonly ICancelable _halfOpenTask;\n\n    public CircuitBreakerActor(IActorRef targetActor)\n    {\n        _breaker = new CircuitBreaker(\n            Context.System.Scheduler,\n            5,\n            TimeSpan.FromSeconds(10),\n            TimeSpan.FromSeconds(10));\n        _targetActor = targetActor;\n        _halfOpenTask = Context.System.Scheduler.ScheduleTellRepeatedlyCancelable(\n            TimeSpan.FromSeconds(10),\n            TimeSpan.FromSeconds(10),\n            Self,\n            new AttemptHalfOpen(),\n            Self);\n\n        Receive<string>(HandleStringMessage);\n        Receive<HalfOpenExecution>(HandleHalfOpenExecution);\n        Receive<AttemptHalfOpen>(msg => {\n            if (_breaker.IsOpen)\n                Self.Tell(new HalfOpenExecution());\n        });\n    }\n\n    private void HandleStringMessage(string message)\n    {\n        if (_breaker.IsOpen)\n        {\n            Sender.Tell(new CircuitBreakerOpenException());\n        }\n        else if (_breaker.IsHalfOpen)\n        {\n            // In half-open state, don't call the target actor.\n            // The next attempt will be made when scheduler sends AttemptHalfOpen\n            Sender.Tell(new CircuitBreakerOpenException());\n        }\n        else\n        {\n            _targetActor.Tell(message);\n            Context.SetReceiveTimeout(TimeSpan.FromSeconds(5));\n            Become(() => {\n                Receive<string>(response => {\n                    _breaker.Succeed();\n                    UnbecomeStacked();\n                    Sender.Tell(response);\n                });\n                Receive<ReceiveTimeout>(timeout => {\n                    _breaker.Fail();\n                    UnbecomeStacked();\n                    Sender.Tell(new CircuitBreakerTimeoutException());\n                });\n            });\n        }\n    }\n\n    private void HandleHalfOpenExecution()\n    {\n        _targetActor.Tell(\"Are you alive?\");\n        Context.SetReceiveTimeout(TimeSpan.FromSeconds(5));\n        Become(() => {\n            Receive<string>(response => {\n                _breaker.Succeed();\n                UnbecomeStacked();\n            });\n            Receive<ReceiveTimeout>(timeout => {\n                _breaker.Fail();\n                UnbecomeStacked();\n            });\n        });\n    }\n\n    protected override void PostStop()\n    {\n        _halfOpenTask.Cancel();\n        base.PostStop();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ClusterMessageSerializer Implementation in C#\nDESCRIPTION: C# code showing the message serializer implementation that handles different versions of the wire format messages for backward compatibility.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/wire-compatibility.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Heartbeat](../../../src/core/Akka.Cluster/Serialization/ClusterMessageSerializer.cs?name=MsgRead)]\n```\n\n----------------------------------------\n\nTITLE: Creating a Fan-out Publisher with Multiple Subscribers in C#\nDESCRIPTION: Demonstrates creating a Publisher that supports multiple subscribers using fan-out/broadcasting. The input buffer size controls how far apart subscribers can be before slowing down.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\nvar authorPublisher = Source.FromPublisher(tweets)\n    .Via(authors)\n    .RunWith(Sink.AsPublisher<Author>(fanout: true), materializer);\n\nauthorPublisher.Subscribe(storage);\nauthorPublisher.Subscribe(alert);\n```\n\n----------------------------------------\n\nTITLE: Implementing UnboundedStashImpl Class in C#\nDESCRIPTION: An implementation of an unbounded stash for actors, extending AbstractStash. Allows actors to temporarily stash messages for later processing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_64\n\nLANGUAGE: C#\nCODE:\n```\npublic class UnboundedStashImpl : Akka.Actor.Internal.AbstractStash\n{\n    public UnboundedStashImpl(Akka.Actor.IActorContext context) { }\n    public override int Capacity { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing HoconSubstitution Class in C#\nDESCRIPTION: The HoconSubstitution class implements variable substitution in HOCON configuration. It allows referencing other parts of the configuration using paths and provides methods for resolving these references.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_69\n\nLANGUAGE: C#\nCODE:\n```\npublic class HoconSubstitution : Akka.Configuration.Hocon.IHoconElement, Akka.Configuration.Hocon.IMightBeAHoconObject\n{\n    protected HoconSubstitution() { }\n    public HoconSubstitution(string path) { }\n    public string Path { get; set; }\n    public Akka.Configuration.Hocon.HoconValue ResolvedValue { get; set; }\n    public System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray() { }\n    public Akka.Configuration.Hocon.HoconObject GetObject() { }\n    public string GetString() { }\n    public bool IsArray() { }\n    public bool IsObject() { }\n    public bool IsString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Actor with Bounded Stash Capacity in Akka.NET\nDESCRIPTION: Shows how to create an actor with a limited stash capacity using Props configuration, setting a maximum limit on how many messages can be stashed before throwing a StashOverflowException.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_31\n\nLANGUAGE: csharp\nCODE:\n```\n// create an actor with a stash size of 2\nIActorRef stasher = Sys.ActorOf(Props.Create<StashingActorWithOverflow>().WithStashCapacity(2));\n```\n\n----------------------------------------\n\nTITLE: Extended Actor System Implementation in C#\nDESCRIPTION: Abstract class defining the extended actor system with core functionality for actor creation, system management and actor resolution.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ExtendedActorSystem : Akka.Actor.ActorSystem\n{\n    protected ExtendedActorSystem() { }\n    public abstract Akka.Actor.ActorProducerPipelineResolver ActorPipelineResolver { get; }\n    public abstract Akka.Actor.IInternalActorRef Guardian { get; }\n    public abstract Akka.Actor.IInternalActorRef LookupRoot { get; }\n    public abstract Akka.Actor.IActorRefProvider Provider { get; }\n    public abstract Akka.Actor.IInternalActorRef SystemGuardian { get; }\n    public abstract void Abort();\n    public abstract string PrintTree();\n    public abstract Akka.Actor.IActorRef SystemActorOf(Akka.Actor.Props props, string name = null);\n    public abstract Akka.Actor.IActorRef SystemActorOf<TActor>(string name = null)\n        where TActor : Akka.Actor.ActorBase, new ();\n}\n```\n\n----------------------------------------\n\nTITLE: Actor Lifecycle System Message: Create in Akka.NET\nDESCRIPTION: System message class for creating an actor instance. Includes an optional ActorInitializationException parameter to handle initialization failures.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_94\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class Create : Akka.Dispatch.SysMsg.SystemMessage\n{\n    public Create(Akka.Actor.ActorInitializationException failure = null) { }\n    public Akka.Actor.ActorInitializationException Failure { get; }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LogFilterSetup Class in C#\nDESCRIPTION: A sealed class that extends Setup to configure log filters for an actor system. It creates filter evaluators from filter configurations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_138\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class LogFilterSetup : Akka.Actor.Setup.Setup\n{\n    public LogFilterSetup(Akka.Event.LogFilterBase[] filters) { }\n    public Akka.Event.LogFilterBase[] Filters { get; }\n    public Akka.Event.LogFilterEvaluator CreateEvaluator() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ByteString Class for Byte Manipulation in C#\nDESCRIPTION: The ByteString class provides methods for manipulating byte arrays efficiently. It includes operations for concatenation, slicing, and conversion to various formats.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_157\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ByteString : System.Collections.Generic.IEnumerable<byte>, System.Collections.IEnumerable, System.IEquatable<Akka.IO.ByteString>\n{\n    public int Count { get; }\n    public static Akka.IO.ByteString Empty { get; }\n    public bool IsCompact { get; }\n    public bool IsEmpty { get; }\n    public byte this[int index] { get; }\n    public Akka.IO.ByteString Compact() { }\n    public Akka.IO.ByteString Concat(Akka.IO.ByteString other) { }\n    // ... (other methods)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TestFSMRef Generic Class in C#\nDESCRIPTION: Test reference class for Finite State Machine actors with methods for managing state, timers and transitions. Provides functionality to test FSM behavior.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestFSMRef<TActor, TState, TData> : Akka.TestKit.TestActorRefBase<TActor>\n    where TActor : Akka.Actor.FSM<TState, TData>\n{\n    public TestFSMRef(Akka.Actor.ActorSystem system, Akka.Actor.Props props, Akka.Actor.IActorRef supervisor = null, string name = null, bool activateLogging = False) { }\n    public TData StateData { get; }\n    public TState StateName { get; }\n    public void CancelTimer(string name) { }\n    public bool IsStateTimerActive() { }\n    public bool IsTimerActive(string name) { }\n    public void SetState(TState stateName, System.Nullable<System.TimeSpan> timeout = null) { }\n    public void SetState(TState stateName, TData stateData, System.Nullable<System.TimeSpan> timeout = null, Akka.Actor.FSMBase.Reason stopReason = null) { }\n    public void SetStateData(TData stateData, System.Nullable<System.TimeSpan> timeout = null) { }\n    public void SetStateTimeout(System.TimeSpan timeout) { }\n    public void SetTimer(string name, object msg, System.TimeSpan timeout, bool repeat = False) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Buffer Sizes in Akka.NET\nDESCRIPTION: Shows how to configure default buffer sizes through HOCON configuration or ActorMaterializerSettings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/buffersandworkingwithrate.md#2025-04-16_snippet_1\n\nLANGUAGE: hocon\nCODE:\n```\nakka.stream.materializer.max-input-buffer-size = 16\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvar materializer = ActorMaterializer.Create(system, \nActorMaterializerSettings.Create(system).WithInputBuffer(64, 64));\n```\n\n----------------------------------------\n\nTITLE: Terminated Message Implementation in Akka.NET\nDESCRIPTION: Implementation of the Terminated message class that provides information about why a watched actor has died, including network failure detection.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/remoting/deathwatch.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class Terminated : IAutoReceivedMessage, IPossiblyHarmful\n{\n    public Terminated(IActorRef actorRef, bool existenceConfirmed, bool addressTerminated)\n    {\n        ActorRef = actorRef;\n        ExistenceConfirmed = existenceConfirmed;\n        AddressTerminated = addressTerminated;\n    }\n\n    public IActorRef ActorRef { get; private set; }\n\n\n    public bool AddressTerminated { get; private set; }\n\n    public bool ExistenceConfirmed { get; private set; }\n\n    public override string ToString()\n    {\n        return \"<Terminated>: \" + ActorRef + \" - ExistenceConfirmed=\" + ExistenceConfirmed;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Remote Message Serialization Classes in C#\nDESCRIPTION: Collection of serializer classes for handling different types of messages in Akka.NET remote communication. Includes serializers for system messages, protobuf, primitive types and misc messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic class DaemonMsgCreateSerializer : Akka.Serialization.Serializer\n{\n    public DaemonMsgCreateSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override bool IncludeManifest { get; }\n    public override object FromBinary(byte[] bytes, System.Type type) { }\n    public override byte[] ToBinary(object obj) { }\n}\n\npublic sealed class MiscMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public MiscMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object obj) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BroadcastPool Router in HOCON Configuration\nDESCRIPTION: Shows how to define a broadcast pool router in HOCON configuration. This router type will send each message to all routees simultaneously.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_6\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.deployment {\n  /some-pool {\n    router = broadcast-pool\n    nr-of-instances = 5\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Local Fact and Theory Attributes\nDESCRIPTION: This snippet defines custom attributes `LocalFactAttribute` and `LocalTheoryAttribute` for xUnit tests to enable skipping tests locally. It extends xUnit's `FactAttribute` and `TheoryAttribute` to support conditionally skipping tests by overwriting the 'Skip' property.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKitXunit2.DotNet.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.TestKit.Xunit2.Attributes\n{\n    public class LocalFactAttribute : Xunit.FactAttribute\n    {\n        public LocalFactAttribute() { }\n        public override string Skip { get; set; }\n        public string SkipLocal { get; set; }\n    }\n    [System.AttributeUsageAttribute(System.AttributeTargets.Method | System.AttributeTargets.All, AllowMultiple=false)]\n    [Xunit.Sdk.XunitTestCaseDiscovererAttribute(\"Xunit.Sdk.TheoryDiscoverer\", \"xunit.execution.{Platform}\")]\n    public class LocalTheoryAttribute : Xunit.TheoryAttribute\n    {\n        public LocalTheoryAttribute() { }\n        public override string Skip { get; set; }\n        public string SkipLocal { get; set; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking FSM Timer Status in C#\nDESCRIPTION: Demonstrates how to check if a named timer is currently active in the FSM.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/finite-state-machine.md#2025-04-16_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nIsTimerActive(name);\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Member Object in C# 8\nDESCRIPTION: This C# 8 code demonstrates pattern matching using a switch expression. It checks if the input 'member' is a `Member` object and returns the result of `HasRole`. If not, returns `true`.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/porting-guide.md#2025-04-16_snippet_13\n\nLANGUAGE: c#\nCODE:\n```\npublic bool MatchingRole(Member member, string role)\n    => member switch \n    {\n        Member m => m.HasRole(role),\n        _ => true\n    }\n```\n\n----------------------------------------\n\nTITLE: Creating PersistenceMessageSerializer Class in C#\nDESCRIPTION: This class is responsible for serializing and deserializing persistence messages in Akka.NET. It implements methods for converting objects to binary and vice versa.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class PersistenceMessageSerializer : Akka.Serialization.Serializer\n{\n    public PersistenceMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override bool IncludeManifest { get; }\n    public override object FromBinary(byte[] bytes, System.Type type) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Mailboxes Management Class in Akka.NET\nDESCRIPTION: Manages mailbox types and their configurations in the actor system. It provides lookup methods for mailbox types and handles mailbox requirements for actors. This class is responsible for creating and configuring mailboxes based on actor and dispatcher requirements.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_87\n\nLANGUAGE: C#\nCODE:\n```\npublic class Mailboxes\n    {\n        public static readonly string DefaultMailboxId;\n        public static readonly string NoMailboxRequirement;\n        public Mailboxes(Akka.Actor.ActorSystem system) { }\n        public Akka.Actor.DeadLetterMailbox DeadLetterMailbox { get; }\n        public Akka.Dispatch.MailboxType GetMailboxType(Akka.Actor.Props props, Akka.Configuration.Config dispatcherConfig) { }\n        public System.Type GetRequiredType(System.Type actorType) { }\n        public bool HasRequiredType(System.Type actorType) { }\n        public Akka.Dispatch.MailboxType Lookup(string id) { }\n        public Akka.Dispatch.MailboxType LookupByQueueType(System.Type queueType) { }\n        public bool ProducesMessageQueue(System.Type mailboxType) { }\n        [Akka.Annotations.InternalApiAttribute()]\n        public int StashCapacity(string dispatcher, string mailbox) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Transport Base Class Definition in C#\nDESCRIPTION: Abstract base class defining the core transport functionality for Akka.NET remote communication. Includes configuration properties and abstract methods for association handling, listening, and shutdown operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Transport\n{\n    protected Transport() { }\n    public Akka.Configuration.Config Config { get; set; }\n    public virtual long MaximumPayloadBytes { get; set; }\n    public virtual string SchemeIdentifier { get; set; }\n    public Akka.Actor.ActorSystem System { get; set; }\n    public abstract System.Threading.Tasks.Task<Akka.Remote.Transport.AssociationHandle> Associate(Akka.Actor.Address remoteAddress);\n    public abstract bool IsResponsibleFor(Akka.Actor.Address remote);\n    public abstract System.Threading.Tasks.Task<System.ValueTuple<Akka.Actor.Address, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.IAssociationEventListener>>> Listen();\n    public virtual System.Threading.Tasks.Task<bool> ManagementCommand(object message) { }\n    public abstract System.Threading.Tasks.Task<bool> Shutdown();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DNS Resolution Classes in Akka.IO\nDESCRIPTION: Contains DNS resolution implementation classes including InetAddressDnsProvider, InetAddressDnsResolver, and SimpleDnsCache for resolving and caching network addresses within Akka.IO.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_161\n\nLANGUAGE: csharp\nCODE:\n```\npublic class InetAddressDnsProvider : Akka.IO.IDnsProvider\n{\n    public InetAddressDnsProvider() { }\n    public System.Type ActorClass { get; }\n    public Akka.IO.DnsBase Cache { get; }\n    public System.Type ManagerClass { get; }\n}\npublic class InetAddressDnsResolver : Akka.Actor.ActorBase\n{\n    public InetAddressDnsResolver(Akka.IO.SimpleDnsCache cache, Akka.Configuration.Config config) { }\n    protected override bool Receive(object message) { }\n}\npublic class SimpleDnsCache : Akka.IO.DnsBase\n{\n    public SimpleDnsCache() { }\n    public override Akka.IO.Dns.Resolved Cached(string name) { }\n    public void CleanUp() { }\n    protected virtual long Clock() { }\n}\npublic class SimpleDnsManager : Akka.Actor.ActorBase, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedMessageQueueSemantics>\n{\n    public SimpleDnsManager(Akka.IO.DnsExt ext) { }\n    protected override void PostStop() { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining UdpConnected Received Event in Akka.NET\nDESCRIPTION: Event notification for when data is received over a UDP connection. Contains the received data as a ByteString for efficient binary handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_182\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Received : Akka.IO.UdpConnected.Event\n{\n    public Received(Akka.IO.ByteString data) { }\n    public Akka.IO.ByteString Data { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DurableProducerQueue for Akka.NET Delivery in C#\nDESCRIPTION: This snippet defines the DurableProducerQueue class for managing durable message production in Akka.NET. It includes classes for loading state and handling sent messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_72\n\nLANGUAGE: C#\nCODE:\n```\npublic class static DurableProducerQueue\n{\n    public const string NoQualifier = \"\";\n    public interface IDurableProducerQueueCommand { }\n    public sealed class LoadState : Akka.Delivery.DurableProducerQueue.IDurableProducerQueueCommand, System.IEquatable<Akka.Delivery.DurableProducerQueue.LoadState>\n    {\n        public LoadState(Akka.Actor.IActorRef ReplyTo) { }\n        public Akka.Actor.IActorRef ReplyTo { get; set; }\n    }\n    public sealed class MessageSent<T> : Akka.Delivery.Internal.IDeliverySerializable, System.IEquatable<Akka.Delivery.DurableProducerQueue.MessageSent<T>>\n    {\n        public MessageSent(long SeqNr, Akka.Delivery.Internal.MessageOrChunk<T> Message, bool Ack, string ConfirmationQualifier, long Timestamp) { }\n        public bool Ack { get; set; }\n        public string ConfirmationQualifier { get; set; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UDP Extension and Message Classes in C#\nDESCRIPTION: Defines the UDP extension and various message classes for UDP communication. Includes commands and events for binding, sending, and receiving UDP packets.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_171\n\nLANGUAGE: C#\nCODE:\n```\npublic class Udp : Akka.Actor.ExtensionIdProvider<Akka.IO.UdpExt>\n{\n    public static readonly Akka.IO.Udp Instance;\n    public Udp() { }\n    public override Akka.IO.UdpExt CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n    public static Akka.Actor.IActorRef Manager(Akka.Actor.ActorSystem system) { }\n    public sealed class Bind : Akka.IO.Udp.Command\n    {\n        public Bind(Akka.Actor.IActorRef handler, System.Net.EndPoint localAddress, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options = null) { }\n        public Akka.Actor.IActorRef Handler { get; }\n        public System.Net.EndPoint LocalAddress { get; }\n        public System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> Options { get; }\n        public override string ToString() { }\n    }\n    public sealed class Bound : Akka.IO.Udp.Event\n    {\n        public Bound(System.Net.EndPoint localAddress) { }\n        public System.Net.EndPoint LocalAddress { get; }\n        public override string ToString() { }\n    }\n    public abstract class Command : Akka.IO.Udp.Message\n    {\n        protected Command() { }\n        public object FailureMessage { get; }\n    }\n    public sealed class CommandFailed : Akka.IO.Udp.Event\n    {\n        public CommandFailed(Akka.IO.Udp.Command cmd) { }\n        public Akka.IO.Udp.Command Cmd { get; }\n        public override string ToString() { }\n    }\n    public abstract class Event : Akka.IO.Udp.Message\n    {\n        protected Event() { }\n    }\n    public abstract class Message : Akka.Actor.INoSerializationVerificationNeeded\n    {\n        protected Message() { }\n    }\n    public sealed class NoAck : Akka.IO.Udp.Event\n    {\n        public static readonly Akka.IO.Udp.NoAck Instance;\n        public NoAck(object token) { }\n        public object Token { get; }\n        public override string ToString() { }\n    }\n    public sealed class Received : Akka.IO.Udp.Event\n    {\n        public Received(Akka.IO.ByteString data, System.Net.EndPoint sender) { }\n        public Akka.IO.ByteString Data { get; }\n        public System.Net.EndPoint Sender { get; }\n        public override string ToString() { }\n    }\n    public sealed class ResumeReading : Akka.IO.Udp.Command\n    {\n        public static readonly Akka.IO.Udp.ResumeReading Instance;\n    }\n    public sealed class SO : Akka.IO.Inet.SoForwarders\n    {\n        public SO() { }\n        public sealed class Broadcast : Akka.IO.Inet.SocketOption\n        {\n            public Broadcast(bool on) { }\n            public bool On { get; }\n            public override void BeforeDatagramBind(System.Net.Sockets.Socket s) { }\n        }\n    }\n    public sealed class Send : Akka.IO.Udp.Command\n    {\n        public Send(Akka.IO.ByteString payload, System.Net.EndPoint target, Akka.IO.Udp.Event ack) { }\n        public Akka.IO.Udp.Event Ack { get; }\n        public Akka.IO.ByteString Payload { get; }\n        public System.Net.EndPoint Target { get; }\n        public bool WantsAck { get; }\n        public static Akka.IO.Udp.Send Create(Akka.IO.ByteString data, System.Net.EndPoint target) { }\n        public override string ToString() { }\n    }\n    public sealed class SimpleSender : Akka.IO.Udp.Command\n    {\n        public static readonly Akka.IO.Udp.SimpleSender Instance;\n        public SimpleSender(System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options = null) { }\n        public System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> Options { get; }\n    }\n    public sealed class SimpleSenderReady : Akka.IO.Udp.Event\n    {\n        public static readonly Akka.IO.Udp.SimpleSenderReady Instance;\n    }\n    public sealed class SuspendReading : Akka.IO.Udp.Command\n    {\n        public static readonly Akka.IO.Udp.SuspendReading Instance;\n    }\n    public sealed class Unbind : Akka.IO.Udp.Command\n    {\n        public static readonly Akka.IO.Udp.Unbind Instance;\n    }\n    public sealed class Unbound\n    {\n        public static readonly Akka.IO.Udp.Unbound Instance;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: AsyncHandlerInvocation Class Definition in Akka.Persistence\nDESCRIPTION: Implements the IPendingHandlerInvocation interface to represent an asynchronous event handler. This class holds an event and its associated handler function for delayed execution during event replay in persistent actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class AsyncHandlerInvocation : Akka.Persistence.IPendingHandlerInvocation\n{\n    public AsyncHandlerInvocation(object evt, System.Action<object> handler) { }\n    public object Event { get; }\n    public System.Action<object> Handler { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: HOCON Configuration for Akka.Persistence Snapshot Store Plugin\nDESCRIPTION: This HOCON configuration snippet outlines the essential settings and default fallbacks for a custom SQLite snapshot store plugin within Akka.Persistence. It specifies the class implementation, plugin dispatcher, and circuit breaker settings to ensure reliable snapshot management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/custom-persistence-provider.md#2025-04-16_snippet_13\n\nLANGUAGE: hocon\nCODE:\n```\nakka.persistence{\n  snapshot-store {\n    plugin = \"akka.persistence.snapshot-store.custom-sqlite\"\n    custom-sqlite {\n      class = \"Akka.Persistence.Custom.Snapshot.SqliteSnapshotStore, Akka.Persistence.Custom\"\n    }\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Data Envelope Classes for Akka.NET Distributed Data in C#\nDESCRIPTION: This snippet defines two data envelope classes, DurableDataEnvelope and DataEnvelope, used in Akka.NET Distributed Data for encapsulating replicated data. These classes implement IReplicatorMessage interface and provide methods for equality comparison and hash code generation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_52\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DurableDataEnvelope : Akka.DistributedData.IReplicatorMessage, System.IEquatable<Akka.DistributedData.Durable.DurableDataEnvelope>\n{\n    public DurableDataEnvelope(Akka.DistributedData.Internal.DataEnvelope dataEnvelope) { }\n    public DurableDataEnvelope(Akka.DistributedData.IReplicatedData data) { }\n    public Akka.DistributedData.IReplicatedData Data { get; }\n    public bool Equals(Akka.DistributedData.Durable.DurableDataEnvelope other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n}\n\npublic sealed class DataEnvelope : Akka.DistributedData.IReplicatorMessage, System.IEquatable<Akka.DistributedData.Internal.DataEnvelope>\n{\n    public Akka.DistributedData.IReplicatedData Data { get; }\n    public static Akka.DistributedData.Internal.DataEnvelope DeletedEnvelope { get; }\n    public Akka.DistributedData.VersionVector DeltaVersions { get; }\n    public System.Collections.Immutable.ImmutableDictionary<Akka.Cluster.UniqueAddress, Akka.DistributedData.IPruningState> Pruning { get; }\n    public bool Equals(Akka.DistributedData.Internal.DataEnvelope other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Actor Identity and Initialization Classes\nDESCRIPTION: Provides custom exception and identity classes for actor management in Akka.NET, including handling actor initialization, interruption, and path resolution\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic ActorIdentity(object messageId, Akka.Actor.IActorRef subject) { }\n```\n\n----------------------------------------\n\nTITLE: Querying Default Internal Stash Overflow Strategy in Akka.NET\nDESCRIPTION: Retrieves the default internal stash overflow strategy for the current actor system using the Akka persistence extension singleton.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/event-sourcing.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nContext.System.DefaultInternalStashOverflowStrategy\n```\n\n----------------------------------------\n\nTITLE: Using PriorityWorkerPool in an Akka.NET Streams Graph\nDESCRIPTION: Demonstrates how to use the custom PriorityWorkerPool in a complete stream processing graph. This example creates two worker pools in sequence, processes string jobs, and prints the results to the console.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithgraphs.md#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nvar worker1 = Flow.Create<string>().Select(s => \"step 1 \" + s);\nvar worker2 = Flow.Create<string>().Select(s => \"step 2 \" + s);\n\nRunnableGraph.FromGraph(GraphDsl.Create(b =>\n{\n    Func<string, Source<string, NotUsed>> createSource = desc =>\n        Source.From(Enumerable.Range(1, 100))\n            .Select(s => desc + s);\n\n    var priorityPool1 = b.Add(PriorityWorkerPool.Create(worker1, 4));\n    var priorityPool2 = b.Add(PriorityWorkerPool.Create(worker2, 2));\n\n    b.From(createSource(\"job: \")).To(priorityPool1.JobsIn);\n    b.From(createSource(\"priority job: \")).To(priorityPool1.PriorityJobsIn);\n\n    b.From(priorityPool1.ResultsOut).To(priorityPool2.JobsIn);\n    b.From(createSource(\"one-step, priority : \")).To(priorityPool2.PriorityJobsIn);\n\n    var sink = Sink.ForEach<string>(Console.WriteLine).MapMaterializedValue(_ => NotUsed.Instance);\n    b.From(priorityPool2.ResultsOut).To(sink);\n    return ClosedShape.Instance;\n})).Run(materializer);\n```\n\n----------------------------------------\n\nTITLE: Defining HOCON Element Interfaces in C#\nDESCRIPTION: This snippet defines interfaces for HOCON elements, including methods for retrieving arrays, strings, and objects from the configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_69\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IHoconElement\n{\n    System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray();\n    string GetString();\n    bool IsArray();\n    bool IsString();\n}\npublic interface IMightBeAHoconObject\n{\n    Akka.Configuration.Hocon.HoconObject GetObject();\n    bool IsObject();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LogMessage Abstract Class in C#\nDESCRIPTION: Abstract base class for log messages with formatting capabilities. Provides a foundation for creating structured log messages with custom formatting and parameter handling. Includes internal API methods for processing formatted and unformatted message content.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_146\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class LogMessage\n{\n    protected readonly Akka.Event.ILogMessageFormatter Formatter;\n    public LogMessage(Akka.Event.ILogMessageFormatter formatter, string format) { }\n    public string Format { get; }\n    [Akka.Annotations.InternalApiAttribute()]\n    public abstract System.Collections.Generic.IEnumerable<object> Parameters();\n    [Akka.Annotations.InternalApiAttribute()]\n    public abstract string Unformatted();\n}\n\npublic class static LogMessageExtensions { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Unbounded Message Queue in Akka.NET\nDESCRIPTION: Defines a basic unbounded message queue implementation for actors that can grow as needed. Provides standard queue operations with no capacity constraints.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_112\n\nLANGUAGE: C#\nCODE:\n```\npublic class UnboundedMessageQueue : Akka.Dispatch.ISemantics, Akka.Dispatch.IUnboundedMessageQueueSemantics, Akka.Dispatch.MessageQueues.IMessageQueue\n{\n    public UnboundedMessageQueue() { }\n    public int Count { get; }\n    public bool HasMessages { get; }\n    public void CleanUp(Akka.Actor.IActorRef owner, Akka.Dispatch.MessageQueues.IMessageQueue deadletters) { }\n    public void Enqueue(Akka.Actor.IActorRef receiver, Akka.Actor.Envelope envelope) { }\n    public bool TryDequeue(out Akka.Actor.Envelope envelope) { }\n}\n```\n\n----------------------------------------\n\nTITLE: ConsistentHashingPool Code Configuration\nDESCRIPTION: Code-based configuration for ConsistentHashingPool router.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\nvar router = system.ActorOf(Props.Create<Worker>().WithRouter(new ConsistentHashingPool(5)), \"some-pool\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Log Extension Methods for ILoggingAdapter in Akka.NET\nDESCRIPTION: Defines extension methods for custom log-level logging with various generic type parameters. These methods extend ILoggingAdapter to provide strongly-typed logging with specified log levels, format strings, and exception causes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_137\n\nLANGUAGE: C#\nCODE:\n```\npublic static void Log(this Akka.Event.ILoggingAdapter log, Akka.Event.LogLevel level, string format) { }\npublic static void Log(this Akka.Event.ILoggingAdapter log, Akka.Event.LogLevel level, string format, object[] args) { }\npublic static void Log(this Akka.Event.ILoggingAdapter log, Akka.Event.LogLevel level, System.Exception cause, string format, object[] args) { }\npublic static void Log<T1>(this Akka.Event.ILoggingAdapter log, Akka.Event.LogLevel logLevel, System.Exception cause, string format, T1 arg1) { }\npublic static void Log<T1, T2>(this Akka.Event.ILoggingAdapter log, Akka.Event.LogLevel logLevel, System.Exception cause, string format, T1 arg1, T2 arg2) { }\npublic static void Log<T1, T2, T3>(this Akka.Event.ILoggingAdapter log, Akka.Event.LogLevel logLevel, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3) { }\npublic static void Log<T1, T2, T3, T4>(this Akka.Event.ILoggingAdapter log, Akka.Event.LogLevel logLevel, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4) { }\npublic static void Log<T1, T2, T3, T4, T5>(this Akka.Event.ILoggingAdapter log, Akka.Event.LogLevel logLevel, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) { }\npublic static void Log<T1, T2, T3, T4, T5, T6>(this Akka.Event.ILoggingAdapter log, Akka.Event.LogLevel logLevel, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) { }\n```\n\n----------------------------------------\n\nTITLE: RemoteTransport Abstract Class in C#\nDESCRIPTION: Abstract base class for remote transport implementations that handle network communication between remote actors. Provides core functionality for message sending and system management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class RemoteTransport\n{\n    protected RemoteTransport(Akka.Actor.ExtendedActorSystem system, Akka.Remote.RemoteActorRefProvider provider) { }\n    public abstract System.Collections.Generic.ISet<Akka.Actor.Address> Addresses { get; }\n    public abstract Akka.Actor.Address DefaultAddress { get; }\n    // Additional members...\n}\n```\n\n----------------------------------------\n\nTITLE: Recovery Class Implementation in C#\nDESCRIPTION: Sealed class defining recovery parameters and configurations for Akka.NET persistence, including snapshot selection criteria and sequence number boundaries.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Recovery\n{\n    public Recovery() { }\n    public Recovery(Akka.Persistence.SnapshotSelectionCriteria fromSnapshot) { }\n    public Recovery(Akka.Persistence.SnapshotSelectionCriteria fromSnapshot, long toSequenceNr) { }\n    public Recovery(Akka.Persistence.SnapshotSelectionCriteria fromSnapshot = null, long toSequenceNr = 9223372036854775807, long replayMax = 9223372036854775807) { }\n    public static Akka.Persistence.Recovery Default { get; }\n    public Akka.Persistence.SnapshotSelectionCriteria FromSnapshot { get; }\n    public static Akka.Persistence.Recovery None { get; }\n    public long ReplayMax { get; }\n    public long ToSequenceNr { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Snapshot Deletion Equality in C#\nDESCRIPTION: This snippet defines equality methods including \"Equals\" and \"GetHashCode\" for the DeleteSnapshot class in Akka Persistence. It ensures that instances of DeleteSnapshot can be correctly compared, a fundamental aspect when dealing with operational messages in Akka.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\npublic bool Equals(Akka.Persistence.DeleteSnapshot other) { }\npublic override bool Equals(object obj) { }\npublic override int GetHashCode() { }\npublic override string ToString() { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Listener Support and Message Handling in C#\nDESCRIPTION: Implements listener support functionality with message handling capabilities. Includes classes for managing actor listeners and message broadcasting.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_181\n\nLANGUAGE: C#\nCODE:\n```\npublic class ListenerSupport\n{\n    protected readonly System.Collections.Generic.HashSet<Akka.Actor.IActorRef> Listeners;\n    public ListenerSupport() { }\n    public Akka.Actor.Receive ListenerReceive { get; }\n    public void Add(Akka.Actor.IActorRef actor) { }\n    public void Gossip(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: InMemoryReadJournal Class Implementation\nDESCRIPTION: Implements multiple Akka.Persistence.Query interfaces for in-memory journal operations, providing methods for querying events and persistence IDs.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceInMemoryQuery.Net.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class InMemoryReadJournal : Akka.Persistence.Query.IAllEventsQuery, Akka.Persistence.Query.ICurrentAllEventsQuery, Akka.Persistence.Query.ICurrentEventsByPersistenceIdQuery, Akka.Persistence.Query.ICurrentEventsByTagQuery, Akka.Persistence.Query.ICurrentPersistenceIdsQuery, Akka.Persistence.Query.IEventsByPersistenceIdQuery, Akka.Persistence.Query.IEventsByTagQuery, Akka.Persistence.Query.IPersistenceIdsQuery, Akka.Persistence.Query.IReadJournal\n{\n    public const string Identifier = \"akka.persistence.query.journal.inmem\";\n    public InMemoryReadJournal(Akka.Configuration.Config config) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> AllEvents(Akka.Persistence.Query.Offset offset = null) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentAllEvents(Akka.Persistence.Query.Offset offset) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentEventsByPersistenceId(string persistenceId, long fromSequenceNr, long toSequenceNr) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentEventsByTag(string tag, Akka.Persistence.Query.Offset offset) { }\n    public Akka.Streams.Dsl.Source<string, Akka.NotUsed> CurrentPersistenceIds() { }\n    public static Akka.Configuration.Config DefaultConfiguration() { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> EventsByPersistenceId(string persistenceId, long fromSequenceNr, long toSequenceNr) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> EventsByTag(string tag, Akka.Persistence.Query.Offset offset) { }\n    public Akka.Streams.Dsl.Source<string, Akka.NotUsed> PersistenceIds() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Enhanced Publish-Subscribe Channel in Akka.NET Streams\nDESCRIPTION: Example of using the enhanced publish-subscribe channel, which now has a type of Flow<string, string, UniqueKillSwitch> and can be used to attach new producers or consumers.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/stream-dynamic.md#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n[!code-csharp[HubsDocTests.cs](../../../src/core/Akka.Docs.Tests/Streams/HubsDocTests.cs?name=pub-sub-4)]\n```\n\n----------------------------------------\n\nTITLE: Defining ExpectOneAsync Methods in C#\nDESCRIPTION: A collection of overloaded ExpectOneAsync methods for handling asynchronous expectations in tests. Includes variants for different return types and timeout options.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nSystem.Threading.Tasks.Task ExpectOneAsync(System.Func<System.Threading.Tasks.Task> actionAsync, System.Threading.CancellationToken cancellationToken = null);\nSystem.Threading.Tasks.Task ExpectOneAsync(System.TimeSpan timeout, System.Func<System.Threading.Tasks.Task> action, System.Threading.CancellationToken cancellationToken = null);\n```\n\n----------------------------------------\n\nTITLE: Implementing ByteArraySerializer in C#\nDESCRIPTION: Defines the ByteArraySerializer class for serializing and deserializing byte arrays in Akka.NET. It includes methods for converting objects to and from binary representations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_223\n\nLANGUAGE: C#\nCODE:\n```\npublic class ByteArraySerializer : Akka.Serialization.Serializer\n{\n    public ByteArraySerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override bool IncludeManifest { get; }\n    public override object FromBinary(byte[] bytes, System.Type type) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ReplayTaggedMessages Class in C#\nDESCRIPTION: Defines a sealed class ReplayTaggedMessages that implements multiple interfaces for journal message handling in Akka.NET persistence. It includes properties for offset, max count, reply actor, and tag.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_51\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ReplayTaggedMessages : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IJournalMessage, Akka.Persistence.IJournalRequest, Akka.Persistence.IPersistenceMessage\n{\n    public readonly int FromOffset;\n    public readonly int Max;\n    public readonly Akka.Actor.IActorRef ReplyTo;\n    public readonly string Tag;\n    public readonly int ToOffset;\n    public ReplayTaggedMessages(int fromOffset, int toOffset, int max, string tag, Akka.Actor.IActorRef replyTo) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Dispatcher Prerequisites Interface in C#\nDESCRIPTION: Interface that defines the prerequisites needed for a dispatcher to function, including access to the event stream, mailboxes, scheduler, and system settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_91\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IDispatcherPrerequisites\n{\n    Akka.Event.EventStream EventStream { get; }\n    Akka.Dispatch.Mailboxes Mailboxes { get; }\n    Akka.Actor.IScheduler Scheduler { get; }\n    Akka.Actor.Settings Settings { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AbstractQueryExecutor for Akka.NET SQL Journal in C#\nDESCRIPTION: Defines an abstract base class for SQL journal query execution in Akka.NET Persistence. Includes methods for CRUD operations on events, persistence IDs, and sequence numbers.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.DotNet.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AbstractQueryExecutor : Akka.Persistence.Sql.Common.Journal.IJournalQueryExecutor\n{\n    protected const int IsDeletedIndex = 3;\n    protected static readonly string LongTypeName;\n    protected const int ManifestIndex = 4;\n    protected const int OrderingIndex = 7;\n    protected const int PayloadIndex = 5;\n    protected const int PersistenceIdIndex = 0;\n    protected const int SequenceNrIndex = 1;\n    protected Akka.Serialization.Serialization Serialization;\n    protected const int SerializerIdIndex = 6;\n    protected const int TimestampIndex = 2;\n    protected Akka.Persistence.Sql.Common.Journal.ITimestampProvider TimestampProvider;\n    protected AbstractQueryExecutor(Akka.Persistence.Sql.Common.Journal.QueryConfiguration configuration, Akka.Serialization.Serialization serialization, Akka.Persistence.Sql.Common.Journal.ITimestampProvider timestampProvider) { }\n    // ... (additional properties and methods)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Delta Propagation Classes for Akka.NET Distributed Data in C#\nDESCRIPTION: This snippet defines classes related to delta propagation in Akka.NET Distributed Data, including Delta, DeltaNack, and DeltaPropagation. These classes are used for efficient updates and synchronization of distributed data across nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_53\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Delta : System.IEquatable<Akka.DistributedData.Internal.Delta>\n{\n    public Delta(Akka.DistributedData.Internal.DataEnvelope dataEnvelope, long fromSeqNr, long toSeqNr) { }\n    public Akka.DistributedData.Internal.DataEnvelope DataEnvelope { get; }\n    public long FromSeqNr { get; }\n    public bool RequiresCausalDeliveryOfDeltas { get; }\n    public long ToSeqNr { get; }\n    public bool Equals(Akka.DistributedData.Internal.Delta other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n}\n\npublic sealed class DeltaNack : Akka.DistributedData.IReplicatorMessage, Akka.Event.IDeadLetterSuppression, System.IEquatable<Akka.DistributedData.Internal.DeltaNack>\n{\n    public static readonly Akka.DistributedData.Internal.DeltaNack Instance;\n    public bool Equals(Akka.DistributedData.Internal.DeltaNack other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n}\n\npublic sealed class DeltaPropagation : Akka.DistributedData.IReplicatorMessage, System.IEquatable<Akka.DistributedData.Internal.DeltaPropagation>\n{\n    public static readonly Akka.DistributedData.IReplicatedDelta NoDeltaPlaceholder;\n    public DeltaPropagation(Akka.Cluster.UniqueAddress fromNode, bool shouldReply, System.Collections.Immutable.ImmutableDictionary<string, Akka.DistributedData.Internal.Delta> deltas) { }\n    public System.Collections.Immutable.ImmutableDictionary<string, Akka.DistributedData.Internal.Delta> Deltas { get; }\n    public Akka.Cluster.UniqueAddress FromNode { get; }\n    public bool ShouldReply { get; }\n    public bool Equals(Akka.DistributedData.Internal.DeltaPropagation other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ORMultiValueDictionary Classes for Multi-Value Dictionaries - C#\nDESCRIPTION: Definition of ORMultiValueDictionary and its key class for implementing distributed multi-value dictionaries (maps with multiple values per key). This convergent data type supports add/remove operations across a cluster with automatic conflict resolution.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ORMultiValueDictionaryKey<TKey, TValue> : Akka.DistributedData.Key<Akka.DistributedData.ORMultiValueDictionary<TKey, TValue>>\n{\n    public ORMultiValueDictionaryKey(string id) { }\n    public System.Type KeyType { get; }\n    public System.Type ValueType { get; }\n}\n\npublic sealed class ORMultiValueDictionary<TKey, TValue> : Akka.DistributedData.IDeltaReplicatedData, Akka.DistributedData.IDeltaReplicatedData<Akka.DistributedData.ORMultiValueDictionary<TKey, TValue>, Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.ORSet<TValue>>.IDeltaOperation>, Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IRemovedNodePruning<Akka.DistributedData.ORMultiValueDictionary<TKey, TValue>>, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.ORMultiValueDictionary<TKey, TValue>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, System.Collections.Immutable.IImmutableSet<TValue>>>, System.Collections.IEnumerable, System.IEquatable<Akka.DistributedData.ORMultiValueDictionary<TKey, TValue>>\n{\n    public static readonly Akka.DistributedData.ORMultiValueDictionary<TKey, TValue> Empty;\n    public static readonly Akka.DistributedData.ORMultiValueDictionary<TKey, TValue> EmptyWithValueDeltas;\n    public int Count { get; }\n    public Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.ORSet<TValue>>.IDeltaOperation Delta { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AbstractQueryExecutor for SQL Journal Operations\nDESCRIPTION: Defines an abstract class AbstractQueryExecutor that implements IJournalQueryExecutor. It provides methods for creating tables, inserting events, and querying the journal.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class AbstractQueryExecutor : Akka.Persistence.Sql.Common.Journal.IJournalQueryExecutor\n{\n    protected const int IsDeletedIndex = 3;\n    protected static readonly string LongTypeName;\n    protected const int ManifestIndex = 4;\n    protected const int OrderingIndex = 7;\n    protected const int PayloadIndex = 5;\n    protected const int PersistenceIdIndex = 0;\n    protected const int SequenceNrIndex = 1;\n    protected Akka.Serialization.Serialization Serialization;\n    protected const int SerializerIdIndex = 6;\n    protected const int TimestampIndex = 2;\n    protected Akka.Persistence.Sql.Common.Journal.ITimestampProvider TimestampProvider;\n    protected AbstractQueryExecutor(Akka.Persistence.Sql.Common.Journal.QueryConfiguration configuration, Akka.Serialization.Serialization serialization, Akka.Persistence.Sql.Common.Journal.ITimestampProvider timestampProvider) { }\n    // ... (other properties and methods)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ObjectExtensions in Akka.Util.Extensions Namespace\nDESCRIPTION: Extension methods for object class that add functional programming capabilities. The AsOption method wraps any object in an Option container for safer null handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_224\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.Util.Extensions\n{\n    public class static ObjectExtensions\n    {\n        public static Akka.Util.Option<T> AsOption<T>(this T obj) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AppVersion Class for Version Management in C#\nDESCRIPTION: Defines the AppVersion class for version management in Akka.NET. It implements IComparable and IEquatable interfaces, providing methods for version comparison, creation, and equality checks.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_204\n\nLANGUAGE: C#\nCODE:\n```\npublic class AppVersion : System.IComparable<Akka.Util.AppVersion>, System.IEquatable<Akka.Util.AppVersion>\n{\n    public static readonly Akka.Util.AppVersion Zero;\n    public string Version { get; }\n    public int CompareTo(Akka.Util.AppVersion other) { }\n    public static Akka.Util.AppVersion Create(string version) { }\n    public bool Equals(Akka.Util.AppVersion other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n    public static bool ==(Akka.Util.AppVersion first, Akka.Util.AppVersion second) { }\n    public static bool !=(Akka.Util.AppVersion first, Akka.Util.AppVersion second) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Watch System Message in Akka.NET\nDESCRIPTION: Defines a system message that requests an actor to watch another actor for termination notifications. Contains references to both the watcher and watchee actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_134\n\nLANGUAGE: C#\nCODE:\n```\npublic class Watch : Akka.Dispatch.SysMsg.SystemMessage\n{\n    public Watch(Akka.Actor.IInternalActorRef watchee, Akka.Actor.IInternalActorRef watcher) { }\n    public Akka.Actor.IInternalActorRef Watchee { get; }\n    public Akka.Actor.IInternalActorRef Watcher { get; }\n    protected bool Equals(Akka.Dispatch.SysMsg.Watch other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: HOCON Configuration for Akka.Persistence Journal Plugin\nDESCRIPTION: This HOCON configuration snippet defines the necessary settings for a custom SQLite journal plugin within Akka.Persistence. The configuration outlines the class information, dispatcher settings, and additional parameters needed for the plugin to function correctly within the Akka framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/custom-persistence-provider.md#2025-04-16_snippet_12\n\nLANGUAGE: hocon\nCODE:\n```\nakka.persistence.journal {\n  plugin = \"akka.persistence.journal.custom-sqlite\"\n  custom-sqlite {\n    class = \"Akka.Persistence.Custom.Journal.SqliteJournal, Akka.Persistence.Custom\"\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating LWWDictionary Static Factory Methods\nDESCRIPTION: Static factory methods for creating LWWDictionary instances with various initialization options. These methods provide convenient ways to create dictionaries with initial values.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic class static LWWDictionary\n{\n    public static Akka.DistributedData.LWWDictionary<TKey, TValue> Create<TKey, TValue>(Akka.Cluster.UniqueAddress node, TKey key, TValue value, Akka.DistributedData.Clock<TValue> clock = null) { }\n    public static Akka.DistributedData.LWWDictionary<TKey, TValue> Create<TKey, TValue>(params System.ValueTuple<, , >[] elements) { }\n    public static Akka.DistributedData.LWWDictionary<TKey, TValue> Create<TKey, TValue>(System.Collections.Generic.IEnumerable<System.ValueTuple<Akka.Cluster.UniqueAddress, TKey, TValue>> elements, Akka.DistributedData.Clock<TValue> clock = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SQL Journal in C# for Akka.NET\nDESCRIPTION: The SqlJournal abstract class extends AsyncWriteJournal and implements various interfaces for journal functionality. It provides methods for creating database connections, reading and writing messages, and managing subscriptions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class SqlJournal : Akka.Persistence.Journal.AsyncWriteJournal, Akka.Actor.IActorStash, Akka.Actor.IWithUnboundedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics>\n{\n    protected SqlJournal(Akka.Configuration.Config journalConfig) { }\n    protected bool HasNewEventSubscribers { get; }\n    protected bool HasPersistenceIdSubscribers { get; }\n    protected bool HasTagSubscribers { get; }\n    protected abstract string JournalConfigPath { get; }\n    protected Akka.Event.ILoggingAdapter Log { get; }\n    public abstract Akka.Persistence.Sql.Common.Journal.IJournalQueryExecutor QueryExecutor { get; }\n    public Akka.Actor.IStash Stash { get; set; }\n    public void AddNewEventsSubscriber(Akka.Actor.IActorRef subscriber) { }\n    public void AddPersistenceIdSubscriber(Akka.Actor.IActorRef subscriber, string persistenceId) { }\n    public void AddTagSubscriber(Akka.Actor.IActorRef subscriber, string tag) { }\n    protected abstract System.Data.Common.DbConnection CreateDbConnection(string connectionString);\n    public System.Data.Common.DbConnection CreateDbConnection() { }\n    protected override System.Threading.Tasks.Task DeleteMessagesToAsync(string persistenceId, long toSequenceNr) { }\n    protected virtual string GetConnectionString() { }\n    protected Akka.Persistence.Sql.Common.Journal.ITimestampProvider GetTimestampProvider(string typeName) { }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n    public override System.Threading.Tasks.Task<long> ReadHighestSequenceNrAsync(string persistenceId, long fromSequenceNr) { }\n    protected override bool ReceivePluginInternal(object message) { }\n    public void RemoveSubscriber(Akka.Actor.IActorRef subscriber) { }\n    protected virtual System.Threading.Tasks.Task<long> ReplayAllEventsAsync(Akka.Persistence.Sql.Common.Journal.ReplayAllEvents replay) { }\n    public override System.Threading.Tasks.Task ReplayMessagesAsync(Akka.Actor.IActorContext context, string persistenceId, long fromSequenceNr, long toSequenceNr, long max, System.Action<Akka.Persistence.IPersistentRepresentation> recoveryCallback) { }\n    protected virtual System.Threading.Tasks.Task<long> ReplayTaggedMessagesAsync(Akka.Persistence.Sql.Common.Journal.ReplayTaggedMessages replay) { }\n    [return: System.Runtime.CompilerServices.TupleElementNamesAttribute(new string[] {\n            \"Ids\",\n            \"LastOrdering\"})]\n    protected virtual System.Threading.Tasks.Task<System.ValueTuple<System.Collections.Generic.IEnumerable<string>, long>> SelectAllPersistenceIdsAsync(long offset) { }\n    protected bool WaitingForInitialization(object message) { }\n    protected override System.Threading.Tasks.Task<System.Collections.Immutable.IImmutableList<System.Exception>> WriteMessagesAsync(System.Collections.Generic.IEnumerable<Akka.Persistence.AtomicWrite> messages) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IChildrenContainer Interface in C#\nDESCRIPTION: Interface defining the contract for containers managing child actors, including methods for manipulation and querying the actor hierarchy.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_54\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IChildrenContainer\n{\n    System.Collections.Generic.IReadOnlyCollection<Akka.Actor.IInternalActorRef> Children { get; }\n    bool IsNormal { get; }\n    bool IsTerminating { get; }\n    System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> Stats { get; }\n    Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats);\n    bool Contains(Akka.Actor.IActorRef actor);\n    Akka.Actor.Internal.IChildrenContainer Remove(Akka.Actor.IActorRef child);\n    Akka.Actor.Internal.IChildrenContainer Reserve(string name);\n    Akka.Actor.Internal.IChildrenContainer ShallDie(Akka.Actor.IActorRef actor);\n    bool TryGetByName(string name, out Akka.Actor.Internal.IChildStats stats);\n    bool TryGetByRef(Akka.Actor.IActorRef actor, out Akka.Actor.Internal.ChildRestartStats stats);\n    Akka.Actor.Internal.IChildrenContainer Unreserve(string name);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TerminatingChildrenContainer Class in C#\nDESCRIPTION: Container for child actors that are in the process of terminating. Manages the termination process with tracking of pending children to terminate.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_62\n\nLANGUAGE: C#\nCODE:\n```\npublic class TerminatingChildrenContainer : Akka.Actor.Internal.ChildrenContainerBase\n{\n    public TerminatingChildrenContainer(System.Collections.Immutable.IImmutableDictionary<string, Akka.Actor.Internal.IChildStats> children, Akka.Actor.IActorRef toDie, Akka.Actor.Internal.SuspendReason reason) { }\n    public TerminatingChildrenContainer(System.Collections.Immutable.IImmutableDictionary<string, Akka.Actor.Internal.IChildStats> children, System.Collections.Immutable.ImmutableHashSet<Akka.Actor.IActorRef> toDie, Akka.Actor.Internal.SuspendReason reason) { }\n    public override bool IsNormal { get; }\n    public override bool IsTerminating { get; }\n    public Akka.Actor.Internal.SuspendReason Reason { get; }\n    public System.Collections.Immutable.ImmutableHashSet<Akka.Actor.IActorRef> ToDie { get; }\n    public override Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats) { }\n    public Akka.Actor.Internal.IChildrenContainer CreateCopyWithReason(Akka.Actor.Internal.SuspendReason reason) { }\n    public override Akka.Actor.Internal.IChildrenContainer Remove(Akka.Actor.IActorRef child) { }\n    public override Akka.Actor.Internal.IChildrenContainer Reserve(string name) { }\n    public override Akka.Actor.Internal.IChildrenContainer ShallDie(Akka.Actor.IActorRef actor) { }\n    public override string ToString() { }\n    public override Akka.Actor.Internal.IChildrenContainer Unreserve(string name) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BitArrayHelpers Static Class in C#\nDESCRIPTION: A utility class with extension methods for BitArray operations. Provides the ToBytes method to convert a BitArray to a byte array.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_232\n\nLANGUAGE: C#\nCODE:\n```\npublic class static BitArrayHelpers\n{\n    public static byte[] ToBytes(this System.Collections.BitArray arr) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ChunkedMessage Struct in Akka.Delivery.Internal\nDESCRIPTION: Defines a read-only struct used to represent a chunk of a larger message in Akka's reliable delivery system. It tracks whether the chunk is the first or last part of a message, and contains serialization information.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_73\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\n[System.Runtime.CompilerServices.IsReadOnlyAttribute()]\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic struct ChunkedMessage\n{\n    public ChunkedMessage(Akka.IO.ByteString serializedMessage, bool firstChunk, bool lastChunk, int serializerId, string manifest) { }\n    public bool FirstChunk { get; }\n    public bool LastChunk { get; }\n    public string Manifest { get; }\n```\n\n----------------------------------------\n\nTITLE: ReceiveTimeout Message in Akka.NET (C#)\nDESCRIPTION: Special message sent to actors when they haven't received any messages for a configured timeout period. Implements IPossiblyHarmful to indicate it's a system message.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\npublic class ReceiveTimeout : Akka.Actor.IPossiblyHarmful\n{\n    public static Akka.Actor.ReceiveTimeout Instance { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Akka.NET Configuration from App.config\nDESCRIPTION: Shows how to create an ActorSystem that automatically loads configuration from App.config or Web.config.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/config.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar system = ActorSystem.Create(\"MySystem\"); //automatically loads App/Web.config\n```\n\n----------------------------------------\n\nTITLE: ClusterClientDiscovery Actor Implementation\nDESCRIPTION: The ClusterClientDiscovery class handles service discovery for ClusterClient, implementing various Akka.NET actor interfaces for message handling, timing, and stashing functionality. It manages the process of discovering and connecting to cluster contact points.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic class ClusterClientDiscovery : Akka.Actor.UntypedActor, Akka.Actor.IActorStash, Akka.Actor.IWithTimers, Akka.Actor.IWithUnboundedStash, Akka.Actor.IWithUnrestrictedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics>\n{\n    public ClusterClientDiscovery(Akka.Cluster.Tools.Client.ClusterClientSettings settings) { }\n    public Akka.Actor.IStash Stash { get; set; }\n    public Akka.Actor.ITimerScheduler Timers { get; set; }\n    protected override void OnReceive(object message) { }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n}\n```\n\n----------------------------------------\n\nTITLE: ClusterClients Class Definition in C#\nDESCRIPTION: A container class that holds a set of active cluster clients, providing access to the list of client actor references.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterClients\n{\n    public ClusterClients(System.Collections.Immutable.IImmutableSet<Akka.Actor.IActorRef> clusterClientsList) { }\n    public System.Collections.Immutable.IImmutableSet<Akka.Actor.IActorRef> ClusterClientsList { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing InitializeLogger Message Class in C#\nDESCRIPTION: A message class used to initialize logger actors with a reference to the logging bus. It implements INoSerializationVerificationNeeded to skip serialization verification.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_132\n\nLANGUAGE: C#\nCODE:\n```\npublic class InitializeLogger : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public InitializeLogger(Akka.Event.LoggingBus loggingBus) { }\n    public Akka.Event.LoggingBus LoggingBus { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ExtendedActorSystem Abstract Class in C#\nDESCRIPTION: Defines the ExtendedActorSystem abstract class which extends ActorSystem. It includes abstract properties and methods for managing the actor system, such as ActorPipelineResolver, Guardian, and SystemActorOf.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ExtendedActorSystem : Akka.Actor.ActorSystem\n{\n    protected ExtendedActorSystem() { }\n    public abstract Akka.Actor.ActorProducerPipelineResolver ActorPipelineResolver { get; }\n    public abstract Akka.Actor.IInternalActorRef Guardian { get; }\n    public abstract Akka.Actor.IInternalActorRef LookupRoot { get; }\n    public abstract Akka.Actor.IActorRefProvider Provider { get; }\n    public abstract Akka.Actor.IInternalActorRef SystemGuardian { get; }\n    public abstract void Abort();\n    public abstract string PrintTree();\n    public abstract Akka.Actor.IActorRef SystemActorOf(Akka.Actor.Props props, string name = null);\n    public abstract Akka.Actor.IActorRef SystemActorOf<TActor>(string name = null)\n        where TActor : Akka.Actor.ActorBase, new ();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TcpMessage Factory Class in C#\nDESCRIPTION: Defines a factory class for creating various TCP command messages. This class simplifies the creation of command messages for common TCP operations like binding, connecting, and sending data.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_169\n\nLANGUAGE: C#\nCODE:\n```\npublic class TcpMessage\n{\n    public TcpMessage() { }\n    public static Akka.IO.Tcp.Command Abort() { }\n    public static Akka.IO.Tcp.Command Bind(Akka.Actor.IActorRef handler, System.Net.EndPoint endpoint, int backlog, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options, bool pullMode) { }\n    public static Akka.IO.Tcp.Command Bind(Akka.Actor.IActorRef handler, System.Net.EndPoint endpoint, int backlog) { }\n    public static Akka.IO.Tcp.Command Close() { }\n    public static Akka.IO.Tcp.Command ConfirmedClose() { }\n    public static Akka.IO.Tcp.Command Connect(System.Net.EndPoint remoteAddress, System.Net.EndPoint localAddress, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options, System.Nullable<System.TimeSpan> timeout, bool pullMode) { }\n    public static Akka.IO.Tcp.Command Connect(System.Net.EndPoint remoteAddress) { }\n    public static Akka.IO.Tcp.NoAck NoAck(object token = null) { }\n    public static Akka.IO.Tcp.Command Register(Akka.Actor.IActorRef handler, bool keepOpenOnPeerClosed = False, bool useResumeWriting = True) { }\n    public static Akka.IO.Tcp.Command ResumeAccepting(int batchSize) { }\n    public static Akka.IO.Tcp.Command ResumeReading() { }\n    public static Akka.IO.Tcp.Command ResumeWriting() { }\n    public static Akka.IO.Tcp.Command SuspendReading() { }\n    public static Akka.IO.Tcp.Command Unbind() { }\n    public static Akka.IO.Tcp.Command Write(Akka.IO.ByteString data, Akka.IO.Tcp.Event ack = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Buffer Sizes for Specific Flow Segments\nDESCRIPTION: Demonstrates how to set buffer sizes for specific segments of a Flow using WithAttributes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/buffersandworkingwithrate.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar section = Flow.Create<int>()\n.Select(_ => _*2)\n.Async()\n.WithAttributes(Attributes.CreateInputBuffer(1,1));// the buffer size of this map is 1\n\nvar flow = Flow.FromGraph(section)\n.Via(Flow.Create<int>().Select(_ => _/2))\n.Async(); // the buffer size of this map is the default\n```\n\n----------------------------------------\n\nTITLE: Uniform Component Usage in C#\nDESCRIPTION: Demonstrates that usage is uniform regardless of whether components are composite or atomic.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/modularitycomposition.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n// Create a RunnableGraph\nvar runnableGraph = nestedSource.To(nestedSink);\n\n// Usage is uniform, no matter if modules are composite or atomic\nvar runnableGraph2 = Source.Single(0).To(Sink.Aggregate<int, int>(0, (sum, x) => sum + x));\n```\n\n----------------------------------------\n\nTITLE: ISnapshotter Interface Implementation in C#\nDESCRIPTION: Interface definition for snapshot management including methods for saving, loading, and deleting snapshots.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ISnapshotter\n{\n    long SnapshotSequenceNr { get; }\n    string SnapshotterId { get; }\n    void DeleteSnapshot(long sequenceNr);\n    void DeleteSnapshots(Akka.Persistence.SnapshotSelectionCriteria criteria);\n    void LoadSnapshot(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria, long toSequenceNr);\n    void SaveSnapshot(object snapshot);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating BroadcastPool Router from HOCON Configuration in C#\nDESCRIPTION: Demonstrates how to create a broadcast pool router from HOCON configuration, which will distribute messages to all routees.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar router = system.ActorOf(Props.Create<Worker>().WithRouter(FromConfig.Instance), \"some-pool\");\n```\n\n----------------------------------------\n\nTITLE: CircuitBreakerSettings Class Definition in C#\nDESCRIPTION: Defines settings for circuit breaker functionality with configuration options for max failures, call timeout, and reset timeout. Supports initialization from Akka.Configuration.Config or direct parameter initialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.DotNet.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class CircuitBreakerSettings\n{\n    public CircuitBreakerSettings(Akka.Configuration.Config config) { }\n    public CircuitBreakerSettings(int maxFailures, System.TimeSpan callTimeout, System.TimeSpan resetTimeout) { }\n    public System.TimeSpan CallTimeout { get; }\n    public int MaxFailures { get; }\n    public System.TimeSpan ResetTimeout { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: DeadLetterListener Actor in Akka.NET\nDESCRIPTION: Actor class for listening to dead letters in the system. Extends ActorBase and implements lifecycle methods for handling dead letters and managing subscription to the dead letter channel.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_118\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DeadLetterListener : Akka.Actor.ActorBase\n{\n    public DeadLetterListener() { }\n    protected override void PostRestart(System.Exception reason) { }\n    protected override void PostStop() { }\n    protected override void PreRestart(System.Exception reason, object message) { }\n    protected override void PreStart() { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing CoordinatedShutdown in C#\nDESCRIPTION: Core implementation for coordinated shutdown of Akka.NET actor systems. Includes various reason classes and shutdown coordination methods.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic class CoordinatedShutdown {\n    public static Akka.Actor.CoordinatedShutdown Get(Akka.Actor.ActorSystem sys) { }\n    public System.Threading.Tasks.Task<Akka.Done> Run(Akka.Actor.CoordinatedShutdown.Reason reason, string fromPhase = null) { }\n    public System.TimeSpan Timeout(string phase) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Error Log Event Class in Akka.NET\nDESCRIPTION: Log event class for error-level messages. Extends LogEvent and provides a constructor for creating error messages with an associated exception.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_124\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Error : Akka.Event.LogEvent\n{\n    public Error(System.Exception cause, string logSource, System.Type logClass, object message) { }\n    public override Akka.Event.LogLevel LogLevel() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Built-in Source Stages in Akka.NET Streams\nDESCRIPTION: Shows how to access the built-in source stages in Akka.NET Streams. These stages are available from the akka.stream.scaladsl.Source class.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/builtinstages.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nakka.stream.scaladsl.Source\n```\n\n----------------------------------------\n\nTITLE: Implementing NormalChildrenContainer Class in C#\nDESCRIPTION: A container class for managing normal (active) actor children. It provides methods to add, remove, reserve, and manage child actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_60\n\nLANGUAGE: C#\nCODE:\n```\npublic class NormalChildrenContainer : Akka.Actor.Internal.ChildrenContainerBase\n{\n    public override Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats) { }\n    public static Akka.Actor.Internal.IChildrenContainer Create(System.Collections.Immutable.IImmutableDictionary<string, Akka.Actor.Internal.IChildStats> children) { }\n    public override Akka.Actor.Internal.IChildrenContainer Remove(Akka.Actor.IActorRef child) { }\n    public override Akka.Actor.Internal.IChildrenContainer Reserve(string name) { }\n    public override Akka.Actor.Internal.IChildrenContainer ShallDie(Akka.Actor.IActorRef actor) { }\n    public override string ToString() { }\n    public override Akka.Actor.Internal.IChildrenContainer Unreserve(string name) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ConsistentHashingPool in C#\nDESCRIPTION: Defines a sealed class ConsistentHashingPool that inherits from Pool. It provides various constructors and methods for creating and configuring consistent hashing pools.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_171\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ConsistentHashingPool : Akka.Routing.Pool\n{\n    public ConsistentHashingPool(int nrOfInstances) { }\n    public ConsistentHashingPool(Akka.Configuration.Config config) { }\n    public ConsistentHashingPool(int nrOfInstances, Akka.Routing.ConsistentHashMapping hashMapping) { }\n    public ConsistentHashingPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False, int virtualNodesFactor = 0, Akka.Routing.ConsistentHashMapping hashMapping = null) { }\n    public int VirtualNodesFactor { get; }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Routing.ConsistentHashingPool WithDispatcher(string dispatcher) { }\n    public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n    public Akka.Routing.ConsistentHashingPool WithHashMapping(Akka.Routing.ConsistentHashMapping mapping) { }\n    public Akka.Routing.ConsistentHashingPool WithResizer(Akka.Routing.Resizer resizer) { }\n    public Akka.Routing.ConsistentHashingPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }\n    public Akka.Routing.ConsistentHashingPool WithVirtualNodesFactor(int vnodes) { }\n    public class ConsistentHashingPoolSurrogate : Akka.Util.ISurrogate\n    {\n        public ConsistentHashingPoolSurrogate() { }\n        public int NrOfInstances { get; set; }\n        public Akka.Routing.Resizer Resizer { get; set; }\n        public string RouterDispatcher { get; set; }\n        public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }\n        public bool UsePoolDispatcher { get; set; }\n        public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ConfigServicesParser Static Class Definition in C#\nDESCRIPTION: A static utility class that parses service discovery configuration from Akka.NET configuration objects into a dictionary of resolved services.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.DotNet.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class static ConfigServicesParser\n{\n    public static System.Collections.Generic.Dictionary<string, Akka.Discovery.ServiceDiscovery.Resolved> Parse(Akka.Configuration.Config config) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Broadcast Implementation in C#\nDESCRIPTION: Implements broadcasting functionality for Akka.NET with both group and pool-based implementations. Includes configuration options for router dispatching and supervision strategies.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_167\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class BroadcastGroup : Akka.Routing.Group\n{\n    public BroadcastGroup(Akka.Configuration.Config config) { }\n    public BroadcastGroup(params string[] paths) { }\n    public BroadcastGroup(System.Collections.Generic.IEnumerable<string> paths) { }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ExactMatchLogSourceFilter in C#\nDESCRIPTION: A sealed class that implements log filtering based on exact log source name matching. It allows filtering log messages by matching the source string with configurable string comparison.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_126\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class ExactMatchLogSourceFilter : Akka.Event.LogFilterBase\n{\n    public ExactMatchLogSourceFilter(string source, System.StringComparison comparison = 5) { }\n    public override Akka.Event.LogFilterType FilterType { get; }\n    public override Akka.Event.LogFilterDecision ShouldKeepMessage(Akka.Event.LogEvent content, [System.Runtime.CompilerServices.NullableAttribute(2)] string expandedMessage = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: ContactPoints Class Definition in C#\nDESCRIPTION: A container class that holds a set of contact points for cluster clients, providing access to the list of contact point actor paths.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ContactPoints\n{\n    public ContactPoints(System.Collections.Immutable.IImmutableSet<Akka.Actor.ActorPath> contactPoints) { }\n    public System.Collections.Immutable.IImmutableSet<Akka.Actor.ActorPath> ContactPointsList { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Least Shard Allocation Strategy in C#\nDESCRIPTION: Abstract base class for implementing least shard allocation strategies in Akka.NET cluster sharding with support for rebalancing and shard allocation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Core.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AbstractLeastShardAllocationStrategy : Akka.Actor.INoSerializationVerificationNeeded, Akka.Cluster.Sharding.IActorSystemDependentAllocationStrategy, Akka.Cluster.Sharding.IShardAllocationStrategy\n{\n    protected AbstractLeastShardAllocationStrategy() { }\n    protected virtual Akka.Cluster.ClusterEvent.CurrentClusterState ClusterState { get; }\n    protected virtual Akka.Cluster.Member SelfMember { get; }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> AllocateShard(Akka.Actor.IActorRef requester, string shardId, System.Collections.Immutable.IImmutableDictionary<Akka.Actor.IActorRef, System.Collections.Immutable.IImmutableList<string>> currentShardAllocations) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Handler Priority in Message Reception\nDESCRIPTION: Shows how multiple message handlers are prioritized based on their declaration order.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\nReceive<string>(s => Console.WriteLine(\"Received string: \" + s));      //1\nReceive<string>(s => Console.WriteLine(\"Also received string: \" + s)); //2\nReceive<object>(o => Console.WriteLine(\"Received object: \" + o));      //3\n```\n\n----------------------------------------\n\nTITLE: ClusterClientDiscoverySettings Configuration Class\nDESCRIPTION: The ClusterClientDiscoverySettings class holds configuration parameters for service discovery in the ClusterClient. It includes settings for discovery method, service properties, timeouts, and backoff policies when connecting to cluster nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class ClusterClientDiscoverySettings : System.IEquatable<Akka.Cluster.Tools.Client.ClusterClientDiscoverySettings>\n{\n    [System.Runtime.CompilerServices.NullableAttribute(1)]\n    public static readonly Akka.Cluster.Tools.Client.ClusterClientDiscoverySettings Empty;\n    public ClusterClientDiscoverySettings(string DiscoveryMethod, string ServiceName, string PortName, int NumberOfContacts, System.TimeSpan Interval, double ExponentialBackoffJitter, System.TimeSpan ExponentialBackoffMax, System.TimeSpan ResolveTimeout, System.TimeSpan ProbeTimeout) { }\n    public string DiscoveryMethod { get; set; }\n    public double ExponentialBackoffJitter { get; set; }\n    public System.TimeSpan ExponentialBackoffMax { get; set; }\n    public System.TimeSpan Interval { get; set; }\n    public int NumberOfContacts { get; set; }\n    public string PortName { get; set; }\n    public System.TimeSpan ProbeTimeout { get; set; }\n    public System.TimeSpan ResolveTimeout { get; set; }\n    public string ServiceName { get; set; }\n    public static Akka.Cluster.Tools.Client.ClusterClientDiscoverySettings Create(Akka.Configuration.Config clusterClientConfig) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DeleteSnapshotSuccess Class\nDESCRIPTION: This snippet defines the `DeleteSnapshotSuccess` class, representing the successful deletion of a snapshot in Akka.Persistence. It implements interfaces like `INoSerializationVerificationNeeded`, `IPersistenceMessage`, `ISnapshotMessage`, `ISnapshotResponse`, and `IEquatable<DeleteSnapshotSuccess>`. The class likely holds metadata associated with the deleted snapshot.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\n\"public sealed class DeleteSnapshotSuccess : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage, Akka.Persistence.ISnapshotResponse, System.IEquatable<Akka.Persistence.DeleteSnapshotSuccess>\n    {\n        public DeleteSnapshotSuccess(Akka.Persistence.SnapshotMetadata metadata) { }\n        public Akka.Persistence.SnapshotMetadata Metadata { get; }\n        public bool Equals(Akka.Persistence.DeleteSnapshotSuccess other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n    }\"\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterReceptionistSettings Class in C#\nDESCRIPTION: Implements a sealed class ClusterReceptionistSettings with various configuration options for cluster reception. It includes methods for creating and modifying settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterReceptionistSettings : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public ClusterReceptionistSettings(string role, int numberOfContacts, System.TimeSpan responseTunnelReceiveTimeout, System.TimeSpan heartbeatInterval, System.TimeSpan acceptableHeartbeatPause, System.TimeSpan failureDetectionInterval) { }\n    public System.TimeSpan AcceptableHeartbeatPause { get; }\n    public System.TimeSpan FailureDetectionInterval { get; }\n    public System.TimeSpan HeartbeatInterval { get; }\n    public int NumberOfContacts { get; }\n    public System.TimeSpan ResponseTunnelReceiveTimeout { get; }\n    public string Role { get; }\n    public static Akka.Cluster.Tools.Client.ClusterReceptionistSettings Create(Akka.Actor.ActorSystem system) { }\n    public static Akka.Cluster.Tools.Client.ClusterReceptionistSettings Create(Akka.Configuration.Config config) { }\n    public Akka.Cluster.Tools.Client.ClusterReceptionistSettings WithHeartbeat(System.TimeSpan heartbeatInterval, System.TimeSpan acceptableHeartbeatPause, System.TimeSpan failureDetectionInterval) { }\n    public Akka.Cluster.Tools.Client.ClusterReceptionistSettings WithNumberOfContacts(int numberOfContacts) { }\n    public Akka.Cluster.Tools.Client.ClusterReceptionistSettings WithResponseTunnelReceiveTimeout(System.TimeSpan responseTunnelReceiveTimeout) { }\n    public Akka.Cluster.Tools.Client.ClusterReceptionistSettings WithRole(string role) { }\n    public Akka.Cluster.Tools.Client.ClusterReceptionistSettings WithoutRole() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Failed System Message in Akka.NET\nDESCRIPTION: Internal API that defines a system message indicating a child actor has failed with a specific exception. Includes a unique ID to identify the specific failure instance.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_119\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic sealed class Failed : Akka.Dispatch.SysMsg.SystemMessage\n{\n    public Failed(Akka.Actor.IActorRef child, System.Exception cause, long uid) { }\n    public System.Exception Cause { get; }\n    public Akka.Actor.IActorRef Child { get; }\n    public long Uid { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Hocon Configuration Value Accessor Methods in C#\nDESCRIPTION: Interface methods for retrieving different data types from Hocon configuration elements. Includes methods for getting primitive types, arrays, objects, and performing type checking operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_77\n\nLANGUAGE: C#\nCODE:\n```\npublic decimal GetDecimal() { }\npublic System.Collections.Generic.IList<decimal> GetDecimalList() { }\npublic double GetDouble() { }\npublic System.Collections.Generic.IList<double> GetDoubleList() { }\npublic float GetFloat() { }\npublic System.Collections.Generic.IList<float> GetFloatList() { }\npublic int GetInt() { }\npublic System.Collections.Generic.IList<int> GetIntList() { }\npublic long GetLong() { }\npublic System.Collections.Generic.IList<long> GetLongList() { }\npublic Akka.Configuration.Hocon.HoconObject GetObject() { }\npublic string GetString() { }\npublic System.Collections.Generic.IList<string> GetStringList() { }\npublic System.TimeSpan GetTimeSpan(bool allowInfinite = True) { }\npublic bool IsArray() { }\npublic bool IsObject() { }\npublic bool IsString() { }\npublic void NewValue(Akka.Configuration.Hocon.IHoconElement value) { }\npublic Akka.Configuration.Config ToConfig() { }\npublic override string ToString() { }\npublic virtual string ToString(int indent) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ActorTransportAdapter in C#\nDESCRIPTION: A concrete implementation of AbstractTransportAdapter for actor-based transport in Akka.NET. It provides methods for intercepting associations and listening, as well as shutdown functionality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ActorTransportAdapter : Akka.Remote.Transport.AbstractTransportAdapter\n{\n    public static readonly System.TimeSpan AskTimeout;\n    protected Akka.Actor.IActorRef modreq(System.Runtime.CompilerServices.IsVolatile) manager;\n    protected ActorTransportAdapter(Akka.Remote.Transport.Transport wrappedTransport, Akka.Actor.ActorSystem system) { }\n    protected abstract string ManagerName { get; }\n    protected abstract Akka.Actor.Props ManagerProps { get; }\n    protected override void InterceptAssociate(Akka.Actor.Address remoteAddress, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.AssociationHandle> statusPromise) { }\n    protected override System.Threading.Tasks.Task<Akka.Remote.Transport.IAssociationEventListener> InterceptListen(Akka.Actor.Address listenAddress, System.Threading.Tasks.Task<Akka.Remote.Transport.IAssociationEventListener> listenerTask) { }\n    public override System.Threading.Tasks.Task<bool> Shutdown() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LocalSnapshotStore Class in C#\nDESCRIPTION: This class provides functionality for storing and managing snapshots locally in Akka.NET. It includes methods for saving, loading, and deleting snapshots.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\npublic class LocalSnapshotStore : Akka.Persistence.Snapshot.SnapshotStore\n{\n    public LocalSnapshotStore() { }\n    protected override System.Threading.Tasks.Task DeleteAsync(Akka.Persistence.SnapshotMetadata metadata) { }\n    protected override System.Threading.Tasks.Task DeleteAsync(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria) { }\n    protected System.IO.FileInfo GetSnapshotFileForWrite(Akka.Persistence.SnapshotMetadata metadata, string extension = \"\") { }\n    protected override System.Threading.Tasks.Task<Akka.Persistence.SelectedSnapshot> LoadAsync(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria) { }\n    protected override void PreStart() { }\n    protected override bool ReceivePluginInternal(object message) { }\n    protected virtual void Save(Akka.Persistence.SnapshotMetadata metadata, object snapshot) { }\n    protected override System.Threading.Tasks.Task SaveAsync(Akka.Persistence.SnapshotMetadata metadata, object snapshot) { }\n    protected void Serialize(System.IO.Stream stream, Akka.Persistence.Serialization.Snapshot snapshot) { }\n    protected System.IO.FileInfo WithOutputStream(Akka.Persistence.SnapshotMetadata metadata, System.Action<System.IO.Stream> p) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Async Command Methods in C#\nDESCRIPTION: This snippet shows various overloads of the CommandAsync method for handling asynchronous message processing in Akka.NET persistence.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\nprotected void CommandAsync<T>(System.Func<T, System.Threading.Tasks.Task> handler, System.Predicate<T> shouldHandle = null) { }\nprotected void CommandAsync<T>(System.Predicate<T> shouldHandle, System.Func<T, System.Threading.Tasks.Task> handler) { }\nprotected void CommandAsync(System.Type messageType, System.Func<object, System.Threading.Tasks.Task> handler, System.Predicate<object> shouldHandle = null) { }\nprotected void CommandAsync(System.Type messageType, System.Predicate<object> shouldHandle, System.Func<object, System.Threading.Tasks.Task> handler) { }\n```\n\n----------------------------------------\n\nTITLE: Custom ThreadPool Dispatcher Configuration\nDESCRIPTION: Example of configuring a custom dispatcher that uses the .NET Thread Pool.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/dispatchers.md#2025-04-16_snippet_3\n\nLANGUAGE: hocon\nCODE:\n```\ncustom-dispatcher {\ntype = Dispatcher\nthroughput = 100\n}\n```\n\n----------------------------------------\n\nTITLE: Using ITellScheduler with Proper Cancellation in C#\nDESCRIPTION: This code snippet demonstrates how to use ITellScheduler methods safely by accepting an ICancelable parameter and calling ICancelable.Cancel() in the actor's PostStop() method. This ensures proper cleanup of timers when the actor is stopped.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK1004.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Actor;\nusing System.Threading.Tasks;\nusing System;\n\npublic sealed class MyActor : ReceiveActor\n{\n    private sealed class TimerMessage\n    {\n        public static readonly TimerMessage Instance = new();\n        private TimerMessage() { }\n    }\n    \n    private readonly Cancelable _timerCancelable;\n    \n    public MyActor()\n    {\n        _timerCancelable = new Cancelable(Context.System.Scheduler);\n        \n        Context.System.Scheduler.ScheduleTellRepeatedly(\n            initialDelay: TimeSpan.FromSeconds(3), \n            interval: TimeSpan.FromSeconds(3), \n            receiver: Self, \n            message: TimerMessage.Instance, \n            sender: Self\n            cancelable: _timerCancelable);\n    }\n    \n    protected override void PostStop()\n    {\n        _timerCancelable.Cancel();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Device Registration in C#\nDESCRIPTION: This code extends the Device actor to handle registration requests. It validates that the group and device IDs match the actor's configuration and responds with a DeviceRegistered acknowledgment if valid.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-3.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Device : UntypedActor\n{\n    private double? _lastTemperatureReading = null;\n\n    public Device(string groupId, string deviceId)\n    {\n        GroupId = groupId;\n        DeviceId = deviceId;\n    }\n\n    protected override void OnReceive(object message)\n    {\n        switch (message)\n        {\n            case RequestTrackDevice req when req.GroupId.Equals(GroupId) && req.DeviceId.Equals(DeviceId):\n                Sender.Tell(DeviceRegistered.Instance);\n                break;\n            case RequestTrackDevice req:\n                Log.Warning(\"Ignoring TrackDevice request for {0}-{1}.This actor is responsible for {2}-{3}.\",\n                    req.GroupId, req.DeviceId, GroupId, DeviceId);\n                break;\n            case RecordTemperature rec:\n                Log.Info(\"Recorded temperature reading {0} with {1}\", rec.Value, rec.RequestId);\n                _lastTemperatureReading = rec.Value;\n                Sender.Tell(new TemperatureRecorded(rec.RequestId));\n                break;\n            case ReadTemperature read:\n                Sender.Tell(new RespondTemperature(read.RequestId, DeviceId, _lastTemperatureReading));\n                break;\n        }\n    }\n\n    public string GroupId { get; }\n    public string DeviceId { get; }\n\n    public static Props Props(string groupId, string deviceId) =>\n        Akka.Actor.Props.Create(() => new Device(groupId, deviceId));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ByteArraySerializer in Akka.NET\nDESCRIPTION: Defines a ByteArraySerializer class that extends the base Serializer to handle serialization of byte arrays. This is a simple pass-through serializer that directly returns byte arrays without transformation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_192\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ByteArraySerializer : Akka.Serialization.Serializer\n{\n    public ByteArraySerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override bool IncludeManifest { get; }\n    public override object FromBinary(byte[] bytes, System.Type type) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Info Log Event Class in C#\nDESCRIPTION: Implementation of the Info log event type that extends LogEvent. It represents informational log messages with constructors for creating messages with or without an exception cause.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_130\n\nLANGUAGE: C#\nCODE:\n```\npublic class Info : Akka.Event.LogEvent\n{\n    public Info(string logSource, System.Type logClass, object message) { }\n    public Info(System.Exception cause, string logSource, System.Type logClass, object message) { }\n    public override Akka.Event.LogLevel LogLevel() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ORDictionaryKey Class for Distributed Data - C#\nDESCRIPTION: Definition of ORDictionaryKey class that extends Key for Akka's distributed data module. This class provides a typed identifier for ORDictionary instances, keeping track of key and value types for type-safety in distributed operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ORDictionaryKey<TKey, TValue> : Akka.DistributedData.Key<Akka.DistributedData.ORDictionary<TKey, TValue>>\n    where TValue : Akka.DistributedData.IReplicatedData<TValue>\n{\n    public ORDictionaryKey(string id) { }\n    public System.Type KeyType { get; }\n    public System.Type ValueType { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Child Actors in Akka.NET Tests\nDESCRIPTION: Methods for creating child actors during tests with various configuration options. Supports both synchronous and asynchronous creation with optional supervisor strategy and naming.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic Akka.Actor.IActorRef ChildActorOf(Akka.Actor.Props props, string name, Akka.Actor.SupervisorStrategy supervisorStrategy, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.Task<Akka.Actor.IActorRef> ChildActorOfAsync(Akka.Actor.Props props, string name, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Resizer Abstract Class in Akka.NET Routing\nDESCRIPTION: Defines an abstract base class for router resizing strategies. It provides methods to determine when resizing should occur and how many routees should be created or removed based on current conditions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_187\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Resizer\n{\n    protected Resizer() { }\n    public static Akka.Routing.Resizer FromConfig(Akka.Configuration.Config parentConfig) { }\n    public abstract bool IsTimeForResize(long messageCounter);\n    public abstract int Resize(System.Collections.Generic.IEnumerable<Akka.Routing.Routee> currentRoutees);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Failure Injector Transport Adapter in C#\nDESCRIPTION: Defines a FailureInjectorTransportAdapter class that extends AbstractTransportAdapter. It provides functionality for simulating network failures and errors in the transport layer for testing purposes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic class FailureInjectorTransportAdapter : Akka.Remote.Transport.AbstractTransportAdapter, Akka.Remote.Transport.IAssociationEventListener\n{\n    public readonly Akka.Actor.ExtendedActorSystem ExtendedActorSystem;\n    public const string FailureInjectorSchemeIdentifier = \"gremlin\";\n    protected int MaximumOverhead;\n    public FailureInjectorTransportAdapter(Akka.Remote.Transport.Transport wrappedTransport, Akka.Actor.ExtendedActorSystem extendedActorSystem) { }\n    protected override Akka.Remote.Transport.SchemeAugmenter SchemeAugmenter { get; }\n    protected override void InterceptAssociate(Akka.Actor.Address remoteAddress, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.AssociationHandle> statusPromise) { }\n    protected override System.Threading.Tasks.Task<Akka.Remote.Transport.IAssociationEventListener> InterceptListen(Akka.Actor.Address listenAddress, System.Threading.Tasks.Task<Akka.Remote.Transport.IAssociationEventListener> listenerTask) { }\n    public override System.Threading.Tasks.Task<bool> ManagementCommand(object message) { }\n    public void Notify(Akka.Remote.Transport.IAssociationEvent ev) { }\n    public bool ShouldDropInbound(Akka.Actor.Address remoteAddress, object instance, string debugMessage) { }\n    public bool ShouldDropOutbound(Akka.Actor.Address remoteAddress, object instance, string debugMessage) { }\n    // ... (nested classes omitted for brevity)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ShardedDaemonProcess Class in C#\nDESCRIPTION: Defines the ShardedDaemonProcess class, which implements the IExtension interface. It provides methods for initializing and managing sharded daemon processes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Net.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.ApiMayChangeAttribute()]\n[Akka.Annotations.DoNotInheritAttribute()]\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic class ShardedDaemonProcess : Akka.Actor.IExtension\n{\n    public ShardedDaemonProcess(Akka.Actor.ExtendedActorSystem system) { }\n    public static Akka.Cluster.Sharding.ShardedDaemonProcess Get(Akka.Actor.ActorSystem system) { }\n    [return: System.Runtime.CompilerServices.NullableAttribute(2)]\n    public Akka.Actor.IActorRef Init(string name, int numberOfInstances, System.Func<int, Akka.Actor.Props> propsFactory) { }\n    // ... (other Init and InitProxy methods omitted for brevity)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ThrottleTransportAdapter Class in Akka.NET Remote Transport\nDESCRIPTION: A transport adapter that adds throttling capabilities to an underlying transport implementation in Akka.NET's remoting system, allowing control of message rates.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\npublic class ThrottleTransportAdapter : Akka.Remote.Transport.ActorTransportAdapter\n{\n    public const string Scheme = \"trttl\";\n    public static readonly Akka.Util.Internal.AtomicCounter UniqueId;\n    public ThrottleTransportAdapter(Akka.Remote.Transport.Transport wrappedTransport, Akka.Actor.ActorSystem system) { }\n    protected override string ManagerName { get; }\n    protected override Akka.Actor.Props ManagerProps { get; }\n    protected override Akka.Remote.Transport.SchemeAugmenter SchemeAugmenter { get; }\n    public override System.Threading.Tasks.Task<bool> ManagementCommand(object message) { }\n    public enum Direction\n    {\n        Send = 0,\n        Receive = 1,\n        Both = 2,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ActionWithStateRunnable in Akka.Dispatch Namespace\nDESCRIPTION: The ActionWithStateRunnable class implements IRunnable to wrap an Action with state parameter. This allows parameterized actions to be scheduled and executed within the Akka.NET runtime.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_79\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ActionWithStateRunnable : Akka.Dispatch.IRunnable\n{\n    public ActionWithStateRunnable(System.Action<object> actionWithState, object state) { }\n    public void Run() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UdpSettings Configuration in Akka.NET\nDESCRIPTION: Configuration settings for UDP functionality. Includes buffer pool settings, logging options, and dispatcher configurations. Provides factory methods to create settings from system configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_189\n\nLANGUAGE: C#\nCODE:\n```\npublic class UdpSettings\n{\n    public UdpSettings(string bufferPoolConfigPath, bool traceLogging, int initialSocketAsyncEventArgs, int batchReceiveLimit, string managementDispatcher, string fileIoDispatcher) { }\n    public int BatchReceiveLimit { get; }\n    public string BufferPoolConfigPath { get; }\n    public string FileIODispatcher { get; }\n    public int InitialSocketAsyncEventArgs { get; }\n    public string ManagementDispatcher { get; }\n    public bool TraceLogging { get; }\n    public static Akka.IO.UdpSettings Create(Akka.Actor.ActorSystem system) { }\n    public static Akka.IO.UdpSettings Create(Akka.Configuration.Config config) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Query Configuration for Journal Events\nDESCRIPTION: Provides a comprehensive configuration class for specifying database schema, table names, column names, and query settings for journal events in a persistence system\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Core.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic class QueryConfiguration {\n    public readonly string SchemaName;\n    public readonly string JournalEventsTableName;\n    public readonly string MetaTableName;\n    public readonly TimeSpan Timeout;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Scope and SelectionPathElement classes in C# for Akka.NET\nDESCRIPTION: These classes define the scoping and selection mechanisms for Akka.NET actors. Scope is used for actor creation scope, while SelectionPathElement and its derived classes are used for actor selection paths.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_48\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Scope : System.IEquatable<Akka.Actor.Scope>\n{\n    public static readonly Akka.Actor.LocalScope Local;\n    protected Scope() { }\n    public abstract Akka.Actor.Scope Copy();\n    public virtual bool Equals(Akka.Actor.Scope other) { }\n    public abstract Akka.Actor.Scope WithFallback(Akka.Actor.Scope other);\n}\n\npublic abstract class SelectionPathElement\n{\n    protected SelectionPathElement() { }\n}\n\npublic class SelectChildName : Akka.Actor.SelectionPathElement\n{\n    public SelectChildName(string name) { }\n    public string Name { get; }\n    protected bool Equals(Akka.Actor.SelectChildName other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n\npublic class SelectChildPattern : Akka.Actor.SelectionPathElement\n{\n    public SelectChildPattern(string patternStr) { }\n    public string PatternStr { get; }\n    protected bool Equals(Akka.Actor.SelectChildPattern other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n\npublic class SelectChildRecursive : Akka.Actor.SelectionPathElement\n{\n    public static readonly Akka.Actor.SelectChildRecursive Instance;\n    public SelectChildRecursive() { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n\npublic class SelectParent : Akka.Actor.SelectionPathElement\n{\n    public static readonly Akka.Actor.SelectParent Instance;\n    public SelectParent() { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TypeCache Static Class\nDESCRIPTION: Static utility class that provides type resolution and caching for improved performance. The GetType method resolves types by name with caching to avoid repeated expensive type lookups.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_232\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.Util.Reflection\n{\n    public class static TypeCache\n    {\n        public static System.Type GetType(string typeName) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Akka.NET Remote Actor Provider\nDESCRIPTION: Example of how to configure the Akka.NET actor system to use the remote actor provider. This configuration automatically adds serializers for Akka.Remote.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/serialization/codes.md#2025-04-16_snippet_0\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.provider = remote\n```\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.provider = \"Akka.Remote.RemoteActorRefProvider, Akka.Remote\"\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Akka.DistributedData Updates\nDESCRIPTION: Demonstrates how to create an actor that subscribes to updates for a specific key in the distributed data store. It shows handling of the Replicator.Changed messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/distributed-data.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing Akka.DistributedData;\nusing static Akka.DistributedData.Dsl;\n\nclass Subscriber : ReceiveActor \n{\n    public Subscriber() \n    {\n        var replicator = DistributedData.Get(Context.System).Replicator;\n        var key = new ORSetKey<string>(\"keyA\");\n        replicator.Tell(Subscribe(key, Self));\n\n        Receive<Replicator.Changed>(changed => \n        {\n            var newValue = changed.Get(key);\n            Console.WriteLine($\"Received updated value for key '{key}': {newValue}\");\n        });\n    }    \n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BroadcastRoutingLogic in C#\nDESCRIPTION: Defines a sealed class BroadcastRoutingLogic that inherits from RoutingLogic. It provides a constructor and overrides the Select method for routing messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_168\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class BroadcastRoutingLogic : Akka.Routing.RoutingLogic\n{\n    public BroadcastRoutingLogic() { }\n    public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining VectorClock Node Class in C#\nDESCRIPTION: Implements a Node class for VectorClock, including methods for creation, comparison, and string representation. This class is used to represent individual nodes in a vector clock.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Core.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class Node : System.IComparable<Akka.Cluster.VectorClock.Node>\n{\n    public Node(string value) { }\n    public int CompareTo(Akka.Cluster.VectorClock.Node other) { }\n    public static Akka.Cluster.VectorClock.Node Create(string name) { }\n    public override bool Equals(object obj) { }\n    public static Akka.Cluster.VectorClock.Node FromHash(string hash) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Abstract Transport Adapter Base Class Implementation in C#\nDESCRIPTION: Defines abstract base class for transport adapters with methods for intercepting associations and managing network listeners. Contains core functionality for wrapping and extending transport implementations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nprotected abstract void InterceptAssociate(Akka.Actor.Address remoteAddress, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.AssociationHandle> statusPromise);\nprotected abstract System.Threading.Tasks.Task<Akka.Remote.Transport.IAssociationEventListener> InterceptListen(Akka.Actor.Address listenAddress, System.Threading.Tasks.Task<Akka.Remote.Transport.IAssociationEventListener> listenerTask);\n```\n\n----------------------------------------\n\nTITLE: Implementing Remote Actor Reference Classes in C# for Akka.NET\nDESCRIPTION: Defines RemoteActorRef class and related interfaces for managing remote actor references in Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic class RemoteActorRef : Akka.Actor.InternalActorRefBase, Akka.Actor.IActorRefScope, Akka.Remote.IRemoteRef\n{\n    public RemoteActorRef(Akka.Remote.RemoteTransport remote, Akka.Actor.Address localAddressToUse, Akka.Actor.ActorPath path, Akka.Actor.IInternalActorRef parent, Akka.Actor.Props props, Akka.Actor.Deploy deploy) { }\n    public override bool IsLocal { get; }\n    [System.ObsoleteAttribute(\"Use Context.Watch and Receive<Terminated> [1.1.0]\")]\n}\n\n[Akka.Annotations.InternalApiAttribute()]\npublic interface IRemoteActorRefProvider : Akka.Actor.IActorRefProvider\n{\n    Akka.Actor.IInternalActorRef RemoteDaemon { get; }\n    Akka.Remote.RemoteSettings RemoteSettings { get; }\n    Akka.Actor.IActorRef RemoteWatcher { get; }\n    Akka.Remote.RemoteTransport Transport { get; }\n    bool HasAddress(Akka.Actor.Address address);\n    Akka.Actor.IActorRef InternalResolveActorRef(string path);\n    Akka.Actor.Deploy LookUpRemotes(System.Collections.Generic.IEnumerable<string> p);\n    void Quarantine(Akka.Actor.Address address, System.Nullable<int> uid);\n    Akka.Actor.IInternalActorRef ResolveActorRefWithLocalAddress(string path, Akka.Actor.Address localAddress);\n    void UseActorOnNode(Akka.Remote.RemoteActorRef actor, Akka.Actor.Props props, Akka.Actor.Deploy deploy, Akka.Actor.IInternalActorRef supervisor);\n}\n\n[Akka.Annotations.InternalApiAttribute()]\npublic interface IRemoteRef : Akka.Actor.IActorRefScope { }\n```\n\n----------------------------------------\n\nTITLE: Implementing TCP Extension Methods for ActorSystem in C#\nDESCRIPTION: Provides a static extension method for accessing the TCP functionality from an ActorSystem instance, making it easier to use TCP features.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_168\n\nLANGUAGE: C#\nCODE:\n```\npublic class static TcpExtensions\n{\n    public static Akka.Actor.IActorRef Tcp(this Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Akka.NET Serialization Settings with HOCON\nDESCRIPTION: This code snippet shows how to configure Akka.NET serialization settings using HOCON (Human-Optimized Config Object Notation). The `akka.actor.serialization-settings.primitive.use-legacy-behavior` setting controls whether to use the legacy behavior for primitive serialization, which is relevant for cross-platform compatibility between .NET Framework and .NET Core. Setting it to `on` resolves the backwards compatibility issue and resolves the regression introduced in the \"primitives\" serializer.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/whats-new/akkadotnet-v1.4-upgrade-advisories.md#2025-04-16_snippet_0\n\nLANGUAGE: hocon\nCODE:\n```\n\"akka.actor.serialization-settings.primitive.use-legacy-behavior = on\"\n```\n\n----------------------------------------\n\nTITLE: Defining Socket Option Abstract Classes in Akka.IO\nDESCRIPTION: Contains abstract classes for socket options in Akka.IO, including SoForwarders, SocketOption, and SocketOptionV2, which provide methods for configuring socket behavior before and after various connection events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_160\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class SoForwarders\n{\n    protected SoForwarders() { }\n}\npublic abstract class SocketOption\n{\n    protected SocketOption() { }\n    public virtual void AfterConnect(System.Net.Sockets.Socket s) { }\n    public virtual void BeforeConnect(System.Net.Sockets.Socket s) { }\n    public virtual void BeforeDatagramBind(System.Net.Sockets.Socket ds) { }\n    public virtual void BeforeServerSocketBind(System.Net.Sockets.Socket ss) { }\n}\npublic abstract class SocketOptionV2 : Akka.IO.Inet.SocketOption\n{\n    protected SocketOptionV2() { }\n    public virtual void AfterBind(System.Net.Sockets.Socket s) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Assembly Metadata for Akka.NET\nDESCRIPTION: These assembly attributes set metadata for the Akka.NET assembly, including the repository URL and specifying which internal types are visible to other assemblies, primarily for testing and modularity purposes. This allows internal classes and members to be accessed by specified assemblies without being publicly exposed. The `InternalsVisibleToAttribute` is used to grant access to specific assemblies like test projects and other Akka modules.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.API.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Benchmarks\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding.Tests.MultiNode\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.TestKit\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Tests.MultiNode\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Tools\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.DependencyInjection\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.DependencyInjection.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.DistributedData\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Docs.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.MultiNodeTestRunner.Shared.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Persistence\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Persistence.Sql.TestKit\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Persistence.TCK\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Persistence.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Remote\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Remote.TestKit\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Remote.TestKit.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Remote.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Remote.Tests.MultiNode\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Streams\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Streams.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.TestKit\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.TestKit.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Tests.Performance\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"1a5cab08-b032-49ca-8db3-9428c5a9db14\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Implementing WeightedRoutees for Cluster Load Balancing in C#\nDESCRIPTION: This internal API class handles weighted distribution of routees for load balancing in a cluster. It maintains a collection of routees with their associated weights based on cluster node characteristics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Net.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic class WeightedRoutees\n{\n    public WeightedRoutees(System.Collections.Immutable.ImmutableArray<Akka.Routing.Routee> routees, Akka.Actor.Address selfAddress, System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, int> weights) { }\n    public bool IsEmpty { get; }\n    public Akka.Routing.Routee this[int value] { get; }\n    public int Total { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: DeleteMessagesTo Class Definition in Akka.Persistence\nDESCRIPTION: Class representing a request to delete messages up to a specific sequence number, used as a command sent to the journal to remove persisted events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DeleteMessagesTo : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IJournalMessage, Akka.Persistence.IJournalRequest, Akka.Persistence.IPersistenceMessage, System.IEquatable<Akka.Persistence.DeleteMessagesTo>\n{\n    public DeleteMessagesTo(string persistenceId, long toSequenceNr, Akka.Actor.IActorRef persistentActor) { }\n    public string PersistenceId { get; }\n    public Akka.Actor.IActorRef PersistentActor { get; }\n    public long ToSequenceNr { get; }\n    public bool Equals(Akka.Persistence.DeleteMessagesTo other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Hocon Object Interface Definition in C#\nDESCRIPTION: Interface for components that might represent a Hocon object, providing methods to check if the element is an object and to retrieve the object value.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_79\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IMightBeAHoconObject\n{\n    Akka.Configuration.Hocon.HoconObject GetObject();\n    bool IsObject();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Unsubscribe Message Class for Akka Distributed PubSub in C#\nDESCRIPTION: Defines a sealed Unsubscribe message class used to unsubscribe an actor from a topic in Akka's distributed publish-subscribe system. Includes support for group-based subscriptions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class Unsubscribe : System.IEquatable<Akka.Cluster.Tools.PublishSubscribe.Unsubscribe>\n{\n    public Unsubscribe(string topic, Akka.Actor.IActorRef @ref, string group = null) { }\n    public string Group { get; }\n    public Akka.Actor.IActorRef Ref { get; }\n    public string Topic { get; }\n    public bool Equals(Akka.Cluster.Tools.PublishSubscribe.Unsubscribe other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ReceivePersistentActor Abstract Class in Akka.NET\nDESCRIPTION: This code defines the `ReceivePersistentActor` abstract class, which inherits from `Akka.Persistence.UntypedPersistentActor` and implements `Akka.Actor.Internal.IInitializableActor`. It provides methods for defining command handlers using `Become`, `BecomeStacked`, and `Command`. This class facilitates the creation of persistent actors that use a receive-based programming model for handling commands.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class ReceivePersistentActor : Akka.Persistence.UntypedPersistentActor, Akka.Actor.Internal.IInitializableActor\n{\n    protected ReceivePersistentActor() { }\n    protected void Become(System.Action configure) { }\n    protected void BecomeStacked(System.Action configure) { }\n    protected void Command<T>(System.Action<T> handler, System.Predicate<T> shouldHandle = null) { }\n    protected void Command<T>(System.Predicate<T> shouldHandle, System.Action<T> handler) { }\n    protected void Command(System.Type messageType, System.Action<object> handler, System.Predicate<object> shouldHandle = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Inet Class for Socket Options and Configuration in Akka.NET\nDESCRIPTION: Provides classes for socket configuration in Akka.NET with options for buffer sizes, address reuse, and traffic class. This class contains various socket options and creators for different types of sockets.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_161\n\nLANGUAGE: C#\nCODE:\n```\npublic class Inet\n    {\n        public Inet() { }\n        public abstract class AbstractSocketOption : Akka.IO.Inet.SocketOption\n        {\n            protected AbstractSocketOption() { }\n        }\n        public abstract class AbstractSocketOptionV2 : Akka.IO.Inet.SocketOptionV2\n        {\n            protected AbstractSocketOptionV2() { }\n        }\n        public class DatagramChannelCreator : Akka.IO.Inet.SocketOption\n        {\n            public DatagramChannelCreator() { }\n            public virtual System.Net.Sockets.Socket Create(System.Net.Sockets.AddressFamily addressFamily) { }\n        }\n        public class static SO\n        {\n            public class ReceiveBufferSize : Akka.IO.Inet.SocketOption\n            {\n                public ReceiveBufferSize(int size) { }\n                public override void BeforeConnect(System.Net.Sockets.Socket s) { }\n                public override void BeforeDatagramBind(System.Net.Sockets.Socket ds) { }\n                public override void BeforeServerSocketBind(System.Net.Sockets.Socket ss) { }\n            }\n            public class ReuseAddress : Akka.IO.Inet.SocketOption\n            {\n                public ReuseAddress(bool on) { }\n                public override void BeforeConnect(System.Net.Sockets.Socket s) { }\n                public override void BeforeDatagramBind(System.Net.Sockets.Socket ds) { }\n                public override void BeforeServerSocketBind(System.Net.Sockets.Socket ss) { }\n            }\n            public class SendBufferSize : Akka.IO.Inet.SocketOption\n            {\n                public SendBufferSize(int size) { }\n                public override void AfterConnect(System.Net.Sockets.Socket s) { }\n            }\n            public class TrafficClass : Akka.IO.Inet.SocketOption\n            {\n                public TrafficClass(int tc) { }\n                public override void AfterConnect(System.Net.Sockets.Socket s) { }\n            }\n        }\n        public abstract class SoForwarders\n        {\n            protected SoForwarders() { }\n        }\n        public abstract class SocketOption\n        {\n            protected SocketOption() { }\n            public virtual void AfterConnect(System.Net.Sockets.Socket s) { }\n            public virtual void BeforeConnect(System.Net.Sockets.Socket s) { }\n            public virtual void BeforeDatagramBind(System.Net.Sockets.Socket ds) { }\n            public virtual void BeforeServerSocketBind(System.Net.Sockets.Socket ss) { }\n        }\n        public abstract class SocketOptionV2 : Akka.IO.Inet.SocketOption\n        {\n            protected SocketOptionV2() { }\n            public virtual void AfterBind(System.Net.Sockets.Socket s) { }\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining IReadConsistency Interface for Distributed Reads in C#\nDESCRIPTION: Defines the IReadConsistency interface that specifies a timeout property for read operations, used to configure consistency levels for distributed data reads.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IReadConsistency\n{\n    System.TimeSpan Timeout { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Akka.Cluster.Sharding Store Modes in HOCON\nDESCRIPTION: HOCON configuration showing recommended settings for Akka.Cluster.Sharding state store and remember-entities store modes. Uses ddata for state-store-mode and eventsourced for remember-entities-store.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/RELEASE_NOTES.md#2025-04-16_snippet_7\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster.sharding{\n  state-store-mode = ddata\n  remember-entities-store = eventsourced\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Child Actor for Fault Tolerance Testing in C#\nDESCRIPTION: This code defines a Child actor used for testing fault tolerance. It maintains a state and can throw exceptions on demand, allowing for various failure scenarios to be tested.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/fault-tolerance.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Child : UntypedActor\n{\n    private int state = 0;\n\n    protected override void OnReceive(object message)\n    {\n        switch (message)\n        {\n            case Exception ex:\n                throw ex;\n                break;\n            case int x:\n                state = x;\n                break;\n            case \"get\":\n                Sender.Tell(state);\n                break;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TailChoppingPool Router in C#\nDESCRIPTION: Defines the TailChoppingPool class for Akka.NET routing. It includes constructors, properties for interval and timeout, and methods for creating routers and managing instances.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_222\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class TailChoppingPool : Akka.Routing.Pool\n{\n    public TailChoppingPool(Akka.Configuration.Config config) { }\n    public TailChoppingPool(int nrOfInstances, System.TimeSpan within, System.TimeSpan interval) { }\n    public TailChoppingPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, System.TimeSpan within, System.TimeSpan interval, bool usePoolDispatcher = False) { }\n    public System.TimeSpan Interval { get; }\n    public System.TimeSpan Within { get; }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Routing.TailChoppingPool WithDispatcher(string dispatcher) { }\n    public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n    public Akka.Routing.TailChoppingPool WithResizer(Akka.Routing.Resizer resizer) { }\n    public Akka.Routing.TailChoppingPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }\n    // ... (TailChoppingPoolSurrogate class omitted for brevity)\n}\n```\n\n----------------------------------------\n\nTITLE: JournalEntry Class Definition in C#\nDESCRIPTION: Represents a journal entry with properties for persistence ID, sequence number, deletion status, manifest, timestamp, and payload. Serves as a container for event data to be persisted to the database.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.DotNet.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class JournalEntry\n{\n    public readonly bool IsDeleted;\n    public readonly string Manifest;\n    public readonly object Payload;\n    public readonly string PersistenceId;\n    public readonly long SequenceNr;\n    public readonly System.DateTime Timestamp;\n    public JournalEntry(string persistenceId, long sequenceNr, bool isDeleted, string manifest, System.DateTime timestamp, object payload) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Requesting Elements from Input Ports - Scala\nDESCRIPTION: This snippet explains operations related to input ports including requesting new elements with `Pull(in)`, acquiring elements with `Grab(in)`, and closing the port using `Cancel(in)`. These methods are essential for managing data flow from input ports in the stream, reflecting the current state of data consumption.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/custom-stream-processing.md#2025-04-16_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nPull(in)\nGrab(in)\nCancel(in)\n```\n\n----------------------------------------\n\nTITLE: Implementing ConsistentHash Generic Class in C#\nDESCRIPTION: Generic class implementation for consistent hashing functionality in Akka.NET. Provides methods for adding/removing nodes and finding nodes for keys.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_200\n\nLANGUAGE: C#\nCODE:\n```\npublic class ConsistentHash<T>\n{\n    public ConsistentHash(System.Collections.Generic.SortedDictionary<int, T> nodes, int virtualNodesFactor) { }\n    public bool IsEmpty { get; }\n    public Akka.Routing.ConsistentHash<T> Add(T node) { }\n    public T NodeFor(byte[] key) { }\n    public T NodeFor(string key) { }\n    public Akka.Routing.ConsistentHash<T> Remove(T node) { }\n    public static Akka.Routing.ConsistentHash<T> +(Akka.Routing.ConsistentHash<T> hash, T node) { }\n    public static Akka.Routing.ConsistentHash<T> -(Akka.Routing.ConsistentHash<T> hash, T node) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Base Event Classes Implementation\nDESCRIPTION: Defines base classes for event handling including TraceLogger, UnhandledMessage and Warning classes. These classes handle logging and message processing functionality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_145\n\nLANGUAGE: C#\nCODE:\n```\npublic TraceLogger() { }\nprotected override void OnReceive(object message) { }\n}\npublic sealed class UnhandledMessage : Akka.Event.AllDeadLetters, Akka.Actor.IWrappedMessage\n{\n    public UnhandledMessage(object message, Akka.Actor.IActorRef sender, Akka.Actor.IActorRef recipient) { }\n}\npublic class Warning : Akka.Event.LogEvent\n{\n    public Warning(string logSource, System.Type logClass, object message) { }\n    public Warning(System.Exception cause, string logSource, System.Type logClass, object message) { }\n    public override Akka.Event.LogLevel LogLevel() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PostRestartException in Akka.NET\nDESCRIPTION: Defines the PostRestartException class, which is thrown when an actor fails to restart. It includes information about the actor and the original cause of the failure.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic class PostRestartException : Akka.Actor.ActorInitializationException\n{\n    public PostRestartException(Akka.Actor.IActorRef actor, System.Exception cause, System.Exception originalCause) { }\n    protected PostRestartException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n    public System.Exception OriginalCause { get; }\n    public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UnsubscribeAck Message Class for Akka Distributed PubSub in C#\nDESCRIPTION: Defines a sealed UnsubscribeAck message class that acknowledges successful unsubscription in Akka's distributed publish-subscribe system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class UnsubscribeAck : System.IEquatable<Akka.Cluster.Tools.PublishSubscribe.UnsubscribeAck>\n{\n    public UnsubscribeAck(Akka.Cluster.Tools.PublishSubscribe.Unsubscribe unsubscribe) { }\n    public Akka.Cluster.Tools.PublishSubscribe.Unsubscribe Unsubscribe { get; }\n    public bool Equals(Akka.Cluster.Tools.PublishSubscribe.UnsubscribeAck other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DbConnectionExtensions for Transaction Execution in C#\nDESCRIPTION: Extends DbConnection with methods to execute tasks within transactions, supporting both void and generic return types. Uses asynchronous programming with cancellation token support.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.DotNet.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class static DbConnectionExtensions\n{\n    public static System.Threading.Tasks.Task ExecuteInTransaction(this System.Data.Common.DbConnection connection, System.Data.IsolationLevel isolationLevel, System.Threading.CancellationToken token, System.Func<System.Data.Common.DbTransaction, System.Threading.CancellationToken, System.Threading.Tasks.Task> task) { }\n    public static System.Threading.Tasks.Task<T> ExecuteInTransaction<T>(this System.Data.Common.DbConnection connection, System.Data.IsolationLevel isolationLevel, System.Threading.CancellationToken token, System.Func<System.Data.Common.DbTransaction, System.Threading.CancellationToken, System.Threading.Tasks.Task<T>> task) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NoLogger Class in Akka.NET\nDESCRIPTION: A null object implementation of ILoggingAdapter that discards all log messages. It provides a singleton instance to be used when logging is disabled or not required.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_140\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class NoLogger : Akka.Event.ILoggingAdapter\n{\n    public static readonly Akka.Event.ILoggingAdapter Instance;\n    public Akka.Event.ILogMessageFormatter Formatter { get; }\n    public bool IsDebugEnabled { get; }\n    public bool IsErrorEnabled { get; }\n    public bool IsInfoEnabled { get; }\n    public bool IsWarningEnabled { get; }\n    public bool IsEnabled(Akka.Event.LogLevel logLevel) { }\n    public void Log(Akka.Event.LogLevel logLevel, System.Exception cause, string format) { }\n    public void Log(Akka.Event.LogLevel logLevel, System.Exception cause, Akka.Event.LogMessage message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: AllDeadLetters Base Class in Akka.NET\nDESCRIPTION: Abstract base class for all dead letter types. Implements IWrappedMessage and contains information about the message, sender, and recipient involved in the dead letter.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_115\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class AllDeadLetters : Akka.Actor.IWrappedMessage\n{\n    protected AllDeadLetters(object message, Akka.Actor.IActorRef sender, Akka.Actor.IActorRef recipient) { }\n    public object Message { get; }\n    public Akka.Actor.IActorRef Recipient { get; }\n    public Akka.Actor.IActorRef Sender { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UnboundedMessageQueue for Akka.NET in C#\nDESCRIPTION: A standard unbounded message queue implementation that provides FIFO operations with no capacity constraints. It implements the basic IMessageQueue interface and unbounded semantics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_108\n\nLANGUAGE: C#\nCODE:\n```\npublic class UnboundedMessageQueue : Akka.Dispatch.ISemantics, Akka.Dispatch.IUnboundedMessageQueueSemantics, Akka.Dispatch.MessageQueues.IMessageQueue\n{\n    public UnboundedMessageQueue() { }\n    public int Count { get; }\n    public bool HasMessages { get; }\n    public void CleanUp(Akka.Actor.IActorRef owner, Akka.Dispatch.MessageQueues.IMessageQueue deadletters) { }\n    public void Enqueue(Akka.Actor.IActorRef receiver, Akka.Actor.Envelope envelope) { }\n    public bool TryDequeue(out Akka.Actor.Envelope envelope) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Aggregate Service Discovery Implementation\nDESCRIPTION: Implementation of aggregate service discovery that combines multiple discovery methods. Includes settings class for configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.Net.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class AggregateServiceDiscovery : Akka.Discovery.ServiceDiscovery\n{\n    public AggregateServiceDiscovery(Akka.Actor.ExtendedActorSystem system) { }\n    public override System.Threading.Tasks.Task<Akka.Discovery.ServiceDiscovery.Resolved> Lookup(Akka.Discovery.Lookup query, System.TimeSpan resolveTimeout) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Dsl Static Class for DistributedData Operations\nDESCRIPTION: Static class providing a domain-specific language for distributed data operations. It offers convenient methods for creating messages for data operations like Get, Update, Delete, Subscribe, and Unsubscribe.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic class static Dsl\n{\n    public static Akka.DistributedData.GetKeyIds GetKeyIds { get; }\n    public static Akka.DistributedData.GetReplicaCount GetReplicaCount { get; }\n    public static Akka.DistributedData.ReadLocal ReadLocal { get; }\n    public static Akka.DistributedData.WriteLocal WriteLocal { get; }\n    public static Akka.DistributedData.Delete Delete<T>(Akka.DistributedData.IKey<T> key, Akka.DistributedData.IWriteConsistency consistency, object request = null)\n        where T : Akka.DistributedData.IReplicatedData { }\n    public static Akka.DistributedData.Get Get<T>(Akka.DistributedData.IKey<T> key, Akka.DistributedData.IReadConsistency consistency = null, object request = null)\n        where T : Akka.DistributedData.IReplicatedData { }\n    public static Akka.DistributedData.Subscribe Subscribe<T>(Akka.DistributedData.IKey<T> key, Akka.Actor.IActorRef subscriber)\n        where T : Akka.DistributedData.IReplicatedData { }\n    public static Akka.DistributedData.Unsubscribe Unsubscribe<T>(Akka.DistributedData.IKey<T> key, Akka.Actor.IActorRef subscriber)\n        where T : Akka.DistributedData.IReplicatedData { }\n    public static Akka.DistributedData.Update Update<T>(Akka.DistributedData.IKey<T> key, T value, Akka.DistributedData.IWriteConsistency consistency = null)\n        where T : Akka.DistributedData.IReplicatedData<T> { }\n    public static Akka.DistributedData.Update Update<T>(Akka.DistributedData.IKey<T> key, Akka.DistributedData.IWriteConsistency consistency, System.Func<T, T> modify)\n        where T : Akka.DistributedData.IReplicatedData { }\n    public static Akka.DistributedData.Update Update<T>(Akka.DistributedData.IKey<T> key, T initial, Akka.DistributedData.IWriteConsistency consistency, System.Func<T, T> modify)\n        where T : Akka.DistributedData.IReplicatedData { }\n    public static Akka.DistributedData.Update Update<T>(Akka.DistributedData.IKey<T> key, T initial, Akka.DistributedData.IWriteConsistency consistency, object request, System.Func<T, T> modify)\n        where T : Akka.DistributedData.IReplicatedData { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Akka.NET Extension Constructor for Custom Persistence\nDESCRIPTION: Implementation of the constructor for a custom SQLite persistence extension in Akka.NET, which is required to take an ExtendedActorSystem parameter.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/custom-persistence-provider.md#2025-04-16_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\npublic SqlitePersistence(ExtendedActorSystem system)\n{\n    _system = system;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MixMetricsSelector in C# for Akka.NET\nDESCRIPTION: Defines a sealed class for mixing multiple metrics selectors. It implements interfaces for deep cloning, message handling, and equality comparison.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Core.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class MixMetricsSelector : Google.Protobuf.IDeepCloneable<Akka.Cluster.Metrics.Serialization.MixMetricsSelector>, Google.Protobuf.IMessage, Google.Protobuf.IMessage<Akka.Cluster.Metrics.Serialization.MixMetricsSelector>, System.IEquatable<Akka.Cluster.Metrics.Serialization.MixMetricsSelector>\n{\n    public const int SelectorsFieldNumber = 1;\n    public MixMetricsSelector() { }\n    public MixMetricsSelector(Akka.Cluster.Metrics.Serialization.MixMetricsSelector other) { }\n    public static Google.Protobuf.Reflection.MessageDescriptor Descriptor { get; }\n    public static Google.Protobuf.MessageParser<Akka.Cluster.Metrics.Serialization.MixMetricsSelector> Parser { get; }\n    public Google.Protobuf.Collections.RepeatedField<Akka.Cluster.Metrics.Serialization.MetricsSelector> Selectors { get; }\n    public int CalculateSize() { }\n    public Akka.Cluster.Metrics.Serialization.MixMetricsSelector Clone() { }\n    public override bool Equals(object other) { }\n    public bool Equals(Akka.Cluster.Metrics.Serialization.MixMetricsSelector other) { }\n    public override int GetHashCode() { }\n    public void MergeFrom(Akka.Cluster.Metrics.Serialization.MixMetricsSelector other) { }\n    public void MergeFrom(Google.Protobuf.CodedInputStream input) { }\n    public override string ToString() { }\n    public void WriteTo(Google.Protobuf.CodedOutputStream output) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining WithListeners Message Class in C#\nDESCRIPTION: Implements a listener message used for router configuration that provides a function to be executed on each routee actor reference. This enables custom operations on routees within a router.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_206\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class WithListeners : Akka.Routing.ListenerMessage\n    {\n        public WithListeners(System.Action<Akka.Actor.IActorRef> listenerFunction) { }\n        public System.Action<Akka.Actor.IActorRef> ListenerFunction { get; }\n    }\n```\n\n----------------------------------------\n\nTITLE: Actor Reference Extension Methods\nDESCRIPTION: Static extension methods providing utility functions for actor references like checking if an actor reference is nobody\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic class static ActorRefExtensions { \n    public static Akka.Actor.IActorRef GetOrElse(this Akka.Actor.IActorRef actorRef, System.Func<Akka.Actor.IActorRef> elseValue) { } \n    public static bool IsNobody(this Akka.Actor.IActorRef actorRef) { } \n}\n```\n\n----------------------------------------\n\nTITLE: Implementing No Message System Message in Akka.NET\nDESCRIPTION: Defines a special system message indicating no message is available. Used as a sentinel value in message processing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_121\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class NoMessage : Akka.Dispatch.SysMsg.SystemMessage\n{\n    public NoMessage() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: TimestampProvider Interface and Implementation in C#\nDESCRIPTION: Defines the ITimestampProvider interface and DefaultTimestampProvider implementation for generating timestamps for persistent events. Timestamps are used for ordering events in the journal.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ITimestampProvider\n{\n    long GenerateTimestamp(Akka.Persistence.IPersistentRepresentation message);\n}\n\npublic sealed class DefaultTimestampProvider : Akka.Persistence.Sql.Common.Journal.ITimestampProvider\n{\n    public DefaultTimestampProvider() { }\n    public long GenerateTimestamp(Akka.Persistence.IPersistentRepresentation message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DurableProducerQueue State Struct for Message Tracking\nDESCRIPTION: Implements a state structure that tracks sequence numbers for sent and confirmed messages in Akka's durable producer queue. It maintains collections of unconfirmed messages and confirmation states per qualifier.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_74\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.IsReadOnlyAttribute()]\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic struct State<[System.Runtime.CompilerServices.NullableAttribute(2)]  T> : Akka.Delivery.Internal.IDeliverySerializable, System.IEquatable<Akka.Delivery.DurableProducerQueue.State<T>>\n{\n    public State(long CurrentSeqNr, long HighestConfirmedSeqNr, [System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            1,\n            1,\n            0})] System.Collections.Immutable.ImmutableDictionary<string, System.ValueTuple<long, long>> ConfirmedSeqNr, System.Collections.Immutable.ImmutableList<Akka.Delivery.DurableProducerQueue.MessageSent<T>> Unconfirmed) { }\n    [System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            1,\n            1,\n            0})] \n    public System.Collections.Immutable.ImmutableDictionary<string, System.ValueTuple<long, long>> ConfirmedSeqNr { get; set; }\n    public long CurrentSeqNr { get; set; }\n    [System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})]\n    public static Akka.Delivery.DurableProducerQueue.State<T> Empty { get; }\n    public long HighestConfirmedSeqNr { get; set; }\n    public System.Collections.Immutable.ImmutableList<Akka.Delivery.DurableProducerQueue.MessageSent<T>> Unconfirmed { get; set; }\n    [return: System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})]\n    public Akka.Delivery.DurableProducerQueue.State<T> AddConfirmed(long seqNr, string qualifier, long timestamp) { }\n    [return: System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})]\n    public Akka.Delivery.DurableProducerQueue.State<T> AddMessageSent(Akka.Delivery.DurableProducerQueue.MessageSent<T> messageSent) { }\n    [return: System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})]\n    public Akka.Delivery.DurableProducerQueue.State<T> CleanUp(System.Collections.Generic.ISet<string> confirmationQualifiers) { }\n    [return: System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})]\n    public Akka.Delivery.DurableProducerQueue.State<T> CleanUpPartialChunkedMessages() { }\n    public bool Equals([System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})] Akka.Delivery.DurableProducerQueue.State<T> other) { }\n    public override int GetHashCode() { }\n```\n\n----------------------------------------\n\nTITLE: Configuring ReplicatorSettings in Akka.NET Distributed Data\nDESCRIPTION: This snippet shows methods for configuring various aspects of the ReplicatorSettings class in Akka.NET's Distributed Data module. These methods allow customization of durable keys, gossip intervals, pruning, and other replication-related settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\npublic Akka.DistributedData.ReplicatorSettings WithDurableKeys(System.Collections.Immutable.IImmutableSet<string> durableKeys) { }\npublic Akka.DistributedData.ReplicatorSettings WithDurableStoreProps(Akka.Actor.Props durableStoreProps) { }\npublic Akka.DistributedData.ReplicatorSettings WithGossipInterval(System.TimeSpan gossipInterval) { }\npublic Akka.DistributedData.ReplicatorSettings WithMaxDeltaElements(int maxDeltaElements) { }\npublic Akka.DistributedData.ReplicatorSettings WithMaxDeltaSize(int maxDeltaSize) { }\npublic Akka.DistributedData.ReplicatorSettings WithNotifySubscribersInterval(System.TimeSpan notifySubscribersInterval) { }\npublic Akka.DistributedData.ReplicatorSettings WithPreferOldest(bool preferOldest) { }\npublic Akka.DistributedData.ReplicatorSettings WithPruning(System.TimeSpan pruningInterval, System.TimeSpan maxPruningDissemination) { }\npublic Akka.DistributedData.ReplicatorSettings WithPruningMarkerTimeToLive(System.TimeSpan pruningMarkerTtl, System.TimeSpan durablePruningMarkerTtl) { }\npublic Akka.DistributedData.ReplicatorSettings WithRestartReplicatorOnFailure(bool restart) { }\npublic Akka.DistributedData.ReplicatorSettings WithRole(string role) { }\npublic Akka.DistributedData.ReplicatorSettings WithVerboseDebugLogging(bool verboseDebugLogging) { }\n```\n\n----------------------------------------\n\nTITLE: Custom Actor Implementation for Windows Service\nDESCRIPTION: Definition of a custom actor class for handling specific behaviors within the Akka.NET Windows Service.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/deployment/windows-service.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/examples/WindowsService/AkkaWindowsService/MyActor.cs?name=akka-windows-service-actor)]\n```\n\n----------------------------------------\n\nTITLE: Implementing RandomPool Class in C#\nDESCRIPTION: Defines a pool-based router that randomly selects routees. It includes methods for creating the router, getting the number of instances, and customizing the pool configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_206\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class RandomPool : Akka.Routing.Pool\n{\n    public RandomPool(Akka.Configuration.Config config) { }\n    public RandomPool(int nrOfInstances) { }\n    public RandomPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False) { }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Routing.RandomPool WithDispatcher(string dispatcher) { }\n    public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n    public Akka.Routing.RandomPool WithResizer(Akka.Routing.Resizer resizer) { }\n    public Akka.Routing.RandomPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }\n    public class RandomPoolSurrogate : Akka.Util.ISurrogate\n    {\n        public RandomPoolSurrogate() { }\n        public int NrOfInstances { get; set; }\n        public Akka.Routing.Resizer Resizer { get; set; }\n        public string RouterDispatcher { get; set; }\n        public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }\n        public bool UsePoolDispatcher { get; set; }\n        public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Flag Replicated Boolean Data Type\nDESCRIPTION: Implementation of a replicated boolean flag data type. It provides True and False static instances and implements interfaces for serialization, comparison, and equality operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Flag : Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.Flag>, System.IComparable, System.IComparable<Akka.DistributedData.Flag>, System.IEquatable<Akka.DistributedData.Flag>\n{\n    public static readonly Akka.DistributedData.Flag False;\n    public static readonly Akka.DistributedData.Flag True;\n    public Flag() { }\n    public Flag(bool enabled) { }\n    public bool Enabled { get; }\n    public int CompareTo(object obj) { }\n    public int CompareTo(Akka.DistributedData.Flag other) { }\n    public bool Equals(Akka.DistributedData.Flag other) { }\n}\n```\n\n----------------------------------------\n\nTITLE: TCP Extension and Command Classes in Akka.NET\nDESCRIPTION: This snippet shows the declaration of various TCP-related classes in Akka.NET, including WriteCommand, WritingResumed, and TcpExt. These classes provide functionality for managing TCP connections in an actor-based system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_167\n\nLANGUAGE: csharp\nCODE:\n```\n        public override string ToString() { }\n        }\n        public abstract class WriteCommand : Akka.IO.Tcp.Command\n        {\n            protected WriteCommand() { }\n            public static Akka.IO.Tcp.WriteCommand Create(System.Collections.Generic.IEnumerable<Akka.IO.Tcp.WriteCommand> writes) { }\n            public static Akka.IO.Tcp.WriteCommand Create(params WriteCommand[] writes) { }\n            public Akka.IO.Tcp.CompoundWrite Prepend(Akka.IO.Tcp.SimpleWriteCommand other) { }\n            public Akka.IO.Tcp.WriteCommand Prepend(System.Collections.Generic.IEnumerable<Akka.IO.Tcp.WriteCommand> writes) { }\n        }\n        public class WritingResumed : Akka.IO.Tcp.Event\n        {\n            public static readonly Akka.IO.Tcp.WritingResumed Instance;\n        }\n    }\n    public sealed class TcpExt : Akka.IO.IOExtension\n    {\n        public TcpExt(Akka.Actor.ExtendedActorSystem system) { }\n        public Akka.IO.Buffers.IBufferPool BufferPool { get; }\n        public override Akka.Actor.IActorRef Manager { get; }\n        public Akka.IO.TcpSettings Settings { get; }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Debug Log Level Class in C#\nDESCRIPTION: A class representing debug-level log events in the Akka.NET logging system. It contains the log message, source, class, and optional exception cause.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_117\n\nLANGUAGE: C#\nCODE:\n```\npublic class Debug : Akka.Event.LogEvent\n{\n    public Debug(string logSource, System.Type logClass, object message) { }\n    public Debug(System.Exception cause, string logSource, System.Type logClass, object message) { }\n    public override Akka.Event.LogLevel LogLevel() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Akka.NET Cluster Metrics Core Settings\nDESCRIPTION: Core configuration for Akka.NET cluster metrics including dispatcher, periodic tasks timing, and supervisor settings. Defines the basic structure and behavior of the metrics collection system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-metrics.md#2025-04-16_snippet_8\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster.metrics {\n  dispatcher = \"akka.actor.default-dispatcher\"\n  periodic-tasks-initial-delay = 1s\n  supervisor {\n    name = \"cluster-metrics\"\n    strategy {\n      provider = \"Akka.Cluster.Metrics.ClusterMetricsStrategy, Akka.Cluster.Metrics\"\n      configuration = {\n        loggingEnabled = true\n        withinTimeRange = 3s\n        maxNrOfRetries = 3\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Test Transport Implementation for Akka.NET\nDESCRIPTION: Implements a test transport class for simulating network behavior in unit tests. Provides controllable behaviors for association, dissociation, and message writing operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestTransport : Akka.Remote.Transport.Transport\n{\n    public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<Akka.Actor.Address, Akka.Remote.Transport.AssociationHandle> AssociateBehavior;\n    public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<Akka.Remote.Transport.TestAssociationHandle, bool> DisassociateBehavior;\n    public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<bool, System.ValueTuple<Akka.Actor.Address, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.IAssociationEventListener>>> ListenBehavior;\n    public readonly Akka.Actor.Address LocalAddress;\n    public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<bool, bool> ShutdownBehavior;\n    public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<System.ValueTuple<Akka.Remote.Transport.TestAssociationHandle, Google.Protobuf.ByteString>, bool> WriteBehavior;\n    public TestTransport(Akka.Actor.ActorSystem system, Akka.Configuration.Config conf) { }\n    public TestTransport(Akka.Actor.Address localAddress, Akka.Remote.Transport.AssociationRegistry registry, long maximumPayloadBytes = 32000, string schemeIdentifier = \"test\") { }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Persistence Failure Scenarios\nDESCRIPTION: Example test case demonstrating how to test persistence failures using PersistenceTestKit.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistence-testing.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic class CounterActorTests : PersistenceTestKit\n{\n    [Fact]\n    public async Task CounterActor_internal_state_will_be_lost_if_underlying_persistence_store_is_not_available()\n    {\n        await WithJournalWrite(write => write.Fail(), () =>\n        {\n            var actor = ActorOf(() => new CounterActor(\"test\"), \"counter\");\n            actor.Tell(\"inc\", TestActor);\n            actor.Tell(\"read\", TestActor);\n\n            var value = ExpectMsg<int>(TimeSpan.FromSeconds(3));\n            value.ShouldBe(0);\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FSMBase Abstract Class in C#\nDESCRIPTION: Defines the FSMBase abstract class which extends ActorBase. It includes nested classes and structures for managing finite state machine states, events, and transitions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class FSMBase : Akka.Actor.ActorBase\n{\n    protected FSMBase() { }\n    public sealed class CurrentState<TS>\n    {\n        public CurrentState(Akka.Actor.IActorRef fsmRef, TS state) { }\n        public Akka.Actor.IActorRef FsmRef { get; }\n        public TS State { get; }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n    }\n    public struct Event<TD> : Akka.Actor.INoSerializationVerificationNeeded\n    {\n        public Event(object fsmEvent, TD stateData) { }\n        public object FsmEvent { get; }\n        public TD StateData { get; }\n        public override string ToString() { }\n    }\n    // ... (other nested classes omitted for brevity)\n}\n```\n\n----------------------------------------\n\nTITLE: EWMA Class Implementation in C#\nDESCRIPTION: Exponentially Weighted Moving Average (EWMA) implementation for Akka.NET metrics with Protocol Buffer serialization support. Includes methods for calculating alpha values and handling metric updates.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class EWMA : Google.Protobuf.IDeepCloneable<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA>, Google.Protobuf.IMessage, Google.Protobuf.IMessage<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA>, System.IEquatable<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA>\n{\n    public const int AlphaFieldNumber = 2;\n    public const int ValueFieldNumber = 1;\n    public EWMA() { }\n    public EWMA(Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA other) { }\n    public EWMA(double value, double alpha) { }\n    public double Alpha { get; set; }\n    public static Google.Protobuf.Reflection.MessageDescriptor Descriptor { get; }\n    public static Google.Protobuf.MessageParser<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA> Parser { get; }\n    public double Value { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Cluster Reachability Status Events in C#\nDESCRIPTION: Defines the ReachableMember and UnreachableMember events that indicate when cluster nodes become reachable or unreachable. These events are critical for maintaining awareness of cluster health.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.DotNet.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ReachableMember : Akka.Cluster.ClusterEvent.ReachabilityEvent\n{\n    public ReachableMember(Akka.Cluster.Member member) { }\n}\npublic sealed class UnreachableMember : Akka.Cluster.ClusterEvent.ReachabilityEvent\n{\n    public UnreachableMember(Akka.Cluster.Member member) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TCP WriteCommand Abstract Class in C#\nDESCRIPTION: Defines the abstract WriteCommand class that serves as a base for TCP write operations. Includes factory methods for creating command instances and methods for combining commands.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_165\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class WriteCommand : Akka.IO.Tcp.Command\n{\n    protected WriteCommand() { }\n    public static Akka.IO.Tcp.WriteCommand Create(System.Collections.Generic.IEnumerable<Akka.IO.Tcp.WriteCommand> writes) { }\n    public static Akka.IO.Tcp.WriteCommand Create(params WriteCommand[] writes) { }\n    public Akka.IO.Tcp.CompoundWrite Prepend(Akka.IO.Tcp.SimpleWriteCommand other) { }\n    public Akka.IO.Tcp.WriteCommand Prepend(System.Collections.Generic.IEnumerable<Akka.IO.Tcp.WriteCommand> writes) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ORDictionary Class for Akka.NET Distributed Data in C#\nDESCRIPTION: Defines the ORDictionary class, an observed-remove dictionary for distributed data. It includes methods for adding, updating, removing, and merging entries, as well as properties for accessing dictionary contents.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ORDictionary<TKey, TValue> : Akka.DistributedData.IDeltaReplicatedData, Akka.DistributedData.IDeltaReplicatedData<Akka.DistributedData.ORDictionary<TKey, TValue>, Akka.DistributedData.ORDictionary<TKey, TValue>.IDeltaOperation>, Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IRemovedNodePruning<Akka.DistributedData.ORDictionary<TKey, TValue>>, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.ORDictionary<TKey, TValue>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable, System.IEquatable<Akka.DistributedData.ORDictionary<TKey, TValue>>\n    where TValue : Akka.DistributedData.IReplicatedData<TValue>\n{\n    public static readonly Akka.DistributedData.ORDictionary<TKey, TValue> Empty;\n    public ORDictionary(Akka.DistributedData.ORSet<TKey> keySet, System.Collections.Immutable.IImmutableDictionary<TKey, TValue> valueMap) { }\n    public int Count { get; }\n    public Akka.DistributedData.ORDictionary<TKey, TValue>.IDeltaOperation Delta { get; }\n    public System.Collections.Immutable.IImmutableDictionary<TKey, TValue> Entries { get; }\n    public bool IsEmpty { get; }\n    public TValue this[TKey key] { get; }\n    public System.Type KeyType { get; }\n    public System.Collections.Generic.IEnumerable<TKey> Keys { get; }\n    public System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.UniqueAddress> ModifiedByNodes { get; }\n    public System.Type ValueType { get; }\n    public System.Collections.Generic.IEnumerable<TValue> Values { get; }\n    public Akka.DistributedData.ORDictionary<TKey, TValue> AddOrUpdate(Akka.Cluster.Cluster node, TKey key, TValue initial, System.Func<TValue, TValue> modify) { }\n    public Akka.DistributedData.ORDictionary<TKey, TValue> AddOrUpdate(Akka.Cluster.UniqueAddress node, TKey key, TValue initial, System.Func<TValue, TValue> modify) { }\n    public bool ContainsKey(TKey key) { }\n    public bool Equals(Akka.DistributedData.ORDictionary<TKey, TValue> other) { }\n    public override bool Equals(object obj) { }\n    public System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> GetEnumerator() { }\n    public override int GetHashCode() { }\n    public Akka.DistributedData.ORDictionary<TKey, TValue> Merge(Akka.DistributedData.ORDictionary<TKey, TValue> other) { }\n    public Akka.DistributedData.IReplicatedData Merge(Akka.DistributedData.IReplicatedData other) { }\n    public Akka.DistributedData.ORDictionary<TKey, TValue> MergeDelta(Akka.DistributedData.ORDictionary<TKey, TValue>.IDeltaOperation delta) { }\n    public bool NeedPruningFrom(Akka.Cluster.UniqueAddress removedNode) { }\n    public Akka.DistributedData.ORDictionary<TKey, TValue> Prune(Akka.Cluster.UniqueAddress removedNode, Akka.Cluster.UniqueAddress collapseInto) { }\n    public Akka.DistributedData.ORDictionary<TKey, TValue> PruningCleanup(Akka.Cluster.UniqueAddress removedNode) { }\n    public Akka.DistributedData.ORDictionary<TKey, TValue> Remove(Akka.Cluster.Cluster node, TKey key) { }\n    public Akka.DistributedData.ORDictionary<TKey, TValue> Remove(Akka.Cluster.UniqueAddress node, TKey key) { }\n    public Akka.DistributedData.ORDictionary<TKey, TValue> ResetDelta() { }\n    public Akka.DistributedData.ORDictionary<TKey, TValue> SetItem(Akka.Cluster.Cluster node, TKey key, TValue value) { }\n    public Akka.DistributedData.ORDictionary<TKey, TValue> SetItem(Akka.Cluster.UniqueAddress node, TKey key, TValue value) { }\n    public override string ToString() { }\n    public bool TryGetValue(TKey key, out TValue value) { }\n    public interface IDeltaOperation<TKey, TValue> : Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedDelta, Akka.DistributedData.IRequireCausualDeliveryOfDeltas, System.IEquatable<Akka.DistributedData.ORDictionary<TKey, TValue>.IDeltaOperation>\n        where TValue : Akka.DistributedData.IReplicatedData<TValue> { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IHoconElement Interface in C#\nDESCRIPTION: The IHoconElement interface defines the basic contract for elements in a HOCON configuration. It specifies methods for determining the type of element and accessing its value as an array or string.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_72\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IHoconElement\n{\n    System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray();\n    string GetString();\n    bool IsArray();\n    bool IsString();\n}\n```\n\n----------------------------------------\n\nTITLE: Sharded Daemon Process Settings Management in C#\nDESCRIPTION: Encapsulates settings for a sharded daemon process, including keep-alive intervals and role assignments. Provides methods for constructing and modifying settings using system parameters and Akka configurations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Core.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ShardedDaemonProcessSettings {\n        public readonly System.TimeSpan KeepAliveInterval;\n        public readonly string Role;\n        public readonly Akka.Cluster.Sharding.ClusterShardingSettings ShardingSettings;\n        public static Akka.Cluster.Sharding.ShardedDaemonProcessSettings Create(Akka.Actor.ActorSystem system) { }\n        public static Akka.Cluster.Sharding.ShardedDaemonProcessSettings FromConfig(Akka.Configuration.Config config) { }\n        public Akka.Cluster.Sharding.ShardedDaemonProcessSettings WithKeepAliveInterval(System.TimeSpan keepAliveInterval) { }\n        public Akka.Cluster.Sharding.ShardedDaemonProcessSettings WithRole(string role) { }\n        public Akka.Cluster.Sharding.ShardedDaemonProcessSettings WithShardingSettings(Akka.Cluster.Sharding.ClusterShardingSettings shardingSettings) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining RoleLeaderChanged Event in C#\nDESCRIPTION: Implements the RoleLeaderChanged event that is triggered when leadership for a specific role changes within the cluster. This is used for role-based leader election scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.DotNet.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class RoleLeaderChanged : Akka.Cluster.ClusterEvent.IClusterDomainEvent, Akka.Event.IDeadLetterSuppression\n{\n    public RoleLeaderChanged(string role, Akka.Actor.Address leader) { }\n    public Akka.Actor.Address Leader { get; }\n    public string Role { get; }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating ConsistentHash Utility Class in C#\nDESCRIPTION: Implements a static ConsistentHash class with a Create method for generating consistent hash instances. It also includes a nested ConsistentHashingPoolSurrogate class for serialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_169\n\nLANGUAGE: C#\nCODE:\n```\npublic class static ConsistentHash\n{\n    public static Akka.Routing.ConsistentHash<T> Create<T>(System.Collections.Generic.IEnumerable<T> nodes, int virtualNodesFactor) { }\n    public class ConsistentHashingPoolSurrogate : Akka.Util.ISurrogate\n    {\n        public ConsistentHashingPoolSurrogate() { }\n        public int NrOfInstances { get; set; }\n        public Akka.Routing.Resizer Resizer { get; set; }\n        public string RouterDispatcher { get; set; }\n        public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }\n        public bool UsePoolDispatcher { get; set; }\n        public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining VersionVector Comparison Operators in C#\nDESCRIPTION: This snippet defines equality and comparison operators for the VersionVector class in Akka.DistributedData namespace. It includes operators for equality, inequality, greater than, and less than.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_53\n\nLANGUAGE: C#\nCODE:\n```\npublic static bool ==(Akka.DistributedData.VersionVector x, Akka.DistributedData.VersionVector y) { }\npublic static bool >(Akka.DistributedData.VersionVector x, Akka.DistributedData.VersionVector y) { }\npublic static bool !=(Akka.DistributedData.VersionVector x, Akka.DistributedData.VersionVector y) { }\npublic static bool <(Akka.DistributedData.VersionVector x, Akka.DistributedData.VersionVector y) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterReceptionist Actor in C#\nDESCRIPTION: Defines a sealed class ClusterReceptionist that inherits from ActorBase. It handles cluster reception operations and includes lifecycle methods.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterReceptionist : Akka.Actor.ActorBase\n{\n    public ClusterReceptionist(Akka.Actor.IActorRef pubSubMediator, Akka.Cluster.Tools.Client.ClusterReceptionistSettings settings) { }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n    public static Akka.Actor.Props Props(Akka.Actor.IActorRef pubSubMediator, Akka.Cluster.Tools.Client.ClusterReceptionistSettings settings) { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generic and Non-Generic Overloads for Receive in C#\nDESCRIPTION: Displays examples of using both generic and non-generic overloads of Receive. Parameters are used to demonstrate conditional message handling and logical flow control, with code that adapts based on specified message types and predicates.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka/Util/MatchHandler/README.md#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nReceive(typeof(string), obj => Console.WriteLine(obj.ToString()) );\nReceive(typeof(string), obj=> ((string) obj).Length>5, obj => Console.WriteLine(obj.ToString()) );\nReceive(typeof(string), obj => Console.WriteLine(obj.ToString()), obj=> ((string) obj).Length>5 );\nReceive(typeof(string), obj => \n  { \n    var s = (string) obj;\n    if(s.Length>5)\n    {\n      Console.WriteLine(\"1: \" + s);\n      return true;\n    }\n    return false;\n  });\n```\n\n----------------------------------------\n\nTITLE: Implementing TCP Write and Command Failure Classes in Akka.NET\nDESCRIPTION: Classes for writing data over TCP connections and handling command failures. CompoundWrite allows chaining multiple write operations, while CommandFailed provides detailed failure information.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_157\n\nLANGUAGE: C#\nCODE:\n```\npublic class CompoundWrite : Akka.IO.Tcp.WriteCommand, System.Collections.Generic.IEnumerable<Akka.IO.Tcp.SimpleWriteCommand>, System.Collections.IEnumerable\n{\n    public CompoundWrite(Akka.IO.Tcp.SimpleWriteCommand head, Akka.IO.Tcp.WriteCommand tailCommand) { }\n    public Akka.IO.Tcp.SimpleWriteCommand Head { get; }\n    public Akka.IO.Tcp.WriteCommand TailCommand { get; }\n    public System.Collections.Generic.IEnumerator<Akka.IO.Tcp.SimpleWriteCommand> GetEnumerator() { }\n    public override string ToString() { }\n}\npublic sealed class CommandFailed : Akka.IO.Tcp.Event\n{\n    public CommandFailed(Akka.IO.Tcp.Command cmd) { }\n    public Akka.Util.Option<System.Exception> Cause { get; }\n    [Akka.Annotations.InternalApiAttribute()]\n    public string CauseString { get; }\n    public Akka.IO.Tcp.Command Cmd { get; }\n    public override string ToString() { }\n    [Akka.Annotations.InternalApiAttribute()]\n    public Akka.IO.Tcp.CommandFailed WithCause(System.Exception cause) { }\n}\npublic class NoAck : Akka.IO.Tcp.Event\n{\n    public static readonly Akka.IO.Tcp.NoAck Instance;\n    public NoAck(object token) { }\n    public object Token { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Messages using Tell Pattern in C#\nDESCRIPTION: Demonstrates the fire-and-forget message sending pattern using Tell(). This is the preferred way of sending messages as it provides better concurrency and scalability.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\ntarget.Tell(message, Self);\n```\n\n----------------------------------------\n\nTITLE: Implementing Subscription Generic Class in Akka.NET\nDESCRIPTION: A class that represents a subscription in the Akka.NET event system. It manages a subscriber and an optional set of unsubscription classifiers for the event bus.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_142\n\nLANGUAGE: C#\nCODE:\n```\npublic class Subscription<TSubscriber, TClassifier>\n{\n    public Subscription(TSubscriber subscriber, System.Collections.Generic.IEnumerable<TClassifier> unsubscriptions) { }\n    public Subscription(TSubscriber subscriber) { }\n    public TSubscriber Subscriber { get; }\n    public System.Collections.Generic.ISet<TClassifier> Unsubscriptions { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LoopMessageSuccess Class in Akka.NET Persistence\nDESCRIPTION: This code defines the `LoopMessageSuccess` class, which represents a successful loop message in Akka.NET persistence. It includes properties for the message and the actor instance ID. The `LoopMessageSuccess` class implements interfaces related to journal messages, journal responses and persistence messages, also implementing `IEquatable` for value comparison.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class LoopMessageSuccess : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IJournalMessage, Akka.Persistence.IJournalResponse, Akka.Persistence.IPersistenceMessage, System.IEquatable<Akka.Persistence.LoopMessageSuccess>\n{\n    public LoopMessageSuccess(object message, int actorInstanceId) { }\n    public int ActorInstanceId { get; }\n    public object Message { get; }\n    public bool Equals(Akka.Persistence.LoopMessageSuccess other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Akka.NotUsed Type Definition\nDESCRIPTION: A singleton type that implements IComparable and IEquatable. Used to represent a placeholder when no actual value is required or used in an API that expects a type parameter.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_113\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class NotUsed : System.IComparable<Akka.NotUsed>, System.IEquatable<Akka.NotUsed>\n{\n    public static readonly Akka.NotUsed Instance;\n    public int CompareTo(Akka.NotUsed other) { }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.NotUsed other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StandardOutWriter Static Class in C#\nDESCRIPTION: Utility methods for writing colored text to the console, with optional foreground and background color specifications.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_232\n\nLANGUAGE: C#\nCODE:\n```\npublic class static StandardOutWriter\n{\n    public static void Write(string message, System.Nullable<System.ConsoleColor> foregroundColor = null, System.Nullable<System.ConsoleColor> backgroundColor = null) { }\n    public static void WriteLine(string message, System.Nullable<System.ConsoleColor> foregroundColor = null, System.Nullable<System.ConsoleColor> backgroundColor = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Router Messaging Classes in Akka.NET\nDESCRIPTION: Defines router-related message classes including RouterEnvelope for wrapping messages, RouterManagementMessage as a base for management messages, and RouterMessage containing static message instances.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_211\n\nLANGUAGE: C#\nCODE:\n```\npublic class RouterEnvelope\n{\n    public RouterEnvelope(object message) { }\n    public object Message { get; }\n}\n\npublic abstract class RouterManagementMessage\n{\n    protected RouterManagementMessage() { }\n}\n\npublic class static RouterMessage\n{\n    public static readonly Akka.Routing.GetRoutees GetRoutees;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ReplicatorSettings in C# for Akka.NET Distributed Data\nDESCRIPTION: Defines the configuration settings for the Akka.NET Distributed Data replicator. It includes properties for gossip intervals, pruning, durable storage, and other replication-related settings. The class provides methods for creating settings from ActorSystem or Config objects.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ReplicatorSettings\n{\n    [System.ObsoleteAttribute(\"Use constructor with `verboseDebugLogging` argument. Obsolete since v1.5.0-alpha2\")]\n    public ReplicatorSettings(string role, System.TimeSpan gossipInterval, System.TimeSpan notifySubscribersInterval, int maxDeltaElements, string dispatcher, System.TimeSpan pruningInterval, System.TimeSpan maxPruningDissemination, System.Collections.Immutable.IImmutableSet<string> durableKeys, Akka.Actor.Props durableStoreProps, System.TimeSpan pruningMarkerTimeToLive, System.TimeSpan durablePruningMarkerTimeToLive, int maxDeltaSize, bool restartReplicatorOnFailure, bool preferOldest) { }\n    public ReplicatorSettings(string role, System.TimeSpan gossipInterval, System.TimeSpan notifySubscribersInterval, int maxDeltaElements, string dispatcher, System.TimeSpan pruningInterval, System.TimeSpan maxPruningDissemination, System.Collections.Immutable.IImmutableSet<string> durableKeys, Akka.Actor.Props durableStoreProps, System.TimeSpan pruningMarkerTimeToLive, System.TimeSpan durablePruningMarkerTimeToLive, int maxDeltaSize, bool restartReplicatorOnFailure, bool preferOldest, bool verboseDebugLogging) { }\n    public string Dispatcher { get; }\n    public System.Collections.Immutable.IImmutableSet<string> DurableKeys { get; }\n    public System.TimeSpan DurablePruningMarkerTimeToLive { get; }\n    public Akka.Actor.Props DurableStoreProps { get; }\n    public System.TimeSpan GossipInterval { get; }\n    public bool IsDurable { get; }\n    public int MaxDeltaElements { get; }\n    public int MaxDeltaSize { get; }\n    public System.TimeSpan MaxPruningDissemination { get; }\n    public System.TimeSpan NotifySubscribersInterval { get; }\n    public bool PreferOldest { get; }\n    public System.TimeSpan PruningInterval { get; }\n    public System.TimeSpan PruningMarkerTimeToLive { get; }\n    public bool RestartReplicatorOnFailure { get; }\n    public string Role { get; }\n    public bool VerboseDebugLogging { get; }\n    public static Akka.DistributedData.ReplicatorSettings Create(Akka.Actor.ActorSystem system) { }\n    public static Akka.DistributedData.ReplicatorSettings Create(Akka.Configuration.Config config) { }\n    public Akka.DistributedData.ReplicatorSettings WithDispatcher(string dispatcher) { }\n}\n```\n\n----------------------------------------\n\nTITLE: NoRouter Class in Akka.NET Routing\nDESCRIPTION: Implements a router configuration that doesn't perform any routing. It's used as a default or placeholder router when no specific routing is needed, with a singleton Instance property.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_180\n\nLANGUAGE: C#\nCODE:\n```\npublic class NoRouter : Akka.Routing.RouterConfig\n{\n    protected NoRouter() { }\n    public static Akka.Routing.NoRouter Instance { get; }\n    public override string RouterDispatcher { get; }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override Akka.Actor.ActorBase CreateRouterActor() { }\n    public Akka.Actor.Props Props(Akka.Actor.Props routeeProps) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n    public class NoRouterSurrogate : Akka.Util.ISurrogate\n    {\n        public NoRouterSurrogate() { }\n        public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Wildcard Matching in C#\nDESCRIPTION: Provides a WildcardMatch static class with extension methods for string pattern matching using wildcards. This enables simple pattern matching capabilities for strings in the framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_261\n\nLANGUAGE: C#\nCODE:\n```\npublic class static WildcardMatch\n{\n    public static bool Like(this string text, string pattern, bool caseSensitive = False) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ReplayFilter for Akka.NET Persistence\nDESCRIPTION: This class implements a filter for replaying messages in Akka.NET persistence, with various modes for handling old or conflicting messages during replay.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\npublic class ReplayFilter : Akka.Actor.ActorBase\n{\n    public ReplayFilter(Akka.Actor.IActorRef persistentActor, Akka.Persistence.Journal.ReplayFilterMode mode, int windowSize, int maxOldWriters, bool debugEnabled) { }\n    public bool DebugEnabled { get; }\n    public int MaxOldWriters { get; }\n    public Akka.Persistence.Journal.ReplayFilterMode Mode { get; }\n    public Akka.Actor.IActorRef PersistentActor { get; }\n    public int WindowSize { get; }\n    public static Akka.Actor.Props Props(Akka.Actor.IActorRef persistentActor, Akka.Persistence.Journal.ReplayFilterMode mode, int windowSize, int maxOldWriters, bool debugEnabled) { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: ConsumerController Factory Method in C#\nDESCRIPTION: Static factory method for creating ConsumerController instances, which are used in Akka.NET's reliable delivery system to handle message consumption with automatic confirmations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_84\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic class static ConsumerController\n{\n    public static Akka.Actor.Props Create<[System.Runtime.CompilerServices.NullableAttribute(2)]  T>(Akka.Actor.IActorRefFactory actorRefFactory, [System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})] Akka.Util.Option<Akka.Actor.IActorRef> producerControllerReference, [System.Runtime.CompilerServices.NullableAttribute(2)] Akka.Delivery.ConsumerController.Settings settings = null) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Subscribe and Unsubscribe in Akka.NET Distributed Data\nDESCRIPTION: These classes represent subscription and unsubscription messages for distributed data in Akka.NET. They contain properties for the key and subscriber, and implement equality comparison methods.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Subscribe : Akka.DistributedData.IReplicatorMessage, System.IEquatable<Akka.DistributedData.Subscribe>\n{\n    public Subscribe(Akka.DistributedData.IKey key, Akka.Actor.IActorRef subscriber) { }\n    public Akka.DistributedData.IKey Key { get; }\n    public Akka.Actor.IActorRef Subscriber { get; }\n    public bool Equals(Akka.DistributedData.Subscribe other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n\npublic sealed class Unsubscribe : Akka.DistributedData.IReplicatorMessage, System.IEquatable<Akka.DistributedData.Unsubscribe>\n{\n    public Unsubscribe(Akka.DistributedData.IKey key, Akka.Actor.IActorRef subscriber) { }\n    public Akka.DistributedData.IKey Key { get; }\n    public Akka.Actor.IActorRef Subscriber { get; }\n    public bool Equals(Akka.DistributedData.Unsubscribe other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PoisonPill Message in Akka.NET\nDESCRIPTION: Defines the PoisonPill class, which is a special message used to stop actors. It implements several Akka.NET interfaces for message handling and suppression.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class PoisonPill : Akka.Actor.IAutoReceivedMessage, Akka.Actor.IPossiblyHarmful, Akka.Event.IDeadLetterSuppression\n{\n    public static Akka.Actor.PoisonPill Instance { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Actor Reference Extensions for Message Passing\nDESCRIPTION: Extension methods for actor references to support forwarding and telling messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class static ActorRefImplicitSenderExtensions\n{\n    public static void Forward(this Akka.Actor.IActorRef receiver, object message) { }\n    public static void Tell(this Akka.Actor.IActorRef receiver, object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AdaptiveLoadBalancingGroup in Akka.NET\nDESCRIPTION: This class represents a group of actors that uses adaptive load balancing based on provided metrics. It allows for configuring the load balancing behavior via a selector and maintains routing logic for distributing messages among its members.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Core.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Metrics.Tests\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\nnamespace Akka.Cluster.Metrics\n{\n    public sealed class AdaptiveLoadBalancingGroup : Akka.Routing.Group\n    {\n        public AdaptiveLoadBalancingGroup(Akka.Cluster.Metrics.IMetricsSelector metricsSelector = null, System.Collections.Generic.IEnumerable<string> paths = null, string routerDispatcher = null) { }\n        public AdaptiveLoadBalancingGroup(Akka.Configuration.Config config) { }\n        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n        public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }\n        public override Akka.Actor.Props RoutingLogicController(Akka.Routing.RoutingLogic routingLogic) { }\n        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n        public Akka.Cluster.Metrics.AdaptiveLoadBalancingGroup WithDispatcher(string dispatcherId) { }\n        public class AdaptiveLoadBalancingGroupSurrogate : Akka.Util.ISurrogate\n        {\n            public AdaptiveLoadBalancingGroupSurrogate() { }\n            public Akka.Cluster.Metrics.IMetricsSelector MetricsSelector { get; set; }\n            public System.Collections.Generic.IEnumerable<string> Paths { get; set; }\n            public string RouterDispatcher { get; set; }\n            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Clock Delegate Definition for Timestamp Management\nDESCRIPTION: Defines a Clock delegate for managing logical timestamps in replicated data. This is used for tracking causality and resolving conflicts in distributed operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic delegate long Clock<in T>(long currentTimestamp, T value);\n```\n\n----------------------------------------\n\nTITLE: Deferring Actions in Persistent Actors with DeferAsync in Akka.NET\nDESCRIPTION: Shows how to use DeferAsync to define actions that should be executed after previous Persist/PersistAsync handlers have completed, without persisting new events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/event-sourcing.md#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/core/Akka.Docs.Tests/Persistence/PersistentActor/Defer.cs?name=Defer)]\n```\n\n----------------------------------------\n\nTITLE: Implementing ActorIdentity Class in C#\nDESCRIPTION: The ActorIdentity class represents the identity of an actor, containing a message ID and a reference to the actor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ActorIdentity\n{\n    public ActorIdentity(object messageId, Akka.Actor.IActorRef subject) { }\n    public object MessageId { get; }\n    public Akka.Actor.IActorRef Subject { get; }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Supervisor Strategy Abstract Methods\nDESCRIPTION: Abstract methods for handling actor supervision and failure management in Akka.NET\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_51\n\nLANGUAGE: C#\nCODE:\n```\nprotected abstract Akka.Actor.Directive Handle(Akka.Actor.IActorRef child, System.Exception exception);\npublic abstract void HandleChildTerminated(Akka.Actor.IActorContext actorContext, Akka.Actor.IActorRef child, System.Collections.Generic.IEnumerable<Akka.Actor.IInternalActorRef> children);\n```\n\n----------------------------------------\n\nTITLE: Snapshot Management Classes in C#\nDESCRIPTION: Classes for managing snapshots in Akka.NET persistence, including metadata handling and snapshot selection functionality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SnapshotMetadata : System.IEquatable<Akka.Persistence.SnapshotMetadata>\n{\n    public static System.DateTime TimestampNotSpecified;\n    public SnapshotMetadata(string persistenceId, long sequenceNr) { }\n    [Newtonsoft.Json.JsonConstructorAttribute()]\n    public SnapshotMetadata(string persistenceId, long sequenceNr, System.DateTime timestamp) { }\n    public static System.Collections.Generic.IComparer<Akka.Persistence.SnapshotMetadata> Comparer { get; }\n    public string PersistenceId { get; }\n    public long SequenceNr { get; }\n    public System.DateTime Timestamp { get; }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.Persistence.SnapshotMetadata other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: DummyClassForStringSources in Akka.NET\nDESCRIPTION: A placeholder class used when a string log source is provided instead of a Type. This class has no functionality other than serving as a marker for string-based log sources.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_123\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DummyClassForStringSources\n{\n    public DummyClassForStringSources() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Unwatch System Message in Akka.NET\nDESCRIPTION: Defines a system message that requests an actor to stop watching another actor. Contains references to both the watcher and watchee actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_133\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Unwatch : Akka.Dispatch.SysMsg.SystemMessage\n{\n    public Unwatch(Akka.Actor.IInternalActorRef watchee, Akka.Actor.IInternalActorRef watcher) { }\n    public Akka.Actor.IInternalActorRef Watchee { get; }\n    public Akka.Actor.IInternalActorRef Watcher { get; }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: NodeMetrics Core Class Implementation in C#\nDESCRIPTION: Core methods of NodeMetrics class for handling cluster metrics including equality comparison, merging, and serialization operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Core.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic bool Equals(Akka.Cluster.Metrics.Serialization.NodeMetrics other) { }\npublic override int GetHashCode() { }\npublic Akka.Cluster.Metrics.Serialization.NodeMetrics Merge(Akka.Cluster.Metrics.Serialization.NodeMetrics that) { }\npublic void MergeFrom(Akka.Cluster.Metrics.Serialization.NodeMetrics other) { }\npublic void MergeFrom(Google.Protobuf.CodedInputStream input) { }\npublic Akka.Util.Option<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric> Metric(string name) { }\npublic bool SameAs(Akka.Cluster.Metrics.Serialization.NodeMetrics that) { }\npublic override string ToString() { }\npublic Akka.Cluster.Metrics.Serialization.NodeMetrics Update(Akka.Cluster.Metrics.Serialization.NodeMetrics that) { }\npublic void WriteTo(Google.Protobuf.CodedOutputStream output) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ListenAttempt Class in Akka.NET Remote Transport\nDESCRIPTION: A class representing an attempt to listen at a specific address in Akka.NET's remote transport system, extending the Activity base class.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ListenAttempt : Akka.Remote.Transport.Activity\n{\n    public ListenAttempt(Akka.Actor.Address boundAddress) { }\n    public Akka.Actor.Address BoundAddress { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Extractor Usage in C# 8\nDESCRIPTION: This C# 8 code demonstrates the usage of the `TryExtractName` extension method in a switch expression with pattern matching and 'when' clauses, providing a concise way to mimic Scala extractors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/porting-guide.md#2025-04-16_snippet_17\n\nLANGUAGE: c#\nCODE:\n```\nvar message = user switch\n{\n    FreeUser p when p.TryExtractName(out var name) => $\"Hello {name}\",\n    PremiumUser p when p.TryExtractName(out var name) => $\"Welcome back, dear {name}\",\n    _ => string.Empty\n};\n```\n\n----------------------------------------\n\nTITLE: Member Class Definition\nDESCRIPTION: This snippet defines a class `Member` that implements `IComparable` and `IComparable<Akka.Cluster.Member>`. It represents a member of the Akka cluster, containing information such as its address, roles, and status. It also includes methods for comparing members, copying member instances with updated statuses, and checking for role membership.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Member : System.IComparable, System.IComparable<Akka.Cluster.Member>\n{\n    public static readonly System.Collections.Generic.IComparer<Akka.Actor.Address> AddressOrdering;\n    public static readonly System.Collections.Generic.IComparer<Akka.Cluster.Member> AgeOrdering;\n    public Akka.Actor.Address Address { get; }\n    public Akka.Util.AppVersion AppVersion { get; }\n    public System.Collections.Immutable.ImmutableHashSet<string> Roles { get; }\n    public Akka.Cluster.MemberStatus Status { get; }\n    public Akka.Cluster.UniqueAddress UniqueAddress { get; }\n    public int CompareTo(Akka.Cluster.Member other) { }\n    public Akka.Cluster.Member Copy(Akka.Cluster.MemberStatus status) { }\n    public Akka.Cluster.Member CopyUp(int upNumber) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public bool HasRole(string role) { }\n    public static Akka.Cluster.Member HighestPriorityOf(Akka.Cluster.Member m1, Akka.Cluster.Member m2) { }\n    public bool IsOlderThan(Akka.Cluster.Member other) { }\n    public static System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.Member> PickHighestPriority(System.Collections.Generic.IEnumerable<Akka.Cluster.Member> a, System.Collections.Generic.IEnumerable<Akka.Cluster.Member> b) { }\n    public static System.Collections.Immutable.ImmutableSortedSet<Akka.Cluster.Member> PickNextTransition(System.Collections.Generic.IEnumerable<Akka.Cluster.Member> a, System.Collections.Generic.IEnumerable<Akka.Cluster.Member> b) { }\n    public static Akka.Cluster.Member PickNextTransition(Akka.Cluster.Member a, Akka.Cluster.Member b) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: EventSourcedProducerQueue Settings Implementation in C#\nDESCRIPTION: Defines configuration settings for EventSourcedProducerQueue including cleanup timing, event deletion, journal plugins, and snapshot management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\npublic class Settings : System.IEquatable<Akka.Persistence.Delivery.EventSourcedProducerQueue.Settings>\n{\n    public System.TimeSpan CleanupUnusedAfter { get; set; }\n    public bool DeleteEvents { get; set; }\n    public string JournalPluginId { get; set; }\n    public int KeepNSnapshots { get; set; }\n    public System.TimeSpan RestartMaxBackoff { get; set; }\n    public int SnapshotEvery { get; set; }\n    public string SnapshotPluginId { get; set; }\n    public static Akka.Persistence.Delivery.EventSourcedProducerQueue.Settings Create(Akka.Actor.ActorSystem sys) { }\n    public static Akka.Persistence.Delivery.EventSourcedProducerQueue.Settings Create(Akka.Configuration.Config config) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining VectorClock Ordering Enum in C#\nDESCRIPTION: Enumerates possible ordering relationships between vector clocks. This enum is used to represent the result of comparing two vector clocks.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Core.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic enum Ordering\n{\n    After = 0,\n    Before = 1,\n    Same = 2,\n    Concurrent = 3,\n    FullOrder = 4,\n}\n```\n\n----------------------------------------\n\nTITLE: Actor Watch System Message in Akka.NET\nDESCRIPTION: System message for setting up a death watch. Contains references to both the watchee (actor to be watched) and the watcher (actor that will receive notifications).\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_111\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Watch : Akka.Dispatch.SysMsg.SystemMessage\n{\n    public Watch(Akka.Actor.IInternalActorRef watchee, Akka.Actor.IInternalActorRef watcher) { }\n    public Akka.Actor.IInternalActorRef Watchee { get; }\n    public Akka.Actor.IInternalActorRef Watcher { get; }\n    protected bool Equals(Akka.Dispatch.SysMsg.Watch other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Akka.Cluster.Sharding for DData without Remember Entities - HOCON\nDESCRIPTION: Minimal HOCON configuration required for users migrating from persistence to ddata without using the remember entities feature.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/whats-new/akkadotnet-v1.5-upgrade-advisories.md#2025-04-16_snippet_7\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster.sharding {\n    state-store-mode = ddata\n}\n\n```\n\n----------------------------------------\n\nTITLE: Hocon Tokenizer Class Definition in C#\nDESCRIPTION: Class responsible for tokenizing Hocon configuration text, providing methods for character inspection, pattern matching, and token manipulation during the parsing process.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_83\n\nLANGUAGE: C#\nCODE:\n```\npublic class Tokenizer\n{\n    public Tokenizer(string text) { }\n    public bool EoF { get; }\n    public bool Matches(string pattern) { }\n    public bool Matches(params string[] patterns) { }\n    public char Peek() { }\n    protected string PickErrorLine(out int index) { }\n    public void Pop() { }\n    public void PullWhitespace() { }\n    public void Push() { }\n    public string Take(int length) { }\n    public char Take() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SuppressedDeadLetter Class in Akka.NET\nDESCRIPTION: A sealed class that represents a dead letter that has been suppressed from normal dead letter processing. It extends AllDeadLetters and works with IDeadLetterSuppression messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_143\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SuppressedDeadLetter : Akka.Event.AllDeadLetters\n{\n    public SuppressedDeadLetter(Akka.Event.IDeadLetterSuppression message, Akka.Actor.IActorRef sender, Akka.Actor.IActorRef recipient) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Child Actors in TestKit\nDESCRIPTION: Methods for creating child actors with various configurations including props, names, and supervisor strategies.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic Akka.Actor.IActorRef ChildActorOf(Akka.Actor.Props props, string name, Akka.Actor.SupervisorStrategy supervisorStrategy, System.Threading.CancellationToken cancellationToken = null) { }\npublic Akka.Actor.IActorRef ChildActorOf(Akka.Actor.Props props, string name, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: AtLeastOnceDeliverySnapshot Class Definition in Akka.Persistence\nDESCRIPTION: Represents a snapshot of the delivery state for at-least-once delivery actors. This class stores the current delivery ID and unconfirmed deliveries, allowing delivery state to be persisted and recovered after actor restarts.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class AtLeastOnceDeliverySnapshot : Akka.Persistence.Serialization.IMessage, System.IEquatable<Akka.Persistence.AtLeastOnceDeliverySnapshot>\n{\n    public AtLeastOnceDeliverySnapshot(long currentDeliveryId, Akka.Persistence.UnconfirmedDelivery[] unconfirmedDeliveries) { }\n    public long CurrentDeliveryId { get; }\n    public Akka.Persistence.UnconfirmedDelivery[] UnconfirmedDeliveries { get; }\n    public bool Equals(Akka.Persistence.AtLeastOnceDeliverySnapshot other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Group Query Feature Integration - C#\nDESCRIPTION: This snippet tests the overall integration of the group query feature, ensuring that the group actor and query actor functionalities work together seamlessly.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-4.md#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[DeviceGroupSpec.cs](../../../../src/core/Akka.Docs.Tutorials/Tutorial4/DeviceGroupSpec.cs?name=group-query-integration-test)]\n```\n\n----------------------------------------\n\nTITLE: AtomicWrite Class Definition in Akka.Persistence\nDESCRIPTION: Class representing an atomic write operation to the journal, containing one or more persistent representations that must be written as a single unit.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class AtomicWrite : Akka.Persistence.IPersistentEnvelope, Akka.Persistence.Serialization.IMessage\n{\n    public AtomicWrite(Akka.Persistence.IPersistentRepresentation @event) { }\n    public AtomicWrite(System.Collections.Immutable.IImmutableList<Akka.Persistence.IPersistentRepresentation> payload) { }\n    public long HighestSequenceNr { get; }\n    public long LowestSequenceNr { get; }\n    public object Payload { get; }\n    public string PersistenceId { get; }\n    public Akka.Actor.IActorRef Sender { get; }\n    public int Size { get; }\n    public bool Equals(Akka.Persistence.AtomicWrite other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AnyNumber Struct for Metrics Type Conversion\nDESCRIPTION: Defines a utility structure for working with different numeric types in metrics collection. It provides implicit conversions and type handling for common numeric types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic struct AnyNumber\n{\n    public AnyNumber(int n) { }\n    public AnyNumber(long n) { }\n    public AnyNumber(float n) { }\n    public AnyNumber(double n) { }\n    public double DoubleValue { get; }\n    public long LongValue { get; }\n    public Akka.Cluster.Metrics.Helpers.AnyNumber.NumberType Type { get; }\n    public override string ToString() { }\n    public static Akka.Cluster.Metrics.Helpers.AnyNumber op_Implicit(int n) { }\n    public static Akka.Cluster.Metrics.Helpers.AnyNumber op_Implicit(long n) { }\n    public static Akka.Cluster.Metrics.Helpers.AnyNumber op_Implicit(float n) { }\n    public static Akka.Cluster.Metrics.Helpers.AnyNumber op_Implicit(double n) { }\n    public enum NumberType\n    {\n        Int = 0,\n        Long = 1,\n        Float = 2,\n        Double = 3,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ClusterClientReceptionistExtensionProvider Class Definition in C#\nDESCRIPTION: Extension provider for the ClusterClientReceptionist that handles creation of the extension within an actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterClientReceptionistExtensionProvider : Akka.Actor.ExtensionIdProvider<Akka.Cluster.Tools.Client.ClusterClientReceptionist>\n{\n    public ClusterClientReceptionistExtensionProvider() { }\n    public override Akka.Cluster.Tools.Client.ClusterClientReceptionist CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: AbstractTransportAdapter Class Implementation in C#\nDESCRIPTION: Abstract base class for transport adapters in Akka.NET remote system. Provides core functionality for wrapping transport implementations and handling associations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AbstractTransportAdapter : Akka.Remote.Transport.Transport\n{\n    protected Akka.Remote.Transport.Transport WrappedTransport;\n    protected AbstractTransportAdapter(Akka.Remote.Transport.Transport wrappedTransport) { }\n    public override long MaximumPayloadBytes { get; }\n    protected abstract Akka.Remote.Transport.SchemeAugmenter SchemeAugmenter { get; }\n    public override string SchemeIdentifier { get; }\n    public override System.Threading.Tasks.Task<Akka.Remote.Transport.AssociationHandle> Associate(Akka.Actor.Address remoteAddress) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Read Consistency Models in C# for Akka.NET Distributed Data\nDESCRIPTION: Defines various read consistency models such as ReadAll, ReadFrom, ReadLocal, ReadMajority, and ReadMajorityPlus. These classes implement the IReadConsistency interface and provide different strategies for reading data in a distributed system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ReadAll : Akka.DistributedData.IReadConsistency, System.IEquatable<Akka.DistributedData.ReadAll>\n{\n    public ReadAll(System.TimeSpan timeout) { }\n    public System.TimeSpan Timeout { get; }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.DistributedData.ReadAll other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n\npublic sealed class ReadFrom : Akka.DistributedData.IReadConsistency, System.IEquatable<Akka.DistributedData.ReadFrom>\n{\n    public ReadFrom(int n, System.TimeSpan timeout) { }\n    public int N { get; }\n    public System.TimeSpan Timeout { get; }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.DistributedData.ReadFrom other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n\npublic sealed class ReadLocal : Akka.DistributedData.IReadConsistency\n{\n    public static readonly Akka.DistributedData.ReadLocal Instance;\n    public System.TimeSpan Timeout { get; }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n\npublic sealed class ReadMajority : Akka.DistributedData.IReadConsistency, System.IEquatable<Akka.DistributedData.ReadMajority>\n{\n    public ReadMajority(System.TimeSpan timeout, int minCapacity = 0) { }\n    public int MinCapacity { get; }\n    public System.TimeSpan Timeout { get; }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.DistributedData.ReadMajority other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n\npublic sealed class ReadMajorityPlus : Akka.DistributedData.IReadConsistency, System.IEquatable<Akka.DistributedData.ReadMajorityPlus>\n{\n    public ReadMajorityPlus(System.TimeSpan timeout, int additional, int minCapacity = 0) { }\n    public int Additional { get; }\n    public int MinCapacity { get; }\n    public System.TimeSpan Timeout { get; }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.DistributedData.ReadMajorityPlus other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Event Adapter Interface Implementation in C#\nDESCRIPTION: Combined implementation of read and write event adapters for journal events with methods for converting events between journal and domain formats.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_57\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class CombinedReadEventAdapter : Akka.Persistence.Journal.IEventAdapter, Akka.Persistence.Journal.IReadEventAdapter, Akka.Persistence.Journal.IWriteEventAdapter\n{\n    public CombinedReadEventAdapter(System.Collections.Generic.IEnumerable<Akka.Persistence.Journal.IEventAdapter> adapters) { }\n    public System.Collections.Generic.IEnumerable<Akka.Persistence.Journal.IEventAdapter> Adapters { get; }\n    public Akka.Persistence.Journal.IEventSequence FromJournal(object evt, string manifest) { }\n    public string Manifest(object evt) { }\n    public object ToJournal(object evt) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BatchingSqlJournalSetup for Akka.NET Persistence in C#\nDESCRIPTION: Provides a setup class for batching SQL journal in Akka.NET Persistence. Configures connection strings, isolation levels, circuit breaker settings, and other journal-related parameters.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.DotNet.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class BatchingSqlJournalSetup\n{\n    protected BatchingSqlJournalSetup(Akka.Configuration.Config config, Akka.Persistence.Sql.Common.Journal.QueryConfiguration namingConventions) { }\n    // ... (additional constructors and properties)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a SometimesSlowService in C#\nDESCRIPTION: This snippet defines a class called SometimesSlowService that simulates a slow processing service. It increments and decrements a running count to track active processes and converts input strings to uppercase with variable processing time based on the first character.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic class SometimesSlowService {\n    private readonly AtomicCounter runningCount = new AtomicCounter();\n  \n    public Task<string> Convert(string s) {\n        Console.WriteLine($\"running {s} {runningCount.IncrementAndGet()}\");\n  \n        return Task.Run(() => {\n            if(s != \"\" && char.IsLower(s[0]))\n                Thread.Sleep(500);\n            else\n                Thread.Sleep(20);\n            Console.WriteLine($\"completed {s} {runningCount.GetAndDecrement()}\");\n  \n            return s.ToUpper();\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: DefaultTimestampProvider Implementation in C#\nDESCRIPTION: Implements the ITimestampProvider interface to generate timestamps for persistent messages. Used by journal implementations to add timing information to stored events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.DotNet.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class DefaultTimestampProvider : Akka.Persistence.Sql.Common.Journal.ITimestampProvider\n{\n    public DefaultTimestampProvider() { }\n    public long GenerateTimestamp(Akka.Persistence.IPersistentRepresentation message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Right<TA,TB> Class in C#\nDESCRIPTION: A specialized Right class that inherits from Either<TA,TB>, representing the right value in an Either monad.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_229\n\nLANGUAGE: C#\nCODE:\n```\npublic class Right<TA, TB> : Akka.Util.Either<TA, TB>\n{\n    public Right(TB b) { }\n    public override bool IsLeft { get; }\n    public override bool IsRight { get; }\n    public TB Value { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Akka API Annotation Attributes in C#\nDESCRIPTION: A set of system annotation attributes used to mark API status, including ApiMayChangeAttribute, DoNotInheritAttribute, InternalApiAttribute, and InternalStableApiAttribute.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_68\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsageAttribute(System.AttributeTargets.Module | System.AttributeTargets.Class | System.AttributeTargets.Struct | System.AttributeTargets.Enum | System.AttributeTargets.Constructor | System.AttributeTargets.Method | System.AttributeTargets.Property | System.AttributeTargets.Field | System.AttributeTargets.Interface | System.AttributeTargets.All, AllowMultiple=false, Inherited=true)]\npublic sealed class ApiMayChangeAttribute : System.Attribute\n{\n    public ApiMayChangeAttribute() { }\n}\n[System.AttributeUsageAttribute(System.AttributeTargets.Class | System.AttributeTargets.Interface | System.AttributeTargets.All, AllowMultiple=false, Inherited=true)]\npublic sealed class DoNotInheritAttribute : System.Attribute\n{\n    public DoNotInheritAttribute() { }\n}\n[System.AttributeUsageAttribute(System.AttributeTargets.Module | System.AttributeTargets.Class | System.AttributeTargets.Struct | System.AttributeTargets.Enum | System.AttributeTargets.Constructor | System.AttributeTargets.Method | System.AttributeTargets.Property | System.AttributeTargets.Field | System.AttributeTargets.Interface | System.AttributeTargets.All, AllowMultiple=false, Inherited=true)]\npublic sealed class InternalApiAttribute : System.Attribute\n{\n    public InternalApiAttribute() { }\n}\n[System.AttributeUsageAttribute(System.AttributeTargets.Module | System.AttributeTargets.Class | System.AttributeTargets.Struct | System.AttributeTargets.Enum | System.AttributeTargets.Constructor | System.AttributeTargets.Method | System.AttributeTargets.Property | System.AttributeTargets.Field | System.AttributeTargets.Interface | System.AttributeTargets.All, AllowMultiple=false, Inherited=true)]\npublic sealed class InternalStableApiAttribute : System.Attribute\n{\n    public InternalStableApiAttribute() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Virtual Message Delivery Methods in C#\nDESCRIPTION: Defines virtual methods for delivering messages and system messages in an actor system. These methods are likely part of a base class for actors or message handlers.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic virtual void DeliverAsk(object message, Akka.Actor.ICanTell destination) { }\npublic override void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message) { }\nprotected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }\n```\n\n----------------------------------------\n\nTITLE: Provider Selection Hierarchy for Akka.NET Actor Systems (C#)\nDESCRIPTION: Abstract class hierarchy defining different actor provider types (Local, Remote, Cluster, Custom) for Akka.NET actor systems. Each provider type configures how actors are created and accessed across node boundaries.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ProviderSelection\n{\n    public sealed class Cluster : Akka.Actor.ProviderSelection\n    {\n        public static readonly Akka.Actor.ProviderSelection.Cluster Instance;\n    }\n    public sealed class Custom : Akka.Actor.ProviderSelection\n    {\n        public Custom(string fqn, string identifier = null, bool hasCluster = False) { }\n    }\n    public sealed class Local : Akka.Actor.ProviderSelection\n    {\n        public static readonly Akka.Actor.ProviderSelection.Local Instance;\n    }\n    public sealed class Remote : Akka.Actor.ProviderSelection\n    {\n        public static readonly Akka.Actor.ProviderSelection.Remote Instance;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Delete Message Class for Data Removal Operations\nDESCRIPTION: Message class used to request deletion of data from the distributed store. It contains the key of the data to delete, consistency requirements, and optional request metadata.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Delete : Akka.Actor.INoSerializationVerificationNeeded, System.IEquatable<Akka.DistributedData.Delete>\n{\n    public Delete(Akka.DistributedData.IKey key, Akka.DistributedData.IWriteConsistency consistency, object request = null) { }\n    public Akka.DistributedData.IWriteConsistency Consistency { get; }\n    public Akka.DistributedData.IKey Key { get; }\n    public object Request { get; }\n    public bool Equals(Akka.DistributedData.Delete other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: LeaseProvider Class Definition in C#\nDESCRIPTION: Implements the IExtension interface to provide lease functionality as an Akka extension. Allows getting lease instances with specified configuration and ownership information.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class LeaseProvider : Akka.Actor.IExtension\n{\n    public LeaseProvider(Akka.Actor.ExtendedActorSystem system) { }\n    public static Akka.Configuration.Config DefaultConfig() { }\n    public static Akka.Coordination.LeaseProvider Get(Akka.Actor.ActorSystem system) { }\n    public Akka.Coordination.Lease GetLease(string leaseName, string configPath, string ownerName) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BlackHoleActor in C#\nDESCRIPTION: Defines the BlackHoleActor class which extends ActorBase. This actor implementation discards all received messages, acting as a 'black hole' in the actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\npublic class BlackHoleActor : Akka.Actor.ActorBase\n{\n    public BlackHoleActor() { }\n    public static Akka.Actor.Props Props { get; }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Mailbox Class in C#\nDESCRIPTION: This class implements the IRunnable interface and represents a mailbox in Akka.NET. It includes methods for cleaning up, debugging, running, and setting the actor associated with the mailbox.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_101\n\nLANGUAGE: C#\nCODE:\n```\npublic class Mailbox : Akka.Dispatch.IRunnable\n{\n    public Mailbox(Akka.Dispatch.MessageQueues.IMessageQueue messageQueue) { }\n    public Akka.Dispatch.MessageDispatcher Dispatcher { get; }\n    public Akka.Dispatch.MessageQueues.IMessageQueue MessageQueue { get; }\n    public virtual void CleanUp() { }\n    [System.Diagnostics.ConditionalAttribute(\"MAILBOXDEBUG\")]\n    public static void DebugPrint(string message, params object[] args) { }\n    public void Run() { }\n    public virtual void SetActor(Akka.Actor.ActorCell actorCell) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NotFound Response Class for Distributed Data Replicator - C#\nDESCRIPTION: Definition of NotFound class that implements IGetResponse and other interfaces for Akka's distributed data replicator. This class represents a response when requested data is not found in the distributed data store, providing properties to access the key and original request.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class NotFound : Akka.Actor.INoSerializationVerificationNeeded, Akka.DistributedData.IGetResponse, Akka.DistributedData.IReplicatorMessage, System.IEquatable<Akka.DistributedData.NotFound>\n{\n    public NotFound(Akka.DistributedData.IKey key, object request) { }\n    public bool IsFailure { get; }\n    public bool IsFound { get; }\n    public bool IsSuccessful { get; }\n    public Akka.DistributedData.IKey Key { get; }\n    public object Request { get; }\n    public bool Equals(Akka.DistributedData.NotFound other) { }\n    public override bool Equals(object obj) { }\n    public T Get<T>(Akka.DistributedData.IKey<T> key)\n        where T : Akka.DistributedData.IReplicatedData { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SeveralRoutees Class in C#\nDESCRIPTION: Definition of SeveralRoutees which extends Routee to represent a collection of routees as a single routing destination. It broadcasts messages to all contained routees when sending a message.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_200\n\nLANGUAGE: C#\nCODE:\n```\npublic class SeveralRoutees : Akka.Routing.Routee\n{\n    public SeveralRoutees(Akka.Routing.Routee[] routees) { }\n    public override void Send(object message, Akka.Actor.IActorRef sender) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Actor Reference Provider Interface in C#\nDESCRIPTION: IActorRefProvider interface that defines core functionality for creating and managing actor references, including system actors and temporary actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IActorRefProvider\n{\n    Akka.Actor.IActorRef DeadLetters { get; }\n    Akka.Actor.Address DefaultAddress { get; }\n    Akka.Actor.Deployer Deployer { get; }\n    Akka.Actor.LocalActorRef Guardian { get; }\n    Akka.Actor.IActorRef IgnoreRef { get; }\n    Akka.Actor.IInternalActorRef RootGuardian { get; }\n    Akka.Actor.ActorPath RootPath { get; }\n    Akka.Serialization.Information SerializationInformation { get; }\n    Akka.Actor.Settings Settings { get; }\n    Akka.Actor.LocalActorRef SystemGuardian { get; }\n    Akka.Actor.IInternalActorRef TempContainer { get; }\n    System.Threading.Tasks.Task TerminationTask { get; }\n    Akka.Actor.IInternalActorRef ActorOf(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.Props props, Akka.Actor.IInternalActorRef supervisor, Akka.Actor.ActorPath path, bool systemService, Akka.Actor.Deploy deploy, bool lookupDeploy, bool async);\n    Akka.Actor.FutureActorRef<T> CreateFutureRef<T>(System.Threading.Tasks.TaskCompletionSource<T> tcs);\n    Akka.Actor.Address GetExternalAddressFor(Akka.Actor.Address address);\n    void Init(Akka.Actor.Internal.ActorSystemImpl system);\n    void RegisterTempActor(Akka.Actor.IInternalActorRef actorRef, Akka.Actor.ActorPath path);\n    Akka.Actor.IActorRef ResolveActorRef(string path);\n    Akka.Actor.IActorRef ResolveActorRef(Akka.Actor.ActorPath actorPath);\n    Akka.Actor.IActorRef RootGuardianAt(Akka.Actor.Address address);\n    Akka.Actor.ActorPath TempPath();\n    void UnregisterTempActor(Akka.Actor.ActorPath path);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Atomic Counter in C#\nDESCRIPTION: Defines AtomicCounter classes for thread-safe incrementing and manipulating counter values. These provide thread-safe operations on integer and long values for concurrent scenarios in the actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_263\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.Util.Internal\n{\n    public class AtomicCounter : Akka.Util.Internal.IAtomicCounter<int>\n    {\n        public AtomicCounter(int initialValue) { }\n        public AtomicCounter() { }\n        public int Current { get; }\n        public int AddAndGet(int amount) { }\n        public bool CompareAndSet(int expected, int newValue) { }\n        public int Decrement() { }\n        public int DecrementAndGet() { }\n        public int GetAndAdd(int amount) { }\n        public int GetAndDecrement() { }\n        public int GetAndIncrement() { }\n        public int GetAndSet(int value) { }\n        public int IncrementAndGet() { }\n        public int Next() { }\n        public void Reset() { }\n    }\n    public class AtomicCounterLong : Akka.Util.Internal.IAtomicCounter<long>\n    {\n        public AtomicCounterLong(long value) { }\n        public AtomicCounterLong() { }\n        public long Current { get; }\n        public long AddAndGet(long amount) { }\n        public bool CompareAndSet(long expected, long newValue) { }\n        public long DecrementAndGet() { }\n        public long GetAndAdd(long amount) { }\n        public long GetAndIncrement() { }\n        public long GetAndSet(long value) { }\n        public long IncrementAndGet() { }\n        public long Next() { }\n        public void Reset() { }\n        public override string ToString() { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Inheriting from ReceiveActor in C#\nDESCRIPTION: This code snippet demonstrates how to declare a new actor class that inherits from ReceiveActor in C#. The class is prepared to handle messages using the Receive() method but does not implement any handlers initially.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka/Util/MatchHandler/README.md#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nprivate class MyActor : ReceiveActor\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Utility Methods for Event Filtering in C#\nDESCRIPTION: This snippet shows utility methods for event filtering in Akka.NET TestKit, including methods for intercepting, muting, and handling events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\nprotected static string GetMessageString(int number) { }\nprotected T Intercept<T>(System.Func<T> func, Akka.Actor.ActorSystem system, System.Nullable<System.TimeSpan> timeout, System.Nullable<int> expectedOccurrences, Akka.TestKit.Internal.InternalEventFilterApplier.MatchedEventHandler matchedEventHandler = null, System.Threading.CancellationToken cancellationToken = null) { }\nprotected System.Threading.Tasks.Task<T> InterceptAsync<T>(System.Func<System.Threading.Tasks.Task<T>> func, Akka.Actor.ActorSystem system, System.Nullable<System.TimeSpan> timeout, System.Nullable<int> expectedOccurrences, Akka.TestKit.Internal.InternalEventFilterApplier.MatchedEventHandler matchedEventHandler = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic T Mute<T>(System.Func<T> func, System.Threading.CancellationToken cancellationToken = null) { }\npublic void Mute(System.Action action, System.Threading.CancellationToken cancellationToken = null) { }\npublic Akka.TestKit.IUnmutableFilter Mute() { }\npublic System.Threading.Tasks.Task<T> MuteAsync<T>(System.Func<System.Threading.Tasks.Task<T>> func, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.Task MuteAsync(System.Func<System.Threading.Tasks.Task> action, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.Task MuteAsync(System.Action action, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ActorSystemSetup Class in C#\nDESCRIPTION: A class for configuring actor systems during creation. Provides methods for combining and retrieving setup configurations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_66\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ActorSystemSetup\n{\n    public static readonly Akka.Actor.Setup.ActorSystemSetup Empty;\n    public Akka.Actor.Setup.ActorSystemSetup And<T>(T setup)\n        where T : Akka.Actor.Setup.Setup { }\n    public static Akka.Actor.Setup.ActorSystemSetup Create(params Akka.Actor.Setup.Setup[] setup) { }\n    public Akka.Util.Option<T> Get<T>()\n        where T : Akka.Actor.Setup.Setup { }\n    public override string ToString() { }\n    public Akka.Actor.Setup.ActorSystemSetup WithSetup<T>(T setup)\n        where T : Akka.Actor.Setup.Setup { }\n}\n```\n\n----------------------------------------\n\nTITLE: Store Operation Classes in C#\nDESCRIPTION: Classes for handling distributed store operations including failures, subscriptions, updates and timeouts.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_49\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class StoreFailure : Akka.Actor.INoSerializationVerificationNeeded, Akka.DistributedData.IDeleteResponse, Akka.DistributedData.IUpdateFailure\n{\n    public StoreFailure(Akka.DistributedData.IKey key, object request = null) { }\n    public bool AlreadyDeleted { get; }\n    public System.Exception Cause { get; }\n    public object Request { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterClientMessageSerializer in C#\nDESCRIPTION: Defines a serializer for cluster client messages extending SerializerWithStringManifest. It includes methods for binary conversion and manifest handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Core.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterClientMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public ClusterClientMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object o) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Scala Case Objects to C# Singletons\nDESCRIPTION: Shows how to convert Scala case objects into C# singleton classes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/porting-guide.md#2025-04-16_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ncase object RecoveryCompleted\n```\n\nLANGUAGE: c#\nCODE:\n```\npublic sealed class RecoveryCompleted\n{\n    public static RecoveryCompleted Instance { get; } = new RecoveryCompleted();\n    private RecoveryCompleted() {}\n}\n```\n\n----------------------------------------\n\nTITLE: MemberWeaklyUp Class Definition\nDESCRIPTION: This snippet defines a sealed class `MemberWeaklyUp` that inherits from `Akka.Cluster.ClusterEvent.MemberStatusChange`. It represents the event when a cluster member transitions to the 'WeaklyUp' state. It takes a `Akka.Cluster.Member` object in the constructor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class MemberWeaklyUp : Akka.Cluster.ClusterEvent.MemberStatusChange\n{\n    public MemberWeaklyUp(Akka.Cluster.Member member) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ProducerController Settings for Configuration\nDESCRIPTION: Settings class for configuring ProducerController behavior, including message chunking parameters and durable queue retry options.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_76\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class Settings : System.IEquatable<Akka.Delivery.ProducerController.Settings>\n{\n    public const int DefaultDeliveryBufferSize = 128;\n    public System.Nullable<int> ChunkLargeMessagesBytes { get; set; }\n    public System.TimeSpan DurableQueueRequestTimeout { get; set; }\n    public System.TimeSpan DurableQueueResendFirstInterval { get; set; }\n    public int DurableQueueRetryAttempts { get; set; }\n    public static Akka.Delivery.ProducerController.Settings Create(Akka.Actor.ActorSystem actorSystem) { }\n    public static Akka.Delivery.ProducerController.Settings Create(Akka.Configuration.Config config) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EventFilterFactory in Akka.NET TestKit\nDESCRIPTION: Defines an EventFilterFactory class with methods for creating various types of event filters used in actor system testing, including debug, error, and exception filters.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class EventFilterFactory\n{\n    public EventFilterFactory(Akka.TestKit.TestKitBase testkit) { }\n    public EventFilterFactory(Akka.TestKit.TestKitBase testkit, Akka.Actor.ActorSystem system) { }\n    public EventFilterFactory(Akka.TestKit.TestKitBase testkit, Akka.Actor.ActorSystem actorSystem, System.Collections.Generic.IReadOnlyList<Akka.TestKit.Internal.EventFilterBase> filters) { }\n    // ... (other methods)\n    public Akka.TestKit.IEventFilterApplier Debug(string message = null, string start = null, string contains = null, string source = null) { }\n    public Akka.TestKit.IEventFilterApplier Error(string message = null, string start = null, string contains = null, string source = null) { }\n    public Akka.TestKit.IEventFilterApplier Exception<TException>(string message = null, string start = null, string contains = null, string source = null)\n        where TException : System.Exception { }\n    // ... (more methods)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Graceful Stop Support for Akka.NET Actors in C#\nDESCRIPTION: Provides extension methods for gracefully stopping Akka.NET actors. These methods allow specifying a timeout and an optional stop message.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\npublic class static GracefulStopSupport\n{\n    public static System.Threading.Tasks.Task<bool> GracefulStop(this Akka.Actor.IActorRef target, System.TimeSpan timeout) { }\n    public static System.Threading.Tasks.Task<bool> GracefulStop(this Akka.Actor.IActorRef target, System.TimeSpan timeout, object stopMessage) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SplitBrainResolverSettings in C#\nDESCRIPTION: Defines settings for split-brain resolution in Akka.NET clusters. It includes constants for strategy names and properties for various resolution strategies.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SplitBrainResolverSettings\n{\n    public static readonly System.Collections.Immutable.ImmutableHashSet<string> AllStrategyNames;\n    public const string DownAllName = \"down-all\";\n    public const string KeepMajorityName = \"keep-majority\";\n    public const string KeepOldestName = \"keep-oldest\";\n    public const string LeaseMajorityName = \"lease-majority\";\n    public const string StaticQuorumName = \"static-quorum\";\n    public SplitBrainResolverSettings(Akka.Configuration.Config config) { }\n    public System.TimeSpan DownAllWhenUnstable { get; }\n    public System.TimeSpan DowningStableAfter { get; }\n    public string DowningStrategy { get; }\n    public string KeepMajorityRole { get; }\n    public Akka.Cluster.SBR.KeepOldestSettings KeepOldestSettings { get; }\n    public Akka.Cluster.SBR.LeaseMajoritySettings LeaseMajoritySettings { get; }\n    public Akka.Cluster.SBR.StaticQuorumSettings StaticQuorumSettings { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IReplicatedDeltaSize Interface in C#\nDESCRIPTION: This snippet defines the `IReplicatedDeltaSize` interface, which provides a way to determine the size of a replicated delta. It includes a `DeltaSize` property that returns an integer value representing the size of the delta.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\n    public interface IReplicatedDeltaSize\n    {\n        int DeltaSize { get; }\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Defining Actor-related Exception Classes in C#\nDESCRIPTION: These classes define various exceptions that can occur in the Akka.NET actor system, such as initialization errors, interruptions, and actor not found scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic class ActorInitializationException : Akka.Actor.AkkaException\n{\n    // ... (constructors and properties)\n}\n\npublic class ActorInterruptedException : Akka.Actor.AkkaException\n{\n    // ... (constructors)\n}\n\npublic class ActorKilledException : Akka.Actor.AkkaException\n{\n    // ... (constructors)\n}\n\npublic class ActorNotFoundException : Akka.Actor.AkkaException\n{\n    // ... (constructors)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Exceptions for Assertion Failures in C#\nDESCRIPTION: This snippet defines AkkaEqualException, a custom exception for assertion failures in Akka.NET tests. It provides constructors for format-based messages and a static method ForMismatchedValues for generating exceptions when expected and actual values do not match.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKitXunit2.Net.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic class AkkaEqualException : Xunit.Sdk.XunitException\n{\n    public AkkaEqualException(string format = \"\", params object[] args) { }\n    protected AkkaEqualException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n    [return: System.Runtime.CompilerServices.NullableAttribute(1)]\n    public static Akka.TestKit.Xunit2.Internals.AkkaEqualException ForMismatchedValues(object expected, object actual, string format = null, [System.Runtime.CompilerServices.NullableAttribute(1)] params object[] args) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing InvalidAssociationException in Akka.NET\nDESCRIPTION: Exception class for signaling invalid associations in Akka.NET remote transport. Extends AkkaException and provides constructors for creating with a message and optional cause, plus serialization support.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic class InvalidAssociationException : Akka.Actor.AkkaException\n{\n    public InvalidAssociationException(string message, System.Exception cause = null) { }\n    protected InvalidAssociationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MetricsGossipEnvelope in C# for Akka.NET\nDESCRIPTION: Defines a sealed class for encapsulating metrics gossip messages. It implements interfaces for cluster metric messages, dead letter suppression, deep cloning, and message handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Core.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class MetricsGossipEnvelope : Akka.Cluster.Metrics.Serialization.IClusterMetricMessage, Akka.Event.IDeadLetterSuppression, Google.Protobuf.IDeepCloneable<Akka.Cluster.Metrics.Serialization.MetricsGossipEnvelope>, Google.Protobuf.IMessage, Google.Protobuf.IMessage<Akka.Cluster.Metrics.Serialization.MetricsGossipEnvelope>, System.IEquatable<Akka.Cluster.Metrics.Serialization.MetricsGossipEnvelope>\n{\n    public const int FromFieldNumber = 1;\n    public const int GossipFieldNumber = 2;\n    public const int ReplyFieldNumber = 3;\n    public MetricsGossipEnvelope(Akka.Actor.Address fromAddress, Akka.Cluster.Metrics.Serialization.MetricsGossip gossip, bool reply) { }\n    public MetricsGossipEnvelope() { }\n    public MetricsGossipEnvelope(Akka.Cluster.Metrics.Serialization.MetricsGossipEnvelope other) { }\n    public static Google.Protobuf.Reflection.MessageDescriptor Descriptor { get; }\n    public Akka.Cluster.Metrics.Serialization.AddressData From { get; set; }\n    public Akka.Actor.Address FromAddress { get; }\n    public Akka.Cluster.Metrics.Serialization.MetricsGossip Gossip { get; set; }\n    public static Google.Protobuf.MessageParser<Akka.Cluster.Metrics.Serialization.MetricsGossipEnvelope> Parser { get; }\n    public bool Reply { get; set; }\n    public int CalculateSize() { }\n    public Akka.Cluster.Metrics.Serialization.MetricsGossipEnvelope Clone() { }\n    public override bool Equals(object other) { }\n    public bool Equals(Akka.Cluster.Metrics.Serialization.MetricsGossipEnvelope other) { }\n    public override int GetHashCode() { }\n    public void MergeFrom(Akka.Cluster.Metrics.Serialization.MetricsGossipEnvelope other) { }\n    public void MergeFrom(Google.Protobuf.CodedInputStream input) { }\n    public override string ToString() { }\n    public void WriteTo(Google.Protobuf.CodedOutputStream output) { }\n}\n```\n\n----------------------------------------\n\nTITLE: PNCounter Dictionary Key Implementation in C#\nDESCRIPTION: Generic class for managing PN-Counter dictionary keys in distributed data systems. Extends from Akka.DistributedData.Key.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\npublic class PNCounterDictionaryKey<T> : Akka.DistributedData.Key<Akka.DistributedData.PNCounterDictionary<T>>\n{\n    public PNCounterDictionaryKey(string id) { }\n    public System.Type KeyType { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PersistentFSMBase Abstract Class in C#\nDESCRIPTION: Base class for persistent finite state machines that extends PersistentActor. Provides core FSM functionality like state transitions, timers, and event handling with persistence capabilities.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class PersistentFSMBase<TState, TData, TEvent> : Akka.Persistence.PersistentActor, Akka.Routing.IListeners\n{\n    protected PersistentFSMBase() { }\n    public Akka.Routing.ListenerSupport Listeners { get; }\n    public TData NextStateData { get; }\n    public TData StateData { get; }\n    public TState StateName { get; }\n    protected System.Collections.Generic.IEnumerable<TState> StateNames { get; }\n    protected virtual void ApplyState(Akka.Persistence.Fsm.PersistentFSM.State<TState, TData, TEvent> nextState) { }\n    public void CancelTimer(string name) { }\n    public Akka.Persistence.Fsm.PersistentFSM.State<TState, TData, TEvent> GoTo(TState nextStateName) { }\n    public bool IsTimerActive(string name) { }\n    protected virtual void LogTermination(Akka.Actor.FSMBase.Reason reason) { }\n    public void OnTermination(System.Action<Akka.Actor.FSMBase.StopEvent<TState, TData>> terminationHandler) { }\n    public void OnTransition(Akka.Persistence.Fsm.PersistentFSMBase<TState, TData, TEvent>.TransitionHandler transitionHandler) { }\n    protected override void PostStop() { }\n    protected override bool ReceiveCommand(object message) { }\n    public void SetStateTimeout(TState state, System.Nullable<System.TimeSpan> timeout) { }\n    public void SetTimer(string name, object msg, System.TimeSpan timeout, bool repeat = False) { }\n    public void StartWith(TState stateName, TData stateData, System.Nullable<System.TimeSpan> timeout = null) { }\n    public Akka.Persistence.Fsm.PersistentFSM.State<TState, TData, TEvent> Stay() { }\n    public Akka.Persistence.Fsm.PersistentFSM.State<TState, TData, TEvent> Stop() { }\n    public Akka.Persistence.Fsm.PersistentFSM.State<TState, TData, TEvent> Stop(Akka.Actor.FSMBase.Reason reason) { }\n    public Akka.Persistence.Fsm.PersistentFSM.State<TState, TData, TEvent> Stop(Akka.Actor.FSMBase.Reason reason, TData stateData) { }\n    public Akka.Persistence.Fsm.PersistentFSMBase<TState, TData, TEvent>.TransformHelper Transform(Akka.Persistence.Fsm.PersistentFSMBase<TState, TData, TEvent>.StateFunction func) { }\n    public void When(TState stateName, Akka.Persistence.Fsm.PersistentFSMBase<TState, TData, TEvent>.StateFunction func, System.Nullable<System.TimeSpan> timeout = null) { }\n    public void WhenUnhandled(Akka.Persistence.Fsm.PersistentFSMBase<TState, TData, TEvent>.StateFunction stateFunction) { }\n    public delegate Akka.Persistence.Fsm.PersistentFSM.State<TState, TData, TEvent> StateFunction<TState, TData, TEvent>(Akka.Actor.FSMBase.Event<TData> fsmEvent, Akka.Persistence.Fsm.PersistentFSM.State<TState, TData, TEvent> state = null);\n    public sealed class TransformHelper<TState, TData, TEvent>\n    {\n        public TransformHelper(Akka.Persistence.Fsm.PersistentFSMBase<TState, TData, TEvent>.StateFunction func) { }\n        public Akka.Persistence.Fsm.PersistentFSMBase<TState, TData, TEvent>.StateFunction Func { get; }\n        public Akka.Persistence.Fsm.PersistentFSMBase<TState, TData, TEvent>.StateFunction Using(System.Func<Akka.Persistence.Fsm.PersistentFSM.State<TState, TData, TEvent>, Akka.Persistence.Fsm.PersistentFSM.State<TState, TData, TEvent>> andThen) { }\n    }\n    public delegate void TransitionHandler<TState, TData, TEvent>(TState initialState, TState nextState);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract MessageDispatcherConfigurator Class in C#\nDESCRIPTION: Abstract base class for configuring message dispatchers in Akka.NET. Provides access to configuration settings and dispatcher prerequisites, with concrete implementations creating specific dispatcher types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_97\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class MessageDispatcherConfigurator\n{\n    protected MessageDispatcherConfigurator(Akka.Configuration.Config config, Akka.Dispatch.IDispatcherPrerequisites prerequisites) { }\n    public Akka.Configuration.Config Config { get; }\n    public Akka.Dispatch.IDispatcherPrerequisites Prerequisites { get; }\n    protected Akka.Dispatch.ExecutorServiceConfigurator ConfigureExecutor() { }\n    public abstract Akka.Dispatch.MessageDispatcher Dispatcher();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DeleteSnapshots Class in C#\nDESCRIPTION: This snippet defines the DeleteSnapshots class, which represents a request to delete one or more snapshots based on specified criteria and persistence ID. The class also implements equality methods and various interface contracts.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class DeleteSnapshots : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage, Akka.Persistence.ISnapshotRequest, System.IEquatable<Akka.Persistence.DeleteSnapshots>\n{\n    public DeleteSnapshots(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria) { }\n    public Akka.Persistence.SnapshotSelectionCriteria Criteria { get; }\n    public string PersistenceId { get; }\n    public bool Equals(Akka.Persistence.DeleteSnapshots other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PNCounter Class in C#\nDESCRIPTION: This class represents a distributed counter (PNCounter) in Akka.NET, supporting increments and decrements across distributed nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class PNCounter : Akka.DistributedData.IDeltaReplicatedData, Akka.DistributedData.IDeltaReplicatedData<Akka.DistributedData.PNCounter, Akka.DistributedData.PNCounter>, Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IRemovedNodePruning<Akka.DistributedData.PNCounter>, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.PNCounter>, Akka.DistributedData.IReplicatedDelta, System.IEquatable<Akka.DistributedData.PNCounter>\n{\n    // ... (properties and methods omitted for brevity)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UdpConnected NoAck Event in Akka.NET\nDESCRIPTION: Event indicating no acknowledgment was received for a sent message. Contains an optional token for identifying which message wasn't acknowledged.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_181\n\nLANGUAGE: C#\nCODE:\n```\npublic class NoAck : Akka.IO.UdpConnected.Event\n{\n    public static readonly Akka.IO.UdpConnected.NoAck Instance;\n    public NoAck(object token) { }\n    public object Token { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Akka.NET Metrics Serialization and Routing\nDESCRIPTION: Configuration for metrics serialization and routing including serializer bindings and router type mappings. Defines how metrics messages are serialized for network transmission and how routing decisions are made based on metrics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-metrics.md#2025-04-16_snippet_10\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor {\n  serializers {\n    akka-cluster-metrics = \"Akka.Cluster.Metrics.Serialization.ClusterMetricsMessageSerializer, Akka.Cluster.Metrics\"\n  }\n  serialization-bindings {\n    \"Akka.Cluster.Metrics.Serialization.MetricsGossipEnvelope, Akka.Cluster.Metrics\" = akka-cluster-metrics\n    \"Akka.Cluster.Metrics.AdaptiveLoadBalancingPool, Akka.Cluster.Metrics\" = akka-cluster-metrics\n    \"Akka.Cluster.Metrics.MixMetricsSelector, Akka.Cluster.Metrics\" = akka-cluster-metrics\n    \"Akka.Cluster.Metrics.CpuMetricsSelector, Akka.Cluster.Metrics\" = akka-cluster-metrics\n    \"Akka.Cluster.Metrics.MemoryMetricsSelector, Akka.Cluster.Metrics\" = akka-cluster-metrics\n  }\n  serialization-identifiers {\n    \"Akka.Cluster.Metrics.Serialization.ClusterMetricsMessageSerializer, Akka.Cluster.Metrics\" = 10\n  }\n  router.type-mapping {\n    cluster-metrics-adaptive-pool = \"Akka.Cluster.Metrics.AdaptiveLoadBalancingPool, Akka.Cluster.Metrics\"\n    cluster-metrics-adaptive-group = \"Akka.Cluster.Metrics.AdaptiveLoadBalancingGroup, Akka.Cluster.Metrics\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterSharding Class for Actor Management in Akka.NET\nDESCRIPTION: The ClusterSharding class implements the IExtension interface and provides methods for starting and managing sharded actors in an Akka.NET cluster. It includes multiple overloads for starting shard regions and proxies with various configuration options.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.Cluster.Sharding\n{\n    [System.Runtime.CompilerServices.NullableAttribute(0)]\n    public class ClusterSharding : Akka.Actor.IExtension\n    {\n        public ClusterSharding(Akka.Actor.ExtendedActorSystem system) { }\n        [Akka.Annotations.InternalApiAttribute()]\n        public Akka.Cluster.Sharding.IShardingBufferMessageAdapter BufferMessageAdapter { get; }\n        public Akka.Cluster.Sharding.ClusterShardingSettings Settings { get; }\n        public System.Collections.Immutable.ImmutableHashSet<string> ShardTypeNames { get; }\n        public static Akka.Configuration.Config DefaultConfig() { }\n        public Akka.Cluster.Sharding.IShardAllocationStrategy DefaultShardAllocationStrategy(Akka.Cluster.Sharding.ClusterShardingSettings settings) { }\n        public static Akka.Cluster.Sharding.ClusterSharding Get(Akka.Actor.ActorSystem system) { }\n        [Akka.Annotations.InternalApiAttribute()]\n        public void SetShardingBufferMessageAdapter(Akka.Cluster.Sharding.IShardingBufferMessageAdapter bufferMessageAdapter) { }\n        public Akka.Actor.IActorRef ShardRegion(string typeName) { }\n        public Akka.Actor.IActorRef ShardRegionProxy(string typeName) { }\n        [System.ObsoleteAttribute(\"Use one of the overloads that accepts an IMessageExtractor instead\")]\n        public Akka.Actor.IActorRef Start(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n        [System.ObsoleteAttribute(\"Use one of the overloads that accepts an IMessageExtractor instead\")]\n        public Akka.Actor.IActorRef Start(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n        public Akka.Actor.IActorRef Start(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n        public Akka.Actor.IActorRef Start(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n        [System.ObsoleteAttribute(\"Use one of the overloads that accepts an IMessageExtractor instead\")]\n        public Akka.Actor.IActorRef Start(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n        [System.ObsoleteAttribute(\"Use one of the overloads that accepts an IMessageExtractor instead\")]\n        public Akka.Actor.IActorRef Start(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n        public Akka.Actor.IActorRef Start(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n        public Akka.Actor.IActorRef Start(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n        [System.ObsoleteAttribute(\"Use one of the overloads that accepts an IMessageExtractor instead\")]\n        public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n        [System.ObsoleteAttribute(\"Use one of the overloads that accepts an IMessageExtractor instead\")]\n        public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n        public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n        public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, Akka.Actor.Props entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n        [System.ObsoleteAttribute(\"Use one of the overloads that accepts an IMessageExtractor instead\")]\n        public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n        [System.ObsoleteAttribute(\"Use one of the overloads that accepts an IMessageExtractor instead\")]\n        public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n        public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor, Akka.Cluster.Sharding.IShardAllocationStrategy allocationStrategy, object handOffStopMessage) { }\n        public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartAsync(string typeName, System.Func<string, Akka.Actor.Props> entityPropsFactory, Akka.Cluster.Sharding.ClusterShardingSettings settings, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n        [System.ObsoleteAttribute(\"Use one of the overloads that accepts an IMessageExtractor instead\")]\n        public Akka.Actor.IActorRef StartProxy(string typeName, string role, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n        public Akka.Actor.IActorRef StartProxy(string typeName, string role, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n        [System.ObsoleteAttribute(\"Use one of the overloads that accepts an IMessageExtractor instead\")]\n        public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartProxyAsync(string typeName, string role, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId) { }\n        public System.Threading.Tasks.Task<Akka.Actor.IActorRef> StartProxyAsync(string typeName, string role, Akka.Cluster.Sharding.IMessageExtractor messageExtractor) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining IMightBeAHoconObject Interface in C#\nDESCRIPTION: The IMightBeAHoconObject interface extends the capabilities of HOCON elements to possibly represent objects. It provides methods to check if an element is an object and to retrieve it as an object.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_73\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IMightBeAHoconObject\n{\n    Akka.Configuration.Hocon.HoconObject GetObject();\n    bool IsObject();\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly Attributes Declaration for Akka.NET Cluster Sharding in C#\nDESCRIPTION: Defines assembly-level attributes for the Akka.NET Cluster Sharding module, including repository URL, internals visibility to test projects, and framework targeting information.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Net.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Benchmarks\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding.Tests.MultiNode\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.DistributedData.Tests\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"a05c31e8-0246-46a1-b3bc-4d6fe7a9aa49\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: ConsumerController Message Classes in C#\nDESCRIPTION: Message classes used by the ConsumerController for reliable delivery, including confirmation messages, delivery messages, and controller registration commands.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_85\n\nLANGUAGE: C#\nCODE:\n```\n    public sealed class Confirmed\n    {\n        [System.Runtime.CompilerServices.NullableAttribute(1)]\n        public static readonly Akka.Delivery.ConsumerController.Confirmed Instance;\n    }\n    public sealed class DeliverThenStop<[System.Runtime.CompilerServices.NullableAttribute(2)]  T> : Akka.Delivery.ConsumerController.IConsumerCommand<T>\n    {\n        [System.Runtime.CompilerServices.NullableAttribute(1)]\n        public static readonly Akka.Delivery.ConsumerController.DeliverThenStop<T> Instance;\n    }\n    [System.Runtime.CompilerServices.NullableAttribute(0)]\n    public sealed class Delivery<[System.Runtime.CompilerServices.NullableAttribute(2)]  T> : Akka.Delivery.ConsumerController.IConsumerCommand<T>, Akka.Delivery.Internal.IDeliverySerializable, Akka.Event.IDeadLetterSuppression, System.IEquatable<Akka.Delivery.ConsumerController.Delivery<T>>\n    {\n        public Delivery(T Message, Akka.Actor.IActorRef ConfirmTo, string ProducerId, long SeqNr) { }\n        public Akka.Actor.IActorRef ConfirmTo { get; set; }\n        public T Message { get; set; }\n        public string ProducerId { get; set; }\n        public long SeqNr { get; set; }\n        public override string ToString() { }\n    }\n    public interface IConsumerCommand<T> { }\n    [System.Runtime.CompilerServices.NullableAttribute(0)]\n    public sealed class RegisterToProducerController<[System.Runtime.CompilerServices.NullableAttribute(2)]  T> : Akka.Delivery.ConsumerController.IConsumerCommand<T>\n    {\n        public RegisterToProducerController(Akka.Actor.IActorRef producerController) { }\n        public Akka.Actor.IActorRef ProducerController { get; }\n    }\n    [Akka.Annotations.InternalApiAttribute()]\n    [System.Runtime.CompilerServices.NullableAttribute(0)]\n    public sealed class SequencedMessage<[System.Runtime.CompilerServices.NullableAttribute(2)]  T> : Akka.Delivery.ConsumerController.IConsumerCommand<T>, Akka.Delivery.Internal.IDeliverySerializable, Akka.Event.IDeadLetterSuppression, System.IEquatable<Akka.Delivery.ConsumerController.SequencedMessage<T>>\n    {\n        public SequencedMessage(string ProducerId, long SeqNr, [System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n                0,\n                1})] Akka.Delivery.Internal.MessageOrChunk<T> Message, bool First, bool Ack) { }\n        public bool Ack { get; set; }\n        public bool First { get; set; }\n        [System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n                0,\n                1})]\n        public Akka.Delivery.Internal.MessageOrChunk<T> Message { get; set; }\n        public string ProducerId { get; set; }\n        public long SeqNr { get; set; }\n        public bool Equals([System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n                2,\n                1})] Akka.Delivery.ConsumerController.SequencedMessage<T> other) { }\n        public override int GetHashCode() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: TestFSMRef Generic Class Implementation in C#\nDESCRIPTION: Test reference class for Finite State Machine actors with support for state management and timing operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestFSMRef<TActor, TState, TData> : Akka.TestKit.TestActorRefBase<TActor>\n    where TActor : Akka.Actor.FSM<TState, TData>\n{\n    public TestFSMRef(Akka.Actor.ActorSystem system, Akka.Actor.Props props, Akka.Actor.IActorRef supervisor = null, string name = null, bool activateLogging = False) { }\n    public TData StateData { get; }\n    public TState StateName { get; }\n    public void CancelTimer(string name) { }\n    public bool IsStateTimerActive() { }\n    public bool IsTimerActive(string name) { }\n    public void SetState(TState stateName, System.Nullable<System.TimeSpan> timeout = null) { }\n    public void SetState(TState stateName, TData stateData, System.Nullable<System.TimeSpan> timeout = null, Akka.Actor.FSMBase.Reason stopReason = null) { }\n    public void SetStateData(TData stateData, System.Nullable<System.TimeSpan> timeout = null) { }\n    public void SetStateTimeout(System.TimeSpan timeout) { }\n    public void SetTimer(string name, object msg, System.TimeSpan timeout, bool repeat = False) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TaskSchedulerPriority Enum in C#\nDESCRIPTION: Enumeration for task scheduler priorities, ranging from Idle to Realtime. Used to set the execution priority of tasks in the Akka.NET dispatcher system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_100\n\nLANGUAGE: C#\nCODE:\n```\npublic enum TaskSchedulerPriority\n{\n    None = 0,\n    Idle = 4,\n    Background = 4,\n    Low = 5,\n    BelowNormal = 6,\n    Normal = 8,\n    AboveNormal = 10,\n    High = 13,\n    Realtime = 24,\n}\n```\n\n----------------------------------------\n\nTITLE: FSM Termination Handler in C#\nDESCRIPTION: Demonstrates how to implement a termination handler that processes different stop event scenarios including Normal, Shutdown, and Failure cases.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/finite-state-machine.md#2025-04-16_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\nOnTermination(termination =>\n{\n    switch (termination)\n    {\n        case StopEvent<State, IData> st when st.Reason is Normal:\n            // ...\n            break;\n        case StopEvent<State, IData> st when st.Reason is Shutdown:\n            // ...\n            break;\n        case StopEvent<State, IData> st when st.Reason is Failure:\n            // ...\n            break;\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Require Implementation in C#\nDESCRIPTION: This C# code uses an `if` statement to check a condition and throws an `ArgumentException` if the condition is not met, mirroring the behavior of Scala's `require` function.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/porting-guide.md#2025-04-16_snippet_19\n\nLANGUAGE: c#\nCODE:\n```\nif (cost <= 0) throw new ArgumentException(\"cost must be > 0\", nameof(cost));\n```\n\n----------------------------------------\n\nTITLE: Abstract ActorEventBus Class in Akka.NET\nDESCRIPTION: Abstract base class for actor event buses that extends the generic EventBus with actor references as subscribers. Provides a foundation for building event buses where actors subscribe to specific event types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_114\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class ActorEventBus<TEvent, TClassifier> : Akka.Event.EventBus<TEvent, TClassifier, Akka.Actor.IActorRef>\n{\n    protected ActorEventBus() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Cluster Interfaces in C#\nDESCRIPTION: Defines key interfaces for cluster functionality including IClusterActorRefProvider, IClusterMessage, and IDowningProvider. These interfaces establish the contract for core cluster components.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.DotNet.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic interface IClusterActorRefProvider : Akka.Actor.IActorRefProvider, Akka.Remote.IRemoteActorRefProvider { }\npublic interface IClusterMessage { }\npublic interface IDowningProvider\n{\n    System.TimeSpan DownRemovalMargin { get; }\n    Akka.Actor.Props DowningActorProps { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SuspendReason Abstract Class with Nested Types in C#\nDESCRIPTION: Class hierarchy for representing reasons why an actor might be suspended, including Creation, Recreation, Termination, and UserRequest subclasses.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_60\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class SuspendReason\n{\n    protected SuspendReason() { }\n    public class Creation : Akka.Actor.Internal.SuspendReason, Akka.Actor.Internal.SuspendReason.IWaitingForChildren\n    {\n        public Creation() { }\n    }\n    public interface IWaitingForChildren { }\n    public class Recreation : Akka.Actor.Internal.SuspendReason, Akka.Actor.Internal.SuspendReason.IWaitingForChildren\n    {\n        public Recreation(System.Exception cause) { }\n        public System.Exception Cause { get; }\n    }\n    public class Termination : Akka.Actor.Internal.SuspendReason\n    {\n        public static Akka.Actor.Internal.SuspendReason.Termination Instance { get; }\n    }\n    public class UserRequest : Akka.Actor.Internal.SuspendReason\n    {\n        public static Akka.Actor.Internal.SuspendReason.UserRequest Instance { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using HOCON Configuration in App.config for Akka.NET\nDESCRIPTION: Example of embedding HOCON configuration within an App.config file, showing how to configure various Akka.NET settings including logging and network transport.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/config.md#2025-04-16_snippet_3\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <configSections>\n    <section name=\"akka\" type=\"Akka.Configuration.Hocon.AkkaConfigurationSection, Akka\" />\n  </configSections>\n\n  <akka>\n    <hocon>\n      <![CDATA[\n          akka {\n            # here we are configuring log levels\n            log-config-on-start = off\n            stdout-loglevel = INFO\n            loglevel = ERROR\n            # this config section will be referenced as akka.actor\n            actor {\n              provider = remote\n              debug {\n                  receive = on\n                  autoreceive = on\n                  lifecycle = on\n                  event-stream = on\n                  unhandled = on\n              }\n            }\n            # here we're configuring the Akka.Remote module\n            remote {\n              dot-netty.tcp {\n                  transport-class = \"Akka.Remote.Transport.DotNetty.TcpTransport, Akka.Remote\"\n                  #applied-adapters = []\n                  transport-protocol = tcp\n                  port = 8091\n                  hostname = \"127.0.0.1\"\n              }\n            log-remote-lifecycle-events = INFO\n          }\n      ]]>\n    </hocon>\n  </akka>\n</configuration>\n```\n\n----------------------------------------\n\nTITLE: Defining AsyncReplayTimeoutException Class in C#\nDESCRIPTION: Exception class thrown when asynchronous replay operations time out during persistence recovery. Extends the AkkaException base class.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\npublic class AsyncReplayTimeoutException : Akka.Actor.AkkaException\n{\n    public AsyncReplayTimeoutException() { }\n    public AsyncReplayTimeoutException(string message) { }\n    protected AsyncReplayTimeoutException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AppVersion Class in C#\nDESCRIPTION: A utility class for version comparison that implements IComparable and IEquatable interfaces. Used for semantic version checks throughout the Akka.NET framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_229\n\nLANGUAGE: C#\nCODE:\n```\npublic class AppVersion : System.IComparable<Akka.Util.AppVersion>, System.IEquatable<Akka.Util.AppVersion>\n{\n    public static readonly Akka.Util.AppVersion Zero;\n    public string Version { get; }\n    public int CompareTo(Akka.Util.AppVersion other) { }\n    public static Akka.Util.AppVersion Create(string version) { }\n    public bool Equals(Akka.Util.AppVersion other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n    public static bool ==(Akka.Util.AppVersion first, Akka.Util.AppVersion second) { }\n    public static bool !=(Akka.Util.AppVersion first, Akka.Util.AppVersion second) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DistributedPubSubMessageSerializer in C#\nDESCRIPTION: Defines a serializer for distributed pub-sub messages. It extends SerializerWithStringManifest to handle serialization of pub-sub related messages in the Akka.NET cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic class DistributedPubSubMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public DistributedPubSubMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AsyncWriteProxy in C#\nDESCRIPTION: Defines the AsyncWriteProxy class that extends AsyncWriteJournal and implements various actor interfaces. This class serves as a proxy for asynchronous journal operations, managing timeouts and message stashing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_53\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AsyncWriteProxy : Akka.Persistence.Journal.AsyncWriteJournal, Akka.Actor.IActorStash, Akka.Actor.IWithUnboundedStash, Akka.Actor.IWithUnrestrictedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics>\n{\n    protected AsyncWriteProxy() { }\n    public Akka.Actor.IStash Stash { get; set; }\n    public abstract System.TimeSpan Timeout { get; }\n    public override void AroundPreStart() { }\n    protected override bool AroundReceive(Akka.Actor.Receive receive, object message) { }\n    protected override System.Threading.Tasks.Task DeleteMessagesToAsync(string persistenceId, long toSequenceNr) { }\n    public override System.Threading.Tasks.Task<long> ReadHighestSequenceNrAsync(string persistenceId, long fromSequenceNr) { }\n    public override System.Threading.Tasks.Task ReplayMessagesAsync(Akka.Actor.IActorContext context, string persistenceId, long fromSequenceNr, long toSequenceNr, long max, System.Action<Akka.Persistence.IPersistentRepresentation> recoveryCallback) { }\n    protected override System.Threading.Tasks.Task<System.Collections.Immutable.IImmutableList<System.Exception>> WriteMessagesAsync(System.Collections.Generic.IEnumerable<Akka.Persistence.AtomicWrite> messages) { }\n    public class InitTimeout\n    {\n        public static Akka.Persistence.Journal.AsyncWriteProxy.InitTimeout Instance { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ClusterClients and ClusterReceptionist Classes in C#\nDESCRIPTION: Classes that handle collections of cluster clients and implement the receptionist component that receives and routes client requests. ClusterReceptionist is the actor that manages client connectivity.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Core.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterClients\n{\n    public ClusterClients(System.Collections.Immutable.IImmutableSet<Akka.Actor.IActorRef> clusterClientsList) { }\n    public System.Collections.Immutable.IImmutableSet<Akka.Actor.IActorRef> ClusterClientsList { get; }\n}\n\npublic sealed class ClusterReceptionist : Akka.Actor.ActorBase\n{\n    public ClusterReceptionist(Akka.Actor.IActorRef pubSubMediator, Akka.Cluster.Tools.Client.ClusterReceptionistSettings settings) { }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n    public static Akka.Actor.Props Props(Akka.Actor.IActorRef pubSubMediator, Akka.Cluster.Tools.Client.ClusterReceptionistSettings settings) { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DefaultCollector Class in C#\nDESCRIPTION: Default implementation of the IMetricsCollector interface. Collects metrics from a node in an Akka cluster and implements IDisposable for proper resource cleanup.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.DotNet.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic class DefaultCollector : Akka.Cluster.Metrics.IMetricsCollector, System.IDisposable\n{\n    public DefaultCollector(Akka.Actor.Address address) { }\n    public DefaultCollector(Akka.Actor.ActorSystem system) { }\n    public void Dispose() { }\n    public Akka.Cluster.Metrics.Serialization.NodeMetrics Sample() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Executor Service Components in C#\nDESCRIPTION: Abstract executor service classes for Akka.NET that define the interface for executing runnables. These components include ExecutorService, ExecutorServiceConfigurator, and ExecutorServiceFactory, which provide the foundation for task execution infrastructure.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_87\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class ExecutorService\n{\n    protected ExecutorService(string id) { }\n    public string Id { get; }\n    public abstract void Execute(Akka.Dispatch.IRunnable run);\n    public abstract void Shutdown();\n}\n\n[Akka.Annotations.InternalApiAttribute()]\npublic abstract class ExecutorServiceConfigurator : Akka.Dispatch.ExecutorServiceFactory\n{\n    protected ExecutorServiceConfigurator(Akka.Configuration.Config config, Akka.Dispatch.IDispatcherPrerequisites prerequisites) { }\n    public Akka.Configuration.Config Config { get; }\n    public Akka.Dispatch.IDispatcherPrerequisites Prerequisites { get; }\n}\n\n[Akka.Annotations.InternalApiAttribute()]\npublic abstract class ExecutorServiceFactory\n{\n    protected ExecutorServiceFactory() { }\n    public abstract Akka.Dispatch.ExecutorService Produce(string id);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Resume System Message in Akka.NET\nDESCRIPTION: Defines a system message that instructs an actor to resume after suspension. Can include information about the failure that caused the suspension.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_124\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Resume : Akka.Dispatch.SysMsg.SystemMessage\n{\n    public Resume(System.Exception causedByFailure) { }\n    public System.Exception CausedByFailure { get; set; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HOCON TokenType Enum in C#\nDESCRIPTION: The TokenType enum defines the possible types of tokens in HOCON configuration syntax. It includes values for structural elements like object start/end, array start/end, as well as content elements like keys, values, and comments.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_76\n\nLANGUAGE: C#\nCODE:\n```\npublic enum TokenType\n{\n    Comment = 0,\n    Key = 1,\n    LiteralValue = 2,\n    Assign = 3,\n    ObjectStart = 4,\n    ObjectEnd = 5,\n    Dot = 6,\n    EoF = 7,\n    ArrayStart = 8,\n    ArrayEnd = 9,\n    Comma = 10,\n    Substitute = 11,\n    Include = 12,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LogSource struct for Akka.NET logging\nDESCRIPTION: The LogSource struct provides methods to create standardized log sources from various input types, including objects, ActorRef, and Type objects. This struct manages creating consistent logging identifiers.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_142\n\nLANGUAGE: C#\nCODE:\n```\npublic struct LogSource\n{\n    public string Source { get; }\n    public System.Type Type { get; }\n    public static Akka.Event.LogSource Create(object o) { }\n    public static Akka.Event.LogSource Create(object o, Akka.Actor.ActorSystem system) { }\n    public static Akka.Event.LogSource Create(string source, System.Type t) { }\n    public static string FromActor(Akka.Actor.IActorContext actor, Akka.Actor.ActorSystem system) { }\n    public static string FromActorRef(Akka.Actor.IActorRef a, Akka.Actor.ActorSystem system) { }\n    public static string FromString(string source, Akka.Actor.ActorSystem system) { }\n    public static string FromType(System.Type t, Akka.Actor.ActorSystem system) { }\n    public static System.Type SourceType(object o) { }\n}\n```\n\n----------------------------------------\n\nTITLE: HOCON Configuration Elements\nDESCRIPTION: Classes implementing HOCON (Human-Optimized Config Object Notation) configuration format including arrays, objects, and literals.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_67\n\nLANGUAGE: C#\nCODE:\n```\npublic class HoconArray : System.Collections.Generic.List<Akka.Configuration.Hocon.HoconValue>, Akka.Configuration.Hocon.IHoconElement\n{\n    public HoconArray() { }\n    public System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray() { }\n    public string GetString() { }\n    public bool IsArray() { }\n    public bool IsString() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterClient Class in Akka.NET\nDESCRIPTION: Definition of the ClusterClient class which allows sending messages to an Akka Cluster from external systems. It includes nested classes for different message patterns: Send for point-to-point messaging, SendToAll for broadcasting, and Publish for pub/sub communication.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Net.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterClient : Akka.Actor.ActorBase\n{\n    public ClusterClient(Akka.Cluster.Tools.Client.ClusterClientSettings settings) { }\n    protected override void PostStop() { }\n    public static Akka.Actor.Props Props(Akka.Cluster.Tools.Client.ClusterClientSettings settings) { }\n    protected override bool Receive(object message) { }\n    public sealed class Publish : Akka.Cluster.Tools.Client.IClusterClientProtocolMessage, System.IEquatable<Akka.Cluster.Tools.Client.ClusterClient.Publish>\n    {\n        public Publish(string topic, object message) { }\n        public object Message { get; }\n        public string Topic { get; }\n        public bool Equals(Akka.Cluster.Tools.Client.ClusterClient.Publish other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n    }\n    public sealed class Send : Akka.Cluster.Tools.Client.IClusterClientProtocolMessage, System.IEquatable<Akka.Cluster.Tools.Client.ClusterClient.Send>\n    {\n        public Send(string path, object message, bool localAffinity = False) { }\n        public bool LocalAffinity { get; }\n        public object Message { get; }\n        public string Path { get; }\n        public bool Equals(Akka.Cluster.Tools.Client.ClusterClient.Send other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n    }\n    public sealed class SendToAll : Akka.Cluster.Tools.Client.IClusterClientProtocolMessage, System.IEquatable<Akka.Cluster.Tools.Client.ClusterClient.SendToAll>\n    {\n        public SendToAll(string path, object message) { }\n        public object Message { get; }\n        public string Path { get; }\n        public bool Equals(Akka.Cluster.Tools.Client.ClusterClient.SendToAll other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IInitializableActor Interface in C#\nDESCRIPTION: This interface defines a single method 'Init()' for actors that require initialization. It's part of the actor lifecycle management in Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_60\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IInitializableActor\n{\n    void Init();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CurrentTopics class for DistributedPubSub in C#\nDESCRIPTION: Implements a sealed class to represent current topics in a distributed publish-subscribe system. It includes equality comparisons and overrides for standard object methods.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class CurrentTopics : System.IEquatable<Akka.Cluster.Tools.PublishSubscribe.CurrentTopics>\n{\n    public CurrentTopics(System.Collections.Immutable.IImmutableSet<string> topics) { }\n    public System.Collections.Immutable.IImmutableSet<string> Topics { get; }\n    public bool Equals(Akka.Cluster.Tools.PublishSubscribe.CurrentTopics other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Killing an Actor by Sending a Kill Message in Akka.NET\nDESCRIPTION: Shows how to terminate an actor by sending a Kill message, which causes the actor to throw an ActorKilledException that will be handled by its supervisor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_33\n\nLANGUAGE: csharp\nCODE:\n```\n// kill the 'victim' actor\nvictim.Tell(Akka.Actor.Kill.Instance, ActorRefs.NoSender);\n```\n\n----------------------------------------\n\nTITLE: Implementing DurableDataEnvelope Class for Durable Data in C#\nDESCRIPTION: This class represents a durable data envelope in Akka.DistributedData.Durable namespace. It encapsulates replicated data and provides equality comparison methods.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_56\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DurableDataEnvelope : Akka.DistributedData.IReplicatorMessage, System.IEquatable<Akka.DistributedData.Durable.DurableDataEnvelope>\n{\n    public DurableDataEnvelope(Akka.DistributedData.Internal.DataEnvelope dataEnvelope) { }\n    public DurableDataEnvelope(Akka.DistributedData.IReplicatedData data) { }\n    public Akka.DistributedData.IReplicatedData Data { get; }\n    public bool Equals(Akka.DistributedData.Durable.DurableDataEnvelope other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DeleteMessagesTo Class for Akka.NET Persistence in C#\nDESCRIPTION: This class represents a request to delete messages up to a specific sequence number for a given persistence ID. It includes properties for the persistence ID and target sequence number, and implements IEquatable for comparison.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DeleteMessagesTo : System.IEquatable<Akka.Persistence.Journal.AsyncWriteTarget.DeleteMessagesTo>\n{\n    public DeleteMessagesTo(string persistenceId, long toSequenceNr) { }\n    public string PersistenceId { get; }\n    public long ToSequenceNr { get; }\n    public bool Equals(Akka.Persistence.Journal.AsyncWriteTarget.DeleteMessagesTo other) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EWMA (Exponentially Weighted Moving Average) in C# for Akka.NET\nDESCRIPTION: This class implements the EWMA algorithm for smoothing time series data. It includes methods for creating, comparing, and updating EWMA values.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Net.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class EWMA : System.IEquatable<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA>\n{\n    public EWMA(double value, double alpha) { }\n    public double Alpha { get; }\n    public double Value { get; }\n    public bool Equals(Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA other) { }\n    public override bool Equals(object obj) { }\n    public static double GetAlpha(System.TimeSpan halfLife, System.TimeSpan collectInterval) { }\n    public override int GetHashCode() { }\n    public static Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA +(Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA current, double xn) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Command Methods in C#\nDESCRIPTION: Protected methods for handling various command types with synchronous and asynchronous execution patterns. Includes overloads for typed and untyped message handling with optional predicates.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nprotected void Command(System.Type messageType, System.Action<object> handler, System.Predicate<object> shouldHandle = null) { }\nprotected void Command(System.Type messageType, System.Predicate<object> shouldHandle, System.Action<object> handler) { }\nprotected void Command<T>(System.Func<T, bool> handler) { }\nprotected void Command(System.Type messageType, System.Func<object, bool> handler) { }\nprotected void Command(System.Action<object> handler) { }\nprotected void CommandAny(System.Action<object> handler) { }\nprotected void CommandAnyAsync(System.Func<object, System.Threading.Tasks.Task> handler) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing SerializerDetails Class in C#\nDESCRIPTION: Defines a sealed class representing serializer details in Akka.NET, containing information about alias, serializer instance, and types it can be used for. Includes a static Create method for instantiation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_226\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SerializerDetails\n{\n    public string Alias { get; }\n    public Akka.Serialization.Serializer Serializer { get; }\n    public System.Collections.Immutable.ImmutableHashSet<System.Type> UseFor { get; }\n    public static Akka.Serialization.SerializerDetails Create(string alias, Akka.Serialization.Serializer serializer, System.Collections.Immutable.ImmutableHashSet<System.Type> useFor) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ASP.NET Core Host Builder with Serilog\nDESCRIPTION: Setting up Serilog in ASP.NET Core application with environment-based log levels and console sink configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/serilog.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic static IHostBuilder CreateHostBuilder(string[] args) => Host.CreateDefaultBuilder(args)\n        .UseSerilog((hostingContext, services, loggerConfiguration) => \n           (Environment.GetEnvironmentVariable(\"MY_AKKA_APP__DEFAULT_LOG_LEVEL\") switch\n            {\n                \"INFO\" => loggerConfiguration.MinimumLevel.Information(),\n                \"WARN\" => loggerConfiguration.MinimumLevel.Warning(),\n                \"ERROR\" => loggerConfiguration.MinimumLevel.Error(),\n                \"DEBUG\" => loggerConfiguration.MinimumLevel.Debug(),\n                _ => loggerConfiguration.MinimumLevel.Information()\n            })\n            .WriteTo.Console()\n            .ReadFrom.Services(services)\n            .Enrich.FromLogContext()\n            .EnrichWithCommonProperties(...)\n            ... // continue logger configuration);\n```\n\n----------------------------------------\n\nTITLE: Implementing SqlReadJournalProvider Class for Akka.NET Persistence\nDESCRIPTION: Defines the SqlReadJournalProvider class which implements the IReadJournalProvider interface. It provides a method to get an instance of the SQL-based read journal.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommonQuery.Net.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class SqlReadJournalProvider : Akka.Persistence.Query.IReadJournalProvider\n{\n    public SqlReadJournalProvider(Akka.Actor.ExtendedActorSystem system, Akka.Configuration.Config config) { }\n    public Akka.Persistence.Query.IReadJournal GetReadJournal() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Typed Pattern Matching in Scala\nDESCRIPTION: This Scala code demonstrates typed pattern matching using a match statement. It checks the type of the input 'x' and returns a string based on the matched type. The example handles String, Int, Float, Array[Int], Array[String], Dog, List, and Map types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/porting-guide.md#2025-04-16_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ndef testPattern(x: Any): String = x match {\n   case s: String => s\"you gave me this string: $s\"\n   case i: Int => s\"thanks for the int: $i\"\n   case f: Float => s\"thanks for the float: $f\"\n   case a: Array[Int] => s\"an array of int: ${a.mkString(\",\")}\"\n   case as: Array[String] => s\"an array of strings: ${as.mkString(\",\")}\"\n   case d: Dog => s\"dog: ${d.name}\"\n   case list: List[_] => s\"thanks for the List: $list\"\n   case m: Map[_, _] => m.toString\n}\n```\n\n----------------------------------------\n\nTITLE: ClusterClientReceptionist Class Definition in C#\nDESCRIPTION: The ClusterClientReceptionist class that acts as an extension for registering and unregistering services within a cluster that can be accessed by external clients. It includes methods for service registration and topic subscription.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterClientReceptionist : Akka.Actor.IExtension\n{\n    public ClusterClientReceptionist(Akka.Actor.ExtendedActorSystem system) { }\n    public bool IsTerminated { get; }\n    public Akka.Actor.IActorRef Underlying { get; }\n    public static Akka.Configuration.Config DefaultConfig() { }\n    public static Akka.Cluster.Tools.Client.ClusterClientReceptionist Get(Akka.Actor.ActorSystem system) { }\n    public void RegisterService(Akka.Actor.IActorRef actorRef) { }\n    public void RegisterSubscriber(string topic, Akka.Actor.IActorRef actorRef) { }\n    public void UnregisterService(Akka.Actor.IActorRef actorRef) { }\n    public void UnregisterSubscriber(string topic, Akka.Actor.IActorRef actorRef) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ReadHighestSequenceNrAsync Method for Akka.Persistence Journal\nDESCRIPTION: Implementation of the ReadHighestSequenceNrAsync method for a SQLite-based Akka.Persistence journal. This method retrieves the highest stored sequence number for a given persistence ID.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/custom-persistence-provider.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override async Task<long> ReadHighestSequenceNrAsync(string persistenceId, long fromSequenceNr)\n{\n    using (var connection = await _connectionFactory.CreateConnection())\n    using (var command = connection.CreateCommand())\n    {\n        command.CommandText = HighestSequenceNrSql;\n        command.Parameters.AddWithValue(\"@PersistenceId\", persistenceId);\n\n        var result = await command.ExecuteScalarAsync();\n        return result == DBNull.Value ? 0L : Convert.ToInt64(result);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Config-based Service Discovery Implementation\nDESCRIPTION: Implementation of configuration-based service discovery with methods for managing endpoints and parsing services configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.Net.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class ConfigServiceDiscovery : Akka.Discovery.ServiceDiscovery\n{\n    public ConfigServiceDiscovery(Akka.Actor.ExtendedActorSystem system) { }\n    public ConfigServiceDiscovery(Akka.Actor.ExtendedActorSystem system, Akka.Configuration.Config config) { }\n    public override System.Threading.Tasks.Task<Akka.Discovery.ServiceDiscovery.Resolved> Lookup(Akka.Discovery.Lookup lookup, System.TimeSpan resolveTimeout) { }\n    public bool TryAddEndpoint(string serviceName, Akka.Discovery.ServiceDiscovery.ResolvedTarget target) { }\n    public bool TryRemoveEndpoint(string serviceName, Akka.Discovery.ServiceDiscovery.ResolvedTarget target) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Option<T> Select Method in C#\nDESCRIPTION: A method to transform an Option<T> to Option<TNew> using a selector function. This is part of the functional programming approach in Akka.Net.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_221\n\nLANGUAGE: C#\nCODE:\n```\npublic Akka.Util.Option<TNew> Select<TNew>(System.Func<T, TNew> selector) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing MemoryJournal for In-Memory Persistence in Akka.NET\nDESCRIPTION: Provides an in-memory journal implementation with methods for adding, reading, updating, and deleting persistent messages, along with supporting classes for managing persistence IDs and replay operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_49\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MemoryJournal : Akka.Persistence.Journal.AsyncWriteJournal\n{\n    public MemoryJournal() { }\n    protected virtual System.Collections.Concurrent.ConcurrentDictionary<string, System.Collections.Generic.LinkedList<Akka.Persistence.IPersistentRepresentation>> Messages { get; }\n    public System.Collections.Generic.IDictionary<string, System.Collections.Generic.LinkedList<Akka.Persistence.IPersistentRepresentation>> Add(Akka.Persistence.IPersistentRepresentation persistent) { }\n    public System.Collections.Generic.IDictionary<string, System.Collections.Generic.LinkedList<Akka.Persistence.IPersistentRepresentation>> Delete(string pid, long seqNr) { }\n    protected override System.Threading.Tasks.Task DeleteMessagesToAsync(string persistenceId, long toSequenceNr) { }\n    public long HighestSequenceNr(string pid) { }\n    public System.Collections.Generic.IEnumerable<Akka.Persistence.IPersistentRepresentation> Read(string pid, long fromSeqNr, long toSeqNr, long max) { }\n    public override System.Threading.Tasks.Task<long> ReadHighestSequenceNrAsync(string persistenceId, long fromSequenceNr) { }\n    protected override bool ReceivePluginInternal(object message) { }\n    public override System.Threading.Tasks.Task ReplayMessagesAsync(Akka.Actor.IActorContext context, string persistenceId, long fromSequenceNr, long toSequenceNr, long max, System.Action<Akka.Persistence.IPersistentRepresentation> recoveryCallback) { }\n    public System.Collections.Generic.IDictionary<string, System.Collections.Generic.LinkedList<Akka.Persistence.IPersistentRepresentation>> Update(string pid, long seqNr, System.Func<Akka.Persistence.IPersistentRepresentation, Akka.Persistence.IPersistentRepresentation> updater) { }\n    protected override System.Threading.Tasks.Task<System.Collections.Immutable.IImmutableList<System.Exception>> WriteMessagesAsync(System.Collections.Generic.IEnumerable<Akka.Persistence.AtomicWrite> messages) { }\n    public sealed class CurrentPersistenceIds : Akka.Event.IDeadLetterSuppression\n    {\n        public readonly System.Collections.Generic.IEnumerable<string> AllPersistenceIds;\n        public readonly int HighestOrderingNumber;\n        public CurrentPersistenceIds(System.Collections.Generic.IEnumerable<string> allPersistenceIds, int highestOrderingNumber) { }\n    }\n    public sealed class EventReplayFailure\n    {\n        public EventReplayFailure(System.Exception cause) { }\n        public System.Exception Cause { get; }\n        public bool Equals(Akka.Persistence.Journal.MemoryJournal.EventReplayFailure other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n    }\n    public sealed class EventReplaySuccess\n    {\n        public EventReplaySuccess(int highestSequenceNr) { }\n        public int HighestSequenceNr { get; }\n        public bool Equals(Akka.Persistence.Journal.MemoryJournal.EventReplaySuccess other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n    }\n    public sealed class ReplayAllEvents : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IJournalMessage, Akka.Persistence.IJournalRequest, Akka.Persistence.IPersistenceMessage\n    {\n        public readonly int FromOffset;\n        public readonly long Max;\n        public readonly Akka.Actor.IActorRef ReplyTo;\n        public readonly int ToOffset;\n        public ReplayAllEvents(int fromOffset, int toOffset, long max, Akka.Actor.IActorRef replyTo) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LWWDictionary for Akka.NET Distributed Data\nDESCRIPTION: Last-Write-Wins Dictionary implementation for Akka.NET's distributed data. This class provides a conflict-free replicated dictionary with automatic conflict resolution based on timestamps.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class LWWDictionary<TKey, TValue> : Akka.DistributedData.IDeltaReplicatedData, Akka.DistributedData.IDeltaReplicatedData<Akka.DistributedData.LWWDictionary<TKey, TValue>, Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.LWWRegister<TValue>>.IDeltaOperation>, Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IRemovedNodePruning<Akka.DistributedData.LWWDictionary<TKey, TValue>>, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.LWWDictionary<TKey, TValue>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable, System.IEquatable<Akka.DistributedData.LWWDictionary<TKey, TValue>>\n{\n    public static readonly Akka.DistributedData.LWWDictionary<TKey, TValue> Empty;\n    public LWWDictionary(Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.LWWRegister<TValue>> underlying) { }\n    public int Count { get; }\n    public Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.LWWRegister<TValue>>.IDeltaOperation Delta { get; }\n    public System.Collections.Immutable.IImmutableDictionary<TKey, TValue> Entries { get; }\n    public bool IsEmpty { get; }\n    public TValue this[TKey key] { get; }\n    public System.Type KeyType { get; }\n    public System.Collections.Generic.IEnumerable<TKey> Keys { get; }\n    public System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.UniqueAddress> ModifiedByNodes { get; }\n    public System.Type ValueType { get; }\n    public System.Collections.Generic.IEnumerable<TValue> Values { get; }\n    public bool ContainsKey(TKey key) { }\n    public bool Equals(Akka.DistributedData.LWWDictionary<TKey, TValue> other) { }\n    public override bool Equals(object obj) { }\n    public System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> GetEnumerator() { }\n    public override int GetHashCode() { }\n    public Akka.DistributedData.LWWDictionary<TKey, TValue> Merge(Akka.DistributedData.LWWDictionary<TKey, TValue> other) { }\n    public Akka.DistributedData.IReplicatedData Merge(Akka.DistributedData.IReplicatedData other) { }\n    public Akka.DistributedData.LWWDictionary<TKey, TValue> MergeDelta(Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.LWWRegister<TValue>>.IDeltaOperation delta) { }\n    public bool NeedPruningFrom(Akka.Cluster.UniqueAddress removedNode) { }\n    public Akka.DistributedData.LWWDictionary<TKey, TValue> Prune(Akka.Cluster.UniqueAddress removedNode, Akka.Cluster.UniqueAddress collapseInto) { }\n    public Akka.DistributedData.LWWDictionary<TKey, TValue> PruningCleanup(Akka.Cluster.UniqueAddress removedNode) { }\n    public Akka.DistributedData.LWWDictionary<TKey, TValue> Remove(Akka.Cluster.Cluster node, TKey key) { }\n    public Akka.DistributedData.LWWDictionary<TKey, TValue> Remove(Akka.Cluster.UniqueAddress node, TKey key) { }\n    public Akka.DistributedData.LWWDictionary<TKey, TValue> ResetDelta() { }\n    public Akka.DistributedData.LWWDictionary<TKey, TValue> SetItem(Akka.Cluster.Cluster node, TKey key, TValue value, Akka.DistributedData.Clock<TValue> clock = null) { }\n    public Akka.DistributedData.LWWDictionary<TKey, TValue> SetItem(Akka.Cluster.UniqueAddress node, TKey key, TValue value, Akka.DistributedData.Clock<TValue> clock = null) { }\n    public override string ToString() { }\n    public bool TryGetValue(TKey key, out TValue value) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterShardingSettings for Akka.NET Sharding Configuration\nDESCRIPTION: Settings class that encapsulates all configuration options for cluster sharding, including entity passivation, state persistence, and tuning parameters. Provides methods to create settings from system configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Core.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterShardingSettings : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public readonly Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings CoordinatorSingletonSettings;\n    public readonly string JournalPluginId;\n    public readonly Akka.Coordination.LeaseUsageSettings LeaseSettings;\n    public readonly System.TimeSpan PassivateIdleEntityAfter;\n    public readonly bool RememberEntities;\n    public readonly Akka.Cluster.Sharding.RememberEntitiesStore RememberEntitiesStore;\n    public readonly string Role;\n    public readonly System.TimeSpan ShardRegionQueryTimeout;\n    public readonly string SnapshotPluginId;\n    public readonly Akka.Cluster.Sharding.StateStoreMode StateStoreMode;\n    public readonly Akka.Cluster.Sharding.TuningParameters TuningParameters;\n    public ClusterShardingSettings(string role, bool rememberEntities, string journalPluginId, string snapshotPluginId, System.TimeSpan passivateIdleEntityAfter, Akka.Cluster.Sharding.StateStoreMode stateStoreMode, Akka.Cluster.Sharding.TuningParameters tuningParameters, Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings coordinatorSingletonSettings) { }\n    public ClusterShardingSettings(string role, bool rememberEntities, string journalPluginId, string snapshotPluginId, System.TimeSpan passivateIdleEntityAfter, Akka.Cluster.Sharding.StateStoreMode stateStoreMode, Akka.Cluster.Sharding.TuningParameters tuningParameters, Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings coordinatorSingletonSettings, Akka.Coordination.LeaseUsageSettings leaseSettings) { }\n    public ClusterShardingSettings(string role, bool rememberEntities, string journalPluginId, string snapshotPluginId, System.TimeSpan passivateIdleEntityAfter, Akka.Cluster.Sharding.StateStoreMode stateStoreMode, Akka.Cluster.Sharding.RememberEntitiesStore rememberEntitiesStore, System.TimeSpan shardRegionQueryTimeout, Akka.Cluster.Sharding.TuningParameters tuningParameters, Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings coordinatorSingletonSettings, Akka.Coordination.LeaseUsageSettings leaseSettings) { }\n    public static Akka.Cluster.Sharding.ClusterShardingSettings Create(Akka.Actor.ActorSystem system) { }\n    public static Akka.Cluster.Sharding.ClusterShardingSettings Create(Akka.Configuration.Config config, Akka.Configuration.Config singletonConfig) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Message Types for At-Least-Once Delivery in C#\nDESCRIPTION: This snippet defines the message types used for at-least-once delivery, including IDeliverable for wrapping messages with delivery IDs, and Confirmation for acknowledging message receipt.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/at-least-once-delivery.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IDeliverable\n{\n    long DeliveryId { get; }\n}\n\npublic class Msg : IDeliverable\n{\n    public Msg(string s, long deliveryId)\n    {\n        S = s;\n        DeliveryId = deliveryId;\n    }\n\n    public string S { get; }\n    public long DeliveryId { get; }\n}\n\npublic class Confirmation\n{\n    public Confirmation(long deliveryId)\n    {\n        DeliveryId = deliveryId;\n    }\n\n    public long DeliveryId { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Using DocFX Tag Syntax for Code Referencing in C#\nDESCRIPTION: This C# snippet shows an alternative way to mark code for documentation using DocFX's tag syntax. It uses // <TagName> and // </TagName> to define a section of code that can be referenced in documentation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/documentation-guidelines.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n// <ClusterClient>\npublic class ClientListener : UntypedActor\n{\n    private readonly IActorRef _targetClient;\n\n    public ClientListener(IActorRef targetClient)\n    {\n        _targetClient = targetClient;\n    }\n\n    protected override void OnReceive(object message)\n    {\n        Context.Become(ReceiveWithContactPoints(ImmutableHashSet<ActorPath>.Empty));\n    }\n\n    protected override void PreStart()\n    {\n        _targetClient.Tell(SubscribeContactPoints.Instance);\n    }\n\n    public UntypedReceive ReceiveWithContactPoints(IImmutableSet<ActorPath> contactPoints)\n    {\n        return (message) =>\n        {\n            switch (message)\n            {\n                // Now do something with the up-to-date \"cps\"\n                case ContactPoints cp:\n                    Context.Become(ReceiveWithContactPoints(cp.ContactPointsList));\n                    break;\n                // Now do something with an up-to-date \"contactPoints + cp\"\n                case ContactPointAdded cpa:\n                    Context.Become(ReceiveWithContactPoints(contactPoints.Add(cpa.ContactPoint)));\n                    break;\n                // Now do something with an up-to-date \"contactPoints - cp\"\n                case ContactPointRemoved cpr:\n                    Context.Become(ReceiveWithContactPoints(contactPoints.Remove(cpr.ContactPoint)));\n                    break;\n            }\n        };\n    }\n}\n// </ClusterClient>\n```\n\n----------------------------------------\n\nTITLE: Implementing Extension System Interfaces in C#\nDESCRIPTION: Interfaces for the Akka.NET extension system, allowing for type-safe extension creation and retrieval.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IExtensionId\n{\n    System.Type ExtensionType { get; }\n    object Apply(Akka.Actor.ActorSystem system);\n    object CreateExtension(Akka.Actor.ExtendedActorSystem system);\n    object Get(Akka.Actor.ActorSystem system);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Recovery Methods in C#\nDESCRIPTION: This snippet shows various overloads of the Recover method for handling recovery of different types of messages in Akka.NET persistence.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\nprotected void Recover<T>(System.Action<T> handler, System.Predicate<T> shouldHandle = null) { }\nprotected void Recover<T>(System.Predicate<T> shouldHandle, System.Action<T> handler) { }\nprotected void Recover(System.Type messageType, System.Action<object> handler, System.Predicate<object> shouldHandle = null) { }\nprotected void Recover(System.Type messageType, System.Predicate<object> shouldHandle, System.Action<object> handler) { }\nprotected void Recover<T>(System.Func<T, bool> handler) { }\nprotected void Recover(System.Type messageType, System.Func<object, bool> handler) { }\nprotected void RecoverAny(System.Action<object> handler) { }\n```\n\n----------------------------------------\n\nTITLE: Redirecting HTML for Moved Documentation Pages\nDESCRIPTION: This HTML snippet demonstrates how to create a redirect page for documentation that has been moved to a new location. It uses a meta refresh tag to perform a 301 redirect to the new file location.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/documentation-guidelines.md#2025-04-16_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta http-equiv=\"refresh\" content=\"0; url=../articles/intro/building-akka-net.html\" />\n  </head>\n</html>\n```\n\n----------------------------------------\n\nTITLE: UnderlyingTransportError Class Implementation\nDESCRIPTION: Sealed class representing transport-level errors in Akka.NET remote communication. Implements INoSerializationVerificationNeeded and IHandleEvent interfaces.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class UnderlyingTransportError : Akka.Actor.INoSerializationVerificationNeeded, Akka.Remote.Transport.IHandleEvent\n{\n    public UnderlyingTransportError(System.Exception cause, string message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ActorTaskScheduler in C#\nDESCRIPTION: A TaskScheduler implementation for Akka.NET that integrates with the actor system, providing methods to queue and execute tasks within actor contexts. It tracks current message and supports both synchronous and asynchronous task execution.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_82\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ActorTaskScheduler : System.Threading.Tasks.TaskScheduler\n{\n    public object CurrentMessage { get; }\n    public override int MaximumConcurrencyLevel { get; }\n    protected override System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> GetScheduledTasks() { }\n    protected virtual void OnAfterTaskCompleted() { }\n    protected virtual void OnBeforeTaskStarted() { }\n    protected override void QueueTask(System.Threading.Tasks.Task task) { }\n    public static void RunTask(System.Action action) { }\n    public static void RunTask(System.Func<System.Threading.Tasks.Task> asyncAction) { }\n    protected override bool TryExecuteTaskInline(System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Publish Message in C#\nDESCRIPTION: This class represents a Publish message in the Distributed Publish-Subscribe system. It includes properties for the topic, message content, and delivery options.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Net.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Publish : Akka.Actor.IWrappedMessage, Akka.Cluster.Tools.PublishSubscribe.IDistributedPubSubMessage, System.IEquatable<Akka.Cluster.Tools.PublishSubscribe.Publish>\n{\n    public Publish(string topic, object message, bool sendOneMessageToEachGroup = False) { }\n    public object Message { get; }\n    public bool SendOneMessageToEachGroup { get; }\n    public string Topic { get; }\n    public bool Equals(Akka.Cluster.Tools.PublishSubscribe.Publish other) { }\n    public override bool Equals(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PersistentFSM in C#\nDESCRIPTION: Defines the PersistentFSM class that extends PersistentFSMBase and requires TState to implement IFsmState. This class provides functionality for applying domain events to data and recovering state from persistence.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_50\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class PersistentFSM<TState, TData, TEvent> : Akka.Persistence.Fsm.PersistentFSMBase<TState, TData, TEvent>\n    where TState : Akka.Persistence.Fsm.PersistentFSM.IFsmState\n{\n    protected PersistentFSM() { }\n    protected abstract TData ApplyEvent(TEvent domainEvent, TData currentData);\n    protected override void ApplyState(Akka.Persistence.Fsm.PersistentFSM.State<TState, TData, TEvent> nextState) { }\n    protected virtual void OnRecoveryCompleted() { }\n    protected override bool ReceiveRecover(object message) { }\n    public void SaveStateSnapshot() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterShardingStats Class in C#\nDESCRIPTION: A sealed class representing cluster sharding statistics, including a dictionary of shard region stats and methods for equality comparison and string representation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterShardingStats : Akka.Cluster.Sharding.IClusterShardingSerializable, System.IEquatable<Akka.Cluster.Sharding.ClusterShardingStats>\n{\n    public readonly System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, Akka.Cluster.Sharding.ShardRegionStats> Regions;\n    public ClusterShardingStats(System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, Akka.Cluster.Sharding.ShardRegionStats> regions) { }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.Cluster.Sharding.ClusterShardingStats other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: ThrottlerProvider Class Implementation (C#)\nDESCRIPTION: Provider class that creates throttling transport adapters. Implements ITransportAdapterProvider interface for transport adapter creation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\npublic class ThrottlerProvider : Akka.Remote.Transport.ITransportAdapterProvider\n{\n    public ThrottlerProvider() { }\n    public Akka.Remote.Transport.Transport Create(Akka.Remote.Transport.Transport wrappedTransport, Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Address UID Management in Akka.NET Remote\nDESCRIPTION: Defines AddressUid and AddressUidExtension classes for managing unique identifiers for actor addresses in the remote system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.Remote\n{\n    public class AddressUid : Akka.Actor.IExtension\n    {\n        public readonly int Uid;\n        public AddressUid() { }\n    }\n    public class AddressUidExtension : Akka.Actor.ExtensionIdProvider<Akka.Remote.AddressUid>\n    {\n        public AddressUidExtension() { }\n        public override Akka.Remote.AddressUid CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n        public static int Uid(Akka.Actor.ActorSystem system) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Actor DSL Implementation in C#\nDESCRIPTION: Domain-specific language implementation for creating and configuring actors. Provides fluent API for actor creation and message handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_55\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Act : Akka.Actor.ReceiveActor, Akka.Actor.Dsl.IActorDsl\n{\n    public Act(System.Action<Akka.Actor.Dsl.IActorDsl> config) { }\n    public Act(System.Action<Akka.Actor.Dsl.IActorDsl, Akka.Actor.IActorContext> config) { }\n    public System.Action<System.Exception, Akka.Actor.IActorContext> OnPostRestart { get; set; }\n    public System.Action<Akka.Actor.IActorContext> OnPostStop { get; set; }\n    public System.Action<System.Exception, object, Akka.Actor.IActorContext> OnPreRestart { get; set; }\n    public System.Action<Akka.Actor.IActorContext> OnPreStart { get; set; }\n    public Akka.Actor.SupervisorStrategy Strategy { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Condition Awaiting in C#\nDESCRIPTION: Provides various overloads of AwaitCondition methods for asynchronously waiting on conditions with timeout and cancellation support.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic System.Threading.Tasks.Task AwaitConditionAsync(System.Func<System.Threading.Tasks.Task<bool>> conditionIsFulfilled, System.Nullable<System.TimeSpan> max, string message, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.Task AwaitConditionAsync(System.Func<bool> conditionIsFulfilled, System.Nullable<System.TimeSpan> max, string message, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Abstract Eventsourced Class in C#\nDESCRIPTION: An abstract base class for event-sourced actors in Akka, implementing interfaces for persistence, stash management, and providing core functionality. Defines essential methods for persisting, recovering, and handling messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class Eventsourced : Akka.Actor.ActorBase, Akka.Actor.IActorStash, Akka.Actor.IWithUnboundedStash, Akka.Actor.IWithUnrestrictedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics>, Akka.Persistence.IPersistenceRecovery, Akka.Persistence.IPersistenceStash, Akka.Persistence.IPersistentIdentity\n{\n    public static readonly System.Func<Akka.Actor.Envelope, bool> UnstashFilterPredicate;\n    protected Eventsourced() { }\n    protected Akka.Persistence.PersistenceExtension Extension { get; }\n    public virtual Akka.Persistence.IStashOverflowStrategy InternalStashOverflowStrategy { get; }\n    public bool IsRecovering { get; }\n    public bool IsRecoveryFinished { get; }\n    public Akka.Actor.IActorRef Journal { get; }\n    public string JournalPluginId { get; set; }\n    public long LastSequenceNr { get; }\n    protected virtual Akka.Event.ILoggingAdapter Log { get; }\n    public abstract string PersistenceId { get; }\n    public virtual Akka.Persistence.Recovery Recovery { get; }\n    public string SnapshotPluginId { get; set; }\n    public long SnapshotSequenceNr { get; }\n    public Akka.Actor.IActorRef SnapshotStore { get; }\n    public string SnapshotterId { get; }\n    public Akka.Actor.IStash Stash { get; set; }\n    public override void AroundPostRestart(System.Exception reason, object message) { }\n    public override void AroundPostStop() { }\n    public override void AroundPreRestart(System.Exception cause, object message) { }\n    public override void AroundPreStart() { }\n    protected override bool AroundReceive(Akka.Actor.Receive receive, object message) { }\n    public void DeferAsync<TEvent>(TEvent evt, System.Action<TEvent> handler) { }\n    public void DeleteMessages(long toSequenceNr) { }\n    public void DeleteSnapshot(long sequenceNr) { }\n    public void DeleteSnapshots(Akka.Persistence.SnapshotSelectionCriteria criteria) { }\n    public void LoadSnapshot(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria, long toSequenceNr) { }\n    protected virtual void OnPersistFailure(System.Exception cause, object @event, long sequenceNr) { }\n    protected virtual void OnPersistRejected(System.Exception cause, object @event, long sequenceNr) { }\n    protected virtual void OnRecoveryFailure(System.Exception reason, object message = null) { }\n    protected virtual void OnReplaySuccess() { }\n    public void Persist<TEvent>(TEvent @event, System.Action<TEvent> handler) { }\n    public void PersistAll<TEvent>(System.Collections.Generic.IEnumerable<TEvent> events, System.Action<TEvent> handler) { }\n    public void PersistAllAsync<TEvent>(System.Collections.Generic.IEnumerable<TEvent> events, System.Action<TEvent> handler) { }\n    public void PersistAsync<TEvent>(TEvent @event, System.Action<TEvent> handler) { }\n    protected abstract bool ReceiveCommand(object message);\n    protected abstract bool ReceiveRecover(object message);\n    protected void RunTask(System.Func<System.Threading.Tasks.Task> action) { }\n    public void SaveSnapshot(object snapshot) { }\n    protected override void Unhandled(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract Query Executor for Snapshots\nDESCRIPTION: Abstract base class for executing snapshot-related database queries. Provides methods for creating, reading, and deleting snapshots with configurable SQL commands.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Core.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AbstractQueryExecutor : Akka.Persistence.Sql.Common.Snapshot.ISnapshotQueryExecutor {\n    protected Akka.Serialization.Serialization Serialization;\n    protected AbstractQueryExecutor(Akka.Persistence.Sql.Common.Snapshot.QueryConfiguration configuration, Akka.Serialization.Serialization serialization) { }\n    public Akka.Persistence.Sql.Common.Snapshot.QueryConfiguration Configuration { get; }\n    protected abstract string CreateSnapshotTableSql { get; }\n    // Additional methods omitted for brevity\n}\n```\n\n----------------------------------------\n\nTITLE: Partial Definition of ModifyFailure Class in C#\nDESCRIPTION: Begins the definition of the ModifyFailure class which implements IUpdateFailure and INoSerializationVerificationNeeded, used to represent update failures in the distributed data system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ModifyFailure : Akka.Actor.INoSerializationVerificationNeeded, Akka.DistributedData.IUpdateFailure, Akka.DistributedData.IUpdateResponse\n{\n```\n\n----------------------------------------\n\nTITLE: Defining MessageOrChunk<T> Class in C#\nDESCRIPTION: Defines a generic class MessageOrChunk<T> with methods for handling chunked messages and implicit conversions. It includes properties for checking if the content is a message or chunk, and methods for equality comparison and hash code generation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_92\n\nLANGUAGE: C#\nCODE:\n```\npublic MessageOrChunk(Akka.Delivery.Internal.ChunkedMessage chunkedMessage) { }\npublic System.Nullable<Akka.Delivery.Internal.ChunkedMessage> Chunk { get; }\npublic bool IsMessage { get; }\npublic T Message { get; }\npublic bool Equals([System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n        0,\n        1})] Akka.Delivery.Internal.MessageOrChunk<T> other) { }\npublic override bool Equals(object obj) { }\npublic override int GetHashCode() { }\npublic override string ToString() { }\n[return: System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n        0,\n        1})]\npublic static Akka.Delivery.Internal.MessageOrChunk<T> op_Implicit(T message) { }\npublic static T op_Implicit([System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n        0,\n        1})] Akka.Delivery.Internal.MessageOrChunk<T> message) { }\npublic static Akka.Delivery.Internal.ChunkedMessage op_Implicit([System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n        0,\n        1})] Akka.Delivery.Internal.MessageOrChunk<T> message) { }\n[return: System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n        0,\n        1})]\npublic static Akka.Delivery.Internal.MessageOrChunk<T> op_Implicit(Akka.Delivery.Internal.ChunkedMessage chunkedMessage) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing TimeSpan Extension Methods in C#\nDESCRIPTION: This snippet defines extension methods for TimeSpan in Akka.NET TestKit. These methods provide utility functions for checking various properties of TimeSpan instances.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic class static TimeSpanExtensions\n{\n    public static void EnsureIsPositiveFinite(this System.TimeSpan timeSpan, string parameterName) { }\n    public static bool IsInfinite(this System.TimeSpan timeSpan) { }\n    public static bool IsInfinite(this System.Nullable<System.TimeSpan> timeSpan) { }\n    public static bool IsInfiniteTimeout(this System.TimeSpan timeSpan) { }\n    public static bool IsInfiniteTimeout(this System.Nullable<System.TimeSpan> timeSpan) { }\n    public static bool IsPositiveFinite(this System.TimeSpan timeSpan) { }\n    public static bool IsPositiveFinite(this System.Nullable<System.TimeSpan> timeSpan) { }\n    public static bool IsUndefined(this System.Nullable<System.TimeSpan> timeSpan) { }\n    public static bool IsZero(this System.TimeSpan timeSpan) { }\n    public static bool IsZero(this System.Nullable<System.TimeSpan> timeSpan) { }\n    public static System.TimeSpan Min(this System.TimeSpan a, System.Nullable<System.TimeSpan> b) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IRunnable Interfaces in C#\nDESCRIPTION: Defines two sealed classes, ActionRunnable and ActionWithStateRunnable, that implement the IRunnable interface. These classes encapsulate actions to be run, with ActionWithStateRunnable allowing for additional state to be passed.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_93\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ActionRunnable : Akka.Dispatch.IRunnable\n{\n    public ActionRunnable(System.Action action) { }\n    public void Run() { }\n}\npublic sealed class ActionWithStateRunnable : Akka.Dispatch.IRunnable\n{\n    public ActionWithStateRunnable(System.Action<object> actionWithState, object state) { }\n    public void Run() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending a Message to a Remote Actor Over HTTP in C#\nDESCRIPTION: C# code example showing how to use ActorSelection to send a message to a remote actor using a specific transport protocol (HTTP in this case). The protocol is specified in the address scheme of the remote actor path.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/remoting/transports.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar as = MyActorSystem.ActorSelection(\"akka.http://RemoteSystem@localhost:8082/user/actor\");\nas.Tell(\"remote message!\"); //delivers message to remote system, if they're also using this transport\n```\n\n----------------------------------------\n\nTITLE: Implementing Selection Path Elements for Actor Selection\nDESCRIPTION: Classes for representing path elements in Akka.NET's actor selection mechanism. Includes implementations for selecting children by name, pattern matching, recursive selection, and parent selection.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_46\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class SelectionPathElement\n    {\n        protected SelectionPathElement() { }\n    }\n\n    public class SelectChildName : Akka.Actor.SelectionPathElement\n    {\n        public SelectChildName(string name) { }\n        public string Name { get; }\n        protected bool Equals(Akka.Actor.SelectChildName other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n    }\n\n    public class SelectChildPattern : Akka.Actor.SelectionPathElement\n    {\n        public SelectChildPattern(string patternStr) { }\n        public string PatternStr { get; }\n        protected bool Equals(Akka.Actor.SelectChildPattern other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n    }\n\n    public class SelectChildRecursive : Akka.Actor.SelectionPathElement\n    {\n        public static readonly Akka.Actor.SelectChildRecursive Instance;\n        public SelectChildRecursive() { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n    }\n\n    public class SelectParent : Akka.Actor.SelectionPathElement\n    {\n        public static readonly Akka.Actor.SelectParent Instance;\n        public SelectParent() { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Cluster Sharding Message Serializer in C#\nDESCRIPTION: Serializer class for cluster sharding messages extending SerializerWithStringManifest.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterShardingMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public ClusterShardingMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object o) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Log Configuration and Filtering in Akka.NET\nDESCRIPTION: Defines classes for configuring and building log filters in Akka.NET. The LogFilterBuilder class provides a fluent API for creating complex log filtering rules based on message content and source patterns.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_140\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class LogFilterBuilder\n{\n    public LogFilterBuilder() { }\n    public Akka.Event.LogFilterBuilder Add(Akka.Event.LogFilterBase filter) { }\n    public Akka.Event.LogFilterBuilder AddRange(System.Collections.Generic.IEnumerable<Akka.Event.LogFilterBase> filters) { }\n    public Akka.Event.LogFilterSetup Build() { }\n    public Akka.Event.LogFilterBuilder ExcludeMessageContaining(string messagePart) { }\n    public Akka.Event.LogFilterBuilder ExcludeMessageRegex(System.Text.RegularExpressions.Regex regex) { }\n    public Akka.Event.LogFilterBuilder ExcludeSourceContaining(string sourcePart) { }\n    public Akka.Event.LogFilterBuilder ExcludeSourceEndingWith(string sourceEnd) { }\n    public Akka.Event.LogFilterBuilder ExcludeSourceExactly(string source, System.StringComparison comparison = 5) { }\n    public Akka.Event.LogFilterBuilder ExcludeSourceRegex(System.Text.RegularExpressions.Regex regex) { }\n    public Akka.Event.LogFilterBuilder ExcludeSourceStartingWith(string sourceStart) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Config Extension Methods\nDESCRIPTION: Extension methods for the Config class providing additional functionality like null checking and safe fallback operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_66\n\nLANGUAGE: C#\nCODE:\n```\npublic class static ConfigExtensions\n{\n    public static bool IsNullOrEmpty(this Akka.Configuration.Config config) { }\n    public static Akka.Configuration.Config SafeWithFallback(this Akka.Configuration.Config config, Akka.Configuration.Config fallback) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract MessageDispatcher Class in C#\nDESCRIPTION: This abstract class represents a message dispatcher in Akka.NET. It includes methods for attaching, detaching, dispatching, and scheduling tasks, as well as properties for configuration and performance settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_102\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class MessageDispatcher\n{\n    public const int DefaultThroughput = 100;\n    protected MessageDispatcher(Akka.Dispatch.MessageDispatcherConfigurator configurator) { }\n    public Akka.Dispatch.MessageDispatcherConfigurator Configurator { get; }\n    public Akka.Event.EventStream EventStream { get; }\n    public string Id { get; set; }\n    protected long Inhabitants { get; }\n    public Akka.Dispatch.Mailboxes Mailboxes { get; }\n    [Akka.Annotations.InternalApiAttribute()]\n    public System.TimeSpan ShutdownTimeout { get; set; }\n    public int Throughput { get; set; }\n    public System.Nullable<long> ThroughputDeadlineTime { get; set; }\n    public virtual void Attach(Akka.Actor.ActorCell cell) { }\n    public virtual void Detach(Akka.Actor.ActorCell cell) { }\n    public virtual void Dispatch(Akka.Actor.ActorCell cell, Akka.Actor.Envelope envelope) { }\n    protected abstract void ExecuteTask(Akka.Dispatch.IRunnable run);\n    protected void ReportFailure(System.Exception ex) { }\n    public void Schedule(System.Action run) { }\n    public void Schedule(Akka.Dispatch.IRunnable run) { }\n    [Akka.Annotations.InternalApiAttribute()]\n    protected abstract void Shutdown();\n    public virtual void SystemDispatch(Akka.Actor.ActorCell cell, Akka.Dispatch.SysMsg.SystemMessage message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Contact Auto-Discovery With Akka.Discovery.Azure (Receptionist Side)\nDESCRIPTION: Shows the implementation on the receptionist side when using Azure-based discovery. This configuration ensures the receptionist can be discovered by clients using corresponding service and table names.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-client.md#2025-04-16_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nservices.AddAkka(\"ReceptionistSys\", (builder, provider) => {\n    \n  builder\n    // This is the Discovery plugin that will be used with ClusterClientDiscovery.\n    .WithAzureDiscovery(options => {\n      // IMPORTANT:\n      // This signals Akka.Hosting that this plugin **should not** be used for ClusterBootstrap\n      options.IsDefaultPlugin = false,\n      \n      // IMPORTANT:\n      // The ConfigPath property has to be different than the default discovery ConfigPath.\n      // The actual name does not matter, but it has to be different than the default name \"azure\"\n      options.ConfigPath = \"azure-cluster-client\",\n        \n      // IMPORTANT:\n      // All service names for cluster client discovery should be the same.\n      // If you're also using ClusterBootstrap, make sure that this name does not collide.  \n      options.ServiceName = \"cluster-client\",\n        \n      // IMPORTANT:\n      // All table names for cluster client discovery should be the same.\n      // If you're also using ClusterBootstrap, make sure that this table name does not collide.  \n      options.TableName = \"akkaclusterreceptionists\",\n    }\n\n    // If you're not using ClusterBootstrap in the cluster client side, you will need to add\n    // these code\n    .AddStartup(async (system, registry) => {\n      await AkkaManagement.Get(system).Start();\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Least Shard Allocation Strategy in C#\nDESCRIPTION: Abstract base class for implementing least-shard allocation strategies in Akka.NET clusters, providing core allocation and rebalancing functionality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Net.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AbstractLeastShardAllocationStrategy : Akka.Actor.INoSerializationVerificationNeeded, Akka.Cluster.Sharding.IActorSystemDependentAllocationStrategy, Akka.Cluster.Sharding.IShardAllocationStrategy\n{\n    protected AbstractLeastShardAllocationStrategy() { }\n    protected virtual Akka.Cluster.ClusterEvent.CurrentClusterState ClusterState { get; }\n    protected virtual Akka.Cluster.Member SelfMember { get; }\n    public System.Threading.Tasks.Task<Akka.Actor.IActorRef> AllocateShard(Akka.Actor.IActorRef requester, string shardId, System.Collections.Immutable.IImmutableDictionary<Akka.Actor.IActorRef, System.Collections.Immutable.IImmutableList<string>> currentShardAllocations) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ClusterShardingSettings in C#\nDESCRIPTION: This snippet shows methods for configuring various aspects of ClusterShardingSettings, such as coordinator settings, journal plugin, lease settings, and more.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Core.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic Akka.Cluster.Sharding.ClusterShardingSettings WithCoordinatorSingletonSettings(Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings coordinatorSingletonSettings) { }\npublic Akka.Cluster.Sharding.ClusterShardingSettings WithJournalPluginId(string journalPluginId) { }\npublic Akka.Cluster.Sharding.ClusterShardingSettings WithLeaseSettings(Akka.Coordination.LeaseUsageSettings leaseSettings) { }\npublic Akka.Cluster.Sharding.ClusterShardingSettings WithPassivateIdleAfter(System.TimeSpan duration) { }\npublic Akka.Cluster.Sharding.ClusterShardingSettings WithRememberEntities(bool rememberEntities) { }\npublic Akka.Cluster.Sharding.ClusterShardingSettings WithRole(string role) { }\npublic Akka.Cluster.Sharding.ClusterShardingSettings WithSnapshotPluginId(string snapshotPluginId) { }\npublic Akka.Cluster.Sharding.ClusterShardingSettings WithStateStoreMode(Akka.Cluster.Sharding.StateStoreMode mode) { }\npublic Akka.Cluster.Sharding.ClusterShardingSettings WithTuningParameters(Akka.Cluster.Sharding.TuningParameters tuningParameters) { }\n```\n\n----------------------------------------\n\nTITLE: IDowningProvider Interface Definition\nDESCRIPTION: This snippet defines an interface `IDowningProvider`.  It is likely responsible for providing the configuration and actor properties related to downing (removing) nodes from the cluster, particularly during split-brain scenarios. It includes properties for `DownRemovalMargin` and `DowningActorProps`.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IDowningProvider\n{\n    System.TimeSpan DownRemovalMargin { get; }\n    Akka.Actor.Props DowningActorProps { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UntypedActor with Stash in C#\nDESCRIPTION: Defines abstract classes for UntypedActor with various stash implementations. These classes provide different message queue semantics and stash capabilities for actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_45\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class UntypedActorWithStash : Akka.Actor.UntypedActor, Akka.Actor.IActorStash, Akka.Actor.IWithStash, Akka.Actor.IWithUnrestrictedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IDequeBasedMessageQueueSemantics>\n{\n    protected UntypedActorWithStash() { }\n    public Akka.Actor.IStash Stash { get; set; }\n}\n\npublic abstract class UntypedActorWithUnboundedStash : Akka.Actor.UntypedActor, Akka.Actor.IActorStash, Akka.Actor.IWithUnboundedStash, Akka.Actor.IWithUnrestrictedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics>\n{\n    protected UntypedActorWithUnboundedStash() { }\n    public Akka.Actor.IStash Stash { get; set; }\n}\n\npublic abstract class UntypedActorWithUnrestrictedStash : Akka.Actor.UntypedActor, Akka.Actor.IActorStash, Akka.Actor.IWithUnrestrictedStash\n{\n    protected UntypedActorWithUnrestrictedStash() { }\n    public Akka.Actor.IStash Stash { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DistributedPubSubMessageSerializer for Akka in C#\nDESCRIPTION: Defines a serializer class for distributed publish-subscribe messages in Akka.NET. Extends SerializerWithStringManifest to handle serialization of pub/sub messages to and from binary format.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_23\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DistributedPubSubMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public DistributedPubSubMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object o) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IWriteConsistency Interface for Distributed Writes in C#\nDESCRIPTION: Defines an interface with a Timeout property for write consistency, used to configure the consistency levels for write operations in the distributed data system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IWriteConsistency\n{\n    System.TimeSpan Timeout { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cluster Sharding with Order Role\nDESCRIPTION: HOCON configuration for deploying Cluster Sharding on nodes with the 'order' role, allowing distributed actor management for order processing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/member-roles.md#2025-04-16_snippet_5\n\nLANGUAGE: hocon\nCODE:\n```\nakka\n{\n  cluster\n  {\n    roles = [\"order\"]\n    sharding\n    {\n      role = \"order\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract Transport Adapter in C#\nDESCRIPTION: Defines an abstract class ActorTransportAdapter that extends AbstractTransportAdapter. It provides a base implementation for transport adapters that use actors for managing remote connections.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ActorTransportAdapter : Akka.Remote.Transport.AbstractTransportAdapter\n{\n    public static readonly System.TimeSpan AskTimeout;\n    protected Akka.Actor.IActorRef modreq(System.Runtime.CompilerServices.IsVolatile) manager;\n    protected ActorTransportAdapter(Akka.Remote.Transport.Transport wrappedTransport, Akka.Actor.ActorSystem system) { }\n    protected abstract string ManagerName { get; }\n    protected abstract Akka.Actor.Props ManagerProps { get; }\n    protected override void InterceptAssociate(Akka.Actor.Address remoteAddress, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.AssociationHandle> statusPromise) { }\n    protected override System.Threading.Tasks.Task<Akka.Remote.Transport.IAssociationEventListener> InterceptListen(Akka.Actor.Address listenAddress, System.Threading.Tasks.Task<Akka.Remote.Transport.IAssociationEventListener> listenerTask) { }\n    public override System.Threading.Tasks.Task<bool> Shutdown() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PNCounterDictionary in C#\nDESCRIPTION: Generic distributed counter dictionary implementation that supports increment/decrement operations and delta-based replication.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class PNCounterDictionary<TKey> : Akka.DistributedData.IDeltaReplicatedData, Akka.DistributedData.IDeltaReplicatedData<Akka.DistributedData.PNCounterDictionary<TKey>, Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.PNCounter>.IDeltaOperation>, Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IRemovedNodePruning<Akka.DistributedData.PNCounterDictionary<TKey>>, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.PNCounterDictionary<TKey>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, System.Numerics.BigInteger>>, System.Collections.IEnumerable, System.IEquatable<Akka.DistributedData.PNCounterDictionary<TKey>>\n{\n    public static readonly Akka.DistributedData.PNCounterDictionary<TKey> Empty;\n    public PNCounterDictionary(Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.PNCounter> underlying) { }\n    public int Count { get; }\n    public Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.PNCounter>.IDeltaOperation Delta { get; }\n    public System.Collections.Immutable.IImmutableDictionary<TKey, System.Numerics.BigInteger> Entries { get; }\n    public bool IsEmpty { get; }\n    public System.Numerics.BigInteger this[TKey key] { get; }\n    public System.Type KeyType { get; }\n    public System.Collections.Generic.IEnumerable<TKey> Keys { get; }\n    public System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.UniqueAddress> ModifiedByNodes { get; }\n    public System.Collections.Generic.IEnumerable<System.Numerics.BigInteger> Values { get; }\n    public bool ContainsKey(TKey key) { }\n    public Akka.DistributedData.PNCounterDictionary<TKey> Decrement(Akka.Cluster.Cluster node, TKey key, long delta = 1) { }\n    public Akka.DistributedData.PNCounterDictionary<TKey> Decrement(Akka.Cluster.UniqueAddress node, TKey key, long delta = 1) { }\n    public bool Equals(Akka.DistributedData.PNCounterDictionary<TKey> other) { }\n    public override bool Equals(object obj) { }\n    public System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, System.Numerics.BigInteger>> GetEnumerator() { }\n    public override int GetHashCode() { }\n    public Akka.DistributedData.PNCounterDictionary<TKey> Increment(Akka.Cluster.Cluster node, TKey key, long delta = 1) { }\n    public Akka.DistributedData.PNCounterDictionary<TKey> Increment(Akka.Cluster.UniqueAddress node, TKey key, long delta = 1) { }\n    public Akka.DistributedData.PNCounterDictionary<TKey> Merge(Akka.DistributedData.PNCounterDictionary<TKey> other) { }\n    public Akka.DistributedData.IReplicatedData Merge(Akka.DistributedData.IReplicatedData other) { }\n    public Akka.DistributedData.PNCounterDictionary<TKey> MergeDelta(Akka.DistributedData.ORDictionary<TKey, Akka.DistributedData.PNCounter>.IDeltaOperation delta) { }\n    public bool NeedPruningFrom(Akka.Cluster.UniqueAddress removedNode) { }\n    public Akka.DistributedData.PNCounterDictionary<TKey> Prune(Akka.Cluster.UniqueAddress removedNode, Akka.Cluster.UniqueAddress collapseInto) { }\n    public Akka.DistributedData.PNCounterDictionary<TKey> PruningCleanup(Akka.Cluster.UniqueAddress removedNode) { }\n    public Akka.DistributedData.PNCounterDictionary<TKey> Remove(Akka.Cluster.Cluster node, TKey key) { }\n    public Akka.DistributedData.PNCounterDictionary<TKey> Remove(Akka.Cluster.UniqueAddress node, TKey key) { }\n    public Akka.DistributedData.PNCounterDictionary<TKey> ResetDelta() { }\n    public override string ToString() { }\n    public bool TryGetValue(TKey key, out System.Numerics.BigInteger value) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MinimalLogger Abstract Class in C# for Akka.NET\nDESCRIPTION: The MinimalLogger abstract class extends MinimalActorRef and provides a base implementation for custom loggers in Akka.NET. It includes properties for filtering and path management, and abstract methods for logging and message handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_154\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class MinimalLogger : Akka.Actor.MinimalActorRef\n{\n    protected MinimalLogger() { }\n    public Akka.Event.LogFilterEvaluator Filter { get; }\n    public virtual Akka.Actor.ActorPath Path { get; }\n    public virtual Akka.Actor.IActorRefProvider Provider { get; }\n    protected abstract void Log(object message);\n    protected virtual void TellInternal(object message, Akka.Actor.IActorRef sender) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining UdpConnectedExt Extension in Akka.NET\nDESCRIPTION: Extension for UDP-connected mode operations. Provides access to the UDP connection manager actor. Implements INoSerializationVerificationNeeded to indicate it doesn't need serialization verification.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_186\n\nLANGUAGE: C#\nCODE:\n```\npublic class UdpConnectedExt : Akka.IO.IOExtension, Akka.Actor.INoSerializationVerificationNeeded\n{\n    public UdpConnectedExt(Akka.Actor.ExtendedActorSystem system) { }\n    public UdpConnectedExt(Akka.Actor.ExtendedActorSystem system, Akka.IO.UdpSettings settings) { }\n    public override Akka.Actor.IActorRef Manager { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Logging Level Methods in C#\nDESCRIPTION: Methods for logging at specific levels with support for formatted messages and variable arguments. Includes overloads for different log levels and exception handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_150\n\nLANGUAGE: csharp\nCODE:\n```\npublic static void Log(this Akka.Event.ILoggingAdapter log, Akka.Event.LogLevel level, string format) { }\npublic static void Log(this Akka.Event.ILoggingAdapter log, Akka.Event.LogLevel level, string format, object[] args) { }\npublic static void Log(this Akka.Event.ILoggingAdapter log, Akka.Event.LogLevel level, System.Exception cause, string format, object[] args) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing MixMetricsSelectorBase Abstract Class in C#\nDESCRIPTION: This abstract class extends CapacityMetricsSelector to enable mixing multiple metric selectors. It maintains a collection of selectors and overrides the Capacity method to evaluate node metrics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Net.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class MixMetricsSelectorBase : Akka.Cluster.Metrics.CapacityMetricsSelector\n{\n    protected MixMetricsSelectorBase(System.Collections.Immutable.ImmutableArray<Akka.Cluster.Metrics.CapacityMetricsSelector> selectors) { }\n    public System.Collections.Immutable.ImmutableArray<Akka.Cluster.Metrics.CapacityMetricsSelector> Selectors { get; }\n    public override System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, double> Capacity(System.Collections.Immutable.IImmutableSet<Akka.Cluster.Metrics.Serialization.NodeMetrics> nodeMetrics) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly Metadata and Target Framework Definition in C#\nDESCRIPTION: Assembly-level metadata attributes that define the repository URL and target framework for the Akka.NET library. Sets .NET Standard 2.0 as the target framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.Core.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Implementing Extensions Static Class in Akka.Util.Internal Namespace\nDESCRIPTION: Collection of extension methods for various types including collections and TimeSpan. These extensions provide functional programming patterns like Head, TakeRight, ForEach, and utility methods for dictionary manipulation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_227\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.Util.Internal\n{\n    public class static Extensions\n    {\n        public static System.Collections.Generic.IDictionary<TKey, TValue> AddAndReturn<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> hash, TKey key, TValue value) { }\n        [System.ObsoleteAttribute(\"Use the dictionary setter directly\")]\n        public static void AddOrSet<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> hash, TKey key, TValue value) { }\n        public static T AsInstanceOf<T>(this object self) { }\n        public static string BetweenDoubleQuotes(this string self) { }\n        public static System.Collections.Generic.IEnumerable<T> Concat<[System.Runtime.CompilerServices.NullableAttribute(2)]  T>([System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n                2,\n                1})] this System.Collections.Generic.IEnumerable<T> enumerable, T item) { }\n        public static System.Collections.Generic.IEnumerable<T> Drop<T>(this System.Collections.Generic.IEnumerable<T> self, int count) { }\n        public static void ForEach<T>(this System.Collections.Generic.IEnumerable<T> source, System.Action<T> action) { }\n        public static TValue GetOrElse<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> hash, TKey key, TValue elseValue) { }\n        public static T Head<T>(this System.Collections.Generic.IEnumerable<T> self) { }\n        public static string Join(this System.Collections.Generic.IEnumerable<string> self, string separator) { }\n        public static System.TimeSpan Max(this System.TimeSpan @this, System.TimeSpan other) { }\n        public static System.TimeSpan Min(this System.TimeSpan @this, System.TimeSpan other) { }\n        public static System.Collections.Generic.IEnumerable<string> SplitDottedPathHonouringQuotes(this string path) { }\n        public static System.Collections.Generic.IEnumerable<T> TakeRight<T>(this System.Collections.Generic.IEnumerable<T> self, int n) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TailChopping Routing Logic in C#\nDESCRIPTION: Defines the TailChopping routing logic which sends messages to multiple routees with time intervals, taking the first response. Used for reducing latency at the cost of redundant messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_203\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class TailChopping : Akka.Routing.RoutingLogic\n    {\n        public TailChopping(Akka.Actor.IScheduler scheduler, System.TimeSpan within, System.TimeSpan interval) { }\n        public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Example Persistent Actor Test with Journal Failure\nDESCRIPTION: Example test implementation showing how to test actor behavior when journal fails.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistence-testing.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic class PersistentActorSpec : PersistenceTestKit\n{\n    [Fact]\n    public async Task actor_must_fail_when_journal_will_fail_saving_message()\n    {\n        await WithJournalWrite(write => write.Fail(), () =>\n        {\n            var actor = ActorOf(() => new PersistActor());\n            Watch(actor);\n\n            actor.Tell(\"write\", TestActor);\n            ExpectTerminated(actor);\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HOCON-related Classes in C#\nDESCRIPTION: This snippet shows various classes related to HOCON (Human-Optimized Config Object Notation) parsing and representation, including AkkaConfigurationSection, HoconArray, HoconLiteral, and HoconObject.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_74\n\nLANGUAGE: C#\nCODE:\n```\npublic class AkkaConfigurationSection : System.Configuration.ConfigurationSection\n{\n    public AkkaConfigurationSection() { }\n    public Akka.Configuration.Config AkkaConfig { get; }\n    [System.Configuration.ConfigurationPropertyAttribute(\"hocon\", IsRequired=true)]\n    public Akka.Configuration.Hocon.HoconConfigurationElement Hocon { get; set; }\n}\n\npublic abstract class CDataConfigurationElement : System.Configuration.ConfigurationElement\n{\n    protected const string ContentPropertyName = \"content\";\n    protected CDataConfigurationElement() { }\n    protected override void DeserializeElement(System.Xml.XmlReader reader, bool serializeCollectionKey) { }\n}\n\npublic class HoconArray : System.Collections.Generic.List<Akka.Configuration.Hocon.HoconValue>, Akka.Configuration.Hocon.IHoconElement\n{\n    public HoconArray() { }\n    public System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray() { }\n    public string GetString() { }\n    public bool IsArray() { }\n    public bool IsString() { }\n    public override string ToString() { }\n}\n\npublic class HoconLiteral : Akka.Configuration.Hocon.IHoconElement\n{\n    public HoconLiteral() { }\n    public string Value { get; set; }\n    public System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray() { }\n    public string GetString() { }\n    public bool IsArray() { }\n    public bool IsString() { }\n    public override string ToString() { }\n}\n\npublic class HoconObject : Akka.Configuration.Hocon.IHoconElement\n{\n    public HoconObject() { }\n    public System.Collections.Generic.Dictionary<string, Akka.Configuration.Hocon.HoconValue> Items { get; }\n    [Newtonsoft.Json.JsonIgnoreAttribute()]\n    public System.Collections.Generic.IDictionary<string, object> Unwrapped { get; }\n    public System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray() { }\n    public Akka.Configuration.Hocon.HoconValue GetKey(string key) { }\n    public Akka.Configuration.Hocon.HoconValue GetOrCreateKey(string key) { }\n    public string GetString() { }\n    public bool IsArray() { }\n    public bool IsString() { }\n    public void Merge(Akka.Configuration.Hocon.HoconObject other) { }\n    public override string ToString() { }\n    public string ToString(int indent) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IShardingBufferMessageAdapter Interface in Akka.NET Sharding\nDESCRIPTION: Interface that allows modifying sharding messages when buffering is enabled. This enables to change messages before buffering and after buffering.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n    [Akka.Annotations.InternalApiAttribute()]\n    public interface IShardingBufferMessageAdapter\n    {\n        object Apply(object message, Akka.Actor.IActorContext context);\n        object UnApply(object message, Akka.Actor.IActorContext context);\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Throttle Control Classes in Akka.NET Remote\nDESCRIPTION: Classes for controlling network throttling. SetThrottle sets throttling parameters for a specific address and direction, while SetThrottleAck provides acknowledgment of throttle settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SetThrottle\n{\n    public SetThrottle(Akka.Actor.Address address, Akka.Remote.Transport.ThrottleTransportAdapter.Direction direction, Akka.Remote.Transport.ThrottleMode mode) { }\n    public Akka.Actor.Address Address { get; }\n    public Akka.Remote.Transport.ThrottleTransportAdapter.Direction Direction { get; }\n    public Akka.Remote.Transport.ThrottleMode Mode { get; }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public static bool ==(Akka.Remote.Transport.SetThrottle left, Akka.Remote.Transport.SetThrottle right) { }\n    public static bool !=(Akka.Remote.Transport.SetThrottle left, Akka.Remote.Transport.SetThrottle right) { }\n}\n\npublic sealed class SetThrottleAck\n{\n    public static Akka.Remote.Transport.SetThrottleAck Instance { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterShardingSettings Methods in C#\nDESCRIPTION: Methods for configuring ClusterShardingSettings, including setting coordinator singleton settings, journal plugin ID, lease settings, passivation duration, entity remembering, role, snapshot plugin ID, state store mode, and tuning parameters.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic Akka.Cluster.Sharding.ClusterShardingSettings WithCoordinatorSingletonSettings(Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings coordinatorSingletonSettings) { }\npublic Akka.Cluster.Sharding.ClusterShardingSettings WithJournalPluginId(string journalPluginId) { }\npublic Akka.Cluster.Sharding.ClusterShardingSettings WithLeaseSettings(Akka.Coordination.LeaseUsageSettings leaseSettings) { }\npublic Akka.Cluster.Sharding.ClusterShardingSettings WithPassivateIdleAfter(System.TimeSpan duration) { }\npublic Akka.Cluster.Sharding.ClusterShardingSettings WithRememberEntities(bool rememberEntities) { }\npublic Akka.Cluster.Sharding.ClusterShardingSettings WithRole(string role) { }\npublic Akka.Cluster.Sharding.ClusterShardingSettings WithSnapshotPluginId(string snapshotPluginId) { }\npublic Akka.Cluster.Sharding.ClusterShardingSettings WithStateStoreMode(Akka.Cluster.Sharding.StateStoreMode mode) { }\npublic Akka.Cluster.Sharding.ClusterShardingSettings WithTuningParameters(Akka.Cluster.Sharding.TuningParameters tuningParameters) { }\n```\n\n----------------------------------------\n\nTITLE: Terminated Message Implementation\nDESCRIPTION: Sealed class representing actor termination messages with equality comparison support\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_53\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Terminated : Akka.Actor.IAutoReceivedMessage, Akka.Actor.INoSerializationVerificationNeeded, Akka.Actor.IPossiblyHarmful, Akka.Event.IDeadLetterSuppression, System.IEquatable<Akka.Actor.Terminated>\n{\n    public Terminated(Akka.Actor.IActorRef actorRef, bool existenceConfirmed, bool addressTerminated) { }\n    public Akka.Actor.IActorRef ActorRef { get; }\n    public bool AddressTerminated { get; }\n    public bool ExistenceConfirmed { get; }\n    public bool Equals(Akka.Actor.Terminated other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Scope Abstract Class in Akka.NET\nDESCRIPTION: Abstract base class for defining scopes in Akka.NET. Includes core functionality for scope comparison and composition with fallback scopes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_45\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Scope : System.IEquatable<Akka.Actor.Scope>\n    {\n        public static readonly Akka.Actor.LocalScope Local;\n        protected Scope() { }\n        public abstract Akka.Actor.Scope Copy();\n        public virtual bool Equals(Akka.Actor.Scope other) { }\n        public abstract Akka.Actor.Scope WithFallback(Akka.Actor.Scope other);\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing PostRestartException for Actor Lifecycle Management\nDESCRIPTION: Exception class used when an actor fails during its post-restart phase. Tracks both the immediate cause and the original cause that triggered the restart cycle.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\npublic class PostRestartException : Akka.Actor.ActorInitializationException\n{\n    public PostRestartException(Akka.Actor.IActorRef actor, System.Exception cause, System.Exception originalCause) { }\n    protected PostRestartException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n    public System.Exception OriginalCause { get; }\n    public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Enhancing TestKit for xUnit Integration\nDESCRIPTION: Defines an enhanced `TestKit` class extending `TestKitBase` and implementing `IDisposable` for managing enhanced xUnit test setup with support for output logging and custom configurations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKitXunit2.DotNet.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.TestKit.Xunit2\n{\n    public class TestKit : Akka.TestKit.TestKitBase, System.IDisposable\n    {\n        protected readonly Xunit.Abstractions.ITestOutputHelper Output;\n        public TestKit(Akka.Actor.ActorSystem system = null, Xunit.Abstractions.ITestOutputHelper output = null) { }\n        public TestKit(Akka.Actor.Setup.ActorSystemSetup config, string actorSystemName = null, Xunit.Abstractions.ITestOutputHelper output = null) { }\n        public TestKit(Akka.Configuration.Config config, string actorSystemName = null, Xunit.Abstractions.ITestOutputHelper output = null) { }\n        public TestKit(string config, Xunit.Abstractions.ITestOutputHelper output = null) { }\n        protected static Akka.TestKit.Xunit2.XunitAssertions Assertions { get; }\n        public new static Akka.Configuration.Config DefaultConfig { get; }\n        public new static Akka.Configuration.Config FullDebugConfig { get; }\n        protected virtual void AfterAll() { }\n        protected virtual void Dispose(bool disposing) { }\n        public void Dispose() { }\n        protected void InitializeLogger(Akka.Actor.ActorSystem system) { }\n        protected void InitializeLogger(Akka.Actor.ActorSystem system, string prefix) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IJournalQueryExecutor Interface in C#\nDESCRIPTION: An interface for executing journal queries against a database. Provides methods for creating tables, inserting and deleting batches, and selecting events with various criteria including by persistence ID and tag.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IJournalQueryExecutor\n{\n    Akka.Persistence.Sql.Common.Journal.QueryConfiguration Configuration { get; }\n    System.Threading.Tasks.Task CreateTablesAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken);\n    System.Threading.Tasks.Task DeleteBatchAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string persistenceId, long toSequenceNr);\n    System.Threading.Tasks.Task InsertBatchAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, Akka.Persistence.Sql.Common.Journal.WriteJournalBatch write);\n    System.Threading.Tasks.Task<long> SelectAllEventsAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, long fromOffset, long toOffset, long max, System.Action<Akka.Persistence.Sql.Common.Journal.ReplayedEvent> callback);\n    System.Threading.Tasks.Task<System.Collections.Immutable.ImmutableArray<string>> SelectAllPersistenceIdsAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, long offset);\n    System.Threading.Tasks.Task SelectByPersistenceIdAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string persistenceId, long fromSequenceNr, long toSequenceNr, long max, System.Action<Akka.Persistence.IPersistentRepresentation> callback);\n    System.Threading.Tasks.Task<long> SelectByTagAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string tag, long fromOffset, long toOffset, long max, System.Action<Akka.Persistence.Sql.Common.Journal.ReplayedTaggedMessage> callback);\n    System.Threading.Tasks.Task<long> SelectHighestSequenceNrAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string persistenceId);\n    System.Threading.Tasks.Task<long> SelectHighestSequenceNrAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Shorthand Notation for Cluster Actor Provider in HOCON\nDESCRIPTION: Simplified configuration to specify the cluster actor provider using the shorthand notation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-client.md#2025-04-16_snippet_1\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.provider = cluster\n```\n\n----------------------------------------\n\nTITLE: TestKit Extension Configuration in Akka.NET\nDESCRIPTION: Extension class for providing TestKit settings to actor systems. This extension manages test-specific configurations and settings for Akka.NET test environments.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestKitExtension : Akka.Actor.ExtensionIdProvider<Akka.TestKit.TestKitSettings>\n{\n    public TestKitExtension() { }\n    public override Akka.TestKit.TestKitSettings CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n    public static Akka.TestKit.TestKitSettings For(Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract Serializer Base Class in Akka.NET\nDESCRIPTION: Defines the abstract base class for all serializers in Akka.NET with core methods for serialization and deserialization. Includes methods for handling type-specific deserialization and address-aware serialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_200\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class Serializer\n{\n    protected readonly Akka.Actor.ExtendedActorSystem system;\n    protected Serializer(Akka.Actor.ExtendedActorSystem system) { }\n    public virtual int Identifier { get; }\n    public abstract bool IncludeManifest { get; }\n    public abstract object FromBinary(byte[] bytes, System.Type type);\n    public T FromBinary<T>(byte[] bytes) { }\n    public abstract byte[] ToBinary(object obj);\n    public byte[] ToBinaryWithAddress(Akka.Actor.Address address, object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Discovery Extension Implementation\nDESCRIPTION: Core Discovery extension class that provides access to service discovery functionality in Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class Discovery : Akka.Actor.IExtension\n{\n    public Discovery(Akka.Actor.ExtendedActorSystem system) { }\n    public Akka.Discovery.ServiceDiscovery Default { get; }\n    public static Akka.Discovery.Discovery Get(Akka.Actor.ActorSystem system) { }\n    public Akka.Discovery.ServiceDiscovery LoadServiceDiscovery(string method) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Streams with Sink.ActorRef in C#\nDESCRIPTION: This snippet demonstrates testing a stream using Sink.ActorRef to send incoming elements to a TestProbe, allowing for element-by-element assertions and completion verification.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/testingstreams.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar sourceUnderTest = Source.Tick(TimeSpan.FromSeconds(0), TimeSpan.FromMilliseconds(200), \"Tick\");\n\nvar probe = CreateTestProbe();\nvar cancellable = sourceUnderTest.To(Sink.ActorRef<string>(probe.Ref, \"completed\")).Run(materializer);\n\nprobe.ExpectMsg(\"Tick\");\nprobe.ExpectNoMsg(TimeSpan.FromMilliseconds(100));\nprobe.ExpectMsg(\"Tick\", TimeSpan.FromMilliseconds(200));\ncancellable.Cancel();\nprobe.ExpectMsg(\"completed\");\n```\n\n----------------------------------------\n\nTITLE: Defining UdpConnected Class in C# for Akka.NET\nDESCRIPTION: This snippet implements the UdpConnected class, which extends ExtensionIdProvider. It includes various nested classes for UDP-related commands and events, such as Connect, Disconnect, and Received.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_162\n\nLANGUAGE: C#\nCODE:\n```\npublic class UdpConnected : Akka.Actor.ExtensionIdProvider<Akka.IO.UdpConnectedExt>\n{\n    public static readonly Akka.IO.UdpConnected Instance;\n    public UdpConnected() { }\n    public override Akka.IO.UdpConnectedExt CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n    public abstract class Command : Akka.IO.UdpConnected.Message\n    {\n        protected Command() { }\n        public object FailureMessage { get; }\n    }\n    // ... (other nested classes)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MultiVersionVector Class in Akka.NET DistributedData Module - C#\nDESCRIPTION: Definition of MultiVersionVector class that extends VersionVector in Akka's DistributedData module. This class manages version information across cluster nodes for conflict resolution, providing methods for incrementing versions, merging vectors, and pruning removed nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class MultiVersionVector : Akka.DistributedData.VersionVector\n{\n    public MultiVersionVector(params System.Collections.Generic.KeyValuePair<, >[] nodeVersions) { }\n    public MultiVersionVector(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<Akka.Cluster.UniqueAddress, long>> versions) { }\n    public MultiVersionVector(System.Collections.Immutable.ImmutableDictionary<Akka.Cluster.UniqueAddress, long> nodeVersions) { }\n    public override int Count { get; }\n    public override bool IsEmpty { get; }\n    public override System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.UniqueAddress> ModifiedByNodes { get; }\n    public override System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<Akka.Cluster.UniqueAddress, long>> VersionEnumerator { get; }\n    public override bool Contains(Akka.Cluster.UniqueAddress node) { }\n    public override int GetHashCode() { }\n    public override Akka.DistributedData.VersionVector Increment(Akka.Cluster.UniqueAddress node) { }\n    public override Akka.DistributedData.VersionVector Merge(Akka.DistributedData.VersionVector other) { }\n    public override bool NeedPruningFrom(Akka.Cluster.UniqueAddress removedNode) { }\n    public override Akka.DistributedData.VersionVector Prune(Akka.Cluster.UniqueAddress removedNode, Akka.Cluster.UniqueAddress collapseInto) { }\n    public override Akka.DistributedData.VersionVector PruningCleanup(Akka.Cluster.UniqueAddress removedNode) { }\n    public override string ToString() { }\n    public override long VersionAt(Akka.Cluster.UniqueAddress node) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ShardedDaemonProcessSettings Class in Akka.NET Sharding\nDESCRIPTION: This class defines the settings for a ShardedDaemonProcess, including the keep-alive interval, the role, and the sharding settings.  It allows configuring the behavior of the sharded daemon process.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_23\n\nLANGUAGE: csharp\nCODE:\n```\n    [Akka.Annotations.ApiMayChangeAttribute()]\n    [System.Runtime.CompilerServices.NullableAttribute(0)]\n    public sealed class ShardedDaemonProcessSettings\n    {\n        public readonly System.TimeSpan KeepAliveInterval;\n        [System.Runtime.CompilerServices.NullableAttribute(2)]\n        public readonly string Role;\n        [System.Runtime.CompilerServices.NullableAttribute(2)]\n        public readonly Akka.Cluster.Sharding.ClusterShardingSettings ShardingSettings;\n        public static Akka.Cluster.Sharding.ShardedDaemonProcessSettings Create(Akka.Actor.ActorSystem system) { }\n        public static Akka.Cluster.Sharding.ShardedDaemonProcessSettings FromConfig(Akka.Configuration.Config config) { }\n        public Akka.Cluster.Sharding.ShardedDaemonProcessSettings WithKeepAliveInterval(System.TimeSpan keepAliveInterval) { }\n        public Akka.Cluster.Sharding.ShardedDaemonProcessSettings WithRole(string role) { }\n        public Akka.Cluster.Sharding.ShardedDaemonProcessSettings WithShardingSettings(Akka.Cluster.Sharding.ClusterShardingSettings shardingSettings) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing InternalActivateFsmLogging Class in C#\nDESCRIPTION: A singleton class used to activate logging for Finite State Machines in Akka.NET. It exposes a single static Instance property.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_58\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic class InternalActivateFsmLogging\n{\n    public static Akka.Actor.Internal.InternalActivateFsmLogging Instance { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RouterEnvelope and RouterManagementMessage Classes in C#\nDESCRIPTION: Definitions of utility classes for router message handling. RouterEnvelope wraps messages sent to routers, while RouterManagementMessage serves as a base class for router control messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_195\n\nLANGUAGE: C#\nCODE:\n```\npublic class RouterEnvelope\n{\n    public RouterEnvelope(object message) { }\n    public object Message { get; }\n}\n\npublic abstract class RouterManagementMessage\n{\n    protected RouterManagementMessage() { }\n}\n\npublic class static RouterMessage\n{\n    public static readonly Akka.Routing.GetRoutees GetRoutees;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NodeMetrics class in C# for Akka.NET\nDESCRIPTION: Implements a sealed class for node metrics, including properties for address, timestamp, and metrics. It implements interfaces for deep cloning, message handling, and equality comparison.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Core.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class NodeMetrics : Google.Protobuf.IDeepCloneable<Akka.Cluster.Metrics.Serialization.NodeMetrics>, Google.Protobuf.IMessage, Google.Protobuf.IMessage<Akka.Cluster.Metrics.Serialization.NodeMetrics>, System.IEquatable<Akka.Cluster.Metrics.Serialization.NodeMetrics>\n{\n    public const int AddressIndexFieldNumber = 1;\n    public const int MetricsFieldNumber = 3;\n    public const int TimestampFieldNumber = 2;\n    public NodeMetrics() { }\n    public NodeMetrics(Akka.Cluster.Metrics.Serialization.NodeMetrics other) { }\n    public NodeMetrics(Akka.Actor.Address address, long timestamp, System.Collections.Generic.IEnumerable<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric> metrics) { }\n    public Akka.Actor.Address Address { get; }\n    public int AddressIndex { get; set; }\n    public static Google.Protobuf.Reflection.MessageDescriptor Descriptor { get; }\n    public Google.Protobuf.Collections.RepeatedField<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric> Metrics { get; }\n    public static Google.Protobuf.MessageParser<Akka.Cluster.Metrics.Serialization.NodeMetrics> Parser { get; }\n    public long Timestamp { get; set; }\n    public int CalculateSize() { }\n    public Akka.Cluster.Metrics.Serialization.NodeMetrics Clone() { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Bounded Mailbox Types in C#\nDESCRIPTION: Two mailbox implementations with bounded capacity and push timeout semantics. BoundedDequeBasedMailbox uses a double-ended queue, while BoundedMailbox uses a regular queue. Both are configured with settings from the actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_83\n\nLANGUAGE: csharp\nCODE:\n```\npublic class BoundedDequeBasedMailbox : Akka.Dispatch.MailboxType, Akka.Dispatch.IProducesMessageQueue<Akka.Dispatch.MessageQueues.BoundedDequeMessageQueue>, Akka.Dispatch.IProducesPushTimeoutSemanticsMailbox\n{\n    public BoundedDequeBasedMailbox(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }\n    public int Capacity { get; }\n    public System.TimeSpan PushTimeout { get; }\n    public override Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }\n}\n\npublic sealed class BoundedMailbox : Akka.Dispatch.MailboxType, Akka.Dispatch.IProducesMessageQueue<Akka.Dispatch.MessageQueues.BoundedMessageQueue>, Akka.Dispatch.IProducesPushTimeoutSemanticsMailbox\n{\n    public BoundedMailbox(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }\n    public int Capacity { get; }\n    public System.TimeSpan PushTimeout { get; }\n    public override Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Cluster Metrics Serialization Classes in C#\nDESCRIPTION: Classes for serializing and deserializing cluster metrics messages. Includes the ClusterMetricsMessageSerializer for serialization, interface for message identification, and classes for representing metrics gossip between nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.DotNet.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterMetricsMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public ClusterMetricsMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object o) { }\n    public override byte[] ToBinary(object obj) { }\n}\n[Akka.Annotations.InternalApiAttribute()]\npublic interface IClusterMetricMessage { }\n[Akka.Annotations.InternalApiAttribute()]\npublic sealed class MetricsGossip\n{\n    public static readonly Akka.Cluster.Metrics.Serialization.MetricsGossip Empty;\n    public MetricsGossip(System.Collections.Immutable.IImmutableSet<Akka.Cluster.Metrics.Serialization.NodeMetrics> nodes) { }\n    public System.Collections.Immutable.IImmutableSet<Akka.Cluster.Metrics.Serialization.NodeMetrics> Nodes { get; }\n    public Akka.Cluster.Metrics.Serialization.MetricsGossip Filter(System.Collections.Immutable.IImmutableSet<Akka.Actor.Address> includeNodes) { }\n    public Akka.Cluster.Metrics.Serialization.MetricsGossip Merge(Akka.Cluster.Metrics.Serialization.MetricsGossip otherGossip) { }\n    public Akka.Util.Option<Akka.Cluster.Metrics.Serialization.NodeMetrics> NodeMetricsFor(Akka.Actor.Address address) { }\n    public Akka.Cluster.Metrics.Serialization.MetricsGossip Remove(Akka.Actor.Address node) { }\n    public static Akka.Cluster.Metrics.Serialization.MetricsGossip +(Akka.Cluster.Metrics.Serialization.MetricsGossip gossip, Akka.Cluster.Metrics.Serialization.NodeMetrics newNodeMetrics) { }\n}\n[Akka.Annotations.InternalApiAttribute()]\npublic sealed class MetricsGossipEnvelope : Akka.Cluster.Metrics.Serialization.IClusterMetricMessage, Akka.Event.IDeadLetterSuppression\n{\n    public MetricsGossipEnvelope(Akka.Actor.Address fromAddress, Akka.Cluster.Metrics.Serialization.MetricsGossip gossip, bool reply) { }\n    public Akka.Actor.Address FromAddress { get; }\n    public Akka.Cluster.Metrics.Serialization.MetricsGossip Gossip { get; }\n    public bool Reply { get; }\n}\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class NodeMetrics : System.IEquatable<Akka.Cluster.Metrics.Serialization.NodeMetrics>\n{\n    public NodeMetrics(Akka.Actor.Address address, long timestamp, System.Collections.Generic.IEnumerable<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric> metrics) { }\n    public Akka.Actor.Address Address { get; }\n    public System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric> Metrics { get; }\n    public long Timestamp { get; }\n    public bool Equals(Akka.Cluster.Metrics.Serialization.NodeMetrics other) { }\n    public override int GetHashCode() { }\n    public Akka.Cluster.Metrics.Serialization.NodeMetrics Merge(Akka.Cluster.Metrics.Serialization.NodeMetrics that) { }\n    [return: System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})]\n    public Akka.Util.Option<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric> Metric(string name) { }\n    public bool SameAs(Akka.Cluster.Metrics.Serialization.NodeMetrics that) { }\n}\n```\n\n----------------------------------------\n\nTITLE: RemoteSettings Configuration Class in C#\nDESCRIPTION: Configuration class that holds remote system settings including timeouts, buffer sizes, transport settings and security configurations. Initialized from Akka.NET configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class RemoteSettings\n{\n    public static readonly string AkkaScheme;\n    public RemoteSettings(Akka.Configuration.Config config) { }\n    public System.Collections.Generic.IDictionary<string, string> Adapters { get; set; }\n    public System.TimeSpan BackoffPeriod { get; set; }\n    // Additional properties...\n}\n```\n\n----------------------------------------\n\nTITLE: TimeoutSettings Class Definition\nDESCRIPTION: Defines timeout-related settings for leases, including heartbeat interval, heartbeat timeout, and operation timeout. Provides factory methods and methods for creating new instances with modified settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.Net.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class TimeoutSettings\n{\n    public TimeoutSettings(System.TimeSpan heartbeatInterval, System.TimeSpan heartbeatTimeout, System.TimeSpan operationTimeout) { }\n    public System.TimeSpan HeartbeatInterval { get; }\n    public System.TimeSpan HeartbeatTimeout { get; }\n    public System.TimeSpan OperationTimeout { get; }\n    public static Akka.Coordination.TimeoutSettings Create(Akka.Configuration.Config config) { }\n    public override string ToString() { }\n    public Akka.Coordination.TimeoutSettings WithHeartbeatInterval(System.TimeSpan heartbeatInterval) { }\n    public Akka.Coordination.TimeoutSettings WithHeartbeatTimeout(System.TimeSpan heartbeatTimeout) { }\n    public Akka.Coordination.TimeoutSettings withOperationTimeout(System.TimeSpan operationTimeout) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting Messages To Asynchronously with Akka.Persistence and C#\nDESCRIPTION: This method asynchronously deletes all persistent messages up to and including the specified 'toSequenceNr'. It is protected by a circuit breaker and requires a valid persistence ID. The operation must be atomic, ensuring that either all specified messages are deleted or none are. The method is part of a broader implementation for managing persistence in Akka.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/custom-persistence-provider.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nprotected abstract Task DeleteMessagesToAsync(\n    string persistenceId, \n    long toSequenceNr)\n\n```\n\n----------------------------------------\n\nTITLE: Implementing ByteArraySerializer in C#\nDESCRIPTION: A serializer implementation for byte arrays that passes them through without modification. This is useful for efficiently serializing raw binary data in Akka.NET applications.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_207\n\nLANGUAGE: C#\nCODE:\n```\npublic class ByteArraySerializer : Akka.Serialization.Serializer\n    {\n        public ByteArraySerializer(Akka.Actor.ExtendedActorSystem system) { }\n        public override bool IncludeManifest { get; }\n        public override object FromBinary(byte[] bytes, System.Type type) { }\n        public override byte[] ToBinary(object obj) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Lease Abstract Class Definition in Akka.Coordination\nDESCRIPTION: Defines the abstract Lease class that provides methods for acquiring, checking, and releasing distributed leases. The class includes methods for lease acquisition with optional callback for lease loss notification.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.Net.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Lease\n{\n    public Lease(Akka.Coordination.LeaseSettings settings) { }\n    public Akka.Coordination.LeaseSettings Settings { get; }\n    public abstract System.Threading.Tasks.Task<bool> Acquire();\n    public abstract System.Threading.Tasks.Task<bool> Acquire(System.Action<System.Exception> leaseLostCallback);\n    public abstract bool CheckLease();\n    public abstract System.Threading.Tasks.Task<bool> Release();\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly Metadata and Framework Target Declaration\nDESCRIPTION: Declares assembly metadata for repository URL and targets .NET Standard 2.0 framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceInMemoryQuery.Net.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: TransportOperation Abstract Class Definition (C#)\nDESCRIPTION: Base class for transport operations that defines common functionality for transport-related operations. Implements INoSerializationVerificationNeeded for serialization exclusion.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class TransportOperation : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public static readonly System.TimeSpan AskTimeout;\n    protected TransportOperation() { }\n}\n```\n\n----------------------------------------\n\nTITLE: IOExtension Abstract Class for IO Extensions in Akka.NET\nDESCRIPTION: Provides the base class for IO-related extensions in Akka.NET with an abstract Manager property. This class is the foundation for specific IO extensions like DnsExt.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_159\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class IOExtension : Akka.Actor.IExtension\n    {\n        protected IOExtension() { }\n        public abstract Akka.Actor.IActorRef Manager { get; }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Downing Providers in C#\nDESCRIPTION: Defines downing providers NoDowning and SplitBrainResolver that handle unreachable nodes in the cluster. SplitBrainResolver implements a strategy for resolving network partitions in the cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.DotNet.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class NoDowning : Akka.Cluster.IDowningProvider\n{\n    public NoDowning(Akka.Actor.ActorSystem system, Akka.Cluster.Cluster cluster) { }\n    public System.TimeSpan DownRemovalMargin { get; }\n    public Akka.Actor.Props DowningActorProps { get; }\n}\npublic sealed class SplitBrainResolver : Akka.Cluster.IDowningProvider\n{\n    public SplitBrainResolver(Akka.Actor.ActorSystem system, Akka.Cluster.Cluster cluster) { }\n    public System.TimeSpan DownRemovalMargin { get; }\n    public Akka.Actor.Props DowningActorProps { get; }\n    public System.TimeSpan StableAfter { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Snapshot Properties in C#\nDESCRIPTION: This snippet defines properties for a snapshot, including sequence number, snapshot data, and timestamp.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_63\n\nLANGUAGE: C#\nCODE:\n```\n        public long SequenceNr { get; set; }\n        public object Snapshot { get; set; }\n        public long Timestamp { get; set; }\n```\n\n----------------------------------------\n\nTITLE: Array Whitespace Behavior Examples in HOCON\nDESCRIPTION: Illustrates how whitespace affects array interpretation in HOCON. Non-newline whitespace results in concatenation rather than separate elements, while newlines act as element separators.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/hocon.md#2025-04-16_snippet_6\n\nLANGUAGE: hocon\nCODE:\n```\n// this is an array with one element, the string \"1 2 3 4\"\n[ 1 2 3 4 ]\n// this is an array of four integers\n[ 1\n  2\n  3\n  4 ]\n\n// an array of one element, the array [ 1, 2, 3, 4 ]\n[ [ 1, 2 ] [ 3, 4 ] ]\n// an array of two arrays\n[ [ 1, 2 ]\n  [ 3, 4 ] ]\n```\n\n----------------------------------------\n\nTITLE: Defining DeleteSnapshotsSuccess Class\nDESCRIPTION: This snippet defines the `DeleteSnapshotsSuccess` class, indicating the successful deletion of multiple snapshots based on provided criteria in Akka.Persistence. It implements interfaces such as `INoSerializationVerificationNeeded`, `IPersistenceMessage`, `ISnapshotMessage`, `ISnapshotResponse`, and `IEquatable<DeleteSnapshotsSuccess>`. The class contains the `SnapshotSelectionCriteria` that were used for the deletion operation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\n\"public sealed class DeleteSnapshotsSuccess : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage, Akka.Persistence.ISnapshotResponse, System.IEquatable<Akka.Persistence.DeleteSnapshotsSuccess>\n    {\n        public DeleteSnapshotsSuccess(Akka.Persistence.SnapshotSelectionCriteria criteria) { }\n        public Akka.Persistence.SnapshotSelectionCriteria Criteria { get; }\n        public bool Equals(Akka.Persistence.DeleteSnapshotsSuccess other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n    }\"\n```\n\n----------------------------------------\n\nTITLE: Defining Core Snapshot Interfaces in C#\nDESCRIPTION: Defines the base interfaces for snapshot functionality including ISnapshotMessage, ISnapshotRequest, ISnapshotResponse and ISnapshotter with methods for managing snapshots.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ISnapshotMessage : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage { }\npublic interface ISnapshotRequest : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage { }\npublic interface ISnapshotResponse : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage { }\npublic interface ISnapshotter\n{\n    long SnapshotSequenceNr { get; }\n    string SnapshotterId { get; }\n    void DeleteSnapshot(long sequenceNr);\n    void DeleteSnapshots(Akka.Persistence.SnapshotSelectionCriteria criteria);\n    void LoadSnapshot(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria, long toSequenceNr);\n    void SaveSnapshot(object snapshot);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Death Watch Notification System Message in Akka.NET\nDESCRIPTION: Defines a system message that notifies actors about the termination of watched actors. Includes information about whether the actor's existence was confirmed and if the termination was due to address termination.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_117\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DeathWatchNotification : Akka.Dispatch.SysMsg.SystemMessage, Akka.Event.IDeadLetterSuppression\n{\n    public DeathWatchNotification(Akka.Actor.IActorRef actor, bool existenceConfirmed, bool addressTerminated) { }\n    public Akka.Actor.IActorRef Actor { get; }\n    public bool AddressTerminated { get; }\n    public bool ExistenceConfirmed { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: SnapshotEntry Class for Storing Snapshot Data\nDESCRIPTION: Defines a data structure for storing snapshot entries, including persistence ID, sequence number, timestamp, serialization manifest, and the actual payload (snapshot data). This class represents the data model for snapshots in the SQL store.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic class SnapshotEntry\n{\n    public readonly string Manifest;\n    public readonly object Payload;\n    public readonly string PersistenceId;\n    public readonly long SequenceNr;\n    public readonly System.DateTime Timestamp;\n    public SnapshotEntry(string persistenceId, long sequenceNr, System.DateTime timestamp, string manifest, object payload) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Transport Infrastructure in C#\nDESCRIPTION: Test implementation of transport layer components including association handles and behavior switches for testing network scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestTransport : Akka.Remote.Transport.Transport\n{\n    public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<Akka.Actor.Address, Akka.Remote.Transport.AssociationHandle> AssociateBehavior;\n    public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<Akka.Remote.Transport.TestAssociationHandle, bool> DisassociateBehavior;\n    public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<bool, System.ValueTuple<Akka.Actor.Address, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.IAssociationEventListener>>> ListenBehavior;\n    public readonly Akka.Actor.Address LocalAddress;\n    public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<bool, bool> ShutdownBehavior;\n    public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<System.ValueTuple<Akka.Remote.Transport.TestAssociationHandle, Google.Protobuf.ByteString>, bool> WriteBehavior;\n    public TestTransport(Akka.Actor.ActorSystem system, Akka.Configuration.Config conf) { }\n    public TestTransport(Akka.Actor.Address localAddress, Akka.Remote.Transport.AssociationRegistry registry, long maximumPayloadBytes = 32000, string schemeIdentifier = \"test\") { }\n}\n```\n\n----------------------------------------\n\nTITLE: Untyped Actor Base Classes in C#\nDESCRIPTION: Abstract base classes for untyped actors with different stashing capabilities. Includes base UntypedActor and variants with bounded and unbounded message stashing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_54\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class UntypedActor : Akka.Actor.ActorBase\n{\n    protected UntypedActor() { }\n    protected static Akka.Actor.IUntypedActorContext Context { get; }\n    protected void Become(Akka.Actor.UntypedReceive receive) { }\n    protected void BecomeStacked(Akka.Actor.UntypedReceive receive) { }\n    protected abstract void OnReceive(object message);\n    protected virtual bool Receive(object message) { }\n    protected void RunTask(System.Action action) { }\n    protected void RunTask(System.Func<System.Threading.Tasks.Task> action) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Base Socket Option Classes in Akka.NET\nDESCRIPTION: Abstract classes that define the base functionality for socket options. The SocketOption class provides virtual methods for different socket lifecycle stages, while SocketOptionV2 extends it with additional functionality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_151\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class SoForwarders\n{\n    protected SoForwarders() { }\n}\npublic abstract class SocketOption\n{\n    protected SocketOption() { }\n    public virtual void AfterConnect(System.Net.Sockets.Socket s) { }\n    public virtual void BeforeConnect(System.Net.Sockets.Socket s) { }\n    public virtual void BeforeDatagramBind(System.Net.Sockets.Socket ds) { }\n    public virtual void BeforeServerSocketBind(System.Net.Sockets.Socket ss) { }\n}\npublic abstract class SocketOptionV2 : Akka.IO.Inet.SocketOption\n{\n    protected SocketOptionV2() { }\n    public virtual void AfterBind(System.Net.Sockets.Socket s) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract Key<T> Class in C#\nDESCRIPTION: Implements the IKey and IKey<T> interfaces with a generic type parameter T. Provides basic key functionality including equality comparison and string conversion.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Key<T> : Akka.DistributedData.IKey, Akka.DistributedData.IKey<T>, Akka.DistributedData.IReplicatedDataSerialization\n    where T : Akka.DistributedData.IReplicatedData\n{\n    protected Key(string id) { }\n    public string Id { get; }\n    public bool Equals(Akka.DistributedData.IKey key) { }\n    public virtual bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n    public static string op_Implicit(Akka.DistributedData.Key<T> key) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DeadLetterActorRef in C#\nDESCRIPTION: Handles messages sent to non-existent actors by implementing special message handling for dead letters. Extends EmptyLocalActorRef to provide dead letter functionality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic class DeadLetterActorRef : Akka.Actor.EmptyLocalActorRef\n{\n    public DeadLetterActorRef(Akka.Actor.IActorRefProvider provider, Akka.Actor.ActorPath path, Akka.Event.EventStream eventStream) { }\n    protected override bool SpecialHandle(object message, Akka.Actor.IActorRef sender) { }\n    protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TokenBucket Abstract Class\nDESCRIPTION: Abstract base class for token bucket rate limiting implementations. It defines core functionality for allocating tokens over time and provides methods to request tokens for operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_219\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic abstract class TokenBucket\n{\n    protected TokenBucket(long capacity, long ticksBetweenTokens) { }\n    public abstract long CurrentTime { get; }\n    public void Init() { }\n    public long Offer(long cost) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MetricsSelector class in C# for Akka.NET\nDESCRIPTION: Implements a sealed class for metrics selection, including properties for serializer ID, manifest, and data. It implements interfaces for deep cloning, message handling, and equality comparison.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Core.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class MetricsSelector : Google.Protobuf.IDeepCloneable<Akka.Cluster.Metrics.Serialization.MetricsSelector>, Google.Protobuf.IMessage, Google.Protobuf.IMessage<Akka.Cluster.Metrics.Serialization.MetricsSelector>, System.IEquatable<Akka.Cluster.Metrics.Serialization.MetricsSelector>\n{\n    public const int DataFieldNumber = 3;\n    public const int ManifestFieldNumber = 2;\n    public const int SerializerIdFieldNumber = 1;\n    public MetricsSelector() { }\n    public MetricsSelector(Akka.Cluster.Metrics.Serialization.MetricsSelector other) { }\n    public Google.Protobuf.ByteString Data { get; set; }\n    public static Google.Protobuf.Reflection.MessageDescriptor Descriptor { get; }\n    public string Manifest { get; set; }\n    public static Google.Protobuf.MessageParser<Akka.Cluster.Metrics.Serialization.MetricsSelector> Parser { get; }\n    public uint SerializerId { get; set; }\n    public int CalculateSize() { }\n    public Akka.Cluster.Metrics.Serialization.MetricsSelector Clone() { }\n    public override bool Equals(object other) { }\n    public bool Equals(Akka.Cluster.Metrics.Serialization.MetricsSelector other) { }\n    public override int GetHashCode() { }\n    public void MergeFrom(Akka.Cluster.Metrics.Serialization.MetricsSelector other) { }\n    public void MergeFrom(Google.Protobuf.CodedInputStream input) { }\n    public override string ToString() { }\n    public void WriteTo(Google.Protobuf.CodedOutputStream output) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterSingletonManager for Akka in C#\nDESCRIPTION: Defines the ClusterSingletonManager that manages singleton actor instances across a cluster. Implements Finite State Machine (FSM) for handling lifecycle and provides factory methods for creating Props.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_25\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n        0,\n        1})]\npublic sealed class ClusterSingletonManager : Akka.Actor.FSM<Akka.Cluster.Tools.Singleton.ClusterSingletonState, Akka.Cluster.Tools.Singleton.IClusterSingletonData>\n{\n    public ClusterSingletonManager(Akka.Actor.Props singletonProps, object terminationMessage, Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings settings) { }\n    [System.ObsoleteAttribute(\"Deprecated and will be removed in v1.6, please use ClusterSingleton.DefaultConfig\" +\n        \"() instead. Since 1.5.32.\")]\n    public static Akka.Configuration.Config DefaultConfig() { }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n    public static Akka.Actor.Props Props(Akka.Actor.Props singletonProps, Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings settings) { }\n    public static Akka.Actor.Props Props(Akka.Actor.Props singletonProps, object terminationMessage, Akka.Cluster.Tools.Singleton.ClusterSingletonManagerSettings settings) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SerializerDetails Class in Akka.NET\nDESCRIPTION: Defines a SerializerDetails class that associates a serializer instance with an alias and a set of types it can handle. Used for registering serializers with the serialization system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_201\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class SerializerDetails\n{\n    public string Alias { get; }\n    public Akka.Serialization.Serializer Serializer { get; }\n    public System.Collections.Immutable.ImmutableHashSet<System.Type> UseFor { get; }\n    public static Akka.Serialization.SerializerDetails Create(string alias, Akka.Serialization.Serializer serializer, System.Collections.Immutable.ImmutableHashSet<System.Type> useFor) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WildcardMatch Static Class in C#\nDESCRIPTION: Extension methods for string pattern matching with wildcard support, useful for simple pattern matching operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_241\n\nLANGUAGE: C#\nCODE:\n```\npublic class static WildcardMatch\n{\n    public static bool Like(this string text, string pattern, bool caseSensitive = False) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IPruningState Interface for Node Removal in Distributed Data\nDESCRIPTION: Defines the IPruningState interface for managing pruning operations when nodes are removed from the cluster. It provides methods to track seen nodes and merge pruning states.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IPruningState\n{\n    Akka.DistributedData.IPruningState AddSeen(Akka.Actor.Address node);\n    Akka.DistributedData.IPruningState Merge(Akka.DistributedData.IPruningState other);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Common Interfaces and Utility Classes for Akka.NET Logging\nDESCRIPTION: Defines interfaces and utility classes used throughout the Akka.NET logging system, including marker interfaces for queue semantics and specialized utility classes for log source handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_143\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IDeadLetterSuppression { }\npublic interface ILoggerMessageQueueSemantics : Akka.Dispatch.ISemantics { }\n\npublic class DummyClassForStringSources\n{\n    public DummyClassForStringSources() { }\n}\n\npublic enum LogFilterDecision\n{\n    Keep = 0,\n    Drop = 1,\n    NoDecision = 2,\n}\n\npublic class InitializeLogger : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public InitializeLogger(Akka.Event.LoggingBus loggingBus) { }\n    public Akka.Event.LoggingBus LoggingBus { get; }\n}\n\npublic abstract class LogEvent : Akka.Actor.INoSerializationVerificationNeeded\n{\n    protected LogEvent() { }\n    public System.Exception Cause { get; set; }\n    public System.Type LogClass { get; set; }\n    public string LogSource { get; set; }\n    public object Message { get; set; }\n    public System.Threading.Thread Thread { get; }\n    public System.DateTime Timestamp { get; }\n    public abstract Akka.Event.LogLevel LogLevel();\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Async Stream Processing with Operator Fusion\nDESCRIPTION: Demonstrates how to use async boundaries to enable parallel processing in Akka.NET streams by creating separate processing regions\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/basics.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nSource.From(new[] {1, 2, 3})\n    .Select(x => x + 1)\n    .Async()\n    .Select(x => x*2)\n    .To(Sink.Ignore<int>());\n```\n\n----------------------------------------\n\nTITLE: Implementing SnapshotOffer Class in C#\nDESCRIPTION: Defines a sealed class for snapshot offers in Akka.NET persistence with metadata and snapshot content support. Implements IEquatable for comparison functionality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SnapshotOffer : System.IEquatable<Akka.Persistence.SnapshotOffer>\n{\n    public SnapshotOffer(Akka.Persistence.SnapshotMetadata metadata, object snapshot) { }\n    public Akka.Persistence.SnapshotMetadata Metadata { get; }\n    public object Snapshot { get; }\n    public bool Equals(Akka.Persistence.SnapshotOffer other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: IConsistentHashable Interface in Akka.NET Routing\nDESCRIPTION: Defines an interface for objects that can be used with consistent hash routing. Implementing classes must provide a ConsistentHashKey property that will be used for consistent hash routing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_175\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IConsistentHashable\n{\n    object ConsistentHashKey { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Headless Actor in Akka.NET\nDESCRIPTION: Implementation of a headless actor class that serves as the core processing unit for the headless service. It inherits from ReceiveActor and handles actor lifecycle events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/deployment/headless-service.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/examples/HeadlessService/AkkaHeadlesssService/HeadlessActor.cs?name=headless-actor)]\n```\n\n----------------------------------------\n\nTITLE: Configuring Akka.NET Metrics Collector Settings\nDESCRIPTION: Detailed configuration for the metrics collector component including collection intervals, sampling frequency, and gossip settings. Specifies how metrics are gathered and distributed across the cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-metrics.md#2025-04-16_snippet_9\n\nLANGUAGE: hocon\nCODE:\n```\ncollector {\n  enabled = on\n  provider = \"\"\n  fallback = true\n  sample-interval = 3s\n  gossip-interval = 3s\n  moving-average-half-life = 12s\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AsyncWriteJournal Abstract Class in C#\nDESCRIPTION: Abstract base class for asynchronous journal implementations. Provides methods for writing, deleting, and replaying persistent messages with async Task-based API.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AsyncWriteJournal : Akka.Persistence.Journal.WriteJournalBase, Akka.Persistence.Journal.IAsyncRecovery\n{\n    protected readonly bool CanPublish;\n    protected AsyncWriteJournal() { }\n    protected abstract System.Threading.Tasks.Task DeleteMessagesToAsync(string persistenceId, long toSequenceNr);\n    public abstract System.Threading.Tasks.Task<long> ReadHighestSequenceNrAsync(string persistenceId, long fromSequenceNr);\n    protected virtual bool Receive(object message) { }\n    protected virtual bool ReceivePluginInternal(object message) { }\n    protected bool ReceiveWriteJournal(object message) { }\n    public abstract System.Threading.Tasks.Task ReplayMessagesAsync(Akka.Actor.IActorContext context, string persistenceId, long fromSequenceNr, long toSequenceNr, long max, System.Action<Akka.Persistence.IPersistentRepresentation> recoveryCallback);\n    protected static System.Exception TryUnwrapException(System.Exception e) { }\n    protected abstract System.Threading.Tasks.Task<System.Collections.Immutable.IImmutableList<System.Exception>> WriteMessagesAsync(System.Collections.Generic.IEnumerable<Akka.Persistence.AtomicWrite> messages);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating RunnableGraph with Explicit Port References in C#\nDESCRIPTION: This snippet shows an alternative way to create the same complex graph as before, but with explicit port references and without using the implicit Add() method for linear stages. It demonstrates the flexibility in constructing graphs.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/modularitycomposition.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nRunnableGraph.FromGraph(GraphDsl.Create(builder =>\n{\n    var b = builder.Add(new Broadcast<int>(2));\n    var c = builder.Add(new Merge<int>(2));\n    var e = builder.Add(new Balance<int>(2));\n    var f = builder.Add(new Merge<int>(2));\n\n    builder.To(c.In(0)).From(f.Out);\n\n    builder.From(Source.Single(0)).To(b.In);\n    builder.From(b.Out(0)).To(c.In(1));\n    builder.From(c.Out).To(f.In(0));\n\n    builder.From(b.Out(1)).Via(Flow.Create<int>().Select(x => x + 1)).To(e.In);\n    builder.From(e.Out(0)).To(f.In(1));\n\n    var sink = Sink.ForEach<int>(Console.WriteLine)\n        .MapMaterializedValue(_ => NotUsed.Instance);\n    builder.From(e.Out(1)).To(sink);\n\n    return ClosedShape.Instance;\n}));\n```\n\n----------------------------------------\n\nTITLE: Implementing Type Extension Methods in C#\nDESCRIPTION: Provides TypeExtensions static class with methods to check type relationships and generate type names. These extension methods help with type checking and reflection operations within the framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_259\n\nLANGUAGE: C#\nCODE:\n```\npublic class static TypeExtensions\n{\n    public static bool Implements<T>(this System.Type type) { }\n    public static bool Implements(this System.Type type, System.Type moreGeneralType) { }\n    [Akka.Annotations.InternalApiAttribute()]\n    public static string TypeQualifiedName(this System.Type type) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Circuit Breaker Settings Configuration\nDESCRIPTION: Configures circuit breaker parameters including maximum failures, call timeout, and reset timeout for managing resilience in distributed systems\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Core.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class CircuitBreakerSettings {\n    public int MaxFailures { get; }\n    public TimeSpan CallTimeout { get; }\n    public TimeSpan ResetTimeout { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Obsolete Failures Class in C#\nDESCRIPTION: Defines an obsolete Failures class with a list of Failure entries. This class is marked as obsolete and should be replaced with a List of Akka.Actor.Status.Failure.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\n[System.ObsoleteAttribute(\"Use List of Akka.Actor.Status.Failure\")]\npublic class Failures\n{\n    public Failures() { }\n    public System.Collections.Generic.List<Akka.Actor.Failure> Entries { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: RemoveRoutee Class in Akka.NET Routing\nDESCRIPTION: Defines a message used to remove a routee from a router. It implements RouterManagementMessage and contains a reference to the routee to be removed.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_185\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class RemoveRoutee : Akka.Routing.RouterManagementMessage\n{\n    public RemoveRoutee(Akka.Routing.Routee routee) { }\n    public Akka.Routing.Routee Routee { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Target Framework Attribute\nDESCRIPTION: This code sets the TargetFramework attribute to indicate that the assembly targets .NET Standard 2.0. This informs the .NET runtime and build tools about the target framework for which the assembly was built. The FrameworkDisplayName provides a user-friendly name for the target framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.Core.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n\"[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\\\".NETStandard,Version=v2.0\\\", FrameworkDisplayName=\\\".NET Standard 2.0\\\")]\"\n```\n\n----------------------------------------\n\nTITLE: Canceling FSM Timer in C#\nDESCRIPTION: Shows how to cancel a named timer in FSM. Cancellation is immediate and prevents processing of already queued timer messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/finite-state-machine.md#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nCancelTimer(name);\n```\n\n----------------------------------------\n\nTITLE: Service Discovery Abstract Class\nDESCRIPTION: This code defines the `ServiceDiscovery` abstract class, serving as the base class for service discovery implementations. It includes an abstract `Lookup` method for resolving service addresses and a concrete overload that accepts only a service name. It defines inner classes `Resolved` and `ResolvedTarget` to represent the resolved service and its targets.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.Core.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace Akka.Discovery\n{\n    public abstract class ServiceDiscovery\n    {\n        protected ServiceDiscovery() { }\n        public abstract System.Threading.Tasks.Task<Akka.Discovery.ServiceDiscovery.Resolved> Lookup(Akka.Discovery.Lookup lookup, System.TimeSpan resolveTimeout);\n        public System.Threading.Tasks.Task<Akka.Discovery.ServiceDiscovery.Resolved> Lookup(string serviceName, System.TimeSpan resolveTimeout) { }\n        public class Resolved : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression, System.IEquatable<Akka.Discovery.ServiceDiscovery.Resolved>\n        {\n            public Resolved(string serviceName) { }\n            public Resolved(string serviceName, System.Collections.Generic.IEnumerable<Akka.Discovery.ServiceDiscovery.ResolvedTarget> addresses) { }\n            public System.Collections.Immutable.ImmutableList<Akka.Discovery.ServiceDiscovery.ResolvedTarget> Addresses { get; }\n            public string ServiceName { get; }\n            public bool Equals(Akka.Discovery.ServiceDiscovery.Resolved other) { }\n            public override bool Equals(object obj) { }\n            public override int GetHashCode() { }\n            public override string ToString() { }\n        }\n        public class ResolvedTarget : Akka.Actor.INoSerializationVerificationNeeded, System.IEquatable<Akka.Discovery.ServiceDiscovery.ResolvedTarget>\n        {\n            public ResolvedTarget(string host, System.Nullable<int> port = null, System.Net.IPAddress address = null) { }\n            public System.Net.IPAddress Address { get; }\n            public string Host { get; }\n            public System.Nullable<int> Port { get; }\n            public bool Equals(Akka.Discovery.ServiceDiscovery.ResolvedTarget other) { }\n            public override bool Equals(object obj) { }\n            public override int GetHashCode() { }\n            public override string ToString() { }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SQL Snapshot Store Interface Definition in C#\nDESCRIPTION: Interface defining the contract for snapshot storage operations in SQL databases. Includes methods for creating tables, inserting, selecting, and deleting snapshots.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ISnapshotQueryExecutor\n{\n    QueryConfiguration Configuration { get; }\n    Task CreateTableAsync(DbConnection connection, CancellationToken cancellationToken);\n    Task DeleteAsync(DbConnection connection, CancellationToken cancellationToken, string persistenceId, long sequenceNr, DateTime? timestamp);\n    Task DeleteBatchAsync(DbConnection connection, CancellationToken cancellationToken, string persistenceId, long maxSequenceNr, DateTime maxTimestamp);\n    Task InsertAsync(DbConnection connection, CancellationToken cancellationToken, object snapshot, SnapshotMetadata metadata);\n    Task<SelectedSnapshot> SelectSnapshotAsync(DbConnection connection, CancellationToken cancellationToken, string persistenceId, long maxSequenceNr, DateTime maxTimestamp);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PersistenceQuery and Related Classes in Akka.NET\nDESCRIPTION: Defines the PersistenceQuery class, PersistenceQueryExtensions, and PersistenceQueryProvider for managing and accessing read journals in Akka.NET persistence.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceQuery.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class PersistenceQuery : Akka.Actor.IExtension\n{\n    public PersistenceQuery(Akka.Actor.ExtendedActorSystem system) { }\n    public Akka.Event.ILoggingAdapter Log { get; }\n    public static Akka.Persistence.Query.PersistenceQuery Get(Akka.Actor.ActorSystem system) { }\n    public static Akka.Configuration.Config GetDefaultConfig<TJournal>() { }\n    public TJournal ReadJournalFor<TJournal>(string readJournalPluginId)\n        where TJournal : Akka.Persistence.Query.IReadJournal { }\n}\n\npublic class static PersistenceQueryExtensions\n{\n    public static TJournal ReadJournalFor<TJournal>(this Akka.Actor.ActorSystem system, string readJournalPluginId)\n        where TJournal : Akka.Persistence.Query.IReadJournal { }\n}\n\npublic class PersistenceQueryProvider : Akka.Actor.ExtensionIdProvider<Akka.Persistence.Query.PersistenceQuery>\n{\n    public PersistenceQueryProvider() { }\n    public override Akka.Persistence.Query.PersistenceQuery CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DefaultCollector for Cluster Metrics\nDESCRIPTION: Defines a default metrics collector that implements the IMetricsCollector interface. This class is responsible for collecting performance metrics from cluster nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class DefaultCollector : Akka.Cluster.Metrics.IMetricsCollector, System.IDisposable\n{\n    public DefaultCollector(Akka.Actor.Address address) { }\n    public DefaultCollector(Akka.Actor.ActorSystem system) { }\n    public void Dispose() { }\n    public Akka.Cluster.Metrics.Serialization.NodeMetrics Sample() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Graph Shape in Akka.NET (C#)\nDESCRIPTION: This code defines a custom shape for a graph component in Akka.NET, representing a pool of worker processes with priority job capabilities. It includes methods for deep copying the shape, critical for maintaining configuration as copies and processing connections continue. Akka.NET libraries are prerequisites.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithgraphs.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic class PriorityWorkerPoolShape<TIn, TOut> : Shape\n{\n    public PriorityWorkerPoolShape(Inlet<TIn> jobsIn, Inlet<TIn> priorityJobsIn, Outlet<TOut> resultsOut)\n    {\n        JobsIn = jobsIn;\n        PriorityJobsIn = priorityJobsIn;\n        ResultsOut = resultsOut;\n\n        Inlets = ImmutableArray.Create<Inlet>(jobsIn, priorityJobsIn);\n        Outlets = ImmutableArray.Create<Outlet>(resultsOut);\n    }\n\n    public override ImmutableArray<Inlet> Inlets { get; }\n\n    public override ImmutableArray<Outlet> Outlets { get; }\n\n    public Inlet<TIn> JobsIn { get; }\n\n    public Inlet<TIn> PriorityJobsIn { get; }\n\n    public Outlet<TOut> ResultsOut { get; }\n\n    public override Shape DeepCopy()\n    {\n        return new PriorityWorkerPoolShape<TIn, TOut>((Inlet<TIn>)JobsIn.CarbonCopy(),\n            (Inlet<TIn>)PriorityJobsIn.CarbonCopy(), (Outlet<TOut>)ResultsOut.CarbonCopy());\n    }\n\n    public override Shape CopyFromPorts(ImmutableArray<Inlet> inlets, ImmutableArray<Outlet> outlets)\n    {\n        if (inlets.Length != Inlets.Length)\n            throw new ArgumentException(\n                $\"Inlets have the wrong length, expected {Inlets.Length} found {inlets.Length}\", nameof(inlets));\n        if (outlets.Length != Outlets.Length)\n            throw new ArgumentException(\n                $\"Outlets have the wrong length, expected {Outlets.Length} found {outlets.Length}\", nameof(outlets));\n\n        // This is why order matters when overriding inlets and outlets.\n        return new PriorityWorkerPoolShape<TIn, TOut>((Inlet<TIn>)inlets[0], (Inlet<TIn>)inlets[1],\n            (Outlet<TOut>)outlets[0]);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EventEnvelope Class in Akka.NET Persistence Query\nDESCRIPTION: Defines the EventEnvelope class, which encapsulates event data including offset, persistence ID, sequence number, and timestamp. It implements IEquatable for comparison.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceQuery.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class EventEnvelope : System.IEquatable<Akka.Persistence.Query.EventEnvelope>\n{\n    [System.ObsoleteAttribute(\"For binary compatibility with previous releases\")]\n    public EventEnvelope(Akka.Persistence.Query.Offset offset, string persistenceId, long sequenceNr, object @event) { }\n    public EventEnvelope(Akka.Persistence.Query.Offset offset, string persistenceId, long sequenceNr, object @event, long timestamp) { }\n    public object Event { get; }\n    public Akka.Persistence.Query.Offset Offset { get; }\n    public string PersistenceId { get; }\n    public long SequenceNr { get; }\n    public long Timestamp { get; }\n    public bool Equals(Akka.Persistence.Query.EventEnvelope other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AbstractStash for Actor Message Stashing in C#\nDESCRIPTION: This class implements the IStash interface, providing methods for stashing and unstashing messages in an actor's mailbox.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_56\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AbstractStash : Akka.Actor.IStash\n{\n    protected AbstractStash(Akka.Actor.IActorContext context) { }\n    public virtual int Capacity { get; }\n    public int Count { get; }\n    public bool IsEmpty { get; }\n    public bool IsFull { get; }\n    public bool NonEmpty { get; }\n    public System.Collections.Generic.IEnumerable<Akka.Actor.Envelope> ClearStash() { }\n    public void Prepend(System.Collections.Generic.IEnumerable<Akka.Actor.Envelope> envelopes) { }\n    public void Stash() { }\n    public void Unstash() { }\n    public void UnstashAll() { }\n    public void UnstashAll(System.Func<Akka.Actor.Envelope, bool> filterPredicate) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Batching SQL Journal for Akka.NET Persistence\nDESCRIPTION: Defines an abstract generic class for implementing batching SQL journals, extending the WriteJournalBase class and providing common functionality for SQL-based journals.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class BatchingSqlJournal<TConnection, TCommand> : Akka.Persistence.Journal.WriteJournalBase\n    where TConnection : System.Data.Common.DbConnection\n    where TCommand : System.Data.Common.DbCommand\n{\n    protected readonly bool CanPublish;\n    protected const int IsDeletedIndex = 3;\n    protected readonly Akka.Event.ILoggingAdapter Log;\n    protected const int ManifestIndex = 4;\n    protected const int OrderingIndex = 7;\n    protected const int PayloadIndex = 5;\n    protected const int PersistenceIdIndex = 0;\n    protected const int SequenceNrIndex = 1;\n    protected const int SerializerIdIndex = 6;\n    // ... (additional members)\n}\n```\n\n----------------------------------------\n\nTITLE: Running Stream with Console Output\nDESCRIPTION: Executes the stream by printing each element to the console using RunForeach\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/quickstart.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nsource.RunForeach(i => Console.WriteLine(i.ToString()), materializer)\n```\n\n----------------------------------------\n\nTITLE: Implementing AtomicBoolean Class for Thread-Safe Boolean Operations in C#\nDESCRIPTION: Defines an AtomicBoolean class that provides thread-safe operations on boolean values. It includes methods for comparing and setting values atomically.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_218\n\nLANGUAGE: C#\nCODE:\n```\npublic class AtomicBoolean\n{\n    public AtomicBoolean(bool initialValue = False) { }\n    public bool Value { get; set; }\n    public bool CompareAndSet(bool expected, bool newValue) { }\n    public bool GetAndSet(bool newValue) { }\n    public static bool op_Implicit(Akka.Util.AtomicBoolean atomicBoolean) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UnboundedStablePriorityMessageQueue for Akka.NET in C#\nDESCRIPTION: A stable priority-based message queue that preserves FIFO order for messages with the same priority. It extends BlockingMessageQueue and provides methods for stable priority-based message handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_110\n\nLANGUAGE: C#\nCODE:\n```\npublic class UnboundedStablePriorityMessageQueue : Akka.Dispatch.MessageQueues.BlockingMessageQueue, Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics, Akka.Dispatch.IUnboundedMessageQueueSemantics\n{\n    public UnboundedStablePriorityMessageQueue(System.Func<object, int> priorityGenerator, int initialCapacity) { }\n    protected override int LockedCount { get; }\n    public void EnqueueFirst(Akka.Actor.Envelope envelope) { }\n    protected override void LockedEnqueue(Akka.Actor.Envelope envelope) { }\n    protected override bool LockedTryDequeue(out Akka.Actor.Envelope envelope) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DurableProducerQueue State Management in C#\nDESCRIPTION: Definition of the State<T> struct that manages the state of durable message producers, including sequence numbers, confirmations and unconfirmed messages. Includes methods for managing message state and confirmations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_89\n\nLANGUAGE: C#\nCODE:\n```\npublic struct State<T> : Akka.Delivery.Internal.IDeliverySerializable, System.IEquatable<Akka.Delivery.DurableProducerQueue.State<T>> {\n    public State(long CurrentSeqNr, long HighestConfirmedSeqNr, ImmutableDictionary<string, System.ValueTuple<long, long>> ConfirmedSeqNr, ImmutableList<MessageSent<T>> Unconfirmed) { }\n    public ImmutableDictionary<string, System.ValueTuple<long, long>> ConfirmedSeqNr { get; set; }\n    public long CurrentSeqNr { get; set; }\n    public static State<T> Empty { get; }\n    public long HighestConfirmedSeqNr { get; set; }\n    public ImmutableList<MessageSent<T>> Unconfirmed { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Actor Lifecycle Monitoring in Akka.NET TestKit\nDESCRIPTION: Methods for watching and unwatching actors during tests. These methods enable detection of actor termination events in both synchronous and asynchronous testing scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\npublic Akka.Actor.IActorRef Unwatch(Akka.Actor.IActorRef actorToUnwatch) { }\npublic System.Threading.Tasks.Task<Akka.Actor.IActorRef> UnwatchAsync(Akka.Actor.IActorRef actorToUnwatch) { }\npublic System.Threading.Tasks.Task<System.Collections.ArrayList> WaitForRadioSilenceAsync(System.Nullable<System.TimeSpan> max = null, System.Nullable<uint> maxMessages = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic Akka.Actor.IActorRef Watch(Akka.Actor.IActorRef actorToWatch) { }\npublic System.Threading.Tasks.Task<Akka.Actor.IActorRef> WatchAsync(Akka.Actor.IActorRef actorToWatch) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing UnstartedCell Class for Actor Initialization in C#\nDESCRIPTION: Defines the UnstartedCell class that implements ICell interface. It provides methods for managing unstarted actors and their lifecycle.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic class UnstartedCell : Akka.Actor.ICell\n{\n    public UnstartedCell(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.RepointableActorRef self, Akka.Actor.Props props, Akka.Actor.IInternalActorRef supervisor) { }\n    public Akka.Actor.Internal.IChildrenContainer ChildrenContainer { get; }\n    public bool HasMessages { get; }\n    public bool IsLocal { get; }\n    public bool IsTerminated { get; }\n    public int NumberOfMessages { get; }\n    public Akka.Actor.IInternalActorRef Parent { get; }\n    public Akka.Actor.Props Props { get; }\n    public Akka.Actor.IActorRef Self { get; }\n    public Akka.Actor.ActorSystem System { get; }\n    public Akka.Actor.Internal.ActorSystemImpl SystemImpl { get; }\n    // ... (other methods)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SqlReadJournalProvider for Akka.NET Persistence Query\nDESCRIPTION: Defines the SqlReadJournalProvider class which implements the IReadJournalProvider interface. It provides a method to get a read journal instance.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommonQuery.Core.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class SqlReadJournalProvider : Akka.Persistence.Query.IReadJournalProvider\n{\n    public SqlReadJournalProvider(Akka.Actor.ExtendedActorSystem system, Akka.Configuration.Config config) { }\n    public Akka.Persistence.Query.IReadJournal GetReadJournal() { }\n}\n```\n\n----------------------------------------\n\nTITLE: TestActorRef Generic Class Definition\nDESCRIPTION: Generic class for test actor references extending TestActorRefBase with actor-specific functionality and comparison operators.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestActorRef<TActor> : Akka.TestKit.TestActorRefBase<TActor>\n    where TActor : Akka.Actor.ActorBase\n{\n    public TestActorRef(Akka.Actor.ActorSystem system, Akka.Actor.Props actorProps, Akka.Actor.IActorRef supervisor = null, string name = null) { }\n    public static bool ==(Akka.TestKit.TestActorRef<TActor> testActorRef, Akka.Actor.IActorRef actorRef) { }\n    public static bool ==(Akka.Actor.IActorRef actorRef, Akka.TestKit.TestActorRef<TActor> testActorRef) { }\n    public static bool !=(Akka.TestKit.TestActorRef<TActor> testActorRef, Akka.Actor.IActorRef actorRef) { }\n    public static bool !=(Akka.Actor.IActorRef actorRef, Akka.TestKit.TestActorRef<TActor> testActorRef) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AkkaProtocolSettings for Akka Remote C#\nDESCRIPTION: This snippet defines the AkkaProtocolSettings class used within Akka.Remote for specifying configuration settings related to remote protocol operations. It handles settings such as handshake timeouts and transport failure detector configurations, allowing customization based on network requirements. Dependencies include Akka.Configuration.Config for accessing configuration files.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class AkkaProtocolSettings\n{\n    public AkkaProtocolSettings(Akka.Configuration.Config config) { }\n    public System.TimeSpan HandshakeTimeout { get; }\n    public Akka.Configuration.Config TransportFailureDetectorConfig { get; }\n    public string TransportFailureDetectorImplementationClass { get; }\n    public System.TimeSpan TransportHeartBeatInterval { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Publisher of Tweets in C#\nDESCRIPTION: Example of a library providing an IPublisher implementation that publishes Tweet objects.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nIPublisher<Tweet> Tweets\n```\n\n----------------------------------------\n\nTITLE: Implementing LoggingExtensions Static Class in C#\nDESCRIPTION: Extension methods for the ILoggingAdapter interface that provide convenient logging methods for different log levels. Includes overloaded methods for debug, error, and info logging with various parameter counts and exception handling support.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_152\n\nLANGUAGE: C#\nCODE:\n```\npublic class static LoggingExtensions\n{\n    public static void Debug(this Akka.Event.ILoggingAdapter log, string format) { }\n    public static void Debug(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format) { }\n    public static void Debug<T1>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1) { }\n    public static void Debug<T1>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1) { }\n    public static void Debug<T1, T2>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2) { }\n    public static void Debug<T1, T2>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2) { }\n    public static void Debug<T1, T2, T3>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3) { }\n    public static void Debug<T1, T2, T3>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3) { }\n    public static void Debug<T1, T2, T3, T4>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4) { }\n    public static void Debug<T1, T2, T3, T4>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4) { }\n    public static void Debug<T1, T2, T3, T4, T5>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) { }\n    public static void Debug<T1, T2, T3, T4, T5>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) { }\n    public static void Debug<T1, T2, T3, T4, T5, T6>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) { }\n    public static void Debug<T1, T2, T3, T4, T5, T6>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) { }\n    public static void Debug(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, object[] args) { }\n    public static void Debug(this Akka.Event.ILoggingAdapter log, string format, object[] args) { }\n    public static void Error(this Akka.Event.ILoggingAdapter log, string format) { }\n    public static void Error(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format) { }\n    public static void Error<T1>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1) { }\n    public static void Error<T1>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1) { }\n    public static void Error<T1, T2>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2) { }\n    public static void Error<T1, T2>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2) { }\n    public static void Error<T1, T2, T3>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3) { }\n    public static void Error<T1, T2, T3>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3) { }\n    public static void Error<T1, T2, T3, T4>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4) { }\n    public static void Error<T1, T2, T3, T4>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4) { }\n    public static void Error<T1, T2, T3, T4, T5>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) { }\n    public static void Error<T1, T2, T3, T4, T5>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) { }\n    public static void Error<T1, T2, T3, T4, T5, T6>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) { }\n    public static void Error<T1, T2, T3, T4, T5, T6>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) { }\n    public static void Error(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, object[] args) { }\n    public static void Error(this Akka.Event.ILoggingAdapter log, string format, object[] args) { }\n    public static void Info(this Akka.Event.ILoggingAdapter log, string format) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ThreadLocalRandom Static Class\nDESCRIPTION: Static utility class providing thread-local random number generation to avoid contention in multi-threaded scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_217\n\nLANGUAGE: C#\nCODE:\n```\npublic class static ThreadLocalRandom\n{\n    public static System.Random Current { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Remote Settings Configuration in C#\nDESCRIPTION: RemoteSettings class that manages configuration settings for remote actor systems including timeouts, buffer sizes, and transport settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class RemoteSettings\n{\n    public static readonly string AkkaScheme;\n    public RemoteSettings(Akka.Configuration.Config config) { }\n    public System.Collections.Generic.IDictionary<string, string> Adapters { get; set; }\n    public System.TimeSpan BackoffPeriod { get; set; }\n    // ... additional properties\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ActorProducerPluginBase Classes in C#\nDESCRIPTION: Defines base classes for actor producer plugins, providing default implementations for the IActorProducerPlugin interface. Includes a generic version for type-safe actor handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ActorProducerPluginBase : Akka.Actor.IActorProducerPlugin\n{\n    protected ActorProducerPluginBase() { }\n    public virtual void AfterIncarnated(Akka.Actor.ActorBase actor, Akka.Actor.IActorContext context) { }\n    public virtual void BeforeIncarnated(Akka.Actor.ActorBase actor, Akka.Actor.IActorContext context) { }\n    public virtual bool CanBeAppliedTo(System.Type actorType) { }\n}\n\npublic abstract class ActorProducerPluginBase<TActor> : Akka.Actor.IActorProducerPlugin\n    where TActor : Akka.Actor.ActorBase\n{\n    protected ActorProducerPluginBase() { }\n    public virtual void AfterIncarnated(TActor actor, Akka.Actor.IActorContext context) { }\n    public virtual void BeforeIncarnated(TActor actor, Akka.Actor.IActorContext context) { }\n    public virtual bool CanBeAppliedTo(System.Type actorType) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Information Class for Serialization Context in Akka.NET\nDESCRIPTION: Defines an internal Information class that holds actor system and address information during serialization. It implements IEquatable for comparison operations and includes operator overloads for equality checks.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_193\n\nLANGUAGE: csharp\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic sealed class Information : System.IEquatable<Akka.Serialization.Information>\n{\n    public Information(Akka.Actor.Address address, Akka.Actor.ActorSystem system) { }\n    public Akka.Actor.Address Address { get; }\n    public Akka.Actor.ActorSystem System { get; }\n    public bool Equals(Akka.Serialization.Information other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public static bool ==(Akka.Serialization.Information left, Akka.Serialization.Information right) { }\n    public static bool !=(Akka.Serialization.Information left, Akka.Serialization.Information right) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Round Robin Router Implementation Classes\nDESCRIPTION: Implementation of round-robin routing logic including both pool and group router variants. Provides sequential selection of routees for even message distribution.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_185\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class RoundRobinRoutingLogic : Akka.Routing.RoutingLogic\n{\n    public RoundRobinRoutingLogic() { }\n    public RoundRobinRoutingLogic(int next) { }\n    public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }\n}\n\npublic sealed class RoundRobinPool : Akka.Routing.Pool\n{\n    public RoundRobinPool(int nrOfInstances) { }\n    public RoundRobinPool(int nrOfInstances, Akka.Routing.Resizer resizer) { }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating BroadcastGroup Router from HOCON Configuration in C#\nDESCRIPTION: Demonstrates how to create a broadcast group router from HOCON configuration using Props.Empty since the routees are pre-existing actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nvar router = system.ActorOf(Props.Empty.WithRouter(FromConfig.Instance), \"some-group\");\n```\n\n----------------------------------------\n\nTITLE: Creating EchoActor for Akka.NET Testing\nDESCRIPTION: An actor that echoes received messages to a TestKit and optionally back to the sender. This test actor helps verify message passing behavior in Akka.NET tests.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_51\n\nLANGUAGE: C#\nCODE:\n```\npublic class EchoActor : Akka.Actor.ReceiveActor\n{\n    public EchoActor(Akka.TestKit.TestKitBase testkit, bool echoBackToSenderAsWell = True) { }\n    public static Akka.Actor.Props Props(Akka.TestKit.TestKitBase testkit, bool echoBackToSenderAsWell = True) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LogSource Struct in C#\nDESCRIPTION: Struct for representing and handling log sources in Akka.NET. Provides methods for creating log sources from different types of objects, including actors, actor references, strings, and types. Helps with standardizing log source identification across the system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_147\n\nLANGUAGE: C#\nCODE:\n```\npublic struct LogSource\n{\n    [get: System.Runtime.CompilerServices.IsReadOnlyAttribute()]\n    public string Source { get; }\n    [get: System.Runtime.CompilerServices.IsReadOnlyAttribute()]\n    public System.Type Type { get; }\n    public static Akka.Event.LogSource Create(object o) { }\n    public static Akka.Event.LogSource Create(object o, Akka.Actor.ActorSystem system) { }\n    public static Akka.Event.LogSource Create(string source, System.Type t) { }\n    public static string FromActor(Akka.Actor.IActorContext actor, Akka.Actor.ActorSystem system) { }\n    public static string FromActorRef(Akka.Actor.IActorRef a, Akka.Actor.ActorSystem system) { }\n    public static string FromString(string source, Akka.Actor.ActorSystem system) { }\n    public static string FromType(System.Type t, Akka.Actor.ActorSystem system) { }\n    public static System.Type SourceType(object o) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic IRemovedNodePruning Interface in C#\nDESCRIPTION: This snippet defines the generic `IRemovedNodePruning<T>` interface, inheriting from both the non-generic `IRemovedNodePruning` and `IReplicatedData<T>`. The type parameter `T` is constrained to be an `IReplicatedData`. It provides type-safe `Prune` and `PruningCleanup` methods that return the specific replicated data type `T`.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\n    public interface IRemovedNodePruning<T> : Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedData<T>\n        where T : Akka.DistributedData.IReplicatedData\n    {\n        T Prune(Akka.Cluster.UniqueAddress removedNode, Akka.Cluster.UniqueAddress collapseInto);\n        T PruningCleanup(Akka.Cluster.UniqueAddress removedNode);\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Initializing CircuitBreaker in C#\nDESCRIPTION: Constructor for the CircuitBreaker class in Akka.NET. It takes parameters for scheduler, max failures, call timeout, reset timeout, max reset timeout, exponential backoff factor, and random factor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_195\n\nLANGUAGE: C#\nCODE:\n```\npublic CircuitBreaker(Akka.Actor.IScheduler scheduler, int maxFailures, System.TimeSpan callTimeout, System.TimeSpan resetTimeout, System.TimeSpan maxResetTimeout, double exponentialBackoffFactor, double randomFactor) { }\n```\n\n----------------------------------------\n\nTITLE: Defining LogFilterEvaluator and LogFilterSetup Classes in C#\nDESCRIPTION: Defines classes for handling log filtering in Akka.NET. LogFilterEvaluator evaluates whether log messages should be kept based on filter criteria, while LogFilterSetup provides configuration for log filters during actor system initialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_144\n\nLANGUAGE: C#\nCODE:\n```\npublic static readonly Akka.Event.LogFilterEvaluator NoFilters;\npublic LogFilterEvaluator(Akka.Event.LogFilterBase[] filters) { }\npublic bool EvaluatesLogSourcesOnly { get; }\npublic virtual bool ShouldTryKeepMessage(Akka.Event.LogEvent evt, out string expandedLogMessage) { }\n\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class LogFilterSetup : Akka.Actor.Setup.Setup\n{\n    public LogFilterSetup(Akka.Event.LogFilterBase[] filters) { }\n    public Akka.Event.LogFilterBase[] Filters { get; }\n    public Akka.Event.LogFilterEvaluator CreateEvaluator() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ShardingConsumerController for Akka.NET\nDESCRIPTION: Defines a controller for managing consumers in Akka.NET cluster sharding with settings for buffer size and bypass behavior.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Net.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic class static ShardingConsumerController\n{\n    public static Akka.Actor.Props Create<T>(System.Func<Akka.Actor.IActorRef, Akka.Actor.Props> consumerProps, Akka.Cluster.Sharding.Delivery.ShardingConsumerController.Settings settings) { }\n    public sealed class Settings : System.IEquatable<Akka.Cluster.Sharding.Delivery.ShardingConsumerController.Settings>\n    {\n        public bool AllowBypass { get; set; }\n        public int BufferSize { get; set; }\n        public Akka.Delivery.ConsumerController.Settings ConsumerControllerSettings { get; set; }\n        public static Akka.Cluster.Sharding.Delivery.ShardingConsumerController.Settings Create(Akka.Actor.ActorSystem system) { }\n        public override string ToString() { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Update Class Definition in C#\nDESCRIPTION: Represents an update operation for distributed data in Akka.NET. This class encapsulates the key to update, a modification function, consistency requirements, and an optional request object for correlation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_49\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Update : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public Update(Akka.DistributedData.IKey key, Akka.DistributedData.IWriteConsistency consistency, System.Func<Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedData> modify, object request = null) { }\n    public Update(Akka.DistributedData.IKey key, Akka.DistributedData.IReplicatedData initial, Akka.DistributedData.IWriteConsistency consistency, System.Func<Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedData> modify, object request = null) { }\n    public Akka.DistributedData.IWriteConsistency Consistency { get; }\n    public Akka.DistributedData.IKey Key { get; }\n    public System.Func<Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedData> Modify { get; }\n    public object Request { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Object Extensions in C#\nDESCRIPTION: Provides an ObjectExtensions static class in the Extensions namespace with methods to convert objects to Option<T> types. This facilitates working with potentially null values in a functional style.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_262\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.Util.Extensions\n{\n    public class static ObjectExtensions\n    {\n        public static Akka.Util.Option<T> AsOption<T>(this T obj) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ForceDisassociateExplicitly Class in Akka.NET Remote Transport\nDESCRIPTION: A class representing a command to force explicit disassociation with a remote address with a specific reason in Akka.NET's transport system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ForceDisassociateExplicitly\n{\n    public ForceDisassociateExplicitly(Akka.Actor.Address address, Akka.Remote.Transport.DisassociateInfo reason) { }\n    public Akka.Actor.Address Address { get; }\n    public Akka.Remote.Transport.DisassociateInfo Reason { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Default Logging Components in Akka.NET\nDESCRIPTION: Defines default implementations for logger and log message formatter in Akka.NET. These classes provide the baseline functionality for logging in Akka actor systems when custom implementations aren't specified.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_142\n\nLANGUAGE: C#\nCODE:\n```\npublic class DefaultLogMessageFormatter : Akka.Event.ILogMessageFormatter\n{\n    public static readonly Akka.Event.DefaultLogMessageFormatter Instance;\n    public string Format(string format, params object[] args) { }\n    public string Format(string format, System.Collections.Generic.IEnumerable<object> args) { }\n}\n\npublic class DefaultLogger : Akka.Actor.ActorBase, Akka.Dispatch.IRequiresMessageQueue<Akka.Event.ILoggerMessageQueueSemantics>\n{\n    public DefaultLogger() { }\n    protected virtual void Print(Akka.Event.LogEvent logEvent) { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: LeaseUsageSettings Class Definition in C#\nDESCRIPTION: Defines settings for how leases are used, including the lease implementation and retry interval. Provides immutable configuration for lease usage behavior.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class LeaseUsageSettings\n{\n    public LeaseUsageSettings(string leaseImplementation, System.TimeSpan leaseRetryInterval) { }\n    public string LeaseImplementation { get; }\n    public System.TimeSpan LeaseRetryInterval { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Expecting Messages from Specific Senders in Akka.NET TestKitBase\nDESCRIPTION: These methods allow for expecting messages from specific senders with various conditions and timeouts. They support both synchronous and asynchronous operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic T ExpectMsgFrom<T>(Akka.Actor.IActorRef sender, System.Nullable<System.TimeSpan> duration = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic T ExpectMsgFrom<T>(Akka.Actor.IActorRef sender, T message, System.Nullable<System.TimeSpan> timeout = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic System.Threading.Tasks.ValueTask<T> ExpectMsgFromAsync<T>(Akka.Actor.IActorRef sender, System.Nullable<System.TimeSpan> duration = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: TerminationHook Message in Akka.NET\nDESCRIPTION: Message representing a termination hook in the actor system. Uses the singleton pattern with a static Instance property.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_108\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class TerminationHook\n{\n    public static Akka.Dispatch.SysMsg.TerminationHook Instance { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Information Class for Transport Details in C#\nDESCRIPTION: An internal API class that holds address and system information for serialization transport. Provides equality comparison methods and operators for comparing Information instances.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_208\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\n    public sealed class Information : System.IEquatable<Akka.Serialization.Information>\n    {\n        public Information(Akka.Actor.Address address, Akka.Actor.ActorSystem system) { }\n        public Akka.Actor.Address Address { get; }\n        public Akka.Actor.ActorSystem System { get; }\n        public bool Equals(Akka.Serialization.Information other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n        public static bool ==(Akka.Serialization.Information left, Akka.Serialization.Information right) { }\n        public static bool !=(Akka.Serialization.Information left, Akka.Serialization.Information right) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Creating BlackHoleActor for Akka.NET Testing\nDESCRIPTION: A special actor that silently consumes all messages. This test actor is useful for simulating unresponsive or absorbing endpoints in Akka.NET actor system tests.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_50\n\nLANGUAGE: C#\nCODE:\n```\npublic class BlackHoleActor : Akka.Actor.ActorBase\n{\n    public BlackHoleActor() { }\n    public static Akka.Actor.Props Props { get; }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining State Data for Akka.NET FSM Actor\nDESCRIPTION: This code defines the state data used by the Buncher FSM actor, including the Uninitialized state and the Todo state with a target and queue.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/finite-state-machine.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/core/Akka.Docs.Tests/Actors/FiniteStateMachine/FiniteStateMachine.Messages.cs?name=FSMData)]\n```\n\n----------------------------------------\n\nTITLE: DefaultLogger Actor in Akka.NET\nDESCRIPTION: Default implementation of a logger actor. Implements IRequiresMessageQueue for logger message queue semantics and handles printing log events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_121\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DefaultLogger : Akka.Actor.ActorBase, Akka.Dispatch.IRequiresMessageQueue<Akka.Event.ILoggerMessageQueueSemantics>\n{\n    public DefaultLogger() { }\n    protected virtual void Print(Akka.Event.LogEvent logEvent) { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ActorSystemSetup Class in C#\nDESCRIPTION: This sealed class provides methods for setting up and configuring an Akka.NET actor system. It allows adding and retrieving setup components.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_63\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ActorSystemSetup\n{\n    public static readonly Akka.Actor.Setup.ActorSystemSetup Empty;\n    public Akka.Actor.Setup.ActorSystemSetup And<T>(T setup)\n        where T : Akka.Actor.Setup.Setup { }\n    public static Akka.Actor.Setup.ActorSystemSetup Create(params Akka.Actor.Setup.Setup[] setup) { }\n    public Akka.Util.Option<T> Get<T>()\n        where T : Akka.Actor.Setup.Setup { }\n    public override string ToString() { }\n    public Akka.Actor.Setup.ActorSystemSetup WithSetup<T>(T setup)\n        where T : Akka.Actor.Setup.Setup { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Reactive Streams Compatible Datastore Projection - C#\nDESCRIPTION: This snippet demonstrates how to create a materialized view in a Reactive Streams compatible datastore using Akka.NET. It utilizes the PersistenceQuery API to access events by persistence ID and batches them for writing into the database. It requires the Akka.Persistence and Akka.Streams libraries for reactive programming.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistence-query.md#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nvar system = ActorSystem.Create(\"MySystem\");\nvar mat = ActorMaterializer.Create(system);\n\nvar readJournal =\n  PersistenceQuery.Get(system).ReadJournalFor<MyReadJournal>(JournalId)\nISubscriber<IImmutableList<object>> dbBatchWriter =\n  new ReactiveStreamsCompatibleDBDriver.BatchWriter();\n \n// Using an example (Reactive Streams) Database driver\nreadJournal\n  .EventsByPersistenceId(\"user-1337\")\n  .Select(envelope => envelope.Event)\n  .Select(ConvertToReadSideTypes) // convert to datatype\n  .Grouped(20) // batch inserts into groups of 20\n  .RunWith(Sink.FromSubscriber(dbBatchWriter), mat); // write batches to read-side database\n```\n\n----------------------------------------\n\nTITLE: WriteAttempt Activity Class Implementation\nDESCRIPTION: Sealed class representing a write attempt activity in the transport layer. Contains sender and recipient addresses along with payload data.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class WriteAttempt : Akka.Remote.Transport.Activity\n{\n    public WriteAttempt(Akka.Actor.Address sender, Akka.Actor.Address recipient, Google.Protobuf.ByteString payload) { }\n    public Google.Protobuf.ByteString Payload { get; }\n    public Akka.Actor.Address Recipient { get; }\n    public Akka.Actor.Address Sender { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Message Queue Semantics Interfaces in C#\nDESCRIPTION: A collection of interfaces that define the semantics for different types of message queues in Akka.NET. These interfaces establish contracts for bounded queues, deque-based queues, and how message processing should behave.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_90\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IBoundedDequeBasedMessageQueueSemantics : Akka.Dispatch.IBoundedMessageQueueSemantics, Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics { }\npublic interface IBoundedMessageQueueSemantics : Akka.Dispatch.ISemantics\n{\n    System.TimeSpan PushTimeOut { get; }\n}\npublic interface IDequeBasedMessageQueueSemantics : Akka.Dispatch.ISemantics\n{\n    void EnqueueFirst(Akka.Actor.Envelope envelope);\n}\npublic interface IMultipleConsumerSemantics : Akka.Dispatch.ISemantics { }\npublic interface IProducesMessageQueue<TQueue>\n    where TQueue : Akka.Dispatch.MessageQueues.IMessageQueue { }\npublic interface IProducesPushTimeoutSemanticsMailbox\n{\n    System.TimeSpan PushTimeout { get; }\n}\npublic interface IRequiresMessageQueue<T>\n    where T : Akka.Dispatch.ISemantics { }\npublic interface ISemantics { }\npublic interface IUnboundedDequeBasedMessageQueueSemantics : Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.IUnboundedMessageQueueSemantics { }\npublic interface IUnboundedMessageQueueSemantics : Akka.Dispatch.ISemantics { }\n```\n\n----------------------------------------\n\nTITLE: DeleteMessagesFailure Class Definition in Akka.Persistence\nDESCRIPTION: Class representing a failure when attempting to delete messages from the journal, containing the cause of the failure and the sequence number up to which deletion was attempted.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DeleteMessagesFailure : Akka.Actor.INoSerializationVerificationNeeded, System.IEquatable<Akka.Persistence.DeleteMessagesFailure>\n{\n    public DeleteMessagesFailure(System.Exception cause, long toSequenceNr) { }\n    public System.Exception Cause { get; }\n    public long ToSequenceNr { get; }\n    public bool Equals(Akka.Persistence.DeleteMessagesFailure other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Metric Class Implementation in C#\nDESCRIPTION: Implementation of the Metric class for storing and managing individual metrics with support for EWMA calculations and Protocol Buffer serialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Metric : Google.Protobuf.IDeepCloneable<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric>, Google.Protobuf.IMessage, Google.Protobuf.IMessage<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric>, System.IEquatable<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric>\n{\n    public const int EwmaFieldNumber = 3;\n    public const int NameIndexFieldNumber = 1;\n    public const int NumberFieldNumber = 2;\n    public Metric() { }\n    public Metric(Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric other) { }\n    public Metric(string name, Akka.Cluster.Metrics.Helpers.AnyNumber value, Akka.Util.Option<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.EWMA> average) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Stop System Message in Akka.NET\nDESCRIPTION: Defines a system message that instructs an actor to stop itself. Part of the actor lifecycle management in the Akka.NET framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_125\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Stop : Akka.Dispatch.SysMsg.SystemMessage\n{\n    public Stop() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Buffer to Avoid Deadlock in Feedback Loop - Akka.Net\nDESCRIPTION: This code snippet demonstrates the use of a buffer in a feedback loop within an Akka.Net graph. By using a Buffer with a dropping strategy, the snippet prevents deadlock by ensuring that the number of circulating elements does not exceed buffer limits.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithgraphs.md#2025-04-16_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\nRunnableGraph.FromGraph(GraphDsl.Create(b =>\n{\n    var merge = b.Add(new Merge<int>(2));\n    var broadcast = b.Add(new Broadcast<int>(2));\n    var print = Flow.Create<int>().Select(s =>\n    {\n        Console.WriteLine(s);\n        return s;\n    });\n    var buffer = Flow.Create<int>().Buffer(10, OverflowStrategy.DropHead);\n    \n    var sink = Sink.Ignore<int>().MapMaterializedValue(_ => NotUsed.Instance);\n    b.From(source).Via(merge).Via(print).Via(broadcast).To(sink);\n    b.To(merge).Via(buffer).From(broadcast);\n\n    return ClosedShape.Instance;\n}));\n```\n\n----------------------------------------\n\nTITLE: Implementing Mute and Unmute Classes in C#\nDESCRIPTION: Defines Mute and Unmute classes used for event filtering in the TestKit. These classes allow specifying which events should be muted or unmuted during testing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Mute : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public Mute(params Akka.TestKit.Internal.EventFilterBase[] filters) { }\n    public Mute(System.Collections.Generic.IReadOnlyCollection<Akka.TestKit.Internal.EventFilterBase> filters) { }\n    public System.Collections.Generic.IReadOnlyCollection<Akka.TestKit.Internal.EventFilterBase> Filters { get; }\n}\n\npublic sealed class Unmute : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public Unmute(params Akka.TestKit.Internal.EventFilterBase[] filters) { }\n    public Unmute(System.Collections.Generic.IReadOnlyCollection<Akka.TestKit.Internal.EventFilterBase> filters) { }\n    public System.Collections.Generic.IReadOnlyCollection<Akka.TestKit.Internal.EventFilterBase> Filters { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IShardRegionCommand Interface in Akka.NET Sharding\nDESCRIPTION: Marker interface for messages that are commands to the shard region. It is used to differentiate commands from queries.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n    public interface IShardRegionCommand { }\n```\n\n----------------------------------------\n\nTITLE: Creating RandomGroup Router from HOCON Configuration in C#\nDESCRIPTION: Demonstrates how to create a random group router from HOCON configuration using Props.Empty since the routees are pre-existing actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\nvar router = system.ActorOf(Props.Empty.WithRouter(FromConfig.Instance), \"some-group\");\n```\n\n----------------------------------------\n\nTITLE: Expression Arguments Extraction Extension in C#\nDESCRIPTION: Extension method for NewExpression that extracts constructor arguments as an object array.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_270\n\nLANGUAGE: C#\nCODE:\n```\npublic static object[] GetArguments(this System.Linq.Expressions.NewExpression newExpression) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing MurmurHash Static Class in C#\nDESCRIPTION: A utility class for generating MurmurHash values, a non-cryptographic hash function. Provides methods for hashing different types of data including arrays, bytes, and strings with support for symmetric hashing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_245\n\nLANGUAGE: C#\nCODE:\n```\npublic class static MurmurHash\n{\n    public const uint StartMagicA = 2505324423u;\n    public const uint StartMagicB = 718793509u;\n    public static int ArrayHash<T>(T[] a) { }\n    public static int ByteHash(byte[] b) { }\n    public static uint ExtendHash(uint hash, uint value, uint magicA, uint magicB) { }\n    public static uint FinalizeHash(uint hash) { }\n    public static uint NextMagicA(uint magicA) { }\n    public static uint NextMagicB(uint magicB) { }\n    public static uint StartHash(uint seed) { }\n    public static int StringHash(string s) { }\n    public static int SymmetricHash<T>(System.Collections.Generic.IEnumerable<T> xs, uint seed) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Performance Comparison Before DotNetty Update (v1.5.22)\nDESCRIPTION: Performance benchmark results showing network throughput before updating DotNetty.Handlers to v0.7.6 to resolve CVE-2018-8292. The data shows message processing performance with varying numbers of clients.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/RELEASE_NOTES.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nNum clients, Total [msg], Msgs/sec, Total [ms], Start Threads, End Threads  \n         1,  200000,    125000,    1600.62,            46,              76  \n         5, 1000000,    494072,    2024.04,            84,              95  \n        10, 2000000,    713013,    2805.73,           103,             107  \n        15, 3000000,    724463,    4141.38,           115,             115  \n        20, 4000000,    714669,    5597.66,           123,             123  \n        25, 5000000,    684932,    7300.37,           131,             107  \n        30, 6000000,    694525,    8639.88,           115,              93  \n```\n\n----------------------------------------\n\nTITLE: Defining IPruningState Interface for Node Pruning in C#\nDESCRIPTION: Defines the IPruningState interface with methods for tracking seen nodes and merging pruning states, which is used for managing removed nodes in a distributed system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IPruningState\n{\n    Akka.DistributedData.IPruningState AddSeen(Akka.Actor.Address node);\n    Akka.DistributedData.IPruningState Merge(Akka.DistributedData.IPruningState other);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DelegateAutoPilot in Akka TestKit\nDESCRIPTION: This class extends AutoPilot and allows defining behavior through delegate functions. It accepts an AutoPilotDelegate to specify actions during message processing. It is dependent on Akka actor interfaces.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DelegateAutoPilot : Akka.TestKit.AutoPilot\n{\n    public DelegateAutoPilot(Akka.TestKit.AutoPilotDelegate autoPilotDelegate) { }\n    public override Akka.TestKit.AutoPilot Run(Akka.Actor.IActorRef sender, object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TokenBucket Class in Akka.NET\nDESCRIPTION: Concrete implementation of ThrottleMode using the token bucket algorithm for rate limiting in Akka.NET remote transport. It manages a bucket of tokens that refill at a specific rate.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class TokenBucket : Akka.Remote.Transport.ThrottleMode\n{\n    public TokenBucket(int capacity, double tokensPerSecond, long nanoTimeOfLastSend, int availableTokens) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override System.TimeSpan TimeToAvailable(long currentNanoTime, int tokens) { }\n    public override System.ValueTuple<Akka.Remote.Transport.ThrottleMode, bool> TryConsumeTokens(long nanoTimeOfSend, int tokens) { }\n    public static bool ==(Akka.Remote.Transport.TokenBucket left, Akka.Remote.Transport.TokenBucket right) { }\n    public static bool !=(Akka.Remote.Transport.TokenBucket left, Akka.Remote.Transport.TokenBucket right) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DiscardToDeadLetterStrategy in C#\nDESCRIPTION: This snippet implements the DiscardToDeadLetterStrategy class, which provides a singleton instance of the discard strategy in Akka. It is specifically designed to handle message overflow by allowing discarded messages to be sent to dead letters.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DiscardToDeadLetterStrategy : Akka.Persistence.IStashOverflowStrategy\n{\n    public static Akka.Persistence.DiscardToDeadLetterStrategy Instance { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Left<TA, TB> Class in C#\nDESCRIPTION: A concrete implementation of Either<TA, TB> representing the left case. Contains a value of type TA and overrides IsLeft to return true and IsRight to return false.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_243\n\nLANGUAGE: C#\nCODE:\n```\npublic class Left<TA, TB> : Akka.Util.Either<TA, TB>\n{\n    public Left(TA a) { }\n    public override bool IsLeft { get; }\n    public override bool IsRight { get; }\n    public TA Value { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Abstract Base Implementation for Actor References\nDESCRIPTION: Base class for actor references implementing core interfaces for actor interaction and comparison\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ActorRefBase : Akka.Actor.IActorRef, Akka.Actor.ICanTell, Akka.Util.ISurrogated, System.IComparable, System.IComparable<Akka.Actor.IActorRef>, System.IEquatable<Akka.Actor.IActorRef>\n```\n\n----------------------------------------\n\nTITLE: Implementing Persistent FSM Classes in C#\nDESCRIPTION: Defines classes for implementing Persistent Finite State Machines in Akka.NET, including state management and state change events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\npublic class static PersistentFSM\n{\n    public interface IFsmState\n    {\n        string Identifier { get; }\n    }\n    public class PersistentFSMSnapshot<TD> : Akka.Persistence.Serialization.IMessage\n    {\n        public PersistentFSMSnapshot(string stateIdentifier, TD data, System.Nullable<System.TimeSpan> timeout) { }\n        public TD Data { get; }\n        public string StateIdentifier { get; }\n        public System.Nullable<System.TimeSpan> Timeout { get; }\n        protected bool Equals(Akka.Persistence.Fsm.PersistentFSM.PersistentFSMSnapshot<TD> other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ReachableMember Class Definition\nDESCRIPTION: This snippet defines a sealed class `ReachableMember` that inherits from `Akka.Cluster.ClusterEvent.ReachabilityEvent`.  It represents the event when a cluster member becomes reachable. It takes a `Akka.Cluster.Member` object in the constructor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class ReachableMember : Akka.Cluster.ClusterEvent.ReachabilityEvent\n{\n    public ReachableMember(Akka.Cluster.Member member) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ReplayMessages Class for Akka.NET Persistence in C#\nDESCRIPTION: This class represents a request to replay messages within a specific sequence number range for a given persistence ID. It includes properties for the persistence ID, start and end sequence numbers, and maximum number of messages to replay.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ReplayMessages : System.IEquatable<Akka.Persistence.Journal.AsyncWriteTarget.ReplayMessages>\n{\n    public ReplayMessages(string persistenceId, long fromSequenceNr, long toSequenceNr, long max) { }\n    public long FromSequenceNr { get; }\n    public long Max { get; }\n    public string PersistenceId { get; }\n    public long ToSequenceNr { get; }\n    public bool Equals(Akka.Persistence.Journal.AsyncWriteTarget.ReplayMessages other) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Akka.NET v1.4.24 Remote Performance\nDESCRIPTION: Performance benchmark results for Akka.NET v1.4.24 using the RemotePingPong benchmark. Shows message throughput and processing time for different numbers of clients.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/RELEASE_NOTES.md#2025-04-16_snippet_13\n\nLANGUAGE: text\nCODE:\n```\nOSVersion:                         Microsoft Windows NT 6.2.9200.0 \nProcessorCount:                    16                              \nClockSpeed:                        0 MHZ                           \nActor Count:                       32                              \nMessages sent/received per client: 200000  (2e5)                   \nIs Server GC:                      True                            \nThread count:                      111                             \n                                                                   \nNum clients, Total [msg], Msgs/sec, Total [ms]                     \n         1,  200000,     96994,    2062.08                         \n         5, 1000000,    194818,    5133.93                         \n        10, 2000000,    198966,   10052.93                         \n        15, 3000000,    199455,   15041.56                         \n        20, 4000000,    198177,   20184.53                         \n        25, 5000000,    197613,   25302.80                         \n        30, 6000000,    197349,   30403.82                         \n```\n\n----------------------------------------\n\nTITLE: Service Lookup Implementation\nDESCRIPTION: Lookup class for defining service discovery queries with support for service name, port name, and protocol specification.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class Lookup : Akka.Actor.INoSerializationVerificationNeeded, System.IEquatable<Akka.Discovery.Lookup>\n{\n    public Lookup(string serviceName, string portName = null, string protocol = null) { }\n    public string PortName { get; }\n    public string Protocol { get; }\n    public string ServiceName { get; }\n    public Akka.Discovery.Lookup Copy(string serviceName = null, string portName = null, string protocol = null) { }\n    public bool Equals(Akka.Discovery.Lookup other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public static bool IsValid(string srv) { }\n    public static Akka.Discovery.Lookup ParseSrv(string srv) { }\n    public override string ToString() { }\n    public Akka.Discovery.Lookup WithPortName(string portName) { }\n    public Akka.Discovery.Lookup WithProtocol(string protocol) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SerializationSetup in Akka.NET\nDESCRIPTION: Defines a setup class for configuring serialization through the ActorSystem setup. It allows passing a factory function to create a set of serializer details when the ActorSystem starts.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_199\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class SerializationSetup : Akka.Actor.Setup.Setup\n{\n    public System.Func<Akka.Actor.ExtendedActorSystem, System.Collections.Immutable.ImmutableHashSet<Akka.Serialization.SerializerDetails>> CreateSerializers { get; }\n    public static Akka.Serialization.SerializationSetup Create(System.Func<Akka.Actor.ExtendedActorSystem, System.Collections.Immutable.ImmutableHashSet<Akka.Serialization.SerializerDetails>> createSerializers) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AtomicReference for Thread-Safe Reference Operations in C#\nDESCRIPTION: Defines the AtomicReference<T> class for thread-safe reference operations in Akka.NET. It provides methods for comparing and setting values atomically for reference types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_206\n\nLANGUAGE: C#\nCODE:\n```\npublic class AtomicReference<T>\n    where T :  class\n{\n    protected T atomicValue;\n    public AtomicReference(T originalValue) { }\n    public AtomicReference() { }\n    public T Value { get; set; }\n    public bool CompareAndSet(T expected, T newValue) { }\n    public T GetAndSet(T newValue) { }\n    public static T op_Implicit(Akka.Util.AtomicReference<T> atomicReference) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IReplicatedData Interface in C#\nDESCRIPTION: This snippet defines the `IReplicatedData` interface, which serves as a base interface for all replicated data types in the system. It includes a `Merge` method for combining two instances of replicated data.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\n    public interface IReplicatedData\n    {\n        Akka.DistributedData.IReplicatedData Merge(Akka.DistributedData.IReplicatedData other);\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Defining ShardRegionStats Class in Akka.NET Sharding\nDESCRIPTION: This class represents statistics for a ShardRegion, including the number of entities per shard. It is useful for monitoring the distribution of entities across shards. The class has a constructor that takes a dictionary of shard IDs to entity counts and a set of failed shard IDs.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\n    public sealed class ShardRegionStats : Akka.Cluster.Sharding.IClusterShardingSerializable, System.IEquatable<Akka.Cluster.Sharding.ShardRegionStats>\n    {\n        public readonly System.Collections.Immutable.IImmutableSet<string> Failed;\n        public readonly System.Collections.Immutable.IImmutableDictionary<string, int> Stats;\n        [System.ObsoleteAttribute(\"Use constructor with `failed` argument. Obsolete since 1.5.0-alpha1\")]\n        public ShardRegionStats(System.Collections.Immutable.IImmutableDictionary<string, int> stats) { }\n        public ShardRegionStats(System.Collections.Immutable.IImmutableDictionary<string, int> stats, System.Collections.Immutable.IImmutableSet<string> failed) { }\n        public override bool Equals(object obj) { }\n        public bool Equals(Akka.Cluster.Sharding.ShardRegionStats other) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining DeleteSnapshotSuccess Class in C#\nDESCRIPTION: Defines a class representing a successful response to a delete snapshot request. This class contains the metadata related to the deleted snapshot and overrides equality and hashing methods.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class DeleteSnapshotSuccess : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage, Akka.Persistence.ISnapshotResponse, System.IEquatable<Akka.Persistence.DeleteSnapshotSuccess>\n{\n    public DeleteSnapshotSuccess(Akka.Persistence.SnapshotMetadata metadata) { }\n    public Akka.Persistence.SnapshotMetadata Metadata { get; }\n    public bool Equals(Akka.Persistence.DeleteSnapshotSuccess other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Equals Method for DeleteSnapshot\nDESCRIPTION: This snippet defines the `Equals` method for the `DeleteSnapshot` class. This method is likely used to compare two `DeleteSnapshot` objects for equality, allowing for efficient checking of duplicate or identical requests.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\n\"public bool Equals(Akka.Persistence.DeleteSnapshot other) { }\"\n```\n\n----------------------------------------\n\nTITLE: Simulating Unplanned Node Crashes with TestConductor.Exit in Akka.NET\nDESCRIPTION: Shows how to simulate an unplanned node shutdown (process crash) using TestConductor.Exit. This method forces the specified node to exit the test completely and will no longer participate in barriers.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/testing/multi-node-testing.md#2025-04-16_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\nRunOn(() => {\n    TestConductor.Exit(_config.Third, 0).Wait();\n}, _config.First);\n```\n\n----------------------------------------\n\nTITLE: TokenBucket Class Implementation (C#)\nDESCRIPTION: Implementation of a token bucket algorithm for rate limiting in the throttle system. Extends ThrottleMode with specific token-based rate limiting behavior.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class TokenBucket : Akka.Remote.Transport.ThrottleMode\n{\n    public TokenBucket(int capacity, double tokensPerSecond, long nanoTimeOfLastSend, int availableTokens) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override System.TimeSpan TimeToAvailable(long currentNanoTime, int tokens) { }\n    public override System.ValueTuple<Akka.Remote.Transport.ThrottleMode, bool> TryConsumeTokens(long nanoTimeOfSend, int tokens) { }\n    public static bool ==(Akka.Remote.Transport.TokenBucket left, Akka.Remote.Transport.TokenBucket right) { }\n    public static bool !=(Akka.Remote.Transport.TokenBucket left, Akka.Remote.Transport.TokenBucket right) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StringFormat Static Class\nDESCRIPTION: Utility class for string formatting operations that provides a SafeJoin method to join objects with a separator, handling null values safely.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_215\n\nLANGUAGE: C#\nCODE:\n```\npublic class static StringFormat\n{\n    public static string SafeJoin(string separator, params object[] args) { }\n}\n```\n\n----------------------------------------\n\nTITLE: ORDictionary Generic Class Implementation\nDESCRIPTION: Implements an Observed-Remove Dictionary for distributed data management with delta-based replication support. Provides operations for adding, updating, and removing key-value pairs across distributed nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ORDictionary<TKey, TValue> : Akka.DistributedData.IDeltaReplicatedData, Akka.DistributedData.IDeltaReplicatedData<Akka.DistributedData.ORDictionary<TKey, TValue>, Akka.DistributedData.ORDictionary<TKey, TValue>.IDeltaOperation>, Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IRemovedNodePruning<Akka.DistributedData.ORDictionary<TKey, TValue>>, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.ORDictionary<TKey, TValue>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable, System.IEquatable<Akka.DistributedData.ORDictionary<TKey, TValue>>\n    where TValue : Akka.DistributedData.IReplicatedData<TValue>\n{\n    public static readonly Akka.DistributedData.ORDictionary<TKey, TValue> Empty;\n    public ORDictionary(Akka.DistributedData.ORSet<TKey> keySet, System.Collections.Immutable.IImmutableDictionary<TKey, TValue> valueMap) { }\n    // ... Additional members omitted for brevity ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AsyncWriteTarget in C#\nDESCRIPTION: Defines the static AsyncWriteTarget class with nested message classes for asynchronous journal operations. These classes encapsulate messages for replay, deletion, and write operations with their associated data.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_54\n\nLANGUAGE: C#\nCODE:\n```\npublic class static AsyncWriteTarget\n{\n    public sealed class DeleteMessagesTo : System.IEquatable<Akka.Persistence.Journal.AsyncWriteTarget.DeleteMessagesTo>\n    {\n        public DeleteMessagesTo(string persistenceId, long toSequenceNr) { }\n        public string PersistenceId { get; }\n        public long ToSequenceNr { get; }\n        public bool Equals(Akka.Persistence.Journal.AsyncWriteTarget.DeleteMessagesTo other) { }\n    }\n    public sealed class ReplayFailure\n    {\n        public ReplayFailure(System.Exception cause) { }\n        public System.Exception Cause { get; }\n    }\n    public sealed class ReplayMessages : System.IEquatable<Akka.Persistence.Journal.AsyncWriteTarget.ReplayMessages>\n    {\n        public ReplayMessages(string persistenceId, long fromSequenceNr, long toSequenceNr, long max) { }\n        public long FromSequenceNr { get; }\n        public long Max { get; }\n        public string PersistenceId { get; }\n        public long ToSequenceNr { get; }\n        public bool Equals(Akka.Persistence.Journal.AsyncWriteTarget.ReplayMessages other) { }\n    }\n    public sealed class ReplaySuccess : System.IEquatable<Akka.Persistence.Journal.AsyncWriteTarget.ReplaySuccess>\n    {\n        public ReplaySuccess(long highestSequenceNr) { }\n        public long HighestSequenceNr { get; }\n        public bool Equals(Akka.Persistence.Journal.AsyncWriteTarget.ReplaySuccess other) { }\n    }\n    public sealed class WriteMessages\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ITellScheduler Interface in C#\nDESCRIPTION: Specifies the ITellScheduler interface with methods for scheduling one-time and repeated message sending to actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ITellScheduler\n{\n    void ScheduleTellOnce(System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender);\n    void ScheduleTellOnce(System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable);\n    void ScheduleTellRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender);\n    void ScheduleTellRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IAtomicState Interface\nDESCRIPTION: Interface for atomic state management that provides thread-safety for executing operations. It supports entering critical sections, invoking asynchronous operations, and event notification.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_229\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.Util.Internal\n{\n    public interface IAtomicState\n    {\n        bool HasListeners { get; }\n        void AddListener(System.Action listener);\n        void Enter();\n        System.Threading.Tasks.Task<T> Invoke<T>(System.Func<System.Threading.Tasks.Task<T>> body);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SimpleDnsManager Class in C#\nDESCRIPTION: Manages DNS operations. It inherits from ActorBase and implements IRequiresMessageQueue for unbounded message queues.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_165\n\nLANGUAGE: C#\nCODE:\n```\npublic class SimpleDnsManager : Akka.Actor.ActorBase, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedMessageQueueSemantics>\n{\n    public SimpleDnsManager(Akka.IO.DnsExt ext) { }\n    protected override void PostStop() { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: MultiVersionVector Class Implementation\nDESCRIPTION: Sealed class extending VersionVector for managing version tracking across distributed nodes. Implements version comparison, merging, and pruning functionality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class MultiVersionVector : Akka.DistributedData.VersionVector\n{\n    public MultiVersionVector(params System.Collections.Generic.KeyValuePair<, >[] nodeVersions) { }\n    public MultiVersionVector(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<Akka.Cluster.UniqueAddress, long>> versions) { }\n    public MultiVersionVector(System.Collections.Immutable.ImmutableDictionary<Akka.Cluster.UniqueAddress, long> nodeVersions) { }\n    public override int Count { get; }\n    public override bool IsEmpty { get; }\n    public override System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.UniqueAddress> ModifiedByNodes { get; }\n    public override System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<Akka.Cluster.UniqueAddress, long>> VersionEnumerator { get; }\n    public override bool Contains(Akka.Cluster.UniqueAddress node) { }\n    public override int GetHashCode() { }\n    public override Akka.DistributedData.VersionVector Increment(Akka.Cluster.UniqueAddress node) { }\n    public override Akka.DistributedData.VersionVector Merge(Akka.DistributedData.VersionVector other) { }\n    public override bool NeedPruningFrom(Akka.Cluster.UniqueAddress removedNode) { }\n    public override Akka.DistributedData.VersionVector Prune(Akka.Cluster.UniqueAddress removedNode, Akka.Cluster.UniqueAddress collapseInto) { }\n    public override Akka.DistributedData.VersionVector PruningCleanup(Akka.Cluster.UniqueAddress removedNode) { }\n    public override string ToString() { }\n    public override long VersionAt(Akka.Cluster.UniqueAddress node) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Flag Class Implementation in Akka.NET\nDESCRIPTION: Sealed class implementing a distributed boolean flag data type with comparison and equality operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Flag : Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.Flag>, System.IComparable, System.IComparable<Akka.DistributedData.Flag>, System.IEquatable<Akka.DistributedData.Flag>\n{\n    public static readonly Akka.DistributedData.Flag False;\n    public static readonly Akka.DistributedData.Flag True;\n    public Flag() { }\n    public Flag(bool enabled) { }\n    public bool Enabled { get; }\n    public int CompareTo(object obj) { }\n    public int CompareTo(Akka.DistributedData.Flag other) { }\n    public bool Equals(Akka.DistributedData.Flag other) { }\n    public override bool Equals(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ISnapshotQueryExecutor Interface in C#\nDESCRIPTION: Defines an interface for executing SQL queries related to snapshot operations in Akka.NET persistence. It includes methods for creating tables, deleting snapshots, inserting snapshots, and selecting snapshots from a database.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nSystem.Threading.Tasks.Task CreateTableAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken);\nSystem.Threading.Tasks.Task DeleteAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string persistenceId, long sequenceNr, System.Nullable<System.DateTime> timestamp);\nSystem.Threading.Tasks.Task DeleteBatchAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string persistenceId, long maxSequenceNr, System.DateTime maxTimestamp);\nSystem.Threading.Tasks.Task InsertAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, object snapshot, Akka.Persistence.SnapshotMetadata metadata);\nSystem.Threading.Tasks.Task<Akka.Persistence.SelectedSnapshot> SelectSnapshotAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string persistenceId, long maxSequenceNr, System.DateTime maxTimestamp);\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract BlockingMessageQueue Class in C#\nDESCRIPTION: Abstract base class for blocking message queues in Akka.NET. Provides the basic implementation for queues that can block on dequeue operations when empty, with configurable timeout settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_106\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class BlockingMessageQueue : Akka.Dispatch.IBlockingMessageQueueSemantics, Akka.Dispatch.IMultipleConsumerSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.MessageQueues.IMessageQueue\n{\n    protected BlockingMessageQueue() { }\n    public System.TimeSpan BlockTimeOut { get; set; }\n    public int Count { get; }\n    public bool HasMessages { get; }\n    protected abstract int LockedCount { get; }\n    public void CleanUp(Akka.Actor.IActorRef owner, Akka.Dispatch.MessageQueues.IMessageQueue deadletters) { }\n    public void Enqueue(Akka.Actor.IActorRef receiver, Akka.Actor.Envelope envelope) { }\n    protected abstract void LockedEnqueue(Akka.Actor.Envelope envelope);\n    protected abstract bool LockedTryDequeue(out Akka.Actor.Envelope envelope);\n    public bool TryDequeue(out Akka.Actor.Envelope envelope) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly Attributes for Akka.DistributedData\nDESCRIPTION: Assembly-level attributes that define metadata and visibility for the Akka.DistributedData library. This includes repository information, internal visibility to related Akka modules, and framework targeting information.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Benchmarks\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding.Tests.MultiNode\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.DistributedData.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.DistributedData.Tests.MultiNode\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"f22db348-9ab3-4c6a-b1e8-9b835308d367\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETCoreApp,Version=v6.0\", FrameworkDisplayName=\".NET 6.0\")]\n```\n\n----------------------------------------\n\nTITLE: Creating Actor Instances using ActorSystem and Context\nDESCRIPTION: Shows how to create actor instances using both ActorSystem for top-level actors and ActorContext for child actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nActorSystem system = ActorSystem.Create(\"MySystem\");\nIActorRef myActor = system.ActorOf<MyActor>(\"myactor\");\n```\n\n----------------------------------------\n\nTITLE: Implementing PersistencePluginProxy Class in C#\nDESCRIPTION: Defines a PersistencePluginProxy class that extends ActorBase and implements multiple interfaces for actor stashing and message queue semantics. It includes methods for starting and setting target location for the proxy.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_52\n\nLANGUAGE: C#\nCODE:\n```\npublic class PersistencePluginProxy : Akka.Actor.ActorBase, Akka.Actor.IActorStash, Akka.Actor.IWithUnboundedStash, Akka.Actor.IWithUnrestrictedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics>\n{\n    public PersistencePluginProxy(Akka.Configuration.Config config) { }\n    public Akka.Actor.IStash Stash { get; set; }\n    protected override void PreStart() { }\n    protected override bool Receive(object message) { }\n    public static void SetTargetLocation(Akka.Actor.ActorSystem system, Akka.Actor.Address address) { }\n    public static void Start(Akka.Actor.ActorSystem system) { }\n    public sealed class TargetLocation\n    {\n        public TargetLocation(Akka.Actor.Address address) { }\n        public Akka.Actor.Address Address { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CurrentRegions Class in C#\nDESCRIPTION: A sealed class representing current regions in cluster sharding, including a set of actor addresses and methods for equality comparison and string representation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class CurrentRegions : Akka.Cluster.Sharding.IClusterShardingSerializable, System.IEquatable<Akka.Cluster.Sharding.CurrentRegions>\n{\n    public readonly System.Collections.Immutable.IImmutableSet<Akka.Actor.Address> Regions;\n    public CurrentRegions(System.Collections.Immutable.IImmutableSet<Akka.Actor.Address> regions) { }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.Cluster.Sharding.CurrentRegions other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Config Service Discovery Implementation\nDESCRIPTION: Configuration-based service discovery implementation that loads service information from config files.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class ConfigServiceDiscovery : Akka.Discovery.ServiceDiscovery\n{\n    public ConfigServiceDiscovery(Akka.Actor.ExtendedActorSystem system) { }\n    public override System.Threading.Tasks.Task<Akka.Discovery.ServiceDiscovery.Resolved> Lookup(Akka.Discovery.Lookup lookup, System.TimeSpan resolveTimeout) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Split Message Ordering Test with Multiple Probes\nDESCRIPTION: Alternative fix using separate TestProbe instances to handle independent message streams.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/debugging.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[Test]\npublic void SplitOrderingAssumption()\n{\n    var probe1 = CreateTestProbe();\n    var probe2 = CreateTestProbe();\n    var actor1 = Sys.ActorOf(Props.Create(() => new SomeActor(probe1)));\n    var actor2 = Sys.ActorOf(Props.Create(() => new SomeActor(probe2)));\n\n    actor1.Tell(\"msg1\");\n    actor2.Tell(\"msg2\");\n\n    probe1.ExpectMsg(\"msg1\");\n    probe2.ExpectMsg(\"msg2\");\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IMemoryMessages Interface for Akka.NET Persistence\nDESCRIPTION: This interface defines methods for managing in-memory persistent messages in Akka.NET, including adding, deleting, updating, and reading messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IMemoryMessages\n{\n    System.Collections.Generic.IDictionary<string, System.Collections.Generic.LinkedList<Akka.Persistence.IPersistentRepresentation>> Add(Akka.Persistence.IPersistentRepresentation persistent);\n    System.Collections.Generic.IDictionary<string, System.Collections.Generic.LinkedList<Akka.Persistence.IPersistentRepresentation>> Delete(string pid, long seqNr);\n    long HighestSequenceNr(string pid);\n    System.Collections.Generic.IEnumerable<Akka.Persistence.IPersistentRepresentation> Read(string pid, long fromSeqNr, long toSeqNr, long max);\n    System.Collections.Generic.IDictionary<string, System.Collections.Generic.LinkedList<Akka.Persistence.IPersistentRepresentation>> Update(string pid, long seqNr, System.Func<Akka.Persistence.IPersistentRepresentation, Akka.Persistence.IPersistentRepresentation> updater);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RoutingLogic Abstract Class in C#\nDESCRIPTION: Definition of the RoutingLogic abstract class which serves as the base for all routing logic implementations. Each concrete implementation must provide a Select method to determine which routee should receive a message.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_196\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class RoutingLogic : Akka.Actor.INoSerializationVerificationNeeded\n{\n    protected RoutingLogic() { }\n    public abstract Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SelectParent Class in C#\nDESCRIPTION: Implements the SelectParent class with static Instance property and overridden object methods.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\npublic static readonly Akka.Actor.SelectParent Instance;\npublic SelectParent() { }\npublic override bool Equals(object obj) { }\npublic override int GetHashCode() { }\npublic override string ToString() { }\n```\n\n----------------------------------------\n\nTITLE: Providing Xunit Assertion Methods in C#\nDESCRIPTION: This snippet defines the XunitAssertions class, containing standard assertion methods like AssertEqual, AssertTrue, and AssertFalse for validating test conditions within the Akka.NET framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKitXunit2.Net.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic class XunitAssertions : Akka.TestKit.ITestKitAssertions\n{\n    public XunitAssertions() { }\n    public void AssertEqual<T>(T expected, T actual, string format = \"\", params object[] args) { }\n    public void AssertEqual<T>(T expected, T actual, System.Func<T, T, bool> comparer, string format = \"\", params object[] args) { }\n    public void AssertFalse(bool condition, string format = \"\", params object[] args) { }\n    public void AssertTrue(bool condition, string format = \"\", params object[] args) { }\n    public void Fail(string format = \"\", params object[] args) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Type Cache Lookup Implementation in C#\nDESCRIPTION: Static method for retrieving Type objects by their string name, likely implementing caching for performance optimization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_271\n\nLANGUAGE: C#\nCODE:\n```\npublic static System.Type GetType(string typeName) { }\n```\n\n----------------------------------------\n\nTITLE: Snapshot Management Classes in C#\nDESCRIPTION: Classes for managing snapshot operations including metadata, save operations, and selection. Implements interfaces for serialization and message handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SnapshotMetadata : System.IEquatable<Akka.Persistence.SnapshotMetadata>\n{\n    [System.ObsoleteAttribute(\"This constructor is deprecated and will be removed in v1.6. Use the constructor with the timestamp parameter instead. Since v1.5.28\", true)]\n    public SnapshotMetadata(string persistenceId, long sequenceNr) { }\n    [Newtonsoft.Json.JsonConstructorAttribute()]\n    public SnapshotMetadata(string persistenceId, long sequenceNr, System.DateTime timestamp) { }\n    public static System.Collections.Generic.IComparer<Akka.Persistence.SnapshotMetadata> Comparer { get; }\n    public string PersistenceId { get; }\n    public long SequenceNr { get; }\n    public System.DateTime Timestamp { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing HOCON Configuration Parsing in C#\nDESCRIPTION: This snippet defines methods for parsing and retrieving values from HOCON (Human-Optimized Config Object Notation) configuration. It includes methods for getting various data types and handling arrays and objects.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_68\n\nLANGUAGE: C#\nCODE:\n```\npublic void Clear() { }\npublic System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray() { }\npublic bool GetBoolean() { }\npublic System.Collections.Generic.IList<bool> GetBooleanList() { }\npublic byte GetByte() { }\npublic System.Collections.Generic.IList<byte> GetByteList() { }\npublic System.Nullable<long> GetByteSize() { }\npublic Akka.Configuration.Hocon.HoconValue GetChildObject(string key) { }\npublic decimal GetDecimal() { }\npublic System.Collections.Generic.IList<decimal> GetDecimalList() { }\npublic double GetDouble() { }\npublic System.Collections.Generic.IList<double> GetDoubleList() { }\npublic float GetFloat() { }\npublic System.Collections.Generic.IList<float> GetFloatList() { }\npublic int GetInt() { }\npublic System.Collections.Generic.IList<int> GetIntList() { }\npublic long GetLong() { }\npublic System.Collections.Generic.IList<long> GetLongList() { }\npublic Akka.Configuration.Hocon.HoconObject GetObject() { }\npublic string GetString() { }\npublic System.Collections.Generic.IList<string> GetStringList() { }\npublic System.TimeSpan GetTimeSpan(bool allowInfinite = True) { }\npublic bool IsArray() { }\npublic bool IsObject() { }\npublic bool IsString() { }\npublic void NewValue(Akka.Configuration.Hocon.IHoconElement value) { }\npublic Akka.Configuration.Config ToConfig() { }\npublic override string ToString() { }\npublic virtual string ToString(int indent) { }\n```\n\n----------------------------------------\n\nTITLE: Creating a ShardRegionProxy for Read-Only Cluster Nodes in C#\nDESCRIPTION: Shows how to create a proxy to communicate with sharded entities without participating in the sharding itself. This is useful for nodes that only need to send messages to entities.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-sharding.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar proxy = ClusterSharding.Get(system).StartProxy(\n    typeName: \"my-actor\",\n    role: null,\n    messageExtractor: new MessageExtractor());\n```\n\n----------------------------------------\n\nTITLE: Implementing ORSet Static Class in C#\nDESCRIPTION: This static class provides factory methods for creating ORSet instances, which are distributed sets in Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\npublic class static ORSet\n{\n    public static Akka.DistributedData.ORSet<T> Create<T>(Akka.Cluster.UniqueAddress node, T element) { }\n    public static Akka.DistributedData.ORSet<T> Create<T>(params System.Collections.Generic.KeyValuePair<, >[] elements) { }\n    public static Akka.DistributedData.ORSet<T> Create<T>(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<Akka.Cluster.UniqueAddress, T>> elements) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ILogMessageFormatter Interface in C#\nDESCRIPTION: Interface for message formatters that handle converting log messages and arguments into formatted strings. It defines methods for formatting strings with either parameter arrays or IEnumerable collections.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_128\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ILogMessageFormatter\n{\n    string Format(string format, params object[] args);\n    string Format(string format, System.Collections.Generic.IEnumerable<object> args);\n}\n```\n\n----------------------------------------\n\nTITLE: Logging Message Levels in Akka.NET\nDESCRIPTION: Demonstrates different logging levels used in an Akka.NET actor system, showing various log message severities and formats\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/DefaultLogFormatSpec.ShouldUseDefaultLogFormat.DotNet.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[DEBUG][DateTime][Thread 0001][ActorSystem(test)] This is a test 1 cheese\n```\n\nLANGUAGE: csharp\nCODE:\n```\n[INFO][DateTime][Thread 0001][ActorSystem(test)] This is a test 1\n```\n\nLANGUAGE: csharp\nCODE:\n```\n[WARNING][DateTime][Thread 0001][ActorSystem(test)] This is a test 1\n```\n\nLANGUAGE: csharp\nCODE:\n```\n[ERROR][DateTime][Thread 0001][ActorSystem(test)] This is a test 1\n```\n\n----------------------------------------\n\nTITLE: Implementing Remote Transport Adapter in C#\nDESCRIPTION: Abstract base class for implementing transport adapters in Akka.NET remote communication. Provides core functionality for associating with remote addresses and handling wrapped transport.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AbstractTransportAdapter : Akka.Remote.Transport.Transport\n{\n    protected Akka.Remote.Transport.Transport WrappedTransport;\n    protected AbstractTransportAdapter(Akka.Remote.Transport.Transport wrappedTransport) { }\n    public override long MaximumPayloadBytes { get; }\n    protected abstract Akka.Remote.Transport.SchemeAugmenter SchemeAugmenter { get; }\n    public override string SchemeIdentifier { get; }\n    public override System.Threading.Tasks.Task<Akka.Remote.Transport.AssociationHandle> Associate(Akka.Actor.Address remoteAddress) { }\n}\n```\n\n----------------------------------------\n\nTITLE: FastMerge Abstract Class for Optimized Data Merging\nDESCRIPTION: Abstract base class for replicated data types that support fast merging operations. It provides internal API methods for tracking ancestry relationships between data instances to optimize merges.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic abstract class FastMerge<T> : Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedData<T>\n    where T : Akka.DistributedData.FastMerge<T>\n{\n    protected FastMerge() { }\n    [Akka.Annotations.InternalApiAttribute()]\n    protected T AssignAncestor(T newData) { }\n    [Akka.Annotations.InternalApiAttribute()]\n    protected T ClearAncestor() { }\n    [Akka.Annotations.InternalApiAttribute()]\n    protected bool IsAncestorOf(T newData) { }\n    public abstract T Merge(T other);\n    public Akka.DistributedData.IReplicatedData Merge(Akka.DistributedData.IReplicatedData other) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Using UniqueKillSwitch for Shutdown in Akka.NET Streams\nDESCRIPTION: Example of using UniqueKillSwitch to control the completion of a single materialized Graph of FlowShape. This snippet demonstrates shutting down the stream.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/stream-dynamic.md#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n[!code-csharp[KillSwitchDocTests.cs](../../../src/core/Akka.Docs.Tests/Streams/KillSwitchDocTests.cs?name=unique-shutdown)]\n```\n\n----------------------------------------\n\nTITLE: Creating AdaptiveLoadBalancingPool in Akka.NET\nDESCRIPTION: This class defines a pool of actors that will use adaptive load balancing strategies based on metrics selectors. It provides methods for adjusting the pool size and dispatcher settings based on runtime conditions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Core.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class AdaptiveLoadBalancingPool : Akka.Routing.Pool\n{\n    public AdaptiveLoadBalancingPool(Akka.Cluster.Metrics.IMetricsSelector metricsSelector = null, int nrOfInstances = 0, Akka.Actor.SupervisorStrategy supervisorStrategy = null, string routerDispatcher = null, bool usePoolDispatcher = False) { }\n    public AdaptiveLoadBalancingPool(Akka.Configuration.Config config) { }\n    public Akka.Cluster.Metrics.IMetricsSelector MetricsSelector { get; }\n    public override Akka.Routing.Resizer Resizer { get; }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }\n    public override Akka.Actor.Props RoutingLogicController(Akka.Routing.RoutingLogic routingLogic) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Cluster.Metrics.AdaptiveLoadBalancingPool WithDispatcher(string dispatcherId) { }\n    public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n    public Akka.Cluster.Metrics.AdaptiveLoadBalancingPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }\n    public class AdaptiveLoadBalancingPoolSurrogate : Akka.Util.ISurrogate\n    {\n        public AdaptiveLoadBalancingPoolSurrogate() { }\n        public Akka.Cluster.Metrics.IMetricsSelector MetricsSelector { get; set; }\n        public int NrOfInstances { get; set; }\n        public string RouterDispatcher { get; set; }\n        public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }\n        public bool UsePoolDispatcher { get; set; }\n        public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ReplicatorSettings Configuration Methods in C#\nDESCRIPTION: Contains method signatures for creating and configuring ReplicatorSettings in Akka.NET's DistributedData module. These methods allow customization of replication parameters such as gossip interval, pruning, and durability settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\npublic static Akka.DistributedData.ReplicatorSettings Create(Akka.Configuration.Config config) { }\npublic Akka.DistributedData.ReplicatorSettings WithDispatcher(string dispatcher) { }\npublic Akka.DistributedData.ReplicatorSettings WithDurableKeys(System.Collections.Immutable.IImmutableSet<string> durableKeys) { }\npublic Akka.DistributedData.ReplicatorSettings WithDurableStoreProps(Akka.Actor.Props durableStoreProps) { }\npublic Akka.DistributedData.ReplicatorSettings WithGossipInterval(System.TimeSpan gossipInterval) { }\npublic Akka.DistributedData.ReplicatorSettings WithMaxDeltaElements(int maxDeltaElements) { }\npublic Akka.DistributedData.ReplicatorSettings WithMaxDeltaSize(int maxDeltaSize) { }\npublic Akka.DistributedData.ReplicatorSettings WithNotifySubscribersInterval(System.TimeSpan notifySubscribersInterval) { }\npublic Akka.DistributedData.ReplicatorSettings WithPreferOldest(bool preferOldest) { }\npublic Akka.DistributedData.ReplicatorSettings WithPruning(System.TimeSpan pruningInterval, System.TimeSpan maxPruningDissemination) { }\npublic Akka.DistributedData.ReplicatorSettings WithPruningMarkerTimeToLive(System.TimeSpan pruningMarkerTtl, System.TimeSpan durablePruningMarkerTtl) { }\npublic Akka.DistributedData.ReplicatorSettings WithRestartReplicatorOnFailure(bool restart) { }\npublic Akka.DistributedData.ReplicatorSettings WithRole(string role) { }\npublic Akka.DistributedData.ReplicatorSettings WithVerboseDebugLogging(bool verboseDebugLogging) { }\n```\n\n----------------------------------------\n\nTITLE: Creating RandomPool Router from HOCON Configuration in C#\nDESCRIPTION: Demonstrates how to create a random pool router from HOCON configuration, which will distribute messages randomly to worker instances.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nvar router = system.ActorOf(Props.Create<Worker>().WithRouter(FromConfig.Instance), \"some-pool\");\n```\n\n----------------------------------------\n\nTITLE: Configuring ShardRegion with ShardingConsumerController in C#\nDESCRIPTION: Shows how to set up a ShardRegion with ShardingConsumerController, including the necessary Props and message extractor configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-sharding-delivery.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar messageExtractor = new ShardingMessageExtractor();\nvar entityProps = Props.Create(() =>\n    ShardingConsumerController.Create<IConfirmableMessage>(\n        c => Props.Create(() => new ShoppingCart(c))));\n\nvar region = ClusterSharding.Get(system).Start(\n    typeName: \"shopping-cart\",\n    entityProps: entityProps,\n    settings: ClusterShardingSettings.Create(system),\n    messageExtractor: messageExtractor);\n```\n\n----------------------------------------\n\nTITLE: Defining DeleteSnapshotsSuccess Class in C#\nDESCRIPTION: Represents a successful response for deleting snapshots in Akka Persistence, holding the criteria that were applied for the deletion. It extends the message capabilities to include successful operation confirmation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class DeleteSnapshotsSuccess : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage, Akka.Persistence.ISnapshotResponse, System.IEquatable<Akka.Persistence.DeleteSnapshotsSuccess>\n{\n    public DeleteSnapshotsSuccess(Akka.Persistence.SnapshotSelectionCriteria criteria) { }\n    public Akka.Persistence.SnapshotSelectionCriteria Criteria { get; }\n    public bool Equals(Akka.Persistence.DeleteSnapshotsSuccess other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterSingletonState Enumeration\nDESCRIPTION: Enumeration defining various states of a cluster singleton throughout its lifecycle.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic enum ClusterSingletonState\n{\n    Start = 0,\n    AcquiringLease = 1,\n    Oldest = 2,\n    Younger = 3,\n    BecomingOldest = 4,\n    WasOldest = 5,\n    HandingOver = 6,\n    TakeOver = 7,\n    Stopping = 8,\n    End = 9,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IKey Interface in C#\nDESCRIPTION: This snippet defines a generic interface `IKey<out T>` that inherits from `Akka.DistributedData.IKey` and `Akka.DistributedData.IReplicatedDataSerialization`. The generic type parameter `T` is constrained to be an `Akka.DistributedData.IReplicatedData`, indicating that this key is associated with a specific type of replicated data.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n    public interface IKey<out T> : Akka.DistributedData.IKey, Akka.DistributedData.IReplicatedDataSerialization\n        where out T : Akka.DistributedData.IReplicatedData { }\n\n```\n\n----------------------------------------\n\nTITLE: Defining SaveSnapshot Class in C#\nDESCRIPTION: This snippet defines the SaveSnapshot class, which represents a request to save a snapshot in Akka.NET persistence.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SaveSnapshot : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage, Akka.Persistence.ISnapshotRequest, System.IEquatable<Akka.Persistence.SaveSnapshot>\n{\n    public SaveSnapshot(Akka.Persistence.SnapshotMetadata metadata, object snapshot) { }\n    public Akka.Persistence.SnapshotMetadata Metadata { get; }\n    public object Snapshot { get; }\n    public bool Equals(Akka.Persistence.SaveSnapshot other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NullSerializer in C#\nDESCRIPTION: A serializer that doesn't perform any actual serialization. Used as a placeholder or for special cases where serialization can be bypassed, with customizable identifier and manifest settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_212\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullSerializer : Akka.Serialization.Serializer\n    {\n        public NullSerializer(Akka.Actor.ExtendedActorSystem system) { }\n        public override int Identifier { get; }\n        public override bool IncludeManifest { get; }\n        public override object FromBinary(byte[] bytes, System.Type type) { }\n        public override byte[] ToBinary(object obj) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Extending Props with Supervisor Strategy in Akka.NET (C#)\nDESCRIPTION: Method for setting a custom supervisor strategy on an actor Props instance. This allows customizing how an actor handles failures of its children.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic Akka.Actor.Props WithSupervisorStrategy(Akka.Actor.SupervisorStrategy supervisorStrategy) { }\n```\n\n----------------------------------------\n\nTITLE: Defining Persistence Extension Class in Akka.NET\nDESCRIPTION: This code defines the `Persistence` class, which serves as an extension ID provider for the `PersistenceExtension` in Akka.NET. It provides static access to the `PersistenceExtension` instance and overrides the `CreateExtension` method to create a new `PersistenceExtension` instance. It also provides access to the default configuration using `DefaultConfig()`.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Persistence : Akka.Actor.ExtensionIdProvider<Akka.Persistence.PersistenceExtension>\n{\n    public Persistence() { }\n    public static Akka.Persistence.Persistence Instance { get; }\n    public override Akka.Persistence.PersistenceExtension CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n    public static Akka.Configuration.Config DefaultConfig() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Eager Initialization for Persistence Plugins in Akka.NET\nDESCRIPTION: HOCON configuration example showing how to enable eager initialization for SQLite journal and snapshot store plugins in Akka.NET Persistence, rather than the default on-demand initialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/storage-plugins.md#2025-04-16_snippet_2\n\nLANGUAGE: hocon\nCODE:\n```\nakka {\n  persistence {\n    journal {\n      plugin = \"akka.persistence.journal.sqlite\"\n      auto-start-journals = [\"akka.persistence.journal.sqlite\"]\n    }\n    snapshot-store {\n      plugin = \"akka.persistence.snapshot-store.sqlite\"\n      auto-start-snapshot-stores = [\"akka.persistence.snapshot-store.sqlite\"]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: VersionVector Abstract Class Definition in C#\nDESCRIPTION: The abstract base class for version vectors in Akka.NET's distributed data system. Provides mechanisms for tracking causality between different versions of replicated data across a cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_52\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class VersionVector : Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IRemovedNodePruning<Akka.DistributedData.VersionVector>, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.VersionVector>, System.IEquatable<Akka.DistributedData.VersionVector>\n{\n    protected static readonly Akka.Util.Internal.AtomicCounterLong Counter;\n    public static readonly Akka.DistributedData.VersionVector Empty;\n    protected VersionVector() { }\n    public abstract int Count { get; }\n    public abstract bool IsEmpty { get; }\n    public abstract System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.UniqueAddress> ModifiedByNodes { get; }\n    public abstract System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<Akka.Cluster.UniqueAddress, long>> VersionEnumerator { get; }\n    public Akka.DistributedData.VersionVector.Ordering Compare(Akka.DistributedData.VersionVector other) { }\n    public abstract bool Contains(Akka.Cluster.UniqueAddress node);\n    public static Akka.DistributedData.VersionVector Create(Akka.Cluster.UniqueAddress node, long version) { }\n    public static Akka.DistributedData.VersionVector Create(System.Collections.Immutable.ImmutableDictionary<Akka.Cluster.UniqueAddress, long> versions) { }\n    public bool Equals(Akka.DistributedData.VersionVector other) { }\n    public override bool Equals(object obj) { }\n    public abstract Akka.DistributedData.VersionVector Increment(Akka.Cluster.UniqueAddress node);\n    public bool IsAfter(Akka.DistributedData.VersionVector y) { }\n    public bool IsBefore(Akka.DistributedData.VersionVector y) { }\n    public bool IsConcurrent(Akka.DistributedData.VersionVector y) { }\n    public bool IsSame(Akka.DistributedData.VersionVector y) { }\n    public abstract Akka.DistributedData.VersionVector Merge(Akka.DistributedData.VersionVector other);\n    public Akka.DistributedData.IReplicatedData Merge(Akka.DistributedData.IReplicatedData other) { }\n    public abstract bool NeedPruningFrom(Akka.Cluster.UniqueAddress removedNode);\n    public abstract Akka.DistributedData.VersionVector Prune(Akka.Cluster.UniqueAddress removedNode, Akka.Cluster.UniqueAddress collapseInto);\n    public abstract Akka.DistributedData.VersionVector PruningCleanup(Akka.Cluster.UniqueAddress removedNode);\n    public abstract long VersionAt(Akka.Cluster.UniqueAddress node);\n```\n\n----------------------------------------\n\nTITLE: Defining InterlockedSpin Class in C#\nDESCRIPTION: Defines the InterlockedSpin static class which likely provides methods for spin-based synchronization. This class appears to be empty in the provided code snippet, but would typically contain methods for low-level concurrency control.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_267\n\nLANGUAGE: C#\nCODE:\n```\npublic class static InterlockedSpin\n{\n\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LogLevel Enumeration in C#\nDESCRIPTION: An enumeration that defines the standard log levels in increasing order of severity: Debug, Info, Warning, and Error.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_140\n\nLANGUAGE: C#\nCODE:\n```\npublic enum LogLevel\n{\n    DebugLevel = 0,\n    InfoLevel = 1,\n    WarningLevel = 2,\n    ErrorLevel = 3,\n}\n```\n\n----------------------------------------\n\nTITLE: Cluster Vector Clock Operations in C#\nDESCRIPTION: Defines vector clock methods for comparing and merging distributed system states with support for node-based versioning\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic Akka.Cluster.VectorClock Merge(Akka.Cluster.VectorClock that) { }\n```\n\n----------------------------------------\n\nTITLE: Multiple Ways to Define Array Values in HOCON\nDESCRIPTION: Demonstrates three equivalent methods to define the same array value: as one complete array, as two concatenated arrays, and using self-referential substitution.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/hocon.md#2025-04-16_snippet_3\n\nLANGUAGE: hocon\nCODE:\n```\n// one array\na : [ 1, 2, 3, 4 ]\n// two arrays that are concatenated\na : [ 1, 2 ] [ 3, 4 ]\n// a later definition referring to an earlier\n// (see \"self-referential substitutions\" below)\na : [ 1, 2 ]\na : ${a} [ 3, 4 ]\n```\n\n----------------------------------------\n\nTITLE: Defining EventStream Extension Methods in C#\nDESCRIPTION: Static extension methods for EventStream that provide type-safe subscription and unsubscription for specific channel types. These methods simplify the process of subscribing actors to specific event types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_127\n\nLANGUAGE: C#\nCODE:\n```\npublic class static EventStreamExtensions\n{\n    public static bool Subscribe<TChannel>(this Akka.Event.EventStream eventStream, Akka.Actor.IActorRef subscriber) { }\n    public static bool Unsubscribe<TChannel>(this Akka.Event.EventStream eventStream, Akka.Actor.IActorRef subscriber) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Association Event Interfaces for Akka.NET Remote Transport\nDESCRIPTION: Interfaces for association events and handlers in Akka.NET remote transport. IAssociationEvent and IHandleEvent mark events, while their respective listener interfaces define notification methods for receiving events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IAssociationEvent : Akka.Actor.INoSerializationVerificationNeeded { }\n\npublic interface IAssociationEventListener\n{\n    void Notify(Akka.Remote.Transport.IAssociationEvent ev);\n}\n\npublic interface IHandleEvent : Akka.Actor.INoSerializationVerificationNeeded { }\n\npublic interface IHandleEventListener\n{\n    void Notify(Akka.Remote.Transport.IHandleEvent ev);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ORDictionary Static Class for Akka.NET Distributed Data in C#\nDESCRIPTION: Defines the static ORDictionary class with methods for creating instances of ORDictionary<TKey, TValue>. It provides various overloads for creating dictionaries with different input types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic class static ORDictionary\n{\n    public static Akka.DistributedData.ORDictionary<TKey, TValue> Create<TKey, TValue>(Akka.Cluster.UniqueAddress node, TKey key, TValue value)\n        where TValue : Akka.DistributedData.IReplicatedData<TValue> { }\n    public static Akka.DistributedData.ORDictionary<TKey, TValue> Create<TKey, TValue>(params System.ValueTuple<, , >[] elements)\n        where TValue : Akka.DistributedData.IReplicatedData<TValue> { }\n    public static Akka.DistributedData.ORDictionary<TKey, TValue> Create<TKey, TValue>(System.Collections.Generic.IEnumerable<System.ValueTuple<Akka.Cluster.UniqueAddress, TKey, TValue>> elements)\n        where TValue : Akka.DistributedData.IReplicatedData<TValue> { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DeleteSnapshotsSuccess Class in C#\nDESCRIPTION: This snippet outlines the DeleteSnapshotsSuccess class, which indicates the successful execution of a delete snapshots operation. It holds criteria information as well as implements equality checks and necessary message interfaces.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class DeleteSnapshotsSuccess : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage, Akka.Persistence.ISnapshotResponse, System.IEquatable<Akka.Persistence.DeleteSnapshotsSuccess>\n{\n    public DeleteSnapshotsSuccess(Akka.Persistence.SnapshotSelectionCriteria criteria) { }\n    public Akka.Persistence.SnapshotSelectionCriteria Criteria { get; }\n    public bool Equals(Akka.Persistence.DeleteSnapshotsSuccess other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DeleteSnapshotsFailure Class in C#\nDESCRIPTION: Describes a failure response for snapshot deletion operations, containing the criteria used for the deletion and the cause of failure. This facilitates more informative error handling in persistence operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class DeleteSnapshotsFailure : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage, Akka.Persistence.ISnapshotResponse, System.IEquatable<Akka.Persistence.DeleteSnapshotsFailure>\n{\n    public DeleteSnapshotsFailure(Akka.Persistence.SnapshotSelectionCriteria criteria, System.Exception cause) { }\n    public System.Exception Cause { get; }\n    public Akka.Persistence.SnapshotSelectionCriteria Criteria { get; }\n    public bool Equals(Akka.Persistence.DeleteSnapshotsFailure other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IUpdateResponse Interface in C#\nDESCRIPTION: This snippet defines the `IUpdateResponse` interface, representing the response to an update operation. It inherits from `Akka.Actor.INoSerializationVerificationNeeded`. It includes properties such as `IsSuccessful` indicating if the update was successful, `Key` representing the key of the updated data, and `Request` representing the original request object. It also includes a `ThrowOnFailure` method.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\n    public interface IUpdateResponse : Akka.Actor.INoSerializationVerificationNeeded\n    {\n        bool IsSuccessful { get; }\n        Akka.DistributedData.IKey Key { get; }\n        object Request { get; }\n        void ThrowOnFailure();\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Defining Discoverable Services in HOCON Configuration\nDESCRIPTION: HOCON configuration structure for defining services and their endpoints when using the Configuration-based discovery method.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/discovery/index.md#2025-04-16_snippet_4\n\nLANGUAGE: hocon\nCODE:\n```\nakka.discovery.config.services = {\n  service1 = {\n    endpoints = [\n        \"cat:1233\",\n        \"dog:1234\"\n    ]\n  },\n  service2 = {\n    endpoints = []\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EmptyChildrenContainer Class in C#\nDESCRIPTION: Implementation of an empty container for child actors. Provides a singleton instance and no-op implementations of container operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_52\n\nLANGUAGE: C#\nCODE:\n```\npublic class EmptyChildrenContainer : Akka.Actor.Internal.IChildrenContainer\n{\n    protected EmptyChildrenContainer() { }\n    public System.Collections.Generic.IReadOnlyCollection<Akka.Actor.IInternalActorRef> Children { get; }\n    public static Akka.Actor.Internal.IChildrenContainer Instance { get; }\n    public virtual bool IsNormal { get; }\n    public virtual bool IsTerminating { get; }\n    public System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> Stats { get; }\n    public virtual Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats) { }\n    public bool Contains(Akka.Actor.IActorRef actor) { }\n    public Akka.Actor.Internal.IChildrenContainer Remove(Akka.Actor.IActorRef child) { }\n    public virtual Akka.Actor.Internal.IChildrenContainer Reserve(string name) { }\n    public Akka.Actor.Internal.IChildrenContainer ShallDie(Akka.Actor.IActorRef actor) { }\n    public override string ToString() { }\n    public bool TryGetByName(string name, out Akka.Actor.Internal.IChildStats stats) { }\n    public bool TryGetByRef(Akka.Actor.IActorRef actor, out Akka.Actor.Internal.ChildRestartStats childRestartStats) { }\n    public Akka.Actor.Internal.IChildrenContainer Unreserve(string name) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Cluster Event Models\nDESCRIPTION: Defines event types and interfaces for tracking cluster membership, leader changes, and member status transitions\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class MemberJoined : Akka.Cluster.ClusterEvent.MemberStatusChange\n{\n    public MemberJoined(Akka.Cluster.Member member) { }\n}\n\npublic sealed class LeaderChanged : Akka.Cluster.ClusterEvent.IClusterDomainEvent\n{\n    public Akka.Actor.Address Leader { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly Configuration for Akka.NET Project\nDESCRIPTION: Contains assembly metadata attributes that specify the repository URL and target framework for the Akka.NET project.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.Net.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Implementing TickTimeTokenBucket Class\nDESCRIPTION: A specialized TokenBucket implementation that uses system ticks for time measurement. It's used for rate limiting operations based on time intervals.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_218\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class TickTimeTokenBucket : Akka.Util.TokenBucket\n{\n    public TickTimeTokenBucket(long capacity, long period) { }\n    public override long CurrentTime { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ThreadPoolConfig Class in C#\nDESCRIPTION: Class that manages thread pool configuration settings for Akka.NET dispatchers. Provides methods for calculating thread pool sizes based on scaling factors and configured limits.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_101\n\nLANGUAGE: C#\nCODE:\n```\npublic class ThreadPoolConfig\n{\n    public ThreadPoolConfig(Akka.Configuration.Config config) { }\n    public double PoolSizeFactor { get; }\n    public int PoolSizeMax { get; }\n    public int PoolSizeMin { get; }\n    public static int ScaledPoolSize(int floor, double scalar, int ceiling) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Buffer Pool Interface in C#\nDESCRIPTION: Interface definition for buffer pool management with methods for renting and releasing byte array segments. Includes diagnostic information retrieval.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_152\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IBufferPool {\n    Akka.IO.Buffers.BufferPoolInfo Diagnostics();\n    void Release(System.ArraySegment<byte> buf);\n    void Release(System.Collections.Generic.IEnumerable<System.ArraySegment<byte>> buf);\n    System.ArraySegment<byte> Rent();\n    System.Collections.Generic.IEnumerable<System.ArraySegment<byte>> Rent(int minimumSize);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IJournalResponse Interface\nDESCRIPTION: This snippet defines the `IJournalResponse` interface, which represents a response message from the journal in Akka.Persistence. It inherits from `INoSerializationVerificationNeeded`, `IJournalMessage`, and `IPersistenceMessage`. Classes implementing this interface are used to communicate the result of journal operations back to the requesting actor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\n\"public interface IJournalResponse : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IJournalMessage, Akka.Persistence.IPersistenceMessage { }\"\n```\n\n----------------------------------------\n\nTITLE: Defining IPendingHandlerInvocation Interface\nDESCRIPTION: This snippet defines the `IPendingHandlerInvocation` interface, representing a pending handler invocation during event persistence in Akka.Persistence. It includes properties to access the event and its associated handler, allowing for asynchronous execution of handlers after an event has been successfully persisted.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\n\"public interface IPendingHandlerInvocation\n    {\n        object Event { get; }\n        System.Action<object> Handler { get; }\n    }\"\n```\n\n----------------------------------------\n\nTITLE: Poor Message Ordering Test in C#\nDESCRIPTION: Example of a flawed test that incorrectly assumes fixed message ordering across multiple actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/debugging.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[Test]\npublic void PoorOrderingAssumption()\n{\n    var probe = CreateTestProbe();\n    var actor1 = Sys.ActorOf(Props.Create(() => new SomeActor(probe)));\n    var actor2 = Sys.ActorOf(Props.Create(() => new SomeActor(probe)));\n\n    actor1.Tell(\"msg1\");\n    actor2.Tell(\"msg2\");\n\n    probe.ExpectMsg(\"msg1\");\n    probe.ExpectMsg(\"msg2\");\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ChildRestartStats Class in C#\nDESCRIPTION: Class tracking restart statistics for child actors, implementing IChildStats. Provides functionality to manage actor restart policies with configurable retry limits.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_50\n\nLANGUAGE: C#\nCODE:\n```\npublic class ChildRestartStats : Akka.Actor.Internal.IChildStats\n{\n    public ChildRestartStats(Akka.Actor.IInternalActorRef child, uint maxNrOfRetriesCount = 0, long restartTimeWindowStartTicks = 0) { }\n    public Akka.Actor.IInternalActorRef Child { get; }\n    public uint MaxNrOfRetriesCount { get; }\n    public long RestartTimeWindowStartTicks { get; }\n    public long Uid { get; }\n    public bool RequestRestartPermission(int maxNrOfRetries, int withinTimeMilliseconds) { }\n}\n```\n\n----------------------------------------\n\nTITLE: DistributedDataExtensions Static Class for Actor System Extension\nDESCRIPTION: Static extension class that adds a DistributedData() method to ActorSystem, providing a convenient way to access the distributed data functionality from an actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic class static DistributedDataExtensions\n{\n    public static Akka.DistributedData.DistributedData DistributedData(this Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AddressUid and AddressUidExtension Classes in C# for Akka.NET\nDESCRIPTION: Defines AddressUid class implementing IExtension and AddressUidExtension class for managing unique address identifiers in Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class AddressUid : Akka.Actor.IExtension\n{\n    public readonly int Uid;\n    public AddressUid() { }\n}\n\npublic class AddressUidExtension : Akka.Actor.ExtensionIdProvider<Akka.Remote.AddressUid>\n{\n    public AddressUidExtension() { }\n    public override Akka.Remote.AddressUid CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n    public static int Uid(Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing HoconValue Class in C#\nDESCRIPTION: The HoconValue class represents a value in HOCON configuration. It provides methods for accessing the value in different formats (boolean, integer, string, etc.) and supports conversion to various types needed for configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_71\n\nLANGUAGE: C#\nCODE:\n```\npublic class HoconValue : Akka.Configuration.Hocon.IMightBeAHoconObject\n{\n    public HoconValue() { }\n    public HoconValue(System.Collections.Generic.List<Akka.Configuration.Hocon.IHoconElement> values, bool adoptedFromFallback = True) { }\n    public bool IsEmpty { get; }\n    public System.Collections.Generic.List<Akka.Configuration.Hocon.IHoconElement> Values { get; }\n    public void AppendValue(Akka.Configuration.Hocon.IHoconElement value) { }\n    public Akka.Configuration.Config AtKey(string key) { }\n    public void Clear() { }\n    public System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray() { }\n    public bool GetBoolean() { }\n    public System.Collections.Generic.IList<bool> GetBooleanList() { }\n    public byte GetByte() { }\n    public System.Collections.Generic.IList<byte> GetByteList() { }\n    public System.Nullable<long> GetByteSize() { }\n    public Akka.Configuration.Hocon.HoconValue GetChildObject(string key) { }\n    public decimal GetDecimal() { }\n    public System.Collections.Generic.IList<decimal> GetDecimalList() { }\n    public double GetDouble() { }\n    public System.Collections.Generic.IList<double> GetDoubleList() { }\n    public float GetFloat() { }\n    public System.Collections.Generic.IList<float> GetFloatList() { }\n    public int GetInt() { }\n    public System.Collections.Generic.IList<int> GetIntList() { }\n    public long GetLong() { }\n    public System.Collections.Generic.IList<long> GetLongList() { }\n    public Akka.Configuration.Hocon.HoconObject GetObject() { }\n    public string GetString() { }\n    public System.Collections.Generic.IList<string> GetStringList() { }\n    public System.TimeSpan GetTimeSpan(bool allowInfinite = True) { }\n    public bool IsArray() { }\n    public bool IsObject() { }\n    public bool IsString() { }\n    public void NewValue(Akka.Configuration.Hocon.IHoconElement value) { }\n    public Akka.Configuration.Config ToConfig() { }\n    public override string ToString() { }\n    public virtual string ToString(int indent) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Message Class 'Greet' in C#\nDESCRIPTION: Creates a simple message class 'Greet' with a Name property. This class is used to send messages to actors in the Akka.NET system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/deployment/console.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Greet\n{\n    public Greet(string name)\n    {\n        Name = name;\n    }\n\n    public string Name { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Deploying an Actor Remotely with SpawnOption\nDESCRIPTION: Demonstrates how to deploy an actor remotely using the spawne function with SpawnOption.Deploy. This allows actors to be deployed to remote systems using a specified network address.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.FSharp/README.md#2025-04-16_snippet_4\n\nLANGUAGE: F#\nCODE:\n```\nopen Akka.Actor\nlet remoteRef =\n    spawne system \"my-actor\" <@ actorOf myFunc @>\n        [SpawnOption.Deploy (Deploy(RemoteScope(Address.Parse \"akka.tcp://remote-system@127.0.0.1:9000/\")))]\n```\n\n----------------------------------------\n\nTITLE: Defining ReplayedEvent Class in C#\nDESCRIPTION: Defines a sealed class ReplayedEvent that implements INoSerializationVerificationNeeded and IDeadLetterSuppression interfaces. It contains an Offset property and a Persistent property of type IPersistentRepresentation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_59\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ReplayedEvent : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression\n{\n    public readonly int Offset;\n    public readonly Akka.Persistence.IPersistentRepresentation Persistent;\n    public ReplayedEvent(Akka.Persistence.IPersistentRepresentation persistent, int offset) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Actor Termination System Message in Akka.NET\nDESCRIPTION: System message for actor termination that implements IPossiblyHarmful and IDeadLetterSuppression. Used to signal complete termination of an actor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_107\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class Terminate : Akka.Dispatch.SysMsg.SystemMessage, Akka.Actor.IPossiblyHarmful, Akka.Event.IDeadLetterSuppression\n{\n    public Terminate() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Supervise System Message for Actor Supervision\nDESCRIPTION: System message for supervising a child actor. Specifies whether supervision should be performed asynchronously and includes a reference to the child actor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_105\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class Supervise : Akka.Dispatch.SysMsg.SystemMessage\n{\n    public Supervise(Akka.Actor.IActorRef child, bool async) { }\n    public bool Async { get; }\n    public Akka.Actor.IActorRef Child { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Create System Message in Akka.NET\nDESCRIPTION: Defines a system message for actor creation. Can optionally carry an ActorInitializationException to indicate initialization failure.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_116\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Create : Akka.Dispatch.SysMsg.SystemMessage\n{\n    public Create(Akka.Actor.ActorInitializationException failure = null) { }\n    public Akka.Actor.ActorInitializationException Failure { get; }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating DeadLettersFilter for Akka.NET\nDESCRIPTION: This sealed class specializes in filtering dead letters in Akka.NET, based on specific message and source matchers. It overrides methods to determine descriptive names and matching log events. Necessary dependencies include Akka.TestKit.Internal.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DeadLettersFilter : Akka.TestKit.Internal.EventFilterBase\n{\n    public DeadLettersFilter(Akka.TestKit.Internal.StringMatcher.IStringMatcher messageMatcher, Akka.TestKit.Internal.StringMatcher.IStringMatcher sourceMatcher, System.Predicate<Akka.Event.DeadLetter> isMatch = null) { }\n    protected override string FilterDescriptiveName { get; }\n    protected override bool IsMatch(Akka.Event.LogEvent evt) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Factorial Frontend Actor in C#\nDESCRIPTION: Defines a frontend actor that receives user jobs and delegates to backend actors via a router.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-metrics.md#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[!code-csharp[RoutersUsageSample](../../../src/core/Akka.Docs.Tests/Cluster.Metrics/RoutersUsageSample.cs?name=FactorialFrontend)]\n```\n\n----------------------------------------\n\nTITLE: Implementing UdpConnected SuspendReading Command in Akka.NET\nDESCRIPTION: Command to temporarily suspend reading from a UDP connection. Uses a singleton instance pattern for memory efficiency.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_185\n\nLANGUAGE: C#\nCODE:\n```\npublic class SuspendReading : Akka.IO.UdpConnected.Command\n{\n    public static readonly Akka.IO.UdpConnected.SuspendReading Instance;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PersistenceQuery class in C# for Akka.NET\nDESCRIPTION: Defines the PersistenceQuery class which serves as an extension for the Akka.NET actor system, providing methods to access read journals and default configurations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceQuery.Core.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class PersistenceQuery : Akka.Actor.IExtension\n{\n    public PersistenceQuery(Akka.Actor.ExtendedActorSystem system) { }\n    public Akka.Event.ILoggingAdapter Log { get; }\n    public static Akka.Persistence.Query.PersistenceQuery Get(Akka.Actor.ActorSystem system) { }\n    public static Akka.Configuration.Config GetDefaultConfig<TJournal>() { }\n    public TJournal ReadJournalFor<TJournal>(string readJournalPluginId)\n        where TJournal : Akka.Persistence.Query.IReadJournal { }\n}\n\npublic class static PersistenceQueryExtensions\n{\n    public static TJournal ReadJournalFor<TJournal>(this Akka.Actor.ActorSystem system, string readJournalPluginId)\n        where TJournal : Akka.Persistence.Query.IReadJournal { }\n}\n\npublic class PersistenceQueryProvider : Akka.Actor.ExtensionIdProvider<Akka.Persistence.Query.PersistenceQuery>\n{\n    public PersistenceQueryProvider() { }\n    public override Akka.Persistence.Query.PersistenceQuery CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing GCounter in Distributed Data\nDESCRIPTION: Represents a grow-only counter in distributed systems with support for merging and incrementing across cluster nodes\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\npublic GCounter() { }\n```\n\n----------------------------------------\n\nTITLE: Defining SubscriptionInitialStateMode Enum in C#\nDESCRIPTION: Enumerates the possible modes for receiving initial state when subscribing to cluster events. Controls whether subscribers receive state as a snapshot or as individual events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.DotNet.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic enum SubscriptionInitialStateMode\n{\n    InitialStateAsSnapshot = 0,\n    InitialStateAsEvents = 1,\n}\n```\n\n----------------------------------------\n\nTITLE: Remote Settings Configuration in C#\nDESCRIPTION: Defines configuration settings for remote actor communication including timeouts, buffer sizes, and transport settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class RemoteSettings\n{\n    public static readonly string AkkaScheme;\n    public RemoteSettings(Akka.Configuration.Config config) { }\n    public System.TimeSpan BackoffPeriod { get; set; }\n    public System.TimeSpan CommandAckTimeout { get; set; }\n    // ... additional properties\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Setup Abstract Class in C#\nDESCRIPTION: An abstract base class for actor system setup configurations. Provides a foundation for creating specialized setup classes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_67\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Setup\n{\n    protected Setup() { }\n    public Akka.Actor.Setup.ActorSystemSetup And(Akka.Actor.Setup.Setup other) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting Snapshot Asynchronously with Akka.Persistence and C#\nDESCRIPTION: This method handles the asynchronous deletion of a snapshot identified by the provided metadata. The operation is designed to be stable, protected by a circuit breaker to handle potential failures gracefully while interacting with the persistence layer.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/custom-persistence-provider.md#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nTask DeleteAsync(SnapshotMetadata metadata);\n\n```\n\n----------------------------------------\n\nTITLE: Implementing UnboundedStashImpl Class in C#\nDESCRIPTION: Implementation of an unbounded stash for actor messages, inheriting from AbstractStash. Provides a constructor that accepts an actor context.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_63\n\nLANGUAGE: C#\nCODE:\n```\npublic class UnboundedStashImpl : Akka.Actor.Internal.AbstractStash\n{\n    public UnboundedStashImpl(Akka.Actor.IActorContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Multi-Node Test Specification in C#\nDESCRIPTION: Implementation of a MultiNodeConfig class that defines test configuration for a two-node cluster test scenario. Sets up seed nodes and common configuration for the test environment.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/testing/multi-node-testing-old.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class RestartNode2SpecConfig : MultiNodeConfig\n{\n    public RoleName Seed1 { get; }\n    public RoleName Seed2 { get; }\n\n    public RestartNode2SpecConfig()\n    {\n        Seed1 = Role(\"seed1\");\n        Seed2 = Role(\"seed2\");\n\n        CommonConfig = ConfigurationFactory.ParseString(@\"\"\"\n            akka.actor.provider = cluster\n            akka.cluster.auto-down-unreachable-after = 0s\n            akka.cluster.retry-unsuccessful-join-after = 3s\n            akka.remote.log-remote-lifecycle-events = INFO\n            \"\"\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PredicateMatcher Class in Akka.NET TestKit\nDESCRIPTION: A string matcher that uses a custom predicate function to determine matches. This flexible implementation of IStringMatcher allows for custom matching logic through a provided delegate.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_47\n\nLANGUAGE: C#\nCODE:\n```\npublic class PredicateMatcher : Akka.TestKit.Internal.StringMatcher.IStringMatcher\n{\n    public PredicateMatcher(System.Predicate<string> predicate, string hint = \"\") { }\n    public bool IsMatch(string s) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterMetricsMessageSerializer for Akka.NET\nDESCRIPTION: This class, `ClusterMetricsMessageSerializer`, is responsible for serializing and deserializing cluster metrics messages within the Akka.NET framework. It inherits from `Akka.Serialization.SerializerWithStringManifest` and implements the necessary methods for converting objects to and from binary representations using a manifest.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ClusterMetricsMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n    {\n        public ClusterMetricsMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n        public override object FromBinary(byte[] bytes, string manifest) { }\n        public override string Manifest(object o) { }\n        public override byte[] ToBinary(object obj) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Exception Handling in Akka.NET Scheduler\nDESCRIPTION: Exception classes for handling scheduler-related errors in Akka.NET. Includes SchedulerException with different constructor overloads for serialization support.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_51\n\nLANGUAGE: C#\nCODE:\n```\npublic SchedulerException(string message) { }\npublic SchedulerException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Transport Activity Classes in Akka.NET\nDESCRIPTION: Activity classes that represent transport operations. ListenAttempt represents an attempt to bind to an address, while ShutdownAttempt represents an attempt to shut down a bound address.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ListenAttempt : Akka.Remote.Transport.Activity\n{\n    public ListenAttempt(Akka.Actor.Address boundAddress) { }\n    public Akka.Actor.Address BoundAddress { get; }\n}\n\npublic sealed class ShutdownAttempt : Akka.Remote.Transport.Activity\n{\n    public ShutdownAttempt(Akka.Actor.Address boundAddress) { }\n    public Akka.Actor.Address BoundAddress { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Event Replay Status and Command Classes in C#\nDESCRIPTION: Defines classes for tracking event replay status and operations, including success and failure notifications, replay filter settings, and tagged message replay.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class EventReplaySuccess\n{\n    public EventReplaySuccess(long highestSequenceNr) { }\n    public long HighestSequenceNr { get; }\n    public bool Equals(Akka.Persistence.Sql.Common.Journal.EventReplaySuccess other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n\npublic sealed class EventReplayFailure\n{\n    public EventReplayFailure(System.Exception cause) { }\n    public System.Exception Cause { get; }\n    public bool Equals(Akka.Persistence.Sql.Common.Journal.EventReplayFailure other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n\npublic sealed class ReplayFilterSettings\n{\n    public readonly bool IsDebug;\n    public readonly int MaxOldWriters;\n    public readonly Akka.Persistence.Journal.ReplayFilterMode Mode;\n    public readonly int WindowSize;\n    public ReplayFilterSettings(Akka.Configuration.Config config) { }\n    public ReplayFilterSettings(Akka.Persistence.Journal.ReplayFilterMode mode, int windowSize, int maxOldWriters, bool isDebug) { }\n    public bool IsEnabled { get; }\n}\n\npublic sealed class ReplayTaggedMessages : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IJournalMessage, Akka.Persistence.IJournalRequest, Akka.Persistence.IPersistenceMessage\n{\n    public readonly long FromOffset;\n    public readonly long Max;\n    public readonly Akka.Actor.IActorRef ReplyTo;\n    public readonly string Tag;\n    public readonly long ToOffset;\n    public ReplayTaggedMessages(long fromOffset, long toOffset, long max, string tag, Akka.Actor.IActorRef replyTo) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Test Actor Interface Methods\nDESCRIPTION: Interface declarations for ExpectOneAsync and Mute methods used in Akka.NET test actors. Includes overloads for handling synchronous and asynchronous operations with optional timeout and cancellation token support.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nSystem.Threading.Tasks.Task ExpectOneAsync(System.Func<System.Threading.Tasks.Task> actionAsync, System.Threading.CancellationToken cancellationToken = null);\nSystem.Threading.Tasks.Task ExpectOneAsync(System.TimeSpan timeout, System.Func<System.Threading.Tasks.Task> action, System.Threading.CancellationToken cancellationToken = null);\n```\n\n----------------------------------------\n\nTITLE: ClusterReceptionistSettings Class Definition in C#\nDESCRIPTION: Configuration settings for the ClusterReceptionist, including role specification, contact management, tunnel timeouts, and heartbeat configuration. Provides factory methods and fluent builder methods for configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterReceptionistSettings : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public ClusterReceptionistSettings(string role, int numberOfContacts, System.TimeSpan responseTunnelReceiveTimeout, System.TimeSpan heartbeatInterval, System.TimeSpan acceptableHeartbeatPause, System.TimeSpan failureDetectionInterval) { }\n    public System.TimeSpan AcceptableHeartbeatPause { get; }\n    public System.TimeSpan FailureDetectionInterval { get; }\n    public System.TimeSpan HeartbeatInterval { get; }\n    public int NumberOfContacts { get; }\n    public System.TimeSpan ResponseTunnelReceiveTimeout { get; }\n    public string Role { get; }\n    public static Akka.Cluster.Tools.Client.ClusterReceptionistSettings Create(Akka.Actor.ActorSystem system) { }\n    public static Akka.Cluster.Tools.Client.ClusterReceptionistSettings Create(Akka.Configuration.Config config) { }\n    public Akka.Cluster.Tools.Client.ClusterReceptionistSettings WithHeartbeat(System.TimeSpan heartbeatInterval, System.TimeSpan acceptableHeartbeatPause, System.TimeSpan failureDetectionInterval) { }\n    public Akka.Cluster.Tools.Client.ClusterReceptionistSettings WithNumberOfContacts(int numberOfContacts) { }\n    public Akka.Cluster.Tools.Client.ClusterReceptionistSettings WithResponseTunnelReceiveTimeout(System.TimeSpan responseTunnelReceiveTimeout) { }\n    public Akka.Cluster.Tools.Client.ClusterReceptionistSettings WithRole(string role) { }\n    public Akka.Cluster.Tools.Client.ClusterReceptionistSettings WithoutRole() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IReplicatedDelta Interface in C#\nDESCRIPTION: This snippet defines the `IReplicatedDelta` interface, representing a delta (change) to replicated data. It inherits from `IReplicatedData` and includes a `Zero` property that provides a way to obtain an empty or zeroed instance of the corresponding delta type.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\n    public interface IReplicatedDelta : Akka.DistributedData.IReplicatedData\n    {\n        Akka.DistributedData.IDeltaReplicatedData Zero { get; }\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Defining StateStoreMode Enum in Akka.NET Sharding\nDESCRIPTION: This enum defines the possible modes for storing the state of entities in a shard. It defines modes for using persistence, DData (Distributed Data), or a custom implementation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_25\n\nLANGUAGE: csharp\nCODE:\n```\n    public enum StateStoreMode\n    {\n        Persistence = 0,\n        DData = 1,\n        Custom = 2,\n    }\n```\n\n----------------------------------------\n\nTITLE: Correct Implementation of Ask Pattern with Non-Zero Timeout\nDESCRIPTION: This example shows the proper way to implement the Ask pattern using a non-zero timeout value, which prevents potential deadlocks.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK2000.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Actor;\nusing System.Threading.Tasks;\nusing System;\n\npublic static class MyActorCaller{\n    public static Task<string> Call(IActorRef actor){\n        return actor.Ask<string>(\"hello\", TimeSpan.FromSeconds(1));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Adaptive Load Balancing Routing Logic in Akka.Cluster\nDESCRIPTION: This snippet provides the AdaptiveLoadBalancingRoutingLogic class, which realizes the adaptive load balancing strategy by implementing Akka.Routing.RoutingLogic and IClusterMetricsRoutingLogic. It updates metrics and selects routees based on incoming messages, with dependencies on Akka.Routing and Akka.Cluster.Metrics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.DotNet.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class AdaptiveLoadBalancingRoutingLogic : Akka.Routing.RoutingLogic, Akka.Cluster.Metrics.IClusterMetricsRoutingLogic\n{\n    public AdaptiveLoadBalancingRoutingLogic(Akka.Actor.ActorSystem system, Akka.Cluster.Metrics.IMetricsSelector metricsSelector = null) { }\n    public void MetricsChanged(Akka.Cluster.Metrics.Events.ClusterMetricsChanged @event) { }\n    public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ThrottleTransportAdapter Class in Akka.NET\nDESCRIPTION: Adapter class that adds throttling capabilities to any Akka.NET transport implementation. It defines constants, properties, and methods to manage throttling behavior.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\npublic class ThrottleTransportAdapter : Akka.Remote.Transport.ActorTransportAdapter\n{\n    public const string Scheme = \"trttl\";\n    public static readonly Akka.Util.Internal.AtomicCounter UniqueId;\n    public ThrottleTransportAdapter(Akka.Remote.Transport.Transport wrappedTransport, Akka.Actor.ActorSystem system) { }\n    protected override string ManagerName { get; }\n    protected override Akka.Actor.Props ManagerProps { get; }\n    protected override Akka.Remote.Transport.SchemeAugmenter SchemeAugmenter { get; }\n    public override System.Threading.Tasks.Task<bool> ManagementCommand(object message) { }\n    public enum Direction\n    {\n        Send = 0,\n        Receive = 1,\n        Both = 2,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MixMetricsSelectorBase for Cluster Metrics Selection\nDESCRIPTION: Defines a base class for mixed metrics selectors that combines multiple capacity metrics selectors. This class provides functionality for calculating node capacity based on multiple metrics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nprotected MixMetricsSelectorBase(System.Collections.Immutable.ImmutableArray<Akka.Cluster.Metrics.CapacityMetricsSelector> selectors) { }\npublic System.Collections.Immutable.ImmutableArray<Akka.Cluster.Metrics.CapacityMetricsSelector> Selectors { get; }\npublic override System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, double> Capacity(System.Collections.Immutable.IImmutableSet<Akka.Cluster.Metrics.Serialization.NodeMetrics> nodeMetrics) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Write Consistency Models in C#\nDESCRIPTION: Defines various write consistency models including WriteAll, WriteLocal, WriteMajority, WriteMajorityPlus and WriteTo. Each class implements IWriteConsistency and includes timeout and capacity parameters.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_46\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class WriteAll : Akka.DistributedData.IWriteConsistency, System.IEquatable<Akka.DistributedData.WriteAll>\n{\n    public WriteAll(System.TimeSpan timeout) { }\n    public System.TimeSpan Timeout { get; }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.DistributedData.WriteAll other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Unthrottled Transport Class Definition in C#\nDESCRIPTION: Implementation of ThrottleMode for unthrottled transport operations, providing methods for token consumption and time availability calculations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\npublic class Unthrottled : Akka.Remote.Transport.ThrottleMode\n{\n    public static Akka.Remote.Transport.Unthrottled Instance { get; }\n    public override System.TimeSpan TimeToAvailable(long currentNanoTime, int tokens) { }\n    public override System.ValueTuple<Akka.Remote.Transport.ThrottleMode, bool> TryConsumeTokens(long nanoTimeOfSend, int tokens) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing InterlockedSpin Static Class\nDESCRIPTION: Utility class providing low-level thread synchronization primitives for reference types. It offers methods for atomic operations on objects with optimistic concurrency control using the compare-and-swap pattern.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_230\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.Util.Internal\n{\n    public class static InterlockedSpin\n    {\n        public static TReturn ConditionallySwap<T, TReturn>(ref T reference, System.Func<T, System.ValueTuple<bool, T, TReturn>> updateIfTrue)\n            where T :  class { }\n        public static T Swap<T>(ref T reference, System.Func<T, T> updater)\n            where T :  class { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Buffer Pool Implementation\nDESCRIPTION: Defines buffer pool related classes including exceptions, info storage and interface for buffer pool operations. Handles memory management for byte arrays.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_146\n\nLANGUAGE: C#\nCODE:\n```\npublic class BufferPoolAllocationException : Akka.Actor.AkkaException\n{\n    public BufferPoolAllocationException(string message) { }\n    protected BufferPoolAllocationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\npublic class BufferPoolInfo\n{\n    public BufferPoolInfo(System.Type type, long totalSize, long free, long used) { }\n    public long Free { get; }\n    public long TotalSize { get; }\n    public System.Type Type { get; }\n    public long Used { get; }\n}\npublic interface IBufferPool\n{\n    Akka.IO.Buffers.BufferPoolInfo Diagnostics();\n    void Release(System.ArraySegment<byte> buf);\n    void Release(System.Collections.Generic.IEnumerable<System.ArraySegment<byte>> buf);\n    System.ArraySegment<byte> Rent();\n    System.Collections.Generic.IEnumerable<System.ArraySegment<byte>> Rent(int minimumSize);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Assembly Metadata and Visibility for Akka.NET\nDESCRIPTION: Defines assembly metadata including repository URL, internal visibility to other Akka.NET components, COM visibility settings, and target framework information. These attributes control which assemblies can access internal members of the core Akka.NET library.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.API.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Benchmarks\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding.Tests.MultiNode\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.TestKit\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Tests.MultiNode\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Tools\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.DependencyInjection\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.DependencyInjection.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.DistributedData\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Docs.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.MultiNodeTestRunner.Shared.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Persistence\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Persistence.Sql.TestKit\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Persistence.TCK\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Persistence.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Remote\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Remote.TestKit\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Remote.TestKit.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Remote.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Remote.Tests.MultiNode\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Streams\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Streams.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.TestKit\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.TestKit.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Tests.Performance\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"1a5cab08-b032-49ca-8db3-9428c5a9db14\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETCoreApp,Version=v6.0\", FrameworkDisplayName=\".NET 6.0\")]\n```\n\n----------------------------------------\n\nTITLE: Implementing SqlReadJournalProvider in Akka.NET C#\nDESCRIPTION: The SqlReadJournalProvider class serves as a factory for creating instances of the SqlReadJournal. It implements the IReadJournalProvider interface and requires an Akka actor system and a configuration to function. It's used to obtain read journal instances to perform SQL-based event queries within the Akka.NET framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommonQuery.DotNet.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class SqlReadJournalProvider : Akka.Persistence.Query.IReadJournalProvider\n{\n    public SqlReadJournalProvider(Akka.Actor.ExtendedActorSystem system, Akka.Configuration.Config config) { }\n    public Akka.Persistence.Query.IReadJournal GetReadJournal() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ConfigurationException Class in C#\nDESCRIPTION: This snippet shows the ConfigurationException class, which extends AkkaException and provides constructors and a static method for creating exceptions related to null or empty configurations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_72\n\nLANGUAGE: C#\nCODE:\n```\npublic class ConfigurationException : Akka.Actor.AkkaException\n{\n    public ConfigurationException(string message) { }\n    public ConfigurationException(string message, System.Exception exception) { }\n    protected ConfigurationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n    public static Akka.Configuration.ConfigurationException NullOrEmptyConfig<T>(string path = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Read Journal Interfaces in C# for Akka.NET Persistence Query\nDESCRIPTION: Declares various interfaces for read journal functionality, including querying all events, current events, events by persistence ID, and events by tag.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceQuery.Core.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IAllEventsQuery : Akka.Persistence.Query.IReadJournal\n{\n    Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> AllEvents(Akka.Persistence.Query.Offset offset);\n}\n\npublic interface ICurrentAllEventsQuery : Akka.Persistence.Query.IReadJournal\n{\n    Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentAllEvents(Akka.Persistence.Query.Offset offset);\n}\n\npublic interface ICurrentEventsByPersistenceIdQuery : Akka.Persistence.Query.IReadJournal\n{\n    Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentEventsByPersistenceId(string persistenceId, long fromSequenceNr, long toSequenceNr);\n}\n\npublic interface ICurrentEventsByTagQuery : Akka.Persistence.Query.IReadJournal\n{\n    Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentEventsByTag(string tag, Akka.Persistence.Query.Offset offset);\n}\n```\n\n----------------------------------------\n\nTITLE: Gracefully Shutting Down Nodes with ActorSystem.Shutdown in C#\nDESCRIPTION: This code demonstrates how to gracefully terminate a node in a multi-node test by calling the Shutdown method on the ActorSystem. This simulates a planned shutdown of a node within the test environment.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/testing/multi-node-testing-old.md#2025-04-16_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\n// shutdown seed1System\nRunOn(() =>\n{\n    Shutdown(seed1System.Value, RemainingOrDefault);\n}, _config.Seed1);\nEnterBarrier(\"seed1-shutdown\");\n```\n\n----------------------------------------\n\nTITLE: Implementing ActorProducerPipeline in C#\nDESCRIPTION: Defines the ActorProducerPipeline class, which manages a collection of IActorProducerPlugin instances for customizing actor creation and lifecycle.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class ActorProducerPipeline : System.Collections.Generic.IEnumerable<Akka.Actor.IActorProducerPlugin>, System.Collections.IEnumerable\n{\n    public ActorProducerPipeline(System.Lazy<Akka.Event.ILoggingAdapter> log, System.Collections.Generic.IEnumerable<Akka.Actor.IActorProducerPlugin> plugins) { }\n    public int Count { get; }\n    public void AfterActorIncarnated(Akka.Actor.ActorBase actor, Akka.Actor.IActorContext context) { }\n    public void BeforeActorIncarnated(Akka.Actor.ActorBase actor, Akka.Actor.IActorContext context) { }\n    public System.Collections.Generic.IEnumerator<Akka.Actor.IActorProducerPlugin> GetEnumerator() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Cluster Member Classes in C#\nDESCRIPTION: Defines core member-related classes including MemberWeaklyUp, ReachabilityEvent, and Member status implementations. These classes handle cluster membership state and reachability events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class Member : System.IComparable, System.IComparable<Akka.Cluster.Member>\n{\n    public static readonly System.Collections.Generic.IComparer<Akka.Actor.Address> AddressOrdering;\n    public static readonly System.Collections.Generic.IComparer<Akka.Cluster.Member> AgeOrdering;\n    public Akka.Actor.Address Address { get; }\n    public Akka.Util.AppVersion AppVersion { get; }\n    public System.Collections.Immutable.ImmutableHashSet<string> Roles { get; }\n    public Akka.Cluster.MemberStatus Status { get; }\n    public Akka.Cluster.UniqueAddress UniqueAddress { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IMessageQueue Interface for Akka.NET Message Processing in C#\nDESCRIPTION: Interface that defines the core functionality required for all message queues in Akka.NET. It specifies methods for enqueuing and dequeuing messages, checking queue status, and cleaning up resources.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_106\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IMessageQueue\n{\n    int Count { get; }\n    bool HasMessages { get; }\n    void CleanUp(Akka.Actor.IActorRef owner, Akka.Dispatch.MessageQueues.IMessageQueue deadletters);\n    void Enqueue(Akka.Actor.IActorRef receiver, Akka.Actor.Envelope envelope);\n    bool TryDequeue(out Akka.Actor.Envelope envelope);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Actor Deployment Configuration in C#\nDESCRIPTION: Configuration class for actor deployment settings including router configuration, dispatcher selection, and mailbox specifications.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic class Deploy : Akka.Util.ISurrogated, System.IEquatable<Akka.Actor.Deploy>\n{\n    public static readonly Akka.Actor.Deploy Local;\n    public static readonly string NoDispatcherGiven;\n    public static readonly string NoMailboxGiven;\n    public static readonly Akka.Actor.Scope NoScopeGiven;\n    public const int NoStashSize = -1;\n    public Deploy(string path, Akka.Configuration.Config config, Akka.Routing.RouterConfig routerConfig, Akka.Actor.Scope scope, string dispatcher, string mailbox, int stashCapacity) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Filters for Akka.NET Logging\nDESCRIPTION: These classes define various event filters for Akka.NET logging, including CustomEventFilter, DebugFilter, ErrorFilter, and InfoFilter. They allow filtering and matching of log events based on different criteria.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic class CustomEventFilter : Akka.TestKit.Internal.EventFilterBase\n{\n    public CustomEventFilter(System.Predicate<Akka.Event.LogEvent> predicate) { }\n    protected override string FilterDescriptiveName { get; }\n    protected override bool IsMatch(Akka.Event.LogEvent evt) { }\n}\n\npublic class DebugFilter : Akka.TestKit.Internal.EventFilterBase\n{\n    public DebugFilter(Akka.TestKit.Internal.StringMatcher.IStringMatcher messageMatcher = null, Akka.TestKit.Internal.StringMatcher.IStringMatcher sourceMatcher = null) { }\n    protected override string FilterDescriptiveName { get; }\n    protected override bool IsMatch(Akka.Event.LogEvent evt) { }\n}\n\npublic class ErrorFilter : Akka.TestKit.Internal.EventFilterBase\n{\n    public ErrorFilter(Akka.TestKit.Internal.StringMatcher.IStringMatcher messageMatcher = null, Akka.TestKit.Internal.StringMatcher.IStringMatcher sourceMatcher = null) { }\n    public ErrorFilter(System.Type exceptionType, Akka.TestKit.Internal.StringMatcher.IStringMatcher messageMatcher = null, Akka.TestKit.Internal.StringMatcher.IStringMatcher sourceMatcher = null, bool recurseInnerExceptions = False) { }\n    protected override string FilterDescriptiveName { get; }\n    protected override bool IsMatch(Akka.Event.LogEvent evt) { }\n}\n\npublic class InfoFilter : Akka.TestKit.Internal.EventFilterBase\n{\n    public InfoFilter(Akka.TestKit.Internal.StringMatcher.IStringMatcher messageMatcher = null, Akka.TestKit.Internal.StringMatcher.IStringMatcher sourceMatcher = null) { }\n    protected override string FilterDescriptiveName { get; }\n    protected override bool IsMatch(Akka.Event.LogEvent evt) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Deque Wrapper Message Queue in Akka.NET\nDESCRIPTION: Provides a wrapper implementation for deque-based message queues that delegates operations to an underlying message queue. Supports double-ended queue operations and standard queue semantics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_109\n\nLANGUAGE: C#\nCODE:\n```\npublic class DequeWrapperMessageQueue : Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.MessageQueues.IMessageQueue\n{\n    protected readonly Akka.Dispatch.MessageQueues.IMessageQueue MessageQueue;\n    public DequeWrapperMessageQueue(Akka.Dispatch.MessageQueues.IMessageQueue messageQueue) { }\n    public int Count { get; }\n    public bool HasMessages { get; }\n    public void CleanUp(Akka.Actor.IActorRef owner, Akka.Dispatch.MessageQueues.IMessageQueue deadletters) { }\n    public void Enqueue(Akka.Actor.IActorRef receiver, Akka.Actor.Envelope envelope) { }\n    public void EnqueueFirst(Akka.Actor.Envelope envelope) { }\n    public bool TryDequeue(out Akka.Actor.Envelope envelope) { }\n}\n```\n\n----------------------------------------\n\nTITLE: TimeoutSettings Class Definition in C#\nDESCRIPTION: Defines timeout-related settings for lease operations including heartbeat interval, heartbeat timeout, and operation timeout. Provides factory methods and immutable modification capabilities.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.DotNet.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class TimeoutSettings\n{\n    public TimeoutSettings(System.TimeSpan heartbeatInterval, System.TimeSpan heartbeatTimeout, System.TimeSpan operationTimeout) { }\n    public System.TimeSpan HeartbeatInterval { get; }\n    public System.TimeSpan HeartbeatTimeout { get; }\n    public System.TimeSpan OperationTimeout { get; }\n    public static Akka.Coordination.TimeoutSettings Create(Akka.Configuration.Config config) { }\n    public override string ToString() { }\n    public Akka.Coordination.TimeoutSettings WithHeartbeatInterval(System.TimeSpan heartbeatInterval) { }\n    public Akka.Coordination.TimeoutSettings WithHeartbeatTimeout(System.TimeSpan heartbeatTimeout) { }\n    public Akka.Coordination.TimeoutSettings withOperationTimeout(System.TimeSpan operationTimeout) { }\n}\n```\n\n----------------------------------------\n\nTITLE: UnderlyingTransportError Class Definition (C#)\nDESCRIPTION: Class representing an error in the underlying transport, implementing IHandleEvent and INoSerializationVerificationNeeded interfaces.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class UnderlyingTransportError : Akka.Actor.INoSerializationVerificationNeeded, Akka.Remote.Transport.IHandleEvent\n{\n    public UnderlyingTransportError(System.Exception cause, string message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SeveralRoutees Class in Akka.NET\nDESCRIPTION: Special Routee implementation that represents multiple routees as a single routing destination. Used by broadcast-style routing strategies to send messages to multiple actors simultaneously.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_216\n\nLANGUAGE: C#\nCODE:\n```\npublic class SeveralRoutees : Akka.Routing.Routee\n{\n    public SeveralRoutees(Akka.Routing.Routee[] routees) { }\n    public override void Send(object message, Akka.Actor.IActorRef sender) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ChannelTaskScheduler in C#\nDESCRIPTION: Defines a ChannelTaskScheduler class that implements IExtension and IDisposable interfaces. It provides task schedulers with different priority levels and methods for managing them within an actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_96\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ChannelTaskScheduler : Akka.Actor.IExtension, System.IDisposable\n{\n    public ChannelTaskScheduler(Akka.Actor.ExtendedActorSystem system) { }\n    public System.Threading.Tasks.TaskScheduler High { get; }\n    public System.Threading.Tasks.TaskScheduler Idle { get; }\n    public System.Threading.Tasks.TaskScheduler Low { get; }\n    public System.Threading.Tasks.TaskScheduler Normal { get; }\n    public void Dispose() { }\n    public static Akka.Dispatch.ChannelTaskScheduler Get(Akka.Actor.ActorSystem system) { }\n    public System.Threading.Tasks.TaskScheduler GetScheduler(Akka.Dispatch.TaskSchedulerPriority priority) { }\n}\n```\n\n----------------------------------------\n\nTITLE: TCP Extensions and Settings Implementation\nDESCRIPTION: Implementation of TCP extension classes and settings configuration for Akka.NET. Includes TcpExt, TcpExtensions, and TcpSettings classes for managing TCP connections and configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_159\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class TcpExt : Akka.IO.IOExtension\n{\n    public TcpExt(Akka.Actor.ExtendedActorSystem system) { }\n    public Akka.IO.Buffers.IBufferPool BufferPool { get; }\n    public override Akka.Actor.IActorRef Manager { get; }\n    public Akka.IO.TcpSettings Settings { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Association and Payload Event Classes in Akka.NET\nDESCRIPTION: Classes for inbound association and payload events. InboundAssociation represents a new incoming connection, while InboundPayload represents data received over an association handle.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class InboundAssociation : Akka.Actor.INoSerializationVerificationNeeded, Akka.Remote.Transport.IAssociationEvent\n{\n    public InboundAssociation(Akka.Remote.Transport.AssociationHandle association) { }\n    public Akka.Remote.Transport.AssociationHandle Association { get; }\n}\n\npublic sealed class InboundPayload : Akka.Actor.INoSerializationVerificationNeeded, Akka.Remote.Transport.IHandleEvent\n{\n    public InboundPayload(Google.Protobuf.ByteString payload) { }\n    public Google.Protobuf.ByteString Payload { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Actor Producer Pipeline Management\nDESCRIPTION: Implements classes for managing actor producer plugins and pipelines, allowing extensible actor creation and lifecycle management\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ActorProducerPipeline : System.Collections.Generic.IEnumerable<Akka.Actor.IActorProducerPlugin>, System.Collections.IEnumerable { }\n```\n\n----------------------------------------\n\nTITLE: Testing Stopped Device Late Response - C#\nDESCRIPTION: This snippet tests how the query actor retains the first reply from a device even when a 'Terminated' message is received for that actor afterward. It ensures the actor maintains state correctly.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-4.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[DeviceGroupQuerySpec.cs](../../../../src/core/Akka.Docs.Tutorials/Tutorial4/DeviceGroupQuerySpec.cs?name=query-test-stopped-later)]\n```\n\n----------------------------------------\n\nTITLE: Default Akka.Cluster.Sharding Configuration in HOCON\nDESCRIPTION: Default backwards-compatible HOCON configuration for Akka.Cluster.Sharding showing persistence mode settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/RELEASE_NOTES.md#2025-04-16_snippet_8\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster.sharding{\n  state-store-mode = persistence\n  # remember-entities-store (not set - also uses legacy Akka.Persistence)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Equality Comparer Interface\nDESCRIPTION: Implements a generic `IEqualityComparer` for Akka.NET tests that optionally skips type checking and allows for using a custom `innerComparer`.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKitXunit2.DotNet.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.TestKit.Xunit2.Internals\n{\n    public class AkkaAssertEqualityComparer<T> : System.Collections.Generic.IEqualityComparer<T>\n    {\n        public AkkaAssertEqualityComparer(bool skipTypeCheck = False, System.Collections.IEqualityComparer innerComparer = null) { }\n        public bool Equals(T x, T y) { }\n        public int GetHashCode(T obj) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TestTransport Class in Akka.NET Remote Transport\nDESCRIPTION: A testable implementation of the Transport base class used for unit testing network behavior in Akka.NET's remoting system with configurable behaviors for associations and messaging.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestTransport : Akka.Remote.Transport.Transport\n{\n    public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<Akka.Actor.Address, Akka.Remote.Transport.AssociationHandle> AssociateBehavior;\n    public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<Akka.Remote.Transport.TestAssociationHandle, bool> DisassociateBehavior;\n    public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<bool, System.ValueTuple<Akka.Actor.Address, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.IAssociationEventListener>>> ListenBehavior;\n    public readonly Akka.Actor.Address LocalAddress;\n    public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<bool, bool> ShutdownBehavior;\n    public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<System.ValueTuple<Akka.Remote.Transport.TestAssociationHandle, Google.Protobuf.ByteString>, bool> WriteBehavior;\n    public TestTransport(Akka.Actor.ActorSystem system, Akka.Configuration.Config conf) { }\n    public TestTransport(Akka.Actor.Address localAddress, Akka.Remote.Transport.AssociationRegistry registry, long maximumPayloadBytes = 32000, string schemeIdentifier = \"test\") { }\n    public override System.Threading.Tasks.Task<Akka.Remote.Transport.AssociationHandle> Associate(Akka.Actor.Address remoteAddress) { }\n    public System.Threading.Tasks.Task<bool> DefaultDisassociate(Akka.Remote.Transport.TestAssociationHandle handle) { }\n    public System.Threading.Tasks.Task<System.ValueTuple<Akka.Actor.Address, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.IAssociationEventListener>>> DefaultListen() { }\n    public System.Threading.Tasks.Task Disassociate(Akka.Remote.Transport.TestAssociationHandle handle) { }\n    public override bool IsResponsibleFor(Akka.Actor.Address remote) { }\n    public override System.Threading.Tasks.Task<System.ValueTuple<Akka.Actor.Address, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.IAssociationEventListener>>> Listen() { }\n    public override System.Threading.Tasks.Task<bool> Shutdown() { }\n    public System.Threading.Tasks.Task<bool> Write(Akka.Remote.Transport.TestAssociationHandle handle, Google.Protobuf.ByteString payload) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining InetAddressDnsResolver Class in C#\nDESCRIPTION: Implements a DNS resolver using InetAddress. It inherits from ActorBase and uses a SimpleDnsCache and Configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_163\n\nLANGUAGE: C#\nCODE:\n```\npublic class InetAddressDnsResolver : Akka.Actor.ActorBase\n{\n    public InetAddressDnsResolver(Akka.IO.SimpleDnsCache cache, Akka.Configuration.Config config) { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IPruningState Interface in C#\nDESCRIPTION: This snippet defines the `IPruningState` interface, which is likely used for managing the state of pruning operations in a distributed data system.  It includes methods for adding seen nodes and merging pruning states. Pruning is a mechanism for removing outdated or irrelevant data from the distributed data set.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n    public interface IPruningState\n    {\n        Akka.DistributedData.IPruningState AddSeen(Akka.Actor.Address node);\n        Akka.DistributedData.IPruningState Merge(Akka.DistributedData.IPruningState other);\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Defining ISurrogated Interface in C#\nDESCRIPTION: An interface for objects that can be converted to surrogates during serialization. Defines the contract for converting an object to its surrogate form using the ToSurrogate method.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_240\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ISurrogated\n{\n    Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Assembly Metadata and InternalsVisibleTo Attributes in C#\nDESCRIPTION: Assembly-level attributes that define metadata about the project, including the repository URL, internal visibility to other assemblies, and target framework. These attributes allow specific Akka.NET assemblies to access internal members of this assembly.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Persistence.TCK\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Persistence.Tests\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"e3bcba88-003c-4cda-8a60-f0c2553fe3c8\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Lookup Class\nDESCRIPTION: This code defines the `Lookup` class, representing a service discovery lookup query.  It encapsulates the service name, port name, and protocol to use for service resolution. It includes methods for copying with modifications, equality checks, parsing from SRV records, and string representation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.Core.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace Akka.Discovery\n{\n    public class Lookup : Akka.Actor.INoSerializationVerificationNeeded, System.IEquatable<Akka.Discovery.Lookup>\n    {\n        public Lookup(string serviceName, string portName = null, string protocol = null) { }\n        public string PortName { get; }\n        public string Protocol { get; }\n        public string ServiceName { get; }\n        public Akka.Discovery.Lookup Copy(string serviceName = null, string portName = null, string protocol = null) { }\n        public bool Equals(Akka.Discovery.Lookup other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n        public static bool IsValid(string srv) { }\n        public static Akka.Discovery.Lookup ParseSrv(string srv) { }\n        public override string ToString() { }\n        public Akka.Discovery.Lookup WithPortName(string portName) { }\n        public Akka.Discovery.Lookup WithProtocol(string protocol) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Distributed GSet\nDESCRIPTION: Provides static methods for creating a grow-only set with immutable elements in a distributed context\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\npublic static Akka.DistributedData.GSet<T> Create<T>(params T[] elements) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing NotFound Class for Akka.NET Distributed Data in C#\nDESCRIPTION: Defines the NotFound class representing a not found response in distributed data operations. It includes properties for the key and request, as well as methods for equality comparison and generic data retrieval.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class NotFound : Akka.Actor.INoSerializationVerificationNeeded, Akka.DistributedData.IGetResponse, Akka.DistributedData.IReplicatorMessage, System.IEquatable<Akka.DistributedData.NotFound>\n{\n    public NotFound(Akka.DistributedData.IKey key, object request) { }\n    public bool IsFailure { get; }\n    public bool IsFound { get; }\n    public bool IsSuccessful { get; }\n    public Akka.DistributedData.IKey Key { get; }\n    public object Request { get; }\n    public bool Equals(Akka.DistributedData.NotFound other) { }\n    public override bool Equals(object obj) { }\n    public T Get<T>(Akka.DistributedData.IKey<T> key)\n        where T : Akka.DistributedData.IReplicatedData { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IKey and IKey<T> Interfaces in Akka.NET Distributed Data\nDESCRIPTION: Defines the basic key interfaces used to identify replicated data in Akka.NET's distributed data system. IKey provides a string identifier, while the generic version adds type constraints for the replicated data.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IKey : Akka.DistributedData.IReplicatedDataSerialization\n{\n    string Id { get; }\n}\npublic interface IKey<out T> : Akka.DistributedData.IKey, Akka.DistributedData.IReplicatedDataSerialization\n    where out T : Akka.DistributedData.IReplicatedData { }\n```\n\n----------------------------------------\n\nTITLE: Defining Command Methods in C#\nDESCRIPTION: This snippet shows various overloads of the Command method for handling different types of messages and handlers in Akka.NET persistence.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\nprotected void Command(System.Type messageType, System.Predicate<object> shouldHandle, System.Action<object> handler) { }\nprotected void Command<T>(System.Func<T, bool> handler) { }\nprotected void Command(System.Type messageType, System.Func<object, bool> handler) { }\nprotected void Command(System.Action<object> handler) { }\nprotected void CommandAny(System.Action<object> handler) { }\nprotected void CommandAnyAsync(System.Func<object, System.Threading.Tasks.Task> handler) { }\n```\n\n----------------------------------------\n\nTITLE: Defining IRemovedNodePruning Interface for Node Removal in C#\nDESCRIPTION: Defines the IRemovedNodePruning interface that extends IReplicatedData with methods for handling node removal from a cluster, including pruning and cleanup operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IRemovedNodePruning : Akka.DistributedData.IReplicatedData\n{\n    System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.UniqueAddress> ModifiedByNodes { get; }\n    bool NeedPruningFrom(Akka.Cluster.UniqueAddress removedNode);\n    Akka.DistributedData.IReplicatedData Prune(Akka.Cluster.UniqueAddress removedNode, Akka.Cluster.UniqueAddress collapseInto);\n    Akka.DistributedData.IReplicatedData PruningCleanup(Akka.Cluster.UniqueAddress removedNode);\n}\n```\n\n----------------------------------------\n\nTITLE: Version Vector Base Class in C#\nDESCRIPTION: Abstract base class implementing version vector functionality for distributed data replication with methods for comparing, merging and pruning versions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_50\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class VersionVector : Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IReplicatedData\n{\n    protected static readonly Akka.Util.Internal.AtomicCounterLong Counter;\n    public static readonly Akka.DistributedData.VersionVector Empty;\n    public abstract int Count { get; }\n    public abstract bool IsEmpty { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RegexMatcher Class in Akka.NET TestKit\nDESCRIPTION: A string matcher that uses regular expressions to determine matches. This class implements IStringMatcher and leverages the .NET Regex class for pattern matching.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_48\n\nLANGUAGE: C#\nCODE:\n```\npublic class RegexMatcher : Akka.TestKit.Internal.StringMatcher.IStringMatcher\n{\n    public RegexMatcher(System.Text.RegularExpressions.Regex regex) { }\n    public bool IsMatch(string s) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Distributed Data with Storage Role\nDESCRIPTION: HOCON configuration for deploying Distributed Data on nodes with the 'storage' role, providing a distributed key-value store across the cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/member-roles.md#2025-04-16_snippet_7\n\nLANGUAGE: hocon\nCODE:\n```\nakka\n{\n  cluster\n  {\n    roles = [\"storage\"]\n    distributed-data\n    {\n      role = \"storage\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecating ClusterSingleton Init() Method - C#\nDESCRIPTION: Adjusts the usage of ClusterSingleton.Init() method to employ ClusterSingletonManager.Props and ClusterSingletonProxy.Props for compatibility with future versions of Akka.NET. Requires understanding of actor system setup in C# and possible refactoring of existing cluster configurations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/whats-new/akkadotnet-v1.5-upgrade-advisories.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar settings = ClusterSingletonSettings.Create(system);\nvar singletonActor = SingletonActor.Create(Counter.Props, \"GlobalCounter\")\n    .WithStopMessage(MyStopMessage.Instance)\n    .WithSettings(settings);\nvar proxy = singleton.Init(singletonActor);\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvar managerSettings = ClusterSingletonManagerSettings.Create(system)\n    .WithSingletonName(\"GlobalCounter\");\nsystem.ActorOf(\n    props: ClusterSingletonManager.Props(\n        singletonProps: Counter.Props,\n        terminationMessage: MyStopMessage.Instance,\n        settings: managerSettings),\n    name: \"singletonManagerGlobalCounter\");\n\nvar proxySettings = ClusterSingletonProxySettings.Create(system)\n    .WithSingletonName(\"GlobalCounter\");\nvar proxy = system.ActorOf(\n    props: ClusterSingletonProxy.Props(\n        singletonManagerPath: \"/user/singletonManagerGlobalCounter\",\n        settings: proxySettings),\n    name: \"singletonProxyGlobalCounter\");\n```\n\n----------------------------------------\n\nTITLE: Testing Normal Device Response - C#\nDESCRIPTION: This snippet tests the scenario where two devices correctly report their temperature to the query actor. It ensures the actor handles successful readings as expected.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-4.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[DeviceGroupQuerySpec.cs](../../../../src/core/Akka.Docs.Tutorials/Tutorial4/DeviceGroupQuerySpec.cs?name=query-test-normal)]\n```\n\n----------------------------------------\n\nTITLE: ISocketEventArgsPool Interface for Socket Event Management\nDESCRIPTION: Defines a pool interface for managing SocketAsyncEventArgs in Akka.NET to improve socket operation efficiency. This interface enables reuse of socket event arguments across operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_160\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ISocketEventArgsPool\n    {\n        Akka.IO.Buffers.BufferPoolInfo BufferPoolInfo { get; }\n        System.Net.Sockets.SocketAsyncEventArgs Acquire(Akka.Actor.IActorRef actor);\n        void Release(System.Net.Sockets.SocketAsyncEventArgs e);\n    }\n```\n\n----------------------------------------\n\nTITLE: SingleVersionVector Class Definition in C#\nDESCRIPTION: Implements a version vector for a single node in Akka.NET's distributed data system. This class provides methods for tracking version changes, merging with other version vectors, and handling node pruning operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_45\n\nLANGUAGE: C#\nCODE:\n```\n[System.Diagnostics.DebuggerDisplayAttribute(\"VersionVector({Node}->{Version})\")]\npublic sealed class SingleVersionVector : Akka.DistributedData.VersionVector\n{\n    public SingleVersionVector(Akka.Cluster.UniqueAddress node, long version) { }\n    public override int Count { get; }\n    public override bool IsEmpty { get; }\n    public override System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.UniqueAddress> ModifiedByNodes { get; }\n    public override System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<Akka.Cluster.UniqueAddress, long>> VersionEnumerator { get; }\n    public override bool Contains(Akka.Cluster.UniqueAddress node) { }\n    public override int GetHashCode() { }\n    public override Akka.DistributedData.VersionVector Increment(Akka.Cluster.UniqueAddress node) { }\n    public override Akka.DistributedData.VersionVector Merge(Akka.DistributedData.VersionVector other) { }\n    public override bool NeedPruningFrom(Akka.Cluster.UniqueAddress removedNode) { }\n    public override Akka.DistributedData.VersionVector Prune(Akka.Cluster.UniqueAddress removedNode, Akka.Cluster.UniqueAddress collapseInto) { }\n    public override Akka.DistributedData.VersionVector PruningCleanup(Akka.Cluster.UniqueAddress removedNode) { }\n    public override string ToString() { }\n    public override long VersionAt(Akka.Cluster.UniqueAddress node) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ThrottlerProvider Class in Akka.NET Remote Transport\nDESCRIPTION: A provider class that creates ThrottleTransportAdapter instances, implementing the ITransportAdapterProvider interface in Akka.NET's transport system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\npublic class ThrottlerProvider : Akka.Remote.Transport.ITransportAdapterProvider\n{\n    public ThrottlerProvider() { }\n    public Akka.Remote.Transport.Transport Create(Akka.Remote.Transport.Transport wrappedTransport, Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing InternalCurrentActorCellKeeper Static Class in C#\nDESCRIPTION: Static class that keeps track of the current ActorCell in the execution context, providing thread-local actor cell access.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_58\n\nLANGUAGE: C#\nCODE:\n```\npublic class static InternalCurrentActorCellKeeper\n{\n    public static Akka.Actor.ActorCell Current { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EventReplayFailure Class in C#\nDESCRIPTION: A sealed class representing a failure during event replay operations. Contains the exception cause and implements equality members for comparison.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class EventReplayFailure\n{\n    public EventReplayFailure(System.Exception cause) { }\n    public System.Exception Cause { get; }\n    public bool Equals(Akka.Persistence.Sql.Common.Journal.EventReplayFailure other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BatchingSqlJournal Abstract Class in C#\nDESCRIPTION: Abstract base class for implementing SQL-based persistence journals with batching capabilities. It provides the foundation for SQL-specific journal implementations with methods for handling various persistence operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nprotected const int TimestampIndex = 2;\nprotected BatchingSqlJournal(Akka.Persistence.Sql.Common.Journal.BatchingSqlJournalSetup setup) { }\nprotected virtual string AllEventsSql { get; }\nprotected virtual string AllPersistenceIdsSql { get; }\nprotected virtual string ByPersistenceIdSql { get; }\nprotected virtual string ByTagSql { get; }\nprotected virtual string DeleteBatchSql { get; }\nprotected virtual string HighestOrderingSql { get; }\nprotected virtual string HighestSequenceNrSql { get; }\nprotected abstract System.Collections.Immutable.ImmutableDictionary<string, string> Initializers { get; }\nprotected virtual string InsertEventSql { get; }\nprotected Akka.Persistence.Sql.Common.Journal.BatchingSqlJournalSetup Setup { get; }\nprotected Akka.Persistence.Sql.Common.Journal.ITimestampProvider TimestampProvider { get; }\nprotected virtual string UpdateSequenceNrSql { get; }\nprotected void AddParameter(TCommand command, string paramName, System.Data.DbType dbType, object value) { }\nprotected void BatchRequest(Akka.Persistence.IJournalRequest message) { }\nprotected abstract TConnection CreateConnection(string connectionString);\nprotected virtual System.Threading.Tasks.Task HandleDeleteMessagesTo(Akka.Persistence.DeleteMessagesTo req, TCommand command) { }\nprotected virtual System.Threading.Tasks.Task HandleReplayAllMessages(Akka.Persistence.Sql.Common.Journal.ReplayAllEvents req, TCommand command) { }\nprotected virtual System.Threading.Tasks.Task HandleReplayMessages(Akka.Persistence.ReplayMessages req, TCommand command, Akka.Actor.IActorContext context) { }\nprotected virtual System.Threading.Tasks.Task HandleReplayTaggedMessages(Akka.Persistence.Sql.Common.Journal.ReplayTaggedMessages req, TCommand command) { }\nprotected virtual System.Threading.Tasks.Task HandleSelectCurrentPersistenceIds(Akka.Persistence.Sql.Common.Journal.SelectCurrentPersistenceIds message, TCommand command) { }\nprotected virtual void OnBufferOverflow(Akka.Persistence.IJournalMessage request) { }\nprotected virtual void PreAddParameterToCommand(TCommand command, System.Data.Common.DbParameter param) { }\nprotected override void PreStart() { }\nprotected virtual Akka.Persistence.IPersistentRepresentation ReadEvent(System.Data.Common.DbDataReader reader) { }\nprotected virtual System.Threading.Tasks.Task<long> ReadHighestSequenceNr(string persistenceId, TCommand command) { }\nprotected virtual System.Threading.Tasks.Task<long> ReadHighestSequenceNr(TCommand command) { }\nprotected virtual bool Receive(object message) { }\nprotected virtual void WriteEvent(TCommand command, Akka.Persistence.IPersistentRepresentation persistent, string tags = \"\") { }\n```\n\n----------------------------------------\n\nTITLE: Defining PersistentFSM State Interface in C#\nDESCRIPTION: Interface that defines the basic structure for a state in a PersistentFSM. States must provide an identifier to enable persistence and recovery.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IFsmState\n{\n    string Identifier { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SerializerWithStringManifest Base Class in C#\nDESCRIPTION: An abstract base class for serializers that use string manifests to identify types. Extends the Akka.Serialization.Serializer class and provides methods for binary serialization with manifest support.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_228\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class SerializerWithStringManifest : Akka.Serialization.Serializer\n{\n    protected SerializerWithStringManifest(Akka.Actor.ExtendedActorSystem system) { }\n    public virtual bool IncludeManifest { get; }\n    public virtual object FromBinary(byte[] bytes, System.Type type) { }\n    public abstract object FromBinary(byte[] bytes, string manifest);\n    public abstract string Manifest(object o);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LeaseException Class in C#\nDESCRIPTION: Exception class for lease-related errors in the coordination system. Provides multiple constructors for different error scenarios including serialization support.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.Core.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class LeaseException : System.Exception\n{\n    public LeaseException(string message) { }\n    public LeaseException(string message, System.Exception innerEx) { }\n    protected LeaseException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SnapshotSelectionCriteria Class in Akka.NET\nDESCRIPTION: The SnapshotSelectionCriteria class defines criteria for selecting snapshots during recovery. It allows filtering snapshots based on sequence numbers and timestamps.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SnapshotSelectionCriteria : System.IEquatable<Akka.Persistence.SnapshotSelectionCriteria>\n{\n    [Newtonsoft.Json.JsonConstructorAttribute()]\n    public SnapshotSelectionCriteria(long maxSequenceNr, System.DateTime maxTimeStamp, long minSequenceNr = 0, System.Nullable<System.DateTime> minTimestamp = null) { }\n    public SnapshotSelectionCriteria(long maxSequenceNr) { }\n    public static Akka.Persistence.SnapshotSelectionCriteria Latest { get; }\n    public long MaxSequenceNr { get; }\n    public System.DateTime MaxTimeStamp { get; }\n    public long MinSequenceNr { get; }\n    public System.Nullable<System.DateTime> MinTimestamp { get; }\n    public static Akka.Persistence.SnapshotSelectionCriteria None { get; }\n    public bool Equals(Akka.Persistence.SnapshotSelectionCriteria other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: AtomicWrite Class Definition in Akka.Persistence\nDESCRIPTION: Represents a collection of persistent events that must be stored atomically (all or nothing) in the journal. This class ensures that multiple events are either all persisted successfully or none of them are persisted.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class AtomicWrite : Akka.Persistence.IPersistentEnvelope, Akka.Persistence.Serialization.IMessage\n{\n    public AtomicWrite(Akka.Persistence.IPersistentRepresentation @event) { }\n    public AtomicWrite(System.Collections.Immutable.IImmutableList<Akka.Persistence.IPersistentRepresentation> payload) { }\n    public long HighestSequenceNr { get; }\n    public long LowestSequenceNr { get; }\n    public object Payload { get; }\n    public string PersistenceId { get; }\n    public Akka.Actor.IActorRef Sender { get; }\n    public int Size { get; }\n    public bool Equals(Akka.Persistence.AtomicWrite other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FSM Generic Class in C#\nDESCRIPTION: Defines the FSM<TState, TData> class which extends FSMBase and implements IInternalSupportsTestFSMRef and IListeners interfaces. It provides methods for managing finite state machine transitions, timers, and state data.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class FSM<TState, TData> : Akka.Actor.FSMBase, Akka.Actor.Internal.IInternalSupportsTestFSMRef<TState, TData>, Akka.Routing.IListeners\n{\n    protected bool DebugEvent;\n    protected FSM() { }\n    public Akka.Routing.ListenerSupport Listeners { get; }\n    public TData NextStateData { get; }\n    public TData StateData { get; }\n    public TState StateName { get; }\n    public void CancelTimer(string name) { }\n    public Akka.Actor.FSMBase.State<TState, TData> GoTo(TState nextStateName) { }\n    // ... (other methods omitted for brevity)\n}\n```\n\n----------------------------------------\n\nTITLE: ClusterClientSettings Configuration in C#\nDESCRIPTION: Settings class that configures the behavior of the ClusterClient, including intervals for contacting and refreshing contacts, heartbeat timing, and buffer sizes. It uses a builder pattern to create and modify settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Core.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterClientSettings : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public ClusterClientSettings(System.Collections.Immutable.IImmutableSet<Akka.Actor.ActorPath> initialContacts, System.TimeSpan establishingGetContactsInterval, System.TimeSpan refreshContactsInterval, System.TimeSpan heartbeatInterval, System.TimeSpan acceptableHeartbeatPause, int bufferSize, System.Nullable<System.TimeSpan> reconnectTimeout = null) { }\n    public System.TimeSpan AcceptableHeartbeatPause { get; }\n    public int BufferSize { get; }\n    public System.TimeSpan EstablishingGetContactsInterval { get; }\n    public System.TimeSpan HeartbeatInterval { get; }\n    public System.Collections.Immutable.IImmutableSet<Akka.Actor.ActorPath> InitialContacts { get; }\n    public System.Nullable<System.TimeSpan> ReconnectTimeout { get; }\n    public System.TimeSpan RefreshContactsInterval { get; }\n    public static Akka.Cluster.Tools.Client.ClusterClientSettings Create(Akka.Actor.ActorSystem system) { }\n    public static Akka.Cluster.Tools.Client.ClusterClientSettings Create(Akka.Configuration.Config config) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithBufferSize(int bufferSize) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithEstablishingGetContactsInterval(System.TimeSpan value) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithHeartbeatInterval(System.TimeSpan value) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithInitialContacts(System.Collections.Immutable.IImmutableSet<Akka.Actor.ActorPath> initialContacts) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithReconnectTimeout(System.Nullable<System.TimeSpan> reconnectTimeout) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithRefreshContactsInterval(System.TimeSpan value) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Xunit Attributes in C#\nDESCRIPTION: This snippet defines custom Xunit attributes for test execution in Akka.NET. The LocalFactAttribute and LocalTheoryAttribute allow skipping tests conditionally, based on the 'Skip' property. Similarly, WindowsFactAttribute provides a platform-specific way to skip tests on Unix systems.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKitXunit2.Net.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.TestKit.Xunit2.Attributes\n{\n    public class LocalFactAttribute : Xunit.FactAttribute\n    {\n        public LocalFactAttribute() { }\n        public override string Skip { get; set; }\n        public string SkipLocal { get; set; }\n    }\n    [System.AttributeUsageAttribute(System.AttributeTargets.Method | System.AttributeTargets.All, AllowMultiple=false)]\n    [Xunit.Sdk.XunitTestCaseDiscovererAttribute(\"Xunit.Sdk.TheoryDiscoverer\", \"xunit.execution.{Platform}\")]\n    public class LocalTheoryAttribute : Xunit.TheoryAttribute\n    {\n        public LocalTheoryAttribute() { }\n        public override string Skip { get; set; }\n        public string SkipLocal { get; set; }\n    }\n    public class WindowsFactAttribute : Xunit.FactAttribute\n    {\n        public WindowsFactAttribute() { }\n        public override string Skip { get; set; }\n        public string SkipUnix { get; set; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: UniqueAddress Class Definition\nDESCRIPTION: This snippet defines a class `UniqueAddress` that implements `IComparable`, `IComparable<Akka.Cluster.UniqueAddress>`, and `IEquatable<Akka.Cluster.UniqueAddress>`. It represents a unique identifier for a member within the Akka cluster, consisting of an `Address` and a unique integer `Uid`. It includes methods for comparing, checking equality, and generating a hash code.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\npublic class UniqueAddress : System.IComparable, System.IComparable<Akka.Cluster.UniqueAddress>, System.IEquatable<Akka.Cluster.UniqueAddress>\n{\n    public UniqueAddress(Akka.Actor.Address address, int uid) { }\n    public Akka.Actor.Address Address { get; }\n    public int Uid { get; }\n    public int CompareTo(Akka.Cluster.UniqueAddress uniqueAddress) { }\n    public bool Equals(Akka.Cluster.UniqueAddress other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n    public static bool ==(Akka.Cluster.UniqueAddress left, Akka.Cluster.UniqueAddress right) { }\n    public static bool !=(Akka.Cluster.UniqueAddress left, Akka.Cluster.UniqueAddress right) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Actor States for Lease Management\nDESCRIPTION: Implementation of actor states for handling lease acquisition and active operation, including message handling and state transitions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/lease.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nprivate void AcquiringLease(object message)\n{\n    switch (message)\n    {\n        case AcquireLeaseSuccess _:\n            UnstashAll();\n            Become(Active);\n            break;\n        case AcquireLeaseFailed _:\n            Context.System.Scheduler.ScheduleTellOnce(\n                _retryInterval,\n                Self,\n                new AcquireLease(),\n                Self);\n            break;\n        default:\n            Stash();\n            break;\n    }\n}\n\nprivate void Active(object message)\n{\n    switch (message)\n    {\n        case LeaseLost _:\n            Context.Stop(Self);\n            break;\n        default:\n            // Normal message handling\n            break;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Streams with TestProbe and Task in C#\nDESCRIPTION: This example shows how to test a stream by materializing it to a Task and using the pipe pattern to send the result to a TestProbe for assertion.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/testingstreams.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar sourceUnderTest = Source.From(Enumerable.Range(1, 4)).Grouped(2);\n\nvar expected = new[] {Enumerable.Range(1, 2), Enumerable.Range(3, 2)}.AsEnumerable();\nvar probe = CreateTestProbe();\n\nsourceUnderTest.Grouped(2)\n    .RunWith(Sink.First<IEnumerable<IEnumerable<int>>>(), materializer)\n    .PipeTo(probe.Ref);\n    \nprobe.ExpectMsg(expected);\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterMessageSerializer in C#\nDESCRIPTION: Defines a serializer for cluster messages in Akka.NET. It extends SerializerWithStringManifest and provides methods for binary serialization and deserialization of cluster messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic class ClusterMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public ClusterMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object o) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HashCodeMessageExtractor Abstract Class in C#\nDESCRIPTION: An abstract class for extracting entity and shard IDs from messages using hash codes, with a configurable maximum number of shards.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class HashCodeMessageExtractor : Akka.Cluster.Sharding.IMessageExtractor\n{\n    public readonly int MaxNumberOfShards;\n    protected HashCodeMessageExtractor(int maxNumberOfShards) { }\n    public abstract string EntityId(object message);\n    public virtual object EntityMessage(object message) { }\n    public virtual string ShardId(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LWWRegisterKey<T> Class in C#\nDESCRIPTION: Extends the Key<T> class for Last-Write-Wins registers, providing strong typing for the value type stored in the register.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class LWWRegisterKey<T> : Akka.DistributedData.Key<Akka.DistributedData.LWWRegister<T>>\n{\n    public LWWRegisterKey(string id) { }\n    public System.Type RegisterType { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ISnapshotQueryExecutor Interface for SQL Snapshot Operations in C#\nDESCRIPTION: Interface defining methods for SQL snapshot operations including creating tables, deleting snapshots, inserting snapshots, and selecting snapshots.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.DotNet.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ISnapshotQueryExecutor\n{\n    Akka.Persistence.Sql.Common.Snapshot.QueryConfiguration Configuration { get; }\n    System.Threading.Tasks.Task CreateTableAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken);\n    System.Threading.Tasks.Task DeleteAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string persistenceId, long sequenceNr, System.Nullable<System.DateTime> timestamp);\n    System.Threading.Tasks.Task DeleteBatchAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string persistenceId, long maxSequenceNr, System.DateTime maxTimestamp);\n    System.Threading.Tasks.Task InsertAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, object snapshot, Akka.Persistence.SnapshotMetadata metadata);\n    System.Threading.Tasks.Task<Akka.Persistence.SelectedSnapshot> SelectSnapshotAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string persistenceId, long maxSequenceNr, System.DateTime maxTimestamp);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract Query Executor for SQL Snapshots in C#\nDESCRIPTION: Abstract base class for executing SQL snapshot operations with configurable serialization and isolation levels. Provides methods for CRUD operations on snapshot data with customizable SQL queries.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AbstractQueryExecutor : ISnapshotQueryExecutor\n{\n    protected Akka.Serialization.Serialization Serialization;\n    protected AbstractQueryExecutor(QueryConfiguration configuration, Akka.Serialization.Serialization serialization) { }\n    public QueryConfiguration Configuration { get; }\n    protected abstract string CreateSnapshotTableSql { get; }\n    protected virtual string DeleteSnapshotRangeSql { get; }\n    protected virtual string DeleteSnapshotSql { get; }\n    protected virtual string InsertSnapshotSql { get; }\n    public System.Data.IsolationLevel ReadIsolationLevel { get; }\n    protected virtual string SelectSnapshotSql { get; }\n    public System.Data.IsolationLevel WriteIsolationLevel { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Remote Router Configuration in C#\nDESCRIPTION: Configuration class for remote routers in Akka.NET that implements pool-based routing with support for remote nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class RemoteRouterConfig : Akka.Routing.Pool, System.IEquatable<Akka.Routing.RouterConfig>\n{\n    public RemoteRouterConfig(Akka.Routing.Pool local, System.Collections.Generic.IEnumerable<Akka.Actor.Address> nodes) { }\n    public override Akka.Routing.Resizer Resizer { get; }\n    public override string RouterDispatcher { get; }\n    public override Akka.Actor.SupervisorStrategy SupervisorStrategy { get; }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override Akka.Actor.ActorBase CreateRouterActor() { }\n    public bool Equals(Akka.Routing.RouterConfig other) { }\n    public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Task Scheduler Priority Enumeration\nDESCRIPTION: Enumeration defining priority levels for task scheduling in the Akka.NET dispatcher system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_90\n\nLANGUAGE: C#\nCODE:\n```\npublic enum TaskSchedulerPriority\n{\n    None = 0,\n    Idle = 4,\n    Background = 4,\n    Low = 5,\n    BelowNormal = 6,\n    Normal = 8,\n    AboveNormal = 10,\n    High = 13,\n    Realtime = 24,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PersistentFSMBase in C#\nDESCRIPTION: Defines the abstract PersistentFSMBase class that extends PersistentActor and implements IListeners. This class provides the core functionality for persistent finite state machines in Akka.NET, with methods for state transitions, timer management, and event handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_49\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class PersistentFSMBase<TState, TData, TEvent> : Akka.Persistence.PersistentActor, Akka.Routing.IListeners\n{\n    protected PersistentFSMBase() { }\n    public Akka.Routing.ListenerSupport Listeners { get; }\n    public TData NextStateData { get; }\n    public TData StateData { get; }\n    public TState StateName { get; }\n    protected System.Collections.Generic.IEnumerable<TState> StateNames { get; }\n    protected virtual void ApplyState(Akka.Persistence.Fsm.PersistentFSM.State<TState, TData, TEvent> nextState) { }\n    public void CancelTimer(string name) { }\n    public Akka.Persistence.Fsm.PersistentFSM.State<TState, TData, TEvent> GoTo(TState nextStateName) { }\n    public bool IsTimerActive(string name) { }\n    protected virtual void LogTermination(Akka.Actor.FSMBase.Reason reason) { }\n    public void OnTermination(System.Action<Akka.Actor.FSMBase.StopEvent<TState, TData>> terminationHandler) { }\n    public void OnTransition(Akka.Persistence.Fsm.PersistentFSMBase<TState, TData, TEvent>.TransitionHandler transitionHandler) { }\n    protected override void PostStop() { }\n    protected override bool ReceiveCommand(object message) { }\n    public void SetStateTimeout(TState state, System.Nullable<System.TimeSpan> timeout) { }\n    public void SetTimer(string name, object msg, System.TimeSpan timeout, bool repeat = False) { }\n    public void StartWith(TState stateName, TData stateData, System.Nullable<System.TimeSpan> timeout = null) { }\n    public Akka.Persistence.Fsm.PersistentFSM.State<TState, TData, TEvent> Stay() { }\n    public Akka.Persistence.Fsm.PersistentFSM.State<TState, TData, TEvent> Stop() { }\n    public Akka.Persistence.Fsm.PersistentFSM.State<TState, TData, TEvent> Stop(Akka.Actor.FSMBase.Reason reason) { }\n    public Akka.Persistence.Fsm.PersistentFSM.State<TState, TData, TEvent> Stop(Akka.Actor.FSMBase.Reason reason, TData stateData) { }\n    public Akka.Persistence.Fsm.PersistentFSMBase<TState, TData, TEvent>.TransformHelper Transform(Akka.Persistence.Fsm.PersistentFSMBase<TState, TData, TEvent>.StateFunction func) { }\n    public void When(TState stateName, Akka.Persistence.Fsm.PersistentFSMBase<TState, TData, TEvent>.StateFunction func, System.Nullable<System.TimeSpan> timeout = null) { }\n    public void WhenUnhandled(Akka.Persistence.Fsm.PersistentFSMBase<TState, TData, TEvent>.StateFunction stateFunction) { }\n    public delegate Akka.Persistence.Fsm.PersistentFSM.State<TState, TData, TEvent> StateFunction<TState, TData, TEvent>(Akka.Actor.FSMBase.Event<TData> fsmEvent, Akka.Persistence.Fsm.PersistentFSM.State<TState, TData, TEvent> state = null);\n    public sealed class TransformHelper<TState, TData, TEvent>\n    {\n        public TransformHelper(Akka.Persistence.Fsm.PersistentFSMBase<TState, TData, TEvent>.StateFunction func) { }\n        public Akka.Persistence.Fsm.PersistentFSMBase<TState, TData, TEvent>.StateFunction Func { get; }\n        public Akka.Persistence.Fsm.PersistentFSMBase<TState, TData, TEvent>.StateFunction Using(System.Func<Akka.Persistence.Fsm.PersistentFSM.State<TState, TData, TEvent>, Akka.Persistence.Fsm.PersistentFSM.State<TState, TData, TEvent>> andThen) { }\n    }\n    public delegate void TransitionHandler<TState, TData, TEvent>(TState initialState, TState nextState);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Persistence Interfaces in C#\nDESCRIPTION: A collection of interfaces defining the structure for journal messages, requests, and responses within Akka Persistence. These interfaces ensure consistent interaction patterns across various persistence-related operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IJournalMessage : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage { }\npublic interface IJournalPlugin\n{\n    Akka.Configuration.Config DefaultConfig { get; }\n    string JournalPath { get; }\n}\npublic interface IJournalRequest : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IJournalMessage, Akka.Persistence.IPersistenceMessage { }\npublic interface IJournalResponse : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IJournalMessage, Akka.Persistence.IPersistenceMessage { }\npublic interface IPendingHandlerInvocation\n{\n    object Event { get; }\n    System.Action<object> Handler { get; }\n}\npublic interface IPersistenceMessage : Akka.Actor.INoSerializationVerificationNeeded { }\npublic interface IPersistenceRecovery\n{\n    Akka.Persistence.Recovery Recovery { get; }\n}\npublic interface IPersistenceStash : Akka.Actor.IActorStash, Akka.Actor.IWithUnboundedStash, Akka.Actor.IWithUnrestrictedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics>\n{\n    Akka.Persistence.IStashOverflowStrategy InternalStashOverflowStrategy { get; }\n}\npublic interface IPersistentEnvelope\n{\n    object Payload { get; }\n    Akka.Actor.IActorRef Sender { get; }\n    int Size { get; }\n}\npublic interface IPersistentIdentity\n{\n    string JournalPluginId { get; }\n    string PersistenceId { get; }\n    string SnapshotPluginId { get; }\n}\npublic interface IPersistentRepresentation : Akka.Persistence.Serialization.IMessage\n{\n    bool IsDeleted { get; }\n    string Manifest { get; }\n    object Payload { get; }\n    string PersistenceId { get; }\n    Akka.Actor.IActorRef Sender { get; }\n    long SequenceNr { get; }\n    long Timestamp { get; }\n    string WriterGuid { get; }\n    Akka.Persistence.IPersistentRepresentation Update(long sequenceNr, string persistenceId, bool isDeleted, Akka.Actor.IActorRef sender, string writerGuid);\n    Akka.Persistence.IPersistentRepresentation WithManifest(string manifest);\n    Akka.Persistence.IPersistentRepresentation WithPayload(object payload);\n    Akka.Persistence.IPersistentRepresentation WithTimestamp(long timestamp);\n}\n```\n\n----------------------------------------\n\nTITLE: Running Akka.Cluster Benchmark as a Standalone Executable in Powershell\nDESCRIPTION: This snippet details the commands to execute the Akka.Cluster.Cpu.Benchmark as a standalone compiled executable. This method similarly outputs CPU usage data to a .csv file, and shares requirements such as the .NET runtime being present on the system. Users can pass optional arguments to modify the benchmark configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/benchmark/Akka.Cluster.Cpu.Benchmark/README.md#2025-04-16_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n./Akka.Cluster.Cpu.Benchmark.exe [OPTIONS]\ndotnet run Akka.Cluster.Cpu.Benchmark.dll\ndotnet run Akka.Cluster.Cpu.Benchmark.dll -- [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Implementing Stable Priority Message Queue in Akka.NET\nDESCRIPTION: Defines a stable priority-based unbounded message queue that maintains order of messages with the same priority. Extends BlockingMessageQueue to provide thread-safe operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_114\n\nLANGUAGE: C#\nCODE:\n```\npublic class UnboundedStablePriorityMessageQueue : Akka.Dispatch.MessageQueues.BlockingMessageQueue, Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics, Akka.Dispatch.IUnboundedMessageQueueSemantics\n{\n    public UnboundedStablePriorityMessageQueue(System.Func<object, int> priorityGenerator, int initialCapacity) { }\n    protected override int LockedCount { get; }\n    public void EnqueueFirst(Akka.Actor.Envelope envelope) { }\n    protected override void LockedEnqueue(Akka.Actor.Envelope envelope) { }\n    protected override bool LockedTryDequeue(out Akka.Actor.Envelope envelope) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Snapshot Loading and Results in C#\nDESCRIPTION: Implements classes for loading snapshots (LoadSnapshot) and handling results (LoadSnapshotResult, LoadSnapshotFailed) with proper equality comparison support.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class LoadSnapshot : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage, Akka.Persistence.ISnapshotRequest, System.IEquatable<Akka.Persistence.LoadSnapshot>\n{\n    public LoadSnapshot(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria, long toSequenceNr) { }\n    public Akka.Persistence.SnapshotSelectionCriteria Criteria { get; }\n    public string PersistenceId { get; }\n    public long ToSequenceNr { get; }\n    public bool Equals(Akka.Persistence.LoadSnapshot other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: SubscriptionInitialStateMode Enum\nDESCRIPTION: This snippet defines an enum `SubscriptionInitialStateMode` with two possible values: `InitialStateAsSnapshot` and `InitialStateAsEvents`. This enum probably controls how initial state is delivered when subscribing to cluster events. `InitialStateAsSnapshot` likely sends the entire current state, while `InitialStateAsEvents` replays all state changes from the beginning.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum SubscriptionInitialStateMode\n{\n    InitialStateAsSnapshot = 0,\n    InitialStateAsEvents = 1,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AsyncReplayTimeoutException in C#\nDESCRIPTION: Defines the AsyncReplayTimeoutException class that extends AkkaException. This exception is used to signal timeout errors during asynchronous replay operations in the persistence journal.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_55\n\nLANGUAGE: C#\nCODE:\n```\npublic class AsyncReplayTimeoutException : Akka.Actor.AkkaException\n{\n    public AsyncReplayTimeoutException() { }\n    public AsyncReplayTimeoutException(string message) { }\n    protected AsyncReplayTimeoutException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: ConsumerController Settings Class in C#\nDESCRIPTION: Configuration settings for ConsumerController, including flow control window settings and resend interval parameters for reliable delivery mechanisms.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_86\n\nLANGUAGE: C#\nCODE:\n```\n    [System.Runtime.CompilerServices.NullableAttribute(0)]\n    public sealed class Settings : System.IEquatable<Akka.Delivery.ConsumerController.Settings>\n    {\n        public int FlowControlWindow { get; set; }\n        public bool OnlyFlowControl { get; set; }\n        public System.TimeSpan ResendIntervalMax { get; set; }\n        public System.TimeSpan ResendIntervalMin { get; set; }\n        public static Akka.Delivery.ConsumerController.Settings Create(Akka.Actor.ActorSystem actorSystem) { }\n        public static Akka.Delivery.ConsumerController.Settings Create(Akka.Configuration.Config config) { }\n        public override string ToString() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing TCP Message Classes in Akka.NET\nDESCRIPTION: Base classes for TCP message handling, including Message, Command, and Event classes that form the foundation of the TCP communication protocol.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_155\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Command : Akka.IO.Tcp.Message\n{\n    protected Command() { }\n    public Akka.IO.Tcp.CommandFailed FailureMessage { get; }\n}\npublic class Event : Akka.IO.Tcp.Message\n{\n    public Event() { }\n}\npublic class Message : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public Message() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering and Monitoring Failures in Akka.Remote C#\nDESCRIPTION: This snippet includes DefaultFailureDetectorRegistry and IFailureDetectorRegistry interfaces for managing resources' failure detection. These interfaces support heartbeat signaling and monitoring status checks, crucial for maintaining communication integrity across remote actor systems. They rely on factories for creating detectors and include functionalities to reset and monitor failure detection status.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DefaultFailureDetectorRegistry<T> : Akka.Remote.IFailureDetectorRegistry<T>\n{\n    public DefaultFailureDetectorRegistry(System.Func<Akka.Remote.FailureDetector> factory) { }\n    public void Heartbeat(T resource) { }\n    public bool IsAvailable(T resource) { }\n    public bool IsMonitoring(T resource) { }\n    public void Remove(T resource) { }\n    public void Reset() { }\n}\npublic interface IFailureDetectorRegistry<in T>\n{\n    void Heartbeat(T resource);\n    bool IsAvailable(T resource);\n    bool IsMonitoring(T resource);\n    void Remove(T resource);\n    void Reset();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Default Metrics Collector\nDESCRIPTION: Default implementation of the metrics collector interface for Akka.NET clusters. Handles metrics sampling and resource cleanup.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Core.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class DefaultCollector : Akka.Cluster.Metrics.IMetricsCollector, System.IDisposable\n{\n    public DefaultCollector(Akka.Actor.Address address) { }\n    public DefaultCollector(Akka.Actor.ActorSystem system) { }\n    public void Dispose() { }\n    public Akka.Cluster.Metrics.Serialization.NodeMetrics Sample() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Values from HOCON Configuration in Akka.NET\nDESCRIPTION: Shows how to retrieve typed values from a HOCON configuration object.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/config.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar a = yourConfig.GetString(\"a\");\n```\n\n----------------------------------------\n\nTITLE: Implementing PreStart Hook in Akka.NET C#\nDESCRIPTION: Shows how to override the PreStart method in an Akka.NET actor. This method is called when the actor is first created and can be used for initialization code.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override void PreStart()\n{\n    child = Context.ActorOf(Props.Empty);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RoundRobinGroup Router in HOCON Configuration\nDESCRIPTION: Shows how to define a round-robin group router in HOCON configuration. This router type uses pre-existing actors at the specified paths rather than creating new ones.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_4\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.deployment {\n  /workers {\n    router = round-robin-group\n    routees.paths = [\"/user/workers/w1\", \"/user/workers/w2\", \"/user/workers/w3\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Delta and Update Interfaces for Distributed Data Operations\nDESCRIPTION: Defines interfaces for delta-based replication and update operations in Akka.NET's distributed data. These interfaces support efficient delta propagation and update response handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IReplicatedDelta : Akka.DistributedData.IReplicatedData\n{\n    Akka.DistributedData.IDeltaReplicatedData Zero { get; }\n}\npublic interface IReplicatedDeltaSize\n{\n    int DeltaSize { get; }\n}\npublic interface IReplicatorMessage { }\npublic interface IRequireCausualDeliveryOfDeltas : Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDelta { }\n```\n\n----------------------------------------\n\nTITLE: Defining WarningFilter Class in C#\nDESCRIPTION: This snippet defines the WarningFilter class, which is used to filter warning messages in Akka.NET TestKit. It extends the EventFilterBase class and provides methods for matching log events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic class WarningFilter : Akka.TestKit.Internal.EventFilterBase\n{\n    public WarningFilter(Akka.TestKit.Internal.StringMatcher.IStringMatcher messageMatcher = null, Akka.TestKit.Internal.StringMatcher.IStringMatcher sourceMatcher = null) { }\n    protected override string FilterDescriptiveName { get; }\n    protected override bool IsMatch(Akka.Event.LogEvent evt) { }\n}\n```\n\n----------------------------------------\n\nTITLE: ClusterShardingExtensionProvider Class Definition in C#\nDESCRIPTION: Defines the extension provider for ClusterSharding, responsible for creating and initializing the ClusterSharding extension for an Akka ActorSystem. It implements the ExtensionIdProvider interface.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Net.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n    [System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})]\n    public sealed class ClusterShardingExtensionProvider : Akka.Actor.ExtensionIdProvider<Akka.Cluster.Sharding.ClusterSharding>\n    {\n        public ClusterShardingExtensionProvider() { }\n        public override Akka.Cluster.Sharding.ClusterSharding CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Swap Operation in C#\nDESCRIPTION: Generic method that conditionally swaps a reference type value based on a provided update function. Returns a tuple containing the swap status, new value, and custom return value.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_268\n\nLANGUAGE: C#\nCODE:\n```\npublic static TReturn ConditionallySwap<T, TReturn>(ref T reference, System.Func<T, System.ValueTuple<bool, T, TReturn>> updateIfTrue)\n    where T :  class { }\n```\n\n----------------------------------------\n\nTITLE: Defining ShardedDaemonProcessExtensionProvider Class in Akka.NET Sharding\nDESCRIPTION: This class provides an extension ID for the ShardedDaemonProcess extension, allowing it to be accessed through the ActorSystem's extension mechanism.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\n    [System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})]\n    public class ShardedDaemonProcessExtensionProvider : Akka.Actor.ExtensionIdProvider<Akka.Cluster.Sharding.ShardedDaemonProcess>\n    {\n        public ShardedDaemonProcessExtensionProvider() { }\n        public override Akka.Cluster.Sharding.ShardedDaemonProcess CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Abstract Query Executor Class Definition\nDESCRIPTION: Abstract base class for executing SQL queries in Akka.NET persistence journal, defining core functionality for event storage and retrieval.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Core.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class AbstractQueryExecutor : Akka.Persistence.Sql.Common.Journal.IJournalQueryExecutor\n{\n    protected const int IsDeletedIndex = 3;\n    protected static readonly string LongTypeName;\n    protected const int ManifestIndex = 4;\n    protected const int OrderingIndex = 7;\n    protected const int PayloadIndex = 5;\n    protected const int PersistenceIdIndex = 0;\n    protected const int SequenceNrIndex = 1;\n    protected Akka.Serialization.Serialization Serialization;\n    protected const int SerializerIdIndex = 6;\n    protected const int TimestampIndex = 2;\n    protected Akka.Persistence.Sql.Common.Journal.ITimestampProvider TimestampProvider;\n}\n```\n\n----------------------------------------\n\nTITLE: SqlSnapshotStore Abstract Class Implementation\nDESCRIPTION: Defines an abstract base class for SQL-based snapshot stores that implements the Akka.NET SnapshotStore interface. It provides methods for loading, saving, and deleting snapshots from SQL databases, while abstracting the database connection creation to derived classes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class SqlSnapshotStore : Akka.Persistence.Snapshot.SnapshotStore, Akka.Actor.IActorStash, Akka.Actor.IWithUnboundedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics>\n{\n    protected SqlSnapshotStore(Akka.Configuration.Config config) { }\n    protected Akka.Event.ILoggingAdapter Log { get; }\n    public abstract Akka.Persistence.Sql.Common.Snapshot.ISnapshotQueryExecutor QueryExecutor { get; }\n    public Akka.Actor.IStash Stash { get; set; }\n    protected abstract System.Data.Common.DbConnection CreateDbConnection(string connectionString);\n    public System.Data.Common.DbConnection CreateDbConnection() { }\n    protected override System.Threading.Tasks.Task DeleteAsync(Akka.Persistence.SnapshotMetadata metadata) { }\n    protected override System.Threading.Tasks.Task DeleteAsync(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria) { }\n    protected virtual string GetConnectionString() { }\n    protected override System.Threading.Tasks.Task<Akka.Persistence.SelectedSnapshot> LoadAsync(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria) { }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n    protected override System.Threading.Tasks.Task SaveAsync(Akka.Persistence.SnapshotMetadata metadata, object snapshot) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Event-Related Classes for Journal Operations in C#\nDESCRIPTION: Defines various event-related classes including JournalEntry for storing event data, EventId for unique identification, and message classes for event replay operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class JournalEntry\n{\n    public readonly bool IsDeleted;\n    public readonly string Manifest;\n    public readonly object Payload;\n    public readonly string PersistenceId;\n    public readonly long SequenceNr;\n    public readonly System.DateTime Timestamp;\n    public JournalEntry(string persistenceId, long sequenceNr, bool isDeleted, string manifest, System.DateTime timestamp, object payload) { }\n}\n\npublic struct EventId\n{\n    public readonly long Id;\n    public readonly string PersistenceId;\n    public readonly long SequenceNr;\n    public EventId(long id, long sequenceNr, string persistenceId) { }\n}\n\npublic sealed class ReplayAllEvents : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IJournalMessage, Akka.Persistence.IJournalRequest, Akka.Persistence.IPersistenceMessage\n{\n    public readonly long FromOffset;\n    public readonly long Max;\n    public readonly Akka.Actor.IActorRef ReplyTo;\n    public readonly long ToOffset;\n    public ReplayAllEvents(long fromOffset, long toOffset, long max, Akka.Actor.IActorRef replyTo) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Static ORSet Factory Methods\nDESCRIPTION: Static factory methods for creating ORSet instances with initial elements.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\npublic class static ORSet\n{\n    public static Akka.DistributedData.ORSet<T> Create<T>(Akka.Cluster.UniqueAddress node, T element) { }\n    public static Akka.DistributedData.ORSet<T> Create<T>(params System.Collections.Generic.KeyValuePair<, >[] elements) { }\n    public static Akka.DistributedData.ORSet<T> Create<T>(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<Akka.Cluster.UniqueAddress, T>> elements) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Other Persistence Interfaces in C#\nDESCRIPTION: These snippets define various interfaces related to persistence in Akka, including IPersistenceMessage, IPersistenceRecovery, IPersistenceStash, IPersistentEnvelope, IPersistentIdentity, and IPersistentRepresentation. These interfaces provide foundational contracts for implementing message handling and persistence strategies.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IPersistenceMessage : Akka.Actor.INoSerializationVerificationNeeded { }\npublic interface IPersistenceRecovery\n{\n    Akka.Persistence.Recovery Recovery { get; }\n}\npublic interface IPersistenceStash : Akka.Actor.IActorStash, Akka.Actor.IWithUnboundedStash, Akka.Actor.IWithUnrestrictedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics>\n{\n    Akka.Persistence.IStashOverflowStrategy InternalStashOverflowStrategy { get; }\n}\npublic interface IPersistentEnvelope\n{\n    object Payload { get; }\n    Akka.Actor.IActorRef Sender { get; }\n    int Size { get; }\n}\npublic interface IPersistentIdentity\n{\n    string JournalPluginId { get; }\n    string PersistenceId { get; }\n    string SnapshotPluginId { get; }\n}\npublic interface IPersistentRepresentation : Akka.Persistence.Serialization.IMessage\n{\n    bool IsDeleted { get; }\n    string Manifest { get; }\n    object Payload { get; }\n    string PersistenceId { get; }\n    Akka.Actor.IActorRef Sender { get; }\n    long SequenceNr { get; }\n    long Timestamp { get; }\n    string WriterGuid { get; }\n    Akka.Persistence.IPersistentRepresentation Update(long sequenceNr, string persistenceId, bool isDeleted, Akka.Actor.IActorRef sender, string writerGuid);\n    Akka.Persistence.IPersistentRepresentation WithManifest(string manifest);\n    Akka.Persistence.IPersistentRepresentation WithPayload(object payload);\n    Akka.Persistence.IPersistentRepresentation WithTimestamp(long timestamp);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing CombinedReadEventAdapter for Akka.NET Persistence\nDESCRIPTION: This class combines multiple event adapters, implementing both read and write event adapter interfaces for Akka.NET persistence journal operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class CombinedReadEventAdapter : Akka.Persistence.Journal.IEventAdapter, Akka.Persistence.Journal.IReadEventAdapter, Akka.Persistence.Journal.IWriteEventAdapter\n{\n    public CombinedReadEventAdapter(System.Collections.Generic.IEnumerable<Akka.Persistence.Journal.IEventAdapter> adapters) { }\n    public System.Collections.Generic.IEnumerable<Akka.Persistence.Journal.IEventAdapter> Adapters { get; }\n    public Akka.Persistence.Journal.IEventSequence FromJournal(object evt, string manifest) { }\n    public string Manifest(object evt) { }\n    public object ToJournal(object evt) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Akka.NET Serialization Error Message\nDESCRIPTION: This snippet shows an example error message that occurs when there's a serialization issue in Akka.NET, typically related to missing serializers for distributed systems.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/deployment/akkacluster-troubleshooting.md#2025-04-16_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nCause: System.Runtime.Serialization.SerializationException:\nFailed to deserialize payload object when deserializing ActorSelectionMessage with payload\n[SerializerId=9, Manifest=A] addressed to [system,distributedPubSubMediator].\nCould not find any internal Akka.NET serializer with Id [9].\nPlease create an issue in our GitHub at [https://github.com/akkadotnet/akka.net].\n```\n\n----------------------------------------\n\nTITLE: Handling Exceptions for Mismatched Assertions\nDESCRIPTION: This snippet defines `AkkaEqualException` which extends `XunitException` to provide error messaging for mismatched values during test assertions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKitXunit2.DotNet.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.TestKit.Xunit2.Internals\n{\n    [System.Runtime.CompilerServices.NullableAttribute(0)]\n    public class AkkaEqualException : Xunit.Sdk.XunitException\n    {\n        public AkkaEqualException(string format = \"\", params object[] args) { }\n        protected AkkaEqualException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n        [return: System.Runtime.CompilerServices.NullableAttribute(1)]\n        public static Akka.TestKit.Xunit2.Internals.AkkaEqualException ForMismatchedValues(object expected, object actual, string format = null, [System.Runtime.CompilerServices.NullableAttribute(1)] params object[] args) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Logger Configuration in Akka.NET\nDESCRIPTION: This example illustrates how to configure a custom logger within an Akka.NET application. It includes the usage of a fully qualified class name in the HOCON configuration to specify the logger.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/logging.md#2025-04-16_snippet_3\n\nLANGUAGE: hocon\nCODE:\n```\nakka {\n    loggers = [\"NameSpace.ClassName, AssemblyName\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Assembly Metadata and Attributes for Akka.NET\nDESCRIPTION: Sets assembly-level attributes for the Akka.NET project, including repository URL, COM visibility, GUID, and target framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.DotNet.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"e438d2c3-1075-4b01-bb84-e9efd3a36691\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETCoreApp,Version=v6.0\", FrameworkDisplayName=\".NET 6.0\")]\n```\n\n----------------------------------------\n\nTITLE: Defining ShardAllocationStrategy Static Class in C#\nDESCRIPTION: A static class providing a factory method for creating a least shard allocation strategy with specified limits.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic class static ShardAllocationStrategy\n{\n    public static Akka.Cluster.Sharding.IShardAllocationStrategy LeastShardAllocationStrategy(int absoluteLimit, double relativeLimit) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Remote Actor References in C# for Akka.NET\nDESCRIPTION: Defines RemoteActorRef class and IRemoteActorRefProvider interface for managing references to remote actors in Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic class RemoteActorRef : Akka.Actor.InternalActorRefBase, Akka.Actor.IActorRefScope, Akka.Remote.IRemoteRef\n{\n    public RemoteActorRef(Akka.Remote.RemoteTransport remote, Akka.Actor.Address localAddressToUse, Akka.Actor.ActorPath path, Akka.Actor.IInternalActorRef parent, Akka.Actor.Props props, Akka.Actor.Deploy deploy) { }\n    public override bool IsLocal { get; }\n}\n\n[Akka.Annotations.InternalApiAttribute()]\npublic interface IRemoteActorRefProvider : Akka.Actor.IActorRefProvider\n{\n    Akka.Actor.IInternalActorRef RemoteDaemon { get; }\n    Akka.Remote.RemoteSettings RemoteSettings { get; }\n    Akka.Actor.IActorRef RemoteWatcher { get; }\n    Akka.Remote.RemoteTransport Transport { get; }\n    // ... (other methods)\n}\n```\n\n----------------------------------------\n\nTITLE: WriteAttempt Activity Class Definition in C#\nDESCRIPTION: Sealed class for handling write attempts in transport layer, containing sender and recipient addresses along with payload data.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class WriteAttempt : Akka.Remote.Transport.Activity\n{\n    public WriteAttempt(Akka.Actor.Address sender, Akka.Actor.Address recipient, Google.Protobuf.ByteString payload) { }\n    public Google.Protobuf.ByteString Payload { get; }\n    public Akka.Actor.Address Recipient { get; }\n    public Akka.Actor.Address Sender { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: TestActorRef Generic Class\nDESCRIPTION: Generic test actor reference implementation that provides access to the underlying actor instance and message handling capabilities.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestActorRef<TActor> : Akka.TestKit.TestActorRefBase<TActor>\n    where TActor : Akka.Actor.ActorBase\n{\n    public TestActorRef(Akka.Actor.ActorSystem system, Akka.Actor.Props actorProps, Akka.Actor.IActorRef supervisor = null, string name = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: IsResponsibleFor Method Implementation (C#)\nDESCRIPTION: Override method that determines if this transport is responsible for handling a specific remote address.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic override bool IsResponsibleFor(Akka.Actor.Address remote) { }\n```\n\n----------------------------------------\n\nTITLE: Deprecated auto-down-unreachable-after Warning - Shell\nDESCRIPTION: Demonstrates the warning message displayed when using the deprecated auto-down-unreachable-after setting in Akka.Cluster. Important for understanding deprecation notifications during upgrades.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/whats-new/akkadotnet-v1.5-upgrade-advisories.md#2025-04-16_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nThe `auto-down-unreachable-after` feature has been deprecated as of Akka.NET v1.5.2 and will be removed in a future version of Akka.NET.\\nThe `keep-majority` split brain resolver will be used instead. See https://getakka.net/articles/cluster/split-brain-resolver.html for more details.\n```\n\n----------------------------------------\n\nTITLE: Defining Assembly Metadata for Akka.NET Cluster Tools\nDESCRIPTION: Assembly attribute declarations that specify metadata for the Akka.NET Cluster Tools assembly, including repository URL, test assembly relationships, and target framework information.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Net.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Tools.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Tools.Tests.MultiNode\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"5cf8a8be-b634-473f-bb01-eba878746bd4\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Implementing EventSequence Static Class for Akka.NET Persistence\nDESCRIPTION: This static class provides factory methods for creating event sequences in Akka.NET persistence, including empty, single, and multiple event sequences.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic class static EventSequence\n{\n    public static Akka.Persistence.Journal.IEventSequence Empty;\n    public static Akka.Persistence.Journal.IEventSequence Create(params object[] events) { }\n    public static Akka.Persistence.Journal.IEventSequence Create(System.Collections.Generic.IEnumerable<object> events) { }\n    public static Akka.Persistence.Journal.IEventSequence Single(object e) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StateChangeEvent Class in C#\nDESCRIPTION: Class that represents a state transition event in a PersistentFSM. Contains the target state identifier and optional timeout configuration for the state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic class StateChangeEvent : Akka.Persistence.Serialization.IMessage\n{\n    public StateChangeEvent(string stateIdentifier, System.Nullable<System.TimeSpan> timeout) { }\n    public string StateIdentifier { get; }\n    public System.Nullable<System.TimeSpan> Timeout { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AkkaProtocolSettings Class in C# for Akka.NET Remote Module\nDESCRIPTION: Defines AkkaProtocolSettings class to manage configuration settings for the Akka protocol in remote communications.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class AkkaProtocolSettings\n{\n    public AkkaProtocolSettings(Akka.Configuration.Config config) { }\n    public System.TimeSpan HandshakeTimeout { get; }\n    public Akka.Configuration.Config TransportFailureDetectorConfig { get; }\n    public string TransportFailureDetectorImplementationClass { get; }\n    public System.TimeSpan TransportHeartBeatInterval { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UnconfirmedDelivery Class in Akka.NET\nDESCRIPTION: The UnconfirmedDelivery class represents a message delivery that hasn't been confirmed yet. It contains the delivery ID, destination actor path, and the message itself.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class UnconfirmedDelivery : System.IEquatable<Akka.Persistence.UnconfirmedDelivery>\n{\n    public UnconfirmedDelivery(long deliveryId, Akka.Actor.ActorPath destination, object message) { }\n    public long DeliveryId { get; }\n    public Akka.Actor.ActorPath Destination { get; }\n    public object Message { get; }\n    public bool Equals(Akka.Persistence.UnconfirmedDelivery other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: ReplicatorSettings Configuration Methods in C#\nDESCRIPTION: Collection of methods for configuring distributed data replicator settings including gossip intervals, pruning, roles and debug options.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_47\n\nLANGUAGE: C#\nCODE:\n```\npublic static Akka.DistributedData.ReplicatorSettings Create(Akka.Configuration.Config config) { }\npublic Akka.DistributedData.ReplicatorSettings WithDispatcher(string dispatcher) { }\npublic Akka.DistributedData.ReplicatorSettings WithDurableKeys(System.Collections.Immutable.IImmutableSet<string> durableKeys) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing MinimalLogger Abstract Class in Akka.NET\nDESCRIPTION: Abstract base class for minimal logger implementations in Akka.NET that extends MinimalActorRef. It provides the basic structure for lightweight logging implementations with abstract methods for logging messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_139\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class MinimalLogger : Akka.Actor.MinimalActorRef\n{\n    protected MinimalLogger() { }\n    public virtual Akka.Actor.ActorPath Path { get; }\n    public virtual Akka.Actor.IActorRefProvider Provider { get; }\n    protected abstract void Log(object message);\n    protected virtual void TellInternal(object message, Akka.Actor.IActorRef sender) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Equality Comparer for Akka.NET Tests\nDESCRIPTION: This snippet defines the AkkaAssertEqualityComparer, which supports type-specific equality assertions within Akka.NET tests. Its constructor can skip type checks or use a custom inner comparator, enhancing flexibility in test assertions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKitXunit2.Net.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.TestKit.Xunit2.Internals\n{\n    public class AkkaAssertEqualityComparer<T> : System.Collections.Generic.IEqualityComparer<T>\n    {\n        public AkkaAssertEqualityComparer(bool skipTypeCheck = False, System.Collections.IEqualityComparer innerComparer = null) { }\n        public bool Equals(T x, T y) { }\n        public int GetHashCode(T obj) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Termination Hook Done Message in Akka.NET\nDESCRIPTION: Defines a singleton message that signals the completion of a termination hook. Used for coordination during actor system shutdown.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_132\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class TerminationHookDone\n{\n    public static Akka.Dispatch.SysMsg.TerminationHookDone Instance { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UdpConnected CommandFailed Event in Akka.NET\nDESCRIPTION: Represents a failure notification when a UDP command fails. Contains a reference to the original command that failed for error handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_174\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class CommandFailed : Akka.IO.UdpConnected.Event\n{\n    public CommandFailed(Akka.IO.UdpConnected.Command cmd) { }\n    public Akka.IO.UdpConnected.Command Cmd { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Atomic State Interface in C#\nDESCRIPTION: Defines the IAtomicState interface for managing atomic access to state with event listeners. This interface provides methods for entering a critical section and performing operations atomically.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_266\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IAtomicState\n{\n    bool HasListeners { get; }\n    void AddListener(System.Action listener);\n    void Enter();\n    System.Threading.Tasks.Task<T> Invoke<T>(System.Func<System.Threading.Tasks.Task<T>> body);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ContainsString Class in C#\nDESCRIPTION: This snippet defines the ContainsString class, which implements the IStringMatcher interface. It is used for string matching in Akka.NET TestKit, specifically for checking if a string contains a certain part.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic class ContainsString : Akka.TestKit.Internal.StringMatcher.IStringMatcher\n{\n    public ContainsString(string part) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Time-Bounded Test Execution in Akka.NET TestKit\nDESCRIPTION: Methods for executing test code within specific time boundaries. These methods enforce timing constraints on test operations and provide both synchronous and asynchronous variants.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\npublic void Within(System.TimeSpan max, System.Action action, System.Nullable<System.TimeSpan> epsilonValue = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic void Within(System.TimeSpan min, System.TimeSpan max, System.Action action, string hint = null, System.Nullable<System.TimeSpan> epsilonValue = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic T Within<T>(System.TimeSpan max, System.Func<T> function, System.Nullable<System.TimeSpan> epsilonValue = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic T Within<T>(System.TimeSpan min, System.TimeSpan max, System.Func<T> function, string hint = null, System.Nullable<System.TimeSpan> epsilonValue = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.Task WithinAsync(System.TimeSpan max, System.Func<System.Threading.Tasks.Task> actionAsync, System.Nullable<System.TimeSpan> epsilonValue = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.Task WithinAsync(System.TimeSpan min, System.TimeSpan max, System.Func<System.Threading.Tasks.Task> actionAsync, string hint = null, System.Nullable<System.TimeSpan> epsilonValue = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.Task<T> WithinAsync<T>(System.TimeSpan max, System.Func<System.Threading.Tasks.Task<T>> function, System.Nullable<System.TimeSpan> epsilonValue = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.Task<T> WithinAsync<T>(System.TimeSpan min, System.TimeSpan max, System.Func<System.Threading.Tasks.Task<T>> function, string hint = null, System.Nullable<System.TimeSpan> epsilonValue = null, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Remote Watcher Implementation in C#\nDESCRIPTION: Implementation of RemoteWatcher class for monitoring remote actors and handling failure detection. Manages watchee-watcher relationships and node monitoring.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class RemoteWatcher : Akka.Actor.UntypedActor, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedMessageQueueSemantics>\n{\n    protected readonly Akka.Event.ILoggingAdapter Log;\n    protected readonly System.Collections.Generic.Dictionary<Akka.Actor.Address, System.Collections.Generic.HashSet<Akka.Actor.IInternalActorRef>> WatcheeByNodes;\n    // ... additional members\n}\n```\n\n----------------------------------------\n\nTITLE: MemberUp Class Definition\nDESCRIPTION: This snippet defines a sealed class `MemberUp` that inherits from `Akka.Cluster.ClusterEvent.MemberStatusChange`.  It represents the event when a cluster member transitions to the 'Up' state. It takes a `Akka.Cluster.Member` object in the constructor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class MemberUp : Akka.Cluster.ClusterEvent.MemberStatusChange\n{\n    public MemberUp(Akka.Cluster.Member member) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SubscribeAck Message Class for Akka Distributed PubSub in C#\nDESCRIPTION: Defines a sealed SubscribeAck message class that acknowledges successful subscription in Akka's distributed publish-subscribe system. Implements IDeadLetterSuppression to prevent routing to dead letter mailbox.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class SubscribeAck : Akka.Event.IDeadLetterSuppression, System.IEquatable<Akka.Cluster.Tools.PublishSubscribe.SubscribeAck>\n{\n    public SubscribeAck(Akka.Cluster.Tools.PublishSubscribe.Subscribe subscribe) { }\n    public Akka.Cluster.Tools.PublishSubscribe.Subscribe Subscribe { get; }\n    public bool Equals(Akka.Cluster.Tools.PublishSubscribe.SubscribeAck other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Conditional Message Reception in Akka.NET TestKit\nDESCRIPTION: Asynchronous methods for receiving messages while conditions hold true. These methods leverage IAsyncEnumerable to provide async streaming of filtered actor messages with timeout and cancellation support.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.AsyncIteratorStateMachineAttribute(typeof(Akka.TestKit.TestKitBase.<ReceiveWhileAsync>d__203<T>))]\npublic System.Collections.Generic.IAsyncEnumerable<T> ReceiveWhileAsync<T>(System.Nullable<System.TimeSpan> max, System.Func<object, T> filter, int msgs = 2147483647, [System.Runtime.CompilerServices.EnumeratorCancellationAttribute()] System.Threading.CancellationToken cancellationToken = null) { }\n[System.Runtime.CompilerServices.AsyncIteratorStateMachineAttribute(typeof(Akka.TestKit.TestKitBase.<ReceiveWhileAsync>d__205<T>))]\npublic System.Collections.Generic.IAsyncEnumerable<T> ReceiveWhileAsync<T>(System.Nullable<System.TimeSpan> max, System.Nullable<System.TimeSpan> idle, System.Func<object, T> filter, int msgs = 2147483647, [System.Runtime.CompilerServices.EnumeratorCancellationAttribute()] System.Threading.CancellationToken cancellationToken = null) { }\n[System.Runtime.CompilerServices.AsyncIteratorStateMachineAttribute(typeof(Akka.TestKit.TestKitBase.<ReceiveWhileAsync>d__207<T>))]\npublic System.Collections.Generic.IAsyncEnumerable<T> ReceiveWhileAsync<T>(System.Func<object, T> filter, System.Nullable<System.TimeSpan> max = null, System.Nullable<System.TimeSpan> idle = null, int msgs = 2147483647, [System.Runtime.CompilerServices.EnumeratorCancellationAttribute()] System.Threading.CancellationToken cancellationToken = null) { }\n[System.Runtime.CompilerServices.AsyncIteratorStateMachineAttribute(typeof(Akka.TestKit.TestKitBase.<ReceiveWhileAsync>d__209<T>))]\npublic System.Collections.Generic.IAsyncEnumerable<T> ReceiveWhileAsync<T>(System.Predicate<T> shouldContinue, System.Nullable<System.TimeSpan> max = null, System.Nullable<System.TimeSpan> idle = null, int msgs = 2147483647, bool shouldIgnoreOtherMessageTypes = True, [System.Runtime.CompilerServices.EnumeratorCancellationAttribute()] System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Message Serialization Functions\nDESCRIPTION: Contains the implementation of ToBytes and FromBytes methods for serializing and deserializing Ping/Pong messages to and from ByteString format.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithgraphs.md#2025-04-16_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\npublic static ByteString ToBytes(IMessage message)\n{\n    var order = ByteOrder.LittleEndian;\n\n    var ping = message as Ping;\n    if (ping != null)\n        return new ByteStringBuilder().PutByte(1).PutInt(ping.Id, order).Result();\n\n    var pong = message as Pong;\n    if (pong != null)\n        return new ByteStringBuilder().PutByte(2).PutInt(pong.Id, order).Result();\n\n    throw new ArgumentException(\"Message is neither Pong nor Ping\", nameof(message));\n}\n\npublic static IMessage FromBytes(ByteString bytes)\n{\n    var order = ByteOrder.LittleEndian;\n    var it = bytes.Iterator();\n    var b = it.GetByte();\n\n    if(b == 1)\n        return new Ping(it.GetInt(order));\n    if(b == 2)\n        return new Pong(it.GetInt(order));\n\n    throw new SystemException($\"Parse error: expected 1|2 got {b}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Require Implementation in Scala\nDESCRIPTION: This Scala code uses the `require` function to enforce a condition. If the condition is not met, an IllegalArgumentException is thrown.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/porting-guide.md#2025-04-16_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nrequire(cost > 0, \"cost must be > 0\")\n```\n\n----------------------------------------\n\nTITLE: IDnsProvider Interface for DNS Provider Implementation\nDESCRIPTION: Defines the contract for DNS providers in Akka.NET with requirements for actor classes, caching, and manager class definition. This interface is implemented by concrete DNS provider implementations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_158\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IDnsProvider\n    {\n        System.Type ActorClass { get; }\n        Akka.IO.DnsBase Cache { get; }\n        System.Type ManagerClass { get; }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining SnapshotMetadata Class in C#\nDESCRIPTION: This snippet defines the SnapshotMetadata class, which represents metadata for a snapshot in Akka.NET persistence.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SnapshotMetadata : System.IEquatable<Akka.Persistence.SnapshotMetadata>\n{\n    public static System.DateTime TimestampNotSpecified;\n    public SnapshotMetadata(string persistenceId, long sequenceNr) { }\n    [Newtonsoft.Json.JsonConstructorAttribute()]\n    public SnapshotMetadata(string persistenceId, long sequenceNr, System.DateTime timestamp) { }\n    public static System.Collections.Generic.IComparer<Akka.Persistence.SnapshotMetadata> Comparer { get; }\n    public string PersistenceId { get; }\n    public long SequenceNr { get; }\n    public System.DateTime Timestamp { get; }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.Persistence.SnapshotMetadata other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Message Dispatcher Base Class\nDESCRIPTION: Abstract base class for message dispatchers in Akka.NET providing core dispatching functionality with methods for scheduling and system message handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_89\n\nLANGUAGE: C#\nCODE:\n```\nprotected void ReportFailure(System.Exception ex) { }\npublic void Schedule(System.Action run) { }\npublic void Schedule(Akka.Dispatch.IRunnable run) { }\n[Akka.Annotations.InternalApiAttribute()]\nprotected abstract void Shutdown();\npublic virtual void SystemDispatch(Akka.Actor.ActorCell cell, Akka.Dispatch.SysMsg.SystemMessage message) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Stop Child Message in Akka.NET\nDESCRIPTION: Defines a message that instructs a parent actor to stop a specific child actor. Carries a reference to the child actor that should be stopped.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_126\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class StopChild\n{\n    public StopChild(Akka.Actor.IActorRef child) { }\n    public Akka.Actor.IActorRef Child { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IWriteConsistency Interface in C#\nDESCRIPTION: This snippet defines the `IWriteConsistency` interface, specifying that implementing classes should provide a `Timeout` property. This interface likely represents a configuration for write operations in a distributed data system, ensuring that writes are performed with a certain level of consistency within the specified timeout period.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\n    public interface IWriteConsistency\n    {\n        System.TimeSpan Timeout { get; }\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Failure Detection in Akka.NET Remote\nDESCRIPTION: Defines classes for failure detection including DeadlineFailureDetector and PhiAccrualFailureDetector, used to monitor the health of remote connections.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class DeadlineFailureDetector : Akka.Remote.FailureDetector\n{\n    public DeadlineFailureDetector(System.TimeSpan acceptableHeartbeatPause, System.TimeSpan heartbeatInterval, Akka.Remote.Clock clock = null) { }\n    public DeadlineFailureDetector(Akka.Configuration.Config config, Akka.Event.EventStream eventStream) { }\n    public override bool IsAvailable { get; }\n    public override bool IsMonitoring { get; }\n    public override void HeartBeat() { }\n}\n\npublic class PhiAccrualFailureDetector : Akka.Remote.FailureDetector\n{\n    public PhiAccrualFailureDetector(double threshold, int maxSampleSize, System.TimeSpan minStdDeviation, System.TimeSpan acceptableHeartbeatPause, System.TimeSpan firstHeartbeatEstimate, Akka.Remote.Clock clock = null) { }\n    public PhiAccrualFailureDetector(Akka.Configuration.Config config, Akka.Event.EventStream ev) { }\n    protected PhiAccrualFailureDetector(Akka.Remote.Clock clock) { }\n    public string Address { get; set; }\n    public override bool IsAvailable { get; }\n    public override bool IsMonitoring { get; }\n    public override void HeartBeat() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Actor with Message Type Declarations\nDESCRIPTION: Example of declaring message types within the actor class for better type safety and documentation of the actor's protocol.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DemoMessagesActor : UntypedActor\n{\n    public class Greeting\n    {\n        public Greeting(string from)\n        {\n            From = from;\n        }\n\n        public string From { get; }\n    }\n\n    public class Goodbye\n    {\n        public static Goodbye Instance = new Goodbye();\n\n        private Goodbye() {}\n    }\n\n    private ILoggingAdapter log = Context.GetLogger();\n\n    protected override void OnReceive(object message)\n    {\n        switch (message)\n        {\n            case Greeting greeting:\n                Sender.Tell($\"I was greeted by {greeting.From}\", Self);\n                break;\n            case Goodbye goodbye:\n                log.Info(\"Someone said goodbye to me.\");\n                break;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NoRouter Base Class in C#\nDESCRIPTION: Base router configuration class that implements no routing behavior. Used as a null object pattern for router configurations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_182\n\nLANGUAGE: C#\nCODE:\n```\npublic class NoRouter : Akka.Routing.RouterConfig\n{\n    protected NoRouter() { }\n    public static Akka.Routing.NoRouter Instance { get; }\n    public override string RouterDispatcher { get; }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override Akka.Actor.ActorBase CreateRouterActor() { }\n    public Akka.Actor.Props Props(Akka.Actor.Props routeeProps) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WeightedRoutees for Load Balancing in Akka.NET\nDESCRIPTION: Defines a class for representing weighted routees in a cluster. This class is used by load balancing routers to distribute messages based on node capacity weights.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic class WeightedRoutees\n{\n    public WeightedRoutees(System.Collections.Immutable.ImmutableArray<Akka.Routing.Routee> routees, Akka.Actor.Address selfAddress, System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, int> weights) { }\n    public bool IsEmpty { get; }\n    public Akka.Routing.Routee this[int value] { get; }\n    public int Total { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Vector Clocks in Akka.NET C#\nDESCRIPTION: This section provides methods for merging, pruning, comparing, and representing vector clocks within Akka clusters, as well as managing nodes and their ordering. The `VectorClock` class ensures consistent event ordering in distributed systems. Dependencies include the Akka.Cluster namespace.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.DotNet.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic Akka.Cluster.VectorClock Merge(Akka.Cluster.VectorClock that) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic Akka.Cluster.VectorClock Prune(Akka.Cluster.VectorClock.Node removedNode) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic override string ToString() { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static bool ==(Akka.Cluster.VectorClock left, Akka.Cluster.VectorClock right) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static bool >(Akka.Cluster.VectorClock left, Akka.Cluster.VectorClock right) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static bool !=(Akka.Cluster.VectorClock left, Akka.Cluster.VectorClock right) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static bool <(Akka.Cluster.VectorClock left, Akka.Cluster.VectorClock right) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class Node : System.IComparable<Akka.Cluster.VectorClock.Node> { public Node(string value) { } public int CompareTo(Akka.Cluster.VectorClock.Node other) { } public static Akka.Cluster.VectorClock.Node Create(string name) { } public override bool Equals(object obj) { } public static Akka.Cluster.VectorClock.Node FromHash(string hash) { } public override int GetHashCode() { } public override string ToString() { } }\n```\n\n----------------------------------------\n\nTITLE: Implementing Weighted Routees for Load Balancing\nDESCRIPTION: Internal API class for managing weighted routees in Akka.NET cluster routing. Handles routing weight distribution across cluster nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Core.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class WeightedRoutees\n{\n    public WeightedRoutees(System.Collections.Immutable.ImmutableArray<Akka.Routing.Routee> routees, Akka.Actor.Address selfAddress, System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, int> weights) { }\n    public bool IsEmpty { get; }\n    public Akka.Routing.Routee this[int value] { get; }\n    public int Total { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Internal FSM Support Interface in C#\nDESCRIPTION: This internal interface provides support for testing Finite State Machine (FSM) actors in Akka.NET. It includes properties and methods for managing FSM state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_61\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic interface IInternalSupportsTestFSMRef<TState, TData>\n{\n    bool IsStateTimerActive { get; }\n    void ApplyState(Akka.Actor.FSMBase.State<TState, TData> upcomingState);\n}\n```\n\n----------------------------------------\n\nTITLE: RandomLogic Class in Akka.NET Routing\nDESCRIPTION: Implements a routing logic that selects a random routee from the available routees. This is used by RandomPool and RandomGroup routers to distribute messages randomly.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_183\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class RandomLogic : Akka.Routing.RoutingLogic\n{\n    public RandomLogic() { }\n    public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HoconRoot Class in C#\nDESCRIPTION: The HoconRoot class represents the root of a HOCON configuration tree. It contains a value and optional substitutions that can be resolved during configuration processing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_68\n\nLANGUAGE: C#\nCODE:\n```\npublic class HoconRoot\n{\n    protected HoconRoot() { }\n    public HoconRoot(Akka.Configuration.Hocon.HoconValue value, System.Collections.Generic.IEnumerable<Akka.Configuration.Hocon.HoconSubstitution> substitutions) { }\n    public HoconRoot(Akka.Configuration.Hocon.HoconValue value) { }\n    public System.Collections.Generic.IEnumerable<Akka.Configuration.Hocon.HoconSubstitution> Substitutions { get; }\n    public Akka.Configuration.Hocon.HoconValue Value { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Event Adapter and Recovery Interfaces in Akka.NET\nDESCRIPTION: Defines interfaces for event adaptation (IEventAdapter, IReadEventAdapter, IWriteEventAdapter) and async recovery (IAsyncRecovery) operations in Akka.NET persistence.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_48\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IAsyncRecovery\n{\n    System.Threading.Tasks.Task<long> ReadHighestSequenceNrAsync(string persistenceId, long fromSequenceNr);\n    System.Threading.Tasks.Task ReplayMessagesAsync(Akka.Actor.IActorContext context, string persistenceId, long fromSequenceNr, long toSequenceNr, long max, System.Action<Akka.Persistence.IPersistentRepresentation> recoveryCallback);\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IEmptyEventSequence : Akka.Persistence.Journal.IEventSequence { }\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IEventAdapter : Akka.Persistence.Journal.IReadEventAdapter, Akka.Persistence.Journal.IWriteEventAdapter { }\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IEventSequence\n{\n    System.Collections.Generic.IEnumerable<object> Events { get; }\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IReadEventAdapter\n{\n    Akka.Persistence.Journal.IEventSequence FromJournal(object evt, string manifest);\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IWriteEventAdapter\n{\n    string Manifest(object evt);\n    object ToJournal(object evt);\n}\n```\n\n----------------------------------------\n\nTITLE: DeleteMessagesSuccess Class Definition in Akka.Persistence\nDESCRIPTION: Class representing a successful deletion of messages from the journal, containing the sequence number up to which messages were deleted.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DeleteMessagesSuccess : System.IEquatable<Akka.Persistence.DeleteMessagesSuccess>\n{\n    public DeleteMessagesSuccess(long toSequenceNr) { }\n    public long ToSequenceNr { get; }\n    public bool Equals(Akka.Persistence.DeleteMessagesSuccess other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DeleteSnapshots Class in C#\nDESCRIPTION: Defines a class for the delete snapshots request in Akka Persistence, detailing the persistence ID and criteria for which snapshots to delete. Implements multiple interfaces to ensure proper message handling and comparison.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class DeleteSnapshots : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage, Akka.Persistence.ISnapshotRequest, System.IEquatable<Akka.Persistence.DeleteSnapshots>\n{\n    public DeleteSnapshots(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria) { }\n    public Akka.Persistence.SnapshotSelectionCriteria Criteria { get; }\n    public string PersistenceId { get; }\n    public bool Equals(Akka.Persistence.DeleteSnapshots other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: RootActorPath Definition in Akka.NET (C#)\nDESCRIPTION: Represents the root path in an actor hierarchy, serving as the starting point for all actor paths in a system. Contains an address and optional name.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class RootActorPath : Akka.Actor.ActorPath\n{\n    public RootActorPath(Akka.Actor.Address address, string name = \"\") { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NoRouter Class in C#\nDESCRIPTION: Defines a router configuration that doesn't perform any routing, acting as a placeholder or default option.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_205\n\nLANGUAGE: C#\nCODE:\n```\npublic class NoRouter : Akka.Routing.RouterConfig\n{\n    protected NoRouter() { }\n    public static Akka.Routing.NoRouter Instance { get; }\n    public override string RouterDispatcher { get; }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override Akka.Actor.ActorBase CreateRouterActor() { }\n    public Akka.Actor.Props Props(Akka.Actor.Props routeeProps) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n    public class NoRouterSurrogate : Akka.Util.ISurrogate\n    {\n        public NoRouterSurrogate() { }\n        public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring CallingThreadDispatcherConfigurator\nDESCRIPTION: This class provides a configuration setup for the CallingThreadDispatcher by overriding the Dispatcher method to return customized dispatcher objects. It needs configuration data and dispatcher prerequisites.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class CallingThreadDispatcherConfigurator : Akka.Dispatch.MessageDispatcherConfigurator\n{\n    public CallingThreadDispatcherConfigurator(Akka.Configuration.Config config, Akka.Dispatch.IDispatcherPrerequisites prerequisites) { }\n    public override Akka.Dispatch.MessageDispatcher Dispatcher() { }\n}\n```\n\n----------------------------------------\n\nTITLE: SQL Snapshot Query Configuration Class in C#\nDESCRIPTION: Configuration class for SQL snapshot operations defining table and column names, timeout settings, and isolation levels. Includes support for sequential access and serialization options.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\npublic class QueryConfiguration\n{\n    public readonly string DefaultSerializer;\n    public readonly string ManifestColumnName;\n    public readonly string PayloadColumnName;\n    public readonly string PersistenceIdColumnName;\n    public readonly string SchemaName;\n    public readonly string SequenceNrColumnName;\n    public readonly string SerializerIdColumnName;\n    public readonly string SnapshotTableName;\n    public readonly TimeSpan Timeout;\n    public readonly string TimestampColumnName;\n    public string FullSnapshotTableName { get; }\n    public System.Data.IsolationLevel ReadIsolationLevel { get; }\n    public bool UseSequentialAccess { get; }\n    public System.Data.IsolationLevel WriteIsolationLevel { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: DataDeleted Exception Class for Data Deletion Responses\nDESCRIPTION: Exception class used as a response when data has been deleted from the distributed store. It implements multiple response interfaces and provides methods to check the status of the deletion operation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DataDeleted : System.Exception, Akka.Actor.INoSerializationVerificationNeeded, Akka.DistributedData.IDeleteResponse, Akka.DistributedData.IGetResponse, Akka.DistributedData.IUpdateResponse, System.IEquatable<Akka.DistributedData.DataDeleted>\n{\n    public DataDeleted(Akka.DistributedData.IKey key, object request = null) { }\n    public bool AlreadyDeleted { get; }\n    public bool IsFailure { get; }\n    public bool IsFound { get; }\n    public bool IsSuccessful { get; }\n    public Akka.DistributedData.IKey Key { get; }\n    public object Request { get; }\n    public bool Equals(Akka.DistributedData.DataDeleted other) { }\n    public override bool Equals(object obj) { }\n    public T Get<T>(Akka.DistributedData.IKey<T> key)\n        where T : Akka.DistributedData.IReplicatedData { }\n    public override int GetHashCode() { }\n    public void ThrowOnFailure() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LWWDictionaryKey<TKey, TValue> Class in C#\nDESCRIPTION: Extends the Key<T> class for Last-Write-Wins dictionaries, providing strong typing for the key and value types used in the dictionary.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class LWWDictionaryKey<TKey, TValue> : Akka.DistributedData.Key<Akka.DistributedData.LWWDictionary<TKey, TValue>>\n{\n    public LWWDictionaryKey(string id) { }\n    public System.Type KeyType { get; }\n    public System.Type ValueType { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Keep Majority Strategy in Akka.NET\nDESCRIPTION: Configuration for the keep-majority strategy (default as of Akka.NET v1.5.2+) which downs the part of the cluster that sees fewer nodes. It's suitable for clusters that can grow or shrink dynamically.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/split-brain-resolver.md#2025-04-16_snippet_4\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster.split-brain-resolver {\n  active-strategy = keep-majority\n\n  keep-majority {\n    # if the 'role' is defined the decision is based only on members with that 'role'\n    role = \"\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Get Operation for Distributed Data\nDESCRIPTION: Defines a get request with key, consistency, and optional request context for retrieving distributed data\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\npublic Get(Akka.DistributedData.IKey key, Akka.DistributedData.IReadConsistency consistency, object request = null) { }\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Unhandled Messages in Akka.NET\nDESCRIPTION: This example shows how to capture unhandled messages in Akka.NET. It creates a DumbActor that doesn't handle any messages and an UnhandledMessagesMonitorActor to capture and print unhandled messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/event-bus.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DumbActor : ReceiveActor {  }\n\npublic class UnhandledMessagesMonitorActor : ReceiveActor\n{\n    public UnhandledMessagesMonitorActor()\n    {\n        Receive<UnhandledMessage>(Console.WriteLine);\n    }\n}\n\nusing (var system = ActorSystem.Create(\"MySystem\"))\n{\n    var dumbActor = system.ActorOf<DumbActor>();\n    var monitorActor = system.ActorOf<UnhandledMessagesMonitorActor>();\n    \n    // Subscribe to messages of type UnhandledMessage\n    system.EventStream.Subscribe(monitorActor, typeof(UnhandledMessage));\n    \n    // try sending a message to actor which it doesn't understand\n    dumbActor.Tell(\"Hello\");\n    \n    Console.ReadLine();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IRunnable Interface in C#\nDESCRIPTION: Interface extending IThreadPoolWorkItem that defines the contract for runnable tasks in Akka.NET's dispatcher system, allowing them to be executed by the thread pool.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_92\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IRunnable : System.Threading.IThreadPoolWorkItem\n{\n    void Run();\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Actor Creation Pattern in C# Akka.NET\nDESCRIPTION: This code demonstrates the incorrect pattern that triggers the AK1008 warning. The FirstActor creates a new actor using Context.System.ActorOf<T>() which places the new actor under the \"/user\" guardian rather than as a child of FirstActor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK1008.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing Akka.Actor;\n\npublic sealed class FirstActor : ReceiveActor\n{\n    public FirstActor()\n    {\n        Context.System.ActorOf<MyActor>(\"newActor\");\n    }\n}\n\npublic sealed class MyActor : ReceiveActor\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterShardingStats Class in C#\nDESCRIPTION: Defines the ClusterShardingStats class to represent statistics for cluster sharding regions. Implements IClusterShardingSerializable and IEquatable interfaces.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Net.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterShardingStats : Akka.Cluster.Sharding.IClusterShardingSerializable, System.IEquatable<Akka.Cluster.Sharding.ClusterShardingStats>\n{\n    public readonly System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, Akka.Cluster.Sharding.ShardRegionStats> Regions;\n    public ClusterShardingStats(System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, Akka.Cluster.Sharding.ShardRegionStats> regions) { }\n    // Additional methods...\n}\n```\n\n----------------------------------------\n\nTITLE: Remote Serialization Classes in C#\nDESCRIPTION: Collection of serializer implementations for various message types in Akka.NET remote communication including system messages, primitives and protobuf.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic class DaemonMsgCreateSerializer : Akka.Serialization.Serializer\n{\n    public DaemonMsgCreateSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override bool IncludeManifest { get; }\n    public override object FromBinary(byte[] bytes, System.Type type) { }\n    public override byte[] ToBinary(object obj) { }\n}\n\npublic sealed class MiscMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public MiscMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object obj) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Using actorOf and actorOf2 Shorthand Functions\nDESCRIPTION: Demonstrates using the shorthand functions actorOf and actorOf2 for defining actor behavior. actorOf takes a function with just the message parameter, while actorOf2 takes a function with both the mailbox and message parameters.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.FSharp/README.md#2025-04-16_snippet_2\n\nLANGUAGE: F#\nCODE:\n```\nlet handleMessage (mailbox: Actor<'a>) msg =\n    match msg with\n    | Some x -> printf \"%A\" x\n    | None -> ()\n\nlet aref = spawn system \"my-actor\" (actorOf2 handleMessage)\nlet blackHole = spawn system \"black-hole\" (actorOf (fun msg -> ()))\n```\n\n----------------------------------------\n\nTITLE: Address Class Implementation in C#\nDESCRIPTION: Implementation of the Akka.NET Address class that represents actor system addresses. Includes methods for parsing, comparison, and manipulation of actor addresses.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Address : Akka.Util.ISurrogated, System.ICloneable, System.IComparable, System.IComparable<Akka.Actor.Address>, System.IEquatable<Akka.Actor.Address>\n{\n    public static readonly Akka.Actor.Address AllSystems;\n    public static readonly System.Collections.Generic.IComparer<Akka.Actor.Address> Comparer;\n    public Address(string protocol, string system, string host = null, System.Nullable<int> port = null) { }\n    public bool HasGlobalScope { get; }\n    public bool HasLocalScope { get; }\n    public string Host { get; }\n    public System.Nullable<int> Port { get; }\n    public string Protocol { get; }\n    public string System { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ISubscriptionCommand Interface in C#\nDESCRIPTION: An obsolete interface marker for subscription commands. Marked as not implemented to indicate that query functionality is not available.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\n[System.ObsoleteAttribute(\"Query is not implemented.\")]\npublic interface ISubscriptionCommand { }\n```\n\n----------------------------------------\n\nTITLE: Basic DotNetty Batching Configuration in HOCON\nDESCRIPTION: Basic HOCON configuration for DotNetty TCP batching settings, showing the enabled flag and max-pending-writes parameter.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/remoting/performance.md#2025-04-16_snippet_1\n\nLANGUAGE: hocon\nCODE:\n```\nakka.remote.dot-netty.tcp{\n      batching{\n\n        enabled = true\n\n        max-pending-writes = 30\n      }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ConsistentHashableEnvelope\nDESCRIPTION: Example of wrapping a message in ConsistentHashableEnvelope for consistent hash routing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\npublic class SomeMessage\n{\n   public Guid GroupID { get; set; }\n}\n\nvar originalMsg = new SomeMessage { GroupID = Guid.NewGuid(); };\nvar msg = new ConsistentHashableEnvelope(originalMsg, originalMsg.GroupID);\n```\n\n----------------------------------------\n\nTITLE: Implementing LeaseProviderExtensionProvider in C#\nDESCRIPTION: Extension provider that creates instances of the LeaseProvider extension for actor systems. Integrates with Akka.NET's extension system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.Core.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class LeaseProviderExtensionProvider : Akka.Actor.ExtensionIdProvider<Akka.Coordination.LeaseProvider>\n{\n    public LeaseProviderExtensionProvider() { }\n    public override Akka.Coordination.LeaseProvider CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: DeleteSnapshot Class Definition in Akka.Persistence\nDESCRIPTION: A message class used to request deletion of a snapshot. This class encapsulates the metadata of the snapshot to be deleted and is used to communicate with the snapshot store.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DeleteSnapshot : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage, Akka.Persistence.ISnapshotRequest, System.IEquatable<Akka.Persistence.DeleteSnapshot>\n{\n    public DeleteSnapshot(Akka.Persistence.SnapshotMetadata metadata) { }\n    public Akka.Persistence.SnapshotMetadata Metadata { get; }\n```\n\n----------------------------------------\n\nTITLE: Defining Snapshot Message Interfaces in Akka.NET Persistence\nDESCRIPTION: This code defines three interfaces related to snapshot messages in Akka.NET persistence: `ISnapshotMessage`, `ISnapshotRequest`, and `ISnapshotResponse`. These interfaces are used to mark messages as being related to snapshot operations within the Akka.Persistence framework and inherit from `Akka.Actor.INoSerializationVerificationNeeded` and `Akka.Persistence.IPersistenceMessage`.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface ISnapshotMessage : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage { }\npublic interface ISnapshotRequest : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage { }\npublic interface ISnapshotResponse : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ShardRegionStats Class in C#\nDESCRIPTION: Defines a sealed class ShardRegionStats that implements IClusterShardingSerializable and IEquatable interfaces. Contains stats and failed shards information for a shard region.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ShardRegionStats : Akka.Cluster.Sharding.IClusterShardingSerializable, System.IEquatable<Akka.Cluster.Sharding.ShardRegionStats>\n{\n    public readonly System.Collections.Immutable.IImmutableSet<string> Failed;\n    public readonly System.Collections.Immutable.IImmutableDictionary<string, int> Stats;\n    [System.ObsoleteAttribute()]\n    public ShardRegionStats(System.Collections.Immutable.IImmutableDictionary<string, int> stats) { }\n    public ShardRegionStats(System.Collections.Immutable.IImmutableDictionary<string, int> stats, System.Collections.Immutable.IImmutableSet<string> failed) { }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.Cluster.Sharding.ShardRegionStats other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterMetricsMessageSerializer in C#\nDESCRIPTION: Defines a serializer for cluster metrics messages, extending SerializerWithStringManifest. It includes methods for binary serialization and deserialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Core.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterMetricsMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public ClusterMetricsMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object o) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Aggregate Discovery with Multiple Methods\nDESCRIPTION: HOCON configuration for setting up Aggregate discovery that tries multiple discovery methods in sequence (DNS followed by Configuration).\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/discovery/index.md#2025-04-16_snippet_5\n\nLANGUAGE: hocon\nCODE:\n```\nakka {\n  discovery {\n    method = aggregate\n    aggregate {\n      discovery-methods = [\"akka-dns\", \"config\"]\n    }\n    config {\n      services {\n        service1 {\n          endpoints [\n              \"host1:1233\",\n              \"host2:1234\"\n          ]\n        }\n      }\n    }\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating HashCodeMessageExtractor Abstract Class in C#\nDESCRIPTION: Defines an abstract HashCodeMessageExtractor class implementing IMessageExtractor. Provides methods for entity ID extraction and shard ID calculation based on hash codes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Net.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class HashCodeMessageExtractor : Akka.Cluster.Sharding.IMessageExtractor\n{\n    public readonly int MaxNumberOfShards;\n    protected HashCodeMessageExtractor(int maxNumberOfShards) { }\n    public static Akka.Cluster.Sharding.HashCodeMessageExtractor Create(int maxNumberOfShards, System.Func<object, string> entityIdExtractor, System.Func<object, object> messageExtractor = null) { }\n    public abstract string EntityId(object message);\n    public virtual object EntityMessage(object message) { }\n    public virtual string ShardId(string entityId, object messageHint = null) { }\n    // Additional methods...\n}\n```\n\n----------------------------------------\n\nTITLE: ListenerMessage Abstract Class in Akka.NET Routing\nDESCRIPTION: Defines an abstract base class for all listener-related messages in the routing system. Serves as a marker class for categorizing message types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_178\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ListenerMessage\n{\n    protected ListenerMessage() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterSingleton Extension in C#\nDESCRIPTION: Implements the ClusterSingleton extension for Akka.NET, providing functionality for managing singleton actors across a cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Core.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.DoNotInheritAttribute()]\npublic class ClusterSingleton : Akka.Actor.IExtension\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Try<T> Class for Error Handling\nDESCRIPTION: A class implementing the Try monad pattern for error handling. It encapsulates either a successful result or an exception, providing methods to safely transform and compose operations that might fail.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_220\n\nLANGUAGE: C#\nCODE:\n```\npublic class Try<T>\n{\n    public Try(T success) { }\n    public Try(System.Exception failure) { }\n    public Akka.Util.Option<System.Exception> Failure { get; }\n    public bool IsSuccess { get; }\n    public Akka.Util.Option<T> Success { get; }\n    public static Akka.Util.Try<T> From(System.Func<T> func) { }\n    public T Get() { }\n    public Akka.Util.Try<T> GetOrElse(System.Func<T> fallback) { }\n    public Akka.Util.Try<T> OrElse(Akka.Util.Try<T> @default) { }\n    public Akka.Util.Try<T> Recover(System.Action<System.Exception> failureHandler) { }\n    public Akka.Util.Try<T> RecoverWith(System.Func<System.Exception, Akka.Util.Try<T>> failureHandler) { }\n    public static Akka.Util.Try<T> op_Implicit(T value) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Ordering Enum for VersionVector in C#\nDESCRIPTION: This snippet defines an Ordering enum used in the VersionVector class to represent different ordering states between version vectors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_54\n\nLANGUAGE: C#\nCODE:\n```\npublic enum Ordering\n{\n    After = 0,\n    Before = 1,\n    Same = 2,\n    Concurrent = 3,\n    FullOrder = 4,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LogFilterType and LogLevel Enumerations in C#\nDESCRIPTION: Enumerations for log filtering and severity levels in Akka.NET. LogFilterType defines whether filtering applies to the log source or content, while LogLevel defines the standard logging levels from debug to error.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_145\n\nLANGUAGE: C#\nCODE:\n```\npublic enum LogFilterType\n{\n    Source = 0,\n    Content = 1,\n}\n\npublic enum LogLevel\n{\n    DebugLevel = 0,\n    InfoLevel = 1,\n    WarningLevel = 2,\n    ErrorLevel = 3,\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Equals Method for DeleteSnapshot\nDESCRIPTION: This snippet overrides the `Equals` method inherited from the `object` class for the `DeleteSnapshot` class. This allows for comparing a `DeleteSnapshot` object with any other object to determine equality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\n\"public override bool Equals(object obj) { }\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Remote Actor References in Akka.NET\nDESCRIPTION: Defines RemoteActorRef class to represent and manage references to actors in remote systems, including handling of remote paths and deployments.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic class RemoteActorRef : Akka.Actor.InternalActorRefBase, Akka.Actor.IActorRefScope, Akka.Remote.IRemoteRef\n{\n    public RemoteActorRef(Akka.Remote.RemoteTransport remote, Akka.Actor.Address localAddressToUse, Akka.Actor.ActorPath path, Akka.Actor.IInternalActorRef parent, Akka.Actor.Props props, Akka.Actor.Deploy deploy) { }\n    public override bool IsLocal { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IInitializableActor Interface in C#\nDESCRIPTION: Interface for actors that require initialization after construction but before message processing begins.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_55\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IInitializableActor\n{\n    void Init();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterClientMessageSerializer in C#\nDESCRIPTION: Defines a class ClusterClientMessageSerializer that extends SerializerWithStringManifest. It handles serialization and deserialization of cluster client messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterClientMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public ClusterClientMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object o) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Static LWWDictionary Factory Methods in C#\nDESCRIPTION: Provides static factory methods for creating LWWDictionary instances with different initialization approaches, including from key-value pairs and collections.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic class static LWWDictionary\n{\n    public static Akka.DistributedData.LWWDictionary<TKey, TValue> Create<TKey, TValue>(Akka.Cluster.UniqueAddress node, TKey key, TValue value, Akka.DistributedData.Clock<TValue> clock = null) { }\n    public static Akka.DistributedData.LWWDictionary<TKey, TValue> Create<TKey, TValue>(params System.ValueTuple<, , >[] elements) { }\n    public static Akka.DistributedData.LWWDictionary<TKey, TValue> Create<TKey, TValue>(System.Collections.Generic.IEnumerable<System.ValueTuple<Akka.Cluster.UniqueAddress, TKey, TValue>> elements, Akka.DistributedData.Clock<TValue> clock = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AkkaProtocolSettings Class in C# for Akka.NET Remote Module\nDESCRIPTION: Defines AkkaProtocolSettings class to manage configuration settings for the Akka protocol in remote actor systems.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class AkkaProtocolSettings\n{\n    public AkkaProtocolSettings(Akka.Configuration.Config config) { }\n    public System.TimeSpan HandshakeTimeout { get; }\n    public Akka.Configuration.Config TransportFailureDetectorConfig { get; }\n    public string TransportFailureDetectorImplementationClass { get; }\n    public System.TimeSpan TransportHeartBeatInterval { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: TestKit Assertion Interface Implementation\nDESCRIPTION: Interface definition for TestKit assertions providing methods for comparing values and asserting conditions in tests.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ITestKitAssertions\n{\n    void AssertEqual<T>(T expected, T actual, string format = \"\", params object[] args);\n    void AssertEqual<T>(T expected, T actual, System.Func<T, T, bool> comparer, string format = \"\", params object[] args);\n    void AssertFalse(bool condition, string format = \"\", params object[] args);\n    void AssertTrue(bool condition, string format = \"\", params object[] args);\n    void Fail(string format = \"\", params object[] args);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Association Events for Remote Actor Systems\nDESCRIPTION: Defines various association events (Associated, Disassociated, Error) to handle lifecycle events in remote actor communications.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class AssociatedEvent : Akka.Remote.AssociationEvent\n{\n    public AssociatedEvent(Akka.Actor.Address localAddress, Akka.Actor.Address remoteAddress, bool inbound) { }\n    public override bool IsInbound { get; set; }\n    public override Akka.Actor.Address LocalAddress { get; set; }\n    public override Akka.Actor.Address RemoteAddress { get; set; }\n    public override Akka.Event.LogLevel LogLevel() { }\n}\n\npublic sealed class DisassociatedEvent : Akka.Remote.AssociationEvent\n{\n    public DisassociatedEvent(Akka.Actor.Address localAddress, Akka.Actor.Address remoteAddress, bool inbound) { }\n    public override bool IsInbound { get; set; }\n    public override Akka.Actor.Address LocalAddress { get; set; }\n    public override Akka.Actor.Address RemoteAddress { get; set; }\n    public override Akka.Event.LogLevel LogLevel() { }\n}\n\npublic sealed class AssociationErrorEvent : Akka.Remote.AssociationEvent\n{\n    public AssociationErrorEvent(System.Exception cause, Akka.Actor.Address localAddress, Akka.Actor.Address remoteAddress, bool inbound, Akka.Event.LogLevel level) { }\n    public System.Exception Cause { get; }\n    public override bool IsInbound { get; set; }\n    public override Akka.Actor.Address LocalAddress { get; set; }\n    public override Akka.Actor.Address RemoteAddress { get; set; }\n    public override Akka.Event.LogLevel LogLevel() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Extractor Definition in Scala\nDESCRIPTION: This Scala code defines a trait `User` and two case classes, `FreeUser` and `PremiumUser`, that implement the trait.  It also defines companion objects with `unapply` methods, which act as extractors, allowing pattern matching based on the user type.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/porting-guide.md#2025-04-16_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ntrait User {\n  def name: String\n}\nclass FreeUser(val name: String) extends User\nclass PremiumUser(val name: String) extends User\n\nobject FreeUser {\n  def unapply(user: FreeUser): Option[String] = Some(user.name)\n}\nobject PremiumUser {\n  def unapply(user: PremiumUser): Option[String] = Some(user.name)\n}\n\n// using\nval user: User = new PremiumUser(\"Daniel\")\nuser match {\n  case FreeUser(name) => \"Hello \" + name\n  case PremiumUser(name) => \"Welcome back, dear \" + name\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BatchingSqlJournal for Batched SQL Operations\nDESCRIPTION: Defines an abstract class BatchingSqlJournal<TConnection, TCommand> that extends WriteJournalBase. It provides methods for batched SQL operations and handling various journal requests.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class BatchingSqlJournal<TConnection, TCommand> : Akka.Persistence.Journal.WriteJournalBase\n    where TConnection : System.Data.Common.DbConnection\n    where TCommand : System.Data.Common.DbCommand\n{\n    protected readonly bool CanPublish;\n    protected const int IsDeletedIndex = 3;\n    protected readonly Akka.Event.ILoggingAdapter Log;\n    protected const int ManifestIndex = 4;\n    protected const int OrderingIndex = 7;\n    protected const int PayloadIndex = 5;\n    protected const int PersistenceIdIndex = 0;\n    protected const int SequenceNrIndex = 1;\n    protected const int SerializerIdIndex = 6;\n    protected const int TimestampIndex = 2;\n    protected BatchingSqlJournal(Akka.Persistence.Sql.Common.Journal.BatchingSqlJournalSetup setup) { }\n    // ... (other properties and methods)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UdpConnected Connect Command in Akka.NET\nDESCRIPTION: Command to establish a UDP connection with specified endpoints. Takes an actor handler reference, remote address, optional local address, and socket options for configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_175\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Connect : Akka.IO.UdpConnected.Command\n{\n    public Connect(Akka.Actor.IActorRef handler, System.Net.EndPoint remoteAddress, System.Net.EndPoint localAddress = null, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options = null) { }\n    public Akka.Actor.IActorRef Handler { get; }\n    public System.Net.EndPoint LocalAddress { get; }\n    public System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> Options { get; }\n    public System.Net.EndPoint RemoteAddress { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Adaptive Load Balancing Pool Router in C#\nDESCRIPTION: Shows how to create an adaptive load balancing pool router in C# code.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-metrics.md#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n[!code-csharp[RouterInCodeSample](../../../src/core/Akka.Docs.Tests/Cluster.Metrics/RouterInCodeSample.cs?name=RouterInCodeSample2)]\n```\n\n----------------------------------------\n\nTITLE: Implementing Batching SQL Journal Setup for Akka.NET Persistence\nDESCRIPTION: Defines an abstract class for setting up batching SQL journals, including configuration options for connection string, batch sizes, isolation levels, and other journal-related settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class BatchingSqlJournalSetup\n{\n    protected BatchingSqlJournalSetup(Akka.Configuration.Config config, Akka.Persistence.Sql.Common.Journal.QueryConfiguration namingConventions) { }\n    // ... (additional constructors and properties)\n}\n```\n\n----------------------------------------\n\nTITLE: RootGuardianSupervisor Implementation in Akka.NET (C#)\nDESCRIPTION: Minimal actor reference implementation that supervises the root guardian actor. Handles system messages and termination of the actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_45\n\nLANGUAGE: C#\nCODE:\n```\npublic class RootGuardianSupervisor : Akka.Actor.MinimalActorRef\n{\n    public RootGuardianSupervisor(Akka.Actor.RootActorPath root, Akka.Actor.IActorRefProvider provider, System.Threading.Tasks.TaskCompletionSource<Akka.Actor.Status> terminationPromise, Akka.Event.ILoggingAdapter log) { }\n    public System.Exception CauseOfTermination { get; }\n    public override Akka.Actor.ActorPath Path { get; }\n    public override Akka.Actor.IActorRefProvider Provider { get; }\n    public override void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage systemMessage) { }\n    public override void Stop() { }\n    protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing InterlockedSpin Static Class in C#\nDESCRIPTION: Utility methods for thread-safe operations on reference types using spinning and interlocked operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_248\n\nLANGUAGE: C#\nCODE:\n```\npublic class static InterlockedSpin\n{\n    public static TReturn ConditionallySwap<T, TReturn>(ref T reference, System.Func<T, System.ValueTuple<bool, T, TReturn>> updateIfTrue)\n        where T :  class { }\n    public static T Swap<T>(ref T reference, System.Func<T, T> updater)\n        where T :  class { }\n}\n```\n\n----------------------------------------\n\nTITLE: Abstract Write Journal Base in C#\nDESCRIPTION: Base class for implementing journal writers with methods for adapting and preparing persistent representations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_46\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class WriteJournalBase : Akka.Actor.ActorBase\n{\n    protected WriteJournalBase() { }\n    [Akka.Annotations.InternalApiAttribute()]\n    protected System.Collections.Generic.IEnumerable<Akka.Persistence.IPersistentRepresentation> AdaptFromJournal(Akka.Persistence.IPersistentRepresentation representation) { }\n    protected Akka.Persistence.IPersistentRepresentation AdaptToJournal(Akka.Persistence.IPersistentRepresentation representation) { }\n    protected System.Collections.Generic.IEnumerable<Akka.Persistence.AtomicWrite> PreparePersistentBatch(System.Collections.Generic.IEnumerable<Akka.Persistence.IPersistentEnvelope> resequenceables) { }\n}\n```\n\n----------------------------------------\n\nTITLE: LeaseProvider Class for Extension System\nDESCRIPTION: Implements the IExtension interface for the Akka actor system, providing factory methods for creating lease instances. It includes methods for obtaining configuration and lease instances based on specified parameters.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.Net.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class LeaseProvider : Akka.Actor.IExtension\n{\n    public LeaseProvider(Akka.Actor.ExtendedActorSystem system) { }\n    public static Akka.Configuration.Config DefaultConfig() { }\n    public static Akka.Coordination.LeaseProvider Get(Akka.Actor.ActorSystem system) { }\n    public Akka.Coordination.Lease GetLease(string leaseName, string configPath, string ownerName) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Hocon Element Interface Definition in C#\nDESCRIPTION: Interface defining methods for Hocon configuration elements, providing capabilities to check element types and retrieve values as arrays or strings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_78\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IHoconElement\n{\n    System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray();\n    string GetString();\n    bool IsArray();\n    bool IsString();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TerminatedChildrenContainer Class in C#\nDESCRIPTION: Container for child actors in terminated state. Extends EmptyChildrenContainer and provides appropriate behavior for terminated actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_61\n\nLANGUAGE: C#\nCODE:\n```\npublic class TerminatedChildrenContainer : Akka.Actor.Internal.EmptyChildrenContainer\n{\n    public new static Akka.Actor.Internal.IChildrenContainer Instance { get; }\n    public override bool IsNormal { get; }\n    public override bool IsTerminating { get; }\n    public override Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats) { }\n    public override Akka.Actor.Internal.IChildrenContainer Reserve(string name) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ThrowOverflowExceptionStrategy Class in Akka.NET\nDESCRIPTION: The ThrowOverflowExceptionStrategy class provides a singleton instance of a strategy that throws exceptions when a stash overflow occurs. It implements IStashOverflowStrategy interface.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\npublic class ThrowOverflowExceptionStrategy : Akka.Persistence.IStashOverflowStrategy\n{\n    public static Akka.Persistence.ThrowOverflowExceptionStrategy Instance { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IProducesPushTimeoutSemanticsMailbox Interface in C#\nDESCRIPTION: This interface defines a contract for mailboxes that produce push timeout semantics. It includes a PushTimeout property of type TimeSpan.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_100\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IProducesPushTimeoutSemanticsMailbox\n{\n    System.TimeSpan PushTimeout { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Either Static Factory Methods in C#\nDESCRIPTION: Static factory methods for creating Either types, a functional programming construct representing a value of one of two possible types. Provides Left and Right factory methods.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_236\n\nLANGUAGE: C#\nCODE:\n```\npublic class static Either\n{\n    public static Akka.Util.Left<T> Left<T>(T value) { }\n    public static Akka.Util.Right<T> Right<T>(T value) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Terminate System Message in Akka.NET\nDESCRIPTION: Defines a system message that instructs an actor to terminate completely. Marked as potentially harmful and suppresses dead letter notifications.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_130\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Terminate : Akka.Dispatch.SysMsg.SystemMessage, Akka.Actor.IPossiblyHarmful, Akka.Event.IDeadLetterSuppression\n{\n    public Terminate() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: ClusterJoinFailedException Class Definition\nDESCRIPTION: This snippet defines a class `ClusterJoinFailedException` that inherits from `Akka.Actor.AkkaException`. It represents an exception that is thrown when a cluster join operation fails. It includes constructors for different scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ClusterJoinFailedException : Akka.Actor.AkkaException\n{\n    public ClusterJoinFailedException(string message) { }\n    protected ClusterJoinFailedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LWWDictionaryKey for Distributed Data\nDESCRIPTION: Key class for Last-Write-Wins Dictionary in Akka.NET's distributed data. This class provides type-safe identification for LWWDictionary instances in the replicated data store.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class LWWDictionaryKey<TKey, TValue> : Akka.DistributedData.Key<Akka.DistributedData.LWWDictionary<TKey, TValue>>\n{\n    public LWWDictionaryKey(string id) { }\n    public System.Type KeyType { get; }\n    public System.Type ValueType { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TestAssociationHandle Class in Akka.NET Remote Transport\nDESCRIPTION: A test-specific implementation of AssociationHandle used for simulating network connections in unit tests for Akka.NET's transport system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class TestAssociationHandle : Akka.Remote.Transport.AssociationHandle\n{\n    public readonly bool Inbound;\n    public TestAssociationHandle(Akka.Actor.Address localAddress, Akka.Actor.Address remoteAddress, Akka.Remote.Transport.TestTransport transport, bool inbound) { }\n    public System.ValueTuple<Akka.Actor.Address, Akka.Actor.Address> Key { get; }\n    public override void Disassociate() { }\n    public override bool Write(Google.Protobuf.ByteString payload) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Adaptive Load Balancing Group in Akka.NET\nDESCRIPTION: This C# class `AdaptiveLoadBalancingGroup` extends the `Akka.Routing.Group` to provide adaptive load balancing using specified metrics selectors. It includes constructors for configuration-based initialization and provides methods to create routers, get paths, and manage routing logic. Dependencies include Akka.Routing, Akka.Actor, and Akka.Metrics namespaces.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Net.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class AdaptiveLoadBalancingGroup : Akka.Routing.Group {\n    public AdaptiveLoadBalancingGroup(Akka.Cluster.Metrics.IMetricsSelector metricsSelector = null, System.Collections.Generic.IEnumerable<string> paths = null, string routerDispatcher = null) { }\n    public AdaptiveLoadBalancingGroup(Akka.Configuration.Config config) { }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }\n    public override Akka.Actor.Props RoutingLogicController(Akka.Routing.RoutingLogic routingLogic) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Cluster.Metrics.AdaptiveLoadBalancingGroup WithDispatcher(string dispatcherId) { }\n    public class AdaptiveLoadBalancingGroupSurrogate : Akka.Util.ISurrogate {\n        public AdaptiveLoadBalancingGroupSurrogate() { }\n        public Akka.Cluster.Metrics.IMetricsSelector MetricsSelector { get; set; }\n        public System.Collections.Generic.IEnumerable<string> Paths { get; set; }\n        public string RouterDispatcher { get; set; }\n        public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining static ClusterMetricsMessagesReflection for Akka.NET\nDESCRIPTION: This static class, `ClusterMetricsMessagesReflection`, provides access to the Google Protocol Buffers file descriptor for cluster metrics messages. It exposes a static property `Descriptor` that returns the `Google.Protobuf.Reflection.FileDescriptor` instance.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\npublic class static ClusterMetricsMessagesReflection\n    {\n        public static Google.Protobuf.Reflection.FileDescriptor Descriptor { get; }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining NoSnapshotStoreException Class in C#\nDESCRIPTION: Custom exception class for handling scenarios where no snapshot store is available. It includes multiple constructors for different exception creation scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\npublic class NoSnapshotStoreException : System.Exception\n{\n    public NoSnapshotStoreException() { }\n    public NoSnapshotStoreException(string message) { }\n    public NoSnapshotStoreException(string message, System.Exception innerException) { }\n    protected NoSnapshotStoreException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: FSM Error State Handler with Stop in C#\nDESCRIPTION: Example of handling an error state in FSM with conditional stopping based on event.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/finite-state-machine.md#2025-04-16_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nWhen(State.Error, state =>\n{\n    if (state.FsmEvent == \"stop\")\n    {\n        return Stop();\n    }\n\n    return null;\n});\n```\n\n----------------------------------------\n\nTITLE: Remote Watcher Message Classes in C#\nDESCRIPTION: Defines message classes used by RemoteWatcher for heartbeat monitoring and watch management between remote actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ExpectedFirstHeartbeat\n{\n    public ExpectedFirstHeartbeat(Akka.Actor.Address from) { }\n    public Akka.Actor.Address From { get; }\n}\n\npublic sealed class Heartbeat\n{\n    public static Akka.Remote.RemoteWatcher.Heartbeat Instance { get; }\n}\n\npublic class HeartbeatRsp\n{\n    public HeartbeatRsp(int addressUid) { }\n    public int AddressUid { get; }\n}\n\npublic class HeartbeatTick\n{\n    public static Akka.Remote.RemoteWatcher.HeartbeatTick Instance { get; }\n}\n\npublic class ReapUnreachableTick\n{\n    public static Akka.Remote.RemoteWatcher.ReapUnreachableTick Instance { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Extractor Implementation in C#\nDESCRIPTION: This C# code defines an interface `IUser` and two classes, `FreeUser` and `PremiumUser`, that implement the interface. It provides a static extension method `TryExtractName` to mimic Scala extractors. This method returns the name of the user and a boolean indicating success.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/porting-guide.md#2025-04-16_snippet_15\n\nLANGUAGE: c#\nCODE:\n```\npublic interface IUser\n{\n    string Name { get; }\n}\n\npublic class FreeUser : IUser\n{\n    public FreeUser(string name)\n    {\n        Name = name;\n    }\n\n    public string Name { get; }\n}\n\npublic class PremiumUser : IUser\n{\n    public PremiumUser(string name)\n    {\n        Name = name;\n    }\n\n    public string Name { get; }\n}\n\npublic static class UserExtensions\n{\n    public static bool TryExtractName(this IUser user, out string name)\n    {\n        name = user.Name;\n        return !string.IsNullOrEmpty(user.Name);\n    }\n}\n\n// using\nIUser user = new PremiumUser(\"Daniel\");\n```\n\n----------------------------------------\n\nTITLE: Implementing TcpExt Extension Class in C#\nDESCRIPTION: Defines the TcpExt extension class for Akka.NET that manages TCP-related functionality. It provides access to buffer pools, manager actors, and TCP settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_167\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class TcpExt : Akka.IO.IOExtension\n{\n    public TcpExt(Akka.Actor.ExtendedActorSystem system) { }\n    public Akka.IO.Buffers.IBufferPool BufferPool { get; }\n    public override Akka.Actor.IActorRef Manager { get; }\n    public Akka.IO.TcpSettings Settings { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dropped Message Class in C#\nDESCRIPTION: A sealed class representing messages that were dropped by the actor system. It includes the message, reason for dropping, sender, and recipient information.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_120\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Dropped : Akka.Event.AllDeadLetters\n{\n    public Dropped(object message, string reason, Akka.Actor.IActorRef sender, Akka.Actor.IActorRef recipient) { }\n    public Dropped(object message, string reason, Akka.Actor.IActorRef recipient) { }\n    public string Reason { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NoLogger Class in C# for Akka.NET\nDESCRIPTION: The NoLogger class implements ILoggingAdapter and provides a null object pattern for logging in Akka.NET. It includes properties for log level checks and methods for logging, but does not perform any actual logging operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_155\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class NoLogger : Akka.Event.ILoggingAdapter\n{\n    public static readonly Akka.Event.ILoggingAdapter Instance;\n    public Akka.Event.ILogMessageFormatter Formatter { get; }\n    public bool IsDebugEnabled { get; }\n    public bool IsErrorEnabled { get; }\n    public bool IsInfoEnabled { get; }\n    public bool IsWarningEnabled { get; }\n    public bool IsEnabled(Akka.Event.LogLevel logLevel) { }\n    public void Log(Akka.Event.LogLevel logLevel, System.Exception cause, string format) { }\n    public void Log(Akka.Event.LogLevel logLevel, System.Exception cause, Akka.Event.LogMessage message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PersistenceSettings Class in Akka.NET\nDESCRIPTION: This code defines the `PersistenceSettings` class, which encapsulates the configuration settings for Akka.NET persistence. It contains nested classes `AtLeastOnceDeliverySettings`, `InternalSettings`, and `ViewSettings` to group related settings. It also includes methods to create new instances of `AtLeastOnceDeliverySettings` with updated values.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class PersistenceSettings : Akka.Actor.Settings\n{\n    public PersistenceSettings(Akka.Actor.ActorSystem system, Akka.Configuration.Config config) { }\n    public Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings AtLeastOnceDelivery { get; set; }\n    public Akka.Persistence.PersistenceSettings.InternalSettings Internal { get; }\n    public Akka.Persistence.PersistenceSettings.ViewSettings View { get; }\n    public sealed class AtLeastOnceDeliverySettings\n    {\n        public AtLeastOnceDeliverySettings(System.TimeSpan redeliverInterval, int redeliveryBurstLimit, int warnAfterNumberOfUnconfirmedAttempts, int maxUnconfirmedMessages) { }\n        public AtLeastOnceDeliverySettings(Akka.Configuration.Config config) { }\n        public int MaxUnconfirmedMessages { get; }\n        public System.TimeSpan RedeliverInterval { get; }\n        public int RedeliveryBurstLimit { get; }\n        public int WarnAfterNumberOfUnconfirmedAttempts { get; }\n        public Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings WithMaxUnconfirmedMessages(int maxUnconfirmedMessages) { }\n        public Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings WithRedeliverInterval(System.TimeSpan redeliverInterval) { }\n        public Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings WithRedeliveryBurstLimit(int redeliveryBurstLimit) { }\n        public Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings WithUnconfirmedAttemptsToWarn(int unconfirmedAttemptsToWarn) { }\n    }\n    public sealed class InternalSettings\n    {\n        public InternalSettings(Akka.Configuration.Config config) { }\n        public bool PublishConfirmations { get; }\n        public bool PublishPluginCommands { get; }\n    }\n    public sealed class ViewSettings\n    {\n        public ViewSettings(Akka.Configuration.Config config) { }\n        public bool AutoUpdate { get; }\n        public System.TimeSpan AutoUpdateInterval { get; }\n        public long AutoUpdateReplayMax { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Stash Capacity in Akka.NET\nDESCRIPTION: Sets the maximum stash capacity for actors to protect against OutOfMemoryException. This HOCON configuration limits the stash capacity to 10000 messages per actor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/event-sourcing.md#2025-04-16_snippet_6\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.default-mailbox.stash-capacity = 10000\n```\n\n----------------------------------------\n\nTITLE: Implementing Runtime Detection in C#\nDESCRIPTION: Provides a static RuntimeDetector class with boolean properties to identify the runtime environment, specifically whether the code is running on Mono or Windows. This helps with platform-specific behaviors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_251\n\nLANGUAGE: C#\nCODE:\n```\npublic class static RuntimeDetector\n{\n    public static readonly bool IsMono;\n    public static readonly bool IsWindows;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TestKit Event Filter Components in C#\nDESCRIPTION: Implementation of internal event filter components including methods for awaiting, expecting and intercepting events. Contains async and sync variants for handling different testing scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\nprotected bool AwaitDone(System.TimeSpan timeout, System.Nullable<int> expectedOccurrences, Akka.TestKit.Internal.InternalEventFilterApplier.MatchedEventHandler matchedEventHandler, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ShardingProducerController for Akka.NET\nDESCRIPTION: Implements producer controller functionality for Akka.NET cluster sharding with message confirmation and delivery settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Net.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic class static ShardingProducerController\n{\n    public static Akka.Actor.Props Create<T>(string producerId, Akka.Actor.IActorRef shardRegion, Akka.Util.Option<Akka.Actor.Props> durableQueue, Akka.Cluster.Sharding.Delivery.ShardingProducerController.Settings settings) { }\n    public interface IShardingProducerControllerCommand<T> { }\n    public sealed class MessageWithConfirmation<T> : IShardingProducerControllerCommand<T>\n    {\n        public string EntityId { get; set; }\n        public T Message { get; set; }\n        public Akka.Actor.IActorRef ReplyTo { get; set; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MetricsSelector message with Google Protocol Buffers for Akka.NET\nDESCRIPTION: This class, `MetricsSelector`, is used for selecting specific metrics from a serialized form. It encapsulates the serializer ID, manifest, and data for a metric. It is used in conjunction with `MixMetricsSelector` to combine multiple metrics selectors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class MetricsSelector : Google.Protobuf.IDeepCloneable<Akka.Cluster.Metrics.Serialization.MetricsSelector>, Google.Protobuf.IMessage, Google.Protobuf.IMessage<Akka.Cluster.Metrics.Serialization.MetricsSelector>, System.IEquatable<Akka.Cluster.Metrics.Serialization.MetricsSelector>\n    {\n        public const int DataFieldNumber = 3;\n        public const int ManifestFieldNumber = 2;\n        public const int SerializerIdFieldNumber = 1;\n        public MetricsSelector() { }\n        public MetricsSelector(Akka.Cluster.Metrics.Serialization.MetricsSelector other) { }\n        public Google.Protobuf.ByteString Data { get; set; }\n        public static Google.Protobuf.Reflection.MessageDescriptor Descriptor { get; }\n        public string Manifest { get; set; }\n        public static Google.Protobuf.MessageParser<Akka.Cluster.Metrics.Serialization.MetricsSelector> Parser { get; }\n        public uint SerializerId { get; set; }\n        public int CalculateSize() { }\n        public Akka.Cluster.Metrics.Serialization.MetricsSelector Clone() { }\n        public override bool Equals(object other) { }\n        public bool Equals(Akka.Cluster.Metrics.Serialization.MetricsSelector other) { }\n        public override int GetHashCode() { }\n        public void MergeFrom(Akka.Cluster.Metrics.Serialization.MetricsSelector other) { }\n        public void MergeFrom(Google.Protobuf.CodedInputStream input) { }\n        public override string ToString() { }\n        public void WriteTo(Google.Protobuf.CodedOutputStream output) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Publish/Subscribe Pattern in F#\nDESCRIPTION: Demonstrates implementation of pub/sub pattern using Akka.NET event streams in F#. Shows subscriber and publisher actor definitions with message handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.FSharp/README.md#2025-04-16_snippet_8\n\nLANGUAGE: F#\nCODE:\n```\ntype Message =\n        | Subscribe\n        | Unsubscribe\n        | Msg of ActorRef * string\n\n    let subscriber =\n        spawn system \"subscriber\"\n            (actorOf2 (fun mailbox msg ->\n                let eventStream = mailbox.Context.System.EventStream\n                match msg with\n                | Msg (sender, content) -> printfn \"%A says %s\" (sender.Path) content\n                | Subscribe -> subscribe typeof<Message> mailbox.Self eventStream |> ignore\n                | Unsubscribe -> unsubscribe typeof<Message> mailbox.Self eventStream |> ignore ))\n\n    let publisher =\n        spawn system \"publisher\"\n            (actorOf2 (fun mailbox msg ->\n                publish msg mailbox.Context.System.EventStream))\n\n    subscriber <! Subscribe\n    publisher  <! Msg (publisher, \"hello\")\n    subscriber <! Unsubscribe\n    publisher  <! Msg (publisher, \"hello again\")\n```\n\n----------------------------------------\n\nTITLE: Defining EventStreamActor Class in C#\nDESCRIPTION: Defines the EventStreamActor class which inherits from ActorBase. It includes a constructor and an overridden Receive method for handling messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic class EventStreamActor : Akka.Actor.ActorBase\n{\n    public EventStreamActor() { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Surrogates for Complex Object Serialization in Hyperion\nDESCRIPTION: This C# snippet shows how to create a surrogate for a complex class `Foo`. The surrogate simplifies serialization by mapping the complex object to a simpler representation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/serialization/serialization.md#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Foo\n{\n    public Foo(string bar)\n    {\n        Bar = bar;\n        ComplexProperty = ComputeComplexProperty();\n    }\n\n    public string Bar { get; }\n    public HighlyComplexComputedProperty ComplexProperty { get; }\n    \n    private  ComputeComplexProperty()\n    {\n        // ...\n    }\n}\n        \npublic class FooSurrogate\n{\n    public FooSurrogate(string bar)\n    {\n        Bar = bar;\n    }\n\n    public string Bar { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GracefulShutdown Class in C#\nDESCRIPTION: A sealed class representing a graceful shutdown command for shard regions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class GracefulShutdown : Akka.Cluster.Sharding.IShardRegionCommand\n{\n    public static readonly Akka.Cluster.Sharding.GracefulShutdown Instance;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing QueryConfiguration for SQL Snapshot Store in C#\nDESCRIPTION: Configuration class for SQL snapshot store, including table and column names, timeout settings, and isolation levels for read and write operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.DotNet.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic class QueryConfiguration\n{\n    [System.ObsoleteAttribute(\"This property should never be used for writes, use the default `System.Object` serializer instead\")]\n    public readonly string DefaultSerializer;\n    public readonly string ManifestColumnName;\n    public readonly string PayloadColumnName;\n    public readonly string PersistenceIdColumnName;\n    public readonly string SchemaName;\n    public readonly string SequenceNrColumnName;\n    public readonly string SerializerIdColumnName;\n    public readonly string SnapshotTableName;\n    public readonly System.TimeSpan Timeout;\n    public readonly string TimestampColumnName;\n    // ... (constructors and properties omitted for brevity)\n}\n```\n\n----------------------------------------\n\nTITLE: Loading ClusterClientReceptionist Extension in HOCON\nDESCRIPTION: Configuration to load the ClusterClientReceptionist extension when the actor system starts, by defining it in the akka.extensions property.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-client.md#2025-04-16_snippet_2\n\nLANGUAGE: hocon\nCODE:\n```\nakka.extensions = [\"Akka.Cluster.Tools.Client.ClusterClientReceptionistExtensionProvider, Akka.Cluster.Tools\"]\n```\n\n----------------------------------------\n\nTITLE: Defining Journal Interceptor Interface in C#\nDESCRIPTION: Defines the interface for a journal interceptor used in the TestJournal. The interceptor allows customization of journal behavior during testing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistence-testing.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IJournalInterceptor\n{\n    Task InterceptAsync(IPersistentRepresentation message);\n}\n```\n\n----------------------------------------\n\nTITLE: LeaseProviderExtensionProvider Class Definition in C#\nDESCRIPTION: Provides extension identification and creation for the LeaseProvider. Implements the ExtensionIdProvider for integrating with Akka's extension system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class LeaseProviderExtensionProvider : Akka.Actor.ExtensionIdProvider<Akka.Coordination.LeaseProvider>\n{\n    public LeaseProviderExtensionProvider() { }\n    public override Akka.Coordination.LeaseProvider CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ActionRunnable in Akka.Dispatch Namespace\nDESCRIPTION: The ActionRunnable class implements the IRunnable interface to wrap a simple Action delegate. This allows standard .NET actions to be scheduled and executed within the Akka.NET runtime.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_78\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ActionRunnable : Akka.Dispatch.IRunnable\n{\n    public ActionRunnable(System.Action action) { }\n    public void Run() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Coordinated Shutdown Implementation\nDESCRIPTION: Implementation of the CoordinatedShutdown extension for managing graceful system shutdown phases and tasks in Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class CoordinatedShutdown : Akka.Actor.IExtension\n{\n    public const string PhaseActorSystemTerminate = \"actor-system-terminate\";\n    public const string PhaseBeforeActorSystemTerminate = \"before-actor-system-terminate\";\n    public const string PhaseBeforeClusterShutdown = \"before-cluster-shutdown\";\n    public const string PhaseBeforeServiceUnbind = \"before-service-unbind\";\n    public Akka.Actor.CoordinatedShutdown.Reason ShutdownReason { get; }\n    public Akka.Actor.ExtendedActorSystem System { get; }\n    public System.TimeSpan TotalTimeout { get; }\n    public void AddTask(string phase, string taskName, System.Func<System.Threading.Tasks.Task<Akka.Done>> task) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LWWRegisterKey for Distributed Data\nDESCRIPTION: Key class for Last-Write-Wins Register in Akka.NET's distributed data. This class provides type-safe identification for LWWRegister instances in the replicated data store.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class LWWRegisterKey<T> : Akka.DistributedData.Key<Akka.DistributedData.LWWRegister<T>>\n{\n    public LWWRegisterKey(string id) { }\n    public System.Type RegisterType { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: AtLeastOnceDeliverySemantic Class Definition in Akka.Persistence\nDESCRIPTION: Core implementation class for at-least-once delivery semantics, providing the functionality used by the actor classes and containing nested types for delivery tracking and redelivery.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class AtLeastOnceDeliverySemantic\n{\n    public AtLeastOnceDeliverySemantic(Akka.Actor.IActorContext context, Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings settings) { }\n    public int MaxUnconfirmedMessages { get; }\n    public System.TimeSpan RedeliverInterval { get; }\n    public int RedeliveryBurstLimit { get; }\n    public int UnconfirmedCount { get; }\n    public int WarnAfterNumberOfUnconfirmedAttempts { get; }\n    public bool AroundReceive(Akka.Actor.Receive receive, object message) { }\n    public void Cancel() { }\n    public bool ConfirmDelivery(long deliveryId) { }\n    public void Deliver(Akka.Actor.ActorPath destination, System.Func<long, object> deliveryMessageMapper, bool isRecovering) { }\n    public Akka.Persistence.AtLeastOnceDeliverySnapshot GetDeliverySnapshot() { }\n    public void OnReplaySuccess() { }\n    public void SetDeliverySnapshot(Akka.Persistence.AtLeastOnceDeliverySnapshot snapshot) { }\n    public sealed class Delivery : System.IEquatable<Akka.Persistence.AtLeastOnceDeliverySemantic.Delivery>\n    {\n        public Delivery(Akka.Actor.ActorPath destination, object message, System.DateTime timestamp, int attempt) { }\n        public int Attempt { get; }\n        public Akka.Actor.ActorPath Destination { get; }\n        public object Message { get; }\n        public System.DateTime Timestamp { get; }\n        public bool Equals(Akka.Persistence.AtLeastOnceDeliverySemantic.Delivery other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n        public Akka.Persistence.AtLeastOnceDeliverySemantic.Delivery IncrementedCopy() { }\n        public override string ToString() { }\n    }\n    public sealed class RedeliveryTick : Akka.Actor.INotInfluenceReceiveTimeout, Akka.Event.IDeadLetterSuppression\n    {\n        public static Akka.Persistence.AtLeastOnceDeliverySemantic.RedeliveryTick Instance { get; }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Association Events in C# for Akka.NET Remote Module\nDESCRIPTION: Defines various association events (AssociatedEvent, AssociationErrorEvent, DisassociatedEvent) for managing remote actor associations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class AssociatedEvent : Akka.Remote.AssociationEvent\n{\n    public AssociatedEvent(Akka.Actor.Address localAddress, Akka.Actor.Address remoteAddress, bool inbound) { }\n    public override bool IsInbound { get; set; }\n    public override Akka.Actor.Address LocalAddress { get; set; }\n    public override Akka.Actor.Address RemoteAddress { get; set; }\n    public override Akka.Event.LogLevel LogLevel() { }\n}\n\n// ... (AssociationErrorEvent and DisassociatedEvent implementations)\n```\n\n----------------------------------------\n\nTITLE: Actor Stop System Message in Akka.NET\nDESCRIPTION: System message for stopping an actor. When an actor receives this message, it initiates its termination sequence.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_103\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class Stop : Akka.Dispatch.SysMsg.SystemMessage\n{\n    public Stop() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DistributedPubSubSettings in C#\nDESCRIPTION: Implements settings for the DistributedPubSub extension, including configuration for gossip intervals, routing logic, and other behaviors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Core.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DistributedPubSubSettings : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public DistributedPubSubSettings(string role, Akka.Routing.RoutingLogic routingLogic, System.TimeSpan gossipInterval, System.TimeSpan removedTimeToLive, int maxDeltaElements, bool sendToDeadLettersWhenNoSubscribers) { }\n    public System.TimeSpan GossipInterval { get; }\n    public int MaxDeltaElements { get; }\n    public System.TimeSpan RemovedTimeToLive { get; }\n    public string Role { get; }\n    public Akka.Routing.RoutingLogic RoutingLogic { get; }\n    public bool SendToDeadLettersWhenNoSubscribers { get; }\n    public static Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings Create(Akka.Actor.ActorSystem system) { }\n    public static Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings Create(Akka.Configuration.Config config) { }\n    // Additional methods for modifying settings\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring TestScheduler Implementation in HOCON\nDESCRIPTION: HOCON configuration for implementing a virtualized TestScheduler that allows developers to artificially advance time in tests.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/modules/akka.testkit.md#2025-04-16_snippet_1\n\nLANGUAGE: hocon\nCODE:\n```\n[!code[Akka.TestKit.dll TestScheduler HOCON Configuration](../../../../src/core/Akka.TestKit/Configs/TestScheduler.conf)]\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Akka.NET Stream with GraphDSL\nDESCRIPTION: Demonstrates how to split a stream into two streams using a Broadcast junction. This example writes author handles and hashtags to separate sinks.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/reactivetweets.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nSink<IUser, NotUsed> writeAuthors = null;\nSink<IHashtagEntity, NotUsed> writeHashtags = null;\n\nvar g = RunnableGraph.FromGraph(GraphDsl.Create(b =>\n{\n    var broadcast = b.Add(new Broadcast<ITweet>(2));\n    b.From(tweetSource).To(broadcast.In);\n    b.From(broadcast.Out(0))\n        .Via(Flow.Create<ITweet>().Select(tweet => tweet.CreatedBy))\n        .To(writeAuthors);\n    b.From(broadcast.Out(1))\n        .Via(Flow.Create<ITweet>().SelectMany(tweet => tweet.Hashtags))\n        .To(writeHashtags);\n\n    return ClosedShape.Instance;\n}));\n\ng.Run(mat);\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Cluster Metrics Events in C#\nDESCRIPTION: Shows how to subscribe a metrics listener actor to cluster metrics events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-metrics.md#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nClusterMetrics.Get(Sys).Subscribe(metricsListenerActor);\n```\n\n----------------------------------------\n\nTITLE: Defining Flag Class in Akka.NET DistributedData (C#)\nDESCRIPTION: Defines the Flag class, which represents a boolean flag in a distributed system. It includes methods for equality comparison, merging, and switching the flag on.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Flag : Akka.DistributedData.FastMerge<Akka.DistributedData.Flag>, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDataSerialization, Akka.DistributedData.IReplicatedData<Akka.DistributedData.Flag>, System.IEquatable<Akka.DistributedData.Flag>\n{\n    public bool Equals(Akka.DistributedData.Flag other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public Akka.DistributedData.Flag Merge(Akka.DistributedData.Flag other) { }\n    public Akka.DistributedData.Flag SwitchOn() { }\n    public override string ToString() { }\n    public static bool op_Implicit(Akka.DistributedData.Flag flag) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IPersistenceRecovery Interface\nDESCRIPTION: This snippet defines the `IPersistenceRecovery` interface, which is used to mark actors that support persistence recovery in Akka.Persistence. It has a `Recovery` property of type `Akka.Persistence.Recovery`, enabling access to recovery-related settings and functionalities for the implementing actor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\n\"public interface IPersistenceRecovery\n    {\n        Akka.Persistence.Recovery Recovery { get; }\n    }\"\n```\n\n----------------------------------------\n\nTITLE: Defining IJournalRequest Interface\nDESCRIPTION: This snippet defines the `IJournalRequest` interface, representing a request message to the journal in Akka.Persistence. It inherits from `INoSerializationVerificationNeeded`, `IJournalMessage`, and `IPersistenceMessage`. This interface is implemented by messages that trigger actions within the journal, such as writing events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\n\"public interface IJournalRequest : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IJournalMessage, Akka.Persistence.IPersistenceMessage { }\"\n```\n\n----------------------------------------\n\nTITLE: Implementing BoundedDequeBasedMailbox in Akka.Dispatch\nDESCRIPTION: The BoundedDequeBasedMailbox class implements a mailbox with a bounded double-ended queue. It provides capacity and timeout settings for handling message overflow conditions in the actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_81\n\nLANGUAGE: C#\nCODE:\n```\npublic class BoundedDequeBasedMailbox : Akka.Dispatch.MailboxType, Akka.Dispatch.IProducesMessageQueue<Akka.Dispatch.MessageQueues.BoundedDequeMessageQueue>, Akka.Dispatch.IProducesPushTimeoutSemanticsMailbox\n{\n    public BoundedDequeBasedMailbox(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }\n    public int Capacity { get; }\n    public System.TimeSpan PushTimeout { get; }\n    public override Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing HoconTokenizer Class in C#\nDESCRIPTION: This snippet defines the HoconTokenizer class, which provides methods for tokenizing HOCON (Human-Optimized Config Object Notation) content, including methods to check for various token types and pull tokens from the input.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_75\n\nLANGUAGE: C#\nCODE:\n```\npublic class HoconTokenizer : Akka.Configuration.Hocon.Tokenizer\n{\n    public HoconTokenizer(string text) { }\n    public bool IsArrayEnd() { }\n    public bool IsArrayStart() { }\n    public bool IsAssignment() { }\n    public bool IsComma() { }\n    public bool IsDot() { }\n    public bool IsEndOfObject() { }\n    public bool IsInclude() { }\n    public bool IsObjectStart() { }\n    public bool IsSpaceOrTab() { }\n    public bool IsStartOfComment() { }\n    public bool IsStartOfQuotedText() { }\n    public bool IsStartOfTripleQuotedText() { }\n    public bool IsStartSimpleValue() { }\n    public bool IsSubstitutionStart() { }\n    public bool IsUnquotedKey() { }\n    public bool IsUnquotedKeyStart() { }\n    public bool IsWhitespace() { }\n    public bool IsWhitespaceOrComment() { }\n    public Akka.Configuration.Hocon.Token PullArrayEnd() { }\n    public Akka.Configuration.Hocon.Token PullArrayStart() { }\n    public Akka.Configuration.Hocon.Token PullAssignment() { }\n    public Akka.Configuration.Hocon.Token PullComma() { }\n    public Akka.Configuration.Hocon.Token PullComment() { }\n    public Akka.Configuration.Hocon.Token PullDot() { }\n    public Akka.Configuration.Hocon.Token PullEndOfObject() { }\n    public Akka.Configuration.Hocon.Token PullInclude() { }\n    public Akka.Configuration.Hocon.Token PullNext() { }\n    public Akka.Configuration.Hocon.Token PullQuotedKey() { }\n    public Akka.Configuration.Hocon.Token PullQuotedText() { }\n    public string PullRestOfLine() { }\n    public Akka.Configuration.Hocon.Token PullSimpleValue() { }\n    public Akka.Configuration.Hocon.Token PullSpaceOrTab() { }\n    public Akka.Configuration.Hocon.Token PullStartOfObject() { }\n    public Akka.Configuration.Hocon.Token PullSubstitution() { }\n    public Akka.Configuration.Hocon.Token PullTripleQuotedText() { }\n    public Akka.Configuration.Hocon.Token PullUnquotedKey() { }\n    public Akka.Configuration.Hocon.Token PullValue() { }\n    public void PullWhitespaceAndComments() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Logging Test Output in Akka.NET\nDESCRIPTION: This class defines TestOutputLogger, an Akka.NET actor for logging test outputs using Xunit's ITestOutputHelper. It allows capturing and managing test logs within Akka actor systems.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKitXunit2.Net.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestOutputLogger : Akka.Actor.ReceiveActor\n{\n    public TestOutputLogger(Xunit.Abstractions.ITestOutputHelper output) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing External Shard Allocation Client Interface in C#\nDESCRIPTION: Defines an interface for external shard allocation client with methods for managing shard locations and updates.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IExternalShardAllocationClient\n{\n    System.Threading.Tasks.Task<Akka.Cluster.Sharding.External.ShardLocations> ShardLocations();\n    System.Threading.Tasks.Task<Akka.Done> UpdateShardLocation(string shard, Akka.Actor.Address location);\n    System.Threading.Tasks.Task<Akka.Done> UpdateShardLocations(System.Collections.Immutable.IImmutableDictionary<string, Akka.Actor.Address> locations);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LoadSnapshot Message Class in Akka.NET Persistence\nDESCRIPTION: This code defines the `LoadSnapshot` class, which represents a message for requesting the loading of a snapshot in Akka.NET persistence. It includes properties for the persistence ID, snapshot selection criteria, and the target sequence number. The `LoadSnapshot` class implements interfaces related to persistence messages, snapshot messages, and snapshot requests, also implementing `IEquatable` for value comparison.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class LoadSnapshot : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage, Akka.Persistence.ISnapshotRequest, System.IEquatable<Akka.Persistence.LoadSnapshot>\n{\n    public LoadSnapshot(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria, long toSequenceNr) { }\n    public Akka.Persistence.SnapshotSelectionCriteria Criteria { get; }\n    public string PersistenceId { get; }\n    public long ToSequenceNr { get; }\n    public bool Equals(Akka.Persistence.LoadSnapshot other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: RemoteScope Implementation for Remote Actor Deployment in Akka.NET (C#)\nDESCRIPTION: Class that specifies a remote address where an actor should be deployed. It extends Scope and provides methods for equality comparison and merging with other scopes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\npublic class RemoteScope : Akka.Actor.Scope, System.IEquatable<Akka.Actor.RemoteScope>\n{\n    protected RemoteScope() { }\n    public RemoteScope(Akka.Actor.Address address) { }\n    public Akka.Actor.Address Address { get; set; }\n    public override Akka.Actor.Scope Copy() { }\n    public bool Equals(Akka.Actor.RemoteScope other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override Akka.Actor.Scope WithFallback(Akka.Actor.Scope other) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Offset classes in C# for Akka.NET Persistence Query\nDESCRIPTION: Defines abstract Offset class and its implementations (NoOffset, Sequence, TimeBasedUuid) for handling event offsets in the persistence query system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceQuery.Core.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Offset : System.IComparable<Akka.Persistence.Query.Offset>\n{\n    protected Offset() { }\n    public abstract int CompareTo(Akka.Persistence.Query.Offset other);\n    public static Akka.Persistence.Query.Offset NoOffset() { }\n    public static Akka.Persistence.Query.Offset Sequence(long value) { }\n    public static Akka.Persistence.Query.Offset TimeBasedUuid(System.Guid value) { }\n}\n\npublic sealed class NoOffset : Akka.Persistence.Query.Offset\n{\n    public static Akka.Persistence.Query.NoOffset Instance { get; }\n    public override int CompareTo(Akka.Persistence.Query.Offset other) { }\n}\n\npublic sealed class Sequence : Akka.Persistence.Query.Offset, System.IComparable<Akka.Persistence.Query.Sequence>\n{\n    public Sequence(long value) { }\n    public long Value { get; }\n    public int CompareTo(Akka.Persistence.Query.Sequence other) { }\n    public override int CompareTo(Akka.Persistence.Query.Offset other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n}\n\npublic sealed class TimeBasedUuid : Akka.Persistence.Query.Offset, System.IComparable<Akka.Persistence.Query.TimeBasedUuid>\n{\n    public TimeBasedUuid(System.Guid value) { }\n    public System.Guid Value { get; }\n    public int CompareTo(Akka.Persistence.Query.TimeBasedUuid other) { }\n    public override int CompareTo(Akka.Persistence.Query.Offset other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Akka.Done Singleton Definition\nDESCRIPTION: A singleton object representing a completed operation with no return value. Used to signal completion of operations that don't need to return any specific value.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_112\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class Done\n{\n    public static readonly Akka.Done Instance;\n}\n```\n\n----------------------------------------\n\nTITLE: Cluster Event Model in C#\nDESCRIPTION: Implements cluster event classes for tracking member status changes, leader elections, and cluster state transitions\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.DotNet.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class MemberJoined : Akka.Cluster.ClusterEvent.MemberStatusChange\n{\n    public MemberJoined(Akka.Cluster.Member member) { }\n}\n```\n\n----------------------------------------\n\nTITLE: LeaseTimeoutException Specialized Exception\nDESCRIPTION: Defines a specialized exception class for lease timeout scenarios. Extends the LeaseException class and provides constructors for different error scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.Net.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class LeaseTimeoutException : Akka.Coordination.LeaseException\n{\n    public LeaseTimeoutException(string message) { }\n    public LeaseTimeoutException(string message, System.Exception innerEx) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IReplicatedDataSerialization Interface in C#\nDESCRIPTION: This snippet defines the `IReplicatedDataSerialization` interface, which is likely a marker interface indicating that a type can be serialized and deserialized within the context of replicated data.  It doesn't declare any methods or properties.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\n    public interface IReplicatedDataSerialization { }\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Either Pattern with Right<T> in C#\nDESCRIPTION: Defines Right<T> and Right<TA, TB> classes that implement the Either pattern for functional programming. The Right type represents the right side of an either type, with methods to check which side it represents and access the value.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_250\n\nLANGUAGE: C#\nCODE:\n```\npublic class Right<T>\n{\n    public Right(T value) { }\n    public bool IsLeft { get; }\n    public bool IsRight { get; }\n    public T Value { get; }\n}\npublic class Right<TA, TB> : Akka.Util.Either<TA, TB>\n{\n    public Right(TB b) { }\n    public override bool IsLeft { get; }\n    public override bool IsRight { get; }\n    public TB Value { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: UpdateSuccess Class Definition in C#\nDESCRIPTION: Represents a successful update operation in Akka.NET's distributed data system. Contains the key that was updated and a reference to the original request for correlation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_50\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class UpdateSuccess : Akka.Actor.INoSerializationVerificationNeeded, Akka.DistributedData.IUpdateResponse, System.IEquatable<Akka.DistributedData.UpdateSuccess>\n{\n    public UpdateSuccess(Akka.DistributedData.IKey key, object request) { }\n    public bool IsSuccessful { get; }\n    public Akka.DistributedData.IKey Key { get; }\n    public object Request { get; }\n    public bool Equals(Akka.DistributedData.UpdateSuccess other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public void ThrowOnFailure() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Warning Methods in C#\nDESCRIPTION: Extension methods for warning-level logging with support for generic parameters and exception handling. Provides multiple overloads for different argument counts.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_151\n\nLANGUAGE: csharp\nCODE:\n```\npublic static void Warning(this Akka.Event.ILoggingAdapter log, string format) { }\npublic static void Warning(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format) { }\npublic static void Warning<T1>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterShardingExtensionProvider in C#\nDESCRIPTION: Extension provider class that creates the ClusterSharding extension instance for an ActorSystem. This follows Akka's extension pattern for system-wide features.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Core.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterShardingExtensionProvider : Akka.Actor.ExtensionIdProvider<Akka.Cluster.Sharding.ClusterSharding>\n{\n    public ClusterShardingExtensionProvider() { }\n    public override Akka.Cluster.Sharding.ClusterSharding CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Contact Point Change Classes in C#\nDESCRIPTION: Classes representing changes to contact points in the cluster, including addition and removal events that implement the IContactPointChange interface.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ContactPointAdded : Akka.Cluster.Tools.Client.IContactPointChange\n{\n    public ContactPointAdded(Akka.Actor.ActorPath contactPoint) { }\n    public Akka.Actor.ActorPath ContactPoint { get; }\n}\n\npublic sealed class ContactPointRemoved : Akka.Cluster.Tools.Client.IContactPointChange\n{\n    public ContactPointRemoved(Akka.Actor.ActorPath contactPoint) { }\n    public Akka.Actor.ActorPath ContactPoint { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StartsWithString Class in Akka.NET TestKit\nDESCRIPTION: A string matcher that checks if a string starts with a specific prefix. This implementation of IStringMatcher is useful for prefix-based string matching in tests.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_49\n\nLANGUAGE: C#\nCODE:\n```\npublic class StartsWithString : Akka.TestKit.Internal.StringMatcher.IStringMatcher\n{\n    public StartsWithString(string start) { }\n    public bool IsMatch(string s) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AddressUid and AddressUidExtension Classes in C# for Akka.NET\nDESCRIPTION: Defines AddressUid class implementing IExtension and AddressUidExtension class for managing unique identifiers in Akka.NET actor systems.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class AddressUid : Akka.Actor.IExtension\n{\n    public readonly int Uid;\n    public AddressUid() { }\n}\n\npublic class AddressUidExtension : Akka.Actor.ExtensionIdProvider<Akka.Remote.AddressUid>\n{\n    public AddressUidExtension() { }\n    public override Akka.Remote.AddressUid CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n    public static int Uid(Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Transport Operation Classes in Akka.NET\nDESCRIPTION: Classes representing various transport operations in Akka.NET, including WriteAttempt, UnderlyingTransportError, and the base TransportOperation class. These provide structure for transport-related operations and error handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class TransportOperation : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public static readonly System.TimeSpan AskTimeout;\n    protected TransportOperation() { }\n}\n\npublic sealed class UnderlyingTransportError : Akka.Actor.INoSerializationVerificationNeeded, Akka.Remote.Transport.IHandleEvent\n{\n    public UnderlyingTransportError(System.Exception cause, string message) { }\n}\n\npublic sealed class WriteAttempt : Akka.Remote.Transport.Activity\n{\n    public WriteAttempt(Akka.Actor.Address sender, Akka.Actor.Address recipient, Google.Protobuf.ByteString payload) { }\n    public Google.Protobuf.ByteString Payload { get; }\n    public Akka.Actor.Address Recipient { get; }\n    public Akka.Actor.Address Sender { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Offset Classes in Akka.NET Persistence Query\nDESCRIPTION: Defines the Offset abstract class and its implementations NoOffset and Sequence, used for tracking event positions in persistence queries.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceQuery.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class NoOffset : Akka.Persistence.Query.Offset\n{\n    public static Akka.Persistence.Query.NoOffset Instance { get; }\n    public override int CompareTo(Akka.Persistence.Query.Offset other) { }\n}\n\npublic abstract class Offset : System.IComparable<Akka.Persistence.Query.Offset>\n{\n    protected Offset() { }\n    public abstract int CompareTo(Akka.Persistence.Query.Offset other);\n    public static Akka.Persistence.Query.Offset NoOffset() { }\n    public static Akka.Persistence.Query.Offset Sequence(long value) { }\n}\n\npublic sealed class Sequence : Akka.Persistence.Query.Offset, System.IComparable<Akka.Persistence.Query.Sequence>\n{\n    public Sequence(long value) { }\n    public long Value { get; }\n    public int CompareTo(Akka.Persistence.Query.Sequence other) { }\n    public override int CompareTo(Akka.Persistence.Query.Offset other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Distributed Pub-Sub with Web Role\nDESCRIPTION: HOCON configuration for deploying Distributed Pub-Sub on nodes with the 'web' role, enabling publish-subscribe messaging patterns across the cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/member-roles.md#2025-04-16_snippet_6\n\nLANGUAGE: hocon\nCODE:\n```\nakka\n{\n  cluster\n  {\n    roles = [\"web\"]\n    pub-sub\n    {\n      role = \"web\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Logger Initialization and Mailbox Classes in C#\nDESCRIPTION: Classes that support the Akka.NET logging infrastructure initialization. LoggerInitialized signals that the logger has been properly set up, while LoggerMailbox provides a specialized mailbox implementation for logger actors with appropriate message handling semantics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_148\n\nLANGUAGE: C#\nCODE:\n```\npublic class LoggerInitialized : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression\n{\n    public LoggerInitialized() { }\n}\n\npublic class LoggerMailbox : Akka.Dispatch.Mailbox, Akka.Dispatch.ISemantics, Akka.Dispatch.IUnboundedMessageQueueSemantics, Akka.Dispatch.MessageQueues.IMessageQueue, Akka.Event.ILoggerMessageQueueSemantics\n{\n    public LoggerMailbox(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Error Handling for Unsolvable Substitutions in C#\nDESCRIPTION: This test shows that required substitutions will throw an exception if the referenced path does not exist in the configuration. The test expects a HoconException when trying to resolve a non-existent path.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/hocon.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n[Fact]\npublic void UnsolvableSubstitutionWillThrowTest()\n{\n    var exception = Assert.Throws<HoconException>(() =>\n    {\n        var hocon = @\"{\n                a: ${does.not.exist}\n            }\";\n        var config = ConfigurationFactory.ParseString(hocon);\n        return config.GetString(\"a\");\n    });\n\n    Assert.Contains(\"Could not resolve substitution\", exception.Message);\n}\n```\n\n----------------------------------------\n\nTITLE: Akka.Cluster.Sharding Configuration for Migration - HOCON\nDESCRIPTION: This HOCON configuration is necessary for users migrating from persistence to ddata with remember entities enabled, ensuring a proper data migration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/whats-new/akkadotnet-v1.5-upgrade-advisories.md#2025-04-16_snippet_6\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster.sharding {\n    remember-entities = on\n    remember-entities-store = eventsourced\n    state-store-mode = ddata\n\n    # fail if upgrade doesn't succeed\n    fail-on-invalid-entity-state-transition = on\n}\n\nakka.persistence.journal.{your-journal-implementation} {\n    event-adapters {\n        coordinator-migration = \"\"Akka.Cluster.Sharding.OldCoordinatorStateMigrationEventAdapter, Akka.Cluster.Sharding\"\"\n    }\n\n    event-adapter-bindings {\n        \"\"Akka.Cluster.Sharding.ShardCoordinator+IDomainEvent, Akka.Cluster.Sharding\"\" = coordinator-migration\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Expecting No Messages in Akka.NET TestKitBase\nDESCRIPTION: These methods are used to assert that no messages are received within a specified duration in Akka.NET tests. They provide both synchronous and asynchronous versions with options for duration and cancellation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic void ExpectNoMsg(System.Threading.CancellationToken cancellationToken = null) { }\npublic void ExpectNoMsg(System.TimeSpan duration, System.Threading.CancellationToken cancellationToken = null) { }\npublic void ExpectNoMsg(int milliseconds, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.ValueTask ExpectNoMsgAsync(System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.ValueTask ExpectNoMsgAsync(System.TimeSpan duration, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.ValueTask ExpectNoMsgAsync(int milliseconds, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Defining UdpConnected Send Command in Akka.NET\nDESCRIPTION: Command to send data over a UDP connection. Takes a payload as ByteString and optional acknowledgment token. Provides a factory method for creating Send commands without acknowledgment.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_184\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Send : Akka.IO.UdpConnected.Command\n{\n    public Send(Akka.IO.ByteString payload, object ack) { }\n    public object Ack { get; }\n    public Akka.IO.ByteString Payload { get; }\n    public bool WantsAck { get; }\n    public static Akka.IO.UdpConnected.Send Create(Akka.IO.ByteString payload) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RejectedExecutionException Class in C#\nDESCRIPTION: Exception class thrown when a task cannot be executed because the execution system has been shut down or is overloaded. Extends the AkkaException base class for dispatcher-related errors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_99\n\nLANGUAGE: C#\nCODE:\n```\npublic class RejectedExecutionException : Akka.Actor.AkkaException\n{\n    public RejectedExecutionException(string message = null, System.Exception inner = null) { }\n    protected RejectedExecutionException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic IReplicatedData<T> Interface in C#\nDESCRIPTION: Extends IReplicatedData with a generic type parameter T, providing a type-safe Merge method that accepts and returns the specific data type T.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IReplicatedData<T> : Akka.DistributedData.IReplicatedData\n    where T : Akka.DistributedData.IReplicatedData\n{\n    T Merge(T other);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Atomic Counter Interface in C#\nDESCRIPTION: Defines the IAtomicCounter<T> interface that specifies operations for thread-safe counter implementations. This interface is implemented by the AtomicCounter classes for different numeric types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_265\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IAtomicCounter<T>\n{\n    T Current { get; }\n    T AddAndGet(T amount);\n    T GetAndAdd(T amount);\n    T GetAndIncrement();\n    T IncrementAndGet();\n    T Next();\n    void Reset();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Put Message Class for Akka Distributed PubSub in C#\nDESCRIPTION: Defines a sealed Put message class used in Akka's distributed publish-subscribe system to register an actor reference. Implements IEquatable interface for proper comparison and overrides standard object methods.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class Put : System.IEquatable<Akka.Cluster.Tools.PublishSubscribe.Put>\n{\n    public Put(Akka.Actor.IActorRef @ref) { }\n    public Akka.Actor.IActorRef Ref { get; }\n    public bool Equals(Akka.Cluster.Tools.PublishSubscribe.Put other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MetricsGossip message with Google Protocol Buffers for Akka.NET\nDESCRIPTION: This class, `MetricsGossip`, represents a gossip message containing cluster metrics information in Akka.NET. It implements `Google.Protobuf.IDeepCloneable` and `Google.Protobuf.IMessage`, utilizing Google Protocol Buffers for serialization.  It includes fields for all addresses, all metric names, and node metrics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\n    public sealed class MetricsGossip : Google.Protobuf.IDeepCloneable<Akka.Cluster.Metrics.Serialization.MetricsGossip>, Google.Protobuf.IMessage, Google.Protobuf.IMessage<Akka.Cluster.Metrics.Serialization.MetricsGossip>, System.IEquatable<Akka.Cluster.Metrics.Serialization.MetricsGossip>\n    {\n        public const int AllAddressesFieldNumber = 1;\n        public const int AllMetricNamesFieldNumber = 2;\n        public static readonly Akka.Cluster.Metrics.Serialization.MetricsGossip Empty;\n        public const int NodeMetricsFieldNumber = 3;\n        public MetricsGossip() { }\n        public MetricsGossip(Akka.Cluster.Metrics.Serialization.MetricsGossip other) { }\n        public MetricsGossip(System.Collections.Immutable.IImmutableSet<Akka.Cluster.Metrics.Serialization.NodeMetrics> nodes) { }\n        public Google.Protobuf.Collections.RepeatedField<Akka.Cluster.Metrics.Serialization.AddressData> AllAddresses { get; }\n        public Google.Protobuf.Collections.RepeatedField<string> AllMetricNames { get; }\n        public static Google.Protobuf.Reflection.MessageDescriptor Descriptor { get; }\n        public Google.Protobuf.Collections.RepeatedField<Akka.Cluster.Metrics.Serialization.NodeMetrics> NodeMetrics { get; }\n        public System.Collections.Immutable.IImmutableSet<Akka.Cluster.Metrics.Serialization.NodeMetrics> Nodes { get; }\n        public static Google.Protobuf.MessageParser<Akka.Cluster.Metrics.Serialization.MetricsGossip> Parser { get; }\n        public int CalculateSize() { }\n        public Akka.Cluster.Metrics.Serialization.MetricsGossip Clone() { }\n        public override bool Equals(object other) { }\n        public bool Equals(Akka.Cluster.Metrics.Serialization.MetricsGossip other) { }\n        public Akka.Cluster.Metrics.Serialization.MetricsGossip Filter(System.Collections.Immutable.IImmutableSet<Akka.Actor.Address> includeNodes) { }\n        public override int GetHashCode() { }\n        public Akka.Cluster.Metrics.Serialization.MetricsGossip Merge(Akka.Cluster.Metrics.Serialization.MetricsGossip otherGossip) { }\n        public void MergeFrom(Akka.Cluster.Metrics.Serialization.MetricsGossip other) { }\n        public void MergeFrom(Google.Protobuf.CodedInputStream input) { }\n        public Akka.Util.Option<Akka.Cluster.Metrics.Serialization.NodeMetrics> NodeMetricsFor(Akka.Actor.Address address) { }\n        public Akka.Cluster.Metrics.Serialization.MetricsGossip Remove(Akka.Actor.Address node) { }\n        public override string ToString() { }\n        public void WriteTo(Google.Protobuf.CodedOutputStream output) { }\n        public static Akka.Cluster.Metrics.Serialization.MetricsGossip +(Akka.Cluster.Metrics.Serialization.MetricsGossip gossip, Akka.Cluster.Metrics.Serialization.NodeMetrics newNodeMetrics) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Props Class for Actor Configuration in Akka.NET\nDESCRIPTION: Defines the Props class that encapsulates actor creation configuration including constructor arguments, supervision strategy, dispatcher, and mailbox. Provides factory methods for creating actors and configuring their behavior.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\npublic class Props : Akka.Util.ISurrogated, System.IEquatable<Akka.Actor.Props>\n{\n    public static readonly Akka.Actor.Props None;\n    protected Props() { }\n    protected Props(Akka.Actor.Props copy) { }\n    public Props(System.Type type, object[] args) { }\n    public Props(System.Type type) { }\n    public Props(System.Type type, Akka.Actor.SupervisorStrategy supervisorStrategy, System.Collections.Generic.IEnumerable<object> args) { }\n    public Props(System.Type type, Akka.Actor.SupervisorStrategy supervisorStrategy, params object[] args) { }\n    public Props(Akka.Actor.Deploy deploy, System.Type type, System.Collections.Generic.IEnumerable<object> args) { }\n    public Props(Akka.Actor.Deploy deploy, System.Type type, params object[] args) { }\n    public object[] Arguments { get; }\n    public Akka.Actor.Deploy Deploy { get; set; }\n    [Newtonsoft.Json.JsonIgnoreAttribute()]\n    public string Dispatcher { get; }\n    public static Akka.Actor.Props Empty { get; }\n    [Newtonsoft.Json.JsonIgnoreAttribute()]\n    public string Mailbox { get; }\n    [Newtonsoft.Json.JsonIgnoreAttribute()]\n    public Akka.Routing.RouterConfig RouterConfig { get; }\n    public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }\n    [Newtonsoft.Json.JsonIgnoreAttribute()]\n    public System.Type Type { get; }\n    public string TypeName { get; }\n    protected virtual Akka.Actor.Props Copy() { }\n    public static Akka.Actor.Props Create<TActor>(System.Linq.Expressions.Expression<System.Func<TActor>> factory, Akka.Actor.SupervisorStrategy supervisorStrategy = null)\n        where TActor : Akka.Actor.ActorBase { }\n    public static Akka.Actor.Props Create<TActor>(params object[] args)\n        where TActor : Akka.Actor.ActorBase { }\n    public static Akka.Actor.Props Create<TActor>(Akka.Actor.SupervisorStrategy supervisorStrategy)\n        where TActor : Akka.Actor.ActorBase, new () { }\n    public static Akka.Actor.Props Create(System.Type type, params object[] args) { }\n    [System.ObsoleteAttribute(\"Do not use this method. Call CreateBy(IIndirectActorProducer, params object[] arg\" +\n        \"s) instead\")]\n    public static Akka.Actor.Props CreateBy<TProducer>(params object[] args)\n        where TProducer :  class, Akka.Actor.IIndirectActorProducer { }\n    public static Akka.Actor.Props CreateBy(Akka.Actor.IIndirectActorProducer producer, params object[] args) { }\n    public bool Equals(Akka.Actor.Props other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public virtual Akka.Actor.ActorBase NewActor() { }\n    public Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Actor.Props WithDeploy(Akka.Actor.Deploy deploy) { }\n    public Akka.Actor.Props WithDispatcher(string dispatcher) { }\n    public Akka.Actor.Props WithMailbox(string mailbox) { }\n    public Akka.Actor.Props WithRouter(Akka.Routing.RouterConfig routerConfig) { }\n    public Akka.Actor.Props WithStashCapacity(int stashCapacity) { }\n    public Akka.Actor.Props WithSupervisorStrategy(Akka.Actor.SupervisorStrategy supervisorStrategy) { }\n```\n\n----------------------------------------\n\nTITLE: Defining IPendingHandlerInvocation Interface in C#\nDESCRIPTION: This snippet defines the IPendingHandlerInvocation interface, which is used to encapsulate events and corresponding handlers for pending invocations in Akka's persistence framework, allowing for deferred processing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IPendingHandlerInvocation\n{\n    object Event { get; }\n    System.Action<object> Handler { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Adaptive Load Balancing Group Router in C#\nDESCRIPTION: Demonstrates how to create an adaptive load balancing group router in C# code.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-metrics.md#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n[!code-csharp[RouterInCodeSample](../../../src/core/Akka.Docs.Tests/Cluster.Metrics/RouterInCodeSample.cs?name=RouterInCodeSample1)]\n```\n\n----------------------------------------\n\nTITLE: Implementing ILoggingAdapter Interface in C#\nDESCRIPTION: Interface that defines the core logging capabilities with methods for checking log level enablement and logging messages at different levels. It provides access to the formatter and methods to check if specific log levels are enabled.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_129\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ILoggingAdapter\n{\n    Akka.Event.ILogMessageFormatter Formatter { get; }\n    bool IsDebugEnabled { get; }\n    bool IsErrorEnabled { get; }\n    bool IsInfoEnabled { get; }\n    bool IsWarningEnabled { get; }\n    bool IsEnabled(Akka.Event.LogLevel logLevel);\n    void Log(Akka.Event.LogLevel logLevel, System.Exception cause, string format);\n    void Log(Akka.Event.LogLevel logLevel, System.Exception cause, Akka.Event.LogMessage message);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MultiVersionVector Class for Akka.NET Distributed Data in C#\nDESCRIPTION: Defines the MultiVersionVector class, a specialized version vector for distributed data. It includes constructors, properties for version information, and methods for incrementing, merging, and pruning versions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class MultiVersionVector : Akka.DistributedData.VersionVector\n{\n    public MultiVersionVector(params System.Collections.Generic.KeyValuePair<, >[] nodeVersions) { }\n    public MultiVersionVector(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<Akka.Cluster.UniqueAddress, long>> versions) { }\n    public MultiVersionVector(System.Collections.Immutable.ImmutableDictionary<Akka.Cluster.UniqueAddress, long> nodeVersions) { }\n    public override int Count { get; }\n    public override bool IsEmpty { get; }\n    public override System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.UniqueAddress> ModifiedByNodes { get; }\n    public override System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<Akka.Cluster.UniqueAddress, long>> VersionEnumerator { get; }\n    public override bool Contains(Akka.Cluster.UniqueAddress node) { }\n    public override int GetHashCode() { }\n    public override Akka.DistributedData.VersionVector Increment(Akka.Cluster.UniqueAddress node) { }\n    public override Akka.DistributedData.VersionVector Merge(Akka.DistributedData.VersionVector other) { }\n    public override bool NeedPruningFrom(Akka.Cluster.UniqueAddress removedNode) { }\n    public override Akka.DistributedData.VersionVector Prune(Akka.Cluster.UniqueAddress removedNode, Akka.Cluster.UniqueAddress collapseInto) { }\n    public override Akka.DistributedData.VersionVector PruningCleanup(Akka.Cluster.UniqueAddress removedNode) { }\n    public override string ToString() { }\n    public override long VersionAt(Akka.Cluster.UniqueAddress node) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Expanding a stream with Akka.NET\nDESCRIPTION: This snippet shows how to use `Expand` to send the same element to the consumer repeatedly when the producer doesn't send new elements. It extrapolates the last received value indefinitely, useful for scenarios where the consumer requires a continuous stream.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/buffersandworkingwithrate.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n var lastFlow = Flow.Create<int>()\n        .Expand(_ => Enumerable.Repeat(_, int.MaxValue).GetEnumerator()); \n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Journal Interceptor for Testing in C#\nDESCRIPTION: Demonstrates how to implement and use a custom journal interceptor for testing persistent actors. The example shows setting up the interceptor and asserting on collected events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistence-testing.md#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n    [Fact]\n    public async Task Custom_interceptor_example_direct_usage()\n    {\n        var interceptor = new MyCollectingInterceptor();\n        //Journal also has OnRecovery and OnConnect options.\n        Journal.OnWrite.SetInterceptorAsync(interceptor);\n\n        //perform test code here\n\n        //assert at the end\n        Assert.IsTrue(interceptor.HasEventsThatIExpect());\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing IdentityEventAdapter for Akka.NET Persistence\nDESCRIPTION: This class implements a simple identity event adapter for Akka.NET persistence, which passes events through without modification.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class IdentityEventAdapter : Akka.Persistence.Journal.IEventAdapter, Akka.Persistence.Journal.IReadEventAdapter, Akka.Persistence.Journal.IWriteEventAdapter\n{\n    public static Akka.Persistence.Journal.IdentityEventAdapter Instance { get; }\n    public Akka.Persistence.Journal.IEventSequence FromJournal(object evt, string manifest) { }\n    public string Manifest(object evt) { }\n    public object ToJournal(object evt) { }\n}\n```\n\n----------------------------------------\n\nTITLE: InetAddressDnsProvider in Akka.NET for Standard DNS Resolution\nDESCRIPTION: Implements the IDnsProvider interface for standard DNS resolution using the .NET InetAddress functionality. This class provides basic DNS resolution capabilities through the system's DNS infrastructure.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_162\n\nLANGUAGE: C#\nCODE:\n```\npublic class InetAddressDnsProvider : Akka.IO.IDnsProvider\n    {\n        public InetAddressDnsProvider() { }\n        public System.Type ActorClass { get; }\n        public Akka.IO.DnsBase Cache { get; }\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterMetricsChanged Event in Akka.NET\nDESCRIPTION: Defines an event class that is published when cluster metrics change. This event contains the updated node metrics and implements the IClusterMetricsEvent interface.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterMetricsChanged : Akka.Cluster.Metrics.Events.IClusterMetricsEvent\n{\n    public ClusterMetricsChanged(System.Collections.Immutable.IImmutableSet<Akka.Cluster.Metrics.Serialization.NodeMetrics> nodeMetrics) { }\n    public System.Collections.Immutable.IImmutableSet<Akka.Cluster.Metrics.Serialization.NodeMetrics> NodeMetrics { get; }\n}\npublic interface IClusterMetricsEvent { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Console Output Utility in C#\nDESCRIPTION: Provides a StandardOutWriter static class with methods for writing to the console with optional color formatting. This utility simplifies colored console output for logging and user feedback.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_253\n\nLANGUAGE: C#\nCODE:\n```\npublic class static StandardOutWriter\n{\n    public static void Write(string message, System.Nullable<System.ConsoleColor> foregroundColor = null, System.Nullable<System.ConsoleColor> backgroundColor = null) { }\n    public static void WriteLine(string message, System.Nullable<System.ConsoleColor> foregroundColor = null, System.Nullable<System.ConsoleColor> backgroundColor = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RandomPool Router in HOCON Configuration\nDESCRIPTION: Shows how to define a random pool router in HOCON configuration. This router type will distribute messages randomly among routees.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_12\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.deployment {\n  /some-pool {\n    router = random-pool\n    nr-of-instances = 5\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Utility Methods for Message Handling in Akka.NET TestKitBase\nDESCRIPTION: These methods provide utility functions for handling messages, including ignoring specific messages, initializing tests, and awaiting conditions. They support various scenarios and configurations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic System.TimeSpan GetTimeoutOrDefault(System.Nullable<System.TimeSpan> timeout) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic void IgnoreMessages(System.Func<object, bool> shouldIgnoreMessage) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\nprotected virtual void InitializeTest(Akka.Actor.ActorSystem system, Akka.Actor.Setup.ActorSystemSetup config, string actorSystemName, string testActorName) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\nprotected static bool InternalAwaitCondition(System.Func<bool> conditionIsFulfilled, System.TimeSpan max, System.Nullable<System.TimeSpan> interval, System.Action<string, object[]> fail, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing UnboundedPriorityMessageQueue for Akka.NET in C#\nDESCRIPTION: A priority-based message queue that orders messages based on a priority generator function. It extends BlockingMessageQueue and provides methods for priority-based message handling with no capacity constraints.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_109\n\nLANGUAGE: C#\nCODE:\n```\npublic class UnboundedPriorityMessageQueue : Akka.Dispatch.MessageQueues.BlockingMessageQueue, Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics, Akka.Dispatch.IUnboundedMessageQueueSemantics\n{\n    public UnboundedPriorityMessageQueue(System.Func<object, int> priorityGenerator, int initialCapacity) { }\n    protected override int LockedCount { get; }\n    public void EnqueueFirst(Akka.Actor.Envelope envelope) { }\n    protected override void LockedEnqueue(Akka.Actor.Envelope envelope) { }\n    protected override bool LockedTryDequeue(out Akka.Actor.Envelope envelope) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Debug Log Event Class in Akka.NET\nDESCRIPTION: Log event class for debug-level messages. Extends LogEvent and provides constructors for creating debug messages with or without an associated exception.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_119\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Debug : Akka.Event.LogEvent\n{\n    public Debug(string logSource, System.Type logClass, object message) { }\n    public Debug(System.Exception cause, string logSource, System.Type logClass, object message) { }\n    public override Akka.Event.LogLevel LogLevel() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DistributedPubSub extension in C#\nDESCRIPTION: Defines the DistributedPubSub extension for Akka.NET, providing access to the mediator and configuration. It includes methods for creating and accessing the extension.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DistributedPubSub : Akka.Actor.IExtension\n{\n    public DistributedPubSub(Akka.Actor.ExtendedActorSystem system) { }\n    public bool IsTerminated { get; }\n    public Akka.Actor.IActorRef Mediator { get; }\n    public static Akka.Configuration.Config DefaultConfig() { }\n    public static Akka.Cluster.Tools.PublishSubscribe.DistributedPubSub Get(Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Standard Metrics Constants and Classes\nDESCRIPTION: Static class defining standard metric types and helper methods for CPU and memory metrics extraction in Akka.NET clusters.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Core.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic class static StandardMetrics\n{\n    public const string CpuProcessUsage = \"CpuProcessUsage\";\n    public const string CpuTotalUsage = \"CpuTotalUsage\";\n    public const string MaxMemoryRecommended = \"MaxMemoryRecommended\";\n    public const string MemoryAvailable = \"MemoryAvailable\";\n    public const string MemoryUsed = \"MemoryUsed\";\n    public const string Processors = \"Processors\";\n    public static Akka.Util.Option<Akka.Cluster.Metrics.StandardMetrics.Cpu> ExtractCpu(Akka.Cluster.Metrics.Serialization.NodeMetrics nodeMetrics) { }\n    public static Akka.Util.Option<Akka.Cluster.Metrics.StandardMetrics.Memory> ExtractMemory(Akka.Cluster.Metrics.Serialization.NodeMetrics nodeMetrics) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Option<T> Struct for Optional Values in C#\nDESCRIPTION: Defines an Option<T> struct that represents an optional value. It provides methods for creating, comparing, and manipulating optional values, similar to the Maybe monad in functional programming.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_220\n\nLANGUAGE: C#\nCODE:\n```\npublic struct Option<T>\n{\n    public static readonly Akka.Util.Option<T> None;\n    [System.ObsoleteAttribute(\"Use Option<T>.Create() instead\")]\n    public Option(T value) { }\n    public bool HasValue { get; }\n    public bool IsEmpty { get; }\n    public T Value { get; }\n    public static Akka.Util.Option<T> Create(T value) { }\n    public bool Equals(Akka.Util.Option<T> other) { }\n    public override bool Equals(object obj) { }\n    public Akka.Util.Option<TNew> FlatSelect<TNew>(System.Func<T, Akka.Util.Option<TNew>> mapper) { }\n    public override int GetHashCode() { }\n    public T GetOrElse(T fallbackValue) { }\n    public void OnSuccess(System.Action<T> action) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dispatchers and ExecutorService in C#\nDESCRIPTION: Defines classes for managing dispatchers and executor services in Akka.NET. Includes DispatcherConfigurator, Dispatchers, ExecutorService, and related classes for configuring and managing message dispatching and execution.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_98\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DispatcherConfigurator : Akka.Dispatch.MessageDispatcherConfigurator\n{\n    public DispatcherConfigurator(Akka.Configuration.Config config, Akka.Dispatch.IDispatcherPrerequisites prerequisites) { }\n    public override Akka.Dispatch.MessageDispatcher Dispatcher() { }\n}\npublic sealed class Dispatchers\n{\n    public const string DefaultBlockingDispatcherId = \"akka.actor.default-blocking-io-dispatcher\";\n    public const string DefaultDispatcherId = \"akka.actor.default-dispatcher\";\n    public const string SynchronizedDispatcherId = \"akka.actor.synchronized-dispatcher\";\n    public Dispatchers(Akka.Actor.ActorSystem system, Akka.Dispatch.IDispatcherPrerequisites prerequisites, Akka.Event.ILoggingAdapter logger) { }\n    public Akka.Configuration.Config DefaultDispatcherConfig { get; }\n    public Akka.Dispatch.MessageDispatcher DefaultGlobalDispatcher { get; }\n    public Akka.Dispatch.IDispatcherPrerequisites Prerequisites { get; }\n    [Akka.Annotations.InternalApiAttribute()]\n    public static Akka.Configuration.Config GetConfig(Akka.Configuration.Config config, string id, int depth = 0) { }\n    public bool HasDispatcher(string id) { }\n    public Akka.Dispatch.MessageDispatcher Lookup(string dispatcherName) { }\n    public bool RegisterConfigurator(string id, Akka.Dispatch.MessageDispatcherConfigurator configurator) { }\n}\npublic abstract class ExecutorService\n{\n    protected ExecutorService(string id) { }\n    public string Id { get; }\n    public abstract void Execute(Akka.Dispatch.IRunnable run);\n    public abstract void Shutdown();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DefaultLogMessageFormatter Class in C#\nDESCRIPTION: A class that implements the ILogMessageFormatter interface to provide standard log message formatting. It contains methods to format log messages with variable arguments.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_118\n\nLANGUAGE: C#\nCODE:\n```\npublic class DefaultLogMessageFormatter : Akka.Event.ILogMessageFormatter\n{\n    public static readonly Akka.Event.DefaultLogMessageFormatter Instance;\n    public string Format(string format, params object[] args) { }\n    public string Format(string format, System.Collections.Generic.IEnumerable<object> args) { }\n}\n```\n\n----------------------------------------\n\nTITLE: DiscoveryProvider Class Definition in C#\nDESCRIPTION: Provides the extension mechanism for the Discovery API in Akka.NET. This class creates the Discovery extension when it's accessed for the first time in an actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.DotNet.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class DiscoveryProvider : Akka.Actor.ExtensionIdProvider<Akka.Discovery.Discovery>\n{\n    public DiscoveryProvider() { }\n    public override Akka.Discovery.Discovery CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n    public static Akka.Configuration.Config DefaultConfiguration() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Remote Settings Configuration in C#\nDESCRIPTION: Configuration class for remote actor system settings including timeouts, buffer sizes, and transport configuration. Handles both system-level and transport-specific settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class RemoteSettings {\n    public static readonly string AkkaScheme;\n    public RemoteSettings(Akka.Configuration.Config config) { }\n    public System.Collections.Generic.IDictionary<string, string> Adapters { get; set; }\n    public System.TimeSpan BackoffPeriod { get; set; }\n    // ... additional properties omitted for brevity\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WeightedRoutees Internal Class in C#\nDESCRIPTION: Internal class for managing weighted routees in a cluster. Provides functionality for accessing routees by index and determining the total weight across all routees, which is used for routing messages based on node metrics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.DotNet.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic class WeightedRoutees\n{\n    public WeightedRoutees(System.Collections.Immutable.ImmutableArray<Akka.Routing.Routee> routees, Akka.Actor.Address selfAddress, System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, int> weights) { }\n    public bool IsEmpty { get; }\n    public Akka.Routing.Routee this[int value] { get; }\n    public int Total { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ORMultiValueDictionary Class in C#\nDESCRIPTION: This class represents a distributed multi-value dictionary in Akka.NET. It provides methods for adding, removing, and managing key-value pairs across distributed nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\npublic class ORMultiValueDictionary<TKey, TValue> {\n    public bool DeltaValues { get; }\n    public System.Collections.Immutable.IImmutableDictionary<TKey, System.Collections.Immutable.IImmutableSet<TValue>> Entries { get; }\n    public bool IsEmpty { get; }\n    public System.Collections.Immutable.IImmutableSet<TValue> this[TKey key] { get; }\n    public System.Type KeyType { get; }\n    public System.Collections.Generic.IEnumerable<TKey> Keys { get; }\n    public System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.UniqueAddress> ModifiedByNodes { get; }\n    public System.Type ValueType { get; }\n    public System.Collections.Generic.IEnumerable<TValue> Values { get; }\n    // ... (methods omitted for brevity)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TailChoppingGroup Class in Akka.NET\nDESCRIPTION: Router configuration for TailChopping strategy operating on a predefined group of actor paths. Sends messages to actors in sequence until a response is received or timeout occurs.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_220\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class TailChoppingGroup : Akka.Routing.Group\n{\n```\n\n----------------------------------------\n\nTITLE: Pushing Events to Output Ports - Scala\nDESCRIPTION: This snippet describes how to push elements to output ports within Akka's GraphStage logic. The method `Push(out, elem)` is utilized to emit new events to downstream consumers after the port has been pulled. Other methods such as `Complete(out)` and `Fail(out, exception)` handle normal and failure closure of the port respectively. This snippet is integral for managing the lifecycle of output events in stream processing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/custom-stream-processing.md#2025-04-16_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nPush(out, elem)\nComplete(out)\nFail(out, exception)\n```\n\n----------------------------------------\n\nTITLE: Configuring Split Brain Resolver Stability Settings in HOCON\nDESCRIPTION: HOCON configuration example showing how to set custom values for down-all-when-unstable and stable-after parameters in Akka.NET Split Brain Resolver. These settings control how the cluster handles network instability and partition scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/split-brain-resolver.md#2025-04-16_snippet_9\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster.split-brain-resolver {\n    down-all-when-unstable = 15s\n    stable-after = 20s\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Key Base Class for Distributed Data\nDESCRIPTION: Abstract base class for distributed data keys that provides common functionality like equality comparison and string representation. This serves as a foundation for specific key implementations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Key<T> : Akka.DistributedData.IKey, Akka.DistributedData.IKey<T>, Akka.DistributedData.IReplicatedDataSerialization\n    where T : Akka.DistributedData.IReplicatedData\n{\n    protected Key(string id) { }\n    public string Id { get; }\n    public bool Equals(Akka.DistributedData.IKey key) { }\n    public virtual bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n    public static string op_Implicit(Akka.DistributedData.Key<T> key) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UdpConnected Extension Class in C#\nDESCRIPTION: Defines the UdpConnected extension class that provides support for connection-oriented UDP sockets in Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_172\n\nLANGUAGE: C#\nCODE:\n```\npublic class UdpConnected : Akka.Actor.ExtensionIdProvider<Akka.IO.UdpConnectedExt>\n{\n    public static readonly Akka.IO.UdpConnected Instance;\n    public UdpConnected() { }\n    public override Akka.IO.UdpConnectedExt CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n\n```\n\n----------------------------------------\n\nTITLE: Association Handle Base Class\nDESCRIPTION: Abstract base class for handling remote actor associations, providing core functionality for connection management and message writing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AssociationHandle\n{\n    protected AssociationHandle(Akka.Actor.Address localAddress, Akka.Actor.Address remoteAddress) { }\n    public Akka.Actor.Address LocalAddress { get; set; }\n    public System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.IHandleEventListener> ReadHandlerSource { get; set; }\n    public Akka.Actor.Address RemoteAddress { get; set; }\n    public abstract bool Write(Google.Protobuf.ByteString payload);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Fraud Role in Akka.NET Cluster\nDESCRIPTION: HOCON configuration for setting up a cluster node with the 'fraud' role, which will handle fraud detection operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/member-roles.md#2025-04-16_snippet_1\n\nLANGUAGE: hocon\nCODE:\n```\nakka\n{\n  cluster\n  {\n    roles = [\"fraud\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly Metadata and Visibility Declarations for Akka.Persistence\nDESCRIPTION: Assembly-level attributes that define metadata, internals visibility, and framework targeting for the Akka.Persistence assembly. These declarations expose internals to related packages and specify the target framework as .NET Standard 2.0.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Persistence.TCK\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Persistence.Tests\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"e3bcba88-003c-4cda-8a60-f0c2553fe3c8\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\"\")]\n```\n\n----------------------------------------\n\nTITLE: Configuring Message Chunking in Akka.Delivery with HOCON\nDESCRIPTION: HOCON configuration that enables message chunking for Akka.Delivery, which breaks large messages into smaller chunks. The example sets a 100-byte chunk size.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/reliable-delivery.md#2025-04-16_snippet_5\n\nLANGUAGE: hocon\nCODE:\n```\nakka.reliable-delvery.producer-controller.chunk-large-messages = 100b #100b chunks, off by default\n```\n\n----------------------------------------\n\nTITLE: Dropped Message Class in Akka.NET\nDESCRIPTION: Sealed class extending AllDeadLetters to represent a dropped message. Contains the dropped message, a reason for dropping, and sender/recipient information.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_122\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class Dropped : Akka.Event.AllDeadLetters\n{\n    public Dropped(object message, string reason, Akka.Actor.IActorRef sender, Akka.Actor.IActorRef recipient) { }\n    public Dropped(object message, string reason, Akka.Actor.IActorRef recipient) { }\n    public string Reason { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WritingResumed Event Class in C#\nDESCRIPTION: Defines the WritingResumed event class used to signal that writing to a TCP socket has been resumed after being suspended.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_166\n\nLANGUAGE: C#\nCODE:\n```\npublic class WritingResumed : Akka.IO.Tcp.Event\n{\n    public static readonly Akka.IO.Tcp.WritingResumed Instance;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TestAssociationHandle for Akka.NET Remote Testing\nDESCRIPTION: Test implementation of an association handle for remote transport testing. Provides methods for disassociation and writing, with tracking of whether the connection is inbound or outbound.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class TestAssociationHandle : Akka.Remote.Transport.AssociationHandle\n{\n    public readonly bool Inbound;\n    public TestAssociationHandle(Akka.Actor.Address localAddress, Akka.Actor.Address remoteAddress, Akka.Remote.Transport.TestTransport transport, bool inbound) { }\n    public System.ValueTuple<Akka.Actor.Address, Akka.Actor.Address> Key { get; }\n    public override void Disassociate() { }\n    public override bool Write(Google.Protobuf.ByteString payload) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Config Class Methods in C#\nDESCRIPTION: This snippet shows the method signatures for various operations on the Config class, including getting values, checking paths, and working with fallback configurations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_70\n\nLANGUAGE: C#\nCODE:\n```\npublic virtual System.Collections.Generic.IList<string> GetStringList(string path) { }\npublic virtual System.Collections.Generic.IList<string> GetStringList(string path, string[] defaultPaths) { }\npublic virtual System.TimeSpan GetTimeSpan(string path, System.Nullable<System.TimeSpan> default = null, bool allowInfinite = True) { }\npublic Akka.Configuration.Hocon.HoconValue GetValue(string path) { }\npublic virtual bool HasPath(string path) { }\npublic override string ToString() { }\npublic string ToString(bool includeFallback) { }\npublic virtual Akka.Configuration.Config WithFallback(Akka.Configuration.Config fallback) { }\npublic static Akka.Configuration.Config +(Akka.Configuration.Config config, string fallback) { }\npublic static Akka.Configuration.Config +(string configHocon, Akka.Configuration.Config fallbackConfig) { }\npublic static Akka.Configuration.Config op_Implicit(string str) { }\n```\n\n----------------------------------------\n\nTITLE: Creating Test Output Logger Actor\nDESCRIPTION: Defines `TestOutputLogger`, an Akka.NET actor used to log test outputs by implementing the `ReceiveActor` class and utilizing an `ITestOutputHelper` instance.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKitXunit2.DotNet.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.TestKit.Xunit2.Internals\n{\n    public class TestOutputLogger : Akka.Actor.ReceiveActor\n    {\n        public TestOutputLogger(Xunit.Abstractions.ITestOutputHelper output) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Stash Capacity with HOCON in Akka.NET\nDESCRIPTION: This HOCON configuration shows how to set the stash capacity for an actor through the `akka.actor.deployment` settings. The `stash-capacity` property defines the maximum number of messages that can be stored in the stash for the specified actor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_28\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.deployment{{\n    /configStashingActor {{\n        stash-capacity = 2\n    }}\n}}\n```\n\n----------------------------------------\n\nTITLE: Implementing ORMultiValueDictionaryKey Class for Akka.NET Distributed Data in C#\nDESCRIPTION: Defines the ORMultiValueDictionaryKey class representing a key for ORMultiValueDictionary<TKey, TValue>. It includes a constructor and properties for key and value types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ORMultiValueDictionaryKey<TKey, TValue> : Akka.DistributedData.Key<Akka.DistributedData.ORMultiValueDictionary<TKey, TValue>>\n{\n    public ORMultiValueDictionaryKey(string id) { }\n    public System.Type KeyType { get; }\n    public System.Type ValueType { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing QueryConfiguration Class in C#\nDESCRIPTION: A class containing configuration settings for SQL journal queries, including table and column names, schema name, and query timeout. Note that one constructor is marked as obsolete in favor of a newer one that accepts isolation levels.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic class QueryConfiguration\n{\n    public readonly string IsDeletedColumnName;\n    public readonly string JournalEventsTableName;\n    public readonly string ManifestColumnName;\n    public readonly string MetaTableName;\n    public readonly string OrderingColumnName;\n    public readonly string PayloadColumnName;\n    public readonly string PersistenceIdColumnName;\n    public readonly string SchemaName;\n    public readonly string SequenceNrColumnName;\n    public readonly string SerializerIdColumnName;\n    public readonly string TagsColumnName;\n    public readonly System.TimeSpan Timeout;\n    public readonly string TimestampColumnName;\n    [System.ObsoleteAttribute(\"Use .ctor that accepts read and write IsolationLevel instead (since v1.5.2)\")]\n```\n\n----------------------------------------\n\nTITLE: Defining NodeMetrics message with Google Protocol Buffers for Akka.NET\nDESCRIPTION: This class, `NodeMetrics`, represents the metrics of a single node in the cluster within Akka.NET. It includes the address of the node, a timestamp, and a collection of individual metric values.  It utilizes Google Protocol Buffers for serialization and data representation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class NodeMetrics : Google.Protobuf.IDeepCloneable<Akka.Cluster.Metrics.Serialization.NodeMetrics>, Google.Protobuf.IMessage, Google.Protobuf.IMessage<Akka.Cluster.Metrics.Serialization.NodeMetrics>, System.IEquatable<Akka.Cluster.Metrics.Serialization.NodeMetrics>\n    {\n        public const int AddressIndexFieldNumber = 1;\n        public const int MetricsFieldNumber = 3;\n        public const int TimestampFieldNumber = 2;\n        public NodeMetrics() { }\n        public NodeMetrics(Akka.Cluster.Metrics.Serialization.NodeMetrics other) { }\n        public NodeMetrics(Akka.Actor.Address address, long timestamp, System.Collections.Generic.IEnumerable<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric> metrics) { }\n        public Akka.Actor.Address Address { get; }\n        public int AddressIndex { get; set; }\n        public static Google.Protobuf.Reflection.MessageDescriptor Descriptor { get; }\n        public Google.Protobuf.Collections.RepeatedField<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric> Metrics { get; }\n        public static Google.Protobuf.MessageParser<Akka.Cluster.Metrics.Serialization.NodeMetrics> Parser { get; }\n        public long Timestamp { get; set; }\n        public int CalculateSize() { }\n        public Akka.Cluster.Metrics.Serialization.NodeMetrics Clone() { }\n        public bool Equals(Akka.Cluster.Metrics.Serialization.NodeMetrics other) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing OneForOneStrategySurrogate Class for Serialization\nDESCRIPTION: Provides serialization support for OneForOneStrategy through the ISurrogate interface. Stores the strategy's configuration including retries, timeouts, and logging settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic class OneForOneStrategySurrogate : Akka.Util.ISurrogate\n{\n    public OneForOneStrategySurrogate() { }\n    public Akka.Actor.IDecider Decider { get; set; }\n    public bool LoggingEnabled { get; set; }\n    public int MaxNumberOfRetries { get; set; }\n    public int WithinTimeRangeMilliseconds { get; set; }\n    public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: RegisterTerminationHook Message in Akka.NET\nDESCRIPTION: Message for registering a termination hook. Uses the singleton pattern with an Instance property to access the shared instance.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_101\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class RegisterTerminationHook\n{\n    public static Akka.Dispatch.SysMsg.RegisterTerminationHook Instance { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IAtomicCounter<T> Interface\nDESCRIPTION: Generic interface for atomic counter implementations providing thread-safe operations. It defines methods for incrementing, adding, and resetting counter values.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_228\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.Util.Internal\n{\n    public interface IAtomicCounter<T>\n    {\n        T Current { get; }\n        T AddAndGet(T amount);\n        T GetAndAdd(T amount);\n        T GetAndIncrement();\n        T IncrementAndGet();\n        T Next();\n        void Reset();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Try<T> Monad Pattern in C#\nDESCRIPTION: Defines a Try<T> class implementing the Try monad pattern which represents a computation that may either result in a value or an exception. Includes methods for handling both success and failure cases in a functional style.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_258\n\nLANGUAGE: C#\nCODE:\n```\npublic class Try<T>\n{\n    public Try(T success) { }\n    public Try(System.Exception failure) { }\n    public Akka.Util.Option<System.Exception> Failure { get; }\n    public bool IsSuccess { get; }\n    public Akka.Util.Option<T> Success { get; }\n    public static Akka.Util.Try<T> From(System.Func<T> func) { }\n    public T Get() { }\n    public Akka.Util.Try<T> GetOrElse(System.Func<T> fallback) { }\n    public Akka.Util.Try<T> OrElse(Akka.Util.Try<T> @default) { }\n    public Akka.Util.Try<T> Recover(System.Action<System.Exception> failureHandler) { }\n    public Akka.Util.Try<T> RecoverWith(System.Func<System.Exception, Akka.Util.Try<T>> failureHandler) { }\n    public static Akka.Util.Try<T> op_Implicit(T value) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Action Runnables for Akka.NET Dispatch in C#\nDESCRIPTION: Two classes for wrapping actions as runnables that implement both IRunnable and IThreadPoolWorkItem interfaces. ActionRunnable handles simple actions, while ActionWithStateRunnable handles actions with state parameters.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_81\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class ActionRunnable : Akka.Dispatch.IRunnable, System.Threading.IThreadPoolWorkItem\n{\n    public ActionRunnable(System.Action action) { }\n    public void Execute() { }\n    public void Run() { }\n}\n\npublic sealed class ActionWithStateRunnable : Akka.Dispatch.IRunnable, System.Threading.IThreadPoolWorkItem\n{\n    public ActionWithStateRunnable(System.Action<object> actionWithState, object state) { }\n    public void Execute() { }\n    public void Run() { }\n}\n```\n\n----------------------------------------\n\nTITLE: SplitBrainResolver Class Definition\nDESCRIPTION: This snippet defines a sealed class `SplitBrainResolver` that implements `Akka.Cluster.IDowningProvider`.  It represents a strategy for automatically downing nodes during a split-brain scenario.  It includes a `StableAfter` property, which likely defines how long the cluster must be stable before downing decisions are made. The `DownRemovalMargin` and `DowningActorProps` properties are defined.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class SplitBrainResolver : Akka.Cluster.IDowningProvider\n{\n    public SplitBrainResolver(Akka.Actor.ActorSystem system, Akka.Cluster.Cluster cluster) { }\n    public System.TimeSpan DownRemovalMargin { get; }\n    public Akka.Actor.Props DowningActorProps { get; }\n    public System.TimeSpan StableAfter { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Rich Event Classes in C#\nDESCRIPTION: Definition of RichEvent and QueryMetadata classes for enhanced event querying with materialized values.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistence-query.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic class RichEvent\n{\n    public RichEvent(ISet<string> tags, object payload)\n    {\n        Tags = tags;\n        Payload = payload;\n    }\n\n    public ISet<string> Tags { get; }\n    public object Payload { get; }\n}\n\npublic class QueryMetadata\n{\n    public QueryMetadata(bool deterministicOrder, bool infinite)\n    {\n        DeterministicOrder = deterministicOrder;\n        Infinite = infinite;\n    }\n\n    public bool DeterministicOrder { get; }\n    public bool Infinite { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TraceLogger Class in Akka.NET\nDESCRIPTION: A logger that implements UntypedActor for tracing messages in the actor system. The class signature is shown but the implementation details are not provided in the snippet.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_144\n\nLANGUAGE: C#\nCODE:\n```\npublic class TraceLogger : Akka.Actor.UntypedActor\n{\n}\n```\n\n----------------------------------------\n\nTITLE: BecomeStacked/UnbecomeStacked Example in Akka.NET\nDESCRIPTION: This snippet demonstrates how to use `BecomeStacked` and `UnbecomeStacked` to push and pop behavior from the behavior stack. Care must be taken to ensure that the number of `UnbecomeStacked` calls matches the number of `BecomeStacked` calls.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_29\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Swapper : ReceiveActor\n{\n    public class Swap\n    {\n        public static Swap Instance = new Swap();\n        private Swap() { }\n    }\n\n    private ILoggingAdapter log = Context.GetLogger();\n\n    public Swapper()\n    {\n        Receive<Swap>(swap1 =>\n        {\n            log.Info(\"Hi\");\n\n            BecomeStacked(() =>\n            {\n                Receive<Swap>(swap2 =>\n                {\n                    log.Info(\"Ho\");\n                    UnbecomeStacked();\n                });\n            });\n        });\n    }\n}\n...\n\nstatic void Main(string[] args)\n{\n    var system = ActorSystem.Create(\"MySystem\");\n    var swapper = system.ActorOf<Swapper>();\n\n    swapper.Tell(Swapper.SWAP);\n    swapper.Tell(Swapper.SWAP);\n    swapper.Tell(Swapper.SWAP);\n    swapper.Tell(Swapper.SWAP);\n    swapper.Tell(Swapper.SWAP);\n    swapper.Tell(Swapper.SWAP);\n\n    Console.ReadLine();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SwitchableLoggedBehavior Generic Class in Akka.NET Remote Transport\nDESCRIPTION: A utility class that allows switching between different behaviors while logging inputs, used primarily in testing scenarios for Akka.NET's transport system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic class SwitchableLoggedBehavior<TIn, TOut>\n{\n    public SwitchableLoggedBehavior(System.Func<TIn, System.Threading.Tasks.Task<TOut>> defaultBehavior, System.Action<TIn> logCallback) { }\n    public System.Func<TIn, System.Threading.Tasks.Task<TOut>> CurrentBehavior { get; }\n    public System.Func<TIn, System.Threading.Tasks.Task<TOut>> DefaultBehavior { get; }\n    public System.Action<TIn> LogCallback { get; }\n    public System.Threading.Tasks.Task<TOut> Apply(TIn param) { }\n    public void Pop() { }\n    public void Push(System.Func<TIn, System.Threading.Tasks.Task<TOut>> behavior) { }\n    public void PushConstant(TOut result) { }\n    public System.Threading.Tasks.TaskCompletionSource<bool> PushDelayed() { }\n    public void PushError(System.Exception e) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Akka.NET Serializers using HOCON\nDESCRIPTION: This code snippet demonstrates how to manually register serializers for Akka.Cluster.Tools and Akka.Cluster.Sharding using HOCON configuration. It combines custom HOCON with default configurations for various cluster components.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/deployment/akkacluster-troubleshooting.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nConfig myHocon = ConfigurationFactory.ParseString(\"{hocon}\");\nConfig fullHocon = myHocon.WithFallback(ClusterSharding.DefaultConfig()\n                .WithFallback(ClusterSingletonManager.DefaultConfig())\n                .WithFallback(DistributedPubSub.DefaultConfig())\n                .WithFallback(ClusterClientReceptionist.DefaultConfig()));\n```\n\n----------------------------------------\n\nTITLE: Metric Type Implementation\nDESCRIPTION: Implementation of the Metric type for representing individual metrics with support for EWMA calculations and protobuf serialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Core.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Metric : Google.Protobuf.IDeepCloneable<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric>, Google.Protobuf.IMessage, Google.Protobuf.IMessage<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric>, System.IEquatable<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric>\n{\n    public const int EwmaFieldNumber = 3;\n    public const int NameIndexFieldNumber = 1;\n    public const int NumberFieldNumber = 2;\n    // Properties and methods...\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Entity Props Factory with Cluster Sharding\nDESCRIPTION: Demonstrates how to register an actor type as a sharded entity using ClusterSharding.Start with an entity props factory for proper persistence ID handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-sharding.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n// register actor type as a sharded entity\nvar region = ClusterSharding.Get(system).Start(\n    typeName: \"aggregate\",\n    entityPropsFactory: s => Props.Create(() => new Aggregate(s)),\n    settings: ClusterShardingSettings.Create(system),\n    messageExtractor: new MessageExtractor());\n\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterSingletonProxySettings Class\nDESCRIPTION: Configuration settings class for cluster singleton proxy with various parameters and builder methods\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Net.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterSingletonProxySettings : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public ClusterSingletonProxySettings(string singletonName, string role, System.TimeSpan singletonIdentificationInterval, int bufferSize, bool considerAppVersion, bool logSingletonIdentificationFailure, System.TimeSpan singletonIdentificationFailurePeriod) { }\n    public int BufferSize { get; }\n    public bool ConsiderAppVersion { get; }\n    public bool LogSingletonIdentificationFailure { get; }\n    public string Role { get; }\n    public System.TimeSpan SingletonIdentificationFailurePeriod { get; }\n    public System.TimeSpan SingletonIdentificationInterval { get; }\n    public string SingletonName { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ScatterGatherFirstCompletedGroup in C#\nDESCRIPTION: This class implements a scatter-gather routing strategy for a group of actors, allowing configuration of paths, timeout, and dispatcher.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_188\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ScatterGatherFirstCompletedGroup : Akka.Routing.Group\n{\n    public ScatterGatherFirstCompletedGroup(Akka.Configuration.Config config) { }\n    public ScatterGatherFirstCompletedGroup(System.TimeSpan within, params string[] paths) { }\n    public ScatterGatherFirstCompletedGroup(System.Collections.Generic.IEnumerable<string> paths, System.TimeSpan within) { }\n    public ScatterGatherFirstCompletedGroup(System.Collections.Generic.IEnumerable<string> paths, System.TimeSpan within, string routerDispatcher) { }\n    public System.TimeSpan Within { get; }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Routing.ScatterGatherFirstCompletedGroup WithDispatcher(string dispatcher) { }\n    public class ScatterGatherFirstCompletedGroupSurrogate : Akka.Util.ISurrogate\n    {\n        public ScatterGatherFirstCompletedGroupSurrogate() { }\n        public System.Collections.Generic.IEnumerable<string> Paths { get; set; }\n        public string RouterDispatcher { get; set; }\n        public System.TimeSpan Within { get; set; }\n        public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Sharded Daemon Processes in Akka.NET C#\nDESCRIPTION: The \"ShardedDaemonProcess\" class, used for initializing sharded actors in Akka.NET environments. The class processes multiple instances, utilizing settings and actor properties configurations for daemon processes in distributed contexts.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Core.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic class ShardedDaemonProcess : Akka.Actor.IExtension {\n        public ShardedDaemonProcess(Akka.Actor.ExtendedActorSystem system) { }\n        public static Akka.Cluster.Sharding.ShardedDaemonProcess Get(Akka.Actor.ActorSystem system) { }\n        public void Init(string name, int numberOfInstances, System.Func<int, Akka.Actor.Props> propsFactory) { }\n        public void Init(string name, int numberOfInstances, System.Func<int, Akka.Actor.Props> propsFactory, object stopMessage) { }\n        public void Init(string name, int numberOfInstances, System.Func<int, Akka.Actor.Props> propsFactory, Akka.Cluster.Sharding.ShardedDaemonProcessSettings settings, object stopMessage) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterExtension in C#\nDESCRIPTION: Defines the ClusterExtension class which is used to create and access the Cluster extension within an Akka.NET ActorSystem. This follows Akka's extension pattern for system-wide functionality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.DotNet.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterExtension : Akka.Actor.ExtensionIdProvider<Akka.Cluster.Cluster>\n{\n    public ClusterExtension() { }\n    public override Akka.Cluster.Cluster CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RepointableActorRef Class in Akka.NET\nDESCRIPTION: Defines the RepointableActorRef class, which represents an actor reference that can be repointed to different underlying actor implementations. It includes properties for the actor system, props, and dispatcher.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\npublic class RepointableActorRef : Akka.Actor.ActorRefWithCell, Akka.Actor.IActorRefScope, Akka.Actor.IRepointableRef\n{\n    protected readonly Akka.Dispatch.MessageDispatcher Dispatcher;\n    protected readonly Akka.Actor.Props Props;\n    protected readonly Akka.Actor.IInternalActorRef Supervisor;\n    protected readonly Akka.Actor.Internal.ActorSystemImpl System;\n    protected readonly Akka.Actor.ActorPath _path;\n    public RepointableActorRef(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.Props props, Akka.Dispatch.MessageDispatcher dispatcher, Akka.Dispatch.MailboxType mailboxType, Akka.Actor.IInternalActorRef supervisor, Akka.Actor.ActorPath path) { }\n    public override System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> Children { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SerializerIdentifierHelper Class in C#\nDESCRIPTION: An internal API static class that helps retrieve serializer identifiers from configuration. Used by the Akka.NET serialization system to map types to their serializers.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_227\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic class static SerializerIdentifierHelper\n{\n    public static int GetSerializerIdentifierFromConfig(System.Type type, Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Tcp Class and Nested Classes in C#\nDESCRIPTION: Defines the Tcp class and its nested classes for TCP connection management. Includes various commands and events for TCP operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_166\n\nLANGUAGE: C#\nCODE:\n```\npublic class Tcp : Akka.Actor.ExtensionIdProvider<Akka.IO.TcpExt>\n{\n    public static readonly Akka.Actor.SupervisorStrategy ConnectionSupervisorStrategy;\n    public static readonly Akka.IO.Tcp Instance;\n    public Tcp() { }\n    public override Akka.IO.TcpExt CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n    public static Akka.Actor.IActorRef Manager(Akka.Actor.ActorSystem system) { }\n    \n    // Nested classes\n    public class Abort : Akka.IO.Tcp.CloseCommand { /* ... */ }\n    public class Aborted : Akka.IO.Tcp.ConnectionClosed { /* ... */ }\n    public class Bind : Akka.IO.Tcp.Command { /* ... */ }\n    // ... (other nested classes)\n}\n```\n\n----------------------------------------\n\nTITLE: ClusterClientReceptionistExtensionProvider in C#\nDESCRIPTION: Extension provider that creates instances of the ClusterClientReceptionist extension. This class follows the Akka extension pattern for system-wide components.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Core.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterClientReceptionistExtensionProvider : Akka.Actor.ExtensionIdProvider<Akka.Cluster.Tools.Client.ClusterClientReceptionist>\n{\n    public ClusterClientReceptionistExtensionProvider() { }\n    public override Akka.Cluster.Tools.Client.ClusterClientReceptionist CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing State Class Constructor and Properties in C#\nDESCRIPTION: Defines the State class constructor and properties for managing FSM state data, timeouts, and transitions in Akka.NET\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic State(TS stateName, TD stateData, System.Nullable<System.TimeSpan> timeout = null, Akka.Actor.FSMBase.Reason stopReason = null, System.Collections.Generic.IReadOnlyList<object> replies = null, System.Collections.Generic.IReadOnlyList<TE> domainEvents = null, System.Action<TD> afterTransitionDo = null, bool notifies = True) { }\n```\n\n----------------------------------------\n\nTITLE: ClusterExtension Class Definition\nDESCRIPTION: This snippet defines a class `ClusterExtension` that inherits from `Akka.Actor.ExtensionIdProvider<Akka.Cluster.Cluster>`. It is used to provide a singleton instance of the `Akka.Cluster.Cluster` extension within an Akka.NET actor system. It implements the `CreateExtension` method, which is responsible for creating the extension instance.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ClusterExtension : Akka.Actor.ExtensionIdProvider<Akka.Cluster.Cluster>\n{\n    public ClusterExtension() { }\n    public override Akka.Cluster.Cluster CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Down All Strategy in Akka.NET\nDESCRIPTION: Configuration for the down-all strategy which downs all members unconditionally if there are any unreachable nodes alive for longer than the stable-after period. This forces a complete rebuild of the cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/split-brain-resolver.md#2025-04-16_snippet_6\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster {\n  downing-provider-class = \"Akka.Cluster.SBR.SplitBrainResolverProvider, Akka.Cluster\"\n  active-strategy = down-all\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DistributedPubSubMediator in C#\nDESCRIPTION: Defines the DistributedPubSubMediator actor responsible for managing publish-subscribe operations across the cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Core.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic class DistributedPubSubMediator : Akka.Actor.ReceiveActor\n{\n    public DistributedPubSubMediator(Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings settings) { }\n    public Akka.Event.ILoggingAdapter Log { get; }\n    public System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, long> OwnVersions { get; }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n    public static Akka.Actor.Props Props(Akka.Cluster.Tools.PublishSubscribe.DistributedPubSubSettings settings) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified Duplicator Implementation Using EmitMultiple in C#\nDESCRIPTION: This snippet simplifies the `Duplicator` stage implementation by using `EmitMultiple`, allowing the emission of multiple elements without maintaining mutable state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/custom-stream-processing.md#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nclass Duplicator<T> : GraphStage<FlowShape<T, T>>\n{\n    private sealed class Logic : GraphStageLogic\n    {\n        public Logic(Duplicator<T> duplicator) : base(duplicator.Shape)\n        {\n            SetHandler(duplicator.In, onPush: () =>\n            {\n                var element = Grab(duplicator.In);\n                // this will temporarily suspend this handler until the two elems\n                // are emitted and then reinstates it\n                EmitMultiple(duplicator.Out, new[] {element, element});\n            });\n\n            SetHandler(duplicator.Out, onPull: () => Pull(duplicator.In));\n        }\n    }\n    \n    public Duplicator(Predicate<T> predicate)\n    {\n        Shape = new FlowShape<T, T>(In, Out);\n    }\n\n    public Inlet<T> In { get; } = new Inlet<T>(\"Duplicator.in\");\n\n    public Outlet<T> Out { get; } = new Outlet<T>(\"Duplicator.out\");\n\n    public override FlowShape<T, T> Shape { get; }\n\n    protected override GraphStageLogic CreateLogic(Attributes inheritedAttributes) => new Logic(this);\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Streams with Actors using SelectAsync and Ask in C#\nDESCRIPTION: This snippet demonstrates how to use SelectAsync with Ask to delegate processing of stream elements to an actor. It maintains back-pressure and preserves message ordering.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar words = Source.From(new [] { \"hello\", \"hi\" });\nwords\n    .SelectAsync(5, elem => _actorRef.Ask(elem, TimeSpan.FromSeconds(5)))\n    .Select(elem => (string)elem)\n    .Select(elem => elem.ToLower())\n    .RunWith(Sink.Ignore<string>(), _actorMaterializer);\n```\n\n----------------------------------------\n\nTITLE: Utility Methods in Akka.NET TestKitBase\nDESCRIPTION: These methods provide various utility functions for Akka.NET tests, including message ignoring, test initialization, condition awaiting, and message peeking. They offer both synchronous and asynchronous versions with various options.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic System.Threading.Tasks.Task FishUntilMessageAsync<T>(System.Nullable<System.TimeSpan> max = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.TimeSpan GetTimeoutOrDefault(System.Nullable<System.TimeSpan> timeout) { }\npublic void IgnoreMessages(System.Func<object, bool> shouldIgnoreMessage) { }\npublic void IgnoreMessages<TMsg>(System.Func<TMsg, bool> shouldIgnoreMessage) { }\npublic void IgnoreMessages<TMsg>() { }\npublic void IgnoreNoMessages() { }\nprotected virtual void InitializeTest(Akka.Actor.ActorSystem system, Akka.Actor.Setup.ActorSystemSetup config, string actorSystemName, string testActorName) { }\nprotected void InitializeTest(Akka.Actor.ActorSystem system, Akka.Configuration.Config config, string actorSystemName, string testActorName) { }\nprotected static bool InternalAwaitCondition(System.Func<bool> conditionIsFulfilled, System.TimeSpan max, System.Nullable<System.TimeSpan> interval, System.Action<string, object[]> fail, System.Threading.CancellationToken cancellationToken = null) { }\nprotected static bool InternalAwaitCondition(System.Func<bool> conditionIsFulfilled, System.TimeSpan max, System.Nullable<System.TimeSpan> interval, System.Action<string, object[]> fail, Akka.Event.ILoggingAdapter logger, System.Threading.CancellationToken cancellationToken = null) { }\nprotected static System.Threading.Tasks.Task<bool> InternalAwaitConditionAsync(System.Func<System.Threading.Tasks.Task<bool>> conditionIsFulfilled, System.TimeSpan max, System.Nullable<System.TimeSpan> interval, System.Action<string, object[]> fail, System.Threading.CancellationToken cancellationToken = null) { }\nprotected static System.Threading.Tasks.Task<bool> InternalAwaitConditionAsync(System.Func<System.Threading.Tasks.Task<bool>> conditionIsFulfilled, System.TimeSpan max, System.Nullable<System.TimeSpan> interval, System.Action<string, object[]> fail, Akka.Event.ILoggingAdapter logger, System.Threading.CancellationToken cancellationToken = null) { }\npublic object PeekOne(System.Nullable<System.TimeSpan> max = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic object PeekOne(System.Threading.CancellationToken cancellationToken) { }\npublic System.Threading.Tasks.ValueTask<object> PeekOneAsync(System.Nullable<System.TimeSpan> max = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.ValueTask<object> PeekOneAsync(System.Threading.CancellationToken cancellationToken) { }\npublic System.Collections.Generic.IReadOnlyCollection<object> ReceiveN(int numberOfMessages, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Collections.Generic.IReadOnlyCollection<object> ReceiveN(int numberOfMessages, System.TimeSpan max, System.Threading.CancellationToken cancellationToken = null) { }\n[System.Runtime.CompilerServices.AsyncIteratorStateMachineAttribute(typeof(Akka.TestKit.TestKitBase.<ReceiveNAsync>d__212))]\npublic System.Collections.Generic.IAsyncEnumerable<object> ReceiveNAsync(int numberOfMessages, [System.Runtime.CompilerServices.EnumeratorCancellationAttribute()] System.Threading.CancellationToken cancellationToken = null) { }\n[System.Runtime.CompilerServices.AsyncIteratorStateMachineAttribute(typeof(Akka.TestKit.TestKitBase.<ReceiveNAsync>d__214))]\n```\n\n----------------------------------------\n\nTITLE: ConfigServiceDiscovery Class Definition in C#\nDESCRIPTION: Implements a service discovery mechanism based on Akka configuration. This class resolves service endpoints from static configuration defined in the application.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.DotNet.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class ConfigServiceDiscovery : Akka.Discovery.ServiceDiscovery\n{\n    public ConfigServiceDiscovery(Akka.Actor.ExtendedActorSystem system) { }\n    public ConfigServiceDiscovery(Akka.Actor.ExtendedActorSystem system, Akka.Configuration.Config config) { }\n    public override System.Threading.Tasks.Task<Akka.Discovery.ServiceDiscovery.Resolved> Lookup(Akka.Discovery.Lookup lookup, System.TimeSpan resolveTimeout) { }\n    [Akka.Annotations.InternalStableApiAttribute()]\n    public bool TryAddEndpoint(string serviceName, Akka.Discovery.ServiceDiscovery.ResolvedTarget target) { }\n    [Akka.Annotations.InternalStableApiAttribute()]\n    public bool TryRemoveEndpoint(string serviceName, Akka.Discovery.ServiceDiscovery.ResolvedTarget target) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining static LWWDictionary Class in C#\nDESCRIPTION: This snippet defines a static class `LWWDictionary` containing static `Create` methods for creating instances of `Akka.DistributedData.LWWDictionary<TKey, TValue>`. These methods provide different ways to initialize the LWWDictionary, including with a single key-value pair, or from an enumerable collection of key-value pairs.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\n    public class static LWWDictionary\n    {\n        public static Akka.DistributedData.LWWDictionary<TKey, TValue> Create<TKey, TValue>(Akka.Cluster.UniqueAddress node, TKey key, TValue value, Akka.DistributedData.Clock<TValue> clock = null) { }\n        public static Akka.DistributedData.LWWDictionary<TKey, TValue> Create<TKey, TValue>(params System.ValueTuple<, , >[] elements) { }\n        public static Akka.DistributedData.LWWDictionary<TKey, TValue> Create<TKey, TValue>(System.Collections.Generic.IEnumerable<System.ValueTuple<Akka.Cluster.UniqueAddress, TKey, TValue>> elements, Akka.DistributedData.Clock<TValue> clock = null) { }\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Implementing IStash Interface in C#\nDESCRIPTION: Defines the IStash interface with methods for managing a stash of envelopes, including clearing, prepending, stashing, and unstashing operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IStash\n{\n    System.Collections.Generic.IEnumerable<Akka.Actor.Envelope> ClearStash();\n    void Prepend(System.Collections.Generic.IEnumerable<Akka.Actor.Envelope> envelopes);\n    void Stash();\n    void Unstash();\n    void UnstashAll();\n    void UnstashAll(System.Func<Akka.Actor.Envelope, bool> predicate);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SnapshotEntry Class in C#\nDESCRIPTION: Data structure class for representing a snapshot entry. It includes properties for identifying and storing snapshot data, such as persistence ID, sequence number, and timestamp.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\npublic class SnapshotEntry\n{\n    public SnapshotEntry() { }\n    public string Id { get; set; }\n    public string PersistenceId { get; set; }\n    public long SequenceNr { get; set; }\n    public object Snapshot { get; set; }\n    public long Timestamp { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AutoPilot Abstract Class in Akka.NET TestKit\nDESCRIPTION: Declares an abstract AutoPilot class with static properties and an abstract Run method for implementing custom autopilots in actor testing scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AutoPilot\n{\n    protected AutoPilot() { }\n    public static Akka.TestKit.KeepRunning KeepRunning { get; }\n    public static Akka.TestKit.NoAutoPilot NoAutoPilot { get; }\n    public abstract Akka.TestKit.AutoPilot Run(Akka.Actor.IActorRef sender, object message);\n}\n```\n\n----------------------------------------\n\nTITLE: Nesting and Flattening Stream Operations Overview\nDESCRIPTION: Detailed description of stream stages that can transform streams into nested streams or flatten nested streams into single element streams\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/builtinstages.md#2025-04-16_snippet_10\n\nLANGUAGE: markdown\nCODE:\n```\n### PrefixAndTail\n\nTake up to `n` elements from the stream (less than `n` only if the upstream completes before emitting `n` elements)\nand returns a pair containing a strict sequence of the taken element and a stream representing the remaining elements.\n```\n\nLANGUAGE: markdown\nCODE:\n```\n### GroupBy\n\nThis operation demultiplexes the incoming stream into separate output streams, one for each element key. The\nkey is computed for each element using the given function.\n```\n\n----------------------------------------\n\nTITLE: Implementing Internal Message Chunking in C#\nDESCRIPTION: Implementation of chunked message handling for large messages in Akka.NET's delivery system. Includes structures for managing message chunks and serialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_91\n\nLANGUAGE: C#\nCODE:\n```\npublic struct ChunkedMessage {\n    public ChunkedMessage(ByteString serializedMessage, bool firstChunk, bool lastChunk, int serializerId, string manifest) { }\n    public bool FirstChunk { get; }\n    public bool LastChunk { get; }\n    public string Manifest { get; }\n    public ByteString SerializedMessage { get; }\n    public int SerializerId { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Vector Static Class in C#\nDESCRIPTION: Utility methods for creating and manipulating vectors, including a factory method for creating lists of a specified size.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_240\n\nLANGUAGE: C#\nCODE:\n```\npublic class static Vector\n{\n    public static System.Func<System.Func<T>, System.Collections.Generic.IList<T>> Fill<T>(int number) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MemoryJournal Class for In-Memory Persistence in Akka.NET C#\nDESCRIPTION: This class implements an in-memory journal for Akka.NET persistence. It provides methods for adding, deleting, and updating persistent representations, as well as reading and replaying messages. It extends AsyncWriteJournal and overrides key methods for journal operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic class MemoryJournal : Akka.Persistence.Journal.AsyncWriteJournal\n{\n    public MemoryJournal() { }\n    protected virtual System.Collections.Concurrent.ConcurrentDictionary<string, System.Collections.Generic.LinkedList<Akka.Persistence.IPersistentRepresentation>> Messages { get; }\n    public System.Collections.Generic.IDictionary<string, System.Collections.Generic.LinkedList<Akka.Persistence.IPersistentRepresentation>> Add(Akka.Persistence.IPersistentRepresentation persistent) { }\n    public System.Collections.Generic.IDictionary<string, System.Collections.Generic.LinkedList<Akka.Persistence.IPersistentRepresentation>> Delete(string pid, long seqNr) { }\n    protected override System.Threading.Tasks.Task DeleteMessagesToAsync(string persistenceId, long toSequenceNr) { }\n    public long HighestSequenceNr(string pid) { }\n    public System.Collections.Generic.IEnumerable<Akka.Persistence.IPersistentRepresentation> Read(string pid, long fromSeqNr, long toSeqNr, long max) { }\n    public override System.Threading.Tasks.Task<long> ReadHighestSequenceNrAsync(string persistenceId, long fromSequenceNr) { }\n    protected override bool ReceivePluginInternal(object message) { }\n    public override System.Threading.Tasks.Task ReplayMessagesAsync(Akka.Actor.IActorContext context, string persistenceId, long fromSequenceNr, long toSequenceNr, long max, System.Action<Akka.Persistence.IPersistentRepresentation> recoveryCallback) { }\n    public System.Collections.Generic.IDictionary<string, System.Collections.Generic.LinkedList<Akka.Persistence.IPersistentRepresentation>> Update(string pid, long seqNr, System.Func<Akka.Persistence.IPersistentRepresentation, Akka.Persistence.IPersistentRepresentation> updater) { }\n    protected override System.Threading.Tasks.Task<System.Collections.Immutable.IImmutableList<System.Exception>> WriteMessagesAsync(System.Collections.Generic.IEnumerable<Akka.Persistence.AtomicWrite> messages) { }\n}\n```\n\n----------------------------------------\n\nTITLE: ServiceDiscovery.ResolvedTarget Class Definition in C#\nDESCRIPTION: Represents a single resolved endpoint from a service discovery operation. Contains the host, optional port, and optional IP address information for a discovered service instance.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.DotNet.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic class ResolvedTarget : Akka.Actor.INoSerializationVerificationNeeded, System.IEquatable<Akka.Discovery.ServiceDiscovery.ResolvedTarget>\n{\n    public ResolvedTarget(string host, System.Nullable<int> port = null, System.Net.IPAddress address = null) { }\n    public System.Net.IPAddress Address { get; }\n    public string Host { get; }\n    public System.Nullable<int> Port { get; }\n    public bool Equals(Akka.Discovery.ServiceDiscovery.ResolvedTarget other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TerminatingChildrenContainer Class in C#\nDESCRIPTION: A container for managing terminating actor children. Tracks children in the process of terminating and provides methods to manage them.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_63\n\nLANGUAGE: C#\nCODE:\n```\npublic class TerminatingChildrenContainer : Akka.Actor.Internal.ChildrenContainerBase\n{\n    public TerminatingChildrenContainer(System.Collections.Immutable.IImmutableDictionary<string, Akka.Actor.Internal.IChildStats> children, Akka.Actor.IActorRef toDie, Akka.Actor.Internal.SuspendReason reason) { }\n    public TerminatingChildrenContainer(System.Collections.Immutable.IImmutableDictionary<string, Akka.Actor.Internal.IChildStats> children, System.Collections.Immutable.ImmutableHashSet<Akka.Actor.IActorRef> toDie, Akka.Actor.Internal.SuspendReason reason) { }\n    public override bool IsNormal { get; }\n    public override bool IsTerminating { get; }\n    public Akka.Actor.Internal.SuspendReason Reason { get; }\n    public System.Collections.Immutable.ImmutableHashSet<Akka.Actor.IActorRef> ToDie { get; }\n    public override Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats) { }\n    public Akka.Actor.Internal.IChildrenContainer CreateCopyWithReason(Akka.Actor.Internal.SuspendReason reason) { }\n    public override Akka.Actor.Internal.IChildrenContainer Remove(Akka.Actor.IActorRef child) { }\n    public override Akka.Actor.Internal.IChildrenContainer Reserve(string name) { }\n    public override Akka.Actor.Internal.IChildrenContainer ShallDie(Akka.Actor.IActorRef actor) { }\n    public override string ToString() { }\n    public override Akka.Actor.Internal.IChildrenContainer Unreserve(string name) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Resulting HOCON Configuration After Overriding Serializer IDs\nDESCRIPTION: This snippet shows the final HOCON configuration after overriding the default serializer IDs. It includes the modified and added serializer identifications.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/serialization/serialization.md#2025-04-16_snippet_5\n\nLANGUAGE: hocon\nCODE:\n```\nserialization-identifiers : {\n    \"Akka.Serialization.ByteArraySerializer, Akka\" : 4\n    \"Akka.Serialization.NewtonSoftJsonSerializer, Akka\" : 1000001\n    \"Akka.Remote.Serialization.ProtobufSerializer, Akka.Remote\" : 2\n    \"Akka.Remote.Serialization.DaemonMsgCreateSerializer, Akka.Remote\" : 3\n    \"Akka.Remote.Serialization.MessageContainerSerializer, Akka.Remote\" : 6\n    \"Akka.Remote.Serialization.MiscMessageSerializer, Akka.Remote\" : 16\n    \"Akka.Remote.Serialization.PrimitiveSerializers, Akka.Remote\" : 17\n    \"Akka.Remote.Serialization.SystemMessageSerializer, Akka.Remote\" : 22\n    \"MyAssembly.MyDefaultSerializer, SomeAssembly\" : 1\n}\n```\n\n----------------------------------------\n\nTITLE: InMemoryReadJournalProvider Class Implementation in C#\nDESCRIPTION: Provider class for instantiating InMemoryReadJournal instances. Implements IReadJournalProvider interface and requires an ExtendedActorSystem and configuration for initialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceInMemoryQuery.Core.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class InMemoryReadJournalProvider : Akka.Persistence.Query.IReadJournalProvider\n{\n    public InMemoryReadJournalProvider(Akka.Actor.ExtendedActorSystem system, Akka.Configuration.Config config) { }\n    public Akka.Persistence.Query.IReadJournal GetReadJournal() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Aggregate Service Discovery Class\nDESCRIPTION: This code defines the `AggregateServiceDiscovery` class, an implementation of `Akka.Discovery.ServiceDiscovery`. It aggregates multiple service discovery methods. It takes an `ExtendedActorSystem` in its constructor and overrides the `Lookup` method to resolve service addresses.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.Core.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace Akka.Discovery.Aggregate\n{\n    [Akka.Annotations.InternalApiAttribute()]\n    public class AggregateServiceDiscovery : Akka.Discovery.ServiceDiscovery\n    {\n        public AggregateServiceDiscovery(Akka.Actor.ExtendedActorSystem system) { }\n        public override System.Threading.Tasks.Task<Akka.Discovery.ServiceDiscovery.Resolved> Lookup(Akka.Discovery.Lookup query, System.TimeSpan resolveTimeout) { }\n    }\n    [Akka.Annotations.InternalApiAttribute()]\n    public sealed class AggregateServiceDiscoverySettings\n    {\n        public AggregateServiceDiscoverySettings(Akka.Configuration.Config config) { }\n        public System.Collections.Generic.List<string> DiscoveryMethods { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IAsyncRecovery Interface for Akka.NET Persistence\nDESCRIPTION: This interface defines methods for asynchronous recovery operations in Akka.NET persistence, including reading highest sequence numbers and replaying messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IAsyncRecovery\n{\n    System.Threading.Tasks.Task<long> ReadHighestSequenceNrAsync(string persistenceId, long fromSequenceNr);\n    System.Threading.Tasks.Task ReplayMessagesAsync(Akka.Actor.IActorContext context, string persistenceId, long fromSequenceNr, long toSequenceNr, long max, System.Action<Akka.Persistence.IPersistentRepresentation> recoveryCallback);\n}\n```\n\n----------------------------------------\n\nTITLE: Unthrottled Transport Mode Implementation\nDESCRIPTION: Implementation of unthrottled transport mode extending ThrottleMode. Provides functionality for token consumption and time availability calculation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic class Unthrottled : Akka.Remote.Transport.ThrottleMode\n{\n    public static Akka.Remote.Transport.Unthrottled Instance { get; }\n    public override System.TimeSpan TimeToAvailable(long currentNanoTime, int tokens) { }\n    public override System.ValueTuple<Akka.Remote.Transport.ThrottleMode, bool> TryConsumeTokens(long nanoTimeOfSend, int tokens) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IPersistenceMessage Interface\nDESCRIPTION: This snippet defines the `IPersistenceMessage` interface, representing a generic message related to persistence in Akka.Persistence. It inherits from `INoSerializationVerificationNeeded`, indicating that implementations should not be subject to serialization verification. This is a base interface for various persistence-related messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\n\"public interface IPersistenceMessage : Akka.Actor.INoSerializationVerificationNeeded { }\"\n```\n\n----------------------------------------\n\nTITLE: LeaseTimeoutException Class Definition in C#\nDESCRIPTION: Represents an exception that is thrown when a lease operation times out. Extends the base LeaseException class with specific constructors for timeout scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.DotNet.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class LeaseTimeoutException : Akka.Coordination.LeaseException\n{\n    public LeaseTimeoutException(string message) { }\n    public LeaseTimeoutException(string message, System.Exception innerEx) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Assembly Attributes for Akka.NET\nDESCRIPTION: Assembly attributes defining internal visibility to other Akka.NET projects and setting metadata like repository URL and target framework. These attributes expose internal members to related Akka.NET assemblies to enable testing and component integration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Benchmarks\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.TestKit\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Tests.MultiNode\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Tools\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.DependencyInjection\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.DistributedData\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.MultiNodeTestRunner.Shared.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Persistence\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Persistence.TCK\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Remote\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Remote.TestKit.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Remote.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Remote.Tests.MultiNode\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Streams\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Streams.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.TestKit\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.TestKit.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Tests.Performance\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"1a5cab08-b032-49ca-8db3-9428c5a9db14\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Defining IConsistentHashable Interface in C#\nDESCRIPTION: Declares an interface for objects that can be consistently hashed, which is useful for certain routing strategies.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_203\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IConsistentHashable\n{\n    object ConsistentHashKey { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Remote Watcher Implementation in C#\nDESCRIPTION: Implements monitoring of remote actors for failure detection and lifecycle management across distributed systems.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class RemoteWatcher : Akka.Actor.UntypedActor, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedMessageQueueSemantics>\n{\n    protected readonly Akka.Event.ILoggingAdapter Log;\n    protected readonly System.Collections.Generic.Dictionary<Akka.Actor.Address, System.Collections.Generic.HashSet<Akka.Actor.IInternalActorRef>> WatcheeByNodes;\n    // ... additional members\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing InternalActivateFsmLogging Class in C#\nDESCRIPTION: Internal class for activating FSM (Finite State Machine) logging, marked with InternalApiAttribute and providing a singleton instance.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_57\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic class InternalActivateFsmLogging\n{\n    public static Akka.Actor.Internal.InternalActivateFsmLogging Instance { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing InboundPayload Class in Akka.NET Remote Transport\nDESCRIPTION: A class representing an inbound payload event in Akka.NET's remote transport system, containing protobuf binary data.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class InboundPayload : Akka.Actor.INoSerializationVerificationNeeded, Akka.Remote.Transport.IHandleEvent\n{\n    public InboundPayload(Google.Protobuf.ByteString payload) { }\n    public Google.Protobuf.ByteString Payload { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Association Handle in C#\nDESCRIPTION: Defines an abstract class AssociationHandle that represents a handle to a remote association. It provides basic properties and methods for managing the association.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AssociationHandle\n{\n    protected AssociationHandle(Akka.Actor.Address localAddress, Akka.Actor.Address remoteAddress) { }\n    public Akka.Actor.Address LocalAddress { get; set; }\n    public System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.IHandleEventListener> ReadHandlerSource { get; set; }\n    public Akka.Actor.Address RemoteAddress { get; set; }\n    [System.ObsoleteAttribute(\"Use the method that states reasons to make sure disassociation reasons are logged\" +\n        \".\")]\n    public abstract void Disassociate();\n    public void Disassociate(string reason, Akka.Event.ILoggingAdapter log) { }\n    public override bool Equals(object obj) { }\n    protected bool Equals(Akka.Remote.Transport.AssociationHandle other) { }\n    public override int GetHashCode() { }\n    public abstract bool Write(Google.Protobuf.ByteString payload);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MessageOrChunk Generic Structure in C#\nDESCRIPTION: A generic structure that can contain either a message of type T or a chunked message. This structure is marked as internal API and includes equality comparison, implicit conversion operators, and standard object methods.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_80\n\nLANGUAGE: csharp\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\n[System.Runtime.CompilerServices.IsReadOnlyAttribute()]\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic struct MessageOrChunk<T> : System.IEquatable<Akka.Delivery.Internal.MessageOrChunk<T>>\n{\n    public MessageOrChunk(T message) { }\n    public MessageOrChunk(Akka.Delivery.Internal.ChunkedMessage chunkedMessage) { }\n    public System.Nullable<Akka.Delivery.Internal.ChunkedMessage> Chunk { get; }\n    public bool IsMessage { get; }\n    public T Message { get; }\n    public bool Equals([System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})] Akka.Delivery.Internal.MessageOrChunk<T> other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n    [return: System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})]\n    public static Akka.Delivery.Internal.MessageOrChunk<T> op_Implicit(T message) { }\n    public static T op_Implicit([System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})] Akka.Delivery.Internal.MessageOrChunk<T> message) { }\n    public static Akka.Delivery.Internal.ChunkedMessage op_Implicit([System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})] Akka.Delivery.Internal.MessageOrChunk<T> message) { }\n    [return: System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})]\n    public static Akka.Delivery.Internal.MessageOrChunk<T> op_Implicit(Akka.Delivery.Internal.ChunkedMessage chunkedMessage) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Register Termination Hook in Akka.NET\nDESCRIPTION: Defines a singleton message for registering termination hooks in the actor system. Used for cleanup operations that need to run when termination occurs.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_123\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class RegisterTerminationHook\n{\n    public static Akka.Dispatch.SysMsg.RegisterTerminationHook Instance { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SchemeAugmenter Class in Akka.NET Remote Transport\nDESCRIPTION: A utility class for augmenting and removing transport scheme identifiers in addresses, used by transport adapters to modify URL schemes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\npublic class SchemeAugmenter\n{\n    public readonly string AddedSchemeIdentifier;\n    public SchemeAugmenter(string addedSchemeIdentifier) { }\n    public string AugmentScheme(string originalScheme) { }\n    public Akka.Actor.Address AugmentScheme(Akka.Actor.Address address) { }\n    public string RemoveScheme(string scheme) { }\n    public Akka.Actor.Address RemoveScheme(Akka.Actor.Address address) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Termination Hook in Akka.NET\nDESCRIPTION: Defines a singleton message for handling termination hooks in the actor system. Used to signal when termination processes should be executed.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_131\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class TerminationHook\n{\n    public static Akka.Dispatch.SysMsg.TerminationHook Instance { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Message Expectation from Specific Senders in Akka.NET TestKitBase\nDESCRIPTION: These methods provide asynchronous versions for expecting messages from specific senders in Akka.NET tests. They offer various overloads for different assertion and predicate scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic System.Threading.Tasks.ValueTask<T> ExpectMsgFromAsync<T>(Akka.Actor.IActorRef sender, System.Nullable<System.TimeSpan> duration = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.ValueTask<T> ExpectMsgFromAsync<T>(Akka.Actor.IActorRef sender, T message, System.Nullable<System.TimeSpan> timeout = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.ValueTask<T> ExpectMsgFromAsync<T>(Akka.Actor.IActorRef sender, System.Predicate<T> isMessage, System.Nullable<System.TimeSpan> timeout = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.ValueTask<T> ExpectMsgFromAsync<T>(System.Predicate<Akka.Actor.IActorRef> isSender, System.Predicate<T> isMessage, System.Nullable<System.TimeSpan> timeout = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.ValueTask<T> ExpectMsgFromAsync<T>(Akka.Actor.IActorRef sender, System.Action<T> assertMessage, System.Nullable<System.TimeSpan> timeout = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.ValueTask<T> ExpectMsgFromAsync<T>(System.Action<Akka.Actor.IActorRef> assertSender, System.Action<T> assertMessage, System.Nullable<System.TimeSpan> timeout = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Defining IJournalRequest and IJournalResponse Interfaces in C#\nDESCRIPTION: These snippets define both IJournalRequest and IJournalResponse interfaces, which serve as contracts for request and response messages in Akka's persistence journal mechanism, ensuring uniform behavior across the implementation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IJournalRequest : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IJournalMessage, Akka.Persistence.IPersistenceMessage { }\npublic interface IJournalResponse : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IJournalMessage, Akka.Persistence.IPersistenceMessage { }\n```\n\n----------------------------------------\n\nTITLE: Transport Abstract Class Definition (C#)\nDESCRIPTION: Base class for all transport implementations that defines the core interface for network communication in Akka.Net. Includes methods for establishing associations and handling connections.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Transport\n{\n    protected Transport() { }\n    public Akka.Configuration.Config Config { get; set; }\n    public virtual long MaximumPayloadBytes { get; set; }\n    public virtual string SchemeIdentifier { get; set; }\n    public Akka.Actor.ActorSystem System { get; set; }\n    public abstract System.Threading.Tasks.Task<Akka.Remote.Transport.AssociationHandle> Associate(Akka.Actor.Address remoteAddress);\n    public abstract bool IsResponsibleFor(Akka.Actor.Address remote);\n    public abstract System.Threading.Tasks.Task<System.ValueTuple<Akka.Actor.Address, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.IAssociationEventListener>>> Listen();\n    public virtual System.Threading.Tasks.Task<bool> ManagementCommand(object message) { }\n    public abstract System.Threading.Tasks.Task<bool> Shutdown();\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Keep Referee Strategy in Akka.NET (Legacy)\nDESCRIPTION: Configuration for the legacy keep-referee strategy which downs the part that doesn't contain the referee node. This strategy is deprecated and will be removed in Akka.NET v1.5.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/split-brain-resolver.md#2025-04-16_snippet_7\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster {\n  downing-provider-class = \"Akka.Cluster.SplitBrainResolver, Akka.Cluster\"\n  active-strategy = keep-referee\n\n  keep-referee {    \n    # referee address on the form of \"akka.tcp://system@hostname:port\"\n    address = \"\"\n    down-all-if-less-than-nodes = 1\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ReplicatorSettings in C#\nDESCRIPTION: Configuration settings class for the Akka.NET distributed data replicator, including gossip intervals, pruning settings, and durable storage options.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_46\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ReplicatorSettings\n{\n    [System.ObsoleteAttribute(\"Use constructor with `verboseDebugLogging` argument. Obsolete since v1.5.0-alpha2\")]\n    public ReplicatorSettings(string role, System.TimeSpan gossipInterval, System.TimeSpan notifySubscribersInterval, int maxDeltaElements, string dispatcher, System.TimeSpan pruningInterval, System.TimeSpan maxPruningDissemination, System.Collections.Immutable.IImmutableSet<string> durableKeys, Akka.Actor.Props durableStoreProps, System.TimeSpan pruningMarkerTimeToLive, System.TimeSpan durablePruningMarkerTimeToLive, int maxDeltaSize, bool restartReplicatorOnFailure, bool preferOldest) { }\n    public ReplicatorSettings(string role, System.TimeSpan gossipInterval, System.TimeSpan notifySubscribersInterval, int maxDeltaElements, string dispatcher, System.TimeSpan pruningInterval, System.TimeSpan maxPruningDissemination, System.Collections.Immutable.IImmutableSet<string> durableKeys, Akka.Actor.Props durableStoreProps, System.TimeSpan pruningMarkerTimeToLive, System.TimeSpan durablePruningMarkerTimeToLive, int maxDeltaSize, bool restartReplicatorOnFailure, bool preferOldest, bool verboseDebugLogging) { }\n    public static Akka.DistributedData.ReplicatorSettings Create(Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Ways to Define Object Values in HOCON\nDESCRIPTION: Shows three equivalent methods to define the same object value: as one complete object, as two concatenated objects, and as two separate fields that get merged.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/hocon.md#2025-04-16_snippet_2\n\nLANGUAGE: hocon\nCODE:\n```\n// one object\na : { b : 1, c : 2 }\n// two objects that are merged via concatenation rules\na : { b : 1 } { c : 2 }\n// two fields that are merged\na : { b : 1 }\na : { c : 2 }\n```\n\n----------------------------------------\n\nTITLE: Defining DeleteSnapshotSuccess Class in C#\nDESCRIPTION: This snippet depicts the DeleteSnapshotSuccess class, which is used to represent a successful deletion of a snapshot, including its associated metadata. The class implements message interfaces to maintain compatibility with the Akka messaging system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class DeleteSnapshotSuccess : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage, Akka.Persistence.ISnapshotResponse, System.IEquatable<Akka.Persistence.DeleteSnapshotSuccess>\n{\n    public DeleteSnapshotSuccess(Akka.Persistence.SnapshotMetadata metadata) { }\n    public Akka.Persistence.SnapshotMetadata Metadata { get; }\n    public bool Equals(Akka.Persistence.DeleteSnapshotSuccess other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Number Type Implementation\nDESCRIPTION: Implementation of the Number type supporting various numeric formats with protobuf serialization capabilities.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Core.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Number : Google.Protobuf.IDeepCloneable<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Number>, Google.Protobuf.IMessage, Google.Protobuf.IMessage<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Number>, System.IEquatable<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Number>\n{\n    public const int SerializedFieldNumber = 4;\n    public const int TypeFieldNumber = 1;\n    public const int Value32FieldNumber = 2;\n    public const int Value64FieldNumber = 3;\n    // Properties and methods...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing InternalCurrentActorCellKeeper Static Class in C#\nDESCRIPTION: A static keeper class that maintains a reference to the current ActorCell. This provides access to the current actor context during execution.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_59\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic class static InternalCurrentActorCellKeeper\n{\n    public static Akka.Actor.ActorCell Current { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DefaultTimestampProvider in C#\nDESCRIPTION: A default implementation of the ITimestampProvider interface. Generates timestamps for persistent representations that can be used for event ordering and querying.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DefaultTimestampProvider : Akka.Persistence.Sql.Common.Journal.ITimestampProvider\n{\n    public DefaultTimestampProvider() { }\n    public long GenerateTimestamp(Akka.Persistence.IPersistentRepresentation message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: ClusterClientSettings Class Definition in C#\nDESCRIPTION: Configuration settings for the ClusterClient, including initial contacts, intervals for establishing connections and heartbeats, buffer sizes, and timeout configuration. Contains builder methods for fluent configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterClientSettings : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public ClusterClientSettings(System.Collections.Immutable.IImmutableSet<Akka.Actor.ActorPath> initialContacts, System.TimeSpan establishingGetContactsInterval, System.TimeSpan refreshContactsInterval, System.TimeSpan heartbeatInterval, System.TimeSpan acceptableHeartbeatPause, int bufferSize, System.Nullable<System.TimeSpan> reconnectTimeout = null) { }\n    public System.TimeSpan AcceptableHeartbeatPause { get; }\n    public int BufferSize { get; }\n    public System.TimeSpan EstablishingGetContactsInterval { get; }\n    public System.TimeSpan HeartbeatInterval { get; }\n    public System.Collections.Immutable.IImmutableSet<Akka.Actor.ActorPath> InitialContacts { get; }\n    public System.Nullable<System.TimeSpan> ReconnectTimeout { get; }\n    public System.TimeSpan RefreshContactsInterval { get; }\n    public static Akka.Cluster.Tools.Client.ClusterClientSettings Create(Akka.Actor.ActorSystem system) { }\n    public static Akka.Cluster.Tools.Client.ClusterClientSettings Create(Akka.Configuration.Config config) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithBufferSize(int bufferSize) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithEstablishingGetContactsInterval(System.TimeSpan value) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithHeartbeatInterval(System.TimeSpan value) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithInitialContacts(System.Collections.Immutable.IImmutableSet<Akka.Actor.ActorPath> initialContacts) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithReconnectTimeout(System.Nullable<System.TimeSpan> reconnectTimeout) { }\n    public Akka.Cluster.Tools.Client.ClusterClientSettings WithRefreshContactsInterval(System.TimeSpan value) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Option<T> ToString Method in C#\nDESCRIPTION: Override of the ToString method for Option<T> class to provide a string representation of the option.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_222\n\nLANGUAGE: C#\nCODE:\n```\npublic override string ToString() { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Reference Type Swap Operation in C#\nDESCRIPTION: Generic method that swaps a reference type value using a provided updater function. Ensures type safety through generic constraint.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_269\n\nLANGUAGE: C#\nCODE:\n```\npublic static T Swap<T>(ref T reference, System.Func<T, T> updater)\n    where T :  class { }\n```\n\n----------------------------------------\n\nTITLE: UpdateTimeout Class Definition in C#\nDESCRIPTION: Represents a timeout failure during an update operation in Akka.NET's distributed data system. Contains information about the key, original request, and failure details.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_51\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class UpdateTimeout : Akka.Actor.INoSerializationVerificationNeeded, Akka.DistributedData.IUpdateFailure, Akka.DistributedData.IUpdateResponse, System.IEquatable<Akka.DistributedData.UpdateTimeout>\n{\n    public UpdateTimeout(Akka.DistributedData.IKey key, object request) { }\n    public System.Exception Cause { get; }\n    public bool IsSuccessful { get; }\n    public Akka.DistributedData.IKey Key { get; }\n    public object Request { get; }\n    public bool Equals(Akka.DistributedData.UpdateTimeout other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public void ThrowOnFailure() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LoadSnapshotResult Message Class in Akka.NET Persistence\nDESCRIPTION: This code defines the `LoadSnapshotResult` class, which represents a message containing the result of loading a snapshot in Akka.NET persistence. It includes properties for the selected snapshot and the target sequence number. The `LoadSnapshotResult` class implements interfaces related to persistence messages, snapshot messages, and snapshot responses, also implementing `IEquatable` for value comparison.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class LoadSnapshotResult : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage, Akka.Persistence.ISnapshotResponse, System.IEquatable<Akka.Persistence.LoadSnapshotResult>\n{\n    public LoadSnapshotResult(Akka.Persistence.SelectedSnapshot snapshot, long toSequenceNr) { }\n    public Akka.Persistence.SelectedSnapshot Snapshot { get; }\n    public long ToSequenceNr { get; }\n    public bool Equals(Akka.Persistence.LoadSnapshotResult other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IStashOverflowStrategy Interface and Configurator in Akka.NET\nDESCRIPTION: This code defines the `IStashOverflowStrategy` interface and its corresponding configurator `IStashOverflowStrategyConfigurator`. The `IStashOverflowStrategy` interface represents a strategy for handling stash overflow situations in Akka.NET actors, while the `IStashOverflowStrategyConfigurator` provides a mechanism for creating instances of these strategies based on configuration settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IStashOverflowStrategy { }\npublic interface IStashOverflowStrategyConfigurator\n{\n    Akka.Persistence.IStashOverflowStrategy Create(Akka.Configuration.Config config);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Message Management Classes in Akka.NET Persistence Journal\nDESCRIPTION: Defines several sealed classes for journal operations including DeleteMessagesTo for message deletion, ReplayMessages for message replay, and WriteMessages for writing atomic messages to the journal.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_45\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class DeleteMessagesTo : System.IEquatable<Akka.Persistence.Journal.AsyncWriteTarget.DeleteMessagesTo>\n{\n    public DeleteMessagesTo(string persistenceId, long toSequenceNr) { }\n    public string PersistenceId { get; }\n    public long ToSequenceNr { get; }\n    public bool Equals(Akka.Persistence.Journal.AsyncWriteTarget.DeleteMessagesTo other) { }\n}\npublic sealed class ReplayFailure\n{\n    public ReplayFailure(System.Exception cause) { }\n    public System.Exception Cause { get; }\n}\npublic sealed class ReplayMessages : System.IEquatable<Akka.Persistence.Journal.AsyncWriteTarget.ReplayMessages>\n{\n    public ReplayMessages(string persistenceId, long fromSequenceNr, long toSequenceNr, long max) { }\n    public long FromSequenceNr { get; }\n    public long Max { get; }\n    public string PersistenceId { get; }\n    public long ToSequenceNr { get; }\n    public bool Equals(Akka.Persistence.Journal.AsyncWriteTarget.ReplayMessages other) { }\n}\npublic sealed class ReplaySuccess : System.IEquatable<Akka.Persistence.Journal.AsyncWriteTarget.ReplaySuccess>\n{\n    public ReplaySuccess(long highestSequenceNr) { }\n    public long HighestSequenceNr { get; }\n    public bool Equals(Akka.Persistence.Journal.AsyncWriteTarget.ReplaySuccess other) { }\n}\npublic sealed class WriteMessages\n{\n    public WriteMessages(System.Collections.Generic.IEnumerable<Akka.Persistence.AtomicWrite> messages) { }\n    public Akka.Persistence.AtomicWrite[] Messages { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: QueryConfiguration Class for SQL Snapshot Store\nDESCRIPTION: Defines configuration settings for SQL-based snapshot stores, including table/column names, schema information, serialization settings, and timeout values. This class provides customization options for the SQL database structure used to store snapshots.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic class QueryConfiguration\n{\n    public readonly string DefaultSerializer;\n    public readonly string ManifestColumnName;\n    public readonly string PayloadColumnName;\n    public readonly string PersistenceIdColumnName;\n    public readonly string SchemaName;\n    public readonly string SequenceNrColumnName;\n    public readonly string SerializerIdColumnName;\n    public readonly string SnapshotTableName;\n    public readonly System.TimeSpan Timeout;\n    public readonly string TimestampColumnName;\n    public QueryConfiguration(string schemaName, string snapshotTableName, string persistenceIdColumnName, string sequenceNrColumnName, string payloadColumnName, string manifestColumnName, string timestampColumnName, string serializerIdColumnName, System.TimeSpan timeout, string defaultSerializer, bool useSequentialAccess) { }\n    public string FullSnapshotTableName { get; }\n    public bool UseSequentialAccess { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterClientUnreachable in Akka.NET\nDESCRIPTION: An empty class definition for ClusterClientUnreachable that implements the IClusterClientInteraction interface. This is likely used as a message to indicate connectivity issues with the cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Net.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterClientUnreachable : Akka.Cluster.Tools.Client.IClusterClientInteraction\n{\n\n\n}\n```\n\n----------------------------------------\n\nTITLE: Path Concatenation Example in HOCON\nDESCRIPTION: Demonstrates how array concatenation can be used to build up path lists, adding new elements to an existing path array using substitution.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/hocon.md#2025-04-16_snippet_5\n\nLANGUAGE: hocon\nCODE:\n```\npath = [ /bin ]\npath = ${path} [ /usr/bin ]\n```\n\n----------------------------------------\n\nTITLE: Defining Utility Classes in Akka.NET Core Namespace\nDESCRIPTION: Defines the Done and NotUsed utility classes in the Akka namespace. These classes serve as marker types for operations that either complete without returning a meaningful value (Done) or represent unused/ignored parameters (NotUsed).\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_135\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka\n{\n    public sealed class Done\n    {\n        public static readonly Akka.Done Instance;\n    }\n    public sealed class NotUsed : System.IComparable<Akka.NotUsed>, System.IEquatable<Akka.NotUsed>\n    {\n        public static readonly Akka.NotUsed Instance;\n        public int CompareTo(Akka.NotUsed other) { }\n        public override bool Equals(object obj) { }\n        public bool Equals(Akka.NotUsed other) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Tagged Event Structure in C#\nDESCRIPTION: Structure for associating tags with payload data in persistence operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_45\n\nLANGUAGE: C#\nCODE:\n```\npublic struct Tagged\n{\n    public Tagged(object payload, System.Collections.Generic.IEnumerable<string> tags) { }\n    public Tagged(object payload, System.Collections.Immutable.IImmutableSet<string> tags) { }\n    public object Payload { get; }\n    public System.Collections.Immutable.IImmutableSet<string> Tags { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Snapshot Query Executor in C# for Akka.NET\nDESCRIPTION: The AbstractQueryExecutor class provides a base implementation for snapshot query execution in SQL-based persistence. It includes methods for creating, deleting, and selecting snapshots from the database.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AbstractQueryExecutor : Akka.Persistence.Sql.Common.Snapshot.ISnapshotQueryExecutor\n{\n    protected Akka.Serialization.Serialization Serialization;\n    protected AbstractQueryExecutor(Akka.Persistence.Sql.Common.Snapshot.QueryConfiguration configuration, Akka.Serialization.Serialization serialization) { }\n    public Akka.Persistence.Sql.Common.Snapshot.QueryConfiguration Configuration { get; }\n    protected abstract string CreateSnapshotTableSql { get; }\n    protected virtual string DeleteSnapshotRangeSql { get; }\n    protected virtual string DeleteSnapshotSql { get; }\n    protected virtual string InsertSnapshotSql { get; }\n    protected virtual string SelectSnapshotSql { get; }\n    protected void AddParameter(System.Data.Common.DbCommand command, string parameterName, System.Data.DbType parameterType, object value) { }\n    protected abstract System.Data.Common.DbCommand CreateCommand(System.Data.Common.DbConnection connection);\n    public virtual System.Threading.Tasks.Task CreateTableAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken) { }\n    public virtual System.Threading.Tasks.Task DeleteAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string persistenceId, long sequenceNr, System.Nullable<System.DateTime> timestamp) { }\n    public virtual System.Threading.Tasks.Task DeleteBatchAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string persistenceId, long maxSequenceNr, System.DateTime maxTimestamp) { }\n    protected System.Data.Common.DbCommand GetCommand(System.Data.Common.DbConnection connection, string sql) { }\n    protected object GetSnapshot(System.Data.Common.DbDataReader reader) { }\n    public virtual System.Threading.Tasks.Task InsertAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, object snapshot, Akka.Persistence.SnapshotMetadata metadata) { }\n    protected virtual void PreAddParameterToCommand(System.Data.Common.DbCommand command, System.Data.Common.DbParameter param) { }\n    protected virtual Akka.Persistence.SelectedSnapshot ReadSnapshot(System.Data.Common.DbDataReader reader) { }\n    public virtual System.Threading.Tasks.Task<Akka.Persistence.SelectedSnapshot> SelectSnapshotAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string persistenceId, long maxSequenceNr, System.DateTime maxTimestamp) { }\n    protected virtual void SetManifestParameters(object snapshot, System.Data.Common.DbCommand command) { }\n    protected virtual void SetPayloadParameter(object snapshot, System.Data.Common.DbCommand command) { }\n    protected virtual void SetPersistenceIdParameter(string persistenceId, System.Data.Common.DbCommand command) { }\n    protected virtual void SetSequenceNrParameter(long sequenceNr, System.Data.Common.DbCommand command) { }\n    protected virtual void SetTimestampParameter(System.DateTime timestamp, System.Data.Common.DbCommand command) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating DiscardConfigurator in C#\nDESCRIPTION: This snippet defines the DiscardConfigurator class, which is responsible for configuring the discard overflow strategy in Akka. It implements a method to create an overflow strategy based on the provided Akka configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class DiscardConfigurator : Akka.Persistence.IStashOverflowStrategyConfigurator\n{\n    public DiscardConfigurator() { }\n    public Akka.Persistence.IStashOverflowStrategy Create(Akka.Configuration.Config config) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IPersistentRepresentation Interface\nDESCRIPTION: This snippet defines the `IPersistentRepresentation` interface, representing the core data structure for persisting events and snapshots in Akka.Persistence. It implements `IMessage` from Akka.Persistence.Serialization. It includes properties for the event payload, sequence number, persistence ID, sender, manifest, timestamp, and writer GUID, along with methods for updating and modifying the representation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\n\"public interface IPersistentRepresentation : Akka.Persistence.Serialization.IMessage\n    {\n        bool IsDeleted { get; }\n        string Manifest { get; }\n        object Payload { get; }\n        string PersistenceId { get; }\n        Akka.Actor.IActorRef Sender { get; }\n        long SequenceNr { get; }\n        long Timestamp { get; }\n        string WriterGuid { get; }\n        Akka.Persistence.IPersistentRepresentation Update(long sequenceNr, string persistenceId, bool isDeleted, Akka.Actor.IActorRef sender, string writerGuid);\n        Akka.Persistence.IPersistentRepresentation WithManifest(string manifest);\n        Akka.Persistence.IPersistentRepresentation WithPayload(object payload);\n        Akka.Persistence.IPersistentRepresentation WithTimestamp(long timestamp);\n    }\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic EventSequence Class for Akka.NET Persistence\nDESCRIPTION: This generic class represents a sequence of events in Akka.NET persistence, implementing IEventSequence interface with equality comparison.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic class EventSequence<T> : Akka.Persistence.Journal.IEventSequence, System.IEquatable<Akka.Persistence.Journal.IEventSequence>\n{\n    public EventSequence(System.Collections.Generic.IEnumerable<object> events) { }\n    public System.Collections.Generic.IEnumerable<object> Events { get; }\n    public bool Equals(Akka.Persistence.Journal.IEventSequence other) { }\n    public override bool Equals(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Client Status Classes in C#\nDESCRIPTION: Classes representing client state changes in the cluster, including ClusterClientUnreachable and ClusterClientUp, both implementing the IClusterClientInteraction interface.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterClientUnreachable : Akka.Cluster.Tools.Client.IClusterClientInteraction\n{\n    public ClusterClientUnreachable(Akka.Actor.IActorRef clusterClient) { }\n    public Akka.Actor.IActorRef ClusterClient { get; }\n}\n\npublic sealed class ClusterClientUp : Akka.Cluster.Tools.Client.IClusterClientInteraction\n{\n    public ClusterClientUp(Akka.Actor.IActorRef clusterClient) { }\n    public Akka.Actor.IActorRef ClusterClient { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Protected Journal Methods in C#\nDESCRIPTION: Defines various protected methods for journal operations including handling persistence IDs, buffer overflow, event reading and writing, and sequence number retrieval.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nprotected virtual System.Threading.Tasks.Task HandleSelectCurrentPersistenceIds(Akka.Persistence.Sql.Common.Journal.SelectCurrentPersistenceIds message, TCommand command) { }\nprotected virtual void OnBufferOverflow(Akka.Persistence.IJournalMessage request) { }\nprotected virtual void PreAddParameterToCommand(TCommand command, System.Data.Common.DbParameter param) { }\nprotected override void PreStart() { }\nprotected virtual Akka.Persistence.IPersistentRepresentation ReadEvent(System.Data.Common.DbDataReader reader) { }\nprotected virtual System.Threading.Tasks.Task<long> ReadHighestSequenceNr(string persistenceId, TCommand command) { }\nprotected virtual System.Threading.Tasks.Task<long> ReadHighestSequenceNr(TCommand command) { }\nprotected virtual bool Receive(object message) { }\nprotected virtual void WriteEvent(TCommand command, Akka.Persistence.IPersistentRepresentation persistent, string tags = \"\") { }\n```\n\n----------------------------------------\n\nTITLE: Transport Adapter Handle Class Implementation in C#\nDESCRIPTION: Abstract class for handling transport adapter connections with methods for managing association handles and address mapping.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AbstractTransportAdapterHandle : Akka.Remote.Transport.AssociationHandle\n{\n    protected AbstractTransportAdapterHandle(Akka.Remote.Transport.AssociationHandle wrappedHandle, string addedSchemeIdentifier) { }\n    protected AbstractTransportAdapterHandle(Akka.Actor.Address originalLocalAddress, Akka.Actor.Address originalRemoteAddress, Akka.Remote.Transport.AssociationHandle wrappedHandle, string addedSchemeIdentifier) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Snapshot Entry Class in C#\nDESCRIPTION: Data class representing a snapshot entry with persistence ID, sequence number, timestamp, manifest, and payload information.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Core.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic class SnapshotEntry\n{\n    public readonly string Manifest;\n    public readonly object Payload;\n    public readonly string PersistenceId;\n    public readonly long SequenceNr;\n    public readonly System.DateTime Timestamp;\n    public SnapshotEntry(string persistenceId, long sequenceNr, System.DateTime timestamp, string manifest, object payload) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IUpdateFailure Interface for Error Handling in C#\nDESCRIPTION: Defines an interface for representing failures during update operations in the distributed data system, including access to the exception that caused the failure.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IUpdateFailure : Akka.Actor.INoSerializationVerificationNeeded, Akka.DistributedData.IUpdateResponse\n{\n    System.Exception Cause { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Protobuf Serialization for AddressData in Akka.NET\nDESCRIPTION: Defines a serialization class for Akka actor addresses using Google Protobuf. This class handles serialization of network address components including hostname, port, protocol, and system name.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class AddressData : Google.Protobuf.IDeepCloneable<Akka.Cluster.Metrics.Serialization.AddressData>, Google.Protobuf.IMessage, Google.Protobuf.IMessage<Akka.Cluster.Metrics.Serialization.AddressData>, System.IEquatable<Akka.Cluster.Metrics.Serialization.AddressData>\n{\n    public const int HostnameFieldNumber = 2;\n    public const int PortFieldNumber = 3;\n    public const int ProtocolFieldNumber = 4;\n    public const int SystemFieldNumber = 1;\n    public AddressData() { }\n    public AddressData(Akka.Cluster.Metrics.Serialization.AddressData other) { }\n    public static Google.Protobuf.Reflection.MessageDescriptor Descriptor { get; }\n    public string Hostname { get; set; }\n    public static Google.Protobuf.MessageParser<Akka.Cluster.Metrics.Serialization.AddressData> Parser { get; }\n    public uint Port { get; set; }\n    public string Protocol { get; set; }\n    public string System { get; set; }\n    public int CalculateSize() { }\n    public Akka.Cluster.Metrics.Serialization.AddressData Clone() { }\n    public override bool Equals(object other) { }\n    public bool Equals(Akka.Cluster.Metrics.Serialization.AddressData other) { }\n    public override int GetHashCode() { }\n    public void MergeFrom(Akka.Cluster.Metrics.Serialization.AddressData other) { }\n    public void MergeFrom(Google.Protobuf.CodedInputStream input) { }\n    public override string ToString() { }\n    public void WriteTo(Google.Protobuf.CodedOutputStream output) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Isolation Level Extensions for Akka.NET SQL Persistence\nDESCRIPTION: Provides extension methods to convert between string representations and System.Data.IsolationLevel enums, and to retrieve isolation levels from configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class static IsolationLevelExtensions\n{\n    public static System.Data.IsolationLevel GetIsolationLevel(this Akka.Configuration.Config config, string key) { }\n    public static System.Data.IsolationLevel ToIsolationLevel(this string level) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Socket Options Implementation\nDESCRIPTION: Defines socket-related classes including options for socket configuration and datagram channel creation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_149\n\nLANGUAGE: C#\nCODE:\n```\npublic class Inet\n{\n    public Inet() { }\n    public abstract class AbstractSocketOption : Akka.IO.Inet.SocketOption\n    {\n        protected AbstractSocketOption() { }\n    }\n    public class DatagramChannelCreator : Akka.IO.Inet.SocketOption\n    {\n        public DatagramChannelCreator() { }\n        public virtual System.Net.Sockets.Socket Create(System.Net.Sockets.AddressFamily addressFamily) { }\n    }\n    // Additional classes omitted...\n}\n```\n\n----------------------------------------\n\nTITLE: AggregateServiceDiscoverySettings Class Definition in C#\nDESCRIPTION: Defines settings for AggregateServiceDiscovery, including configuration for multiple discovery methods to be used together.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.DotNet.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class AggregateServiceDiscoverySettings\n{\n    public AggregateServiceDiscoverySettings(Akka.Configuration.Config config) { }\n    public System.Collections.Generic.List<string> DiscoveryMethods { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Actor DeathWatch Notification in Akka.NET\nDESCRIPTION: System message for death watch notifications, implementing IDeadLetterSuppression. This message is sent when a watched actor terminates, containing information about the terminated actor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_95\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class DeathWatchNotification : Akka.Dispatch.SysMsg.SystemMessage, Akka.Event.IDeadLetterSuppression\n{\n    public DeathWatchNotification(Akka.Actor.IActorRef actor, bool existenceConfirmed, bool addressTerminated) { }\n    public Akka.Actor.IActorRef Actor { get; }\n    public bool AddressTerminated { get; }\n    public bool ExistenceConfirmed { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Storage Role in Akka.NET Cluster\nDESCRIPTION: HOCON configuration for setting up a cluster node with the 'storage' role, which will handle data retrieval and storage operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/member-roles.md#2025-04-16_snippet_2\n\nLANGUAGE: hocon\nCODE:\n```\nakka\n{\n  cluster\n  {\n    roles = [\"storage\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PNCounterKey in C# for Akka.NET Distributed Data\nDESCRIPTION: Implements a key class for PNCounter data type in Akka.NET Distributed Data. It extends the Key<PNCounter> class and provides a constructor that takes a string identifier.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class PNCounterKey : Akka.DistributedData.Key<Akka.DistributedData.PNCounter>\n{\n    public PNCounterKey(string id) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Message and Interface Definitions in C#\nDESCRIPTION: Various messages and interfaces for cluster client communication, including GetClusterClients, GetContactPoints, subscription mechanisms, and contact point management interfaces.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class GetClusterClients\n{\n    public static Akka.Cluster.Tools.Client.GetClusterClients Instance { get; }\n}\n\npublic sealed class GetContactPoints : Akka.Cluster.Tools.Client.IGetContactPoints\n{\n    public static readonly Akka.Cluster.Tools.Client.GetContactPoints Instance;\n}\n\npublic interface IClusterClientInteraction\n{\n    Akka.Actor.IActorRef ClusterClient { get; }\n}\n\npublic interface IClusterClientMessage { }\n\npublic interface IContactPointChange\n{\n    Akka.Actor.ActorPath ContactPoint { get; }\n}\n\npublic interface IGetContactPoints { }\n\npublic interface ISubscribeContactPoints { }\n\npublic interface IUnsubscribeContactPoints { }\n\npublic sealed class SubscribeClusterClients\n{\n    public static Akka.Cluster.Tools.Client.SubscribeClusterClients Instance { get; }\n}\n\npublic sealed class SubscribeContactPoints : Akka.Cluster.Tools.Client.ISubscribeContactPoints\n{\n    public static readonly Akka.Cluster.Tools.Client.SubscribeContactPoints Instance;\n}\n\npublic sealed class UnsubscribeClusterClients\n{\n    public static Akka.Cluster.Tools.Client.UnsubscribeClusterClients Instance { get; }\n}\n\npublic sealed class UnsubscribeContactPoints : Akka.Cluster.Tools.Client.IUnsubscribeContactPoints\n{\n    public static readonly Akka.Cluster.Tools.Client.UnsubscribeContactPoints Instance;\n```\n\n----------------------------------------\n\nTITLE: Defining IStartableAllocationStrategy Interface in Akka.NET Sharding\nDESCRIPTION: This interface extends `IShardAllocationStrategy` with a `Start` method. It is used for allocation strategies that require initialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\n    public interface IStartableAllocationStrategy : Akka.Actor.INoSerializationVerificationNeeded, Akka.Cluster.Sharding.IShardAllocationStrategy\n    {\n        void Start();\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining AbstractTransportAdapter in C#\nDESCRIPTION: An abstract class for transport adapters in Akka.NET, providing methods for intercepting associations and listening.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nprotected abstract void InterceptAssociate(Akka.Actor.Address remoteAddress, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.AssociationHandle> statusPromise);\nprotected abstract System.Threading.Tasks.Task<Akka.Remote.Transport.IAssociationEventListener> InterceptListen(Akka.Actor.Address listenAddress, System.Threading.Tasks.Task<Akka.Remote.Transport.IAssociationEventListener> listenerTask);\npublic override bool IsResponsibleFor(Akka.Actor.Address remote) { }\npublic override System.Threading.Tasks.Task<System.ValueTuple<Akka.Actor.Address, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.IAssociationEventListener>>> Listen() { }\npublic override System.Threading.Tasks.Task<bool> Shutdown() { }\n```\n\n----------------------------------------\n\nTITLE: Defining WriteMessageFailure Class in Akka.NET Persistence\nDESCRIPTION: The WriteMessageFailure class represents a failure to write a message to the journal. It contains the persistent message, the cause of the failure, and the actor instance ID.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class WriteMessageFailure : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IJournalMessage, Akka.Persistence.IJournalResponse, Akka.Persistence.IPersistenceMessage, System.IEquatable<Akka.Persistence.WriteMessageFailure>\n{\n    public WriteMessageFailure(Akka.Persistence.IPersistentRepresentation persistent, System.Exception cause, int actorInstanceId) { }\n    public int ActorInstanceId { get; }\n    public System.Exception Cause { get; }\n    public Akka.Persistence.IPersistentRepresentation Persistent { get; }\n    public bool Equals(Akka.Persistence.WriteMessageFailure other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterRouterSettingsBase Class in C#\nDESCRIPTION: Implements an abstract base class for cluster router settings. This class provides common properties used by both ClusterRouterGroupSettings and ClusterRouterPoolSettings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Core.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ClusterRouterSettingsBase\n{\n    protected ClusterRouterSettingsBase(int totalInstances, bool allowLocalRoutees, string useRole) { }\n    public bool AllowLocalRoutees { get; }\n    public int TotalInstances { get; }\n    public string UseRole { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IStringMatcher Interface in C#\nDESCRIPTION: Defines the IStringMatcher interface with a single method IsMatch for string matching operations. This interface is implemented by various matcher classes in the TestKit.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IStringMatcher\n{\n    bool IsMatch(string s);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LWWRegisterKey Class in C#\nDESCRIPTION: This snippet defines a sealed class `LWWRegisterKey<T>` that inherits from `Key<LWWRegister<T>>`. It represents a key specifically for LWWRegister replicated data types. It includes a property for accessing the register type.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\n    public sealed class LWWRegisterKey<T> : Akka.DistributedData.Key<Akka.DistributedData.LWWRegister<T>>\n    {\n        public LWWRegisterKey(string id) { }\n        public System.Type RegisterType { get; }\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Defining Assembly Metadata for Akka.NET TestKit in C#\nDESCRIPTION: Sets assembly-level attributes including repository URL, COM visibility, GUID, and target framework for the Akka.NET TestKit module.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"ae01b790-1478-4917-9299-b4855ba997cb\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETCoreApp,Version=v6.0\", FrameworkDisplayName=\".NET 6.0\")]\n```\n\n----------------------------------------\n\nTITLE: Defining an Actor with Injected Dependencies\nDESCRIPTION: This code defines an actor class (HasherActor) that uses dependency injection to receive its dependencies through the constructor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/dependency-injection.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[HasherActor](../../../src/examples/AspNetCore/Samples.Akka.AspNetCore/Actors/HasherActor.cs?name=HasherActor)]\n```\n\n----------------------------------------\n\nTITLE: Embedding YouTube Video in Akka.NET Documentation\nDESCRIPTION: This snippet demonstrates how to embed a YouTube video within the Akka.NET documentation, providing an instructional video for users.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/index.md#2025-04-16_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/2Orp1ohI61o?si=HwBAn55QjSHqkE5S\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n```\n\n----------------------------------------\n\nTITLE: Implementing MatchesAll Class in Akka.NET TestKit\nDESCRIPTION: A singleton string matcher that matches all strings. This implements IStringMatcher and provides a static Instance property for easy access to the singleton instance.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_46\n\nLANGUAGE: C#\nCODE:\n```\npublic class MatchesAll : Akka.TestKit.Internal.StringMatcher.IStringMatcher\n{\n    public static Akka.TestKit.Internal.StringMatcher.IStringMatcher Instance { get; }\n    public bool IsMatch(string s) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Consistency Interfaces for Akka.NET Distributed Data\nDESCRIPTION: Defines the interfaces for read and write consistency models in Akka.NET's distributed data, each specifying a timeout duration for operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IReadConsistency\n{\n    System.TimeSpan Timeout { get; }\n}\npublic interface IWriteConsistency\n{\n    System.TimeSpan Timeout { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing JournalBufferOverflowException in C#\nDESCRIPTION: An exception class that represents journal buffer overflow conditions. Extends AkkaException and provides a singleton instance for performance optimization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic class JournalBufferOverflowException : Akka.Actor.AkkaException\n{\n    public static readonly Akka.Persistence.Sql.Common.Journal.JournalBufferOverflowException Instance;\n    public JournalBufferOverflowException() { }\n    protected JournalBufferOverflowException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IClusterMetricMessage interface for Akka.NET\nDESCRIPTION: This interface, `IClusterMetricMessage`, serves as a marker interface for cluster metric messages within Akka.NET. It's decorated with the `InternalApiAttribute` indicating it's intended for internal use within the framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\n    public interface IClusterMetricMessage { }\n```\n\n----------------------------------------\n\nTITLE: Implementing DynamicAccess Static Class in C#\nDESCRIPTION: An internal API utility class for dynamic type creation. Provides CreateInstanceFor method to instantiate types by name with support for Try monad pattern for error handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_235\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic class static DynamicAccess\n{\n    [Akka.Annotations.InternalApiAttribute()]\n    public static Akka.Util.Try<TResult> CreateInstanceFor<TResult>(string typeName, params object[] args)\n        where TResult :  class { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SuspendReason Abstract Class Hierarchy in C#\nDESCRIPTION: A class hierarchy representing reasons why an actor might be suspended. Includes specialized subclasses for Creation, Recreation, Termination, and UserRequest suspension reasons.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_61\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class SuspendReason\n{\n    protected SuspendReason() { }\n    public class Creation : Akka.Actor.Internal.SuspendReason, Akka.Actor.Internal.SuspendReason.IWaitingForChildren\n    {\n        public Creation() { }\n    }\n    public interface IWaitingForChildren { }\n    public class Recreation : Akka.Actor.Internal.SuspendReason, Akka.Actor.Internal.SuspendReason.IWaitingForChildren\n    {\n        public Recreation(System.Exception cause) { }\n        public System.Exception Cause { get; }\n    }\n    public class Termination : Akka.Actor.Internal.SuspendReason\n    {\n        public static Akka.Actor.Internal.SuspendReason.Termination Instance { get; }\n    }\n    public class UserRequest : Akka.Actor.Internal.SuspendReason\n    {\n        public static Akka.Actor.Internal.SuspendReason.UserRequest Instance { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Task Functionality for Akka.NET Testing\nDESCRIPTION: The TaskExtensions class provides extension methods for Task objects, adding timeout and assertion capabilities useful in Akka.NET testing scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic class static TaskExtensions\n{\n    public static System.Threading.Tasks.Task<bool> AwaitWithTimeout(this System.Threading.Tasks.Task parentTask, System.TimeSpan timeout, System.Threading.CancellationToken cancellationToken = null) { }\n    public static System.Threading.Tasks.Task ShouldCompleteWithin<T>(this System.Threading.Tasks.Task<T> task, T expected, System.TimeSpan timeout, string because = \"\", params object[] becauseArgs) { }\n    public static System.Threading.Tasks.Task<T> ShouldCompleteWithin<T>(this System.Threading.Tasks.Task<T> task, System.TimeSpan timeout, string because = \"\", params object[] becauseArgs) { }\n    public static System.Threading.Tasks.Task ShouldCompleteWithin(this System.Threading.Tasks.Task task, System.TimeSpan timeout, string because = \"\", params object[] becauseArgs) { }\n    public static System.Threading.Tasks.Task ShouldThrowWithin<T>(this System.Threading.Tasks.Task task, T expected, System.TimeSpan timeout, string because = \"\", params object[] becauseArgs)\n        where T : System.Exception { }\n    public static System.Threading.Tasks.Task<T> ShouldThrowWithin<T>(this System.Threading.Tasks.Task task, System.TimeSpan timeout, string because = \"\", params object[] becauseArgs)\n        where T : System.Exception { }\n    public static System.Threading.Tasks.Task<T> WithTimeout<T>(this System.Threading.Tasks.Task<T> parentTask, System.TimeSpan timeout, System.Threading.CancellationToken cancellationToken = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Assembly Metadata for Akka.NET Remote Module in C#\nDESCRIPTION: Sets up assembly metadata including repository URL, internal visibility to other Akka.NET modules, and targeting .NET Core 6.0.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Benchmarks\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster\")]\n// ... (additional InternalsVisibleTo attributes)\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"78986bdb-73f7-4532-8e03-1c9ccbe8148e\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETCoreApp,Version=v6.0\", FrameworkDisplayName=\".NET 6.0\")]\n```\n\n----------------------------------------\n\nTITLE: Implementing ISnapshotter Interface in C#\nDESCRIPTION: Defines the ISnapshotter interface that provides methods for managing snapshots including saving, loading and deleting snapshots. Contains properties for sequence number and snapshotter ID.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ISnapshotter\n{\n    long SnapshotSequenceNr { get; }\n    string SnapshotterId { get; }\n    void DeleteSnapshot(long sequenceNr);\n    void DeleteSnapshots(Akka.Persistence.SnapshotSelectionCriteria criteria);\n    void LoadSnapshot(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria, long toSequenceNr);\n    void SaveSnapshot(object snapshot);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ClusterSingletonManager in Akka.Net using HOCON\nDESCRIPTION: HOCON configuration for ClusterSingletonManagerSettings which is passed to the ClusterSingletonManager.props factory method. These settings control singleton actor name, role-based deployment, hand-over behavior when the oldest node changes, and retry mechanisms.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-singleton.md#2025-04-16_snippet_4\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster.singleton {\n  # The actor name of the child singleton actor.\n  singleton-name = \"singleton\"\n  \n  # Singleton among the nodes tagged with specified role.\n  # If the role is not specified it's a singleton among all nodes in the cluster.\n  role = \"\"\n  \n  # When a node is becoming oldest it sends hand-over request to previous oldest, \n  # that might be leaving the cluster. This is retried with this interval until \n  # the previous oldest confirms that the hand over has started or the previous \n  # oldest member is removed from the cluster (+ akka.cluster.down-removal-margin).\n  hand-over-retry-interval = 1s\n  \n  # The number of retries are derived from hand-over-retry-interval and\n  # akka.cluster.down-removal-margin (or ClusterSingletonManagerSettings.RemovalMargin),\n  # but it will never be less than this property.\n  min-number-of-hand-over-retries = 10\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WriteMessages Class for Akka.NET Persistence Journal\nDESCRIPTION: This class encapsulates a collection of atomic write operations for the Akka.NET persistence journal, used for batching multiple write operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class WriteMessages\n{\n    public WriteMessages(System.Collections.Generic.IEnumerable<Akka.Persistence.AtomicWrite> messages) { }\n    public Akka.Persistence.AtomicWrite[] Messages { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AsyncWriteProxy Class in C#\nDESCRIPTION: Abstract proxy implementation for AsyncWriteJournal that adds stashing capability and timeout handling. Used to create proxies to other journal implementations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AsyncWriteProxy : Akka.Persistence.Journal.AsyncWriteJournal, Akka.Actor.IActorStash, Akka.Actor.IWithUnboundedStash, Akka.Actor.IWithUnrestrictedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics>\n{\n    protected AsyncWriteProxy() { }\n    public Akka.Actor.IStash Stash { get; set; }\n    public abstract System.TimeSpan Timeout { get; }\n    public override void AroundPreStart() { }\n    protected override bool AroundReceive(Akka.Actor.Receive receive, object message) { }\n    protected override System.Threading.Tasks.Task DeleteMessagesToAsync(string persistenceId, long toSequenceNr) { }\n    public override System.Threading.Tasks.Task<long> ReadHighestSequenceNrAsync(string persistenceId, long fromSequenceNr) { }\n    public override System.Threading.Tasks.Task ReplayMessagesAsync(Akka.Actor.IActorContext context, string persistenceId, long fromSequenceNr, long toSequenceNr, long max, System.Action<Akka.Persistence.IPersistentRepresentation> recoveryCallback) { }\n    protected override System.Threading.Tasks.Task<System.Collections.Immutable.IImmutableList<System.Exception>> WriteMessagesAsync(System.Collections.Generic.IEnumerable<Akka.Persistence.AtomicWrite> messages) { }\n    public class InitTimeout\n    {\n        public static Akka.Persistence.Journal.AsyncWriteProxy.InitTimeout Instance { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DeleteSnapshotsFailure Class in C#\nDESCRIPTION: This snippet outlines the DeleteSnapshotsFailure class, used for handling errors in snapshot deletion requests. It includes references to the criteria used and details about the failure cause, while implementing the appropriate interfaces for structured messaging.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class DeleteSnapshotsFailure : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage, Akka.Persistence.ISnapshotResponse, System.IEquatable<Akka.Persistence.DeleteSnapshotsFailure>\n{\n    public DeleteSnapshotsFailure(Akka.Persistence.SnapshotSelectionCriteria criteria, System.Exception cause) { }\n    public System.Exception Cause { get; }\n    public Akka.Persistence.SnapshotSelectionCriteria Criteria { get; }\n    public bool Equals(Akka.Persistence.DeleteSnapshotsFailure other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Repairing Network Partitions with TestConductor.PassThrough in C#\nDESCRIPTION: This snippet shows how to repair a previously created network partition by using TestConductor.PassThrough. This allows Akka.Remote to resume normal network communication between the previously isolated nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/testing/multi-node-testing-old.md#2025-04-16_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nRunOn(() =>\n{\n    TestConductor.PassThrough(_config.First, _config.Second, \n        ThrottleTransportAdapter.Direction.Both).Wait();\n}, _config.First);\nEnterBarrier(\"repair-2\");\n```\n\n----------------------------------------\n\nTITLE: StoreFailure Class Definition in C#\nDESCRIPTION: Represents a failure during distributed data store operations in Akka.NET. Implements multiple interfaces for integration with the DistributedData replication system and includes functionality to propagate failures as exceptions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_46\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class StoreFailure : Akka.Actor.INoSerializationVerificationNeeded, Akka.DistributedData.IDeleteResponse, Akka.DistributedData.IUpdateFailure, Akka.DistributedData.IUpdateResponse, System.IEquatable<Akka.DistributedData.StoreFailure>\n{\n    public StoreFailure(Akka.DistributedData.IKey key, object request = null) { }\n    public bool AlreadyDeleted { get; }\n    public System.Exception Cause { get; }\n    public object Request { get; }\n    public bool Equals(Akka.DistributedData.StoreFailure other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public void ThrowOnFailure() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Device Response Timeout - C#\nDESCRIPTION: This snippet evaluates the query actor's behavior when not all devices respond within the specified timeout. It aims to ensure that the actor can manage response times effectively.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-4.md#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[DeviceGroupQuerySpec.cs](../../../../src/core/Akka.Docs.Tutorials/Tutorial4/DeviceGroupQuerySpec.cs?name=query-test-timeout)]\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Ask Pattern with TimeSpan.Zero\nDESCRIPTION: This example demonstrates the incorrect way of using the Ask pattern with a zero timeout value, which can lead to deadlocks in the application.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK2000.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Actor;\nusing System.Threading.Tasks;\nusing System;\n\npublic static class MyActorCaller{\n public static Task<string> Call(IActorRef actor){\n     return actor.Ask<string>(\"hello\", TimeSpan.Zero);\n }\n}\n```\n\n----------------------------------------\n\nTITLE: Protobuf Definition for Address Data\nDESCRIPTION: Protocol Buffer message definition for representing remote addresses in the wire format. Contains system name, hostname, port, and protocol information.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/wire-compatibility.md#2025-04-16_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage AddressData {\n  string system = 1;\n  string hostname = 2;\n  uint32 port = 3;\n  string protocol = 4;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Address Uid in Akka.Remote C#\nDESCRIPTION: This snippet defines AddressUid and AddressUidExtension classes which act as an extension point for the Akka remote system. The classes provide unique identifiers to remote actor addresses and allow integration with the Akka actor system. The primary function is to manage Uids for remote addresses to facilitate accurate system state representation. It relies on Akka.Actor.ExtendedActorSystem for creating extensions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class AddressUid : Akka.Actor.IExtension\n{\n    public readonly int Uid;\n    public AddressUid() { }\n}\npublic class AddressUidExtension : Akka.Actor.ExtensionIdProvider<Akka.Remote.AddressUid>\n{\n    public AddressUidExtension() { }\n    public override Akka.Remote.AddressUid CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n    public static int Uid(Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EventSourcedProducerQueue Class in C#\nDESCRIPTION: Static class for creating event-sourced producer queues with configurable settings. Provides factory methods for queue creation with persistence configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic class static EventSourcedProducerQueue\n{\n    public static Akka.Actor.Props Create<T>(string persistentId, Akka.Persistence.Delivery.EventSourcedProducerQueue.Settings settings) { }\n    public static Akka.Actor.Props Create<T>(string persistentId, Akka.Actor.IActorRefFactory system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Expecting No Messages in Akka.NET TestKitBase\nDESCRIPTION: These methods are used to expect that no messages are received within a specified duration. They support both synchronous and asynchronous operations with optional cancellation tokens.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic void ExpectNoMsg(System.Threading.CancellationToken cancellationToken = null) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic void ExpectNoMsg(System.TimeSpan duration, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic System.Threading.Tasks.ValueTask ExpectNoMsgAsync(System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Serialization for Cluster Metrics in C#\nDESCRIPTION: These classes handle serialization of cluster metrics messages. ClusterMetricsMessageSerializer extends SerializerWithStringManifest to serialize and deserialize metrics messages, while interfaces and data structures define the message format.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Net.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterMetricsMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public ClusterMetricsMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object o) { }\n    public override byte[] ToBinary(object obj) { }\n}\n[Akka.Annotations.InternalApiAttribute()]\npublic interface IClusterMetricMessage { }\n[Akka.Annotations.InternalApiAttribute()]\npublic sealed class MetricsGossip\n{\n    public static readonly Akka.Cluster.Metrics.Serialization.MetricsGossip Empty;\n    public MetricsGossip(System.Collections.Immutable.IImmutableSet<Akka.Cluster.Metrics.Serialization.NodeMetrics> nodes) { }\n    public System.Collections.Immutable.IImmutableSet<Akka.Cluster.Metrics.Serialization.NodeMetrics> Nodes { get; }\n    public Akka.Cluster.Metrics.Serialization.MetricsGossip Filter(System.Collections.Immutable.IImmutableSet<Akka.Actor.Address> includeNodes) { }\n    public Akka.Cluster.Metrics.Serialization.MetricsGossip Merge(Akka.Cluster.Metrics.Serialization.MetricsGossip otherGossip) { }\n    public Akka.Util.Option<Akka.Cluster.Metrics.Serialization.NodeMetrics> NodeMetricsFor(Akka.Actor.Address address) { }\n    public Akka.Cluster.Metrics.Serialization.MetricsGossip Remove(Akka.Actor.Address node) { }\n    public static Akka.Cluster.Metrics.Serialization.MetricsGossip +(Akka.Cluster.Metrics.Serialization.MetricsGossip gossip, Akka.Cluster.Metrics.Serialization.NodeMetrics newNodeMetrics) { }\n}\n[Akka.Annotations.InternalApiAttribute()]\npublic sealed class MetricsGossipEnvelope : Akka.Cluster.Metrics.Serialization.IClusterMetricMessage, Akka.Event.IDeadLetterSuppression\n{\n    public MetricsGossipEnvelope(Akka.Actor.Address fromAddress, Akka.Cluster.Metrics.Serialization.MetricsGossip gossip, bool reply) { }\n    public Akka.Actor.Address FromAddress { get; }\n    public Akka.Cluster.Metrics.Serialization.MetricsGossip Gossip { get; }\n    public bool Reply { get; }\n}\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class NodeMetrics : System.IEquatable<Akka.Cluster.Metrics.Serialization.NodeMetrics>\n{\n    public NodeMetrics(Akka.Actor.Address address, long timestamp, System.Collections.Generic.IEnumerable<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric> metrics) { }\n    public Akka.Actor.Address Address { get; }\n    public System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric> Metrics { get; }\n    public long Timestamp { get; }\n    public bool Equals(Akka.Cluster.Metrics.Serialization.NodeMetrics other) { }\n    public override int GetHashCode() { }\n    public Akka.Cluster.Metrics.Serialization.NodeMetrics Merge(Akka.Cluster.Metrics.Serialization.NodeMetrics that) { }\n    [return: System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})]\n    public Akka.Util.Option<Akka.Cluster.Metrics.Serialization.NodeMetrics.Types.Metric> Metric(string name) { }\n    public bool SameAs(Akka.Cluster.Metrics.Serialization.NodeMetrics that) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Unhandled Message Processing\nDESCRIPTION: Shows how to override default unhandled message behavior in Akka.NET actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override void Unhandled(object message)\n{\n  //Do something with the message.\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WildcardMatch Static Class\nDESCRIPTION: Static utility class that extends strings with pattern matching capabilities. The Like method checks if a string matches a pattern with wildcard support.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_223\n\nLANGUAGE: C#\nCODE:\n```\npublic class static WildcardMatch\n{\n    public static bool Like(this string text, string pattern, bool caseSensitive = False) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DefaultResizer in C#\nDESCRIPTION: Defines a DefaultResizer class that implements the Resizer interface and IEquatable<DefaultResizer>. It provides methods for resizing and adjusting the number of routees based on various parameters.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_172\n\nLANGUAGE: C#\nCODE:\n```\npublic class DefaultResizer : Akka.Routing.Resizer, System.IEquatable<Akka.Routing.DefaultResizer>\n{\n    public DefaultResizer(int lower, int upper, int pressureThreshold = 1, double rampupRate = 0.2, double backoffThreshold = 0.3, double backoffRate = 0.1, int messagesPerResize = 10) { }\n    public double BackoffRate { get; }\n    public double BackoffThreshold { get; }\n    public int LowerBound { get; set; }\n    public int MessagesPerResize { get; }\n    public int PressureThreshold { get; }\n    public double RampupRate { get; }\n    public int UpperBound { get; set; }\n    public int Backoff(int pressure, int capacity) { }\n    public int Capacity(System.Collections.Generic.IEnumerable<Akka.Routing.Routee> currentRoutees) { }\n    public bool Equals(Akka.Routing.DefaultResizer other) { }\n    public override bool Equals(object obj) { }\n    public int Filter(int pressure, int capacity) { }\n    public static Akka.Routing.DefaultResizer FromConfig(Akka.Configuration.Config resizerConfig) { }\n    public override int GetHashCode() { }\n    public override bool IsTimeForResize(long messageCounter) { }\n    public int Pressure(System.Collections.Generic.IEnumerable<Akka.Routing.Routee> currentRoutees) { }\n    public int Rampup(int pressure, int capacity) { }\n    public override int Resize(System.Collections.Generic.IEnumerable<Akka.Routing.Routee> currentRoutees) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RoundRobinPool Class in C#\nDESCRIPTION: Defines a pool-based router that uses a round-robin strategy to select routees. It includes methods for creating the router, getting the number of instances, and customizing the pool configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_207\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class RoundRobinPool : Akka.Routing.Pool\n{\n    public RoundRobinPool(Akka.Configuration.Config config) { }\n    public RoundRobinPool(int nrOfInstances) { }\n    public RoundRobinPool(int nrOfInstances, Akka.Routing.Resizer resizer) { }\n    public RoundRobinPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False) { }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override int GetNrOfInstances(Akka.Actor.ActorSystem sys) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Routing.RoundRobinPool WithDispatcher(string dispatcher) { }\n    public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n    public Akka.Routing.RoundRobinPool WithResizer(Akka.Routing.Resizer resizer) { }\n    public Akka.Routing.RoundRobinPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }\n    public class RoundRobinPoolSurrogate : Akka.Util.ISurrogate\n    {\n        public RoundRobinPoolSurrogate() { }\n        public int NrOfInstances { get; set; }\n        public Akka.Routing.Resizer Resizer { get; set; }\n        public string RouterDispatcher { get; set; }\n        public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }\n        public bool UsePoolDispatcher { get; set; }\n        public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Obsolete Failure Class in C#\nDESCRIPTION: Defines an obsolete Failure class with properties for Exception and Timestamp. This class is marked as obsolete and should be replaced with Akka.Actor.Status.Failure.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\n[System.ObsoleteAttribute(\"Use Akka.Actor.Status.Failure\")]\npublic class Failure\n{\n    public Failure() { }\n    public System.Exception Exception { get; set; }\n    public System.DateTime Timestamp { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: NoMessage System Message in Akka.NET\nDESCRIPTION: System message representing the absence of a message, typically used as a placeholder or to indicate no actual message was available for processing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_99\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class NoMessage : Akka.Dispatch.SysMsg.SystemMessage\n{\n    public NoMessage() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Data Serialization in C#\nDESCRIPTION: Custom serializers for replicated data and replicator messages in Akka.NET distributed data system. Extends SerializerWithStringManifest to handle binary serialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_48\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class ReplicatedDataSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public ReplicatedDataSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object o) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: CircuitBreakerSettings Class Implementation in C#\nDESCRIPTION: Defines the CircuitBreakerSettings class which configures circuit breaker behavior for database operations. It includes parameters for maximum failures, call timeout, and reset timeout.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class CircuitBreakerSettings\n{\n    public CircuitBreakerSettings(Akka.Configuration.Config config) { }\n    public CircuitBreakerSettings(int maxFailures, System.TimeSpan callTimeout, System.TimeSpan resetTimeout) { }\n    public System.TimeSpan CallTimeout { get; }\n    public int MaxFailures { get; }\n    public System.TimeSpan ResetTimeout { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing String Formatting Utility in C#\nDESCRIPTION: Provides a StringFormat static class with methods for safe string operations, such as joining strings with null safety. This helps prevent common string formatting issues in the framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_254\n\nLANGUAGE: C#\nCODE:\n```\npublic class static StringFormat\n{\n    public static string SafeJoin(string separator, params object[] args) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Remote Router Configuration\nDESCRIPTION: Implementation of remote router configuration that enables routing messages to remote actor nodes. Includes functionality for creating routers and managing routing instances.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class RemoteRouterConfig : Akka.Routing.Pool, System.IEquatable<Akka.Routing.RouterConfig>\n{\n    public RemoteRouterConfig(Akka.Routing.Pool local, System.Collections.Generic.IEnumerable<Akka.Actor.Address> nodes) { }\n    public override Akka.Routing.Resizer Resizer { get; }\n    public override string RouterDispatcher { get; }\n    public override Akka.Actor.SupervisorStrategy SupervisorStrategy { get; }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override Akka.Actor.ActorBase CreateRouterActor() { }\n    public bool Equals(Akka.Routing.RouterConfig other) { }\n    public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Split Brain Resolver Settings in C#\nDESCRIPTION: Provides configuration settings for handling split brain scenarios in distributed cluster environments with multiple resolution strategies\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\npublic SplitBrainResolverSettings(Akka.Configuration.Config config) { }\n```\n\n----------------------------------------\n\nTITLE: WriteAttempt Class Definition (C#)\nDESCRIPTION: Class representing an attempt to write data to a transport connection, extending the Activity class and containing payload and address information.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class WriteAttempt : Akka.Remote.Transport.Activity\n{\n    public WriteAttempt(Akka.Actor.Address sender, Akka.Actor.Address recipient, Google.Protobuf.ByteString payload) { }\n    public Google.Protobuf.ByteString Payload { get; }\n    public Akka.Actor.Address Recipient { get; }\n    public Akka.Actor.Address Sender { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Message Production in Producer Actor for Akka.Cluster.Sharding.Delivery in C#\nDESCRIPTION: Shows how a Producer actor handles RequestNext messages from the ShardingProducerController and sends messages wrapped in ShardingEnvelope.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-sharding-delivery.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nprivate void OnRequestNext(ShardingProducerController.RequestNext<IConfirmableMessage> next)\n{\n    var messages = GenerateMessages();\n    foreach (var msg in messages)\n    {\n        var entityId = ExtractEntityId(msg);\n        _producerController.Tell(\n            new ShardingEnvelope(entityId, msg));\n    }\n    Sender.Tell(ShardingProducerController.ConsumeNextCredit<IConfirmableMessage>.Instance);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Log Level Class in C#\nDESCRIPTION: A class representing error-level log events in the Akka.NET logging system. It contains the log message, source, class, and required exception cause.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_122\n\nLANGUAGE: C#\nCODE:\n```\npublic class Error : Akka.Event.LogEvent\n{\n    public Error(System.Exception cause, string logSource, System.Type logClass, object message) { }\n    public override Akka.Event.LogLevel LogLevel() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly Metadata and Target Framework Configuration in C#\nDESCRIPTION: Defines the assembly metadata with repository URL and target framework information for the Akka.NET library.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.DotNet.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETCoreApp,Version=v6.0\", FrameworkDisplayName=\".NET 6.0\")]\n```\n\n----------------------------------------\n\nTITLE: Defining InMemoryReadJournal Class in C#\nDESCRIPTION: This class implements multiple Akka.Persistence.Query interfaces for in-memory journal operations. It provides methods for querying events, persistence IDs, and handling various types of event streams.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceInMemoryQuery.DotNet.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class InMemoryReadJournal : Akka.Persistence.Query.IAllEventsQuery, Akka.Persistence.Query.ICurrentAllEventsQuery, Akka.Persistence.Query.ICurrentEventsByPersistenceIdQuery, Akka.Persistence.Query.ICurrentEventsByTagQuery, Akka.Persistence.Query.ICurrentPersistenceIdsQuery, Akka.Persistence.Query.IEventsByPersistenceIdQuery, Akka.Persistence.Query.IEventsByTagQuery, Akka.Persistence.Query.IPersistenceIdsQuery, Akka.Persistence.Query.IReadJournal\n{\n    public const string Identifier = \"akka.persistence.query.journal.inmem\";\n    public InMemoryReadJournal(Akka.Configuration.Config config) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> AllEvents(Akka.Persistence.Query.Offset offset = null) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentAllEvents(Akka.Persistence.Query.Offset offset) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentEventsByPersistenceId(string persistenceId, long fromSequenceNr, long toSequenceNr) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentEventsByTag(string tag, Akka.Persistence.Query.Offset offset) { }\n    public Akka.Streams.Dsl.Source<string, Akka.NotUsed> CurrentPersistenceIds() { }\n    public static Akka.Configuration.Config DefaultConfiguration() { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> EventsByPersistenceId(string persistenceId, long fromSequenceNr, long toSequenceNr) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> EventsByTag(string tag, Akka.Persistence.Query.Offset offset) { }\n    public Akka.Streams.Dsl.Source<string, Akka.NotUsed> PersistenceIds() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterSingletonMessageSerializer\nDESCRIPTION: Serializer class for cluster singleton messages with binary conversion support.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterSingletonMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public ClusterSingletonMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object o) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterSingleton Extension for Akka in C#\nDESCRIPTION: Defines the ClusterSingleton extension that provides access to singleton actors across a cluster. Contains methods for retrieving default configuration and initializing singleton actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_24\n\nLANGUAGE: csharp\nCODE:\n```\n[Akka.Annotations.DoNotInheritAttribute()]\npublic class ClusterSingleton : Akka.Actor.IExtension\n{\n    public ClusterSingleton(Akka.Actor.ExtendedActorSystem system) { }\n    public static Akka.Configuration.Config DefaultConfig() { }\n    public static Akka.Cluster.Tools.Singleton.ClusterSingleton Get(Akka.Actor.ActorSystem system) { }\n    [System.ObsoleteAttribute(@\"This convenience method is deprecated and will be removed in v1.6, please use ClusterSingletonManager.Props and ClusterSingletonProxy.Props directly instead. See https://getakka.net/community/whats-new/akkadotnet-v1.5-upgrade-advisories.html#upgrading-to-akkanet-v1532. Since 1.5.32.\")]\n    public Akka.Actor.IActorRef Init(Akka.Cluster.Tools.Singleton.SingletonActor singleton) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Passivate Class in C#\nDESCRIPTION: A sealed class representing a passivation command for shard regions, including a stop message.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Passivate : Akka.Cluster.Sharding.IShardRegionCommand\n{\n    public Passivate(object stopMessage) { }\n    public object StopMessage { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MetricsGossipEnvelope message with Google Protocol Buffers for Akka.NET\nDESCRIPTION: This class, `MetricsGossipEnvelope`, encapsulates a `MetricsGossip` message along with sender information and a reply flag. It implements interfaces like `IClusterMetricMessage` and `IDeadLetterSuppression`.  It's also marked with `InternalApiAttribute` for internal use.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\n    public sealed class MetricsGossipEnvelope : Akka.Cluster.Metrics.Serialization.IClusterMetricMessage, Akka.Event.IDeadLetterSuppression, Google.Protobuf.IDeepCloneable<Akka.Cluster.Metrics.Serialization.MetricsGossipEnvelope>, Google.Protobuf.IMessage, Google.Protobuf.IMessage<Akka.Cluster.Metrics.Serialization.MetricsGossipEnvelope>, System.IEquatable<Akka.Cluster.Metrics.Serialization.MetricsGossipEnvelope>\n    {\n        public const int FromFieldNumber = 1;\n        public const int GossipFieldNumber = 2;\n        public const int ReplyFieldNumber = 3;\n        public MetricsGossipEnvelope(Akka.Actor.Address fromAddress, Akka.Cluster.Metrics.Serialization.MetricsGossip gossip, bool reply) { }\n        public MetricsGossipEnvelope() { }\n        public MetricsGossipEnvelope(Akka.Cluster.Metrics.Serialization.MetricsGossipEnvelope other) { }\n        public static Google.Protobuf.Reflection.MessageDescriptor Descriptor { get; }\n        public Akka.Cluster.Metrics.Serialization.AddressData From { get; set; }\n        public Akka.Actor.Address FromAddress { get; }\n        public Akka.Cluster.Metrics.Serialization.MetricsGossip Gossip { get; set; }\n        public static Google.Protobuf.MessageParser<Akka.Cluster.Metrics.Serialization.MetricsGossipEnvelope> Parser { get; }\n        public bool Reply { get; set; }\n        public int CalculateSize() { }\n        public Akka.Cluster.Metrics.Serialization.MetricsGossipEnvelope Clone() { }\n        public override bool Equals(object other) { }\n        public bool Equals(Akka.Cluster.Metrics.Serialization.MetricsGossipEnvelope other) { }\n        public override int GetHashCode() { }\n        public void MergeFrom(Akka.Cluster.Metrics.Serialization.MetricsGossipEnvelope other) { }\n        public void MergeFrom(Google.Protobuf.CodedInputStream input) { }\n        public override string ToString() { }\n        public void WriteTo(Google.Protobuf.CodedOutputStream output) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing JournalEntry Class in C#\nDESCRIPTION: A sealed class representing a single journal entry with persistence ID, sequence number, deletion status, and payload information. Used for storing and retrieving events from the journal.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class JournalEntry\n{\n    public readonly bool IsDeleted;\n    public readonly string Manifest;\n    public readonly object Payload;\n    public readonly string PersistenceId;\n    public readonly long SequenceNr;\n    public readonly System.DateTime Timestamp;\n    public JournalEntry(string persistenceId, long sequenceNr, bool isDeleted, string manifest, System.DateTime timestamp, object payload) { }\n}\n```\n\n----------------------------------------\n\nTITLE: LeaseProviderExtensionProvider Implementation\nDESCRIPTION: Provides an extension point for the Akka actor system to create LeaseProvider instances. Extends the ExtensionIdProvider generic class and overrides CreateExtension method.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.Net.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class LeaseProviderExtensionProvider : Akka.Actor.ExtensionIdProvider<Akka.Coordination.LeaseProvider>\n{\n    public LeaseProviderExtensionProvider() { }\n    public override Akka.Coordination.LeaseProvider CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting Data from Akka.DistributedData Replicator\nDESCRIPTION: Illustrates how to delete data from the distributed data store using a Replicator.Delete request. It shows setting write consistency and handling the response.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/distributed-data.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.DistributedData;\nusing static Akka.DistributedData.Dsl;\n\nvar replicator = DistributedData.Get(system).Replicator;\nvar key = new ORSetKey<string>(\"keyA\");\nvar writeConsistency = WriteLocal.Instance;\n\nvar response = await replicator.Ask<Replicator.IDeleteResponse>(Delete(key, writeConsistency))\n```\n\n----------------------------------------\n\nTITLE: Defining TestConfigs for Akka.NET Test Configuration\nDESCRIPTION: The TestConfigs class provides static properties for default and test scheduler configurations in Akka.NET tests.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\npublic class static TestConfigs\n{\n    public static Akka.Configuration.Config DefaultConfig { get; }\n    public static Akka.Configuration.Config TestSchedulerConfig { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Pinned Dispatcher Configuration\nDESCRIPTION: Configuration for a dispatcher that uses a single dedicated thread.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/dispatchers.md#2025-04-16_snippet_5\n\nLANGUAGE: hocon\nCODE:\n```\ncustom-dedicated-dispatcher {\n  type = PinnedDispatcher\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Serialization Classes for Akka.NET Distributed Data in C#\nDESCRIPTION: This snippet defines two serialization classes, ReplicatedDataSerializer and ReplicatorMessageSerializer, used for serializing and deserializing replicated data and replicator messages in Akka.NET Distributed Data. These classes extend SerializerWithStringManifest and implement methods for binary conversion and manifest generation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_54\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ReplicatedDataSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public ReplicatedDataSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object o) { }\n    public override byte[] ToBinary(object obj) { }\n}\n\npublic sealed class ReplicatorMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public ReplicatorMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object o) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Journal Query Executor Interface\nDESCRIPTION: Defines a comprehensive interface for executing database queries related to journal persistence, including methods for creating tables, inserting and selecting events, and managing persistence IDs\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Core.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IJournalQueryExecutor { \n    QueryConfiguration Configuration { get; }\n    Task CreateTablesAsync(DbConnection connection, CancellationToken cancellationToken);\n    Task InsertBatchAsync(DbConnection connection, CancellationToken cancellationToken, WriteJournalBatch write);\n}\n```\n\n----------------------------------------\n\nTITLE: Actor Transport Adapter Implementation in C#\nDESCRIPTION: Concrete implementation of transport adapter specifically for actors, including manager properties and association handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ActorTransportAdapter : Akka.Remote.Transport.AbstractTransportAdapter\n{\n    public static readonly System.TimeSpan AskTimeout;\n    protected Akka.Actor.IActorRef modreq(System.Runtime.CompilerServices.IsVolatile) manager;\n    protected ActorTransportAdapter(Akka.Remote.Transport.Transport wrappedTransport, Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterMetricsSettings for Configuration in C#\nDESCRIPTION: This class encapsulates configuration settings for the Akka.NET cluster metrics system. It includes settings for collectors, sampling intervals, gossip intervals, and supervisor configurations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Net.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterMetricsSettings\n{\n    public ClusterMetricsSettings(Akka.Configuration.Config config) { }\n    public bool CollectorEnabled { get; }\n    public bool CollectorFallback { get; }\n    public System.TimeSpan CollectorGossipInterval { get; }\n    public System.TimeSpan CollectorMovingAverageHalfLife { get; }\n    public string CollectorProvider { get; }\n    public System.TimeSpan CollectorSampleInterval { get; }\n    public string MetricsDispatcher { get; }\n    public System.TimeSpan PeriodicTasksInitialDelay { get; }\n    public string SupervisorName { get; }\n    public Akka.Configuration.Config SupervisorStrategyConfiguration { get; }\n    public string SupervisorStrategyProvider { get; }\n    public static Akka.Cluster.Metrics.Configuration.ClusterMetricsSettings Create(Akka.Configuration.Config config) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AbstractQueryExecutor for SQL Snapshot Operations in C#\nDESCRIPTION: Abstract class for executing SQL queries related to snapshot operations. It provides methods for creating, deleting, and selecting snapshots from a SQL database.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.DotNet.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AbstractQueryExecutor : Akka.Persistence.Sql.Common.Snapshot.ISnapshotQueryExecutor\n{\n    protected Akka.Serialization.Serialization Serialization;\n    protected AbstractQueryExecutor(Akka.Persistence.Sql.Common.Snapshot.QueryConfiguration configuration, Akka.Serialization.Serialization serialization) { }\n    public Akka.Persistence.Sql.Common.Snapshot.QueryConfiguration Configuration { get; }\n    protected abstract string CreateSnapshotTableSql { get; }\n    protected virtual string DeleteSnapshotRangeSql { get; }\n    protected virtual string DeleteSnapshotSql { get; }\n    protected virtual string InsertSnapshotSql { get; }\n    public System.Data.IsolationLevel ReadIsolationLevel { get; }\n    protected virtual string SelectSnapshotSql { get; }\n    public System.Data.IsolationLevel WriteIsolationLevel { get; }\n    // ... (methods omitted for brevity)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Database Connection Extensions for Akka.NET SQL Persistence\nDESCRIPTION: Defines extension methods for DbConnection to execute tasks within transactions, supporting both void and generic return types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class static DbConnectionExtensions\n{\n    public static System.Threading.Tasks.Task ExecuteInTransaction(this System.Data.Common.DbConnection connection, System.Data.IsolationLevel isolationLevel, System.Threading.CancellationToken token, System.Func<System.Data.Common.DbTransaction, System.Threading.CancellationToken, System.Threading.Tasks.Task> task) { }\n    public static System.Threading.Tasks.Task<T> ExecuteInTransaction<T>(this System.Data.Common.DbConnection connection, System.Data.IsolationLevel isolationLevel, System.Threading.CancellationToken token, System.Func<System.Data.Common.DbTransaction, System.Threading.CancellationToken, System.Threading.Tasks.Task<T>> task) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IsolationLevelExtensions for Akka.NET Configuration in C#\nDESCRIPTION: Provides extension methods to convert between string representations and System.Data.IsolationLevel enum values, facilitating configuration of isolation levels in Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.DotNet.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class static IsolationLevelExtensions\n{\n    public static System.Data.IsolationLevel GetIsolationLevel(this Akka.Configuration.Config config, string key) { }\n    public static System.Data.IsolationLevel ToIsolationLevel(this string level) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Abstract Transport Class Definition in C#\nDESCRIPTION: Defines the base Transport class for Akka.NET remote communication with configuration properties and abstract methods for association handling, listening and shutdown operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Transport\n{\n    protected Transport() { }\n    public Akka.Configuration.Config Config { get; set; }\n    public virtual long MaximumPayloadBytes { get; set; }\n    public virtual string SchemeIdentifier { get; set; }\n    public Akka.Actor.ActorSystem System { get; set; }\n    public abstract System.Threading.Tasks.Task<Akka.Remote.Transport.AssociationHandle> Associate(Akka.Actor.Address remoteAddress);\n    public abstract bool IsResponsibleFor(Akka.Actor.Address remote);\n    public abstract System.Threading.Tasks.Task<System.ValueTuple<Akka.Actor.Address, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.IAssociationEventListener>>> Listen();\n    public virtual System.Threading.Tasks.Task<bool> ManagementCommand(object message) { }\n    public abstract System.Threading.Tasks.Task<bool> Shutdown();\n}\n```\n\n----------------------------------------\n\nTITLE: System Message Interface Definition in Akka.NET\nDESCRIPTION: Interface for all system messages in Akka.NET that extends INoSerializationVerificationNeeded. This marks messages as system messages that should be handled internally by the actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_98\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface ISystemMessage : Akka.Actor.INoSerializationVerificationNeeded { }\n```\n\n----------------------------------------\n\nTITLE: Test Synchronization Mechanism for Akka.NET Tests\nDESCRIPTION: A countdown latch implementation for synchronizing concurrent operations in tests. Provides methods for countdown, reset, and waiting with timeout support.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestLatch\n{\n    [System.ObsoleteAttribute(\"This field will be removed. TestKitSettings.DefaultTimeout is an alternative.\")]\n    public static readonly System.TimeSpan DefaultTimeout;\n    public TestLatch() { }\n    public TestLatch(int count) { }\n    public TestLatch(int count, System.TimeSpan defaultTimeout) { }\n    protected TestLatch(System.Func<System.TimeSpan, System.TimeSpan> dilate, System.TimeSpan defaultTimeout, int count) { }\n    public bool IsOpen { get; }\n    public void CountDown() { }\n    public void Open() { }\n    public void Ready(System.TimeSpan timeout) { }\n    public void Ready() { }\n    public void Reset() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly Configuration for Akka.NET\nDESCRIPTION: Assembly metadata and target framework attributes for the Akka.NET service discovery module.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\"\")]\n```\n\n----------------------------------------\n\nTITLE: Implementing PersistencePluginProxy Class in C#\nDESCRIPTION: This class acts as a proxy for persistence plugins in Akka.NET. It handles message queuing and provides methods for setting target location and starting the proxy.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic class PersistencePluginProxy : Akka.Actor.ActorBase, Akka.Actor.IActorStash, Akka.Actor.IWithUnboundedStash, Akka.Actor.IWithUnrestrictedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics>\n{\n    public PersistencePluginProxy(Akka.Configuration.Config config) { }\n    public Akka.Actor.IStash Stash { get; set; }\n    protected override void PreStart() { }\n    protected override bool Receive(object message) { }\n    public static void SetTargetLocation(Akka.Actor.ActorSystem system, Akka.Actor.Address address) { }\n    public static void Start(Akka.Actor.ActorSystem system) { }\n    public sealed class TargetLocation\n    {\n        public TargetLocation(Akka.Actor.Address address) { }\n        public Akka.Actor.Address Address { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Transport Protocol (Google Quic) in HOCON\nDESCRIPTION: Example configuration showing how to set up a third-party transport protocol (Google's Quic) for Akka.Remote. This demonstrates how to specify the transport class, protocol, and connection details.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/remoting/transports.md#2025-04-16_snippet_1\n\nLANGUAGE: xml\nCODE:\n```\nakka{\n    remote {\n        enabled-transports = [\"akka.remote.google-quic\"]\n        google-quic {\n            transport-class = \"Google.Quic.QuicTransport, Akka.Remote.Quic\"\n            applied-adapters = []\n            transport-protocol = quic\n            port = 0\n            hostname = localhost \n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic IKey<T> Interface in C#\nDESCRIPTION: Extends the IKey interface with generic type parameter T, where T must implement IReplicatedData. This allows for type-safe keys for specific replicated data types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IKey<out T> : Akka.DistributedData.IKey, Akka.DistributedData.IReplicatedDataSerialization\n    where out T : Akka.DistributedData.IReplicatedData { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterScope in C#\nDESCRIPTION: Defines the ClusterScope class which implements a singleton scope for cluster-aware actor creation. This helps in managing actors that need cluster awareness.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.DotNet.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterScope : Akka.Actor.Scope\n{\n    public static readonly Akka.Cluster.ClusterScope Instance;\n    public override Akka.Actor.Scope Copy() { }\n    public override Akka.Actor.Scope WithFallback(Akka.Actor.Scope other) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CapacityMetricsSelector in Akka.NET\nDESCRIPTION: This abstract class represents a metrics selector that will inform the routing components about the resource capabilities of each node based on specific metrics data.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Core.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class CapacityMetricsSelector : Akka.Cluster.Metrics.IMetricsSelector\n{\n    protected CapacityMetricsSelector() { }\n    public abstract System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, double> Capacity(System.Collections.Immutable.IImmutableSet<Akka.Cluster.Metrics.Serialization.NodeMetrics> nodeMetrics);\n    public System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, int> Weights(System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, double> capacity) { }\n    public System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, int> Weights(System.Collections.Immutable.IImmutableSet<Akka.Cluster.Metrics.Serialization.NodeMetrics> nodeMetrics) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StoreFailure in Akka.NET Distributed Data\nDESCRIPTION: This class represents a failure in storing distributed data. It implements various interfaces for delete responses and update failures, providing methods to check the failure status and throw exceptions when necessary.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class StoreFailure : Akka.Actor.INoSerializationVerificationNeeded, Akka.DistributedData.IDeleteResponse, Akka.DistributedData.IUpdateFailure, Akka.DistributedData.IUpdateResponse, System.IEquatable<Akka.DistributedData.StoreFailure>\n{\n    public StoreFailure(Akka.DistributedData.IKey key, object request = null) { }\n    public bool AlreadyDeleted { get; }\n    public System.Exception Cause { get; }\n    public object Request { get; }\n    public bool Equals(Akka.DistributedData.StoreFailure other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public void ThrowOnFailure() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Remote Watcher Implementation in C#\nDESCRIPTION: Actor implementation for monitoring remote actors and handling failure detection. Maintains watch relationships and manages unreachable nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class RemoteWatcher : Akka.Actor.UntypedActor, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedMessageQueueSemantics> {\n    protected readonly Akka.Event.ILoggingAdapter Log;\n    protected readonly System.Collections.Generic.Dictionary<Akka.Actor.Address, System.Collections.Generic.HashSet<Akka.Actor.IInternalActorRef>> WatcheeByNodes;\n    // ... additional members omitted for brevity\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Methods for UDP in Akka.NET\nDESCRIPTION: Static extensions to simplify access to UDP functionality from an ActorSystem. Provides a convenient Udp() method to get the UDP manager actor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_188\n\nLANGUAGE: C#\nCODE:\n```\npublic class static UdpExtensions\n{\n    public static Akka.Actor.IActorRef Udp(this Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Switch Class for State Management\nDESCRIPTION: A class that manages binary on/off state with thread-safe switching capabilities. It provides methods to check, change, and perform actions based on the current state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_216\n\nLANGUAGE: C#\nCODE:\n```\npublic class Switch\n{\n    public Switch(bool startAsOn = False) { }\n    public bool IsOff { get; }\n    public bool IsOn { get; }\n    public bool IfOff(System.Action action) { }\n    public bool IfOn(System.Action action) { }\n    public void Locked(System.Action action) { }\n    public bool SwitchOff(System.Action action) { }\n    public bool SwitchOff() { }\n    public bool SwitchOn(System.Action action) { }\n    public bool SwitchOn() { }\n    protected bool TranscendFrom(bool from, System.Action action) { }\n    public bool WhileOff(System.Action action) { }\n    public bool WhileOn(System.Action action) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterSingletonProxySettings Class\nDESCRIPTION: Configuration settings class for cluster singleton proxy with buffer size, identification intervals, and role management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterSingletonProxySettings : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public ClusterSingletonProxySettings(string singletonName, string role, System.TimeSpan singletonIdentificationInterval, int bufferSize, bool considerAppVersion, bool logSingletonIdentificationFailure, System.TimeSpan singletonIdentificationFailurePeriod) { }\n    public int BufferSize { get; }\n    public bool ConsiderAppVersion { get; }\n    public bool LogSingletonIdentificationFailure { get; }\n    public string Role { get; }\n    public System.TimeSpan SingletonIdentificationFailurePeriod { get; }\n    public System.TimeSpan SingletonIdentificationInterval { get; }\n    public string SingletonName { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Props Serialization Surrogate Implementation in Akka.NET (C#)\nDESCRIPTION: Serialization surrogate for Props class, enabling Props objects to be serialized and deserialized. Contains the Type, Deploy configuration, and constructor Arguments needed to recreate a Props instance.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\npublic class PropsSurrogate : Akka.Util.ISurrogate\n{\n    public PropsSurrogate() { }\n    public object[] Arguments { get; set; }\n    public Akka.Actor.Deploy Deploy { get; set; }\n    public System.Type Type { get; set; }\n    public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Saving Snapshot Asynchronously with Akka.Persistence and C#\nDESCRIPTION: This method asynchronously saves a snapshot using the provided metadata and snapshot object. It ensures the snapshot is stored correctly within the persistence layer of Akka. The operation is protected by a circuit breaker, enhancing stability during the execution of potentially high-latency tasks.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/custom-persistence-provider.md#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nTask SaveAsync(SnapshotMetadata metadata, object snapshot)\n\n```\n\n----------------------------------------\n\nTITLE: ServiceDiscovery.Resolved Class Definition in C#\nDESCRIPTION: Represents the result of a successful service lookup operation. Contains the service name and a collection of resolved targets (addresses) for the requested service.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.DotNet.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class Resolved : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression, System.IEquatable<Akka.Discovery.ServiceDiscovery.Resolved>\n{\n    public Resolved(string serviceName) { }\n    public Resolved(string serviceName, System.Collections.Generic.IEnumerable<Akka.Discovery.ServiceDiscovery.ResolvedTarget> addresses) { }\n    public System.Collections.Immutable.ImmutableList<Akka.Discovery.ServiceDiscovery.ResolvedTarget> Addresses { get; }\n    public string ServiceName { get; }\n    public bool Equals(Akka.Discovery.ServiceDiscovery.Resolved other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Performance Benchmark Results for Akka.NET v1.4.27\nDESCRIPTION: Shows the performance benchmark results for Akka.NET v1.4.27, demonstrating improved message throughput metrics compared to the previous version.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/RELEASE_NOTES.md#2025-04-16_snippet_11\n\nLANGUAGE: plaintext\nCODE:\n```\nOSVersion:                         Microsoft Windows NT 6.2.9200.\nProcessorCount:                    16                            \nClockSpeed:                        0 MHZ                         \nActor Count:                       32                            \nMessages sent/received per client: 200000  (2e5)                 \nIs Server GC:                      True                          \nThread count:                      111                           \n                                                                 \nNum clients, Total [msg], Msgs/sec, Total [ms]                   \n         1,  200000,    105043,    1904.29                       \n         5, 1000000,    255494,    3914.73                       \n        10, 2000000,    291843,    6853.30                       \n        15, 3000000,    291291,   10299.75                       \n        20, 4000000,    286513,   13961.68                       \n        25, 5000000,    292569,   17090.64                       \n        30, 6000000,    281492,   21315.35\n```\n\n----------------------------------------\n\nTITLE: Defining Adaptive Load Balancing Pool in Akka.Cluster\nDESCRIPTION: This snippet implements an AdaptiveLoadBalancingPool class, extending Akka.Routing.Pool. It provides a pool-based actor routing strategy that uses metrics for adaptive load balancing. Key methods allow creation of routers and management of routing logic, with dependencies on Akka.Cluster.Metrics and Akka.Routing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.DotNet.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class AdaptiveLoadBalancingPool : Akka.Routing.Pool\n{\n    public AdaptiveLoadBalancingPool(Akka.Cluster.Metrics.IMetricsSelector metricsSelector = null, int nrOfInstances = 0, Akka.Actor.SupervisorStrategy supervisorStrategy = null, string routerDispatcher = null, bool usePoolDispatcher = False) { }\n    public AdaptiveLoadBalancingPool(Akka.Configuration.Config config) { }\n    public Akka.Cluster.Metrics.IMetricsSelector MetricsSelector { get; }\n    public override Akka.Routing.Resizer Resizer { get; }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }\n    public override Akka.Actor.Props RoutingLogicController(Akka.Routing.RoutingLogic routingLogic) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Cluster.Metrics.AdaptiveLoadBalancingPool WithDispatcher(string dispatcherId) { }\n    public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n    public Akka.Cluster.Metrics.AdaptiveLoadBalancingPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IJournalMessage Interface\nDESCRIPTION: This snippet defines the `IJournalMessage` interface, which represents a message related to the journal in Akka.Persistence. It inherits from `INoSerializationVerificationNeeded` and `IPersistenceMessage`. Classes implementing this interface are typically used to interact with the persistence journal.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\n\"public interface IJournalMessage : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage { }\"\n```\n\n----------------------------------------\n\nTITLE: Event Notification and Tracking Classes in C#\nDESCRIPTION: Defines classes for event notifications like EventAppended and NewEventAppended, as well as CurrentPersistenceIds for tracking all persistence IDs in the system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class EventAppended : Akka.Event.IDeadLetterSuppression\n{\n    public readonly string PersistenceId;\n    public EventAppended(string persistenceId) { }\n}\n\npublic sealed class NewEventAppended : Akka.Event.IDeadLetterSuppression\n{\n    public static Akka.Persistence.Sql.Common.Journal.NewEventAppended Instance;\n}\n\npublic sealed class CurrentPersistenceIds : Akka.Event.IDeadLetterSuppression\n{\n    public readonly System.Collections.Generic.IEnumerable<string> AllPersistenceIds;\n    public readonly long HighestOrderingNumber;\n    public CurrentPersistenceIds(System.Collections.Generic.IEnumerable<string> allPersistenceIds, long highestOrderingNumber) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LoggerInitialized class for Akka.NET\nDESCRIPTION: This class defines a message used to indicate that a logger has been initialized. It implements INoSerializationVerificationNeeded and IDeadLetterSuppression to control serialization and dead letter behavior.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_143\n\nLANGUAGE: C#\nCODE:\n```\npublic class LoggerInitialized : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression\n{\n    public LoggerInitialized() { }\n}\n```\n\n----------------------------------------\n\nTITLE: UDP Settings Configuration in C#\nDESCRIPTION: Configuration class for UDP settings including buffer pool, logging, and dispatcher settings. Provides factory methods for creating settings from ActorSystem or Config.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_173\n\nLANGUAGE: C#\nCODE:\n```\npublic class UdpSettings\n{\n    public UdpSettings(string bufferPoolConfigPath, bool traceLogging, int initialSocketAsyncEventArgs, int batchReceiveLimit, string managementDispatcher, string fileIoDispatcher) { }\n    public int BatchReceiveLimit { get; }\n    public string BufferPoolConfigPath { get; }\n    public string FileIODispatcher { get; }\n    public int InitialSocketAsyncEventArgs { get; }\n    public string ManagementDispatcher { get; }\n    public bool TraceLogging { get; }\n    public static Akka.IO.UdpSettings Create(Akka.Actor.ActorSystem system) { }\n    public static Akka.IO.UdpSettings Create(Akka.Configuration.Config config) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Build Commands on Windows\nDESCRIPTION: Command to display all available build commands on Windows systems\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/build-process.md#2025-04-16_snippet_0\n\nLANGUAGE: console\nCODE:\n```\nbuild.cmd help\n```\n\n----------------------------------------\n\nTITLE: Defining VectorClock Ordering Enum in C#\nDESCRIPTION: Enumerates the possible ordering relationships between vector clocks, including After, Before, Same, Concurrent, and FullOrder.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic enum Ordering\n{\n    After = 0,\n    Before = 1,\n    Same = 2,\n    Concurrent = 3,\n    FullOrder = 4,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Transport Pass-Through Mode in Akka.NET\nDESCRIPTION: Implementation of a PassThru class that implements the IGremlinMode interface in the FailureInjectorTransportAdapter. This provides a singleton instance that allows messages to pass through without modification.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class PassThru : Akka.Remote.Transport.FailureInjectorTransportAdapter.IGremlinMode\n{\n    public static Akka.Remote.Transport.FailureInjectorTransportAdapter.PassThru Instance { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ORSetKey Class in C#\nDESCRIPTION: This class represents a key for ORSet in Akka.NET's distributed data system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ORSetKey<T> : Akka.DistributedData.Key<Akka.DistributedData.ORSet<T>>\n{\n    public ORSetKey(string id) { }\n    public System.Type SetType { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Core Interfaces for Akka.NET Actor System in C#\nDESCRIPTION: Defines a set of core interfaces for the Akka.NET actor system, including IActionScheduler, IActorContext, IActorProducerPlugin, IActorRef, IActorRefFactory, IActorRefProvider, and others. These interfaces define the contract for various components of the actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IActionScheduler : Akka.Actor.IRunnableScheduler\n{\n    void ScheduleOnce(System.TimeSpan delay, System.Action action, Akka.Actor.ICancelable cancelable);\n    void ScheduleOnce(System.TimeSpan delay, System.Action action);\n    void ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action, Akka.Actor.ICancelable cancelable);\n    void ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action);\n}\n\npublic interface IActorContext : Akka.Actor.IActorRefFactory, Akka.Actor.ICanWatch\n{\n    Akka.Dispatch.MessageDispatcher Dispatcher { get; }\n    Akka.Actor.IActorRef Parent { get; }\n    Akka.Actor.Props Props { get; }\n    System.Nullable<System.TimeSpan> ReceiveTimeout { get; }\n    Akka.Actor.IActorRef Self { get; }\n    Akka.Actor.IActorRef Sender { get; }\n    Akka.Actor.ActorSystem System { get; }\n    void Become(Akka.Actor.Receive receive);\n    void BecomeStacked(Akka.Actor.Receive receive);\n    Akka.Actor.IActorRef Child(string name);\n    System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> GetChildren();\n    void SetReceiveTimeout(System.Nullable<System.TimeSpan> timeout);\n    void Stop(Akka.Actor.IActorRef child);\n    void UnbecomeStacked();\n}\n\npublic interface IActorProducerPlugin\n{\n    void AfterIncarnated(Akka.Actor.ActorBase actor, Akka.Actor.IActorContext context);\n    void BeforeIncarnated(Akka.Actor.ActorBase actor, Akka.Actor.IActorContext context);\n    bool CanBeAppliedTo(System.Type actorType);\n}\n\npublic interface IActorRef : Akka.Actor.ICanTell, Akka.Util.ISurrogated, System.IComparable, System.IComparable<Akka.Actor.IActorRef>, System.IEquatable<Akka.Actor.IActorRef>\n{\n    Akka.Actor.ActorPath Path { get; }\n}\n\npublic interface IActorRefFactory\n{\n    Akka.Actor.IActorRef ActorOf(Akka.Actor.Props props, string name = null);\n    Akka.Actor.ActorSelection ActorSelection(Akka.Actor.ActorPath actorPath);\n    Akka.Actor.ActorSelection ActorSelection(string actorPath);\n}\n\npublic interface IActorRefProvider\n{\n    Akka.Actor.IActorRef DeadLetters { get; }\n    Akka.Actor.Address DefaultAddress { get; }\n    Akka.Actor.Deployer Deployer { get; }\n    Akka.Actor.LocalActorRef Guardian { get; }\n    Akka.Actor.IActorRef IgnoreRef { get; }\n    Akka.Actor.IInternalActorRef RootGuardian { get; }\n    Akka.Actor.ActorPath RootPath { get; }\n    [Akka.Annotations.InternalApiAttribute()]\n    Akka.Serialization.Information SerializationInformation { get; }\n    Akka.Actor.Settings Settings { get; }\n    Akka.Actor.LocalActorRef SystemGuardian { get; }\n    Akka.Actor.IInternalActorRef TempContainer { get; }\n    System.Threading.Tasks.Task TerminationTask { get; }\n    Akka.Actor.IInternalActorRef ActorOf(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.Props props, Akka.Actor.IInternalActorRef supervisor, Akka.Actor.ActorPath path, bool systemService, Akka.Actor.Deploy deploy, bool lookupDeploy, bool async);\n    [Akka.Annotations.InternalApiAttribute()]\n    Akka.Actor.FutureActorRef<T> CreateFutureRef<T>(System.Threading.Tasks.TaskCompletionSource<T> tcs);\n    Akka.Actor.Address GetExternalAddressFor(Akka.Actor.Address address);\n    void Init(Akka.Actor.Internal.ActorSystemImpl system);\n    void RegisterTempActor(Akka.Actor.IInternalActorRef actorRef, Akka.Actor.ActorPath path);\n    Akka.Actor.IActorRef ResolveActorRef(string path);\n    Akka.Actor.IActorRef ResolveActorRef(Akka.Actor.ActorPath actorPath);\n    Akka.Actor.IActorRef RootGuardianAt(Akka.Actor.Address address);\n    Akka.Actor.ActorPath TempPath();\n    void UnregisterTempActor(Akka.Actor.ActorPath path);\n}\n\n[Akka.Annotations.InternalApiAttribute()]\npublic interface IActorRefScope\n{\n    bool IsLocal { get; }\n}\n\npublic interface IActorStash\n{\n    Akka.Actor.IStash Stash { get; set; }\n}\n\npublic interface IActorTelemetryEvent : Akka.Actor.INoSerializationVerificationNeeded, Akka.Actor.INotInfluenceReceiveTimeout\n{\n    System.Type ActorType { get; }\n    string ActorTypeOverride { get; }\n    Akka.Actor.IActorRef Subject { get; }\n}\n\npublic interface IAdvancedScheduler : Akka.Actor.IActionScheduler, Akka.Actor.IRunnableScheduler { }\n\npublic interface IAutoReceivedMessage { }\n\npublic interface ICanTell\n{\n    void Tell(object message, Akka.Actor.IActorRef sender);\n}\n\npublic interface ICanWatch\n{\n    Akka.Actor.IActorRef Unwatch(Akka.Actor.IActorRef subject);\n    Akka.Actor.IActorRef Watch(Akka.Actor.IActorRef subject);\n    Akka.Actor.IActorRef WatchWith(Akka.Actor.IActorRef subject, object message);\n}\n\npublic interface ICancelable\n{\n    bool IsCancellationRequested { get; }\n    System.Threading.CancellationToken Token { get; }\n    void Cancel();\n    void Cancel(bool throwOnFirstException);\n    void CancelAfter(System.TimeSpan delay);\n    void CancelAfter(int millisecondsDelay);\n}\n\n[Akka.Annotations.InternalApiAttribute()]\npublic interface ICell\n{\n    Akka.Actor.Internal.IChildrenContainer ChildrenContainer { get; }\n    bool HasMessages { get; }\n    bool IsLocal { get; }\n    bool IsTerminated { get; }\n    int NumberOfMessages { get; }\n    Akka.Actor.IInternalActorRef Parent { get; }\n    Akka.Actor.Props Props { get; }\n    Akka.Actor.IActorRef Self { get; }\n    Akka.Actor.ActorSystem System { get; }\n    Akka.Actor.Internal.ActorSystemImpl SystemImpl { get; }\n    Akka.Actor.IInternalActorRef GetChildByName(string name);\n    [System.ObsoleteAttribute(\"Used ChildrenRefs instead [1.1.0]\")]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TestEventListener Class in C#\nDESCRIPTION: Basic event listener implementation extending DefaultLogger for testing purposes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestEventListener : Akka.Event.DefaultLogger\n{\n    public TestEventListener() { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: LeaseTimeoutException Class Definition in C#\nDESCRIPTION: Defines a specialized exception for timeout scenarios in lease operations. Extends the base LeaseException class with specific timeout semantics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class LeaseTimeoutException : Akka.Coordination.LeaseException\n{\n    public LeaseTimeoutException(string message) { }\n    public LeaseTimeoutException(string message, System.Exception innerEx) { }\n    protected LeaseTimeoutException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: ExpectNoMsg Usage with Within in C#\nDESCRIPTION: Illustrates the use of ExpectNoMsg within a Within block, showing how it affects the timing of the test execution.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/testing-actor-systems.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar worker = ActorOf<Worker>();\nWithin(200.Milliseconds(), () =>\n{\n    worker.Tell(\"some work\");\n    ExpectMsg(\"Some Result\");\n    ExpectNoMsg(); //will block for the rest of the 200ms\n    Thead.Sleep(300); //will NOT make this block fail\n});\n```\n\n----------------------------------------\n\nTITLE: Disabling Default Downing Provider in Akka.NET HOCON\nDESCRIPTION: Configuration to disable the default Akka.Cluster downing provider. This setting turns off the split brain resolver functionality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/split-brain-resolver.md#2025-04-16_snippet_1\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster.downing-provider-class = \"\"\n```\n\n----------------------------------------\n\nTITLE: Testing Device Registration in C#\nDESCRIPTION: This test verifies the device registration functionality. It includes two tests: one for successful registration when IDs match, and one for rejecting registration when IDs don't match.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-3.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[Fact]\npublic void Device_actor_must_reply_to_registration_requests()\n{\n    var probe = CreateTestProbe();\n    var deviceActor = Sys.ActorOf(Device.Props(\"group\", \"device\"));\n\n    deviceActor.Tell(new RequestTrackDevice(\"group\", \"device\"), probe.Ref);\n    probe.ExpectMsg<DeviceRegistered>();\n    probe.LastSender.Should().Be(deviceActor);\n}\n\n[Fact]\npublic void Device_actor_must_ignore_wrong_registration_requests()\n{\n    var probe = CreateTestProbe();\n    var deviceActor = Sys.ActorOf(Device.Props(\"group\", \"device\"));\n\n    deviceActor.Tell(new RequestTrackDevice(\"wrongGroup\", \"device\"), probe.Ref);\n    probe.ExpectNoMsg(TimeSpan.FromMilliseconds(500));\n\n    deviceActor.Tell(new RequestTrackDevice(\"group\", \"wrongDevice\"), probe.Ref);\n    probe.ExpectNoMsg(TimeSpan.FromMilliseconds(500));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Vector Static Class\nDESCRIPTION: Utility class providing functional-style collection operations. The Fill method creates a list of specified size with elements generated by a factory function.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_222\n\nLANGUAGE: C#\nCODE:\n```\npublic class static Vector\n{\n    public static System.Func<System.Func<T>, System.Collections.Generic.IList<T>> Fill<T>(int number) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Option<T> Equality Operator in C#\nDESCRIPTION: Overload of the equality operator for comparing two Option<T> instances.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_223\n\nLANGUAGE: C#\nCODE:\n```\npublic static bool ==(Akka.Util.Option<T> left, Akka.Util.Option<T> right) { }\n```\n\n----------------------------------------\n\nTITLE: Defining IScheduledTellMsg Interface in C#\nDESCRIPTION: Internal interface for scheduled message delivery in Akka.NET, marked with InternalApiAttribute and extending message-related interfaces.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_64\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic interface IScheduledTellMsg : Akka.Actor.INoSerializationVerificationNeeded, Akka.Actor.IWrappedMessage { }\n```\n\n----------------------------------------\n\nTITLE: InMemoryReadJournal Class Implementation in C#\nDESCRIPTION: Implementation of various Akka.Persistence.Query interfaces for in-memory event sourcing. Provides methods for querying events, persistence IDs, and event streams with support for offset-based pagination.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceInMemoryQuery.Core.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class InMemoryReadJournal : Akka.Persistence.Query.IAllEventsQuery, Akka.Persistence.Query.ICurrentAllEventsQuery, Akka.Persistence.Query.ICurrentEventsByPersistenceIdQuery, Akka.Persistence.Query.ICurrentEventsByTagQuery, Akka.Persistence.Query.ICurrentPersistenceIdsQuery, Akka.Persistence.Query.IEventsByPersistenceIdQuery, Akka.Persistence.Query.IEventsByTagQuery, Akka.Persistence.Query.IPersistenceIdsQuery, Akka.Persistence.Query.IReadJournal\n{\n    public const string Identifier = \"akka.persistence.query.journal.inmem\";\n    public InMemoryReadJournal(Akka.Configuration.Config config) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> AllEvents(Akka.Persistence.Query.Offset offset = null) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentAllEvents(Akka.Persistence.Query.Offset offset) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentEventsByPersistenceId(string persistenceId, long fromSequenceNr, long toSequenceNr) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentEventsByTag(string tag, Akka.Persistence.Query.Offset offset) { }\n    public Akka.Streams.Dsl.Source<string, Akka.NotUsed> CurrentPersistenceIds() { }\n    public static Akka.Configuration.Config DefaultConfiguration() { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> EventsByPersistenceId(string persistenceId, long fromSequenceNr, long toSequenceNr) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> EventsByTag(string tag, Akka.Persistence.Query.Offset offset) { }\n    public Akka.Streams.Dsl.Source<string, Akka.NotUsed> PersistenceIds() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Adaptive Load Balancing Metrics Listener in Akka.Cluster\nDESCRIPTION: This snippet defines an AdaptiveLoadBalancingMetricsListener class extending Akka.Actor.ActorBase. This actor is used to listen for metrics and influence load balancing decisions. Key methods include initialization, shutdown procedures, and message handling within Akka.Cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.DotNet.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic class AdaptiveLoadBalancingMetricsListener : Akka.Actor.ActorBase\n{\n    public AdaptiveLoadBalancingMetricsListener(Akka.Cluster.Metrics.IClusterMetricsRoutingLogic routingLogic) { }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: SmallestMailbox Router Configuration\nDESCRIPTION: Configuration examples for SmallestMailbox router implementation using HOCON and code.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_25\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.deployment {\n  /some-pool {\n    router = smallest-mailbox-pool\n    nr-of-instances = 5\n  }\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvar router = system.ActorOf(Props.Create<Worker>().WithRouter(new SmallestMailboxPool(5)), \"some-pool\");\n```\n\n----------------------------------------\n\nTITLE: Defining LoadSnapshotFailed Message Class in Akka.NET Persistence\nDESCRIPTION: This code defines the `LoadSnapshotFailed` class, which represents a message indicating the failure to load a snapshot in Akka.NET persistence.  It includes a property to store the `Exception` that caused the failure.  The `LoadSnapshotFailed` class implements interfaces related to persistence messages, snapshot messages, and snapshot responses.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class LoadSnapshotFailed : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage, Akka.Persistence.ISnapshotResponse\n{\n    public LoadSnapshotFailed(System.Exception cause) { }\n    public System.Exception Cause { get; }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Stream Materialization Using RunWith in C#\nDESCRIPTION: Demonstrates a more concise way to materialize streams using RunWith(), which combines the connection and materialization steps into a single operation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/basics.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar source = Source.From(Enumerable.Range(1, 10));\nvar sink = Sink.Aggregate<int, int>(0, (agg, i) => agg + i);\n  \n// materialize the flow, getting the Sinks materialized value\nTask<int> sum = source.RunWith(sink, materializer);\n```\n\n----------------------------------------\n\nTITLE: Creating SimpleEchoActor for Akka.NET Testing\nDESCRIPTION: A basic actor that echoes messages back to their sender. This test actor provides a simple implementation for echo behavior in Akka.NET tests.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_53\n\nLANGUAGE: C#\nCODE:\n```\npublic class SimpleEchoActor : Akka.Actor.ReceiveActor\n{\n    public SimpleEchoActor() { }\n    public static Akka.Actor.Props Props() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Scala Class Constructors to C#\nDESCRIPTION: Shows how to convert Scala class constructors with different access modifiers to C# equivalents.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/porting-guide.md#2025-04-16_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass Person(name: String, var surname: string, val age: Int, private val position: String)\n{\n}\n```\n\nLANGUAGE: c#\nCODE:\n```\npublic class Person\n{\n    private readonly string _name;\n    private readonly string _position;\n    \n    public Person(string name, string surname, int age, string position)\n    {\n        _name = name;\n        Surname = surname;\n        Age = age;\n        _position = position;\n    }\n    \n    public string Surname { get; set; }\n    public int Age { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Common Properties Import\nDESCRIPTION: XML configuration to import common properties in project files for standardization\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/build-process.md#2025-04-16_snippet_5\n\nLANGUAGE: xml\nCODE:\n```\n<Import Project=\"..\\common.props\" />\n```\n\n----------------------------------------\n\nTITLE: Implementing EventReplaySuccess Class in C#\nDESCRIPTION: A sealed class representing a successful event replay operation. Contains the highest sequence number processed and implements equality members for comparison.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class EventReplaySuccess\n{\n    public EventReplaySuccess(long highestSequenceNr) { }\n    public long HighestSequenceNr { get; }\n    public bool Equals(Akka.Persistence.Sql.Common.Journal.EventReplaySuccess other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PersistencePluginProxy Class in C#\nDESCRIPTION: Defines a PersistencePluginProxy class that inherits from ActorBase and implements multiple interfaces. It includes methods for setting target location, starting the system, and handling messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_60\n\nLANGUAGE: C#\nCODE:\n```\npublic class PersistencePluginProxy : Akka.Actor.ActorBase, Akka.Actor.IActorStash, Akka.Actor.IWithUnboundedStash, Akka.Actor.IWithUnrestrictedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics>\n{\n    public PersistencePluginProxy(Akka.Configuration.Config config) { }\n    public Akka.Actor.IStash Stash { get; set; }\n    protected override void PreStart() { }\n    protected override bool Receive(object message) { }\n    public static void SetTargetLocation(Akka.Actor.ActorSystem system, Akka.Actor.Address address) { }\n    public static void Start(Akka.Actor.ActorSystem system) { }\n    public sealed class TargetLocation\n    {\n        public TargetLocation(Akka.Actor.Address address) { }\n        public Akka.Actor.Address Address { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Side Effects for Persistent FSM in C#\nDESCRIPTION: Side effects implementation for a WebStoreCustomerFSMActor. These are actions that occur as a result of state transitions but aren't part of the core state logic.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistent-fsm.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Declaring IMessageExtractor Interface in C#\nDESCRIPTION: This interface defines the contract for message extractors used in Akka.NET cluster sharding. It is implemented by classes that extract entity and shard IDs from messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IMessageExtractor\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Default HOCON Configuration for Akka.Remote Package\nDESCRIPTION: The default configuration settings for Akka.Remote in HOCON format. These settings define transport protocols, remote deployment, watch failure detection parameters, and other remote communication settings for Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/modules/akka.remote.md#2025-04-16_snippet_0\n\nLANGUAGE: HOCON\nCODE:\n```\nakka.remote {\n    dot-netty.tcp {\n        transport-class = \"Akka.Remote.Transport.DotNetty.TcpTransport, Akka.Remote\"\n        applied-adapters = []\n        transport-protocol = tcp\n        port = 2552\n        hostname = localhost\n        public-hostname = \"POPULATE\"\n        bind-port = 0\n        bind-hostname = \"\"\n        ssl {\n            suppress-validation = false\n            certificate {\n                # valid certificate options: auto | manual\n                # auto - automatically creates a self-signed certificate\n                # manual - requires user to specify certificate parameters\n                mode = \"auto\"\n                # WARNING!: AUTO-GENERATED CERTIFICATES FOR SSL WILL ONLY WORK ON LOCALHOST\n                # Hostname must be specified when using auto-signed certificates otherwise generated certificate \n                # will only operate on \"localhost\".\n                password = \"\"\n                # path-to-certificate-store (PKCS12 format) - manual only\n                path = \"\"\n                # X.509 subject names - manual only\n                subject {\n                    common-name = \"\"\n                    # optional values\n                    organization = \"\"\n                    organization-unit = \"\"\n                }\n                # algorithm with which this certificate was generated\n                signature-algorithm = \"SHA256withRSA\"\n                # minimum RSA key length\n                key-size = 4096\n                # time range of validity\n                validity {\n                    from = \"2019-01-01 00:00:00.000\"\n                    # duration in days\n                    duration = 365\n                }\n            }\n            # Valid values: \"TLS\" (default), \"TLSv1\", \"TLSv1.1\", \"TLSv1.2\"\n            protocol = \"TLS\"\n        }\n\n        # Sets the send buffer size of the Sockets,\n        # set to 0b for platform default\n        send-buffer-size = 256000b\n\n        # Sets the receive buffer size of the Sockets,\n        # set to 0b for platform default\n        receive-buffer-size = 256000b\n\n        # Maximum message size the transport will accept, but at least 32000b.\n        # Please note that UDP does not support arbitrary large datagrams,\n        # so this setting has to be chosen carefully when using UDP.\n        # Both send-buffer-size and receive-buffer-size settings has to\n        # be adjusted to be able to buffer messages of maximum size.\n        maximum-frame-size = 128000b\n\n        # Sets the size of the connection backlog\n        backlog = 100\n\n        # The TcpTransport reconnection interval\n        reconnect-timeout = 30s\n\n        # Enables the TCP_NODELAY flag, i.e. disables Nagle's algorithm\n        tcp-nodelay = on\n\n        # Enables TCP Keepalive, subject to the O/S kernel's configuration\n        tcp-keepalive = on\n\n        # Enables SO_REUSEADDR, which determines when an ActorSystem can open\n        # the specified listen port (the meaning differs between *nix and Windows).\n        # Valid values are \"off\", \"on\", and \"on-close\" corresponding to the values\n        # in Microsoft's SO_REUSEADDR documentation.\n        # Further explanation of values on Windows:\n        # off - consecutive ActorSystems can only use an address if the previous \n        #    user is gone\n        # on - consecutive ActorSystems can use an address even if the previous\n        #    user is still around, but only if the protocol (TCP) is different\n        # on-close - consecutive ActorSystems can use an address even if the \n        #    previous user is still around, using the same protocol (TCP)\n        # on-close is the default value on Windows. For Unix-like systems, this\n        # setting is ignored and the SO_REUSEADDR is unconditionally enabled.\n        reuse-addr = off        \n    }\n\n    dot-netty.udp {\n        transport-class = \"Akka.Remote.Transport.DotNetty.UdpTransport, Akka.Remote\"\n        applied-adapters = []\n        transport-protocol = udp\n        port = 2552\n        hostname = localhost\n        public-hostname = \"POPULATE\"\n        # Sets the send buffer size of the Sockets,\n        # set to 0b for platform default\n        send-buffer-size = 256000b\n\n        # Sets the receive buffer size of the Sockets,\n        # set to 0b for platform default\n        receive-buffer-size = 256000b\n\n        # Maximum message size the transport will accept, but at least 32000b.\n        # Please note that UDP does not support arbitrary large datagrams,\n        # so this setting has to be chosen carefully when using UDP.\n        # Both send-buffer-size and receive-buffer-size settings has to\n        # be adjusted to be able to buffer messages of maximum size.\n        maximum-frame-size = 128000b\n\n        # Sets the size of the connection backlog\n        backlog = 4\n    }\n\n    # DEPRECATED\n    helios.tcp {\n        transport-class = \"Akka.Remote.Transport.Helios.HeliosTcpTransport, Akka.Remote\"\n        applied-adapters = []\n        transport-protocol = tcp\n        port = 2552\n        hostname = localhost\n        public-hostname = \"POPULATE\"\n\n        # Sets the send buffer size of the Sockets,\n        # set to 0b for platform default\n        send-buffer-size = 256000b\n\n        # Sets the receive buffer size of the Sockets,\n        # set to 0b for platform default\n        receive-buffer-size = 256000b\n\n        # Maximum message size the transport will accept, but at least 32000b.\n        # Please note that UDP does not support arbitrary large datagrams,\n        # so this setting has to be chosen carefully when using UDP.\n        # Both send-buffer-size and receive-buffer-size settings has to\n        # be adjusted to be able to buffer messages of maximum size.\n        maximum-frame-size = 128000b\n\n        # Sets the size of the connection backlog\n        backlog = 4\n\n        # Enables TCP Keepalive, subject to the O/S kernel's configuration\n        tcp-keepalive = on\n\n        # Enables the TCP_NODELAY flag, i.e. disables Nagle's algorithm\n        tcp-nodelay = on\n    }\n\n    retry-gate-closed-for = 5s\n\n    # time after which a joining member that has not been accepted will shutdown\n    joining-timeout = 5s \n\n    # If this is \"on\", Akka will log all inbound messages at DEBUG level,\n    # if off then they are not logged\n    log-received-messages = off\n\n    # If this is \"on\", Akka will log all outbound messages at DEBUG level,\n    # if off then they are not logged\n    log-sent-messages = off\n\n    # If this is \"on\", Akka will log all UNSERIALIZABLE messages at INFO level\n    log-remote-lifecycle-events = on\n\n    # Each transport adapters can have several adapters attached to it\n    # An adapter provides specific serialization and deserialization capabilities\n    # which can be utilized for Remote Actor Communications.\n    # Some of them are used by Akka internally while others are to be provided by the user.\n    ### Built in: \n    # akka.remote.serialization-bindings {\n    # \"System.Object\" = akka-actors\n    # }\n    serializers {\n        akka-containers = \"Akka.Remote.Serialization.MessageContainerSerializer, Akka.Remote\"\n    }\n    serialization-bindings {\n        \"Akka.Remote.Serialization.WrappedMessage, Akka.Remote\" = akka-containers\n        \"Akka.Remote.Serialization.MessageContainerByteString, Akka.Remote\" = akka-containers\n        \"Akka.Remote.Serialization.MessageContainerJava, Akka.Remote\" = akka-containers\n        \"Akka.Remote.DaemonMsgCreate, Akka.Remote\" = akka-containers\n    }\n    \n    # The hostname or ip to bind the remoting to,\n    # InetAddress.getLocalHost.getHostAddress is used if empty\n    hostname = localhost\n\n    # For resiliency and network error recovery, set to on\n    use-dispatcher-for-io = on\n\n    # Name of the remote dispatcher to be used by the transport\n    use-dispatcher = akka.remote.default-remote-dispatcher\n\n    # Default remote dispatcher for all used transports\n    # Default local dispatcher to use for Remote operations: default-dispatcher\n    default-remote-dispatcher {\n        type = Dispatcher\n        executor = \"fork-join-executor\"\n        fork-join-executor {\n            # Min number of threads to cap factor-based parallelism number to\n            parallelism-min = 2\n            # The parallelism factor is used to determine thread pool size using the\n            # following formula: ceil(available processors * factor). Resulting size\n            # is then bounded by the parallelism-min and parallelism-max values.\n            parallelism-factor = 0.5\n            # Max number of threads to cap factor-based parallelism number to\n            parallelism-max = 24\n        }\n        throughput = 100\n    }\n\n    ### Security - transport security key generation\n    secure-cookie {\n        # Generate a new key on each node start\n        # Overrides the key-secret value\n        generate-new-key = off\n        # Should a created key be placed in the agent directory\n        # WARNING: Key is placed in plain text\n        save-to-disk = off\n        # An intermediate seed key for the key generator algorithm\n        # WARNING: Do not change unless you know what you're doing.\n        key-secret = \"a-random-seed-value0123-ABCDEF\"\n        # The algorithm to use for the key generator\n        algorithm = \"AES\"\n    }\n\n    ### Security - remote TLS\n    security {\n        # This is the exact same config that can be specified once per port under dot-netty.tcp.\n        # The settings here act as defaults to those, if left unspecified.\n        ssl {\n            suppress-validation = false\n            certificate {\n                # valid certificate options: auto | manual\n                # auto - automatically creates a self-signed certificate\n                # manual - requires user to specify certificate parameters\n                mode = \"auto\"\n                # WARNING!: AUTO-GENERATED CERTIFICATES FOR SSL WILL ONLY WORK ON LOCALHOST\n                # Hostname must be specified when using auto-signed certificates otherwise generated certificate \n                # will only operate on \"localhost\".\n                password = \"\"\n                # path-to-certificate-store (PKCS12 format) - manual only\n                path = \"\"\n                # X.509 subject names - manual only\n                subject {\n                    common-name = \"\"\n                    # optional values\n                    organization = \"\"\n                    organization-unit = \"\"\n                }\n                # algorithm with which this certificate was generated\n                signature-algorithm = \"SHA256withRSA\"\n                # minimum RSA key length\n                key-size = 4096\n                # time range of validity\n                validity {\n                    from = \"2019-01-01 00:00:00.000\"\n                    # duration in days\n                    duration = 365\n                }\n            }\n            # Valid values: \"TLS\" (default), \"TLSv1\", \"TLSv1.1\", \"TLSv1.2\"\n            protocol = \"TLS\"\n        }\n    }\n\n    ### Configuration of the Phi accrual failure detector algorithm.\n    ### Refer to Akka.Remote.PhiAccrualFailureDetector for more information.\n    watch-failure-detector {\n        # FQCN of the failure detector implementation.\n        # It must implement akka.remote.FailureDetector and have\n        # a public constructor with a com.typesafe.config.Config and\n        # akka.actor.EventStream parameter.\n        implementation-class = \"Akka.Remote.PhiAccrualFailureDetector, Akka.Remote\"\n\n        # How often keep-alive heartbeat messages should be sent to each connection.\n        heartbeat-interval = 1s\n\n        # Threshold used for the phi failure detector. Should be set lower for faster failure detection\n        # but to a higher value to be able to survive network congestion / GC pause\n        threshold = 10.0\n\n        # Number of potentially lost/delayed heartbeats that will be accepted before considering it to be an anomaly.\n        # This margin is important to be able to survive sudden, occasional, pauses in heartbeat arrivals,\n        # due to for example garbage collection or network drop outs.\n        max-sample-size = 200\n\n        # Minimum number of samples that the failure detector requires to asses the health of a connection\n        min-std-deviation = 100ms\n\n        # Number of samples of inter-heartbeat arrival times to adaptively calculate the failure timeout for connections.\n        acceptable-heartbeat-pause = 10s\n\n        # Automatically correct clocks that would otherwise force the failure detector to mark connections as failed, even\n        # in the presence of regular heartbeats.\n        # DANGEROUS: In production you should be very careful about enabling this since it can mask real crashed.\n        expected-response-after = 2s\n    }\n\n    ### Configuration of the automatic transport-layer failure injector.\n    # The injector will impose failure conditions on the remoting subsystem, which is useful to\n    # test the resilience of your system in the presence of network failures.\n    # It does support the injection of any of the following fault kinds:\n    # 1) Disabling packet transfer between a pair of endpoints completely;\n    # 2) Inducing message losses;\n    # 3) Adding random delays (latency) to messages within specified parameters.\n    transport-failure-detector {\n        # FQCN of the failure detector implementation.\n        # It must implement akka.remote.FailureDetector and have\n        # a public constructor with a com.typesafe.config.Config and\n        # akka.actor.EventStream parameter.\n        implementation-class = \"Akka.Remote.DeadlineFailureDetector, Akka.Remote\"\n\n        # How often keep-alive heartbeat messages should be sent to each connection.\n        heartbeat-interval = 4s\n\n        # Number of potentially lost/delayed heartbeats that will be accepted before considering it to be an anomaly.\n        # A margin of 10 messages corresponds to roughly 40 seconds with a heartbeat interval of 4 seconds.\n        acceptable-heartbeat-pause = 40s\n\n        # Maximum time under which an acknowledged packet must be received for the \n        # DeadlineFailureDetector.\n        expected-response-after = 8s\n    }\n\n    command-ack-timeout=30s\n\n    backoff-remote-dispatcher-failure = 0s\n\n    prune-quarantine-marker-after = 5d\n\n    system-message-ack-piggyback-timeout = 3s\n\n    system-message-buffer-size = 1000\n\n    systemmessage-resend-interval = 100ms\n\n    initial-system-message-delivery-timeout = 3m\n\n    resend-interval = 2s\n\n    enabled-transports = [\"akka.remote.dot-netty.tcp\"]\n\n    maximum-retries-in-window = 20\n\n    retry-window = 5s\n\n    prune-quarantine-marker-after = 5d\n\n    gate-invalid-addresses-for = 5s\n}\n\nakka.actor.deployment {\n    default {\n        # if this is set to a valid remote address, the actor will be deployed\n        # on that node (requires cluster)\n        remote = \"POPULATE\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ILoggerMessageQueueSemantics Interface in C#\nDESCRIPTION: A marker interface that extends ISemantics to specify message queue semantics for loggers in the actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_129\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ILoggerMessageQueueSemantics : Akka.Dispatch.ISemantics { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterShardingExtensionProvider for Akka.NET\nDESCRIPTION: A sealed class that provides the extension mechanism for registering the ClusterSharding module with the Akka.NET actor system. It implements ExtensionIdProvider to create and initialize the ClusterSharding extension.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n    [System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n            0,\n            1})]\n    public sealed class ClusterShardingExtensionProvider : Akka.Actor.ExtensionIdProvider<Akka.Cluster.Sharding.ClusterSharding>\n    {\n        public ClusterShardingExtensionProvider() { }\n        public override Akka.Cluster.Sharding.ClusterSharding CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing NewtonSoftJsonSerializer in C#\nDESCRIPTION: Defines the NewtonSoftJsonSerializer class for JSON serialization in Akka.NET using Newtonsoft.Json. It includes constructors with various configuration options and methods for serialization and deserialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_224\n\nLANGUAGE: C#\nCODE:\n```\npublic class NewtonSoftJsonSerializer : Akka.Serialization.Serializer\n{\n    public NewtonSoftJsonSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public NewtonSoftJsonSerializer(Akka.Actor.ExtendedActorSystem system, Akka.Configuration.Config config) { }\n    public NewtonSoftJsonSerializer(Akka.Actor.ExtendedActorSystem system, Akka.Serialization.NewtonSoftJsonSerializerSettings settings) { }\n    public override bool IncludeManifest { get; }\n    public object Serializer { get; }\n    public Newtonsoft.Json.JsonSerializerSettings Settings { get; }\n    public override object FromBinary(byte[] bytes, System.Type type) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ClusterMetricsSettings in Akka.NET\nDESCRIPTION: Defines a configuration class for Akka.NET cluster metrics. This class provides settings for controlling metrics collection intervals, dispatcher configuration, and supervisor strategy.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterMetricsSettings\n{\n    public ClusterMetricsSettings(Akka.Configuration.Config config) { }\n    public bool CollectorEnabled { get; }\n    public bool CollectorFallback { get; }\n    public System.TimeSpan CollectorGossipInterval { get; }\n    public System.TimeSpan CollectorMovingAverageHalfLife { get; }\n    public string CollectorProvider { get; }\n    public System.TimeSpan CollectorSampleInterval { get; }\n    public string MetricsDispatcher { get; }\n    public System.TimeSpan PeriodicTasksInitialDelay { get; }\n    public string SupervisorName { get; }\n    public Akka.Configuration.Config SupervisorStrategyConfiguration { get; }\n    public string SupervisorStrategyProvider { get; }\n    public static Akka.Cluster.Metrics.Configuration.ClusterMetricsSettings Create(Akka.Configuration.Config config) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IdentifyResult Enumeration\nDESCRIPTION: Enumeration for singleton identification results with success and timeout states.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\npublic enum IdentifyResult\n{\n    Success = 0,\n    Timeout = 1,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PreRestartException for Actor Lifecycle Management\nDESCRIPTION: Exception class used when an actor fails during its pre-restart phase. Tracks the restart exception, original cause, and the optional message that was being processed when the failure occurred.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\npublic class PreRestartException : Akka.Actor.ActorInitializationException\n{\n    public PreRestartException(Akka.Actor.IActorRef actor, System.Exception restartException, System.Exception cause, object optionalMessage) { }\n    protected PreRestartException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n    public object OptionalMessage { get; }\n    public System.Exception RestartException { get; }\n    public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Akka.NET Stream with RunForeach Shorthand\nDESCRIPTION: Demonstrates the shorthand version of running a stream with a ForEach sink, which is a common operation in Akka.NET Streams.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/reactivetweets.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nformattedRetweets.RunForeach(Console.WriteLine, mat);\n```\n\n----------------------------------------\n\nTITLE: DeadLetter Class in Akka.NET\nDESCRIPTION: Sealed class that extends AllDeadLetters to represent a message that couldn't be delivered. Contains the undelivered message, original sender, and intended recipient.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_117\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class DeadLetter : Akka.Event.AllDeadLetters\n{\n    public DeadLetter(object message, Akka.Actor.IActorRef sender, Akka.Actor.IActorRef recipient) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ModifyFailure Class for Akka.NET Distributed Data in C#\nDESCRIPTION: Defines the ModifyFailure class representing a failure in modifying distributed data. It includes properties for the key, error message, cause, and request, as well as methods for throwing on failure and string representation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\npublic ModifyFailure(Akka.DistributedData.IKey key, string errorMessage, System.Exception cause, object request) { }\npublic System.Exception Cause { get; }\npublic string ErrorMessage { get; }\npublic bool IsSuccessful { get; }\npublic Akka.DistributedData.IKey Key { get; }\npublic object Request { get; }\npublic void ThrowOnFailure() { }\npublic override string ToString() { }\n```\n\n----------------------------------------\n\nTITLE: Using Synchronized Dispatcher in Windows Forms\nDESCRIPTION: Example of creating an actor with a synchronized dispatcher in a Windows Forms application.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/dispatchers.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nprivate void Form1_Load(object sender, System.EventArgs e)\n{\n  system.ActorOf(Props.Create<UIWorker>().WithDispatcher(\"synchronized-dispatcher\"), \"ui-worker\");\n}\n```\n\n----------------------------------------\n\nTITLE: NoSnapshotStoreException Class in C#\nDESCRIPTION: Custom exception class for handling snapshot store-related errors with multiple constructors supporting different exception creation scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_56\n\nLANGUAGE: C#\nCODE:\n```\npublic class NoSnapshotStoreException : System.Exception {\n    public NoSnapshotStoreException() { }\n    public NoSnapshotStoreException(string message) { }\n    public NoSnapshotStoreException(string message, System.Exception innerException) { }\n    protected NoSnapshotStoreException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ModifyFailure Class for Distributed Data Operations - C#\nDESCRIPTION: Definition of ModifyFailure class that represents a failed modification operation in Akka's distributed data system. This class provides access to error information, the original request, and can throw the underlying exception when needed.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\npublic ModifyFailure(Akka.DistributedData.IKey key, string errorMessage, System.Exception cause, object request) { }\npublic System.Exception Cause { get; }\npublic string ErrorMessage { get; }\npublic bool IsSuccessful { get; }\npublic Akka.DistributedData.IKey Key { get; }\npublic object Request { get; }\npublic void ThrowOnFailure() { }\npublic override string ToString() { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Transport Adapter Base Class\nDESCRIPTION: Abstract base class for transport adapters in Akka.NET that provides core functionality for intercepting and managing remote actor associations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AbstractTransportAdapterHandle : Akka.Remote.Transport.AssociationHandle\n{\n    protected AbstractTransportAdapterHandle(Akka.Remote.Transport.AssociationHandle wrappedHandle, string addedSchemeIdentifier) { }\n    protected AbstractTransportAdapterHandle(Akka.Actor.Address originalLocalAddress, Akka.Actor.Address originalRemoteAddress, Akka.Remote.Transport.AssociationHandle wrappedHandle, string addedSchemeIdentifier) { }\n    public Akka.Actor.Address OriginalLocalAddress { get; }\n    public Akka.Actor.Address OriginalRemoteAddress { get; }\n    protected Akka.Remote.Transport.SchemeAugmenter SchemeAugmenter { get; }\n    public Akka.Remote.Transport.AssociationHandle WrappedHandle { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ISnapshotter Interface for Snapshot Management in Akka.NET\nDESCRIPTION: This code defines the `ISnapshotter` interface, which outlines the contract for snapshot management in Akka.NET persistence. It specifies methods for deleting snapshots, loading snapshots based on criteria, and saving snapshots, as well as properties to access snapshot sequence number and snapshotter ID. This interface serves as a core component for interacting with snapshot stores within Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface ISnapshotter\n{\n    long SnapshotSequenceNr { get; }\n    string SnapshotterId { get; }\n    void DeleteSnapshot(long sequenceNr);\n    void DeleteSnapshots(Akka.Persistence.SnapshotSelectionCriteria criteria);\n    void LoadSnapshot(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria, long toSequenceNr);\n    void SaveSnapshot(object snapshot);\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Docker Container with PowerShell\nDESCRIPTION: Command to execute the start.cmd script which builds and launches the Docker container using docker-compose.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/examples/Cluster/ClusterSharding/ShoppingCart/README.md#2025-04-16_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\nPS> ./start.cmd\n```\n\n----------------------------------------\n\nTITLE: Defining SQL Query for Inserting Events in Akka.Persistence\nDESCRIPTION: SQL insert statement used to store persistent events in a SQLite journal. This statement includes all necessary fields for event storage including persistence ID, sequence number, and serialized payload.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/custom-persistence-provider.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic const string InsertEventSql = @\"\n    insert into journal\n    (\n        persistence_id,\n        sequence_nr,\n        is_deleted,\n        manifest,\n        payload,\n        created_at\n    )\n    values\n    (\n        @PersistenceId,\n        @SequenceNr,\n        @IsDeleted,\n        @Manifest,\n        @Payload,\n        @Timestamp\n    );\"\n```\n\n----------------------------------------\n\nTITLE: System Guardian Actor Implementation in C#\nDESCRIPTION: Implementation of the system guardian actor that manages system-level supervision. Includes message handling and restart behavior.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_53\n\nLANGUAGE: C#\nCODE:\n```\npublic class SystemGuardianActor : Akka.Actor.ActorBase, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedMessageQueueSemantics>\n{\n    public SystemGuardianActor(Akka.Actor.IActorRef userGuardian) { }\n    protected override void PreRestart(System.Exception reason, object message) { }\n    protected override bool Receive(object message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DeleteSnapshotFailure class in C#\nDESCRIPTION: This sealed class represents a failure in deleting a snapshot. It implements several interfaces and contains properties for the cause of the failure and the metadata of the snapshot.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DeleteSnapshotFailure : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage, Akka.Persistence.ISnapshotResponse, System.IEquatable<Akka.Persistence.DeleteSnapshotFailure>\n{\n    public DeleteSnapshotFailure(Akka.Persistence.SnapshotMetadata metadata, System.Exception cause) { }\n    public System.Exception Cause { get; }\n    public Akka.Persistence.SnapshotMetadata Metadata { get; }\n    public bool Equals(Akka.Persistence.DeleteSnapshotFailure other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IRequireCausualDeliveryOfDeltas Interface in C#\nDESCRIPTION: This snippet defines the `IRequireCausualDeliveryOfDeltas` interface, which combines `IReplicatedData` and `IReplicatedDelta`. This likely indicates that implementations of this interface require causal delivery of delta updates, ensuring that changes are applied in the correct order to maintain consistency.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\n    public interface IRequireCausualDeliveryOfDeltas : Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDelta { }\n\n```\n\n----------------------------------------\n\nTITLE: Defining AsyncWriteTarget Static Class in C#\nDESCRIPTION: Static class declaration for AsyncWriteTarget in the Akka.Persistence.Journal namespace. Contains static methods or properties for interacting with asynchronous write targets.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\npublic class static AsyncWriteTarget\n{\n\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Hyperion to Allow Unsafe Types\nDESCRIPTION: This HOCON setting allows the deserialization of unsafe types by turning off the default safety feature. Use this with caution as it opens up potential security vulnerabilities.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/serialization/serialization.md#2025-04-16_snippet_8\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.serialization-settings.hyperion.disallow-unsafe-type = false\n```\n\n----------------------------------------\n\nTITLE: Journal Entry Data Structure\nDESCRIPTION: Represents a single journal entry with metadata such as persistence ID, sequence number, deletion status, manifest, timestamp, and payload\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Core.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class JournalEntry {\n    public readonly string PersistenceId;\n    public readonly long SequenceNr;\n    public readonly bool IsDeleted;\n    public readonly string Manifest;\n    public readonly DateTime Timestamp;\n    public readonly object Payload;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UdpConnected Event Base Class in Akka.NET\nDESCRIPTION: Abstract base class for UDP connection events. Events are messages sent by the UDP system to notify about state changes or incoming data.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_179\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Event : Akka.IO.UdpConnected.Message\n{\n    protected Event() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring BackoffSupervisor with Manual Reset and Default Stopping Strategy\nDESCRIPTION: Demonstrates BackoffSupervisor configuration with manual reset requirement and default stopping strategy. Child must explicitly send Reset message to parent for backoff reset.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/concepts/supervision.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar supervisor = BackoffSupervisor.Props(\n    Backoff.OnStop(\n        childProps,\n        childName: \"myEcho\",\n        minBackoff: TimeSpan.FromSeconds(3),\n        maxBackoff: TimeSpan.FromSeconds(30),\n        randomFactor: 0.2)\n        .WithManualReset() // the child must send BackoffSupervisor.Reset to its parent\n        .WithDefaultStoppingStrategy()); // Stop at any Exception thrown\n```\n\n----------------------------------------\n\nTITLE: Defining EventEnvelope Class in C#\nDESCRIPTION: Defines the EventEnvelope class, which encapsulates event data including offset, persistence ID, sequence number, event object, timestamp, and tags. It includes multiple constructors and implements IEquatable<EventEnvelope>.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceQuery.Net.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class EventEnvelope : System.IEquatable<Akka.Persistence.Query.EventEnvelope>\n{\n    [System.ObsoleteAttribute(\"For binary compatibility with previous releases. Since 1.4.14\")]\n    public EventEnvelope(Akka.Persistence.Query.Offset offset, string persistenceId, long sequenceNr, object @event) { }\n    [System.ObsoleteAttribute(\"For binary compatibility with previous releases. Since 1.5.11\")]\n    public EventEnvelope(Akka.Persistence.Query.Offset offset, string persistenceId, long sequenceNr, object @event, long timestamp) { }\n    public EventEnvelope(Akka.Persistence.Query.Offset offset, string persistenceId, long sequenceNr, object @event, long timestamp, string[] tags) { }\n    public object Event { get; }\n    public Akka.Persistence.Query.Offset Offset { get; }\n    public string PersistenceId { get; }\n    public long SequenceNr { get; }\n    public string[] Tags { get; }\n    public long Timestamp { get; }\n    public bool Equals(Akka.Persistence.Query.EventEnvelope other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing InvalidAssociationException Class in Akka.NET Remote Transport\nDESCRIPTION: An exception class for invalid associations in Akka.NET's remote transport system, extending the base AkkaException class.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\npublic class InvalidAssociationException : Akka.Actor.AkkaException\n{\n    public InvalidAssociationException(string message, System.Exception cause = null) { }\n    protected InvalidAssociationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Good C# XML Documentation Example\nDESCRIPTION: This C# code snippet shows an example of well-written XML documentation comments. The comments are clear, concise, and provide useful information about the code, including parameter descriptions and return values.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/documentation-guidelines.md#2025-04-16_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n/// <summary>\n/// A Serializer represents a bimap between an object and an array of bytes representing that object.\n/// </summary>\npublic abstract class Serializer\n{\n    /// <summary>\n    /// Deserializes a byte array into an object of type <paramref name=\"type\"/>\n    /// </summary>\n    /// <param name=\"bytes\">The array containing the serialized object</param>\n    /// <param name=\"type\">The type of object contained in the array</param>\n    /// <returns>The object contained in the array</returns>\n    public abstract object FromBinary(byte[] bytes, Type type);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Socket Options for Akka.NET IO in C#\nDESCRIPTION: The Inet class contains nested classes for various socket options used in Akka.NET IO operations. These options include receive buffer size, address reuse, and send buffer size.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_159\n\nLANGUAGE: C#\nCODE:\n```\npublic class Inet\n{\n    public Inet() { }\n    public abstract class AbstractSocketOption : Akka.IO.Inet.SocketOption\n    {\n        protected AbstractSocketOption() { }\n    }\n    // ... (other nested classes)\n    public class static SO\n    {\n        public class ReceiveBufferSize : Akka.IO.Inet.SocketOption\n        {\n            public ReceiveBufferSize(int size) { }\n            public override void BeforeConnect(System.Net.Sockets.Socket s) { }\n            public override void BeforeDatagramBind(System.Net.Sockets.Socket ds) { }\n            public override void BeforeServerSocketBind(System.Net.Sockets.Socket ss) { }\n        }\n        // ... (other socket options)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Async Recovery Interface Definition in C#\nDESCRIPTION: Interface defining asynchronous recovery operations for reading highest sequence numbers and replaying messages from the journal.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_58\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IAsyncRecovery\n{\n    System.Threading.Tasks.Task<long> ReadHighestSequenceNrAsync(string persistenceId, long fromSequenceNr);\n    System.Threading.Tasks.Task ReplayMessagesAsync(Akka.Actor.IActorContext context, string persistenceId, long fromSequenceNr, long toSequenceNr, long max, System.Action<Akka.Persistence.IPersistentRepresentation> recoveryCallback);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EnumerableExtensions Class in C#\nDESCRIPTION: A static class providing an extension method for grouping enumerable items into fixed-size chunks.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class static EnumerableExtensions\n{\n    public static System.Collections.Generic.IEnumerable<System.Collections.Generic.IEnumerable<T>> Grouped<T>(this System.Collections.Generic.IEnumerable<T> items, int size) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RuntimeDetector Static Class\nDESCRIPTION: Static class providing runtime environment detection properties. It contains read-only flags to determine if the code is running on Mono and if the operating system is Windows.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_212\n\nLANGUAGE: C#\nCODE:\n```\npublic class static RuntimeDetector\n{\n    public static readonly bool IsMono;\n    public static readonly bool IsWindows;\n}\n```\n\n----------------------------------------\n\nTITLE: IClusterActorRefProvider Interface Definition\nDESCRIPTION: This snippet defines an interface `IClusterActorRefProvider` that inherits from `Akka.Actor.IActorRefProvider` and `Akka.Remote.IRemoteActorRefProvider`.  It's marked as an internal API and likely provides cluster-specific extensions to the actor reference provider.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic interface IClusterActorRefProvider : Akka.Actor.IActorRefProvider, Akka.Remote.IRemoteActorRefProvider { }\n```\n\n----------------------------------------\n\nTITLE: LeaseUsageSettings Class Definition in C#\nDESCRIPTION: Configures how leases are used, including the lease implementation class name and retry interval for lease acquisition attempts. Provides immutable access to these settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.DotNet.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class LeaseUsageSettings\n{\n    public LeaseUsageSettings(string leaseImplementation, System.TimeSpan leaseRetryInterval) { }\n    public string LeaseImplementation { get; }\n    public System.TimeSpan LeaseRetryInterval { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: IClusterMessage Interface Definition\nDESCRIPTION: This snippet defines an interface `IClusterMessage`.  It likely serves as a marker interface for messages that are intended to be used within the Akka.Cluster system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IClusterMessage { }\n```\n\n----------------------------------------\n\nTITLE: ClusterClientUnreachable Class Declaration\nDESCRIPTION: The ClusterClientUnreachable class represents a notification message that indicates when a cluster client becomes unreachable. It implements the IClusterClientInteraction interface to integrate with cluster client messaging systems.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterClientUnreachable : Akka.Cluster.Tools.Client.IClusterClientInteraction\n{\n\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Assembly Metadata for Akka.NET Remote Module\nDESCRIPTION: Sets up assembly metadata including repository URL, internal visibility, and target framework for the Akka.NET Remote module.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Benchmarks\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster\")]\n// ... (additional InternalsVisibleTo attributes)\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"78986bdb-73f7-4532-8e03-1c9ccbe8148e\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Implementing Cluster Metrics Event Classes in C#\nDESCRIPTION: These classes define the events related to cluster metrics. ClusterMetricsChanged is a sealed class that implements the IClusterMetricsEvent interface and represents a change in cluster node metrics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Net.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterMetricsChanged : Akka.Cluster.Metrics.Events.IClusterMetricsEvent\n{\n    public ClusterMetricsChanged(System.Collections.Immutable.IImmutableSet<Akka.Cluster.Metrics.Serialization.NodeMetrics> nodeMetrics) { }\n    public System.Collections.Immutable.IImmutableSet<Akka.Cluster.Metrics.Serialization.NodeMetrics> NodeMetrics { get; }\n}\npublic interface IClusterMetricsEvent { }\n```\n\n----------------------------------------\n\nTITLE: Configuration for Replay Filter in HOCON\nDESCRIPTION: This HOCON configuration example outlines how to set up a replay filter for the SQLite journal plugin in Akka Persistence. It specifies the behavior of the filter when detecting corrupt events during replay, allowing users to choose among different modes like 'repair-by-discard-old' and 'fail'.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/event-sourcing.md#2025-04-16_snippet_15\n\nLANGUAGE: hocon\nCODE:\n```\n# The replay filter can detect a corrupt event stream by inspecting\n# sequence numbers and writerUuid when replaying events.\nakka.persistence.journal.sqlite.replay-filter {\n  # What the filter should do when detecting invalid events.\n  # Supported values:\n  # `repair-by-discard-old` : discard events from old writers,\n  #                           warning is logged\n  # `fail` : fail the replay, error is logged\n  # `warn` : log warning but emit events untouched\n  # `off` : disable this feature completely\n  mode = repair-by-discard-old\n}\n```\n\n----------------------------------------\n\nTITLE: Kubernetes YAML Configuration for Receptionist Pods\nDESCRIPTION: Shows the required YAML configuration for Kubernetes pods hosting ClusterClient receptionist actors. The key part is adding a discovery label that matches the PodLabelSelector in the ClusterClientDiscovery configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-client.md#2025-04-16_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\nspec:\n  template:\n    metadata:\n      labels:\n        # Note that \"discovery\" matches the `PodLabelSelector` in `.WithClusterClientDiscovery()`\n        # Note that \"initial-contact\" matches the `ServiceName` in `.WithClusterClientDiscovery()`\n        discovery: initial-contact \n```\n\n----------------------------------------\n\nTITLE: Implementing ThrottlerProvider in Akka.NET Remote\nDESCRIPTION: Implementation of the ITransportAdapterProvider interface for creating ThrottleTransportAdapter instances. Creates a throttling adapter that wraps an existing transport implementation to provide rate limiting functionality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\npublic class ThrottlerProvider : Akka.Remote.Transport.ITransportAdapterProvider\n{\n    public ThrottlerProvider() { }\n    public Akka.Remote.Transport.Transport Create(Akka.Remote.Transport.Transport wrappedTransport, Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IReplicatedDelta Interface for Delta CRDT in C#\nDESCRIPTION: Defines the IReplicatedDelta interface that extends IReplicatedData with a Zero property, which is used for implementing delta-based CRDTs (Conflict-free Replicated Data Types).\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IReplicatedDelta : Akka.DistributedData.IReplicatedData\n{\n    Akka.DistributedData.IDeltaReplicatedData Zero { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining xUnit Assertions for Akka.NET\nDESCRIPTION: Establishes `XunitAssertions`, implementing the `ITestKitAssertions` interface to provide specialized assertions like equality evaluation, and boolean checks specifically for Akka.NET testing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKitXunit2.DotNet.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.TestKit.Xunit2\n{\n    public class XunitAssertions : Akka.TestKit.ITestKitAssertions\n    {\n        public XunitAssertions() { }\n        public void AssertEqual<T>(T expected, T actual, string format = \"\", params object[] args) { }\n        public void AssertEqual<T>(T expected, T actual, System.Func<T, T, bool> comparer, string format = \"\", params object[] args) { }\n        public void AssertFalse(bool condition, string format = \"\", params object[] args) { }\n        public void AssertTrue(bool condition, string format = \"\", params object[] args) { }\n        public void Fail(string format = \"\", params object[] args) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Actor Creation Pattern in C# Akka.NET\nDESCRIPTION: This code demonstrates the correct pattern for creating child actors. The FirstActor uses Context.ActorOf<T>() which properly creates the new actor as a child of FirstActor rather than under the \"/user\" guardian.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK1008.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing Akka.Actor;\n\npublic sealed class FirstActor : ReceiveActor\n{\n    public FirstActor()\n    {\n        Context.ActorOf<MyActor>(\"newActor\");\n    }\n}\n\npublic sealed class MyActor : ReceiveActor\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IChildStats Interface in C#\nDESCRIPTION: Marker interface for classes that provide statistics for child actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_53\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IChildStats { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract Query Executor for Akka.NET SQL Persistence\nDESCRIPTION: Defines an abstract base class for SQL query executors, providing common functionality and abstract methods for database operations in Akka.NET Persistence.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class AbstractQueryExecutor : Akka.Persistence.Sql.Common.Journal.IJournalQueryExecutor\n{\n    protected const int IsDeletedIndex = 3;\n    protected static readonly string LongTypeName;\n    protected const int ManifestIndex = 4;\n    protected const int OrderingIndex = 7;\n    protected const int PayloadIndex = 5;\n    protected const int PersistenceIdIndex = 0;\n    protected const int SequenceNrIndex = 1;\n    protected Akka.Serialization.Serialization Serialization;\n    protected const int SerializerIdIndex = 6;\n    protected const int TimestampIndex = 2;\n    protected Akka.Persistence.Sql.Common.Journal.ITimestampProvider TimestampProvider;\n    protected AbstractQueryExecutor(Akka.Persistence.Sql.Common.Journal.QueryConfiguration configuration, Akka.Serialization.Serialization serialization, Akka.Persistence.Sql.Common.Journal.ITimestampProvider timestampProvider) { }\n    // ... (additional properties and methods)\n}\n```\n\n----------------------------------------\n\nTITLE: Problematic Pattern: Using Persist() Inside a Loop in Akka.NET\nDESCRIPTION: This code demonstrates the problematic pattern where Persist() is called multiple times inside a loop. This can create multiple asynchronous database connections and impact performance negatively.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK1006.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Persistence;\n\npublic class MyActor: ReceivePersistentActor\n{\n    public override string PersistenceId { get; }\n    public MyActor(string persistenceId)\n    {\n        PersistenceId = persistenceId;\n        CommandAny(obj =>\n        {\n            for (var i=0; i<10; i++)\n            {\n                Persist(i, o => {});\n            }\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UDP Commands and Events in C#\nDESCRIPTION: This snippet defines several sealed classes for UDP commands and events in Akka.NET. These classes are used for operations like suspending reading, unbinding, and handling connection states.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_161\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SuspendReading : Akka.IO.Udp.Command\n{\n    public static readonly Akka.IO.Udp.SuspendReading Instance;\n}\npublic sealed class Unbind : Akka.IO.Udp.Command\n{\n    public static readonly Akka.IO.Udp.Unbind Instance;\n}\npublic sealed class Unbound\n{\n    public static readonly Akka.IO.Udp.Unbound Instance;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Left<T> Class in C#\nDESCRIPTION: A class representing the left side of an Either type. Contains a value of type T and provides properties to check if it's a Left (true) or Right (false) instance.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_242\n\nLANGUAGE: C#\nCODE:\n```\npublic class Left<T>\n{\n    public Left(T value) { }\n    public bool IsLeft { get; }\n    public bool IsRight { get; }\n    public T Value { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Akka.NET Stream with Sink.ForEach\nDESCRIPTION: Shows how to materialize and run a stream by attaching it to a Sink. In this case, it prints each formatted retweet to the console.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/reactivetweets.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nformattedRetweets.RunWith(Sink.ForEach<string>(Console.WriteLine), mat);\n```\n\n----------------------------------------\n\nTITLE: Correct Implementation Using Receive<T>() for Synchronous Operations in C#\nDESCRIPTION: This example demonstrates the correct approach to handle synchronous operations in a ReceiveActor by using Receive<T>() instead of ReceiveAsync<T>(). This resolves the AK1003 warning and improves performance by avoiding unnecessary actor task creation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK1003.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Actor;\nusing System.Threading.Tasks;\nusing System;\n\npublic sealed class MyActor : ReceiveActor\n{\n    public MyActor()\n    {\n        // Notice we have replaced `ReceiveAsync` with `Receive`\n        // and removed the async keyword\n        Receive<string>(str => {\n            Sender.Tell(str);\n        }):\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ByteHelpers Static Class in C#\nDESCRIPTION: A utility class with extension methods for byte array operations. Includes PutInt method to insert an integer value into a byte array with byte order specification.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_233\n\nLANGUAGE: C#\nCODE:\n```\npublic class static ByteHelpers\n{\n    public static byte[] PutInt(this byte[] target, int x, int offset = 0, Akka.IO.ByteOrder order = 0) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending PoisonPill to Router Routees in C#\nDESCRIPTION: This code snippet illustrates how to send a PoisonPill message wrapped in a Broadcast message to stop all routees of a router in Akka.NET using C#.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_29\n\nLANGUAGE: csharp\nCODE:\n```\nactorSystem.ActorOf(Props.Create<Worker>(), \"worker1\");\nactorSystem.ActorOf(Props.Create<Worker>(), \"worker2\");\nactorSystem.ActorOf(Props.Create<Worker>(), \"worker3\");\n\nvar workers = new[] { \"/user/worker1\", \"/user/worker2\", \"/user/worker3\" };\nvar router = actorSystem.ActorOf(Props.Empty.WithRouter(new RoundRobinGroup(workers)), \"workers\");\n\nrouter.Tell(\"Hello, worker1\");\nrouter.Tell(\"Hello, worker2\");\nrouter.Tell(\"Hello, worker3\");\n\n// this sends PoisonPill message to all routees\nrouter.Tell(new Broadcast(PoisonPill.Instance));\n```\n\n----------------------------------------\n\nTITLE: ThrottleTransportAdapter Class Definition (C#)\nDESCRIPTION: Transport adapter that implements throttling functionality for network communication. Extends ActorTransportAdapter and defines constants and properties for throttle management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\npublic class ThrottleTransportAdapter : Akka.Remote.Transport.ActorTransportAdapter\n{\n    public const string Scheme = \"trttl\";\n    public static readonly Akka.Util.Internal.AtomicCounter UniqueId;\n    public ThrottleTransportAdapter(Akka.Remote.Transport.Transport wrappedTransport, Akka.Actor.ActorSystem system) { }\n    protected override string ManagerName { get; }\n    protected override Akka.Actor.Props ManagerProps { get; }\n    protected override Akka.Remote.Transport.SchemeAugmenter SchemeAugmenter { get; }\n    public override System.Threading.Tasks.Task<bool> ManagementCommand(object message) { }\n    public enum Direction\n    {\n        Send = 0,\n        Receive = 1,\n        Both = 2,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Assembly Metadata for Akka.NET\nDESCRIPTION: These assembly attributes define the repository URL, internal visibility for testing and specific modules, COM visibility, a GUID, and the target framework for the Akka.NET assembly. This metadata is used for identification, testing, and compatibility purposes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Core.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n\"[assembly: System.Reflection.AssemblyMetadataAttribute(\\\"RepositoryUrl\\\", \\\"https://github.com/akkadotnet/akka.net\\\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\\\"Akka.Benchmarks\\\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\\\"Akka.Cluster.Metrics\\\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\\\"Akka.Cluster.Sharding\\\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\\\"Akka.Cluster.Sharding.Tests\\\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\\\"Akka.Cluster.Sharding.Tests.MultiNode\\\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\\\"Akka.Cluster.TestKit\\\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\\\"Akka.Cluster.Tests\\\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\\\"Akka.Cluster.Tests.MultiNode\\\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\\\"Akka.Cluster.Tests.Performance\\\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\\\"Akka.Cluster.Tools\\\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\\\"Akka.Cluster.Tools.Tests\\\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\\\"Akka.Cluster.Tools.Tests.MultiNode\\\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\\\"Akka.DistributedData\\\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\\\"Akka.Management.Cluster.Http\\\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\\\"0e3e691b-0c31-4718-9b1a-d749b93208c9\\\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\\\".NETStandard,Version=v2.0\\\", FrameworkDisplayName=\\\".NET Standard 2.0\\\")]\"\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Akka.NET v1.4.25 Remote Performance\nDESCRIPTION: Performance benchmark results for Akka.NET v1.4.25 using the RemotePingPong benchmark. Shows improved message throughput and processing time compared to v1.4.24.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/RELEASE_NOTES.md#2025-04-16_snippet_14\n\nLANGUAGE: text\nCODE:\n```\nOSVersion:                         Microsoft Windows NT 6.2.9200.0\nProcessorCount:                    16\nClockSpeed:                        0 MHZ\nActor Count:                       32\nMessages sent/received per client: 200000  (2e5)\nIs Server GC:                      True\nThread count:                      111\n\nNum clients, Total [msg], Msgs/sec, Total [ms]\n         1,  200000,    130634,    1531.54\n         5, 1000000,    246975,    4049.20\n        10, 2000000,    244499,    8180.16\n        15, 3000000,    244978,   12246.39\n        20, 4000000,    245159,   16316.37\n        25, 5000000,    243333,   20548.09\n        30, 6000000,    241644,   24830.55\n```\n\n----------------------------------------\n\nTITLE: Implementing SerializerIdentifierHelper in Akka.NET\nDESCRIPTION: Defines a static helper class for retrieving serializer identifiers from configuration. Used internally by the serialization system to resolve serializer IDs.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_202\n\nLANGUAGE: csharp\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic class static SerializerIdentifierHelper\n{\n    public static int GetSerializerIdentifierFromConfig(System.Type type, Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Event Adapters in HOCON\nDESCRIPTION: HOCON configuration syntax for binding event adapters to specific event types in Akka.NET persistence journal. Shows how to define multiple adapters and bind them to event types, including support for multiple adapter bindings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/event-adapters.md#2025-04-16_snippet_1\n\nLANGUAGE: hocon\nCODE:\n```\nakka.persistence.journal {\n    <journal_identifier> {\n        event-adapters {\n            tagging = \"<fully qualified event adapter type name with assembly>\"\n            v1 = \"<fully qualified event adapter type name with assembly>\"\n            v2 = \"<fully qualified event adapter type name with assembly>\"\n        }\n\n        event-adapter-bindings {\n            \"<fully qualified event type name with assembly>\" = v1\n            \"<fully qualified event type name with assembly>\" = [v2, tagging]\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Cluster Sharding Message Serialization in C#\nDESCRIPTION: Implements serialization for cluster sharding messages in Akka.NET. Handles binary serialization and deserialization of sharding-related messages with string manifests.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterShardingMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public ClusterShardingMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object o) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: SingleVersionVector Implementation in C#\nDESCRIPTION: Implementation of version vector tracking for single node with methods for incrementing, merging and pruning version information.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_48\n\nLANGUAGE: C#\nCODE:\n```\n[System.Diagnostics.DebuggerDisplayAttribute(\"VersionVector({Node}->{Version})\")]\npublic sealed class SingleVersionVector : Akka.DistributedData.VersionVector\n{\n    public SingleVersionVector(Akka.Cluster.UniqueAddress node, long version) { }\n    public override int Count { get; }\n    public override bool IsEmpty { get; }\n    public override System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.UniqueAddress> ModifiedByNodes { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Materializing View Using SelectAsync - C#\nDESCRIPTION: This snippet shows how to materialize a view using the SelectAsync method if the target database does not provide a reactive streams subscriber. It defines an ExampleStore class to represent the datastore and performs the write operation in a stateless manner. The snippet requires Akka Streams to process messages asynchronously.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistence-query.md#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ExampleStore\n{\n    public Task<object> Save(object evt)\n    {\n        return Task.FromResult(evt);\n    }\n}\n\nvar store = new ExampleStore();\n\nreadJournal\n    .EventsByTag(\"bid\", 0L)\n    .SelectAsync(1, e => store.Save(e))\n    .RunWith(Sink.Ignore<object>(), mat);\n```\n\n----------------------------------------\n\nTITLE: Journal Interceptor Interface Definition\nDESCRIPTION: Interface definition for implementing custom journal interceptors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistence-testing.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IJournalInterceptor\n{\n    Task InterceptAsync(IPersistentRepresentation message);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing InboundAssociation Class in Akka.NET Remote Transport\nDESCRIPTION: A class representing an inbound association event in Akka.NET's remote transport system, containing the association handle reference.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class InboundAssociation : Akka.Actor.INoSerializationVerificationNeeded, Akka.Remote.Transport.IAssociationEvent\n{\n    public InboundAssociation(Akka.Remote.Transport.AssociationHandle association) { }\n    public Akka.Remote.Transport.AssociationHandle Association { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SQL Journal Base Class in C#\nDESCRIPTION: Abstract base class for SQL-based journal implementation in Akka.NET with async write capabilities and message queue semantics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class SqlJournal : Akka.Persistence.Journal.AsyncWriteJournal, Akka.Actor.IActorStash, Akka.Actor.IWithUnboundedStash, Akka.Actor.IWithUnrestrictedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics> {\n    protected readonly Akka.Persistence.Sql.Common.JournalSettings Settings;\n    protected SqlJournal(Akka.Configuration.Config journalConfig) { }\n    protected abstract string JournalConfigPath { get; }\n    protected Akka.Event.ILoggingAdapter Log { get; }\n    public abstract Akka.Persistence.Sql.Common.Journal.IJournalQueryExecutor QueryExecutor { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PersistentFSMSnapshot Class in C#\nDESCRIPTION: Class used to create snapshots of FSM state for persistence. Contains the state identifier, data, and timeout information that can be persisted and recovered.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\npublic class PersistentFSMSnapshot<TD> : Akka.Persistence.Serialization.IMessage\n{\n    public PersistentFSMSnapshot(string stateIdentifier, TD data, System.Nullable<System.TimeSpan> timeout) { }\n    public TD Data { get; }\n    public string StateIdentifier { get; }\n    public System.Nullable<System.TimeSpan> Timeout { get; }\n    protected bool Equals(Akka.Persistence.Fsm.PersistentFSM.PersistentFSMSnapshot<TD> other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ShardRegion Class in C#\nDESCRIPTION: A sealed class representing a shard region actor, including initialization parameters and message handling logic.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ShardRegion : Akka.Actor.ActorBase, Akka.Actor.IWithTimers\n{\n    public ShardRegion(string typeName, System.Func<string, Akka.Actor.Props> entityProps, Akka.Cluster.Sharding.ClusterShardingSettings settings, string coordinatorPath, Akka.Cluster.Sharding.ExtractEntityId extractEntityId, Akka.Cluster.Sharding.ExtractShardId extractShardId, object handOffStopMessage, Akka.Cluster.Sharding.Internal.IRememberEntitiesProvider rememberEntitiesProvider) { }\n    public Akka.Actor.ITimerScheduler Timers { get; set; }\n    protected override void PostStop() { }\n    protected override void PreStart() { }\n    protected override bool Receive(object message) { }\n    public sealed class StartEntity : Akka.Cluster.Sharding.IClusterShardingSerializable, System.IEquatable<Akka.Cluster.Sharding.ShardRegion.StartEntity>\n    {\n        public readonly string EntityId;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WriteMessageRejected Class in Akka.NET\nDESCRIPTION: The WriteMessageRejected class represents a rejected write to the journal. It contains the persistent message, the cause of the rejection, and the actor instance ID.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class WriteMessageRejected : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IJournalMessage, Akka.Persistence.IJournalResponse, Akka.Persistence.IPersistenceMessage, System.IEquatable<Akka.Persistence.WriteMessageRejected>\n{\n    public WriteMessageRejected(Akka.Persistence.IPersistentRepresentation persistent, System.Exception cause, int actorInstanceId) { }\n    public int ActorInstanceId { get; }\n    public System.Exception Cause { get; }\n    public Akka.Persistence.IPersistentRepresentation Persistent { get; }\n    public bool Equals(Akka.Persistence.WriteMessageRejected other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Using System-Level Materializer in Akka.NET Actor\nDESCRIPTION: This alternative solution uses the ActorSystem's materializer, which is cached internally and managed by the system. This approach avoids having to manually dispose of the materializer while still preventing the creation of multiple instances.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK2002.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Actor;\nusing Akka.Streams;\nusing Akka.Streams.Dsl;\n\npublic sealed class MyActor : ReceiveActor\n{\n    public MyActor()\n    {\n        ReceiveAsync<string>(\n            s => s == \"hello\",\n            async _ =>\n            {\n                await Source.Single(1)\n                    .Select(x => x + 1)\n                    .ToMaterialized(Sink.ForEach<int>(_ => { }), Keep.Right)\n                    .Run(Context.System.Materializer()); // Use ActorSystem.Materializer(), this is cached internally\n            });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Read Journal Interfaces for Akka.NET Persistence\nDESCRIPTION: Collection of interfaces defining various read journal query capabilities including event retrieval by persistence ID, tag, and all events queries.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceQuery.DotNet.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IReadJournal { }\n\npublic interface IAllEventsQuery : Akka.Persistence.Query.IReadJournal\n{\n    Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> AllEvents(Akka.Persistence.Query.Offset offset);\n}\n\npublic interface ICurrentAllEventsQuery : Akka.Persistence.Query.IReadJournal\n{\n    Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentAllEvents(Akka.Persistence.Query.Offset offset);\n}\n\npublic interface ICurrentEventsByPersistenceIdQuery : Akka.Persistence.Query.IReadJournal\n{\n    Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentEventsByPersistenceId(string persistenceId, long fromSequenceNr, long toSequenceNr);\n}\n```\n\n----------------------------------------\n\nTITLE: Extractor Usage in C# 7\nDESCRIPTION: This C# 7 code demonstrates the usage of the `TryExtractName` extension method in a switch statement with pattern matching and 'when' clauses to achieve a similar effect as Scala extractors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/porting-guide.md#2025-04-16_snippet_16\n\nLANGUAGE: c#\nCODE:\n```\nstring message = string.Empty;\nswitch (user)\n{\n    case FreeUser p when p.TryExtractName(out var name):\n        message = $\"Hello {name}\";\n        break;\n    case PremiumUser p when p.TryExtractName(out var name):\n        message = $\"Welcome back, dear {name}\"\n        break;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ModifyFailure Class in C#\nDESCRIPTION: This snippet defines a sealed class `ModifyFailure` that implements `IUpdateFailure` and `IUpdateResponse`. It represents a failure during a modify operation on distributed data. It stores information about the key, error message, cause, and the original request that triggered the failure.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\n    public sealed class ModifyFailure : Akka.Actor.INoSerializationVerificationNeeded, Akka.DistributedData.IUpdateFailure, Akka.DistributedData.IUpdateResponse\n    {\n        public ModifyFailure(Akka.DistributedData.IKey key, string errorMessage, System.Exception cause, object request) { }\n        public System.Exception Cause { get; }\n\n```\n\n----------------------------------------\n\nTITLE: Defining Id Property in C#\nDESCRIPTION: This snippet defines an interface `IKey` with a single property `Id` of type string. This `Id` likely represents a unique identifier for a distributed data key, enabling retrieval and manipulation of the associated data.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n        string Id { get; }\n\n```\n\n----------------------------------------\n\nTITLE: HOCON Configuration for Cross-Platform Name Overrides\nDESCRIPTION: This HOCON configuration specifies name transformations for types that may differ across .NET Framework and .NET Core. It demonstrates how to set up package name overrides to ensure compatibility.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/serialization/serialization.md#2025-04-16_snippet_9\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.serialization-settings.hyperion.cross-platform-package-name-overrides = {\n  netfx = [\n    {\n      fingerprint = \"System.Private.CoreLib,%core%\",\n      rename-from = \"System.Private.CoreLib,%core%\",\n      rename-to = \"mscorlib,%core%\"\n   }]\n  netcore = [\n    {\n      fingerprint = \"mscorlib,%core%\",\n      rename-from = \"mscorlib,%core%\",\n      rename-to = \"System.Private.CoreLib,%core%\"\n    }]\n  net = [\n    {\n      fingerprint = \"mscorlib,%core%\",\n      rename-from = \"mscorlib,%core%\",\n      rename-to = \"System.Private.CoreLib,%core%\"\n    }]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LogMessage Abstract Class in C#\nDESCRIPTION: An abstract base class for log messages that contains a formatter and format string. It serves as a base for different types of formatted log messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_141\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class LogMessage\n{\n    protected readonly Akka.Event.ILogMessageFormatter Formatter;\n    public LogMessage(Akka.Event.ILogMessageFormatter formatter, string format) { }\n    public string Format { get; }\n\n```\n\n----------------------------------------\n\nTITLE: Implementing LocalSnapshotStore Class in C#\nDESCRIPTION: Defines a LocalSnapshotStore class that inherits from SnapshotStore. It provides methods for saving, loading, and deleting snapshots using the local file system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_62\n\nLANGUAGE: C#\nCODE:\n```\npublic class LocalSnapshotStore : Akka.Persistence.Snapshot.SnapshotStore\n{\n    public LocalSnapshotStore() { }\n    protected override System.Threading.Tasks.Task DeleteAsync(Akka.Persistence.SnapshotMetadata metadata) { }\n    protected override System.Threading.Tasks.Task DeleteAsync(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria) { }\n    protected System.IO.FileInfo GetSnapshotFileForWrite(Akka.Persistence.SnapshotMetadata metadata, string extension = \"\") { }\n    protected override System.Threading.Tasks.Task<Akka.Persistence.SelectedSnapshot> LoadAsync(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria) { }\n    protected override void PreStart() { }\n    protected override bool ReceivePluginInternal(object message) { }\n    protected virtual void Save(Akka.Persistence.SnapshotMetadata metadata, object snapshot) { }\n    protected override System.Threading.Tasks.Task SaveAsync(Akka.Persistence.SnapshotMetadata metadata, object snapshot) { }\n    protected void Serialize(System.IO.Stream stream, Akka.Persistence.Serialization.Snapshot snapshot) { }\n    protected System.IO.FileInfo WithOutputStream(Akka.Persistence.SnapshotMetadata metadata, System.Action<System.IO.Stream> p) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Changed Class Definition in Akka.DistributedData\nDESCRIPTION: Definition of the Changed class that represents notification messages when data has been modified in the distributed data store. It implements IReplicatorMessage interface and provides methods to access the modified data.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Changed : Akka.DistributedData.IReplicatorMessage, System.IEquatable<Akka.DistributedData.Changed>\n{\n    public Changed(Akka.DistributedData.IKey key, object data) { }\n    public object Data { get; }\n    public Akka.DistributedData.IKey Key { get; }\n    public bool Equals(Akka.DistributedData.Changed other) { }\n    public override bool Equals(object obj) { }\n    public T Get<T>(Akka.DistributedData.IKey<T> key)\n        where T : Akka.DistributedData.IReplicatedData { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Recovery Output Example\nDESCRIPTION: Shows the console output from the Recover example, displaying numbers 0-4 and the recovery message.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/error-handling.md#2025-04-16_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n0\n1\n2\n3\n4\nstream truncated\n```\n\n----------------------------------------\n\nTITLE: Implementing SetThrottleAck Class in Akka.NET Remote Transport\nDESCRIPTION: A singleton acknowledgment class for the SetThrottle command in Akka.NET's throttling transport adapter.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SetThrottleAck\n{\n    public static Akka.Remote.Transport.SetThrottleAck Instance { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Config Service Discovery Class\nDESCRIPTION: This code defines the `ConfigServiceDiscovery` class, an implementation of `Akka.Discovery.ServiceDiscovery` that uses configuration to resolve service addresses. It takes an `ExtendedActorSystem` in its constructor and overrides the `Lookup` method. Also defines static `ConfigServicesParser` class for parsing config.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.Core.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace Akka.Discovery.Config\n{\n    [Akka.Annotations.InternalApiAttribute()]\n    public class ConfigServiceDiscovery : Akka.Discovery.ServiceDiscovery\n    {\n        public ConfigServiceDiscovery(Akka.Actor.ExtendedActorSystem system) { }\n        public override System.Threading.Tasks.Task<Akka.Discovery.ServiceDiscovery.Resolved> Lookup(Akka.Discovery.Lookup lookup, System.TimeSpan resolveTimeout) { }\n    }\n    [Akka.Annotations.InternalApiAttribute()]\n    public class static ConfigServicesParser\n    {\n        public static System.Collections.Generic.Dictionary<string, Akka.Discovery.ServiceDiscovery.Resolved> Parse(Akka.Configuration.Config config) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: GetRoutees Class Implementation in Akka.NET Routing\nDESCRIPTION: Defines a sealed class for retrieving routees from a router. It implements RouterManagementMessage and provides a static Instance property for convenient access.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_173\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class GetRoutees : Akka.Routing.RouterManagementMessage\n{\n    public GetRoutees() { }\n    public static Akka.Routing.GetRoutees Instance { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ILogMessageFormatter Interface in C#\nDESCRIPTION: An interface for log message formatters that defines methods to format log messages with variable arguments or collections of arguments.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_128\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ILogMessageFormatter\n{\n    string Format(string format, params object[] args);\n    string Format(string format, System.Collections.Generic.IEnumerable<object> args);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Unthrottled Mode in Akka.NET\nDESCRIPTION: Concrete implementation of ThrottleMode that represents an unthrottled state in Akka.NET remote transport. It allows unlimited token consumption without any rate limiting.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic class Unthrottled : Akka.Remote.Transport.ThrottleMode\n{\n    public static Akka.Remote.Transport.Unthrottled Instance { get; }\n    public override System.TimeSpan TimeToAvailable(long currentNanoTime, int tokens) { }\n    public override System.ValueTuple<Akka.Remote.Transport.ThrottleMode, bool> TryConsumeTokens(long nanoTimeOfSend, int tokens) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DummyClassForStringSources in C#\nDESCRIPTION: A utility class used as a placeholder for string log sources when a Type reference is required for logging.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_121\n\nLANGUAGE: C#\nCODE:\n```\npublic class DummyClassForStringSources\n{\n    public DummyClassForStringSources() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SQL Query for Retrieving Persistent Events by ID in Akka.Persistence\nDESCRIPTION: SQL query statement used to retrieve events from a SQLite journal by persistence ID within a specified sequence number range. The query orders results by sequence number to ensure proper event ordering during replay.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/custom-persistence-provider.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic const string ByPersistenceIdSql = @\"\n    select\n        j.persistence_id as PersistenceId,\n        j.sequence_nr as SequenceNr,\n        j.is_deleted as IsDeleted,\n        j.manifest as Manifest,\n        j.payload as Payload,\n        j.created_at as Timestamp\n    from journal j\n    where j.persistence_id = @PersistenceId\n      and j.sequence_nr >= @FromSequenceNr\n      and j.sequence_nr <= @ToSequenceNr\n    order by j.sequence_nr\n    limit @MaxCount;\"\n```\n\n----------------------------------------\n\nTITLE: Actor Exception Handling Classes\nDESCRIPTION: Implements specialized exception classes for different actor-related error scenarios, extending AkkaException to provide context-specific error handling\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ActorInitializationException : Akka.Actor.AkkaException { }\n```\n\n----------------------------------------\n\nTITLE: Referencing Reactive Streams Interfaces in C#\nDESCRIPTION: Shows the primary interfaces from Reactive Streams that are used for integration with Akka Streams.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nReactive.Streams.IPublisher\nReactive.Streams.ISubscriber\n```\n\n----------------------------------------\n\nTITLE: UnreachableMember Class Definition\nDESCRIPTION: This snippet defines a sealed class `UnreachableMember` that inherits from `Akka.Cluster.ClusterEvent.ReachabilityEvent`. It represents the event when a cluster member becomes unreachable. It takes a `Akka.Cluster.Member` object in the constructor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class UnreachableMember : Akka.Cluster.ClusterEvent.ReachabilityEvent\n{\n    public UnreachableMember(Akka.Cluster.Member member) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Advanced DotNetty Batching Configuration in HOCON\nDESCRIPTION: Complete HOCON configuration for DotNetty TCP batching, including all available parameters like max-pending-bytes and flush-interval.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/remoting/performance.md#2025-04-16_snippet_2\n\nLANGUAGE: hocon\nCODE:\n```\nakka.remote.dot-netty.tcp{\n      batching{\n\n        enabled = true\n\n        max-pending-writes = 30\n\n        max-pending-bytes = 16k\n\n        flush-interval = 40ms\n      }\n}\n```\n\n----------------------------------------\n\nTITLE: Snapshot Management Classes in C#\nDESCRIPTION: Classes for managing snapshots including metadata, save operations, and selection criteria.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SnapshotMetadata : System.IEquatable<Akka.Persistence.SnapshotMetadata>\n{\n    [System.ObsoleteAttribute(\"This constructor is deprecated and will be removed in v1.6. Use the constructor with the timestamp parameter instead. Since v1.5.28\", true)]\n    public SnapshotMetadata(string persistenceId, long sequenceNr) { }\n    [Newtonsoft.Json.JsonConstructorAttribute()]\n    public SnapshotMetadata(string persistenceId, long sequenceNr, System.DateTime timestamp) { }\n    public static System.Collections.Generic.IComparer<Akka.Persistence.SnapshotMetadata> Comparer { get; }\n    public string PersistenceId { get; }\n    public long SequenceNr { get; }\n    public System.DateTime Timestamp { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterRouterGroupSettings Class in C#\nDESCRIPTION: Defines settings for ClusterRouterGroup, including total instances, routee paths, and local routee allowance. This class is used to configure the behavior of a ClusterRouterGroup.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Core.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterRouterGroupSettings : Akka.Cluster.Routing.ClusterRouterSettingsBase\n{\n    public ClusterRouterGroupSettings(int totalInstances, System.Collections.Generic.IEnumerable<string> routeesPaths, bool allowLocalRoutees, string useRole = null) { }\n    public System.Collections.Generic.IEnumerable<string> RouteesPaths { get; }\n    public static Akka.Cluster.Routing.ClusterRouterGroupSettings FromConfig(Akka.Configuration.Config config) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Viewing Akka.NET Log Format with Multiple Severity Levels\nDESCRIPTION: Sample output showing the standard Akka.NET logging format across different severity levels. Each log entry includes the log level, timestamp, thread ID, and actor system name, followed by the actual message content.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/DefaultLogFormatSpec.ShouldUseDefaultLogFormat.Net.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n[DEBUG][DateTime][Thread 0001][ActorSystem(test)] This is a test 1 cheese\n[INFO][DateTime][Thread 0001][ActorSystem(test)] This is a test 1\n[WARNING][DateTime][Thread 0001][ActorSystem(test)] This is a test 1\n[ERROR][DateTime][Thread 0001][ActorSystem(test)] This is a test 1\n```\n\n----------------------------------------\n\nTITLE: Implementing ScatterGatherFirstCompletedPool in Akka.NET\nDESCRIPTION: Router configuration for ScatterGatherFirstCompleted strategy that creates and manages a pool of actor instances. Broadcasts messages to all actors in the pool and returns the first response received within the timeout.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_214\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ScatterGatherFirstCompletedPool : Akka.Routing.Pool\n{\n    public ScatterGatherFirstCompletedPool(Akka.Configuration.Config config) { }\n    public ScatterGatherFirstCompletedPool(int nrOfInstances) { }\n    public ScatterGatherFirstCompletedPool(int nrOfInstances, System.TimeSpan within) { }\n    public ScatterGatherFirstCompletedPool(int nrOfInstances, Akka.Routing.Resizer resizer, System.TimeSpan within, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False) { }\n    public System.TimeSpan Within { get; }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Routing.ScatterGatherFirstCompletedPool WithDispatcher(string dispatcher) { }\n    public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n    public Akka.Routing.ScatterGatherFirstCompletedPool WithResizer(Akka.Routing.Resizer resizer) { }\n    public Akka.Routing.ScatterGatherFirstCompletedPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }\n    public class ScatterGatherFirstCompletedPoolSurrogate : Akka.Util.ISurrogate\n    {\n        public ScatterGatherFirstCompletedPoolSurrogate() { }\n        public int NrOfInstances { get; set; }\n        public Akka.Routing.Resizer Resizer { get; set; }\n        public string RouterDispatcher { get; set; }\n        public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }\n        public bool UsePoolDispatcher { get; set; }\n        public System.TimeSpan Within { get; set; }\n        public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ClusterClientReceptionistExtensionProvider Implementation\nDESCRIPTION: The ClusterClientReceptionistExtensionProvider creates instances of the ClusterClientReceptionist extension. It implements the ExtensionIdProvider interface which is part of Akka.NET's extension mechanism for plugin functionality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterClientReceptionistExtensionProvider : Akka.Actor.ExtensionIdProvider<Akka.Cluster.Tools.Client.ClusterClientReceptionist>\n{\n    public ClusterClientReceptionistExtensionProvider() { }\n    public override Akka.Cluster.Tools.Client.ClusterClientReceptionist CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ChildNameReserved Class in C#\nDESCRIPTION: Class implementing IChildStats to represent a reserved child actor name. Includes a static Instance property and overrides ToString.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_49\n\nLANGUAGE: C#\nCODE:\n```\npublic class ChildNameReserved : Akka.Actor.Internal.IChildStats\n{\n    public static Akka.Actor.Internal.ChildNameReserved Instance { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Akka.Cluster via NuGet Package Manager\nDESCRIPTION: Command to install the Akka.Cluster NuGet package using Package Manager Console in Visual Studio.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-overview.md#2025-04-16_snippet_0\n\nLANGUAGE: console\nCODE:\n```\nPM> Install-Package Akka.Cluster\n```\n\n----------------------------------------\n\nTITLE: Extracting Arguments from NewExpression in C#\nDESCRIPTION: An extension method that extracts argument values from a System.Linq.Expressions.NewExpression object. This method allows accessing the arguments passed to a constructor expression.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_249\n\nLANGUAGE: csharp\nCODE:\n```\n    {\n        public static object[] GetArguments(this System.Linq.Expressions.NewExpression newExpression) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Protected Internal Schedule Method Implementation\nDESCRIPTION: Empty implementation of InternalScheduleTellRepeatedly method for scheduling repeated actor messages with delay and interval.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\nprotected override void InternalScheduleTellRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable) { }\n```\n\n----------------------------------------\n\nTITLE: Akka.NET Receive Persistent Actors\nDESCRIPTION: Receive-style persistent actor implementations that provide alternatives to the untyped persistent actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/architecture.md#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n* ReceivePersistentActor\n* AtLeastOnceDeliveryReceiveActor\n```\n\n----------------------------------------\n\nTITLE: Implementing ThrottlerProvider in Akka.NET\nDESCRIPTION: Provider class that creates instances of ThrottleTransportAdapter in Akka.NET. It implements the ITransportAdapterProvider interface to create throttled transport instances.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic class ThrottlerProvider : Akka.Remote.Transport.ITransportAdapterProvider\n{\n    public ThrottlerProvider() { }\n    public Akka.Remote.Transport.Transport Create(Akka.Remote.Transport.Transport wrappedTransport, Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Intercept Exception in C# with FluentAssertions and Xunit\nDESCRIPTION: This C# code provides two equivalent ways to assert that a specific exception is thrown: using FluentAssertions' `ShouldThrow` and Xunit's `Assert.Throws`. Both methods check for `ArgumentException` when calling `serializer.Manifest` with an invalid argument.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/porting-guide.md#2025-04-16_snippet_21\n\nLANGUAGE: c#\nCODE:\n```\nvar serializer = new MiscMessageSerializer(Sys.AsInstanceOf<ExtendedActorSystem>());\n\n// use FluentAssertions\nAction comparison = () => serializer.Manifest(\"INVALID\");\ncomparison.ShouldThrow<ArgumentException>();\n\n// use Xunit2 asserts\nAssert.Throws<ArgumentException>(() => serializer.Manifest(\"INVALID\"));\n```\n\n----------------------------------------\n\nTITLE: Cluster-Wide Minimum Size Configuration\nDESCRIPTION: Configuration example showing how to set a minimum number of nodes required for the entire cluster using HOCON format.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-configuration.md#2025-04-16_snippet_2\n\nLANGUAGE: xml\nCODE:\n```\nakka {\n   actor.provider = cluster\n    remote {\n        dot-netty.tcp {\n            port = 8081\n            hostname = localhost\n        }\n    }\n    cluster {\n       seed-nodes = [\"akka.tcp://ClusterSystem@localhost:8081\"]\n       min-nr-of-members = 3\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Predicates in Message Handlers in C#\nDESCRIPTION: This snippet demonstrates the use of predicates to conditionally handle messages. Handlers for strings with length greater than specified values are defined. Only the first handler with a true predicate is invoked. Examples illustrate message outcomes based on different string lengths.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka/Util/MatchHandler/README.md#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nReceive<string>(s => s.Length>5, s => Console.WriteLine(\"Received string: \" + s);\nReceive<string>(s => s.Length>5, s => Console.WriteLine(\"1: \" + s));    //1\nReceive<string>(s => s.Length>2, s => Console.WriteLine(\"2: \" + s));    //2\nReceive<string>(s => Console.WriteLine(\"3: \" + s));                     //3\n```\n\n----------------------------------------\n\nTITLE: Defining CurrentPersistenceIds Class in C#\nDESCRIPTION: A sealed class that contains information about all persistence IDs and their highest ordering number. Implements IDeadLetterSuppression to prevent dead letter messages when this message is not handled.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class CurrentPersistenceIds : Akka.Event.IDeadLetterSuppression\n{\n    public readonly System.Collections.Generic.IEnumerable<string> AllPersistenceIds;\n    public readonly long HighestOrderingNumber;\n    public CurrentPersistenceIds(System.Collections.Generic.IEnumerable<string> allPersistenceIds, long highestOrderingNumber) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Publish/Subscribe Components in Akka.NET\nDESCRIPTION: This snippet defines various message classes for handling publish/subscribe operations in Akka.NET. Each class, such as 'Put', 'Remove', 'Send', and 'Subscribe', represents a specific type of message used in the publish/subscribe pattern. These messages include properties for actor references and topics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Net.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic override int GetHashCode() { }\npublic override string ToString() { }\n}\npublic sealed class Put : System.IEquatable<Akka.Cluster.Tools.PublishSubscribe.Put>\n{\n    public Put(Akka.Actor.IActorRef @ref) { }\n    public Akka.Actor.IActorRef Ref { get; }\n    public bool Equals(Akka.Cluster.Tools.PublishSubscribe.Put other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Remove : System.IEquatable<Akka.Cluster.Tools.PublishSubscribe.Remove>\n{\n    public Remove(string path) { }\n    public string Path { get; }\n    public bool Equals(Akka.Cluster.Tools.PublishSubscribe.Remove other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Send : Akka.Actor.IWrappedMessage, Akka.Cluster.Tools.PublishSubscribe.IDistributedPubSubMessage, System.IEquatable<Akka.Cluster.Tools.PublishSubscribe.Send>\n{\n    public Send(string path, object message, bool localAffinity = False) { }\n    public bool LocalAffinity { get; }\n    public object Message { get; }\n    public string Path { get; }\n    public bool Equals(Akka.Cluster.Tools.PublishSubscribe.Send other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SendToAll : Akka.Actor.IWrappedMessage, Akka.Cluster.Tools.PublishSubscribe.IDistributedPubSubMessage, System.IEquatable<Akka.Cluster.Tools.PublishSubscribe.SendToAll>\n{\n    public SendToAll(string path, object message, bool excludeSelf = False) { }\n    public bool ExcludeSelf { get; }\n    public object Message { get; }\n    public string Path { get; }\n    public bool Equals(Akka.Cluster.Tools.PublishSubscribe.SendToAll other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Subscribe : System.IEquatable<Akka.Cluster.Tools.PublishSubscribe.Subscribe>\n{\n    public Subscribe(string topic, Akka.Actor.IActorRef @ref, string group = null) { }\n    public string Group { get; }\n    public Akka.Actor.IActorRef Ref { get; }\n    public string Topic { get; }\n    public bool Equals(Akka.Cluster.Tools.PublishSubscribe.Subscribe other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SubscribeAck : Akka.Event.IDeadLetterSuppression, System.IEquatable<Akka.Cluster.Tools.PublishSubscribe.SubscribeAck>\n{\n    public SubscribeAck(Akka.Cluster.Tools.PublishSubscribe.Subscribe subscribe) { }\n    public Akka.Cluster.Tools.PublishSubscribe.Subscribe Subscribe { get; }\n    public bool Equals(Akka.Cluster.Tools.PublishSubscribe.SubscribeAck other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Unsubscribe : System.IEquatable<Akka.Cluster.Tools.PublishSubscribe.Unsubscribe>\n{\n    public Unsubscribe(string topic, Akka.Actor.IActorRef @ref, string group = null) { }\n    public string Group { get; }\n    public Akka.Actor.IActorRef Ref { get; }\n    public string Topic { get; }\n    public bool Equals(Akka.Cluster.Tools.PublishSubscribe.Unsubscribe other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class UnsubscribeAck : System.IEquatable<Akka.Cluster.Tools.PublishSubscribe.UnsubscribeAck>\n{\n    public UnsubscribeAck(Akka.Cluster.Tools.PublishSubscribe.Unsubscribe unsubscribe) { }\n    public Akka.Cluster.Tools.PublishSubscribe.Unsubscribe Unsubscribe { get; }\n    public bool Equals(Akka.Cluster.Tools.PublishSubscribe.UnsubscribeAck other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Assembly Metadata and InternalsVisibleTo Attributes in C#\nDESCRIPTION: Assembly-level attributes to configure repository URL, expose internals to test projects, and set COM interoperability options. The TargetFramework is set to .NET Standard 2.0.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Core.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding.Tests.MultiNode\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"a05c31e8-0246-46a1-b3bc-4d6fe7a9aa49\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: WSL2 Resource Configuration\nDESCRIPTION: Configuration settings for WSL2 to simulate limited computing resources for testing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/debugging.md#2025-04-16_snippet_3\n\nLANGUAGE: ini\nCODE:\n```\n[wsl2]\nmemory=2GB   # Limits VM memory in WSL 2 up to 2GB\nprocessors=2 # Makes the WSL 2 VM use two virtual processors\n```\n\n----------------------------------------\n\nTITLE: Implementing AnyNumber for Numeric Type Handling in C#\nDESCRIPTION: This internal API struct provides a unified way to handle different numeric types in the metrics system. It supports int, long, float, and double types with implicit conversion operators and type identification.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Net.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic struct AnyNumber\n{\n    public AnyNumber(int n) { }\n    public AnyNumber(long n) { }\n    public AnyNumber(float n) { }\n    public AnyNumber(double n) { }\n    public double DoubleValue { get; }\n    public long LongValue { get; }\n    public Akka.Cluster.Metrics.Helpers.AnyNumber.NumberType Type { get; }\n    public override string ToString() { }\n    public static Akka.Cluster.Metrics.Helpers.AnyNumber op_Implicit(int n) { }\n    public static Akka.Cluster.Metrics.Helpers.AnyNumber op_Implicit(long n) { }\n    public static Akka.Cluster.Metrics.Helpers.AnyNumber op_Implicit(float n) { }\n    public static Akka.Cluster.Metrics.Helpers.AnyNumber op_Implicit(double n) { }\n    public enum NumberType\n    {\n        Int = 0,\n        Long = 1,\n        Float = 2,\n        Double = 3,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Internal Stash Overflow Strategy in Akka.NET\nDESCRIPTION: Defines the default internal stash overflow strategy for all persistent actors. This HOCON configuration sets the strategy to ThrowExceptionConfigurator.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/event-sourcing.md#2025-04-16_snippet_7\n\nLANGUAGE: hocon\nCODE:\n```\nakka.persistence.internal-stash-overflow-strategy = \"akka.persistence.ThrowExceptionConfigurator\"\n```\n\n----------------------------------------\n\nTITLE: Implementing External Shard Location Response Class in C#\nDESCRIPTION: Defines a sealed class for handling shard location responses with address information. Implements INoSerializationVerificationNeeded and IEquatable interfaces.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class GetShardLocationResponse : Akka.Actor.INoSerializationVerificationNeeded, System.IEquatable<Akka.Cluster.Sharding.External.ExternalShardAllocationStrategy.GetShardLocationResponse>\n{\n    public GetShardLocationResponse(Akka.Actor.Address address) { }\n    public Akka.Actor.Address Address { get; }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.Cluster.Sharding.External.ExternalShardAllocationStrategy.GetShardLocationResponse other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FutureActorRef Generic Class in C#\nDESCRIPTION: Defines the FutureActorRef<T> class which extends MinimalActorRef. It provides functionality for handling future actor references and system messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic class FutureActorRef<T> : Akka.Actor.MinimalActorRef\n{\n    public FutureActorRef(System.Threading.Tasks.TaskCompletionSource<T> result, Akka.Actor.ActorPath path, Akka.Actor.IActorRefProvider provider) { }\n    public override Akka.Actor.ActorPath Path { get; }\n    public override Akka.Actor.IActorRefProvider Provider { get; }\n    public virtual void DeliverAsk(object message, Akka.Actor.ICanTell destination) { }\n    public override void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UdpConnected Disconnect Command in Akka.NET\nDESCRIPTION: Command to terminate an existing UDP connection. Uses a singleton instance pattern for memory efficiency.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_177\n\nLANGUAGE: C#\nCODE:\n```\npublic class Disconnect : Akka.IO.UdpConnected.Command\n{\n    public static readonly Akka.IO.UdpConnected.Disconnect Instance;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing State Recovery in Counter Actor\nDESCRIPTION: Implementation of OnRecover method to restore actor state during restart.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistence-testing.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override void OnRecover(object message)\n{\n    switch (message as string)\n    {\n        case \"inc\":\n            value++;\n            break;\n\n        case \"dec\":\n            value++;\n            break;\n        \n        default:\n            return;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Unmute Class for Akka.NET Test Event Filtering\nDESCRIPTION: A message class used to unmute previously muted event filters in the Akka.NET TestKit. This class allows tests to restore normal event reporting after temporary suppression.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_56\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Unmute : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public Unmute(params Akka.TestKit.Internal.EventFilterBase[] filters) { }\n    public Unmute(System.Collections.Generic.IReadOnlyCollection<Akka.TestKit.Internal.EventFilterBase> filters) { }\n    public System.Collections.Generic.IReadOnlyCollection<Akka.TestKit.Internal.EventFilterBase> Filters { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Recovery Class Implementation in C#\nDESCRIPTION: Sealed class defining recovery operations with snapshot selection criteria and sequence number management. Includes constructors and properties for managing recovery state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Recovery\n{\n    public Recovery() { }\n    public Recovery(Akka.Persistence.SnapshotSelectionCriteria fromSnapshot) { }\n    public Recovery(Akka.Persistence.SnapshotSelectionCriteria fromSnapshot, long toSequenceNr) { }\n    public Recovery(Akka.Persistence.SnapshotSelectionCriteria fromSnapshot = null, long toSequenceNr = 9223372036854775807, long replayMax = 9223372036854775807) { }\n    public static Akka.Persistence.Recovery Default { get; }\n    public Akka.Persistence.SnapshotSelectionCriteria FromSnapshot { get; }\n    public static Akka.Persistence.Recovery None { get; }\n    public long ReplayMax { get; }\n    public long ToSequenceNr { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Syntax for RoundRobinPool Router Creation in C#\nDESCRIPTION: An alternative way to create the same router configuration. This syntax emphasizes that the router is created first and then the worker props are applied to it.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar props = new RoundRobinPool(5).Props(Props.Create<Worker>());\n```\n\n----------------------------------------\n\nTITLE: Problematic Usage of ReceiveAsync<T>() with Synchronous Code in C#\nDESCRIPTION: This example demonstrates the incorrect usage of ReceiveAsync<T>() with a synchronous lambda body, which triggers the AK1003 warning. The code shows a ReceiveActor implementation where the message handler doesn't contain any awaited operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK1003.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Actor;\nusing System.Threading.Tasks;\nusing System;\n\npublic sealed class MyActor : ReceiveActor\n{\n    public MyActor()\n    {\n        // Notice that there are no `await` inside the lambda function,\n        // The lambda function is essentially synchronous\n        ReceiveAsync<string>(async str => {\n            Sender.Tell(str);\n        }):\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MetricsGossip class in C# for Akka.NET\nDESCRIPTION: Implements a sealed class for metrics gossip, including methods for merging, filtering, and manipulating node metrics. It implements various interfaces for deep cloning, message handling, and equality comparison.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Core.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class MetricsGossip : Google.Protobuf.IDeepCloneable<Akka.Cluster.Metrics.Serialization.MetricsGossip>, Google.Protobuf.IMessage, Google.Protobuf.IMessage<Akka.Cluster.Metrics.Serialization.MetricsGossip>, System.IEquatable<Akka.Cluster.Metrics.Serialization.MetricsGossip>\n{\n    public const int AllAddressesFieldNumber = 1;\n    public const int AllMetricNamesFieldNumber = 2;\n    public static readonly Akka.Cluster.Metrics.Serialization.MetricsGossip Empty;\n    public const int NodeMetricsFieldNumber = 3;\n    public MetricsGossip() { }\n    public MetricsGossip(Akka.Cluster.Metrics.Serialization.MetricsGossip other) { }\n    public MetricsGossip(System.Collections.Immutable.IImmutableSet<Akka.Cluster.Metrics.Serialization.NodeMetrics> nodes) { }\n    public Google.Protobuf.Collections.RepeatedField<Akka.Cluster.Metrics.Serialization.AddressData> AllAddresses { get; }\n    public Google.Protobuf.Collections.RepeatedField<string> AllMetricNames { get; }\n    public static Google.Protobuf.Reflection.MessageDescriptor Descriptor { get; }\n    public Google.Protobuf.Collections.RepeatedField<Akka.Cluster.Metrics.Serialization.NodeMetrics> NodeMetrics { get; }\n    public System.Collections.Immutable.IImmutableSet<Akka.Cluster.Metrics.Serialization.NodeMetrics> Nodes { get; }\n    public static Google.Protobuf.MessageParser<Akka.Cluster.Metrics.Serialization.MetricsGossip> Parser { get; }\n    public int CalculateSize() { }\n    public Akka.Cluster.Metrics.Serialization.MetricsGossip Clone() { }\n    public override bool Equals(object other) { }\n    public bool Equals(Akka.Cluster.Metrics.Serialization.MetricsGossip other) { }\n    public Akka.Cluster.Metrics.Serialization.MetricsGossip Filter(System.Collections.Immutable.IImmutableSet<Akka.Actor.Address> includeNodes) { }\n    public override int GetHashCode() { }\n    public Akka.Cluster.Metrics.Serialization.MetricsGossip Merge(Akka.Cluster.Metrics.Serialization.MetricsGossip otherGossip) { }\n    public void MergeFrom(Akka.Cluster.Metrics.Serialization.MetricsGossip other) { }\n    public void MergeFrom(Google.Protobuf.CodedInputStream input) { }\n    public Akka.Util.Option<Akka.Cluster.Metrics.Serialization.NodeMetrics> NodeMetricsFor(Akka.Actor.Address address) { }\n    public Akka.Cluster.Metrics.Serialization.MetricsGossip Remove(Akka.Actor.Address node) { }\n    public override string ToString() { }\n    public void WriteTo(Google.Protobuf.CodedOutputStream output) { }\n    public static Akka.Cluster.Metrics.Serialization.MetricsGossip +(Akka.Cluster.Metrics.Serialization.MetricsGossip gossip, Akka.Cluster.Metrics.Serialization.NodeMetrics newNodeMetrics) { }\n}\n```\n\n----------------------------------------\n\nTITLE: YAML Metadata Definition\nDESCRIPTION: This YAML snippet shows the required metadata at the top of each DocFx article. The `uid` is a unique identifier, and the `title` defines the page's `<title>` tag for SEO and user experience.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/documentation-guidelines.md#2025-04-16_snippet_4\n\nLANGUAGE: yml\nCODE:\n```\n---\nuid: documentation-guidelines\ntitle: Documentation Contribution Guidelines\n---\n```\n\n----------------------------------------\n\nTITLE: UDP Connected Extension Implementation in C#\nDESCRIPTION: Defines UDP connection related message and event classes for Akka.NET's IO system. Includes Connected, Disconnect, Send and other UDP operation commands.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_172\n\nLANGUAGE: C#\nCODE:\n```\npublic class UdpConnectedExt : Akka.IO.IOExtension, Akka.Actor.INoSerializationVerificationNeeded\n{\n    public UdpConnectedExt(Akka.Actor.ExtendedActorSystem system) { }\n    public UdpConnectedExt(Akka.Actor.ExtendedActorSystem system, Akka.IO.UdpSettings settings) { }\n    public override Akka.Actor.IActorRef Manager { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Internal Cluster Components in Akka.NET\nDESCRIPTION: This snippet defines classes from the internal namespaces for managing counts of subscribers and message serialization for Akka.NET's distributed publish/subscribe system. These classes are intended for internal use and provide functionality for counting subscribers and serializing messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Net.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.ApiMayChangeAttribute()]\npublic sealed class CountSubscribers\n{\n    public CountSubscribers(string topic) { }\n    public string Topic { get; }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class DistributedPubSubMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public DistributedPubSubMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object o) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PersistencePluginProxyExtension for Akka.NET\nDESCRIPTION: This class extends Akka.NET's extension system to provide a persistence plugin proxy, allowing for dynamic configuration of persistence plugins.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\npublic class PersistencePluginProxyExtension : Akka.Actor.ExtensionIdProvider<Akka.Persistence.Journal.PersistencePluginProxyExtension>, Akka.Actor.IExtension\n{\n    public PersistencePluginProxyExtension(Akka.Actor.ActorSystem system) { }\n    public override Akka.Persistence.Journal.PersistencePluginProxyExtension CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: DurableProducerQueue Message Classes in C#\nDESCRIPTION: Message classes for the DurableProducerQueue, which provides persistence for messages in Akka.NET's reliable delivery system to support recovery after failures.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_88\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic class static DurableProducerQueue\n{\n    public const string NoQualifier = \"\";\n    public interface IDurableProducerQueueCommand { }\n    [System.Runtime.CompilerServices.NullableAttribute(0)]\n    public sealed class LoadState : Akka.Delivery.DurableProducerQueue.IDurableProducerQueueCommand, System.IEquatable<Akka.Delivery.DurableProducerQueue.LoadState>\n    {\n        public LoadState(Akka.Actor.IActorRef ReplyTo) { }\n        public Akka.Actor.IActorRef ReplyTo { get; set; }\n    }\n    [System.Runtime.CompilerServices.NullableAttribute(0)]\n    public sealed class MessageSent<[System.Runtime.CompilerServices.NullableAttribute(2)]  T> : Akka.Delivery.Internal.IDeliverySerializable, System.IEquatable<Akka.Delivery.DurableProducerQueue.MessageSent<T>>\n    {\n        public MessageSent(long SeqNr, [System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n                0,\n                1})] Akka.Delivery.Internal.MessageOrChunk<T> Message, bool Ack, string ConfirmationQualifier, long Timestamp) { }\n        public bool Ack { get; set; }\n        public string ConfirmationQualifier { get; set; }\n        [System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n                0,\n                1})]\n        public Akka.Delivery.Internal.MessageOrChunk<T> Message { get; set; }\n        public long SeqNr { get; set; }\n        public long Timestamp { get; set; }\n        public bool Equals([System.Runtime.CompilerServices.NullableAttribute(new byte[] {\n                2,\n                1})] Akka.Delivery.DurableProducerQueue.MessageSent<T> other) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Option<T> Implicit Conversion in C#\nDESCRIPTION: Implicit conversion operator to convert a value of type T to an Option<T>.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_224\n\nLANGUAGE: C#\nCODE:\n```\npublic static Akka.Util.Option<T> op_Implicit(T value) { }\n```\n\n----------------------------------------\n\nTITLE: Defining IKillSwitch Interface in C#\nDESCRIPTION: Interface definition for IKillSwitch, which allows controlling graph completion from outside. It includes methods for shutting down and aborting linked graphs.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/stream-dynamic.md#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IKillSwitch\n{\n    /// <summary>\n    /// After calling <see cref=\"Shutdown\"/> the linked <see cref=\"IGraph{TShape}\"/>s of <see cref=\"FlowShape{TIn,TOut}\"/> are completed normally.\n    /// </summary>\n    void Shutdown();\n\n    /// <summary>\n    /// After calling <see cref=\"Abort\"/> the linked <see cref=\"IGraph{TShape}\"/>s of <see cref=\"FlowShape{TIn,TOut}\"/> are failed.\n    /// </summary>\n    void Abort(Exception cause);\n}\n```\n\n----------------------------------------\n\nTITLE: Testing No Temperature Reading - C#\nDESCRIPTION: This snippet tests the response of the query actor when devices fail to provide a temperature reading. It helps to verify the actor's handling of missing data.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-4.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[DeviceGroupQuerySpec.cs](../../../../src/core/Akka.Docs.Tutorials/Tutorial4/DeviceGroupQuerySpec.cs?name=query-test-no-reading)]\n```\n\n----------------------------------------\n\nTITLE: Deprecated Example of Unsafe PipeTo Usage in C#\nDESCRIPTION: This code snippet demonstrates a previously considered unsafe use of `PipeTo` without closing over `Context.Sender`. However, this is no longer considered an issue.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK1001.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Actor;\nusing System.Threading.Tasks;\nusing System;\n\npublic sealed class MyActor : UntypedActor{\n\n    protected override void OnReceive(object message){\n        async Task<int> LocalFunction(){\n            await Task.Delay(10);\n            return message.ToString().Length;\n        }\n\n        // potentially unsafe use of Context.Sender\n        LocalFunction().PipeTo(Sender); \n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Closing TCP Connections in Akka Streams\nDESCRIPTION: This snippet shows how to close incoming TCP connections by cancelling the flow or shutting down the server's socket.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithstreamingio.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar connections = Tcp.Get(system).Bind(endpoint);\nvar closed = connections.To(Sink.ForEach<IncomingConnection>(conn =>\n    conn.HandleWith(Flow.FromSinkAndSource<ByteString, ByteString>(\n        Sink.Cancelled,\n        Source.Empty<ByteString>()), materializer)));\n\nclosed.Run(materializer);\n```\n\n----------------------------------------\n\nTITLE: LeaseException Class Definition in C#\nDESCRIPTION: Defines the LeaseException class that represents exceptions thrown by lease-related operations. Extends the standard System.Exception class with additional constructors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.DotNet.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class LeaseException : System.Exception\n{\n    public LeaseException(string message) { }\n    public LeaseException(string message, System.Exception innerEx) { }\n    protected LeaseException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Base Metrics Selector for Akka.NET\nDESCRIPTION: Abstract base class for mixing multiple capacity metrics selectors. Provides foundation for custom metric selection implementations in Akka.NET clusters.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Core.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class MixMetricsSelectorBase : Akka.Cluster.Metrics.CapacityMetricsSelector\n{\n    protected MixMetricsSelectorBase(System.Collections.Immutable.ImmutableArray<Akka.Cluster.Metrics.CapacityMetricsSelector> selectors) { }\n    public System.Collections.Immutable.ImmutableArray<Akka.Cluster.Metrics.CapacityMetricsSelector> Selectors { get; }\n    public override System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, double> Capacity(System.Collections.Immutable.IImmutableSet<Akka.Cluster.Metrics.Serialization.NodeMetrics> nodeMetrics) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FSM State Interface\nDESCRIPTION: Interface defining the basic structure of FSM states with an identifier property.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IFsmState\n{\n    string Identifier { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Shared Memory Journal in C#\nDESCRIPTION: Memory-based journal implementation that can be shared across different components. Extends the base MemoryJournal class.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\npublic class SharedMemoryJournal : Akka.Persistence.Journal.MemoryJournal\n{\n    public SharedMemoryJournal() { }\n    protected override System.Collections.Concurrent.ConcurrentDictionary<string, System.Collections.Generic.LinkedList<Akka.Persistence.IPersistentRepresentation>> Messages { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EventId Structure in C#\nDESCRIPTION: A structure that uniquely identifies an event in the persistence store using a combination of ID, persistence ID, and sequence number.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic struct EventId\n{\n    public readonly long Id;\n    public readonly string PersistenceId;\n    public readonly long SequenceNr;\n    public EventId(long id, long sequenceNr, string persistenceId) { }\n}\n```\n\n----------------------------------------\n\nTITLE: SnapshotEntry Data Class in C#\nDESCRIPTION: Defines a data structure for storing snapshot information including persistence ID, sequence number, timestamp, and the snapshot data itself.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_55\n\nLANGUAGE: C#\nCODE:\n```\npublic class SnapshotEntry {\n    public SnapshotEntry() { }\n    public string Id { get; set; }\n    public string PersistenceId { get; set; }\n    public long SequenceNr { get; set; }\n    public object Snapshot { get; set; }\n    public long Timestamp { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Building EventFilterFactory for Akka TestKit\nDESCRIPTION: This factory class generates various event filters for testing Akka.NET log events. Methods create filters for different log levels, exceptions, and message conditions. It requires Akka event predicates, message matchers, and regular expressions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class EventFilterFactory\n{\n    public EventFilterFactory(Akka.TestKit.TestKitBase testkit) { }\n    public EventFilterFactory(Akka.TestKit.TestKitBase testkit, Akka.Actor.ActorSystem system) { }\n    public EventFilterFactory(Akka.TestKit.TestKitBase testkit, Akka.Actor.ActorSystem actorSystem, System.Collections.Generic.IReadOnlyList<Akka.TestKit.Internal.EventFilterBase> filters) { }\n    protected Akka.TestKit.IEventFilterApplier CreateApplier(Akka.TestKit.Internal.EventFilterBase filter, Akka.Actor.ActorSystem system) { }\n    protected static Akka.TestKit.Internal.StringMatcher.IStringMatcher CreateMessageMatcher(string message, string start, string contains) { }\n    public Akka.TestKit.IEventFilterApplier Custom(System.Predicate<Akka.Event.LogEvent> predicate) { }\n    public Akka.TestKit.IEventFilterApplier Custom<TLogEvent>(System.Predicate<TLogEvent> predicate)\n        where TLogEvent : Akka.Event.LogEvent { }\n    public Akka.TestKit.IEventFilterApplier DeadLetter() { }\n    public Akka.TestKit.IEventFilterApplier DeadLetter<TMessage>(string source = null) { }\n    public Akka.TestKit.IEventFilterApplier DeadLetter<TMessage>(System.Func<TMessage, bool> isMatch, string source = null) { }\n    public Akka.TestKit.IEventFilterApplier DeadLetter(System.Type type, string source = null) { }\n    public Akka.TestKit.IEventFilterApplier DeadLetter(System.Type type, System.Func<object, bool> isMatch, string source = null) { }\n    public Akka.TestKit.IEventFilterApplier Debug(string message = null, string start = null, string contains = null, string source = null) { }\n    public Akka.TestKit.IEventFilterApplier Debug(System.Text.RegularExpressions.Regex pattern, string source = null) { }\n    public Akka.TestKit.IEventFilterApplier Error(string message = null, string start = null, string contains = null, string source = null) { }\n    public Akka.TestKit.IEventFilterApplier Error(System.Text.RegularExpressions.Regex pattern, string source = null) { }\n    public Akka.TestKit.IEventFilterApplier Exception<TException>(System.Text.RegularExpressions.Regex pattern, string source = null)\n        where TException : System.Exception { }\n    public Akka.TestKit.IEventFilterApplier Exception(System.Type exceptionType, System.Text.RegularExpressions.Regex pattern, string source = null, bool checkInnerExceptions = False) { }\n    public Akka.TestKit.IEventFilterApplier Exception<TException>(string message = null, string start = null, string contains = null, string source = null)\n        where TException : System.Exception { }\n    public Akka.TestKit.IEventFilterApplier Exception(System.Type exceptionType, string message = null, string start = null, string contains = null, string source = null, bool checkInnerExceptions = False) { }\n    public Akka.TestKit.IEventFilterApplier ForLogLevel(Akka.Event.LogLevel logLevel, string message = null, string start = null, string contains = null, string source = null) { }\n    public Akka.TestKit.IEventFilterApplier ForLogLevel(Akka.Event.LogLevel logLevel, System.Text.RegularExpressions.Regex pattern, string source = null) { }\n    public Akka.TestKit.IEventFilterApplier Info(string message = null, string start = null, string contains = null, string source = null) { }\n    public Akka.TestKit.IEventFilterApplier Info(System.Text.RegularExpressions.Regex pattern, string source = null) { }\n    public Akka.TestKit.IEventFilterApplier Warning(string message = null, string start = null, string contains = null, string source = null) { }\n    public Akka.TestKit.IEventFilterApplier Warning(System.Text.RegularExpressions.Regex pattern, string source = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Filtering Classes\nDESCRIPTION: Collection of event filter classes for handling different types of log events in Akka.NET testing. Includes filters for debug, error, and info level events with customizable message and source matching.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class EventFilterBase : Akka.TestKit.IEventFilter\n{\n    protected EventFilterBase(Akka.TestKit.Internal.StringMatcher.IStringMatcher messageMatcher, Akka.TestKit.Internal.StringMatcher.IStringMatcher sourceMatcher) { }\n    protected abstract string FilterDescriptiveName { get; }\n    public event Akka.TestKit.Internal.EventMatched EventMatched;\n    public bool Apply(Akka.Event.LogEvent logEvent) { }\n    protected bool InternalDoMatch(string src, object msg) { }\n    protected abstract bool IsMatch(Akka.Event.LogEvent evt);\n    protected virtual void OnEventMatched(Akka.Event.LogEvent logEvent) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating ClusterClientReceptionistExtensionProvider in Akka.NET\nDESCRIPTION: Extension provider implementation for the ClusterClientReceptionist to integrate with Akka's extension system. This enables getting the ClusterClientReceptionist via the extension registry.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Net.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterClientReceptionistExtensionProvider : Akka.Actor.ExtensionIdProvider<Akka.Cluster.Tools.Client.ClusterClientReceptionist>\n{\n    public ClusterClientReceptionistExtensionProvider() { }\n    public override Akka.Cluster.Tools.Client.ClusterClientReceptionist CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Association Handle Base Class in C#\nDESCRIPTION: Abstract base class for managing network associations between actors, including methods for writing data and handling disassociation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AssociationHandle\n{\n    protected AssociationHandle(Akka.Actor.Address localAddress, Akka.Actor.Address remoteAddress) { }\n    public abstract void Disassociate();\n    public abstract bool Write(Google.Protobuf.ByteString payload);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ExtensionIdProvider for Akka.NET Custom Persistence\nDESCRIPTION: Implementation of the ExtensionIdProvider that creates new instances of the SQLite persistence extension, a required component for Akka.NET extensions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/custom-persistence-provider.md#2025-04-16_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\npublic class SqlitePersistenceProvider : ExtensionIdProvider<SqlitePersistence>\n{\n    public override SqlitePersistence CreateExtension(ExtendedActorSystem system)\n    {\n        return new SqlitePersistence(system);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Listen Message Class in Akka.NET Routing\nDESCRIPTION: Defines a message used to register a listener actor with a router. It contains a reference to the listening actor and extends ListenerMessage.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_177\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Listen : Akka.Routing.ListenerMessage\n{\n    public Listen(Akka.Actor.IActorRef listener) { }\n    public Akka.Actor.IActorRef Listener { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IInternalSupportsTestFSMRef Generic Interface in C#\nDESCRIPTION: Internal interface for FSM (Finite State Machine) actors that support testing functionality, marked with InternalApiAttribute.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_56\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic interface IInternalSupportsTestFSMRef<TState, TData>\n{\n    bool IsStateTimerActive { get; }\n    void ApplyState(Akka.Actor.FSMBase.State<TState, TData> upcomingState);\n}\n```\n\n----------------------------------------\n\nTITLE: Constructor Pattern Matching with Typed Pattern in C# 7\nDESCRIPTION: This C# 7 code demonstrates pattern matching using a switch statement and a 'when' clause to simulate constructor patterns. It checks the type of the input 'x' and then uses the 'when' clause to check properties.  It returns a string based on the matched case. Relies on `Person` and `Dog` classes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/porting-guide.md#2025-04-16_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\npublic string TestPattern(object x)\n{\n    switch(x)\n    {\n        case Person p when p.LastName == \"Alexander\": return $\"found an Alexander, first name = {p.FirstName}\";\n        case Dog d when d.Name == \"Suka\": return \"found a dog named Suka\";  \n    }\n    return string.Empty;\n}\n```\n\n----------------------------------------\n\nTITLE: Default Listen Method for Transport (C#)\nDESCRIPTION: Default implementation for listening for incoming connections, returning the local address and a task completion source for the association event listener.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic System.Threading.Tasks.Task<System.ValueTuple<Akka.Actor.Address, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.IAssociationEventListener>>> DefaultListen() { }\n```\n\n----------------------------------------\n\nTITLE: Client State Notification Classes in C#\nDESCRIPTION: Classes for cluster client state notifications, providing information about reachability (ClusterClientUnreachable) and availability (ClusterClientUp) of cluster clients.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Core.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterClientUnreachable : Akka.Cluster.Tools.Client.IClusterClientInteraction\n{\n    public ClusterClientUnreachable(Akka.Actor.IActorRef clusterClient) { }\n    public Akka.Actor.IActorRef ClusterClient { get; }\n}\n\npublic sealed class ClusterClientUp : Akka.Cluster.Tools.Client.IClusterClientInteraction\n{\n    public ClusterClientUp(Akka.Actor.IActorRef clusterClient) { }\n    public Akka.Actor.IActorRef ClusterClient { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Exception Handling with Ask Pattern in C#\nDESCRIPTION: Demonstrates proper exception handling when using Ask pattern, showing how to complete Tasks with either success or failure results.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\ntry\n{\n    var result = operation();\n    Sender.Tell(result, Self);\n}\ncatch (Exception e)\n{\n    Sender.Tell(new Failure { Exception = e }, Self);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ThrottleMode Abstract Class in Akka.NET Remote Transport\nDESCRIPTION: An abstract base class for different throttling modes in Akka.NET's throttling transport adapter, providing methods to calculate time availability and token consumption.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ThrottleMode : Akka.Actor.INoSerializationVerificationNeeded\n{\n    protected ThrottleMode() { }\n    public abstract System.TimeSpan TimeToAvailable(long currentNanoTime, int tokens);\n    public abstract System.ValueTuple<Akka.Remote.Transport.ThrottleMode, bool> TryConsumeTokens(long nanoTimeOfSend, int tokens);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ForceDisassociate Class in Akka.NET Remote Transport\nDESCRIPTION: A class representing a command to force disassociation with a remote address in Akka.NET's transport system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ForceDisassociate\n{\n    public ForceDisassociate(Akka.Actor.Address address) { }\n    public Akka.Actor.Address Address { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Default HOCON Settings for Akka.TestKit\nDESCRIPTION: The default HOCON configuration settings for the Akka.TestKit package. These settings define the base configuration for test implementations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/modules/akka.testkit.md#2025-04-16_snippet_0\n\nLANGUAGE: hocon\nCODE:\n```\n[!code[Akka.TestKit.dll HOCON Configuration](../../../../src/core/Akka.TestKit/Internal/Reference.conf)]\n```\n\n----------------------------------------\n\nTITLE: Using JobManager ActorPublisher as a Source in C#\nDESCRIPTION: Demonstrates how to use the JobManager ActorPublisher as a Source in an Akka Streams pipeline. The example creates a flow that processes jobs and sends new jobs to the actor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\nvar jobManagerSource = Source.ActorPublisher<Job>(JobManager.Props);\nvar actorRef = Flow.Create<Job>()\n    .Select(job => job.Payload.ToUpper())\n    .Select(elem =>\n    {\n        Console.WriteLine(elem);\n        return elem;\n    })\n    .To(Sink.Ignore<string>())\n    .RunWith(jobManagerSource, materializer);\n\nactorRef.Tell(new Job(\"a\"));\nactorRef.Tell(new Job(\"b\"));\nactorRef.Tell(new Job(\"c\"));\n```\n\n----------------------------------------\n\nTITLE: Implementing Remote Transport Adapter in C#\nDESCRIPTION: Abstract base class for transport adapters in Akka.NET that wraps underlying transport implementations and provides association handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AbstractTransportAdapter : Akka.Remote.Transport.Transport\n{\n    protected Akka.Remote.Transport.Transport WrappedTransport;\n    protected AbstractTransportAdapter(Akka.Remote.Transport.Transport wrappedTransport) { }\n    public override long MaximumPayloadBytes { get; }\n    protected abstract Akka.Remote.Transport.SchemeAugmenter SchemeAugmenter { get; }\n    public override string SchemeIdentifier { get; }\n    public override System.Threading.Tasks.Task<Akka.Remote.Transport.AssociationHandle> Associate(Akka.Actor.Address remoteAddress) { }\n    protected abstract void InterceptAssociate(Akka.Actor.Address remoteAddress, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.AssociationHandle> statusPromise);\n}\n```\n\n----------------------------------------\n\nTITLE: Expecting Actor Termination in Akka.NET TestKitBase\nDESCRIPTION: These methods are used to expect and assert the termination of a specific actor in Akka.NET tests. They provide both synchronous and asynchronous versions with options for timeout and cancellation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic Akka.Actor.Terminated ExpectTerminated(Akka.Actor.IActorRef target, System.Nullable<System.TimeSpan> timeout = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.ValueTask<Akka.Actor.Terminated> ExpectTerminatedAsync(Akka.Actor.IActorRef target, System.Nullable<System.TimeSpan> timeout = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Problematic Usage of ScheduleTellRepeatedly in C#\nDESCRIPTION: This code snippet demonstrates incorrect usage of ScheduleTellRepeatedly() that can lead to memory leaks. It creates a new timer every time the actor is started, potentially accumulating timers if the actor is frequently restarted.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK1004.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Actor;\nusing System.Threading.Tasks;\nusing System;\n\npublic sealed class MyActor : ReceiveActor\n{\n    private sealed class TimerMessage\n    {\n        public static readonly TimerMessage Instance = new();\n        private TimerMessage() { }\n    }\n    \n    public MyActor()\n    {\n        Context.System.Scheduler.ScheduleTellRepeatedly(\n            initialDelay: TimeSpan.FromSeconds(3), \n            interval: TimeSpan.FromSeconds(3), \n            receiver: Self, \n            message: TimerMessage.Instance, \n            sender: Self);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ReplayFilterMode Enum for Akka.NET Persistence\nDESCRIPTION: This enum defines the different modes for the replay filter in Akka.NET persistence, including fail, warn, repair, and disabled options.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\npublic enum ReplayFilterMode\n{\n    Fail = 0,\n    Warn = 1,\n    RepairByDiscardOld = 2,\n    Disabled = 3,\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to AllDeadLetters Messages in Akka.NET\nDESCRIPTION: This example demonstrates how to capture all types of unhandled messages using the AllDeadLetters type in Akka.NET. It creates a DumbActor and an AllDeadLettersMessagesMonitorActor to capture and print all unhandled messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/event-bus.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DumbActor : ReceiveActor {  }\n\npublic class AllDeadLettersMessagesMonitorActor : ReceiveActor\n{\n    public AllDeadLettersMessagesMonitorActor()\n    {\n        Receive<AllDeadLetters>(Console.WriteLine);\n    }\n}\n\nusing (var system = ActorSystem.Create(\"MySystem\"))\n{\n    var dumbActor = system.ActorOf<DumbActor>();\n    var monitorActor = system.ActorOf<AllDeadLettersMessagesMonitorActor>();\n    \n    // Subscribe to messages of type AllDeadLetters\n    system.EventStream.Subscribe(monitorActor, typeof(AllDeadLetters));\n    \n    // try sending a message to actor which it doesn't understand\n    dumbActor.Tell(\"Hello\");\n    \n    // simulate the actor failing/stopping\n    dumbActor.Tell(Akka.Actor.PoisonPill.Instance);\n    \n    // try sending a message to the stopped actor\n    dumbActor.Tell(\"world\");\n    \n    Console.ReadLine();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining StashingHandlerInvocation Class in Akka.NET\nDESCRIPTION: The StashingHandlerInvocation class implements IPendingHandlerInvocation for handling events that need to be stashed. It stores the event and its handler function for later execution.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class StashingHandlerInvocation : Akka.Persistence.IPendingHandlerInvocation\n{\n    public StashingHandlerInvocation(object evt, System.Action<object> handler) { }\n    public object Event { get; }\n    public System.Action<object> Handler { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RuntimeDetector Static Class in C#\nDESCRIPTION: Static class with properties to detect runtime environment, helping with platform-specific behavior.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_230\n\nLANGUAGE: C#\nCODE:\n```\npublic class static RuntimeDetector\n{\n    public static readonly bool IsMono;\n    public static readonly bool IsWindows;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Akka.NET Logging in HOCON\nDESCRIPTION: HOCON configuration example for setting up logging in Akka.NET, specifying logger types and log levels.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.FSharp/README.md#2025-04-16_snippet_9\n\nLANGUAGE: HOCON\nCODE:\n```\nakka {\n        actor {\n            # collection of loggers used inside actor system, specified by fully-qualified type name\n            loggers = [ \"Akka.Event.DefaultLogger, Akka\" ]\n\n            # Options: OFF, ERROR, WARNING, INFO, DEBUG\n            logLevel = \"DEBUG\"\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterShardingStats Class in C#\nDESCRIPTION: This class represents statistics for cluster sharding, containing a dictionary of shard region stats keyed by actor addresses.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Core.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterShardingStats : Akka.Cluster.Sharding.IClusterShardingSerializable, System.IEquatable<Akka.Cluster.Sharding.ClusterShardingStats>\n{\n    public readonly System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, Akka.Cluster.Sharding.ShardRegionStats> Regions;\n    public ClusterShardingStats(System.Collections.Immutable.IImmutableDictionary<Akka.Actor.Address, Akka.Cluster.Sharding.ShardRegionStats> regions) { }\n    public override bool Equals(object obj) { }\n    public bool Equals(Akka.Cluster.Sharding.ClusterShardingStats other) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: LeaseSettings Class Definition\nDESCRIPTION: Defines the configuration settings for a lease, including lease name, owner name, and timeout settings. Provides methods for creating instances from configuration and for creating new instances with modified timeout settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.Net.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class LeaseSettings\n{\n    public LeaseSettings(string leaseName, string ownerName, Akka.Coordination.TimeoutSettings timeoutSettings, Akka.Configuration.Config leaseConfig) { }\n    public Akka.Configuration.Config LeaseConfig { get; }\n    public string LeaseName { get; }\n    public string OwnerName { get; }\n    public Akka.Coordination.TimeoutSettings TimeoutSettings { get; }\n    public static Akka.Coordination.LeaseSettings Create(Akka.Configuration.Config config, string leaseName, string ownerName) { }\n    public override string ToString() { }\n    public Akka.Coordination.LeaseSettings WithTimeoutSettings(Akka.Coordination.TimeoutSettings timeoutSettings) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ReplayTaggedMessages Class in C#\nDESCRIPTION: This class represents a request to replay tagged messages from a journal. It includes parameters for offset range, maximum number of messages, tag, and reply actor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ReplayTaggedMessages : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IJournalMessage, Akka.Persistence.IJournalRequest, Akka.Persistence.IPersistenceMessage\n{\n    public readonly int FromOffset;\n    public readonly int Max;\n    public readonly Akka.Actor.IActorRef ReplyTo;\n    public readonly string Tag;\n    public readonly int ToOffset;\n    public ReplayTaggedMessages(int fromOffset, int toOffset, int max, string tag, Akka.Actor.IActorRef replyTo) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Query Configuration Class in C#\nDESCRIPTION: Class for configuring SQL journal queries with table names, column specifications and transaction isolation levels. Includes parameters for schema configuration and serialization settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\npublic QueryConfiguration(string schemaName, string journalEventsTableName, string metaTableName, string persistenceIdColumnName, string sequenceNrColumnName, string payloadColumnName, string manifestColumnName, string timestampColumnName, string isDeletedColumnName, string tagsColumnName, string orderingColumnName, string serializerIdColumnName, System.TimeSpan timeout, string defaultSerializer, bool useSequentialAccess) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing BoundedStashImpl Class in C#\nDESCRIPTION: Implementation of a bounded stash for actor messages, inheriting from AbstractStash. Provides a constructor that accepts an actor context.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_48\n\nLANGUAGE: C#\nCODE:\n```\npublic class BoundedStashImpl : Akka.Actor.Internal.AbstractStash\n{\n    public BoundedStashImpl(Akka.Actor.IActorContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Akka.NET Cluster Actor Provider\nDESCRIPTION: Example of how to configure the Akka.NET actor system to use the cluster actor provider. This configuration automatically adds serializers for Akka.Cluster.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/serialization/codes.md#2025-04-16_snippet_1\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.provider = cluster\n```\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.provider = \"Akka.Cluster.ClusterActorRefProvider, Akka.Cluster\"\n```\n\n----------------------------------------\n\nTITLE: AtLeastOnceDeliverySnapshot Class Definition in Akka.Persistence\nDESCRIPTION: Class representing a snapshot of the at-least-once delivery state, containing the current delivery ID and unconfirmed deliveries for persistence and recovery.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class AtLeastOnceDeliverySnapshot : Akka.Persistence.Serialization.IMessage, System.IEquatable<Akka.Persistence.AtLeastOnceDeliverySnapshot>\n{\n    public AtLeastOnceDeliverySnapshot(long currentDeliveryId, Akka.Persistence.UnconfirmedDelivery[] unconfirmedDeliveries) { }\n    public long CurrentDeliveryId { get; }\n    public Akka.Persistence.UnconfirmedDelivery[] UnconfirmedDeliveries { get; }\n    public bool Equals(Akka.Persistence.AtLeastOnceDeliverySnapshot other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NewEventAppended Obsolete Class in C#\nDESCRIPTION: An obsolete sealed class that would represent a notification about a new event being appended. Marked as not implemented with true parameter to generate compilation errors if used.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\n[System.ObsoleteAttribute(\"Query is not implemented.\", true)]\npublic sealed class NewEventAppended : Akka.Event.IDeadLetterSuppression\n{\n    public static Akka.Persistence.Sql.Common.Journal.NewEventAppended Instance;\n}\n```\n\n----------------------------------------\n\nTITLE: DnsExt Class for DNS Extension Management in Akka.NET\nDESCRIPTION: Implements the extension for DNS functionality in Akka.NET with configuration settings and resolver management. This class handles the creation and configuration of DNS resolvers based on config settings.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_157\n\nLANGUAGE: C#\nCODE:\n```\npublic class DnsExt : Akka.IO.IOExtension\n    {\n        public DnsExt(Akka.Actor.ExtendedActorSystem system) { }\n        public Akka.IO.DnsBase Cache { get; }\n        public override Akka.Actor.IActorRef Manager { get; }\n        public Akka.IO.IDnsProvider Provider { get; }\n        public Akka.IO.DnsExt.DnsSettings Settings { get; }\n        public Akka.Actor.IActorRef GetResolver() { }\n        public class DnsSettings\n        {\n            public DnsSettings(Akka.Configuration.Config config) { }\n            public string Dispatcher { get; }\n            public string ProviderObjectName { get; }\n            public string Resolver { get; }\n            public Akka.Configuration.Config ResolverConfig { get; }\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Converting Scala Case Classes to C# Classes\nDESCRIPTION: Shows how to convert a Scala case class into a C# class with basic properties and constructor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/porting-guide.md#2025-04-16_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nfinal case class HandingOverData(singleton: ActorRef, name: String)\n```\n\nLANGUAGE: c#\nCODE:\n```\npublic sealed class HandingOverData\n{\n    public HandingOverData(IActorRef singleton, string name)\n    {\n        Singleton = singleton;\n        Name = name;\n    }\n\n    public IActorRef Singleton { get; }\n\n    public string Name { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Serilog Package via NuGet\nDESCRIPTION: Commands to install the required Serilog packages via NuGet package manager.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/serilog.md#2025-04-16_snippet_0\n\nLANGUAGE: console\nCODE:\n```\nPM> Install-Package Akka.Logger.Serilog\nPM> Install-Package Serilog.Sinks.Console\n```\n\n----------------------------------------\n\nTITLE: Implementing Association Events in C# for Akka.NET Remote Module\nDESCRIPTION: Defines various association events (AssociatedEvent, AssociationErrorEvent, DisassociatedEvent) for managing remote actor associations in Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class AssociatedEvent : Akka.Remote.AssociationEvent\n{\n    public AssociatedEvent(Akka.Actor.Address localAddress, Akka.Actor.Address remoteAddress, bool inbound) { }\n    public override bool IsInbound { get; set; }\n    public override Akka.Actor.Address LocalAddress { get; set; }\n    public override Akka.Actor.Address RemoteAddress { get; set; }\n    public override Akka.Event.LogLevel LogLevel() { }\n}\n\npublic sealed class AssociationErrorEvent : Akka.Remote.AssociationEvent\n{\n    public AssociationErrorEvent(System.Exception cause, Akka.Actor.Address localAddress, Akka.Actor.Address remoteAddress, bool inbound, Akka.Event.LogLevel level) { }\n    public System.Exception Cause { get; }\n    public override bool IsInbound { get; set; }\n    public override Akka.Actor.Address LocalAddress { get; set; }\n    public override Akka.Actor.Address RemoteAddress { get; set; }\n    public override Akka.Event.LogLevel LogLevel() { }\n    public override string ToString() { }\n}\n\npublic abstract class AssociationEvent : Akka.Remote.RemotingLifecycleEvent\n{\n    protected string EventName;\n    protected AssociationEvent() { }\n    public abstract bool IsInbound { get; set; }\n    public abstract Akka.Actor.Address LocalAddress { get; set; }\n    public abstract Akka.Actor.Address RemoteAddress { get; set; }\n    public override string ToString() { }\n}\n\npublic sealed class DisassociatedEvent : Akka.Remote.AssociationEvent\n{\n    public DisassociatedEvent(Akka.Actor.Address localAddress, Akka.Actor.Address remoteAddress, bool inbound) { }\n    public override bool IsInbound { get; set; }\n    public override Akka.Actor.Address LocalAddress { get; set; }\n    public override Akka.Actor.Address RemoteAddress { get; set; }\n    public override Akka.Event.LogLevel LogLevel() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ITimestampProvider Interface in C#\nDESCRIPTION: An interface for generating timestamps for persistent representations. Implementations can define how timestamps are created for events which affects ordering and querying.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ITimestampProvider\n{\n    long GenerateTimestamp(Akka.Persistence.IPersistentRepresentation message);\n}\n```\n\n----------------------------------------\n\nTITLE: Persistence Serialization Implementation in C#\nDESCRIPTION: Classes for serializing and deserializing persistence-related messages and snapshots.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_47\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IMessage { }\n\npublic sealed class PersistenceMessageSerializer : Akka.Serialization.Serializer\n{\n    public PersistenceMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override bool IncludeManifest { get; }\n    public override object FromBinary(byte[] bytes, System.Type type) { }\n    public override byte[] ToBinary(object obj) { }\n}\n\npublic class PersistenceSnapshotSerializer : Akka.Serialization.Serializer\n{\n    public PersistenceSnapshotSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override bool IncludeManifest { get; }\n    public override object FromBinary(byte[] bytes, System.Type type) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Read Journal Interfaces in Akka.NET Persistence Query\nDESCRIPTION: Declares interfaces for various types of read journals, including all events, current events, events by persistence ID, and events by tag queries. These interfaces extend IReadJournal.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceQuery.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IAllEventsQuery : Akka.Persistence.Query.IReadJournal\n{\n    Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> AllEvents(Akka.Persistence.Query.Offset offset);\n}\n\npublic interface ICurrentAllEventsQuery : Akka.Persistence.Query.IReadJournal\n{\n    Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentAllEvents(Akka.Persistence.Query.Offset offset);\n}\n\npublic interface ICurrentEventsByPersistenceIdQuery : Akka.Persistence.Query.IReadJournal\n{\n    Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentEventsByPersistenceId(string persistenceId, long fromSequenceNr, long toSequenceNr);\n}\n\npublic interface ICurrentEventsByTagQuery : Akka.Persistence.Query.IReadJournal\n{\n    Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentEventsByTag(string tag, Akka.Persistence.Query.Offset offset);\n}\n\npublic interface ICurrentPersistenceIdsQuery : Akka.Persistence.Query.IReadJournal\n{\n    Akka.Streams.Dsl.Source<string, Akka.NotUsed> CurrentPersistenceIds();\n}\n\npublic interface IEventsByPersistenceIdQuery : Akka.Persistence.Query.IReadJournal\n{\n    Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> EventsByPersistenceId(string persistenceId, long fromSequenceNr, long toSequenceNr);\n}\n\npublic interface IEventsByTagQuery : Akka.Persistence.Query.IReadJournal\n{\n    Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> EventsByTag(string tag, Akka.Persistence.Query.Offset offset);\n}\n\npublic interface IPersistenceIdsQuery : Akka.Persistence.Query.IReadJournal\n{\n    Akka.Streams.Dsl.Source<string, Akka.NotUsed> PersistenceIds();\n}\n\npublic interface IReadJournal { }\n\npublic interface IReadJournalProvider\n{\n    Akka.Persistence.Query.IReadJournal GetReadJournal();\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Akka.DependencyInjection via NuGet in PowerShell\nDESCRIPTION: This command installs the Akka.DependencyInjection package using the NuGet package manager in PowerShell.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/dependency-injection.md#2025-04-16_snippet_0\n\nLANGUAGE: console\nCODE:\n```\nPS> Install-Package Akka.DependencyInjection\n```\n\n----------------------------------------\n\nTITLE: LeaseException Class Definition in C#\nDESCRIPTION: Defines the base LeaseException class for lease-related exceptions. Provides constructors for various exception initialization scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class LeaseException : System.Exception\n{\n    public LeaseException(string message) { }\n    public LeaseException(string message, System.Exception innerEx) { }\n    protected LeaseException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing CallingThreadDispatcher in Akka.NET TestKit\nDESCRIPTION: Defines a CallingThreadDispatcher class that extends MessageDispatcher for executing tasks on the calling thread, useful for deterministic testing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class CallingThreadDispatcher : Akka.Dispatch.MessageDispatcher\n{\n    public static string Id;\n    public CallingThreadDispatcher(Akka.Dispatch.MessageDispatcherConfigurator configurator) { }\n    protected override void ExecuteTask(Akka.Dispatch.IRunnable run) { }\n    protected override void Shutdown() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WithListeners Message Class in Akka.NET\nDESCRIPTION: Defines a WithListeners class that extends ListenerMessage, used for routing messages with custom listener functions in Akka.NET. It stores an Action delegate that can be invoked with actor references.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_191\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class WithListeners : Akka.Routing.ListenerMessage\n{\n    public WithListeners(System.Action<Akka.Actor.IActorRef> listenerFunction) { }\n    public System.Action<Akka.Actor.IActorRef> ListenerFunction { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Right<TA, TB> Class Inheriting from Either<TA, TB>\nDESCRIPTION: Defines a specialized Right class for the Either monad pattern with two type parameters. It inherits from Either<TA, TB> and represents the right side of the disjoint union.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_211\n\nLANGUAGE: C#\nCODE:\n```\npublic class Right<TA, TB> : Akka.Util.Either<TA, TB>\n{\n    public Right(TB b) { }\n    public override bool IsLeft { get; }\n    public override bool IsRight { get; }\n    public TB Value { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Force Disassociation Classes in Akka.NET Remote\nDESCRIPTION: A set of classes used to force disassociation of remote connections. ForceDisassociate contains an address to disassociate, ForceDisassociateAck provides acknowledgment, and ForceDisassociateExplicitly includes a reason for disassociation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ForceDisassociate\n{\n    public ForceDisassociate(Akka.Actor.Address address) { }\n    public Akka.Actor.Address Address { get; }\n}\n\npublic sealed class ForceDisassociateAck\n{\n    public static Akka.Remote.Transport.ForceDisassociateAck Instance { get; }\n}\n\npublic sealed class ForceDisassociateExplicitly\n{\n    public ForceDisassociateExplicitly(Akka.Actor.Address address, Akka.Remote.Transport.DisassociateInfo reason) { }\n    public Akka.Actor.Address Address { get; }\n    public Akka.Remote.Transport.DisassociateInfo Reason { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Multi-Node Test Runner via NuGet\nDESCRIPTION: This command demonstrates how to install the Akka.MultiNodeTestRunner package via NuGet, which is necessary to run multi-node tests in Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/testing/multi-node-testing-old.md#2025-04-16_snippet_7\n\nLANGUAGE: console\nCODE:\n```\nPS> nuget.exe Install-Package Akka.MultiNodeTestRunner -NoVersion\n```\n\n----------------------------------------\n\nTITLE: Defining RecoveryCompleted Class in C#\nDESCRIPTION: This snippet defines the RecoveryCompleted class, which represents a completed recovery operation in Akka.NET persistence.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class RecoveryCompleted\n{\n    public static readonly Akka.Persistence.RecoveryCompleted Instance;\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly Attributes Declaration for Akka.Cluster.Sharding\nDESCRIPTION: Defines assembly-level attributes for Akka.Cluster.Sharding, including repository information, internals visibility to test projects, COM visibility settings, GUID, and target framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding.Tests.MultiNode\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"a05c31e8-0246-46a1-b3bc-4d6fe7a9aa49\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Joke Service Implementation\nDESCRIPTION: Service implementation for handling joke-related functionality within the Akka.NET Windows Service.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/deployment/windows-service.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/examples/WindowsService/AkkaWindowsService/JokeService.cs?name=akka-windows-joke-service)]\n```\n\n----------------------------------------\n\nTITLE: ClusterClient Serialization Control - HOCON\nDESCRIPTION: Configures Akka.NET ClusterClient serialization settings to enable or disable legacy serialization methods. Critical for users facing serialization issues post-upgrade. Requires familiarity with HOCON configuration syntax.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/whats-new/akkadotnet-v1.5-upgrade-advisories.md#2025-04-16_snippet_1\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster.client.use-legacy-serialization = on\n```\n\n----------------------------------------\n\nTITLE: Implementing Mute Class for Akka.NET Test Event Filtering\nDESCRIPTION: A message class used to mute specific event filters in the Akka.NET TestKit. This class allows tests to temporarily suppress certain types of log messages or events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_55\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Mute : Akka.Actor.INoSerializationVerificationNeeded\n{\n    public Mute(params Akka.TestKit.Internal.EventFilterBase[] filters) { }\n    public Mute(System.Collections.Generic.IReadOnlyCollection<Akka.TestKit.Internal.EventFilterBase> filters) { }\n    public System.Collections.Generic.IReadOnlyCollection<Akka.TestKit.Internal.EventFilterBase> Filters { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PersistentFSMBase Abstract Class in C#\nDESCRIPTION: Abstract base class for persistent FSM implementation with state management and transition handling\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class PersistentFSMBase<TState, TData, TEvent> : Akka.Persistence.PersistentActor, Akka.Routing.IListeners\n{\n    protected PersistentFSMBase() { }\n    public Akka.Routing.ListenerSupport Listeners { get; }\n    public TData NextStateData { get; }\n    public TData StateData { get; }\n    public TState StateName { get; }\n    protected System.Collections.Generic.IEnumerable<TState> StateNames { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: QueryConfiguration Class Definition in C#\nDESCRIPTION: Defines the QueryConfiguration class which configures SQL query settings for the journal. It specifies table and column names, timeouts, and serialization options for database operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic class QueryConfiguration\n{\n    public readonly string IsDeletedColumnName;\n    public readonly string JournalEventsTableName;\n    public readonly string ManifestColumnName;\n    public readonly string MetaTableName;\n    public readonly string OrderingColumnName;\n    public readonly string PayloadColumnName;\n    public readonly string PersistenceIdColumnName;\n    public readonly string SchemaName;\n    public readonly string SequenceNrColumnName;\n    public readonly string SerializerIdColumnName;\n    public readonly string TagsColumnName;\n    public readonly System.TimeSpan Timeout;\n    public readonly string TimestampColumnName;\n    public QueryConfiguration(string schemaName, string journalEventsTableName, string metaTableName, string persistenceIdColumnName, string sequenceNrColumnName, string payloadColumnName, string manifestColumnName, string timestampColumnName, string isDeletedColumnName, string tagsColumnName, string orderingColumnName, string serializerIdColumnName, System.TimeSpan timeout, string defaultSerializer, bool useSequentialAccess) { }\n    [System.ObsoleteAttribute(\"This property will always return null\")]\n    public string DefaultSerializer { get; }\n    public string FullJournalTableName { get; }\n    public string FullMetaTableName { get; }\n    public bool UseSequentialAccess { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Akka.Cluster.Metrics Auto-Start in HOCON\nDESCRIPTION: HOCON configuration for automatically starting the Akka.Cluster.Metrics module during ActorSystem startup.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-metrics.md#2025-04-16_snippet_7\n\nLANGUAGE: HOCON\nCODE:\n```\nakka {\n    extensions = [\"Akka.Cluster.Metrics.ClusterMetricsExtensionProvider, Akka.Cluster.Metrics\"]\n    actor.provider = \"cluster\"\n    cluster.metrics.collector {\n        provider = [\"Akka.Cluster.Metrics.Collectors.DefaultCollector, Akka.Cluster.Metrics\"]\n    }  \n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ORDictionaryKey Class for Akka.NET Distributed Data in C#\nDESCRIPTION: Defines the ORDictionaryKey class representing a key for ORDictionary<TKey, TValue>. It includes a constructor and properties for key and value types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ORDictionaryKey<TKey, TValue> : Akka.DistributedData.Key<Akka.DistributedData.ORDictionary<TKey, TValue>>\n    where TValue : Akka.DistributedData.IReplicatedData<TValue>\n{\n    public ORDictionaryKey(string id) { }\n    public System.Type KeyType { get; }\n    public System.Type ValueType { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Recreate System Message in Akka.NET\nDESCRIPTION: Defines a system message that instructs an actor to recreate itself after a failure. Carries the exception that caused the need for recreation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_122\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Recreate : Akka.Dispatch.SysMsg.SystemMessage\n{\n    public Recreate(System.Exception cause) { }\n    public System.Exception Cause { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Linux / OS X Build Script Execution\nDESCRIPTION: This shell script executes the DocFx build process on a Linux or OS X environment. It assumes that `build.sh` is available in the current directory and that DocFx is configured to run via this command.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/documentation-guidelines.md#2025-04-16_snippet_7\n\nLANGUAGE: console\nCODE:\n```\nbuild.sh docfx\n```\n\n----------------------------------------\n\nTITLE: Expecting Messages in Akka.NET TestKitBase\nDESCRIPTION: These methods allow expecting and asserting messages received by actors in Akka.NET tests. They provide various overloads for synchronous and asynchronous operations, with options for timeout, cancellation, and custom assertions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic System.Threading.Tasks.ValueTask<T> ExpectMsgAsync<T>(System.Func<T, Akka.Actor.IActorRef, bool> isMessageAndSender, System.Nullable<System.TimeSpan> timeout = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.ValueTask<T> ExpectMsgAsync<T>(System.Action<T, Akka.Actor.IActorRef> assertMessageAndSender, System.Nullable<System.TimeSpan> timeout = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.ValueTask<T> ExpectMsgAsync<T>(T expected, System.Func<T, T, bool> comparer, System.Nullable<System.TimeSpan> timeout = null, string hint = null, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Failure Detectors in C# for Akka.NET Remote Module\nDESCRIPTION: Defines various failure detector classes (DeadlineFailureDetector, PhiAccrualFailureDetector) and related interfaces for monitoring remote actor health.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class DeadlineFailureDetector : Akka.Remote.FailureDetector\n{\n    public DeadlineFailureDetector(System.TimeSpan acceptableHeartbeatPause, System.TimeSpan heartbeatInterval, Akka.Remote.Clock clock = null) { }\n    // ... (other methods and properties)\n}\n\npublic class PhiAccrualFailureDetector : Akka.Remote.FailureDetector\n{\n    public PhiAccrualFailureDetector(double threshold, int maxSampleSize, System.TimeSpan minStdDeviation, System.TimeSpan acceptableHeartbeatPause, System.TimeSpan firstHeartbeatEstimate, Akka.Remote.Clock clock = null) { }\n    // ... (other methods and properties)\n}\n\n// ... (IFailureDetectorRegistry interface and DefaultFailureDetectorRegistry class)\n```\n\n----------------------------------------\n\nTITLE: Defining Windows-Specific Fact Attribute\nDESCRIPTION: Defines `WindowsFactAttribute` for xUnit tests which allows for the conditional skipping of tests on Unix systems by setting the 'SkipUnix' property.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKitXunit2.DotNet.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.TestKit.Xunit2.Attributes\n{\n    public class WindowsFactAttribute : Xunit.FactAttribute\n    {\n        public WindowsFactAttribute() { }\n        public override string Skip { get; set; }\n        public string SkipUnix { get; set; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Distributed Design Principles in Akka.NET\nDESCRIPTION: This snippet discusses the design principles of Akka.NET, emphasizing its default distribution features and asynchronous message passing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/index.md#2025-04-16_snippet_5\n\nLANGUAGE: html\nCODE:\n```\n<h2><strong>Distributed</strong> by Default</h2>\n<p class=\"lead\">\nEverything in Akka.NET is designed to work in a distributed setting: all interactions of actors use purely message passing and everything is asynchronous.\n</p>\n<p>This effort has been undertaken to ensure that all functions are available equally when running within a single process or on a cluster of hundreds of machines. The key for enabling this is to go from remote to local by way of optimization instead of trying to go from local to remote by way of generalization. See this classic paper for a detailed discussion on why the second approach is bound to fail.\n</p>\n<p><a href=\"/articles/Remoting\">Read more</a></p>\n```\n\n----------------------------------------\n\nTITLE: Akka.NET Remote Serializers Implementation\nDESCRIPTION: Collection of serializer classes for handling different types of messages in Akka.NET remote communication.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic class DaemonMsgCreateSerializer : Akka.Serialization.Serializer\n{\n    public DaemonMsgCreateSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override bool IncludeManifest { get; }\n    public override object FromBinary(byte[] bytes, System.Type type) { }\n    public override byte[] ToBinary(object obj) { }\n}\n\npublic class MessageContainerSerializer : Akka.Serialization.Serializer\n{\n    public MessageContainerSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override bool IncludeManifest { get; }\n    public override object FromBinary(byte[] bytes, System.Type type) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Member Object in C#\nDESCRIPTION: This C# code demonstrates pattern matching in a switch statement. It checks if the input 'member' is a `Member` object, and then it calls `HasRole` if it's a `Member`. It returns `true` otherwise, to match the Scala example's behavior when the role is `None`.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/porting-guide.md#2025-04-16_snippet_12\n\nLANGUAGE: c#\nCODE:\n```\npublic bool MatchingRole(Member member, string role)\n{\n    switch (member)\n    {\n        case Member m:\n            return m.HasRole(role);\n        default:\n            return true;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom Line Sink\nDESCRIPTION: Demonstrates using the custom LineSink with the factorial stream\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/quickstart.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nfactorials.Select(_ => _.ToString()).RunWith(LineSink(\"factorial2.txt\"), materializer);\n```\n\n----------------------------------------\n\nTITLE: Managing Disposable Resources in Actors\nDESCRIPTION: Shows how to properly manage disposable resources within an actor using mailbox.Defer. This ensures resources are properly cleaned up when the actor is stopped, preventing resource leaks.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.FSharp/README.md#2025-04-16_snippet_3\n\nLANGUAGE: F#\nCODE:\n```\nlet disposableActor (mailbox:Actor<_>) =\n    let resource = new DisposableResource()\n    mailbox.Defer ((resource :> IDisposable).Dispose)\n    let rec loop () =\n        actor {\n            let! msg = mailbox.Receive()\n            return! loop ()\n        }\n    loop()\n```\n\n----------------------------------------\n\nTITLE: Using Within for Timing Assertions in C#\nDESCRIPTION: Shows how to use the Within construct to manage time constraints in Akka.NET tests. It demonstrates setting minimum and maximum time limits for test blocks.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/testing-actor-systems.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[WithinSample](../../../src/core/Akka.Docs.Tests/Testkit/WithinSampleTest.cs?name=WithinSample_0)]\n```\n\n----------------------------------------\n\nTITLE: Hocon Token Class Definition in C#\nDESCRIPTION: Class representing tokens in the Hocon configuration syntax, with factory methods for creating different token types like keys, literal values, and substitutions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_81\n\nLANGUAGE: C#\nCODE:\n```\npublic class Token\n{\n    protected Token() { }\n    public Token(Akka.Configuration.Hocon.TokenType type) { }\n    public Token(string value) { }\n    public Akka.Configuration.Hocon.TokenType Type { get; set; }\n    public string Value { get; set; }\n    public static Akka.Configuration.Hocon.Token Key(string key) { }\n    public static Akka.Configuration.Hocon.Token LiteralValue(string value) { }\n    public static Akka.Configuration.Hocon.Token Substitution(string path) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Dead Letter Messages in Akka.NET\nDESCRIPTION: This example demonstrates how to capture dead letter messages generated from a stopped actor. It sets up an actor system, creates a DeadletterMonitor actor to handle DeadLetter type messages, and simulates a failure scenario with an ExpendableActor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/event-bus.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Main()\n{\n    // Setup the actor system\n    ActorSystem system = ActorSystem.Create(\"MySystem\");\n\n    // Setup an actor that will handle deadletter type messages\n    var deadletterWatchMonitorProps = Props.Create(() => new DeadletterMonitor());\n    var deadletterWatchActorRef = system.ActorOf(deadletterWatchMonitorProps, \"DeadLetterMonitoringActor\");\n    \n    // subscribe to the event stream for messages of type \"DeadLetter\"\n    system.EventStream.Subscribe(deadletterWatchActorRef, typeof(DeadLetter));    \n    \n    // Setup an actor which will simulate a failure/shutdown\n    var expendableActorProps = Props.Create(() => new ExpendableActor());\n    var expendableActorRef = system.ActorOf(expendableActorProps, \"ExpendableActor\");\n    \n    // simulate the expendable actor failing/stopping\n    expendableActorRef.Tell(Akka.Actor.PoisonPill.Instance);\n    \n    // try sending a message to the stopped actor\n    expendableActorRef.Tell(\"another message\");\n\n}\n\n// A dead letter handling actor specifically for messages of type \"DeadLetter\"\npublic class DeadletterMonitor : ReceiveActor\n{\n    \n    public DeadletterMonitor()\n    {\n        Receive<DeadLetter>(dl => HandleDeadletter(dl));\n    }\n    \n    private void HandleDeadletter(DeadLetter dl)\n    {\n        Console.WriteLine($\"DeadLetter captured: {dl.Message}, sender: {dl.Sender}, recipient: {dl.Recipient}\");\n    }\n}\n\n// An expendable actor which will simulate a failure\npublic class ExpendableActor : ReceiveActor {  }\n```\n\n----------------------------------------\n\nTITLE: Defining WriteMessagesFailed Class in Akka.NET\nDESCRIPTION: The WriteMessagesFailed class represents a failure when writing multiple messages to the journal. It contains the cause of the failure and the number of writes attempted.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_46\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class WriteMessagesFailed : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IJournalMessage, Akka.Persistence.IJournalResponse, Akka.Persistence.IPersistenceMessage, System.IEquatable<Akka.Persistence.WriteMessagesFailed>\n{\n    public WriteMessagesFailed(System.Exception cause, int writeCount) { }\n    public System.Exception Cause { get; }\n    public int WriteCount { get; }\n    public bool Equals(Akka.Persistence.WriteMessagesFailed other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Query Actor State with Context.Become in Akka.NET\nDESCRIPTION: Implementation of state management using Context.Become() to track device responses. The actor tracks which devices have responded and which are still pending, updating its behavior as responses arrive.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-4.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nprivate UntypedReceive WaitingForReplies(\n    Dictionary<string, TemperatureReading> repliesSoFar,\n    HashSet<IActorRef> stillWaiting)\n{\n    return message =>\n    {\n        if (message is RespondTemperature response)\n        {\n            var deviceActor = Sender;\n            ReceivedResponse(deviceActor, response.RequestId, response.Temperature, repliesSoFar, stillWaiting);\n        }\n        else if (message is Terminated t)\n        {\n            var deviceActor = t.ActorRef;\n            ReceivedResponse(deviceActor, 0L, null, repliesSoFar, stillWaiting);\n        }\n        else if (message is CollectionTimeout)\n        {\n            var replies = new Dictionary<string, TemperatureReading>(repliesSoFar);\n            foreach (var deviceActor in stillWaiting)\n            {\n                var deviceId = ActorToDeviceId[deviceActor];\n                replies.Add(deviceId, TemperatureNotAvailable.Instance);\n            }\n\n            Requester.Tell(new RespondAllTemperatures(RequestId, replies));\n            Context.Stop(Self);\n        }\n    };\n}\n\nprotected override void OnReceive(object message)\n{\n    var repliesSoFar = new Dictionary<string, TemperatureReading>();\n    var stillWaiting = new HashSet<IActorRef>(ActorToDeviceId.Values);\n\n    Context.Become(WaitingForReplies(repliesSoFar, stillWaiting));\n\n    // We need the first handler to be active immediately as there might be responses arriving\n    // even before we get scheduled to run the first time, so we manually call the handler\n    Receive(message);\n}\n```\n\n----------------------------------------\n\nTITLE: DiscardConfigurator Implementation in C#\nDESCRIPTION: This class provides a strategy configuration for discarding messages in overflow scenarios for Akka Persistence. It encapsulates the creation of the corresponding overflow strategy based on the given configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class DiscardConfigurator : Akka.Persistence.IStashOverflowStrategyConfigurator\n{\n    public DiscardConfigurator() { }\n    public Akka.Persistence.IStashOverflowStrategy Create(Akka.Configuration.Config config) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining WriteMessageSuccess Class in Akka.NET\nDESCRIPTION: The WriteMessageSuccess class represents a successful write to the journal. It contains the persistent message and the actor instance ID.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class WriteMessageSuccess : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IJournalMessage, Akka.Persistence.IJournalResponse, Akka.Persistence.IPersistenceMessage, System.IEquatable<Akka.Persistence.WriteMessageSuccess>\n{\n    public WriteMessageSuccess(Akka.Persistence.IPersistentRepresentation persistent, int actorInstanceId) { }\n    public int ActorInstanceId { get; }\n    public Akka.Persistence.IPersistentRepresentation Persistent { get; }\n    public bool Equals(Akka.Persistence.WriteMessageSuccess other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SwitchableLoggedBehavior in Akka.NET Remote\nDESCRIPTION: Generic class for implementing switchable behaviors with logging. Provides a mechanism to push, pop, and apply behaviors, with support for logging, constant results, errors, and delayed completion.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\npublic class SwitchableLoggedBehavior<TIn, TOut>\n{\n    public SwitchableLoggedBehavior(System.Func<TIn, System.Threading.Tasks.Task<TOut>> defaultBehavior, System.Action<TIn> logCallback) { }\n    public System.Func<TIn, System.Threading.Tasks.Task<TOut>> CurrentBehavior { get; }\n    public System.Func<TIn, System.Threading.Tasks.Task<TOut>> DefaultBehavior { get; }\n    public System.Action<TIn> LogCallback { get; }\n    public System.Threading.Tasks.Task<TOut> Apply(TIn param) { }\n    public void Pop() { }\n    public void Push(System.Func<TIn, System.Threading.Tasks.Task<TOut>> behavior) { }\n    public void PushConstant(TOut result) { }\n    public System.Threading.Tasks.TaskCompletionSource<bool> PushDelayed() { }\n    public void PushError(System.Exception e) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Assembly Attributes for Akka.NET SQL Read Journal\nDESCRIPTION: Sets assembly-level attributes for the Akka.NET SQL Read Journal, including repository URL, COM visibility, GUID, and target framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommonQuery.Net.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"3cbd3880-0655-44cc-ad81-77e8cadfcc3e\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Unsubscribe Class Definition in C#\nDESCRIPTION: Implements an unsubscription message class for Akka.NET's distributed data replicator. This class allows actors to cancel their subscription to updates for a specific distributed data key.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_48\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Unsubscribe : Akka.DistributedData.IReplicatorMessage, System.IEquatable<Akka.DistributedData.Unsubscribe>\n{\n    public Unsubscribe(Akka.DistributedData.IKey key, Akka.Actor.IActorRef subscriber) { }\n    public Akka.DistributedData.IKey Key { get; }\n    public Akka.Actor.IActorRef Subscriber { get; }\n    public bool Equals(Akka.DistributedData.Unsubscribe other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling DotNetty Batching Configuration in HOCON\nDESCRIPTION: HOCON configuration snippet showing how to disable the DotNetty TCP batching system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/remoting/performance.md#2025-04-16_snippet_0\n\nLANGUAGE: hocon\nCODE:\n```\nakka.remote.dot-netty.tcp.batching.enabled = false\n```\n\n----------------------------------------\n\nTITLE: Implementing PNCounterDictionary Key in C#\nDESCRIPTION: Generic key class for PNCounterDictionary that extends Akka's DistributedData Key type.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\npublic class PNCounterDictionaryKey<T> : Akka.DistributedData.Key<Akka.DistributedData.PNCounterDictionary<T>>\n{\n    public PNCounterDictionaryKey(string id) { }\n    public System.Type KeyType { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Snapshot Query Interface in C#\nDESCRIPTION: Interface defining methods for executing snapshot-related database operations including creation, deletion, insertion, and selection of snapshots.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Core.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ISnapshotQueryExecutor\n{\n    Akka.Persistence.Sql.Common.Snapshot.QueryConfiguration Configuration { get; }\n    System.Threading.Tasks.Task CreateTableAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken);\n    System.Threading.Tasks.Task DeleteAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string persistenceId, long sequenceNr, System.Nullable<System.DateTime> timestamp);\n    System.Threading.Tasks.Task DeleteBatchAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string persistenceId, long maxSequenceNr, System.DateTime maxTimestamp);\n    System.Threading.Tasks.Task InsertAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, object snapshot, Akka.Persistence.SnapshotMetadata metadata);\n    System.Threading.Tasks.Task<Akka.Persistence.SelectedSnapshot> SelectSnapshotAsync(System.Data.Common.DbConnection connection, System.Threading.CancellationToken cancellationToken, string persistenceId, long maxSequenceNr, System.DateTime maxTimestamp);\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Akka.NET Nightly Package Feed URL\nDESCRIPTION: The base URL for accessing Akka.NET nightly package feeds through NuGet. This URL can be added to Visual Studio's package sources to consume pre-release builds.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/getting-access-to-nightly-builds.md#2025-04-16_snippet_0\n\nLANGUAGE: url\nCODE:\n```\nhttps://f.feedz.io/akkadotnet/akka/nuget/index.json\n```\n\n----------------------------------------\n\nTITLE: Defining RememberEntitiesStore Enum in C#\nDESCRIPTION: An enumeration of storage options for remembering entities in cluster sharding.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic enum RememberEntitiesStore\n{\n    DData = 0,\n    Eventsourced = 1,\n    Custom = 2,\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly Attributes in Akka.Persistence\nDESCRIPTION: Assembly attributes for the Akka.Persistence library, including visibility to other assemblies, repository information, GUID, and target framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Persistence.TCK\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Persistence.Tests\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"e3bcba88-003c-4cda-8a60-f0c2553fe3c8\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETCoreApp,Version=v6.0\", FrameworkDisplayName=\".NET 6.0\")]\n```\n\n----------------------------------------\n\nTITLE: Implementing PersistencePluginProxy for Akka.NET\nDESCRIPTION: This class implements a proxy for persistence plugins in Akka.NET, handling message routing and stashing for persistence-related operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\npublic class PersistencePluginProxy : Akka.Actor.ActorBase, Akka.Actor.IActorStash, Akka.Actor.IWithUnboundedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics>\n{\n    public PersistencePluginProxy(Akka.Configuration.Config config) { }\n    public Akka.Actor.IStash Stash { get; set; }\n    protected override void PreStart() { }\n    protected override bool Receive(object message) { }\n    public static void SetTargetLocation(Akka.Actor.ActorSystem system, Akka.Actor.Address address) { }\n    public static void Start(Akka.Actor.ActorSystem system) { }\n    public sealed class TargetLocation\n    {\n        public TargetLocation(Akka.Actor.Address address) { }\n        public Akka.Actor.Address Address { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Bad C# XML Documentation Example\nDESCRIPTION: This C# code snippet shows an example of poorly written XML documentation comments. The comments are generic, lack detail, and appear to be auto-generated rather than providing useful information about the code.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/documentation-guidelines.md#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n/// <summary>\n/// Class Serializer.\n/// </summary>\npublic abstract class Serializer\n{\n    /// <summary>\n    ///     Froms the binary.\n    /// </summary>\n    /// <param name=\"bytes\">The bytes.</param>\n    /// <param name=\"type\">The type.</param>\n    /// <returns>System.Object.</returns>\n    public abstract object FromBinary(byte[] bytes, Type type);\n}\n```\n\n----------------------------------------\n\nTITLE: Windows Build Script Execution\nDESCRIPTION: This shell script executes the DocFx build process on a Windows environment. It assumes that `build.cmd` is available in the current directory and that DocFx is configured to run via this command.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/documentation-guidelines.md#2025-04-16_snippet_6\n\nLANGUAGE: console\nCODE:\n```\nbuild.cmd docfx\n```\n\n----------------------------------------\n\nTITLE: Remote Actor Serialization Classes\nDESCRIPTION: Collection of serializer implementations for various message types in Akka.NET remote communication system. Includes serializers for system messages, protobuf, and primitive types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic class DaemonMsgCreateSerializer : Akka.Serialization.Serializer\n{\n    public DaemonMsgCreateSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override bool IncludeManifest { get; }\n    public override object FromBinary(byte[] bytes, System.Type type) { }\n    public override byte[] ToBinary(object obj) { }\n}\n\npublic class MessageContainerSerializer : Akka.Serialization.Serializer\n{\n    public MessageContainerSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override bool IncludeManifest { get; }\n    public override object FromBinary(byte[] bytes, System.Type type) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: DistributedDataProvider for Extension Creation\nDESCRIPTION: Provider class that creates the DistributedData extension for an actor system. It implements ExtensionIdProvider to integrate with Akka's extension system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class DistributedDataProvider : Akka.Actor.ExtensionIdProvider<Akka.DistributedData.DistributedData>\n{\n    public DistributedDataProvider() { }\n    public override Akka.DistributedData.DistributedData CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Example Release Notes Entry - Current Version (YML)\nDESCRIPTION: Sample release notes entry showing the structure and format for version 1.4.30, including version number, date, changes, and contributor statistics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/release-process.md#2025-04-16_snippet_0\n\nLANGUAGE: yml\nCODE:\n```\n#### 1.4.30 December 20 2021 ####\nAkka.NET v1.4.30 is a minor release that contains some enhancements for Akka.Streams and some bug fixes.\n\nNew features:\n* [Akka: Added StringBuilder pooling in NewtonsoftJsonSerializer](https://github.com/akkadotnet/akka.net/pull/4929)\n* [Akka.TestKit: Added InverseFishForMessage](https://github.com/akkadotnet/akka.net/pull/5430)\n* [Akka.Streams: Added custom frame sized Flow to Framing](https://github.com/akkadotnet/akka.net/pull/5444)\n* [Akka.Streams: Allow Stream to be consumed as IAsyncEnumerable](https://github.com/akkadotnet/akka.net/pull/4742) \n\nBug fixes:\n* [Akka.Cluster: Reverted startup sequence change](https://github.com/akkadotnet/akka.net/pull/5437)\n\nIf you want to see the [full set of changes made in Akka.NET v1.4.30, click here](https://github.com/akkadotnet/akka.net/milestone/61).\n\n| COMMITS | LOC+ | LOC- | AUTHOR |\n| --- | --- | --- | --- |\n| 6 | 75 | 101 | Aaron Stannard |\n| 2 | 53 | 5 | Brah McDude |\n| 2 | 493 | 12 | Drew |\n| 1 | 289 | 383 | Andreas Dirnberger |\n| 1 | 220 | 188 | Gregorius Soedharmo |\n| 1 | 173 | 28 | Ismael Hamed |\n```\n\n----------------------------------------\n\nTITLE: Multi-Node Test Runner Directory Structure\nDESCRIPTION: This snippet shows the directory and file structure created when installing the Akka.MultiNodeTestRunner package, including the executables for both .NET Framework and .NET Core applications.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/testing/multi-node-testing-old.md#2025-04-16_snippet_8\n\nLANGUAGE: text\nCODE:\n```\nroot/akka.multinodetestrunner\nroot/akka.multinodetestrunner/lib/net452/Akka.MultiNodeTestRunner.exe\nroot/akka.multinodetestrunner/lib/netcoreapp1.1/Akka.MultiNodeTestRunner.dll\n```\n\n----------------------------------------\n\nTITLE: Naming Tests with DisplayName Attribute in C#\nDESCRIPTION: Demonstrates how to name tests using the DisplayName attribute in C#. This approach allows for more descriptive test names that explain the test's purpose clearly.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/code-guidelines.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[Fact(DisplayName=\n@\"If a parent receives a Terminated event for a child actor,\nthe parent should no longer supervise it\")]\npublic void ClearChildUponTerminated()\n{\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DeleteSnapshotFailure Class in C#\nDESCRIPTION: This snippet defines the DeleteSnapshotFailure class, which represents a failure response when trying to delete a snapshot. It includes properties for metadata and the cause of the failure, implementing interfaces for serialization verification and message equality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class DeleteSnapshotFailure : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage, Akka.Persistence.ISnapshotResponse, System.IEquatable<Akka.Persistence.DeleteSnapshotFailure>\n{\n    public DeleteSnapshotFailure(Akka.Persistence.SnapshotMetadata metadata, System.Exception cause) { }\n    public System.Exception Cause { get; }\n    public Akka.Persistence.SnapshotMetadata Metadata { get; }\n    public bool Equals(Akka.Persistence.DeleteSnapshotFailure other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Default Downing Provider - HOCON\nDESCRIPTION: Provides configuration for disabling the default Akka.Cluster downing provider, effectively removing split brain resolver functionality. Essential for users who managed cluster network partitions differently prior to version 1.5.2.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/whats-new/akkadotnet-v1.5-upgrade-advisories.md#2025-04-16_snippet_2\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster.downing-provider-class = \"\"\n```\n\n----------------------------------------\n\nTITLE: Lambdas and Unbecome Usage in C#\nDESCRIPTION: Demonstrates how to use lambdas instead of separate methods for become logic and the usage of Unbecome to return to a previous state. It includes a stack-based approach where handlers are pushed and popped, allowing flexible state management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka/Util/MatchHandler/README.md#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nReceive<string>(s => s == \"Grumpy\", _ => Become(() =>\n{\n  Receive<string>(s => Sender.Tell(\"Leave me alone. I'm Grumpy!\"));\n}));\nReceive<string>(s => s == \"Grumpy\", _ => Become(Grumpy, discardOld: false));\n...\nprivate void Grumpy()\n{\n  Receive<string>(s => s == \"Snap out of it!\", _ => Unbecome());\n  Receive<string>(s => s == \"Mood?\", _ => Sender.Tell(\"I'm grumpy!\"));\n  Receive<string>(_ => Sender.Tell(\"Leave me alone. I'm Grumpy!\"));\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Scala Function Currying to C#\nDESCRIPTION: Demonstrates how to convert curried Scala functions to C# methods using delegates.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/porting-guide.md#2025-04-16_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef bufferOr(grouping: String, message: Any, originalSender: ActorRef)(action: ⇒ Unit): Unit = {\n    buffers.get(grouping) match {\n      case None ⇒ action\n      case Some(messages) ⇒\n        buffers = buffers.updated(grouping, messages :+ ((message, originalSender)))\n        totalBufferSize += 1\n    }\n}\n```\n\nLANGUAGE: c#\nCODE:\n```\npublic void BufferOr(string grouping, object message, IActorRef originalSender, Action action)\n{\n    BufferedMessages messages = null;\n    if (_buffers.TryGetValue(grouping, out messages))\n    {\n        _buffers[grouping].Add(new KeyValuePair<object, IActorRef>(message, originalSender));\n        _totalBufferSize += 1;\n    }\n    else {\n        action();\n    }  \n}\n```\n\n----------------------------------------\n\nTITLE: Defining IHandleEvent Interface in Akka.NET Remote Transport\nDESCRIPTION: An interface marker for handle events in Akka.NET's remote transport system that indicates no serialization verification is needed.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IHandleEvent : Akka.Actor.INoSerializationVerificationNeeded { }\n```\n\n----------------------------------------\n\nTITLE: Defining ITransportAdapterProvider Interface in Akka.NET Remote Transport\nDESCRIPTION: An interface for providers that can create transport adapters, wrapping an existing transport with additional functionality in Akka.NET's transport system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ITransportAdapterProvider\n{\n    Akka.Remote.Transport.Transport Create(Akka.Remote.Transport.Transport wrappedTransport, Akka.Actor.ExtendedActorSystem system);\n}\n```\n\n----------------------------------------\n\nTITLE: Fixed Message Ordering Test with ExpectMsgAllOf\nDESCRIPTION: Corrected test using ExpectMsgAllOf to handle messages arriving in any order.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/debugging.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[Test]\npublic void FixedOrderingAssumption()\n{\n    var probe = CreateTestProbe();\n    var actor1 = Sys.ActorOf(Props.Create(() => new SomeActor(probe)));\n    var actor2 = Sys.ActorOf(Props.Create(() => new SomeActor(probe)));\n\n    actor1.Tell(\"msg1\");\n    actor2.Tell(\"msg2\");\n\n    probe.ExpectMsgAllOf(\"msg1\", \"msg2\");\n}\n```\n\n----------------------------------------\n\nTITLE: Object Inheritance Example in HOCON\nDESCRIPTION: Shows how object concatenation can be used to implement configuration inheritance, where a specific configuration extends a generic one by adding or overriding properties.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/hocon.md#2025-04-16_snippet_4\n\nLANGUAGE: hocon\nCODE:\n```\ndata-center-generic = { cluster-size = 6 }\ndata-center-east = ${data-center-generic} { name = \"east\" }\n```\n\n----------------------------------------\n\nTITLE: Hocon TokenType Enumeration in C#\nDESCRIPTION: Enumeration defining the types of tokens used in Hocon configuration parsing, such as comments, keys, values, object delimiters, and array delimiters.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_82\n\nLANGUAGE: C#\nCODE:\n```\npublic enum TokenType\n{\n    Comment = 0,\n    Key = 1,\n    LiteralValue = 2,\n    Assign = 3,\n    ObjectStart = 4,\n    ObjectEnd = 5,\n    Dot = 6,\n    EoF = 7,\n    ArrayStart = 8,\n    ArrayEnd = 9,\n    Comma = 10,\n    Substitute = 11,\n    Include = 12,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Passivate Class in Akka.NET Sharding\nDESCRIPTION: This class represents a command to passivate an entity. It contains a stop message that will be sent to the entity when it is passivated.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\n    public sealed class Passivate : Akka.Cluster.Sharding.IShardRegionCommand\n    {\n        public Passivate(object stopMessage) { }\n        public object StopMessage { get; }\n    }\n```\n\n----------------------------------------\n\nTITLE: Global Using Setup for Akka.Event - C#\nDESCRIPTION: An XML configuration for global usings in C# 10 to streamline logging setup after upgrading to Akka.NET v1.5.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/whats-new/akkadotnet-v1.5-upgrade-advisories.md#2025-04-16_snippet_9\n\nLANGUAGE: xml\nCODE:\n```\n<Project>\n    <ItemGroup>\n        <PackageReference Include=\"Akka\" />\n        <Using Include=\"Akka.Event\" />\n    </ItemGroup>\n</Project>\n\n```\n\n----------------------------------------\n\nTITLE: Convenience Methods for Stage Completion in GraphStage - Scala\nDESCRIPTION: This section highlights convenience methods `CompleteStage()` and `FailStage(exception)`, which allow for the closure and failure of all ports in a stage. These methods simplify the management of the overall state of stream processing and are vital for ensuring that resources are released properly when processing is done.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/custom-stream-processing.md#2025-04-16_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nCompleteStage()\nFailStage(exception)\n```\n\n----------------------------------------\n\nTITLE: Implementing ForceDisassociateAck Class in Akka.NET Remote Transport\nDESCRIPTION: A singleton class representing an acknowledgment for a ForceDisassociate command in Akka.NET's transport system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ForceDisassociateAck\n{\n    public static Akka.Remote.Transport.ForceDisassociateAck Instance { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DeleteSnapshotsFailure Class\nDESCRIPTION: This snippet defines the `DeleteSnapshotsFailure` class, representing a failure when deleting multiple snapshots based on specified criteria in Akka.Persistence. It implements interfaces such as `INoSerializationVerificationNeeded`, `IPersistenceMessage`, `ISnapshotMessage`, `ISnapshotResponse`, and `IEquatable<DeleteSnapshotsFailure>`. The class includes the criteria used for deletion and the cause of the failure.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\n\"public sealed class DeleteSnapshotsFailure : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage, Akka.Persistence.ISnapshotResponse, System.IEquatable<Akka.Persistence.DeleteSnapshotsFailure>\n    {\n        public DeleteSnapshotsFailure(Akka.Persistence.SnapshotSelectionCriteria criteria, System.Exception cause) { }\n        public System.Exception Cause { get; }\n        public Akka.Persistence.SnapshotSelectionCriteria Criteria { get; }\n        public bool Equals(Akka.Persistence.DeleteSnapshotsFailure other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n    }\"\n```\n\n----------------------------------------\n\nTITLE: Defining Generic IRemovedNodePruning<T> Interface in C#\nDESCRIPTION: Extends IRemovedNodePruning with generic type parameter T, allowing for type-safe pruning operations on specific replicated data types. Includes type-specific pruning methods.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IRemovedNodePruning<T> : Akka.DistributedData.IRemovedNodePruning, Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedData<T>\n    where T : Akka.DistributedData.IReplicatedData\n{\n    T Prune(Akka.Cluster.UniqueAddress removedNode, Akka.Cluster.UniqueAddress collapseInto);\n    T PruningCleanup(Akka.Cluster.UniqueAddress removedNode);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RememberEntitiesStore Enum in Akka.NET Sharding\nDESCRIPTION: This enum defines the possible storage options for remembering entities.  The options are DData, Eventsourced, and Custom.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\n    public enum RememberEntitiesStore\n    {\n        DData = 0,\n        Eventsourced = 1,\n        Custom = 2,\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Suspend System Message in Akka.NET\nDESCRIPTION: Defines a system message that instructs an actor to suspend processing further messages until resumed. Part of the supervision strategy implementation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_128\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Suspend : Akka.Dispatch.SysMsg.SystemMessage\n{\n    public Suspend() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Assembly Metadata and Framework Target for Akka.NET\nDESCRIPTION: Assembly attribute declarations specifying repository URL, COM visibility, GUID, and target framework (.NET 6.0) for the Akka.NET assembly.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceQuery.DotNet.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"92ab2788-e008-40d0-8b54-0c95b3cf3404\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETCoreApp,Version=v6.0\", FrameworkDisplayName=\".NET 6.0\")]\n```\n\n----------------------------------------\n\nTITLE: Implementing Associate Method in Transport Class (C#)\nDESCRIPTION: Abstract method implementation for associating with a remote address to establish communication.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic override System.Threading.Tasks.Task<Akka.Remote.Transport.AssociationHandle> Associate(Akka.Actor.Address remoteAddress) { }\n```\n\n----------------------------------------\n\nTITLE: Constructor Pattern Matching in Scala\nDESCRIPTION: This Scala code demonstrates constructor pattern matching using a match statement. It checks the type and properties of the input 'x' and returns a string based on the matched case.  The example uses case classes `Person` and `Dog`.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/porting-guide.md#2025-04-16_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef testPattern(x: Any): String = x match {\n   case Person(first, \"Alexander\") => s\"found an Alexander, first name = $first\"\n   case Dog(\"Suka\") => \"found a dog named Suka\"\n}\n```\n\n----------------------------------------\n\nTITLE: Supervision and Monitoring in Actor Systems\nDESCRIPTION: This snippet details how supervision works in Akka.NET, explaining the parent-child relationship of actors and how it contributes to fault tolerance.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/index.md#2025-04-16_snippet_6\n\nLANGUAGE: html\nCODE:\n```\n<h2><strong>Supervision</strong> &amp; monitoring</h2>\n<p class=\"lead\">\nActors form a tree with actors being parents to the actors they've created.</p>\n<p>\nAs a parent, the actor is responsible for handling its children’s failures (so-called supervision), forming a chain of responsibility, all the way to the top. When an actor crashes, its parent can either restart or stop it, or escalate the failure up the hierarchy of actors.\nThis enables a clean set of semantics for managing failures in a concurrent, distributed system and allows for writing highly fault-tolerant systems that self-heal.</p>\n<p><a href=\"/articles/concepts/supervision.html\">Read more</a></p>\n```\n\n----------------------------------------\n\nTITLE: Information About Akka.NET Features\nDESCRIPTION: This snippet outlines key features of Akka.NET such as concurrency, performance, resiliency, elasticity, extensibility, and its open-source nature.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/index.md#2025-04-16_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<div class=\"row featured-box-minimal\">\n            <div class=\"col-md-4 col-sm-6 col-xs-12\">\n                <h4><i class=\"fa fa-arrows-alt\"></i> Simple Concurrency &amp; Distribution</h4>\n                <p>Asynchronous and Distributed by design. High-level abstractions like Actors and FSM.</p>\n            </div>\n\n            <div class=\"col-md-4 col-sm-6 col-xs-12\">\n                <h4><i class=\"fa fa-flash\"></i> High Performance</h4>\n                <p>50 million msg/sec on a single machine. Small memory footprint; ~2.5 million actors per GB of heap.</p>\n            </div>\n\n            <div class=\"col-md-4 col-sm-6 col-xs-12\">\n                <h4><i class=\"fa fa-shield\"></i> Resilient by Design</h4>\n                <p>Write systems that self-heal. Remote and/or local supervisor hierarchies.</p>\n            </div>\n\n            <div class=\"col-md-4 col-sm-6 col-xs-12\">\n                <h4><i class=\"fa fa-th-large\"></i> Elastic & Decentralized</h4>\n                <p>Adaptive load balancing, routing, partitioning and configuration-driven remoting.</p>\n            </div>\n\n            <div class=\"col-md-4 col-sm-6 col-xs-12\">\n                <h4><i class=\"fa fa-plus-circle\"></i> Extensible</h4>\n                <p>Use Akka.NET Extensions to adapt Akka to fit your needs.</p>\n            </div>\n\n            <div class=\"col-md-4 col-sm-6 col-xs-12\">\n                <h4><i class=\"fa fa-exclamation\"></i> Open Source </h4>\n                <p>Akka.NET is released under the Apache 2 license</p>\n            </div>\n        </div>\n```\n\n----------------------------------------\n\nTITLE: Implementing LeaseProvider Extension in C#\nDESCRIPTION: Actor system extension that provides lease management functionality. Includes methods for retrieving the extension instance and creating lease objects with specific configurations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.Core.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class LeaseProvider : Akka.Actor.IExtension\n{\n    public LeaseProvider(Akka.Actor.ExtendedActorSystem system) { }\n    public static Akka.Configuration.Config DefaultConfig() { }\n    public static Akka.Coordination.LeaseProvider Get(Akka.Actor.ActorSystem system) { }\n    public Akka.Coordination.Lease GetLease(string leaseName, string configPath, string ownerName) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EventAppended Obsolete Class in C#\nDESCRIPTION: An obsolete sealed class that would have represented an event append operation. Marked as not implemented with true parameter to generate compilation errors if used.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n[System.ObsoleteAttribute(\"Query is not implemented.\", true)]\npublic sealed class EventAppended : Akka.Event.IDeadLetterSuppression\n{\n    public readonly string PersistenceId;\n    public EventAppended(string persistenceId) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Structured Logging with Multiple Parameters - C#\nDESCRIPTION: An example of structuring logging calls in C# to avoid excessive allocations and boxing of value types when logging multiple parameters.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/whats-new/akkadotnet-v1.5-upgrade-advisories.md#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nvar @params = new[]{arg1, arg2, arg3, arg4, arg5, arg6, arg7};\nloggingAdapter.Log(format, @params);\n\n```\n\n----------------------------------------\n\nTITLE: Using Ask and Tell Operators in F#\nDESCRIPTION: Shows how to use the F# operators for sending messages to actors. The <!> operator is used for fire-and-forget messaging (Tell), while <?> is used for request-response patterns (Ask).\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.FSharp/README.md#2025-04-16_snippet_5\n\nLANGUAGE: F#\nCODE:\n```\naref <! message\nasync { let! response = aref <? request }\n```\n\n----------------------------------------\n\nTITLE: Implementing LeaseTimeoutException Class in C#\nDESCRIPTION: Specialized exception class for lease timeout scenarios. Extends LeaseException with specific timeout error handling functionality and serialization support.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.Core.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class LeaseTimeoutException : Akka.Coordination.LeaseException\n{\n    public LeaseTimeoutException(string message) { }\n    public LeaseTimeoutException(string message, System.Exception innerEx) { }\n    protected LeaseTimeoutException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: RandomPool Class in Akka.NET Routing\nDESCRIPTION: Implements a pool router with random selection strategy. It creates and manages a pool of routee actors and routes messages randomly among them with support for resizing and custom supervision.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_184\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class RandomPool : Akka.Routing.Pool\n{\n    public RandomPool(Akka.Configuration.Config config) { }\n    public RandomPool(int nrOfInstances) { }\n    public RandomPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False) { }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Routing.RandomPool WithDispatcher(string dispatcher) { }\n    public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n    public Akka.Routing.RandomPool WithResizer(Akka.Routing.Resizer resizer) { }\n    public Akka.Routing.RandomPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }\n    public class RandomPoolSurrogate : Akka.Util.ISurrogate\n    {\n        public RandomPoolSurrogate() { }\n        public int NrOfInstances { get; set; }\n        public Akka.Routing.Resizer Resizer { get; set; }\n        public string RouterDispatcher { get; set; }\n        public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }\n        public bool UsePoolDispatcher { get; set; }\n        public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IReplicatedDataSerialization Marker Interface in C#\nDESCRIPTION: Defines an empty marker interface used to identify types that can be serialized as replicated data in the distributed data system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IReplicatedDataSerialization { }\n```\n\n----------------------------------------\n\nTITLE: Markdown Documentation Header\nDESCRIPTION: Header and description for debugging examples section of the Akka.NET test suite documentation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.Docs.Tests/Debugging/README.md#2025-04-16_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Debugging Examples\n\nThis section of tests includes some non-functional, skipped tests as examples of how to rewrite racy or otherwise buggy unit tests in the Akka.NET test suite.\n```\n\n----------------------------------------\n\nTITLE: Incorrect Timer Registration in PreRestart Method\nDESCRIPTION: An example of incorrect usage where a timer is registered in the PreRestart method. This timer will never be fired because timers are cleared during restart before this registration takes effect.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK1007.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing Akka.Actor;\n\npublic sealed class MyActor : ReceiveActor, IWithTimers\n{\n    private sealed class TimerKey\n    {\n        public static readonly TimerKey Instance = new();\n        private TimerKey() { }\n    }\n    \n    private sealed class TimerMessage\n    {\n        public static readonly TimerMessage Instance = new();\n        private TimerMessage() { }\n    }\n\n    public MyActor()\n    {\n        Receive<TimerMessage>(_ =>\n        {\n            // Timer callback code will never be executed\n        });\n    }\n    \n    public ITimerScheduler Timers { get; set; }\n    \n    protected override void PreRestart(Exception reason, object message)\n    {\n        base.PreRestart(reason, message);\n        \n        // This timer will never be fired\n        Timers.StartSingleTimer(\n            key: TimerKey.Instance, \n            msg: TimerMessage.Instance, \n            timeout: TimeSpan.FromSeconds(3));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Problematic Third-Party API Implementation in C#\nDESCRIPTION: Example of a third-party API implementation that breaks asynchronous context by using ConfigureAwait(false), which will cause issues when used with Akka.NET actors.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK1005.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing System.Threading.Tasks;\n\nnamespace ThirdPartyApi;\n\npublic sealed class JobManager\n{\n    public async Task SubmitJobAsync(string job, Func<Task> asyncCallback)\n    {\n        // This breaks asynchronous context\n        await ConnectToServer().ConfigureAwait(false); \n        // other codes here\n        \n        await asyncCallback();\n    }\n    \n    private async Task ConnectToServer()\n    {\n        // codes here\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Assembly Metadata for Akka.NET Remote Module in C#\nDESCRIPTION: Sets assembly metadata attributes for the Akka.NET Remote module, including repository URL, internal visibility, and target framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Benchmarks\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Metrics\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.TestKit\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Tests.MultiNode\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Tools\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Remote.TestKit\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Remote.TestKit.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Remote.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Remote.Tests.MultiNode\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Remote.Tests.Performance\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"78986bdb-73f7-4532-8e03-1c9ccbe8148e\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Starting Docker Container for Akka.NET Cluster Sharding\nDESCRIPTION: PowerShell command to execute the start script that builds and launches the Docker container using docker-compose for the cluster sharding example.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/examples/Cluster/ClusterSharding/ClusterSharding.Node/README.md#2025-04-16_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\nPS> ./start.cmd\n```\n\n----------------------------------------\n\nTITLE: Implementing VectorClock Node in C#\nDESCRIPTION: Defines a Node class within the VectorClock structure, implementing IComparable<Node>. It includes methods for creation, comparison, and string representation of nodes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class Node : System.IComparable<Akka.Cluster.VectorClock.Node>\n{\n    public Node(string value) { }\n    public int CompareTo(Akka.Cluster.VectorClock.Node other) { }\n    public static Akka.Cluster.VectorClock.Node Create(string name) { }\n    public override bool Equals(object obj) { }\n    public static Akka.Cluster.VectorClock.Node FromHash(string hash) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly Metadata Configuration in C#\nDESCRIPTION: Configures assembly-level metadata for Akka.NET project, including repository URL, internal visibility attributes, and target framework settings\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.DotNet.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Benchmarks\")]\n```\n\n----------------------------------------\n\nTITLE: Accessing Akka.NET Nightly Symbols URL\nDESCRIPTION: The URL for accessing debug symbols for Akka.NET nightly packages. This can be configured in Visual Studio or JetBrains Rider for debugging support.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/getting-access-to-nightly-builds.md#2025-04-16_snippet_1\n\nLANGUAGE: url\nCODE:\n```\nhttps://f.feedz.io/akkadotnet/akka/symbols\n```\n\n----------------------------------------\n\nTITLE: RecoverWithRetries Output Example\nDESCRIPTION: Shows the console output from the RecoverWithRetries example, displaying the original sequence followed by the backup sequence.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/error-handling.md#2025-04-16_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n0\n1\n2\n3\n4\nfive\nsix\nseven\neight\n```\n\n----------------------------------------\n\nTITLE: AsyncHandlerInvocation Class Definition in Akka.Persistence\nDESCRIPTION: Definition of AsyncHandlerInvocation class that implements IPendingHandlerInvocation interface, providing a way to handle persistence events asynchronously.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class AsyncHandlerInvocation : Akka.Persistence.IPendingHandlerInvocation\n{\n    public AsyncHandlerInvocation(object evt, System.Action<object> handler) { }\n    public object Event { get; }\n    public System.Action<object> Handler { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Node Metrics in C# for Akka.NET\nDESCRIPTION: This method updates an existing NodeMetrics object. The implementation details are not provided in the snippet.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Net.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic Akka.Cluster.Metrics.Serialization.NodeMetrics Update(Akka.Cluster.Metrics.Serialization.NodeMetrics that) { }\n```\n\n----------------------------------------\n\nTITLE: Defining ShardState for Entity Tracking in Shards in C#\nDESCRIPTION: Describes \"ShardState\", capturing the state of shard entities with their IDs. Helps in maintaining consistent shard states across the distributed system using immutable collections for tracking entity identifiers.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.Core.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ShardState : Akka.Cluster.Sharding.IClusterShardingSerializable, System.IEquatable<Akka.Cluster.Sharding.ShardState> {\n        public readonly System.Collections.Immutable.IImmutableSet<string> EntityIds;\n        public readonly string ShardId;\n        public ShardState(string shardId, System.Collections.Immutable.IImmutableSet<string> entityIds) { }\n        public override bool Equals(object obj) { }\n        public bool Equals(Akka.Cluster.Sharding.ShardState other) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Deprecated Resolution for PipeTo Usage in C#\nDESCRIPTION: This code snippet shows the previously recommended approach to use `PipeTo` by closing over `Context.Sender`. However, this resolution is no longer necessary.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK1001.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Actor;\nusing System.Threading.Tasks;\nusing System;\n\npublic sealed class MyActor : UntypedActor{\n\n    protected override void OnReceive(object message){\n        async Task<int> LocalFunction(){\n            await Task.Delay(10);\n            return message.ToString().Length;\n        }\n\n        var sender = Sender;\n        LocalFunction().PipeTo(sender); \n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Network Test Transport in C#\nDESCRIPTION: Example of enabling TestTransport in a multi-node configuration to simulate network conditions like partitions and latency.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/testing/multi-node-testing-old.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class SurviveNetworkInstabilitySpecConfig : MultiNodeConfig\n{\n    public SurviveNetworkInstabilitySpecConfig()\n    {\n        TestTransport = true;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ReplaySuccess Class in C# for Akka.NET Persistence\nDESCRIPTION: This class represents a successful replay operation in Akka.NET persistence, containing the highest sequence number reached during the replay.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ReplaySuccess : System.IEquatable<Akka.Persistence.Journal.AsyncWriteTarget.ReplaySuccess>\n{\n    public ReplaySuccess(long highestSequenceNr) { }\n    public long HighestSequenceNr { get; }\n    public bool Equals(Akka.Persistence.Journal.AsyncWriteTarget.ReplaySuccess other) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Send Message Class for Akka Distributed PubSub in C#\nDESCRIPTION: Defines a sealed Send message class used to route a message to a specific path in Akka's distributed publish-subscribe system. Supports local affinity option and implements necessary interfaces for wrapped messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class Send : Akka.Actor.IWrappedMessage, Akka.Cluster.Tools.PublishSubscribe.IDistributedPubSubMessage, System.IEquatable<Akka.Cluster.Tools.PublishSubscribe.Send>\n{\n    public Send(string path, object message, bool localAffinity = False) { }\n    public bool LocalAffinity { get; }\n    public object Message { get; }\n    public string Path { get; }\n    public bool Equals(Akka.Cluster.Tools.PublishSubscribe.Send other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining UnconfirmedWarning Class in Akka.NET\nDESCRIPTION: The UnconfirmedWarning class represents a warning about unconfirmed message deliveries. It contains an array of UnconfirmedDelivery objects.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class UnconfirmedWarning : System.IEquatable<Akka.Persistence.UnconfirmedWarning>\n{\n    public UnconfirmedWarning(Akka.Persistence.UnconfirmedDelivery[] unconfirmedDeliveries) { }\n    public Akka.Persistence.UnconfirmedDelivery[] UnconfirmedDeliveries { get; }\n    public bool Equals(Akka.Persistence.UnconfirmedWarning other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Contact Point Management Classes in C#\nDESCRIPTION: Classes for managing contact points in the cluster, including notifications for point addition and removal, and a container for holding contact point collections.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Core.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ContactPointAdded : Akka.Cluster.Tools.Client.IContactPointChange\n{\n    public ContactPointAdded(Akka.Actor.ActorPath contactPoint) { }\n    public Akka.Actor.ActorPath ContactPoint { get; }\n}\n\npublic sealed class ContactPointRemoved : Akka.Cluster.Tools.Client.IContactPointChange\n{\n    public ContactPointRemoved(Akka.Actor.ActorPath contactPoint) { }\n    public Akka.Actor.ActorPath ContactPoint { get; }\n}\n\npublic sealed class ContactPoints\n{\n    public ContactPoints(System.Collections.Immutable.IImmutableSet<Akka.Actor.ActorPath> contactPoints) { }\n    public System.Collections.Immutable.IImmutableSet<Akka.Actor.ActorPath> ContactPointsList { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Markdown Link using xref\nDESCRIPTION: This Markdown snippet demonstrates how to create links between documents using the `xref` format. This ensures links remain valid even if the documentation structure changes. The `xref` target should match the `uid` of the target document.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/documentation-guidelines.md#2025-04-16_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n[`Akka.Cluster.Tools.ClusterClient` documentation](xref:cluster-client)\n```\n\n----------------------------------------\n\nTITLE: Implementing Static Type Cache in C#\nDESCRIPTION: A static utility class that provides caching functionality for type lookups. The GetType method retrieves a System.Type object based on a type name string, likely implementing caching to improve performance.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_250\n\nLANGUAGE: csharp\nCODE:\n```\n    public class static TypeCache\n    {\n        public static System.Type GetType(string typeName) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Assembly Metadata for Akka.NET Cluster\nDESCRIPTION: Configures assembly-level attributes including repository URL, internal visibility, and target framework\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Benchmarks\")]\n```\n\n----------------------------------------\n\nTITLE: Recommended Pattern: Using PersistAll() After a Loop in Akka.NET\nDESCRIPTION: This code demonstrates the recommended approach where events are collected in a collection inside the loop, then persisted in a single batch using PersistAll() after the loop completes. This improves performance by batching database operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK1006.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Persistence;\n\npublic class MyActor: ReceivePersistentActor\n{\n    public override string PersistenceId { get; }\n    public MyActor(string persistenceId)\n    {\n        PersistenceId = persistenceId;\n        CommandAny(obj =>\n        {\n            var events = new List<int>();\n            for (var i=0; i<10; i++)\n            {\n                events.Add(i);\n            }\n            PersistAll(events, o => {});\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IReadConsistency Interface in C#\nDESCRIPTION: This snippet defines the `IReadConsistency` interface, specifying that implementing classes should provide a `Timeout` property. This interface likely represents a configuration for read operations in a distributed data system, ensuring that reads are performed with a certain level of consistency within the specified timeout period.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n    public interface IReadConsistency\n    {\n        System.TimeSpan Timeout { get; }\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Assembly Metadata and Visibility Attributes in C#\nDESCRIPTION: Assembly-level attributes defining metadata, cross-assembly visibility, COM interoperability settings, and target framework information for the Akka.Cluster.Tools library.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Tools.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Tools.Tests.MultiNode\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"5cf8a8be-b634-473f-bb01-eba878746bd4\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Abstract Remote Transport Class in C#\nDESCRIPTION: Base class for implementing remote transport functionality in Akka.NET. Handles message sending, address management, and system lifecycle operations across the network.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.DotNet.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class RemoteTransport {\n    protected RemoteTransport(Akka.Actor.ExtendedActorSystem system, Akka.Remote.RemoteActorRefProvider provider) { }\n    public abstract System.Collections.Generic.ISet<Akka.Actor.Address> Addresses { get; }\n    // ... additional members omitted for brevity\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SQL Journal Query Parameters in C#\nDESCRIPTION: Constructor for QueryConfiguration class that sets up SQL journal table and column names, timeouts, and serialization settings. Includes parameters for schema, table names, column identifiers and isolation levels.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.DotNet.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic QueryConfiguration(string schemaName, string journalEventsTableName, string metaTableName, string persistenceIdColumnName, string sequenceNrColumnName, string payloadColumnName, string manifestColumnName, string timestampColumnName, string isDeletedColumnName, string tagsColumnName, string orderingColumnName, string serializerIdColumnName, System.TimeSpan timeout, string defaultSerializer, bool useSequentialAccess, System.Nullable<System.Data.IsolationLevel> readIsolationLevel, System.Nullable<System.Data.IsolationLevel> writeIsolationLevel) { }\n```\n\n----------------------------------------\n\nTITLE: Markdown Structure for Akka.NET Documentation\nDESCRIPTION: Markdown formatted structure providing links to various Akka.NET module documentation pages and instructions for requesting additional documentation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/api/index.md#2025-04-16_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Akka.NET API Documentation\n\nFull API reference documentation on Akka.NET's modules, classes, and APIs.\n\n## Popular Modules\n\n* [Akka API Docs](Akka.Actor.yml)\n* [Akka.TestKit API Docs](Akka.TestKit.yml)\n* [Akka.Remote API Docs](Akka.Remote.yml)\n* [Akka.Persistence API Docs](Akka.Persistence.yml)\n* [Akka.Streams API Docs](Akka.Streams.yml)\n* [Akka.Cluster API Docs](Akka.Cluster.yml)\n* [Akka.Cluster.Sharding API Docs](Akka.Cluster.Sharding.yml)\n* [Akka.DependencyInjection API Docs](Akka.DependencyInjection.yml)\n* [Akka.Discovery API Docs](Akka.Discovery.yml)\n\nClicking through on any of those links will expose you to the full Akka.NET API documentation sidebar.\n\n### Missing Something?\n\nAre we missing documentation that you need in order to use Akka.NET properly? [Submit a \"Documentation Improvement\" issue here](https://github.com/akkadotnet/akka.net/issues/new?assignees=&labels=docs&template=doc_improvement.md&title=).\n```\n\n----------------------------------------\n\nTITLE: Single Event Sequence Implementation in C#\nDESCRIPTION: Structure implementing IEventSequence for handling single event persistence operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\npublic struct SingleEventSequence : Akka.Persistence.Journal.IEventSequence, System.IEquatable<Akka.Persistence.Journal.IEventSequence>\n{\n    public SingleEventSequence(object e) { }\n    public System.Collections.Generic.IEnumerable<object> Events { get; }\n    public bool Equals(Akka.Persistence.Journal.IEventSequence other) { }\n    public override bool Equals(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Cluster Info Logging Configuration\nDESCRIPTION: HOCON configuration options for controlling cluster event logging levels.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-configuration.md#2025-04-16_snippet_1\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster.log-info = off\n```\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster.log-info-verbose = on\n```\n\n----------------------------------------\n\nTITLE: Multi-Node Test Runner Command Line Usage\nDESCRIPTION: This snippet demonstrates the command line syntax for running multi-node tests with the Akka.MultiNodeTestRunner, including options for specifying output directories and test specs.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/testing/multi-node-testing-old.md#2025-04-16_snippet_9\n\nLANGUAGE: console\nCODE:\n```\nAkka.MultiNodeTestRunner.exe [path to assembly] [-Dmultinode.enable-filesink=on] [-Dmultinode.output-directory={dir path}] [-Dmultinode.spec={spec name}]\n```\n\n----------------------------------------\n\nTITLE: Configuring StreamRef Subscription Timeout in C#\nDESCRIPTION: This code shows how to configure the subscription timeout for StreamRefs using attributes. It demonstrates setting the timeout for both SourceRef and SinkRef.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/streamrefs.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nSource.Repeat(\"hello\")\n    .RunWith(StreamRefs.SourceRef<string>()\n        .AddAttributes(StreamRefAttributes\n            .SubscriptionTimeout(TimeSpan.FromSeconds(5)))\n    , materializer);\n\nStreamRefs.SinkRef<string>()\n    .AddAttributes(StreamRefAttributes\n        .SubscriptionTimeout(TimeSpan.FromSeconds(5)))\n    .RunWith(Sink.Ignore<string>(), materializer);\n```\n\n----------------------------------------\n\nTITLE: Defining StandardMetrics for Cluster Resource Metrics in C#\nDESCRIPTION: This static class provides constants and methods for extracting standardized metrics from node metrics data. It includes CPU and memory metrics definitions with utility methods to extract and process these metrics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Net.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class static StandardMetrics\n{\n    public const string CpuProcessUsage = \"CpuProcessUsage\";\n    public const string CpuTotalUsage = \"CpuTotalUsage\";\n    public const string MaxMemoryRecommended = \"MaxMemoryRecommended\";\n    public const string MemoryAvailable = \"MemoryAvailable\";\n    public const string MemoryUsed = \"MemoryUsed\";\n    public const string Processors = \"Processors\";\n    public static Akka.Util.Option<Akka.Cluster.Metrics.StandardMetrics.Cpu> ExtractCpu(Akka.Cluster.Metrics.Serialization.NodeMetrics nodeMetrics) { }\n    public static Akka.Util.Option<Akka.Cluster.Metrics.StandardMetrics.Memory> ExtractMemory(Akka.Cluster.Metrics.Serialization.NodeMetrics nodeMetrics) { }\n    public sealed class Cpu\n    {\n        public Cpu(Akka.Actor.Address address, long timestamp, double cpuProcessUsage, double cpuTotalUsage, int processorsNumber) { }\n        public Akka.Actor.Address Address { get; }\n        public double ProcessUsage { get; }\n        public int ProcessorsNumber { get; }\n        public long Timestamp { get; }\n        public double TotalUsage { get; }\n        [return: System.Runtime.CompilerServices.TupleElementNamesAttribute(new string[] {\n                \"Address\",\n                \"Timestamp\",\n                \"CpuProcessUsage\",\n                \"CpuTotalUsage\",\n                \"Processors\"})]\n        public static Akka.Util.Option<System.ValueTuple<Akka.Actor.Address, long, double, double, int>> Decompose(Akka.Cluster.Metrics.Serialization.NodeMetrics nodeMetrics) { }\n    }\n    public sealed class Memory\n    {\n        public Memory(Akka.Actor.Address address, long timestamp, double used, double available, Akka.Util.Option<double> max) { }\n        public Akka.Actor.Address Address { get; }\n        public double Available { get; }\n        public Akka.Util.Option<double> MaxRecommended { get; }\n        public long Timestamp { get; }\n        public double Used { get; }\n        [return: System.Runtime.CompilerServices.TupleElementNamesAttribute(new string[] {\n                \"Address\",\n                \"Timestamp\",\n                \"UsedSmoothValue\",\n                \"AvailableSmoothValue\",\n                \"MaxRecommendedSmoothValue\"})]\n        public static Akka.Util.Option<System.ValueTuple<Akka.Actor.Address, long, double, double, Akka.Util.Option<double>>> Decompose(Akka.Cluster.Metrics.Serialization.NodeMetrics nodeMetrics) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Persistence to Counter Actor Commands\nDESCRIPTION: Enhanced implementation of OnCommand method to persist state changes after operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistence-testing.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nprotected override void OnCommand(object message)\n{\n    switch (message as string)\n    {\n        case \"inc\":\n            value++;\n            Persist(message, _ => { });\n            break;\n\n        case \"dec\":\n            value++;\n            Persist(message, _ => { });\n            break;\n\n        case \"read\":\n            Sender.Tell(value, Self);\n            break;\n        \n        default:\n            return;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ConnectException for Handling Network Connection Errors in Akka.NET\nDESCRIPTION: Defines a specialized exception class for connection-related errors in the Akka.IO module. This class is marked as internal API and extends System.Exception to represent connection failures.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_154\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\n    public class ConnectException : System.Exception\n    {\n        public ConnectException(string message) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Displaying Performance Benchmark Results for Akka.NET v1.4.25\nDESCRIPTION: Shows the performance benchmark results for Akka.NET v1.4.25, including system information and message throughput metrics for different numbers of clients.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/RELEASE_NOTES.md#2025-04-16_snippet_10\n\nLANGUAGE: plaintext\nCODE:\n```\nOSVersion:                         Microsoft Windows NT 6.2.9200.0\nProcessorCount:                    16\nClockSpeed:                        0 MHZ\nActor Count:                       32\nMessages sent/received per client: 200000  (2e5)\nIs Server GC:                      True\nThread count:                      111\n\nNum clients, Total [msg], Msgs/sec, Total [ms]\n         1,  200000,    130634,    1531.54\n         5, 1000000,    246975,    4049.20\n        10, 2000000,    244499,    8180.16\n        15, 3000000,    244978,   12246.39\n        20, 4000000,    245159,   16316.37\n        25, 5000000,    243333,   20548.09\n        30, 6000000,    241644,   24830.55\n```\n\n----------------------------------------\n\nTITLE: Constructor Pattern Matching with Property Pattern in C# 8\nDESCRIPTION: This C# 8 code demonstrates pattern matching using a switch expression and property patterns. It checks the type and properties of the input 'x' in a concise manner. It returns a string based on the matched case. Relies on `Person` and `Dog` classes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/porting-guide.md#2025-04-16_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\npublic static string TestPattern(object x) => x switch\n{\n    Person { FirstName: \"Alexander\" } p =>  $\"found an Alexander, first name = {p.FirstName}\",\n    Dog { Name: \"Suka\" } d => \"found a dog named Suka\",\n    _ => string.Empty\n};\n```\n\n----------------------------------------\n\nTITLE: DeleteSuccess Response Class for Successful Deletions\nDESCRIPTION: Response class indicating successful deletion of data from the distributed store. It provides properties to check the status of the deletion operation and access the associated key and request.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DeleteSuccess : Akka.Actor.INoSerializationVerificationNeeded, Akka.DistributedData.IDeleteResponse, System.IEquatable<Akka.DistributedData.DeleteSuccess>\n{\n    public DeleteSuccess(Akka.DistributedData.IKey key, object request = null) { }\n    public bool AlreadyDeleted { get; }\n    public bool IsSuccessful { get; }\n    public Akka.DistributedData.IKey Key { get; }\n    public object Request { get; }\n    public bool Equals(Akka.DistributedData.DeleteSuccess other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DiscardToDeadLetterStrategy in C#\nDESCRIPTION: Defines a singleton implementation of the discard to dead letter strategy for managing overflow in Akka Persistence's stash. This static instance can be used to maintain consistent behavior on message overflow.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DiscardToDeadLetterStrategy : Akka.Persistence.IStashOverflowStrategy\n{\n    public static Akka.Persistence.DiscardToDeadLetterStrategy Instance { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: ToString Override\nDESCRIPTION: This snippet defines an overridden `ToString` method within a class.  The purpose is to provide a string representation of the object, likely for debugging or logging purposes. Without an implementation, it would return an empty string.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic override string ToString() { }\n```\n\n----------------------------------------\n\nTITLE: Custom Interceptor Test Example\nDESCRIPTION: Example showing how to use a custom interceptor in persistence tests.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistence-testing.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n[Fact]\n    public async Task Custom_interceptor_example()\n    {\n        WithJournalWrite(write => write.SetInterceptorAsync(new myCustomInterceptor()), () =>\n        {\n            //test code here\n            \n        });\n    }\n```\n\n----------------------------------------\n\nTITLE: Assembly Metadata Declaration in C#\nDESCRIPTION: Declares assembly metadata including repository URL and target framework (.NET Standard 2.0) for the Akka.Cluster.Metrics library.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Installing Akka.DistributedData via NuGet\nDESCRIPTION: Shows how to install the Akka.DistributedData plugin using the NuGet package manager console.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/distributed-data.md#2025-04-16_snippet_0\n\nLANGUAGE: console\nCODE:\n```\ninstall-package Akka.DistributedData\n```\n\n----------------------------------------\n\nTITLE: Defining Assembly Attributes for Akka.NET Persistence Query\nDESCRIPTION: Sets assembly-level attributes for the Akka.NET Persistence Query library, including repository URL, COM visibility, GUID, and target framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceQuery.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"92ab2788-e008-40d0-8b54-0c95b3cf3404\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: InMemoryReadJournalProvider Class Implementation\nDESCRIPTION: Implements the IReadJournalProvider interface to provide factory methods for creating InMemoryReadJournal instances.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceInMemoryQuery.Net.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class InMemoryReadJournalProvider : Akka.Persistence.Query.IReadJournalProvider\n{\n    public InMemoryReadJournalProvider(Akka.Actor.ExtendedActorSystem system, Akka.Configuration.Config config) { }\n    public Akka.Persistence.Query.IReadJournal GetReadJournal() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Actor-related Exception Classes in C#\nDESCRIPTION: Implements various exception classes specific to the Akka.NET actor system, such as ActorInitializationException, ActorInterruptedException, and ActorKilledException.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic class ActorInitializationException : Akka.Actor.AkkaException\n{\n    public ActorInitializationException() { }\n    public ActorInitializationException(string message) { }\n    public ActorInitializationException(string message, System.Exception cause) { }\n    public ActorInitializationException(Akka.Actor.IActorRef actor, string message, System.Exception cause = null) { }\n    protected ActorInitializationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n    public Akka.Actor.IActorRef Actor { get; set; }\n    public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n    public override string ToString() { }\n}\n\npublic class ActorInterruptedException : Akka.Actor.AkkaException\n{\n    public ActorInterruptedException(string message = null, System.Exception cause = null) { }\n    protected ActorInterruptedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n\npublic class ActorKilledException : Akka.Actor.AkkaException\n{\n    public ActorKilledException() { }\n    public ActorKilledException(string message) { }\n    protected ActorKilledException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Null Blocking Object Merging in HOCON\nDESCRIPTION: Illustrates how a null value blocks the merge operation for an object. When a key is set to null, it prevents merging with previous values of the same key.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/hocon.md#2025-04-16_snippet_1\n\nLANGUAGE: hocon\nCODE:\n```\n{\n    \"foo\" : { \"a\" : 42 },\n    \"foo\" : null,\n    \"foo\" : { \"b\" : 43 }\n}\n```\n\n----------------------------------------\n\nTITLE: Disassociate Method for Test Associations (C#)\nDESCRIPTION: Method to terminate a test association handle connection.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\npublic System.Threading.Tasks.Task Disassociate(Akka.Remote.Transport.TestAssociationHandle handle) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract Snapshot Store Methods in C#\nDESCRIPTION: Abstract methods for loading and saving snapshots in a custom snapshot store implementation. These methods need to be overridden in concrete implementations to provide specific snapshot storage functionality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\nprotected override System.Threading.Tasks.Task<Akka.Persistence.SelectedSnapshot> LoadAsync(string persistenceId, Akka.Persistence.SnapshotSelectionCriteria criteria) { }\nprotected override System.Threading.Tasks.Task SaveAsync(Akka.Persistence.SnapshotMetadata metadata, object snapshot) { }\n```\n\n----------------------------------------\n\nTITLE: Changed Class Definition in Akka.NET\nDESCRIPTION: Sealed class representing change notifications in distributed data, implementing IReplicatorMessage interface with key and data properties.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Changed : Akka.DistributedData.IReplicatorMessage, System.IEquatable<Akka.DistributedData.Changed>\n{\n    public Changed(Akka.DistributedData.IKey key, object data) { }\n    public object Data { get; }\n    public Akka.DistributedData.IKey Key { get; }\n    public bool Equals(Akka.DistributedData.Changed other) { }\n    public override bool Equals(object obj) { }\n    public T Get<T>(Akka.DistributedData.IKey<T> key)\n        where T : Akka.DistributedData.IReplicatedData { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MaxUnconfirmedMessagesExceededException Class in Akka.NET\nDESCRIPTION: This code defines the `MaxUnconfirmedMessagesExceededException` class, which represents an exception thrown when the maximum number of unconfirmed messages is exceeded. It inherits from `System.Exception` and provides constructors for different initialization scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MaxUnconfirmedMessagesExceededException : System.Exception\n{\n    public MaxUnconfirmedMessagesExceededException() { }\n    public MaxUnconfirmedMessagesExceededException(string message) { }\n    public MaxUnconfirmedMessagesExceededException(string message, System.Exception innerException) { }\n    protected MaxUnconfirmedMessagesExceededException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: ClusterScope Class Definition\nDESCRIPTION: This snippet defines a class `ClusterScope` that inherits from `Akka.Actor.Scope`. It represents a deployment scope for actors within a cluster. It includes a static readonly instance and overrides `Copy` and `WithFallback`.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ClusterScope : Akka.Actor.Scope\n{\n    public static readonly Akka.Cluster.ClusterScope Instance;\n    public override Akka.Actor.Scope Copy() { }\n    public override Akka.Actor.Scope WithFallback(Akka.Actor.Scope other) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LogFilterType Enumeration in C#\nDESCRIPTION: An enumeration that categorizes log filters into Source filters (which filter based on log source) and Content filters (which filter based on message content).\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_139\n\nLANGUAGE: C#\nCODE:\n```\npublic enum LogFilterType\n{\n    Source = 0,\n    Content = 1,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IReplicatorMessage Interface in C#\nDESCRIPTION: This snippet defines the `IReplicatorMessage` interface, which likely serves as a marker interface for messages used by the replicator actor.  It doesn't declare any methods or properties.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\n    public interface IReplicatorMessage { }\n\n```\n\n----------------------------------------\n\nTITLE: Markdown Linting Execution\nDESCRIPTION: This command executes the `markdownlint` tool to validate Markdown files in the `docs` directory and its subdirectories.  It enforces formatting rules, headline capitalization, and other details as configured by the Akka.NET project.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/documentation-guidelines.md#2025-04-16_snippet_10\n\nLANGUAGE: console\nCODE:\n```\nmarkdownlint \"docs/**/*.md\"\n```\n\n----------------------------------------\n\nTITLE: Error Escalation System Message in Akka.NET\nDESCRIPTION: System message for escalating errors to a parent actor. Contains the exception to be escalated up the actor hierarchy for handling by a supervisor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_96\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class Escalate : Akka.Dispatch.SysMsg.SystemMessage\n{\n    public Escalate(System.Exception reason) { }\n    public System.Exception Reason { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Actor Resume System Message in Akka.NET\nDESCRIPTION: System message for resuming an actor after suspension. Contains the exception that caused the failure leading to this resume operation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_102\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class Resume : Akka.Dispatch.SysMsg.SystemMessage\n{\n    public Resume(System.Exception causedByFailure) { }\n    public System.Exception CausedByFailure { get; set; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly Metadata Configuration in C#\nDESCRIPTION: Defines assembly-level metadata and internal visibility configurations for Akka.NET cluster components. Includes repository URL, InternalsVisibleTo attributes for testing and related modules.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Benchmarks\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Metrics\")]\n```\n\n----------------------------------------\n\nTITLE: Defining Assembly Attributes for Akka.NET Cluster Tools\nDESCRIPTION: These assembly attributes define metadata, visibility, and compatibility information for the Akka.NET Cluster Tools library. They specify repository information, internal visibility to test projects, COM interoperability settings, and target framework information.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Tools.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Tools.Tests.MultiNode\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"5cf8a8be-b634-473f-bb01-eba878746bd4\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETCoreApp,Version=v6.0\", FrameworkDisplayName=\".NET 6.0\")]\n```\n\n----------------------------------------\n\nTITLE: Implementing CountSubscribers Message Class for Akka Distributed PubSub in C#\nDESCRIPTION: Defines a sealed CountSubscribers message class used to query the number of subscribers for a specific topic in Akka's distributed publish-subscribe internal API. Marked with ApiMayChange attribute.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\n[Akka.Annotations.ApiMayChangeAttribute()]\npublic sealed class CountSubscribers\n{\n    public CountSubscribers(string topic) { }\n    public string Topic { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating BroadcastGroup Router in C# Code\nDESCRIPTION: Shows how to create a broadcast group router directly in C# code by specifying the actor paths of existing routees.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nvar actors = new [] { \"/user/a1\", \"/user/a2\", \"/user/a3\" }\nvar router = system.ActorOf(Props.Empty.WithRouter(new BroadcastGroup(actors)), \"some-group\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Query Configuration Class in C#\nDESCRIPTION: Configuration class for SQL snapshot queries containing database schema details, column names, and timing parameters.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Core.verified.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic class QueryConfiguration\n{\n    [System.ObsoleteAttribute(\"This property should never be used for writes, use the default `System.Object` serializer instead\")]\n    public readonly string DefaultSerializer;\n    public readonly string ManifestColumnName;\n    public readonly string PayloadColumnName;\n    public readonly string PersistenceIdColumnName;\n    public readonly string SchemaName;\n    public readonly string SequenceNrColumnName;\n    public readonly string SerializerIdColumnName;\n    public readonly string SnapshotTableName;\n    public readonly System.TimeSpan Timeout;\n    public readonly string TimestampColumnName;\n    public QueryConfiguration(string schemaName, string snapshotTableName, string persistenceIdColumnName, string sequenceNrColumnName, string payloadColumnName, string manifestColumnName, string timestampColumnName, string serializerIdColumnName, System.TimeSpan timeout, string defaultSerializer, bool useSequentialAccess) { }\n    public string FullSnapshotTableName { get; }\n    public bool UseSequentialAccess { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Message Handling Delegate in Akka.NET (C#)\nDESCRIPTION: Delegate definition for handling messages in Akka.NET actors. Returns a boolean indicating whether the message was successfully handled.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\npublic delegate bool Receive(object message);\n```\n\n----------------------------------------\n\nTITLE: ClusterShardingExtensionProvider Class Definition in C#\nDESCRIPTION: Provides a way to create and access the ClusterSharding extension in an Akka.NET actor system. Implements ExtensionIdProvider for the ClusterSharding extension.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterShardingExtensionProvider : Akka.Actor.ExtensionIdProvider<Akka.Cluster.Sharding.ClusterSharding>\n{\n    public ClusterShardingExtensionProvider() { }\n    public override Akka.Cluster.Sharding.ClusterSharding CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Cluster Metrics Events in C#\nDESCRIPTION: Definition of events related to cluster metrics changes. Includes the ClusterMetricsChanged event that is published when node metrics are updated, and the IClusterMetricsEvent interface for event type identification.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.DotNet.verified.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterMetricsChanged : Akka.Cluster.Metrics.Events.IClusterMetricsEvent\n{\n    public ClusterMetricsChanged(System.Collections.Immutable.IImmutableSet<Akka.Cluster.Metrics.Serialization.NodeMetrics> nodeMetrics) { }\n    public System.Collections.Immutable.IImmutableSet<Akka.Cluster.Metrics.Serialization.NodeMetrics> NodeMetrics { get; }\n}\npublic interface IClusterMetricsEvent { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ILoggingAdapter Info Extension Methods in C#\nDESCRIPTION: Extension methods for ILoggingAdapter providing various overloads of Info logging with generic type parameters. Supports logging with different numbers of arguments and optional exception causes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_149\n\nLANGUAGE: csharp\nCODE:\n```\npublic static void Info<T1, T2, T3, T4, T5>(this Akka.Event.ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) { }\npublic static void Info<T1, T2, T3, T4, T5>(this Akka.Event.ILoggingAdapter log, System.Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) { }\n```\n\n----------------------------------------\n\nTITLE: Protobuf Definitions for Heartbeat Messages\nDESCRIPTION: Protocol Buffer message definitions for Heartbeat and HeartbeatResponse messages, including both legacy and new formats with additional timing data.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/wire-compatibility.md#2025-04-16_snippet_1\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage Heartbeat {\n  Akka.Remote.Serialization.Proto.Msg.AddressData from = 1;\n  int64 sequenceNr = 2;\n  sint64 creationTime = 3;\n}\n\nmessage HeartBeatResponse {\n  UniqueAddress from = 1;\n  int64 sequenceNr = 2;\n  int64 creationTime = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Multi-Node Test Runner Behavior in Akka.NET\nDESCRIPTION: JSON configuration for customizing the behavior of the Multi-Node Test Runner (MNTR). The configuration controls output directories, network listening settings, and whether to clear previous test output.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/testing/multi-node-testing.md#2025-04-16_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"outputDirectory\": \"TestResults\",\n  \"failedSpecsDirectory\": \"FAILED_SPECS_LOGS\",\n  \"listenAddress\": \"127.0.0.1\",\n  \"listenPort\":  0,\n  \"clearOutputDirectory\": false\n}\n```\n\n----------------------------------------\n\nTITLE: Intercept Exception in Scala\nDESCRIPTION: This Scala code uses `intercept` to assert that a specific exception is thrown when a certain code block is executed. It checks for `IllegalArgumentException` when calling `serializer.manifest` with an invalid argument.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/porting-guide.md#2025-04-16_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\nintercept[IllegalArgumentException] {\n  val serializer = new MiscMessageSerializer(system.asInstanceOf[ExtendedActorSystem])\n  serializer.manifest(\"INVALID\")\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LeastShardAllocationStrategy Class in Akka.NET Sharding\nDESCRIPTION: This class implements a shard allocation strategy that attempts to allocate shards to the node with the least number of shards. It is an obsolete class in favor of ShardAllocationStrategy.LeastShardAllocationStrategy.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\n    [System.ObsoleteAttribute(\"Use ShardAllocationStrategy.LeastShardAllocationStrategy instead. This will be re\" +\n        \"moved in v1.6.\")]\n    public class LeastShardAllocationStrategy : Akka.Cluster.Sharding.Internal.AbstractLeastShardAllocationStrategy\n    {\n        public LeastShardAllocationStrategy(int rebalanceThreshold, int maxSimultaneousRebalance) { }\n        public override System.Threading.Tasks.Task<System.Collections.Immutable.IImmutableSet<string>> Rebalance(System.Collections.Immutable.IImmutableDictionary<Akka.Actor.IActorRef, System.Collections.Immutable.IImmutableList<string>> currentShardAllocations, System.Collections.Immutable.IImmutableSet<string> rebalanceInProgress) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Console Output from Actor Supervision\nDESCRIPTION: Shows the console output generated when an actor fails and is restarted by its supervisor, including error logging and lifecycle events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/intro/getting-started/tutorial-1.md#2025-04-16_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nsupervised actor started\nsupervised actor fails now\nsupervised actor stopped\nsupervised actor started\n[ERROR][05.06.2017 13:34:50][Thread 0003][akka://testSystem/user/supervising-actor/supervised-actor] I failed!\nCause: System.Exception: I failed!\n   at Tutorials.Tutorial1.SupervisedActor.OnReceive(Object message)\n   at Akka.Actor.UntypedActor.Receive(Object message)\n   at Akka.Actor.ActorBase.AroundReceive(Receive receive, Object message)\n   at Akka.Actor.ActorCell.ReceiveMessage(Object message)\n   at Akka.Actor.ActorCell.Invoke(Envelope envelope)\n```\n\n----------------------------------------\n\nTITLE: Overriding ToString Method for DeleteSnapshot\nDESCRIPTION: This snippet overrides the `ToString` method for the `DeleteSnapshot` class. This method is intended to provide a string representation of the `DeleteSnapshot` object, useful for debugging and logging.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\n\"public override string ToString() { }\"\n```\n\n----------------------------------------\n\nTITLE: Implementing TerminatedChildrenContainer Class in C#\nDESCRIPTION: A container for terminated actor children. Extends EmptyChildrenContainer and provides specialized handling for terminated children.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_62\n\nLANGUAGE: C#\nCODE:\n```\npublic class TerminatedChildrenContainer : Akka.Actor.Internal.EmptyChildrenContainer\n{\n    public new static Akka.Actor.Internal.IChildrenContainer Instance { get; }\n    public override bool IsNormal { get; }\n    public override bool IsTerminating { get; }\n    public override Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats) { }\n    public override Akka.Actor.Internal.IChildrenContainer Reserve(string name) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SQL Query for Retrieving Highest Sequence Number in Akka.Persistence\nDESCRIPTION: SQL query statement used to find the highest sequence number for a given persistence ID in a SQLite journal. This is essential for determining where to continue persisting events after recovery.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/custom-persistence-provider.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic const string HighestSequenceNrSql = @\"\n    select max(j.sequence_nr) from journal j\n    where j.persistence_id = @PersistenceId;\"\n```\n\n----------------------------------------\n\nTITLE: Lookup Class Definition in C#\nDESCRIPTION: Represents a service lookup query in Akka.NET service discovery. This class contains information about the service to be discovered, including name, port, and protocol details.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.DotNet.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class Lookup : Akka.Actor.INoSerializationVerificationNeeded, System.IEquatable<Akka.Discovery.Lookup>\n{\n    public Lookup(string serviceName, string portName = null, string protocol = null) { }\n    public string PortName { get; }\n    public string Protocol { get; }\n    public string ServiceName { get; }\n    public Akka.Discovery.Lookup Copy(string serviceName = null, string portName = null, string protocol = null) { }\n    public bool Equals(Akka.Discovery.Lookup other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public static bool IsValid(string srv) { }\n    public static Akka.Discovery.Lookup ParseSrv(string srv) { }\n    public override string ToString() { }\n    public Akka.Discovery.Lookup WithPortName(string portName) { }\n    public Akka.Discovery.Lookup WithProtocol(string protocol) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IAssociationEvent Interface in Akka.NET Remote Transport\nDESCRIPTION: An interface marker for association events in Akka.NET's remote transport system that indicates no serialization verification is needed.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IAssociationEvent : Akka.Actor.INoSerializationVerificationNeeded { }\n```\n\n----------------------------------------\n\nTITLE: Assembly Metadata Configuration in C#\nDESCRIPTION: Assembly-level attributes defining the repository URL and target framework for the Akka.NET project.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceInMemoryQuery.Core.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Split-Brain Resolution in Akka.NET C#\nDESCRIPTION: Classes such as `SplitBrainResolverProvider` provide strategies for resolving cluster partitioning issues ('Split Brain') using available resolution options like 'Keep Oldest' or 'Keep Majority'. It includes settings to configure resolution behavior under network partitions. Akka.Cluster and Akka.Actor namespaces are required dependencies.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.DotNet.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic class SplitBrainResolverProvider : Akka.Cluster.IDowningProvider { public SplitBrainResolverProvider(Akka.Actor.ActorSystem system, Akka.Cluster.Cluster cluster) { } public System.TimeSpan DownRemovalMargin { get; } public Akka.Actor.Props DowningActorProps { get; } }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SplitBrainResolverSettings { public static readonly System.Collections.Immutable.ImmutableHashSet<string> AllStrategyNames; public const string DownAllName = \"down-all\"; public const string KeepMajorityName = \"keep-majority\"; public const string KeepOldestName = \"keep-oldest\"; public const string LeaseMajorityName = \"lease-majority\"; public const string StaticQuorumName = \"static-quorum\"; public SplitBrainResolverSettings(Akka.Configuration.Config config) { } public System.TimeSpan DownAllWhenUnstable { get; } public System.TimeSpan DowningStableAfter { get; } public string DowningStrategy { get; } public string KeepMajorityRole { get; } public Akka.Cluster.SBR.KeepOldestSettings KeepOldestSettings { get; } public Akka.Cluster.SBR.LeaseMajoritySettings LeaseMajoritySettings { get; } public Akka.Cluster.SBR.StaticQuorumSettings StaticQuorumSettings { get; } }\n```\n\n----------------------------------------\n\nTITLE: Akka.NET Promotional Button Links\nDESCRIPTION: This snippet provides buttons linking to community news, getting started tutorial, and documentation for Akka.NET, facilitating user navigation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/index.md#2025-04-16_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<div class=\"options\">\n        <a class=\"btn btn-lg btn-primary\" href=\"community/whats-new/akkadotnet-v1.5.md\">OUT NOW: Akka.NET v1.5</a>\n        <a class=\"btn btn-lg btn-primary\" href=\"articles/intro/getting-started/tutorial-overview.md\">Get Started Now</a> <a class=\"btn btn-lg btn-primary\" href=\"articles/intro/what-is-akka.md\">Read the Documentation</a>\n      </div>\n```\n\n----------------------------------------\n\nTITLE: Configuring Static Quorum Strategy in Akka.NET\nDESCRIPTION: Configuration for the static-quorum strategy which downs unreachable nodes if the number of reachable ones meets the quorum size. This strategy works well when you can define a minimum required cluster size.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/split-brain-resolver.md#2025-04-16_snippet_3\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster.split-brain-resolver {\n  active-strategy = static-quorum\n\n  static-quorum {\n    # minimum number of nodes that the cluster must have \n    quorum-size = undefined\n        \n    # if the 'role' is defined the decision is based only on members with that 'role'\n    role = \"\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Performance Comparison After DotNetty Update (v1.5.22)\nDESCRIPTION: Performance benchmark results showing network throughput after updating DotNetty.Handlers to v0.7.6 to resolve CVE-2018-8292. The data shows approximately 10% performance decrease compared to previous version.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/RELEASE_NOTES.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nNum clients, Total [msg], Msgs/sec, Total [ms], Start Threads, End Threads\n         1,  200000,    123763,    1616.32,            46,              73\n         5, 1000000,    386101,    2590.66,            81,              90\n        10, 2000000,    662691,    3018.54,            98,             104\n        15, 3000000,    666223,    4503.86,           112,             113\n        20, 4000000,    669681,    5973.89,           121,             113\n        25, 5000000,    669255,    7471.86,           121,             105\n        30, 6000000,    669121,    8967.61,           113,              92\n```\n\n----------------------------------------\n\nTITLE: Defining Code Regions for Documentation in C#\nDESCRIPTION: This C# snippet demonstrates how to define a region in source code that can be referenced by documentation. It uses #region and #endregion tags to mark a section of code for inclusion in documentation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/documentation-guidelines.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n#region ClusterClient\npublic class ClientListener : UntypedActor\n{\n    private readonly IActorRef _targetClient;\n\n    public ClientListener(IActorRef targetClient)\n    {\n        _targetClient = targetClient;\n    }\n\n    protected override void OnReceive(object message)\n    {\n        Context.Become(ReceiveWithContactPoints(ImmutableHashSet<ActorPath>.Empty));\n    }\n\n    protected override void PreStart()\n    {\n        _targetClient.Tell(SubscribeContactPoints.Instance);\n    }\n\n    public UntypedReceive ReceiveWithContactPoints(IImmutableSet<ActorPath> contactPoints)\n    {\n        return (message) =>\n        {\n            switch (message)\n            {\n                // Now do something with the up-to-date \"cps\"\n                case ContactPoints cp:\n                    Context.Become(ReceiveWithContactPoints(cp.ContactPointsList));\n                    break;\n                // Now do something with an up-to-date \"contactPoints + cp\"\n                case ContactPointAdded cpa:\n                    Context.Become(ReceiveWithContactPoints(contactPoints.Add(cpa.ContactPoint)));\n                    break;\n                // Now do something with an up-to-date \"contactPoints - cp\"\n                case ContactPointRemoved cpr:\n                    Context.Become(ReceiveWithContactPoints(contactPoints.Remove(cpr.ContactPoint)));\n                    break;\n            }\n        };\n    }\n}\n#endregion\n```\n\n----------------------------------------\n\nTITLE: Defining RecoverySuccess Class in C#\nDESCRIPTION: This snippet defines the RecoverySuccess class, which represents a successful recovery operation in Akka.NET persistence.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class RecoverySuccess : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression, Akka.Persistence.IJournalMessage, Akka.Persistence.IJournalResponse, Akka.Persistence.IPersistenceMessage, System.IEquatable<Akka.Persistence.RecoverySuccess>\n{\n    public RecoverySuccess(long highestSequenceNr) { }\n    public long HighestSequenceNr { get; }\n    public bool Equals(Akka.Persistence.RecoverySuccess other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding GetHashCode Method for DeleteSnapshot\nDESCRIPTION: This snippet overrides the `GetHashCode` method for the `DeleteSnapshot` class. Overriding `GetHashCode` is important for using `DeleteSnapshot` objects in hash-based collections like dictionaries and hash sets.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\n\"public override int GetHashCode() { }\"\n```\n\n----------------------------------------\n\nTITLE: Embedding Closed Graph in Another Graph in C#\nDESCRIPTION: This snippet demonstrates that a RunnableGraph is a component like any other, which can be embedded in other graphs. It shows how to embed one closed graph inside another using the graph DSL.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/modularitycomposition.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar closed1 = Source.Single(0).To(Sink.ForEach<int>(Console.WriteLine));\nvar closed2 = RunnableGraph.FromGraph(GraphDsl.Create(b =>\n{\n    var embeddedClosed = b.Add(closed1);\n    // …\n    return embeddedClosed;\n}));\n```\n\n----------------------------------------\n\nTITLE: Defining IUpdateFailure Interface in C#\nDESCRIPTION: This snippet defines the `IUpdateFailure` interface, representing a failure during an update operation. It inherits from `Akka.Actor.INoSerializationVerificationNeeded` and `Akka.DistributedData.IUpdateResponse`. It includes a `Cause` property that holds the exception that caused the failure.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\n    public interface IUpdateFailure : Akka.Actor.INoSerializationVerificationNeeded, Akka.DistributedData.IUpdateResponse\n    {\n        System.Exception Cause { get; }\n    }\n\n```\n\n----------------------------------------\n\nTITLE: C# Actor Reference Base Classes\nDESCRIPTION: Abstract base classes InternalActorRefBase and MinimalActorRef that provide core functionality for actor references including message handling and lifecycle management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class InternalActorRefBase : Akka.Actor.ActorRefBase, Akka.Actor.IActorRef, Akka.Actor.IActorRefScope, Akka.Actor.ICanTell, Akka.Actor.IInternalActorRef, Akka.Util.ISurrogated, System.IComparable, System.IComparable<Akka.Actor.IActorRef>, System.IEquatable<Akka.Actor.IActorRef>\n{\n    protected InternalActorRefBase() { }\n    public abstract bool IsLocal { get; }\n    public abstract bool IsTerminated { get; }\n    public abstract Akka.Actor.IInternalActorRef Parent { get; }\n    public abstract Akka.Actor.IActorRefProvider Provider { get; }\n    public abstract Akka.Actor.IActorRef GetChild(System.Collections.Generic.IReadOnlyList<string> name);\n    public abstract void Restart(System.Exception cause);\n    public abstract void Resume(System.Exception causedByFailure = null);\n    public abstract void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message);\n    public abstract void Start();\n    public abstract void Stop();\n    public abstract void Suspend();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterSingletonMessageSerializer\nDESCRIPTION: Serializer class for cluster singleton messages with binary conversion support\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Net.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterSingletonMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public ClusterSingletonMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object o) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Factorial Backend Actor in C#\nDESCRIPTION: Defines a backend worker actor that performs factorial calculations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/clustering/cluster-metrics.md#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n[!code-csharp[RoutersUsageSample](../../../src/core/Akka.Docs.Tests/Cluster.Metrics/RoutersUsageSample.cs?name=FactorialBackend)]\n```\n\n----------------------------------------\n\nTITLE: Implementing Option<T> Inequality Operator in C#\nDESCRIPTION: Overload of the inequality operator for comparing two Option<T> instances.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_225\n\nLANGUAGE: C#\nCODE:\n```\npublic static bool !=(Akka.Util.Option<T> left, Akka.Util.Option<T> right) { }\n```\n\n----------------------------------------\n\nTITLE: Defining Assembly Attributes for Akka.NET SQL Read Journal\nDESCRIPTION: Sets assembly-level attributes including repository URL, COM visibility, GUID, and target framework for the Akka.NET SQL Read Journal component.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommonQuery.Core.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"3cbd3880-0655-44cc-ad81-77e8cadfcc3e\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Command Handler Method Signatures in C#\nDESCRIPTION: Protected methods for handling commands in Akka.NET persistence. Includes synchronous and async variations with optional predicate filtering.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nprotected void Command(System.Type messageType, System.Predicate<object> shouldHandle, System.Action<object> handler) { }\nprotected void Command<T>(System.Func<T, bool> handler) { }\nprotected void Command(System.Type messageType, System.Func<object, bool> handler) { }\nprotected void Command(System.Action<object> handler) { }\nprotected void CommandAny(System.Action<object> handler) { }\nprotected void CommandAnyAsync(System.Func<object, System.Threading.Tasks.Task> handler) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterSingletonManagerIsStuckException for Akka in C#\nDESCRIPTION: Defines an exception class for handling cases when the ClusterSingletonManager becomes stuck. Extends AkkaException for proper integration with Akka.NET's exception handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_26\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class ClusterSingletonManagerIsStuckException : Akka.Actor.AkkaException\n{\n    public ClusterSingletonManagerIsStuckException(string message) { }\n    public ClusterSingletonManagerIsStuckException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Get Class in C# for Akka.NET Distributed Data\nDESCRIPTION: Defines the Get class, representing a request to retrieve data from the distributed data store. It includes properties for the key, consistency, and optional request object.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Get : Akka.DistributedData.IReplicatorMessage, System.IEquatable<Akka.DistributedData.Get>\n{\n    public Get(Akka.DistributedData.IKey key, Akka.DistributedData.IReadConsistency consistency, object request = null) { }\n    public Akka.DistributedData.IReadConsistency Consistency { get; }\n    public Akka.DistributedData.IKey Key { get; }\n    public object Request { get; }\n    public bool Equals(Akka.DistributedData.Get other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending ValueTask with PipeTo Method in C#\nDESCRIPTION: Extends the ValueTask struct with a PipeTo method, similar to the Task extension. This allows piping ValueTask results to actors with custom success and failure handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic static System.Threading.Tasks.Task PipeTo(this System.Threading.Tasks.ValueTask taskToPipe, Akka.Actor.ICanTell recipient, bool useConfigureAwait, Akka.Actor.IActorRef sender = null, System.Func<object> success = null, System.Func<System.Exception, object> failure = null) { }\n```\n\n----------------------------------------\n\nTITLE: Defining DeleteSnapshot Class in C#\nDESCRIPTION: Defines a class representing a request to delete a snapshot, implementing several interfaces for message validation and equality comparison. It includes properties for exception cause and metadata related to the snapshot.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Net.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class DeleteSnapshotFailure : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage, Akka.Persistence.ISnapshotResponse, System.IEquatable<Akka.Persistence.DeleteSnapshotFailure>\n{\n    public DeleteSnapshotFailure(Akka.Persistence.SnapshotMetadata metadata, System.Exception cause) { }\n    public System.Exception Cause { get; }\n    public Akka.Persistence.SnapshotMetadata Metadata { get; }\n    public bool Equals(Akka.Persistence.DeleteSnapshotFailure other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MixMetricsSelector message with Google Protocol Buffers for Akka.NET\nDESCRIPTION: This class, `MixMetricsSelector`, allows combining multiple `MetricsSelector` instances. It contains a repeated field of `MetricsSelector` objects, providing a way to select a mix of metrics. It uses Google Protocol Buffers for serialization and implements the necessary interfaces.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.verified.txt#2025-04-16_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class MixMetricsSelector : Google.Protobuf.IDeepCloneable<Akka.Cluster.Metrics.Serialization.MixMetricsSelector>, Google.Protobuf.IMessage, Google.Protobuf.IMessage<Akka.Cluster.Metrics.Serialization.MixMetricsSelector>, System.IEquatable<Akka.Cluster.Metrics.Serialization.MixMetricsSelector>\n    {\n        public const int SelectorsFieldNumber = 1;\n        public MixMetricsSelector() { }\n        public MixMetricsSelector(Akka.Cluster.Metrics.Serialization.MixMetricsSelector other) { }\n        public static Google.Protobuf.Reflection.MessageDescriptor Descriptor { get; }\n        public static Google.Protobuf.MessageParser<Akka.Cluster.Metrics.Serialization.MixMetricsSelector> Parser { get; }\n        public Google.Protobuf.Collections.RepeatedField<Akka.Cluster.Metrics.Serialization.MetricsSelector> Selectors { get; }\n        public int CalculateSize() { }\n        public Akka.Cluster.Metrics.Serialization.MixMetricsSelector Clone() { }\n        public override bool Equals(object other) { }\n        public bool Equals(Akka.Cluster.Metrics.Serialization.MixMetricsSelector other) { }\n        public override int GetHashCode() { }\n        public void MergeFrom(Akka.Cluster.Metrics.Serialization.MixMetricsSelector other) { }\n        public void MergeFrom(Google.Protobuf.CodedInputStream input) { }\n        public override string ToString() { }\n        public void WriteTo(Google.Protobuf.CodedOutputStream output) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining ShardState Class in Akka.NET Sharding\nDESCRIPTION: This class represents the state of a shard, including the shard ID and the set of entity IDs it contains.  It is used for persisting and recovering shard state.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\n    public sealed class ShardState : Akka.Cluster.Sharding.IClusterShardingSerializable, System.IEquatable<Akka.Cluster.Sharding.ShardState>\n    {\n        public readonly System.Collections.Immutable.IImmutableSet<string> EntityIds;\n        public readonly string ShardId;\n        public ShardState(string shardId, System.Collections.Immutable.IImmutableSet<string> entityIds) { }\n        public override bool Equals(object obj) { }\n        public bool Equals(Akka.Cluster.Sharding.ShardState other) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterSingletonProvider for Akka in C#\nDESCRIPTION: Defines a provider class for the ClusterSingleton extension. Implements ExtensionIdProvider to enable registration and retrieval of the extension from the actor system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_28\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ClusterSingletonProvider : Akka.Actor.ExtensionIdProvider<Akka.Cluster.Tools.Singleton.ClusterSingleton>\n{\n    public ClusterSingletonProvider() { }\n    public override Akka.Cluster.Tools.Singleton.ClusterSingleton CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Recovery Class Implementation in C#\nDESCRIPTION: Sealed class for managing recovery operations with snapshot criteria and sequence number configurations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Recovery\n{\n    public Recovery() { }\n    public Recovery(Akka.Persistence.SnapshotSelectionCriteria fromSnapshot) { }\n    public Recovery(Akka.Persistence.SnapshotSelectionCriteria fromSnapshot, long toSequenceNr) { }\n    public Recovery(Akka.Persistence.SnapshotSelectionCriteria fromSnapshot = null, long toSequenceNr = 9223372036854775807, long replayMax = 9223372036854775807) { }\n    public static Akka.Persistence.Recovery Default { get; }\n    public Akka.Persistence.SnapshotSelectionCriteria FromSnapshot { get; }\n    public static Akka.Persistence.Recovery None { get; }\n    public long ReplayMax { get; }\n    public long ToSequenceNr { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SetThrottle Class in Akka.NET Remote Transport\nDESCRIPTION: A command class for setting throttling parameters for a specific address and direction in Akka.NET's throttling transport adapter.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SetThrottle\n{\n    public SetThrottle(Akka.Actor.Address address, Akka.Remote.Transport.ThrottleTransportAdapter.Direction direction, Akka.Remote.Transport.ThrottleMode mode) { }\n    public Akka.Actor.Address Address { get; }\n    public Akka.Remote.Transport.ThrottleTransportAdapter.Direction Direction { get; }\n    public Akka.Remote.Transport.ThrottleMode Mode { get; }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public static bool ==(Akka.Remote.Transport.SetThrottle left, Akka.Remote.Transport.SetThrottle right) { }\n    public static bool !=(Akka.Remote.Transport.SetThrottle left, Akka.Remote.Transport.SetThrottle right) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly Configuration for Akka.NET Service Discovery\nDESCRIPTION: Assembly metadata and target framework configuration for the Akka.NET service discovery module.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.Net.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: ConsistentHashingPool HOCON Configuration\nDESCRIPTION: HOCON configuration for ConsistentHashingPool router with number of instances and virtual nodes factor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_21\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.deployment {\n  /some-pool {\n    router = consistent-hashing-pool\n    nr-of-instances = 5\n    virtual-nodes-factor = 10\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining UdpConnected Disconnected Event in Akka.NET\nDESCRIPTION: Event notification indicating a UDP connection has been terminated. Uses a singleton instance pattern for memory efficiency.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_178\n\nLANGUAGE: C#\nCODE:\n```\npublic class Disconnected : Akka.IO.UdpConnected.Event\n{\n    public static readonly Akka.IO.UdpConnected.Disconnected Instance;\n}\n```\n\n----------------------------------------\n\nTITLE: Introducing ILoggingAdapter Usage in C# - C#\nDESCRIPTION: This C# snippet illustrates how to import the necessary namespace to use ILoggingAdapter after upgrading to v1.5.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/whats-new/akkadotnet-v1.5-upgrade-advisories.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Event;\n\n```\n\n----------------------------------------\n\nTITLE: Default Disassociate Method for Test Association (C#)\nDESCRIPTION: Default implementation for disassociating a test association handle, likely used in testing scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic System.Threading.Tasks.Task<bool> DefaultDisassociate(Akka.Remote.Transport.TestAssociationHandle handle) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ShutdownAttempt Class in Akka.NET Remote Transport\nDESCRIPTION: A class representing an attempt to shutdown a transport at a specific address in Akka.NET's remote transport system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ShutdownAttempt : Akka.Remote.Transport.Activity\n{\n    public ShutdownAttempt(Akka.Actor.Address boundAddress) { }\n    public Akka.Actor.Address BoundAddress { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Incremental Multi-Node Tests\nDESCRIPTION: Command to run specific multi-node tests incrementally to reduce build time during development\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/build-process.md#2025-04-16_snippet_2\n\nLANGUAGE: console\nCODE:\n```\nPS> build.cmd MultiNodeTestsNetCore spec={className} incremental\n```\n\n----------------------------------------\n\nTITLE: Composing Nested Sinks with Keep.Both in Akka.NET Streams\nDESCRIPTION: This code creates a composite Sink that uses Keep.Both to preserve both the materialized value of the flow (Task<OutgoingConnection>) and the sink (Task<String>), resulting in a tuple of both values.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/modularitycomposition.md#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n// Materializes to Task<String>                                 (green)\nvar sink = Sink.Aggregate<ByteString, string>(\"\", (agg, s) => agg + s.DecodeString());\n\n// Materializes to (Task<OutgoingConnection>, Task<String>)     (blue)\nvar nestedSink = nestedFlow.ToMaterialized(sink, Keep.Both);\n```\n\n----------------------------------------\n\nTITLE: Complex String Substitution in Arrays\nDESCRIPTION: Shows how concatenation can be useful for creating complex strings with substitutions within arrays, allowing for template-like behavior in configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/hocon.md#2025-04-16_snippet_7\n\nLANGUAGE: hocon\nCODE:\n```\n[ This is an unquoted string my name is ${name}, Hello ${world} ]\n[ ${a} ${b}, ${x} ${y} ]\n```\n\n----------------------------------------\n\nTITLE: RoleLeaderChanged Class Definition\nDESCRIPTION: This snippet defines a sealed class `RoleLeaderChanged` that implements `Akka.Cluster.ClusterEvent.IClusterDomainEvent` and `Akka.Event.IDeadLetterSuppression`. It represents the event when the leader for a specific role in the cluster changes. It has properties for `Role` and `Leader` and overrides `Equals`, `GetHashCode`, and `ToString`.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Net.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class RoleLeaderChanged : Akka.Cluster.ClusterEvent.IClusterDomainEvent, Akka.Event.IDeadLetterSuppression\n{\n    public RoleLeaderChanged(string role, Akka.Actor.Address leader) { }\n    public Akka.Actor.Address Leader { get; }\n    public string Role { get; }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IAtomicCounter<T> Interface in C#\nDESCRIPTION: Interface for thread-safe counter implementations that support atomic operations on a generic numeric type.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_246\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IAtomicCounter<T>\n{\n    T Current { get; }\n    T AddAndGet(T amount);\n    T GetAndAdd(T amount);\n    T GetAndIncrement();\n    T IncrementAndGet();\n    T Next();\n    void Reset();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Durable Data Envelope in C#\nDESCRIPTION: Implements a durable data envelope for persistent distributed data storage, including load and store operations with support for success/failure handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_47\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class DurableDataEnvelope : Akka.DistributedData.IReplicatorMessage, System.IEquatable<Akka.DistributedData.Durable.DurableDataEnvelope>\n{\n    public DurableDataEnvelope(Akka.DistributedData.Internal.DataEnvelope dataEnvelope) { }\n    public DurableDataEnvelope(Akka.DistributedData.IReplicatedData data) { }\n    public Akka.DistributedData.IReplicatedData Data { get; }\n    public bool Equals(Akka.DistributedData.Durable.DurableDataEnvelope other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Assembly Metadata and Internal Visibility for Akka.NET\nDESCRIPTION: Assembly attributes that specify metadata for the Akka.NET Cluster Sharding module, including repository URL, internal visibility to test projects, and COM/GUID information.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Benchmarks\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding.Tests.MultiNode\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.DistributedData.Tests\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"a05c31e8-0246-46a1-b3bc-4d6fe7a9aa49\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETCoreApp,Version=v6.0\", FrameworkDisplayName=\".NET 6.0\")]\n```\n\n----------------------------------------\n\nTITLE: Defining Internal Messages for Lease Actor\nDESCRIPTION: Internal message definitions required for implementing lease-based actor communication, including lease acquisition status and lease lost notifications.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/lease.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nprivate sealed class AcquireLeaseSuccess\nprivate sealed class AcquireLeaseFailed\nprivate sealed class LeaseLost\n```\n\n----------------------------------------\n\nTITLE: Defining IRequireCausualDeliveryOfDeltas Interface in C#\nDESCRIPTION: Defines a marker interface that combines IReplicatedData and IReplicatedDelta, indicating that the implementing CRDT requires causal delivery order for its delta operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IRequireCausualDeliveryOfDeltas : Akka.DistributedData.IReplicatedData, Akka.DistributedData.IReplicatedDelta { }\n```\n\n----------------------------------------\n\nTITLE: Configuring Akka.Cluster.Sharding for Eventsourced Storage - HOCON\nDESCRIPTION: This HOCON snippet configures Akka.Cluster.Sharding to use the eventsourced storage mode and the ddata state store mode for optimal performance in version 1.5.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/whats-new/akkadotnet-v1.5-upgrade-advisories.md#2025-04-16_snippet_4\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster.sharding{\n  state-store-mode = ddata\n  remember-entities-store = eventsourced\n}\n\n```\n\n----------------------------------------\n\nTITLE: Assembly Metadata Attributes in C#\nDESCRIPTION: Assembly level attributes that define metadata for the Akka.Cluster.Tools library, including repository URL, internals visibility, COM settings, GUID, and target framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Core.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Tools.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Tools.Tests.MultiNode\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"5cf8a8be-b634-473f-bb01-eba878746bd4\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Implementing NullSerializer in Akka.NET\nDESCRIPTION: Defines a NullSerializer class that extends the base Serializer but performs no actual serialization. Typically used for special cases where serialization is not needed or as a placeholder.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_197\n\nLANGUAGE: csharp\nCODE:\n```\npublic class NullSerializer : Akka.Serialization.Serializer\n{\n    public NullSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override int Identifier { get; }\n    public override bool IncludeManifest { get; }\n    public override object FromBinary(byte[] bytes, System.Type type) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing InternalEventFilterApplier for Akka.NET Testing\nDESCRIPTION: The InternalEventFilterApplier class applies event filters in Akka.NET test scenarios. It provides a mechanism for combining multiple filters.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\npublic class InternalEventFilterApplier : Akka.TestKit.IEventFilterApplier\n{\n    public InternalEventFilterApplier(Akka.TestKit.TestKitBase testkit, Akka.Actor.ActorSystem system, System.Collections.Generic.IReadOnlyList<Akka.TestKit.Internal.EventFilterBase> filters) { }\n    public Akka.TestKit.EventFilterFactory And { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining UdpConnected Connected Event in Akka.NET\nDESCRIPTION: Event notification indicating a successful UDP connection. Uses a singleton instance pattern for efficient memory usage.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_176\n\nLANGUAGE: C#\nCODE:\n```\npublic class Connected : Akka.IO.UdpConnected.Event\n{\n    public static readonly Akka.IO.UdpConnected.Connected Instance;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Tell Pattern in Akka.NET\nDESCRIPTION: Demonstrates the fire-and-forget message sending pattern using Tell() method with sender reference.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\ntarget.Tell(message, Self);\n```\n\n----------------------------------------\n\nTITLE: Defining IReplicatedDeltaSize Interface for Delta Size Metrics in C#\nDESCRIPTION: Defines an interface with a DeltaSize property that can be used to measure and optimize the size of delta operations in replicated data structures.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IReplicatedDeltaSize\n{\n    int DeltaSize { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Write Method for Test Associations (C#)\nDESCRIPTION: Method to write payload data to a test association handle, used for sending messages over the network in test scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic System.Threading.Tasks.Task<bool> Write(Akka.Remote.Transport.TestAssociationHandle handle, Google.Protobuf.ByteString payload) { }\n```\n\n----------------------------------------\n\nTITLE: Updating NodeMetrics in C#\nDESCRIPTION: This method serves as a placeholder for updating NodeMetrics instances, a key part of the Akka cluster metrics serialization. It seems to be intended for further implementation or override.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.DotNet.verified.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic Akka.Cluster.Metrics.Serialization.NodeMetrics Update(Akka.Cluster.Metrics.Serialization.NodeMetrics that) { }\n```\n\n----------------------------------------\n\nTITLE: ScatterGatherFirstCompleted Router Configuration\nDESCRIPTION: Configuration examples for ScatterGatherFirstCompleted router using both HOCON and code approaches.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_24\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.deployment {\n  /some-pool {\n    router = scatter-gather-pool\n    nr-of-instances = 5\n    within = 10s\n  }\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvar within = TimeSpan.FromSeconds(10);\nvar router = system.ActorOf(Props.Create<Worker>().WithRouter(new ScatterGatherFirstCompletedPool(5, within)), \"some-pool\");\n```\n\n----------------------------------------\n\nTITLE: Implementing NewtonSoftJsonSerializerSetup in Akka.NET\nDESCRIPTION: Defines a setup class for configuring NewtonSoftJsonSerializer through the ActorSystem setup. It allows passing custom JSON serializer settings via an Action delegate.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_196\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class NewtonSoftJsonSerializerSetup : Akka.Actor.Setup.Setup\n{\n    public System.Action<Newtonsoft.Json.JsonSerializerSettings> ApplySettings { get; }\n    public static Akka.Serialization.NewtonSoftJsonSerializerSetup Create(System.Action<Newtonsoft.Json.JsonSerializerSettings> settings) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WriteMessagesSuccessful Class in Akka.NET\nDESCRIPTION: The WriteMessagesSuccessful class represents a successful write of multiple messages to the journal. It provides a singleton instance.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_47\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class WriteMessagesSuccessful : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IJournalMessage, Akka.Persistence.IJournalResponse, Akka.Persistence.IPersistenceMessage\n{\n    public static Akka.Persistence.WriteMessagesSuccessful Instance { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Release Notes Format Example 1\nDESCRIPTION: Example of RELEASE_NOTES.md format for a regular release version\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/build-process.md#2025-04-16_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n#### 0.1.0 October 05 2019 ####\nFirst release\n```\n\n----------------------------------------\n\nTITLE: Defining IShardRegionQuery Interface in Akka.NET Sharding\nDESCRIPTION: Marker interface for messages that are queries to the shard region. It is used to differentiate queries from commands.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterSharding.DotNet.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n    public interface IShardRegionQuery { }\n```\n\n----------------------------------------\n\nTITLE: Testing Array Substitution in HOCON Configuration with C#\nDESCRIPTION: This test demonstrates array substitution in HOCON configuration by defining arrays in the configuration and substituting them into other properties. It verifies that arrays are correctly substituted and merged according to HOCON rules.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/hocon.md#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n[Fact]\npublic void ArraySubstitutionTest()\n{\n    var hocon = @\"{\n            arrays {\n                a: [1, 2, 3]\n                b: ${arrays.a}\n                c: ${arrays.b}[4]\n            }\n        }\";\n\n    var config = ConfigurationFactory.ParseString(hocon);\n\n    Assert.Equal(new[] { 1, 2, 3 }, config.GetIntList(\"arrays.a\"));\n    Assert.Equal(new[] { 1, 2, 3 }, config.GetIntList(\"arrays.b\"));\n    Assert.Equal(new[] { 1, 2, 3, 4 }, config.GetIntList(\"arrays.c\"));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ScatterGatherFirstCompletedGroup in Akka.NET\nDESCRIPTION: Router configuration for ScatterGatherFirstCompleted strategy operating on a predefined group of actor paths. Sends messages to all routees and returns the first response received within the specified timeout.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_213\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ScatterGatherFirstCompletedGroup : Akka.Routing.Group\n{\n    public ScatterGatherFirstCompletedGroup(Akka.Configuration.Config config) { }\n    public ScatterGatherFirstCompletedGroup(System.TimeSpan within, params string[] paths) { }\n    public ScatterGatherFirstCompletedGroup(System.Collections.Generic.IEnumerable<string> paths, System.TimeSpan within) { }\n    public ScatterGatherFirstCompletedGroup(System.Collections.Generic.IEnumerable<string> paths, System.TimeSpan within, string routerDispatcher) { }\n    public System.TimeSpan Within { get; }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public Akka.Routing.ScatterGatherFirstCompletedGroup WithDispatcher(string dispatcher) { }\n    public class ScatterGatherFirstCompletedGroupSurrogate : Akka.Util.ISurrogate\n    {\n        public ScatterGatherFirstCompletedGroupSurrogate() { }\n        public System.Collections.Generic.IEnumerable<string> Paths { get; set; }\n        public string RouterDispatcher { get; set; }\n        public System.TimeSpan Within { get; set; }\n        public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IPersistentEnvelope Interface\nDESCRIPTION: This snippet defines the `IPersistentEnvelope` interface, representing an envelope that wraps a persistent message in Akka.Persistence. It includes properties for accessing the payload, sender, and size of the message. This is used when replaying persistent messages during recovery.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\n\"public interface IPersistentEnvelope\n    {\n        object Payload { get; }\n        Akka.Actor.IActorRef Sender { get; }\n        int Size { get; }\n    }\"\n```\n\n----------------------------------------\n\nTITLE: EventId Struct Definition in C#\nDESCRIPTION: Defines a structure to uniquely identify events in the journal with properties for the event ID, persistence ID, and sequence number. Used for tracking and referencing persisted events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.DotNet.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\npublic struct EventId\n{\n    public readonly long Id;\n    public readonly string PersistenceId;\n    public readonly long SequenceNr;\n    public EventId(long id, long sequenceNr, string persistenceId) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Markdown Linting Installation via npm\nDESCRIPTION: This console command installs `markdownlint-cli` and `markdownlint-rule-titlecase` globally using Node Package Manager (npm). This makes the `markdownlint` command available in the command line.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/documentation-guidelines.md#2025-04-16_snippet_9\n\nLANGUAGE: console\nCODE:\n```\nnpm install -g markdownlint-cli@0.31.0 markdownlint-rule-titlecase@0.1.0\n```\n\n----------------------------------------\n\nTITLE: Importing Akka.Streams Namespaces\nDESCRIPTION: Imports the necessary namespaces for using Akka Streams functionality\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/quickstart.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Streams;\nusing Akka.Streams.Dsl;\n```\n\n----------------------------------------\n\nTITLE: Implementing EchoActor in C#\nDESCRIPTION: Defines the EchoActor class which extends ReceiveActor. This actor echoes received messages back to the sender and optionally to a test kit. It provides a Props method for creating instances.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\npublic class EchoActor : Akka.Actor.ReceiveActor\n{\n    public EchoActor(Akka.TestKit.TestKitBase testkit, bool echoBackToSenderAsWell = True) { }\n    public static Akka.Actor.Props Props(Akka.TestKit.TestKitBase testkit, bool echoBackToSenderAsWell = True) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IAssociationEventListener Interface in Akka.NET Remote Transport\nDESCRIPTION: An interface for listeners that need to be notified of association events in Akka.NET's remote transport system.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IAssociationEventListener\n{\n    void Notify(Akka.Remote.Transport.IAssociationEvent ev);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LogFilterEvaluator Class in C#\nDESCRIPTION: A class that evaluates a collection of log filters against log events to determine if they should be processed. It optimizes the evaluation process based on filter types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_137\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic class LogFilterEvaluator\n{\n    public static readonly Akka.Event.LogFilterEvaluator NoFilters;\n    public LogFilterEvaluator(Akka.Event.LogFilterBase[] filters) { }\n    public bool EvaluatesLogSourcesOnly { get; }\n    public virtual bool ShouldTryKeepMessage(Akka.Event.LogEvent evt, out string expandedLogMessage) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly Metadata Attribute\nDESCRIPTION: This code sets the AssemblyMetadata attribute to specify the repository URL for the Akka.NET project.  This allows tools to discover the source repository associated with the assembly. The RepositoryUrl is set to the GitHub repository for Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.Core.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n\"[assembly: System.Reflection.AssemblyMetadataAttribute(\\\"RepositoryUrl\\\", \\\"https://github.com/akkadotnet/akka.net\\\")]\"\n```\n\n----------------------------------------\n\nTITLE: Defining DeleteSnapshotFailure Class\nDESCRIPTION: This snippet defines the `DeleteSnapshotFailure` class, which represents a failure when deleting a snapshot in Akka.Persistence. It implements interfaces like `INoSerializationVerificationNeeded`, `IPersistenceMessage`, `ISnapshotMessage`, `ISnapshotResponse`, and `IEquatable<DeleteSnapshotFailure>`.  The class likely contains metadata and a cause for the failure.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\n\"public sealed class DeleteSnapshotFailure : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage, Akka.Persistence.ISnapshotResponse, System.IEquatable<Akka.Persistence.DeleteSnapshotFailure>\n    {\n        public DeleteSnapshotFailure(Akka.Persistence.SnapshotMetadata metadata, System.Exception cause) { }\n        public System.Exception Cause { get; }\n        public Akka.Persistence.SnapshotMetadata Metadata { get; }\n        public bool Equals(Akka.Persistence.DeleteSnapshotFailure other) { }\n        public override bool Equals(object obj) { }\n        public override int GetHashCode() { }\n        public override string ToString() { }\n    }\"\n```\n\n----------------------------------------\n\nTITLE: Implementing UdpConnected ResumeReading Command in Akka.NET\nDESCRIPTION: Command to resume reading from a UDP connection after it was suspended. Uses a singleton instance pattern for memory efficiency.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_183\n\nLANGUAGE: C#\nCODE:\n```\npublic class ResumeReading : Akka.IO.UdpConnected.Command\n{\n    public static readonly Akka.IO.UdpConnected.ResumeReading Instance;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DiscardToDeadLetterStrategy Class\nDESCRIPTION: This snippet defines the `DiscardToDeadLetterStrategy` class, an implementation of the `IStashOverflowStrategy` interface in Akka.Persistence. When the stash overflows, this strategy discards the overflowing messages and sends them to the dead letter office.  The `Instance` property provides a singleton instance of this strategy.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\n\"public class DiscardToDeadLetterStrategy : Akka.Persistence.IStashOverflowStrategy\n    {\n        public static Akka.Persistence.DiscardToDeadLetterStrategy Instance { get; }\n    }\"\n```\n\n----------------------------------------\n\nTITLE: Running Akka.Cluster Benchmark with .NET CLI in Powershell\nDESCRIPTION: This snippet shows how to run the Akka.Cluster.Cpu.Benchmark project using the .NET CLI. The commands provided allow users to execute the project directly or as a standalone executable. Dependencies include having the .NET SDK and powershell installed. Input parameters include optional command-line arguments for custom configurations. Outputs the CPU usage data to a .csv file.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/benchmark/Akka.Cluster.Cpu.Benchmark/README.md#2025-04-16_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\ndotnet run -c Release\ndotnet run -c Release -- [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Assembly Metadata and Attributes Declaration in C#\nDESCRIPTION: Assembly-level attributes defining metadata, internal visibility and framework targeting for the Akka.NET distributed data module.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding.Tests.MultiNode\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.DistributedData.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.DistributedData.Tests.MultiNode\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"f22db348-9ab3-4c6a-b1e8-9b835308d367\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Handler Priority in Message Handling in C#\nDESCRIPTION: Illustrates how message handlers are prioritized. A message type matched by multiple handlers will only trigger the first handler defined in the code. Handlers for strings and a generic object are defined, showing that only the first string handler is invoked for a string message.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka/Util/MatchHandler/README.md#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nReceive<string>(s => Console.WriteLine(\"Received string: \" + )s);      //1\nReceive<string>(s => Console.WriteLine(\"Also received string: \" + s)); //2\nReceive<object>(o => Console.WriteLine(\"Received object: \" + o));      //3\n```\n\n----------------------------------------\n\nTITLE: Defining SetStore Class for Akka.NET Persistence\nDESCRIPTION: This class represents a message to set the store for Akka.NET persistence, containing a reference to the actor that will serve as the store.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class SetStore\n{\n    public readonly Akka.Actor.IActorRef Store;\n    public SetStore(Akka.Actor.IActorRef store) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Actor Instantiation in C#\nDESCRIPTION: This snippet demonstrates the incorrect way of creating an Akka.NET actor using the 'new' keyword, which triggers the AK1000 error.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK1000.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Actor;\n\nclass MyActor : ActorBase {\n    protected override bool Receive(object message) {\n        return true;\n    }\n}\n\nclass Test\n{\n    void Method()\n    {\n        MyActor actorInstance = new MyActor(); // not supported by Akka.NET\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Number Type Enum Implementation in C#\nDESCRIPTION: Enumeration defining the supported number types for metrics serialization in Akka.NET cluster metrics.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.verified.txt#2025-04-16_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic enum NumberType\n{\n    [Google.Protobuf.Reflection.OriginalNameAttribute(\"Serialized\")]\n    Serialized = 0,\n    [Google.Protobuf.Reflection.OriginalNameAttribute(\"Double\")]\n    Double = 1,\n    [Google.Protobuf.Reflection.OriginalNameAttribute(\"Float\")]\n    Float = 2,\n    [Google.Protobuf.Reflection.OriginalNameAttribute(\"Integer\")]\n    Integer = 3,\n    [Google.Protobuf.Reflection.OriginalNameAttribute(\"Long\")]\n    Long = 4\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Journal and Snapshot Store Settings Classes\nDESCRIPTION: Configuration classes for SQL journal and snapshot store settings including connection strings, table names, and initialization options.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Core.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class JournalSettings {\n    public JournalSettings(Akka.Configuration.Config config) { }\n    public bool AutoInitialize { get; }\n    public string ConnectionString { get; }\n    public string ConnectionStringName { get; }\n    // Additional properties omitted for brevity\n}\n\npublic class SnapshotStoreSettings {\n    public SnapshotStoreSettings(Akka.Configuration.Config config) { }\n    public bool AutoInitialize { get; }\n    public string ConnectionString { get; }\n    // Additional properties omitted for brevity\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly Metadata Definition in C#\nDESCRIPTION: Defines assembly metadata including the repository URL and target framework for the Akka.NET library.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\"\")]\n```\n\n----------------------------------------\n\nTITLE: LeaseException Class Definition\nDESCRIPTION: Defines the base exception class for lease-related errors in the Akka.Coordination namespace. Extends the System.Exception class and provides constructors for different error scenarios.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.Net.verified.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class LeaseException : System.Exception\n{\n    public LeaseException(string message) { }\n    public LeaseException(string message, System.Exception innerEx) { }\n    protected LeaseException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing HOCON Parser and Tokenizer in C#\nDESCRIPTION: This snippet defines classes for parsing and tokenizing HOCON configuration. It includes methods for parsing arrays, values, and handling different token types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_70\n\nLANGUAGE: C#\nCODE:\n```\npublic class Parser\n{\n    public Parser() { }\n    public static Akka.Configuration.Hocon.HoconRoot Parse(string text, System.Func<string, Akka.Configuration.Hocon.HoconRoot> includeCallback) { }\n    public Akka.Configuration.Hocon.HoconArray ParseArray(string currentPath) { }\n    public void ParseValue(Akka.Configuration.Hocon.HoconValue owner, string currentPath) { }\n}\npublic class Token\n{\n    protected Token() { }\n    public Token(Akka.Configuration.Hocon.TokenType type) { }\n    public Token(string value) { }\n    public Akka.Configuration.Hocon.TokenType Type { get; set; }\n    public string Value { get; set; }\n    public static Akka.Configuration.Hocon.Token Key(string key) { }\n    public static Akka.Configuration.Hocon.Token LiteralValue(string value) { }\n    public static Akka.Configuration.Hocon.Token Substitution(string path) { }\n}\npublic enum TokenType\n{\n    Comment = 0,\n    Key = 1,\n    LiteralValue = 2,\n    Assign = 3,\n    ObjectStart = 4,\n    ObjectEnd = 5,\n    Dot = 6,\n    EoF = 7,\n    ArrayStart = 8,\n    ArrayEnd = 9,\n    Comma = 10,\n    Substitute = 11,\n    Include = 12,\n}\npublic class Tokenizer\n{\n    public Tokenizer(string text) { }\n    public bool EoF { get; }\n    public bool Matches(string pattern) { }\n    public bool Matches(params string[] patterns) { }\n    public char Peek() { }\n    protected string PickErrorLine(out int index) { }\n    public void Pop() { }\n    public void PullWhitespace() { }\n    public void Push() { }\n    public string Take(int length) { }\n    public char Take() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Assembly Metadata for Akka.NET SQL Persistence\nDESCRIPTION: Sets assembly-level attributes for the Akka.NET SQL Persistence module, including repository URL, COM visibility, GUID, and target framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Net.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"e438d2c3-1075-4b01-bb84-e9efd3a36691\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Assembly Configuration for Akka.NET SQL Persistence\nDESCRIPTION: Assembly metadata configuration including repository URL, COM visibility, GUID and target framework specifications.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.Core.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"e438d2c3-1075-4b01-bb84-e9efd3a36691\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Assembly Metadata and Internal Visibility Declarations in C#\nDESCRIPTION: Assembly-level attributes defining repository information, internal visibility, and framework targeting for the Akka.NET distributed data module.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Net.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Benchmarks\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.Cluster.Sharding.Tests.MultiNode\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.DistributedData.Tests\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(\"Akka.DistributedData.Tests.MultiNode\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"f22db348-9ab3-4c6a-b1e8-9b835308d367\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Defining ISurrogate Interface in C#\nDESCRIPTION: An interface for objects that can act as surrogates during serialization. Defines the contract for converting a surrogate back to its original form using the FromSurrogate method.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_239\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ISurrogate\n{\n    Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system);\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Build Commands on Linux/OSX\nDESCRIPTION: Command to display all available build commands on Unix-based systems\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/build-process.md#2025-04-16_snippet_1\n\nLANGUAGE: console\nCODE:\n```\nbuild.sh help\n```\n\n----------------------------------------\n\nTITLE: LeaseProviderExtensionProvider Implementation in C#\nDESCRIPTION: Extends the ExtensionIdProvider to create the LeaseProvider extension for the Akka actor system. Responsible for initializing the LeaseProvider extension.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.DotNet.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class LeaseProviderExtensionProvider : Akka.Actor.ExtensionIdProvider<Akka.Coordination.LeaseProvider>\n{\n    public LeaseProviderExtensionProvider() { }\n    public override Akka.Coordination.LeaseProvider CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ExpressionExtensions in Akka.Util.Reflection Namespace\nDESCRIPTION: Extension methods for working with expression trees in reflection scenarios. It provides the GetArguments method to extract constructor arguments from NewExpression objects.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_231\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Akka.Util.Reflection\n{\n    public class static ExpressionExtensions\n    {\n        public static object[] GetArguments(this System.Linq.Expressions.NewExpression newExpression) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Akka.NET Version Number\nDESCRIPTION: Simple version number declaration for Akka.NET framework version 2.4.9\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.Persistence/jvm-version.txt#2025-04-16_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n2.4.9\n```\n\n----------------------------------------\n\nTITLE: Defining IdentifyResult Enumeration\nDESCRIPTION: Enumeration defining possible results of singleton identification process\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Net.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic enum IdentifyResult\n{\n    Success = 0,\n    Timeout = 1,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterClientDiscoverySettings in Akka.NET\nDESCRIPTION: Configuration settings class for ClusterClientDiscovery that controls how the service discovery mechanism operates. It includes parameters for discovery method, service name, connection retries, backoff settings, and various timeouts.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Net.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.NullableAttribute(0)]\npublic sealed class ClusterClientDiscoverySettings : System.IEquatable<Akka.Cluster.Tools.Client.ClusterClientDiscoverySettings>\n{\n    [System.Runtime.CompilerServices.NullableAttribute(1)]\n    public static readonly Akka.Cluster.Tools.Client.ClusterClientDiscoverySettings Empty;\n    public ClusterClientDiscoverySettings(string DiscoveryMethod, string ServiceName, string PortName, int NumberOfContacts, System.TimeSpan Interval, double ExponentialBackoffJitter, System.TimeSpan ExponentialBackoffMax, System.TimeSpan ResolveTimeout, System.TimeSpan ProbeTimeout) { }\n    public string DiscoveryMethod { get; set; }\n    public double ExponentialBackoffJitter { get; set; }\n    public System.TimeSpan ExponentialBackoffMax { get; set; }\n    public System.TimeSpan Interval { get; set; }\n    public int NumberOfContacts { get; set; }\n    public string PortName { get; set; }\n    public System.TimeSpan ProbeTimeout { get; set; }\n    public System.TimeSpan ResolveTimeout { get; set; }\n    public string ServiceName { get; set; }\n    public static Akka.Cluster.Tools.Client.ClusterClientDiscoverySettings Create(Akka.Configuration.Config clusterClientConfig) { }\n}\n```\n\n----------------------------------------\n\nTITLE: NumberType Enum Definition\nDESCRIPTION: Enumeration defining supported numeric types for metric values with protobuf attributes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Core.verified.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic enum NumberType\n{\n    [Google.Protobuf.Reflection.OriginalNameAttribute(\"Serialized\")]\n    Serialized = 0,\n    [Google.Protobuf.Reflection.OriginalNameAttribute(\"Double\")]\n    Double = 1,\n    [Google.Protobuf.Reflection.OriginalNameAttribute(\"Float\")]\n    Float = 2,\n    [Google.Protobuf.Reflection.OriginalNameAttribute(\"Integer\")]\n    Integer = 3,\n    [Google.Protobuf.Reflection.OriginalNameAttribute(\"Long\")]\n    Long = 4\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Test Framework for Akka.NET Multi-Node Tests\nDESCRIPTION: Shows how to disable XUnit test parallelization by using the MultiNodeTestFramework provided by Akka.MultiNode.TestAdapter. This is recommended for multi-node tests to prevent interference between test executions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/testing/multi-node-testing.md#2025-04-16_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\nusing Xunit;\n\n[assembly: TestFramework(\"Akka.MultiNode.TestAdapter.MultiNodeTestFramework\", \"Akka.MultiNode.TestAdapter\")]\n```\n\n----------------------------------------\n\nTITLE: Implementing LogFilterBase Abstract Class in C#\nDESCRIPTION: An abstract base class for log filters that determines whether log messages should be kept or dropped. It implements IDeadLetterSuppression to prevent filter-related messages from generating dead letters.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_134\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class LogFilterBase : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression\n{\n    protected LogFilterBase() { }\n    public abstract Akka.Event.LogFilterType FilterType { get; }\n    public abstract Akka.Event.LogFilterDecision ShouldKeepMessage(Akka.Event.LogEvent content, [System.Runtime.CompilerServices.NullableAttribute(2)] string expandedMessage = null);\n}\n```\n\n----------------------------------------\n\nTITLE: TerminationHookDone Message in Akka.NET\nDESCRIPTION: Message indicating that a termination hook has completed execution. Uses the singleton pattern with a static Instance property.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_109\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class TerminationHookDone\n{\n    public static Akka.Dispatch.SysMsg.TerminationHookDone Instance { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Graph Deadlock with Naïve Cycle - Akka.Net\nDESCRIPTION: This code snippet demonstrates a naive cycle in an Akka.Net graph that leads to deadlock. The cycle increases the number of elements without removing any, causing buffer overflow. This occurs because a broadcast loop and a merge create a feedback arc but do not balance the cycle.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithgraphs.md#2025-04-16_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\n// WARNING! The graph below deadlocks!\nRunnableGraph.FromGraph(GraphDsl.Create(b =>\n{\n    var merge = b.Add(new Merge<int>(2));\n    var broadcast = b.Add(new Broadcast<int>(2));\n    var print = Flow.Create<int>().Select(s =>\n    {\n        Console.WriteLine(s);\n        return s;\n    });\n\n    var sink = Sink.Ignore<int>().MapMaterializedValue(_ => NotUsed.Instance);\n    b.From(source).Via(merge).Via(print).Via(broadcast).To(sink);\n    b.To(merge).From(broadcast);\n\n    return ClosedShape.Instance;\n}));\n```\n\n----------------------------------------\n\nTITLE: Referencing Code Samples in Markdown using DocFX\nDESCRIPTION: This Markdown snippet shows how to reference code samples from the Akka.NET source code using DocFX's !code syntax. It demonstrates linking to a specific region in a C# file.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/documentation-guidelines.md#2025-04-16_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n[!code-csharp[Main](../../../src/core/Akka.Docs.Tests/Networking/ClusterClient/ClientListener.cs?name=ClusterClient)]\n```\n\n----------------------------------------\n\nTITLE: LeaseSettings Class Definition in C#\nDESCRIPTION: Defines the configuration settings for leases including name, owner, timeout settings, and lease-specific config. Provides factory methods and immutable modification capabilities.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.verified.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class LeaseSettings\n{\n    public LeaseSettings(string leaseName, string ownerName, Akka.Coordination.TimeoutSettings timeoutSettings, Akka.Configuration.Config leaseConfig) { }\n    public Akka.Configuration.Config LeaseConfig { get; }\n    public string LeaseName { get; }\n    public string OwnerName { get; }\n    public Akka.Coordination.TimeoutSettings TimeoutSettings { get; }\n    public static Akka.Coordination.LeaseSettings Create(Akka.Configuration.Config config, string leaseName, string ownerName) { }\n    public override string ToString() { }\n    public Akka.Coordination.LeaseSettings WithTimeoutSettings(Akka.Coordination.TimeoutSettings timeoutSettings) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LogFilterDecision Enumeration in C#\nDESCRIPTION: An enumeration that represents the possible decisions a log filter can make: Keep the message, Drop the message, or make No decision (defer to other filters).\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_136\n\nLANGUAGE: C#\nCODE:\n```\npublic enum LogFilterDecision\n{\n    Keep = 0,\n    Drop = 1,\n    NoDecision = 2,\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Performance Benchmark Results for Akka.NET v1.4.0\nDESCRIPTION: Shows the performance benchmark results for Akka.NET v1.4.0, providing a baseline for comparison with newer versions and highlighting the significant improvements made.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/RELEASE_NOTES.md#2025-04-16_snippet_12\n\nLANGUAGE: plaintext\nCODE:\n```\nNum clients (actors)    Total [msg] Msgs/sec    Total [ms]\n1   200000  69736   2868.60\n5   1000000 141243  7080.98\n10  2000000 136771  14623.27\n15  3000000 38190   78556.49\n20  4000000 32401   123454.60\n25  5000000 33341   149967.08\n30  6000000 126093  47584.92\n```\n\n----------------------------------------\n\nTITLE: Implementing ThrowExceptionConfigurator Class in Akka.NET\nDESCRIPTION: The ThrowExceptionConfigurator class creates a strategy that throws exceptions when a stash overflow occurs. It implements IStashOverflowStrategyConfigurator interface.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ThrowExceptionConfigurator : Akka.Persistence.IStashOverflowStrategyConfigurator\n{\n    public ThrowExceptionConfigurator() { }\n    public Akka.Persistence.IStashOverflowStrategy Create(Akka.Configuration.Config config) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Option in Scala\nDESCRIPTION: This Scala code demonstrates pattern matching on an Option type. It checks if the 'role' is None or Some(r) and returns a boolean value based on the matched case.  The example relies on the `Member` class and its `hasRole` method.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/porting-guide.md#2025-04-16_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ndef matchingRole(member: Member, role: String): Boolean = role match {\n    case None    ⇒ true\n    case Some(r) ⇒ member.hasRole(r)\n}\n```\n\n----------------------------------------\n\nTITLE: Example Release Notes Entry - New Version (YML)\nDESCRIPTION: Example of a new release notes entry to be added for version 1.4.31, demonstrating the format for documenting bug fixes and changes.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/release-process.md#2025-04-16_snippet_1\n\nLANGUAGE: yml\nCODE:\n```\n#### 1.4.31 December 20 2021 ####\nAkka.NET v1.4.30 is a minor release that contains some bug fixes.\n\nAkka.NET v1.4.30 contained a breaking change that broke binary compatibility with all Akka.DI plugins.\nEven though those plugins are deprecated that change is not compatible with our SemVer standards \nand needed to be reverted. We regret the error.\n\nBug fixes:\n* [Akka: Reverted Props code refactor](https://github.com/akkadotnet/akka.net/pull/5454)\n\n| COMMITS | LOC+ | LOC- | AUTHOR |\n| --- | --- | --- | --- |\n| 1 | 9 | 2 | Gregorius Soedharmo |\n```\n\n----------------------------------------\n\nTITLE: Implementing ProviderSelection Class Hierarchy in C#\nDESCRIPTION: Abstract base class and sealed implementations for different actor provider selection types including Cluster, Custom, Local and Remote providers. Defines the core provider selection mechanism for Akka.NET.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ProviderSelection\n{\n    public sealed class Cluster : Akka.Actor.ProviderSelection\n    {\n        public static readonly Akka.Actor.ProviderSelection.Cluster Instance;\n    }\n    public sealed class Custom : Akka.Actor.ProviderSelection\n    {\n        public Custom(string fqn, string identifier = null, bool hasCluster = False) { }\n    }\n    public sealed class Local : Akka.Actor.ProviderSelection\n    {\n        public static readonly Akka.Actor.ProviderSelection.Local Instance;\n    }\n    public sealed class Remote : Akka.Actor.ProviderSelection\n    {\n        public static readonly Akka.Actor.ProviderSelection.Remote Instance;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: DocFx Local Server Launch\nDESCRIPTION: This shell script launches a local web server using DocFx to preview the generated documentation. It assumes that `serve-docs.cmd` is available in the current directory and that DocFx is configured to run a local server.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/documentation-guidelines.md#2025-04-16_snippet_8\n\nLANGUAGE: console\nCODE:\n```\nserve-docs.cmd\n```\n\n----------------------------------------\n\nTITLE: Defining EmptyEventSequence for Akka.NET Persistence Journal\nDESCRIPTION: This class represents an empty event sequence in Akka.NET persistence, implementing IEmptyEventSequence and IEventSequence interfaces with equality comparison.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.verified.txt#2025-04-16_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class EmptyEventSequence : Akka.Persistence.Journal.IEmptyEventSequence, Akka.Persistence.Journal.IEventSequence, System.IEquatable<Akka.Persistence.Journal.IEventSequence>\n{\n    public static readonly Akka.Persistence.Journal.EmptyEventSequence Instance;\n    public System.Collections.Generic.IEnumerable<object> Events { get; }\n    public bool Equals(Akka.Persistence.Journal.IEventSequence other) { }\n    public override bool Equals(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AnyNumber Struct in C#\nDESCRIPTION: Internal utility struct for handling different numeric types uniformly. Supports conversion between integer, long, float, and double numeric types with implicit operators for easy conversion.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.DotNet.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic struct AnyNumber\n{\n    public AnyNumber(int n) { }\n    public AnyNumber(long n) { }\n    public AnyNumber(float n) { }\n    public AnyNumber(double n) { }\n    public double DoubleValue { get; }\n    public long LongValue { get; }\n    [get: System.Runtime.CompilerServices.IsReadOnlyAttribute()]\n    public Akka.Cluster.Metrics.Helpers.AnyNumber.NumberType Type { get; }\n    public override string ToString() { }\n    public static Akka.Cluster.Metrics.Helpers.AnyNumber op_Implicit(int n) { }\n    public static Akka.Cluster.Metrics.Helpers.AnyNumber op_Implicit(long n) { }\n    public static Akka.Cluster.Metrics.Helpers.AnyNumber op_Implicit(float n) { }\n    public static Akka.Cluster.Metrics.Helpers.AnyNumber op_Implicit(double n) { }\n    public enum NumberType\n    {\n        Int = 0,\n        Long = 1,\n        Float = 2,\n        Double = 3,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterRouterPool in C#\nDESCRIPTION: Defines a sealed class ClusterRouterPool that extends Akka.Routing.Pool. It provides methods for creating and managing routers in a cluster pool configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ClusterRouterPool : Akka.Routing.Pool\n{\n    public ClusterRouterPool(Akka.Routing.Pool local, Akka.Cluster.Routing.ClusterRouterPoolSettings settings) { }\n    public Akka.Routing.Pool Local { get; }\n    public override string RouterDispatcher { get; }\n    public Akka.Cluster.Routing.ClusterRouterPoolSettings Settings { get; }\n    public override bool StopRouterWhenAllRouteesRemoved { get; }\n    public override Akka.Actor.SupervisorStrategy SupervisorStrategy { get; }\n    public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }\n    public override Akka.Actor.ActorBase CreateRouterActor() { }\n    public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }\n    public override bool IsManagementMessage(object message) { }\n    public override Akka.Actor.Props RoutingLogicController(Akka.Routing.RoutingLogic routingLogic) { }\n    public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }\n    public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Actor Transport Adapter Implementation\nDESCRIPTION: Concrete implementation of transport adapter that uses actors for managing remote connections and associations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ActorTransportAdapter : Akka.Remote.Transport.AbstractTransportAdapter\n{\n    public static readonly System.TimeSpan AskTimeout;\n    protected Akka.Actor.IActorRef modreq(System.Runtime.CompilerServices.IsVolatile) manager;\n    protected ActorTransportAdapter(Akka.Remote.Transport.Transport wrappedTransport, Akka.Actor.ActorSystem system) { }\n    protected abstract string ManagerName { get; }\n    protected abstract Akka.Actor.Props ManagerProps { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing InternalTestActorRef in C#\nDESCRIPTION: Implementation of test actor reference class that extends LocalActorRef for testing purposes. Provides methods for actor creation, message receiving and watching/unwatching functionality.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\npublic class InternalTestActorRef : Akka.Actor.LocalActorRef\n{\n    public object UnderlyingActor { get; }\n    public static Akka.TestKit.Internal.InternalTestActorRef Create(Akka.Actor.ActorSystem system, Akka.Actor.Props props, Akka.Actor.IActorRef supervisor = null, string name = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Akka.Cluster.Sharding with DistributedData in HOCON\nDESCRIPTION: This code snippet shows how to configure Akka.Cluster.Sharding to use Akka.DistributedData for storing shard allocation data instead of Akka.Persistence. This configuration change is recommended for Akka.NET v1.4 and later to improve cluster restart times and reduce I/O operations.  It utilizes the `akka.cluster.sharding.state-store-mode` setting.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/whats-new/akkadotnet-v1.4.md#2025-04-16_snippet_0\n\nLANGUAGE: HOCON\nCODE:\n```\n\"akka.cluster{\\n    sharding{\\n        state-store-mode = ddata\\n    }\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Public Hostname with Different Binding Address in HOCON\nDESCRIPTION: Configuration example showing how to set up a transport to listen on all network interfaces (0.0.0.0) while presenting itself with a specific public hostname. This is useful in environments where the binding address differs from the publicly accessible address.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/remoting/transports.md#2025-04-16_snippet_4\n\nLANGUAGE: xml\nCODE:\n```\nakka{\n    remote {\n        enabled-transports = [\"akka.remote.dot-netty.tcp\", \"akka.remote.dot-netty.udp\"]\n        dot-netty.tcp {\n            port = 8081\n            hostname = 0.0.0.0 # listen on all interfaces\n            public-hostname = \"machine1.foobar.com\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EventFilterBase for Akka.NET Log Event Filtering\nDESCRIPTION: The EventFilterBase class provides a base implementation for event filters in Akka.NET logging. It includes methods for matching and applying filters to log events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class EventFilterBase : Akka.TestKit.IEventFilter\n{\n    protected EventFilterBase(Akka.TestKit.Internal.StringMatcher.IStringMatcher messageMatcher, Akka.TestKit.Internal.StringMatcher.IStringMatcher sourceMatcher) { }\n    protected abstract string FilterDescriptiveName { get; }\n    public event Akka.TestKit.Internal.EventMatched EventMatched;\n    public bool Apply(Akka.Event.LogEvent logEvent) { }\n    protected bool InternalDoMatch(string src, object msg) { }\n    protected abstract bool IsMatch(Akka.Event.LogEvent evt);\n    protected virtual void OnEventMatched(Akka.Event.LogEvent logEvent) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing HOCON Token Class in C#\nDESCRIPTION: The Token class represents a lexical token in HOCON configuration syntax. It includes the token type and value, with static factory methods for creating common token types like keys, literal values, and substitutions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_75\n\nLANGUAGE: C#\nCODE:\n```\npublic class Token\n{\n    protected Token() { }\n    public Token(Akka.Configuration.Hocon.TokenType type) { }\n    public Token(string value) { }\n    public Akka.Configuration.Hocon.TokenType Type { get; set; }\n    public string Value { get; set; }\n    public static Akka.Configuration.Hocon.Token Key(string key) { }\n    public static Akka.Configuration.Hocon.Token LiteralValue(string value) { }\n    public static Akka.Configuration.Hocon.Token Substitution(string path) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Protocol Stack Implementation\nDESCRIPTION: Demonstrates how to test the complete protocol stack by connecting the bidirectional flows and simulating network communication without actual network connections.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithgraphs.md#2025-04-16_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\nvar stack = codec.Atop(framing);\n\n// test it by plugging it into its own inverse and closing the right end\nvar pingpong = Flow.Create<IMessage>().Collect(message =>\n{\n    var ping = message as Ping;\n    return ping != null\n        ? new Pong(ping.Id) as IMessage\n        : null;\n});\nvar flow = stack.Atop(stack.Reversed()).Join(pingpong);\nvar result =\n    Source.From(Enumerable.Range(0, 10))\n        .Select(i => new Ping(i) as IMessage)\n        .Via(flow)\n        .Limit(20)\n        .RunWith(Sink.Seq<IMessage>(), materializer);\n\nresult.Wait(TimeSpan.FromSeconds(1)).Should().BeTrue();\nresult.Result.ShouldAllBeEquivalentTo(Enumerable.Range(0, 10));\n```\n\n----------------------------------------\n\nTITLE: Implementing DefaultCollector for Metrics Collection in C#\nDESCRIPTION: This class implements the IMetricsCollector interface to sample and collect metrics from a node in the Akka cluster. It can be initialized with either an address or an actor system and allows proper resource cleanup through IDisposable.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterMetrics.Net.verified.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class DefaultCollector : Akka.Cluster.Metrics.IMetricsCollector, System.IDisposable\n{\n    public DefaultCollector(Akka.Actor.Address address) { }\n    public DefaultCollector(Akka.Actor.ActorSystem system) { }\n    public void Dispose() { }\n    public Akka.Cluster.Metrics.Serialization.NodeMetrics Sample() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating RandomGroup Router in C# Code\nDESCRIPTION: Shows how to create a random group router directly in C# code by specifying the actor paths of existing worker routees.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\nvar workers = new [] { \"/user/workers/w1\", \"/user/workers/w3\", \"/user/workers/w3\" }\nvar router = system.ActorOf(Props.Empty.WithRouter(new RandomGroup(workers)), \"some-group\");\n```\n\n----------------------------------------\n\nTITLE: Implementing TimeoutSettings Class in C#\nDESCRIPTION: Configuration class for timeout-related settings including heartbeat interval, heartbeat timeout, and operation timeout. Provides factory methods and immutable update operations for timeout configurations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.Core.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class TimeoutSettings\n{\n    public TimeoutSettings(System.TimeSpan heartbeatInterval, System.TimeSpan heartbeatTimeout, System.TimeSpan operationTimeout) { }\n    public System.TimeSpan HeartbeatInterval { get; }\n    public System.TimeSpan HeartbeatTimeout { get; }\n    public System.TimeSpan OperationTimeout { get; }\n    public static Akka.Coordination.TimeoutSettings Create(Akka.Configuration.Config config) { }\n    public override string ToString() { }\n    public Akka.Coordination.TimeoutSettings WithHeartbeatInterval(System.TimeSpan heartbeatInterval) { }\n    public Akka.Coordination.TimeoutSettings WithHeartbeatTimeout(System.TimeSpan heartbeatTimeout) { }\n    public Akka.Coordination.TimeoutSettings withOperationTimeout(System.TimeSpan operationTimeout) { }\n}\n```\n\n----------------------------------------\n\nTITLE: TestKitBase Abstract Class Implementation in C#\nDESCRIPTION: Base class for test kit functionality providing actor creation, assertion, and condition checking capabilities.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class TestKitBase : Akka.Actor.IActorRefFactory\n{\n    protected TestKitBase(Akka.TestKit.ITestKitAssertions assertions, Akka.Actor.ActorSystem system = null, string testActorName = null) { }\n    protected TestKitBase(Akka.TestKit.ITestKitAssertions assertions, Akka.Actor.Setup.ActorSystemSetup setup, string actorSystemName = null, string testActorName = null) { }\n    protected TestKitBase(Akka.TestKit.ITestKitAssertions assertions, Akka.Configuration.Config config, string actorSystemName = null, string testActorName = null) { }\n    protected TestKitBase(Akka.TestKit.ITestKitAssertions assertions, Akka.Actor.ActorSystem system, Akka.Actor.Setup.ActorSystemSetup config, string actorSystemName, string testActorName) { }\n    // ... Additional methods and properties ...\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly Metadata Configuration in C#\nDESCRIPTION: Sets assembly metadata including the repository URL and target framework information for the Akka.NET project.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.DotNet.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETCoreApp,Version=v6.0\", FrameworkDisplayName=\".NET 6.0\")]\n```\n\n----------------------------------------\n\nTITLE: Implementing UnboundedPriorityMailbox in C#\nDESCRIPTION: Example implementation of a priority mailbox that orders messages based on their importance. This custom mailbox prioritizes security flaws, then bugs, and finally other messages, demonstrating how to control message processing order.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/mailboxes.md#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class IssueTrackerMailbox : UnboundedPriorityMailbox\n{\n  protected override int PriorityGenerator(object message)\n  {\n      var issue = message as Issue;\n\n      if (issue != null)\n      {\n          if (issue.IsSecurityFlaw)\n              return 0;\n\n          if (issue.IsBug)\n              return 1;\n      }\n\n      return 2;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Remove Message Class for Akka Distributed PubSub in C#\nDESCRIPTION: Defines a sealed Remove message class used in Akka's distributed publish-subscribe system to remove an actor by its path. Implements IEquatable interface for proper comparison and overrides standard object methods.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class Remove : System.IEquatable<Akka.Cluster.Tools.PublishSubscribe.Remove>\n{\n    public Remove(string path) { }\n    public string Path { get; }\n    public bool Equals(Akka.Cluster.Tools.PublishSubscribe.Remove other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct GracefulStop Usage in ReceiveActor\nDESCRIPTION: This example shows the correct implementation using a detached Task to call GracefulStop(). By not awaiting the GracefulStop operation, the actor can continue processing messages and properly handle the termination sequence.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK1002.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Actor;\nusing System.Threading.Tasks;\nusing System;\n\npublic sealed class MyActor : ReceiveActor\n{\n   public MyActor()\n   {\n      ReceiveAsync<string>(async str => {\n         _ = Context.Self.GracefulStop();\n      }):\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing String Substitution in HOCON Configuration with C#\nDESCRIPTION: This test demonstrates string substitution in HOCON by defining a configuration with animal.favorite set to 'cat' and then referencing it in another property. It verifies that the substitution correctly resolves to 'cat is my favorite animal'.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/configuration/hocon.md#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n[Fact]\npublic void StringSubstitutionTest()\n{\n    var hocon = @\"{\n            animal {\n                favorite: cat\n            }\n            sentence: ${animal.favorite} is my favorite animal\n        }\";\n\n    var config = ConfigurationFactory.ParseString(hocon);\n\n    Assert.Equal(\"cat is my favorite animal\", config.GetString(\"sentence\"));\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Query Interfaces in C#\nDESCRIPTION: Defines various query interfaces such as IAllEventsQuery, ICurrentAllEventsQuery, IEventsByTagQuery, etc. These interfaces extend IReadJournal and define methods for querying different aspects of the event journal.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceQuery.Net.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IAllEventsQuery : Akka.Persistence.Query.IReadJournal\n{\n    Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> AllEvents(Akka.Persistence.Query.Offset offset);\n}\n\npublic interface ICurrentAllEventsQuery : Akka.Persistence.Query.IReadJournal\n{\n    Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentAllEvents(Akka.Persistence.Query.Offset offset);\n}\n\n// ... other interfaces\n```\n\n----------------------------------------\n\nTITLE: Creating an Actor with Stash Capacity in Akka.NET\nDESCRIPTION: This code demonstrates how to create an actor with a specific stash capacity using `Props.Create<T>().WithStashCapacity(size)`. The `WithStashCapacity` method configures the actor to use a bounded stash with the specified size, throwing a `StashOverflowException` if the stash exceeds this limit.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_27\n\nLANGUAGE: csharp\nCODE:\n```\n// create an actor with a stash size of 2\nIActorRef stasher = Sys.ActorOf(Props.Create<StashingActorWithOverflow>().WithStashCapacity(2));\n```\n\n----------------------------------------\n\nTITLE: Implementing TokenBucket Class in Akka.NET Remote Transport\nDESCRIPTION: A throttling implementation based on the token bucket algorithm in Akka.NET's transport system, extending the ThrottleMode abstract class.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class TokenBucket : Akka.Remote.Transport.ThrottleMode\n{\n    public TokenBucket(int capacity, double tokensPerSecond, long nanoTimeOfLastSend, int availableTokens) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n    public override System.TimeSpan TimeToAvailable(long currentNanoTime, int tokens) { }\n    public override System.ValueTuple<Akka.Remote.Transport.ThrottleMode, bool> TryConsumeTokens(long nanoTimeOfSend, int tokens) { }\n    public static bool ==(Akka.Remote.Transport.TokenBucket left, Akka.Remote.Transport.TokenBucket right) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BidiShape Class Structure in C#\nDESCRIPTION: Defines the basic structure of a bidirectional flow with two inputs and two outputs using BidiShape class. This forms the foundation for creating bidirectional stream processing components.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/workingwithgraphs.md#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class BidiShape<TIn1, TOut1, TIn2, TOut2> : Shape\n{\n    public BidiShape(Inlet<TIn1> in1, Outlet<TOut1> out1, Inlet<TIn2> in2, Outlet<TOut2> out2)\n    {\n    }\n\n    // implementation details elided ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Recovery Class in C#\nDESCRIPTION: This snippet defines the Recovery class with constructors and properties for managing recovery settings in Akka.NET persistence.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.Core.verified.txt#2025-04-16_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Recovery\n{\n    public Recovery() { }\n    public Recovery(Akka.Persistence.SnapshotSelectionCriteria fromSnapshot) { }\n    public Recovery(Akka.Persistence.SnapshotSelectionCriteria fromSnapshot, long toSequenceNr) { }\n    public Recovery(Akka.Persistence.SnapshotSelectionCriteria fromSnapshot = null, long toSequenceNr = 9223372036854775807, long replayMax = 9223372036854775807) { }\n    public static Akka.Persistence.Recovery Default { get; }\n    public Akka.Persistence.SnapshotSelectionCriteria FromSnapshot { get; }\n    public static Akka.Persistence.Recovery None { get; }\n    public long ReplayMax { get; }\n    public long ToSequenceNr { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected IMessageExtractor Implementation After Code Fix\nDESCRIPTION: The corrected version of the MessageExtractor implementation after applying the Akka.Analyzers code fix, which removes the unnecessary handling of built-in message types that are automatically managed by Akka.Cluster.Sharding.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK2001.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Cluster.Sharding;\n\npublic sealed class MessageExtractor : HashCodeMessageExtractor\n{\n    public MessageExtractor() : base(maxNumberOfShards: 100) { }\n\npublic string EntityId(object message) \n    {\n        return message switch\n        {\n            string sharded => sharded,\n            _ => null,\n        };\n    } \n}\n```\n\n----------------------------------------\n\nTITLE: Abstract ThrottleMode Class Definition (C#)\nDESCRIPTION: Base class for throttling mechanisms that control the rate of message transmission. Implements INoSerializationVerificationNeeded to exclude from serialization verification.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ThrottleMode : Akka.Actor.INoSerializationVerificationNeeded\n{\n    protected ThrottleMode() { }\n    public abstract System.TimeSpan TimeToAvailable(long currentNanoTime, int tokens);\n    public abstract System.ValueTuple<Akka.Remote.Transport.ThrottleMode, bool> TryConsumeTokens(long nanoTimeOfSend, int tokens);\n}\n```\n\n----------------------------------------\n\nTITLE: Unthrottled Class Implementation (C#)\nDESCRIPTION: Implementation of ThrottleMode that represents an unthrottled state where no rate limiting is applied. Provides singleton instance via static property.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic class Unthrottled : Akka.Remote.Transport.ThrottleMode\n{\n    public static Akka.Remote.Transport.Unthrottled Instance { get; }\n    public override System.TimeSpan TimeToAvailable(long currentNanoTime, int tokens) { }\n    public override System.ValueTuple<Akka.Remote.Transport.ThrottleMode, bool> TryConsumeTokens(long nanoTimeOfSend, int tokens) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Shutdown Method Implementation (C#)\nDESCRIPTION: Override method that shuts down the transport, returning a boolean indicating success or failure.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Net.verified.txt#2025-04-16_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic override System.Threading.Tasks.Task<bool> Shutdown() { }\n```\n\n----------------------------------------\n\nTITLE: Defining UdpConnected Command Base Class in Akka.NET\nDESCRIPTION: Abstract base class for UDP connection commands in Akka.NET. Commands are messages that can be sent to UDP actors to initiate actions. Includes a property for failure message handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_173\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Command : Akka.IO.UdpConnected.Message\n{\n    protected Command() { }\n    public object FailureMessage { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Core Snapshot Interfaces in C#\nDESCRIPTION: Declares base interfaces for snapshot messaging in Akka.NET including ISnapshotMessage, ISnapshotRequest, and ISnapshotResponse. These interfaces extend core Akka messaging interfaces.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ISnapshotMessage : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage { }\npublic interface ISnapshotRequest : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage { }\npublic interface ISnapshotResponse : Akka.Actor.INoSerializationVerificationNeeded, Akka.Persistence.IPersistenceMessage, Akka.Persistence.ISnapshotMessage { }\n```\n\n----------------------------------------\n\nTITLE: LeaseUsageSettings Class Definition\nDESCRIPTION: Defines settings for lease usage, including the lease implementation type and retry interval. Provides properties for accessing configuration values and overrides ToString for debugging.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCoordination.Net.verified.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class LeaseUsageSettings\n{\n    public LeaseUsageSettings(string leaseImplementation, System.TimeSpan leaseRetryInterval) { }\n    public string LeaseImplementation { get; }\n    public System.TimeSpan LeaseRetryInterval { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IScheduledTellMsg Interface in C#\nDESCRIPTION: An internal interface for messages scheduled for delayed delivery in the actor system. It inherits from INoSerializationVerificationNeeded and IWrappedMessage.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Net.verified.txt#2025-04-16_snippet_65\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalApiAttribute()]\npublic interface IScheduledTellMsg : Akka.Actor.INoSerializationVerificationNeeded, Akka.Actor.IWrappedMessage { }\n```\n\n----------------------------------------\n\nTITLE: Implementing System Message Base Class in Akka.NET\nDESCRIPTION: Defines the abstract base class for all system messages in Akka.NET. Provides common functionality including unlinking support for message handling.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_129\n\nLANGUAGE: C#\nCODE:\n```\n[Akka.Annotations.InternalStableApiAttribute()]\npublic abstract class SystemMessage : Akka.Actor.INoSerializationVerificationNeeded, Akka.Dispatch.SysMsg.ISystemMessage\n{\n    protected SystemMessage() { }\n    public bool Unlinked { get; }\n    public void Unlink() { }\n}\n```\n\n----------------------------------------\n\nTITLE: UDP Protocol Implementation\nDESCRIPTION: Implementation of UDP-related classes including commands and events for UDP communication. Contains classes for binding, sending, and receiving UDP packets.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_160\n\nLANGUAGE: C#\nCODE:\n```\npublic class Udp : Akka.Actor.ExtensionIdProvider<Akka.IO.UdpExt>\n{\n    public static readonly Akka.IO.Udp Instance;\n    public Udp() { }\n    public override Akka.IO.UdpExt CreateExtension(Akka.Actor.ExtendedActorSystem system) { }\n    public static Akka.Actor.IActorRef Manager(Akka.Actor.ActorSystem system) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Actor Bridge Interface in C#\nDESCRIPTION: Creates an interface for exposing Akka.NET actors to ASP.NET Core controllers. This interface provides a way to access the ActorSystem and lookup actors by path.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/deployment/aspnet-core.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IActorBridge\n{\n    ActorSystem ActorSystem { get; }\n\n    IActorRef ActorOf(Props props, string name = null);\n\n    IActorRef ActorSelection(string actorPath);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterSingletonProxy Class Definition\nDESCRIPTION: Core class for handling cluster singleton proxy functionality with timer scheduling and lifecycle management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.DotNet.verified.txt#2025-04-16_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\npublic ClusterSingletonProxy(string singletonManagerPath, Akka.Cluster.Tools.Singleton.ClusterSingletonProxySettings settings) { }\npublic Akka.Actor.ITimerScheduler Timers { get; set; }\npublic static Akka.Configuration.Config DefaultConfig() { }\nprotected override void PostStop() { }\nprotected override void PreStart() { }\npublic static Akka.Actor.Props Props(string singletonManagerPath, Akka.Cluster.Tools.Singleton.ClusterSingletonProxySettings settings) { }\n```\n\n----------------------------------------\n\nTITLE: Running API Approval Tests in Akka.NET\nDESCRIPTION: Command to generate new API approval files by running tests in Release configuration for .NET 6.0 framework. This needs to be run from the Akka.API.Tests directory.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/api-changes-compatibility.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nPS> cd src/core/Akka.API.Tests\nPS> dotnet test -c Release --framework net6.0\n```\n\n----------------------------------------\n\nTITLE: Creating Props for an Actor with Mixed Dependencies\nDESCRIPTION: This code demonstrates how to create Props for an actor that has both injected and non-injected dependencies using Akka.DependencyInjection.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/dependency-injection.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[NonDiActor](../../../src/contrib/dependencyinjection/Akka.DependencyInjection.Tests/ActorServiceProviderPropsWithScopesSpecs.cs?name=CreateNonDiActor)]\n```\n\n----------------------------------------\n\nTITLE: DataDeletedException Standard Exception Class\nDESCRIPTION: Standard exception class used to indicate that data has been deleted from the distributed data store. It extends the base Exception class and supports serialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.DotNet.verified.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class DataDeletedException : System.Exception\n{\n    public DataDeletedException(string message) { }\n    protected DataDeletedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Styling Akka.NET Documentation with CSS\nDESCRIPTION: This snippet defines CSS styles for the Akka.NET documentation web page, enhancing the visual layout and design elements.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/index.md#2025-04-16_snippet_0\n\nLANGUAGE: css\nCODE:\n```\n<style>\n.subtitle {\n    font-size:20px;\n}\n.jumbotron{\n    text-align: center;\n}\nimg.main-logo{\n    width: 192px;\n}\nimg.pb-logo-full{\n    width:  200px;\n}\nh2:before{\n    display: none;\n}\n.featured-box-minimal h4:before {\n    height: 0px;\n    margin-top: 0px;\n}\n</style>\n```\n\n----------------------------------------\n\nTITLE: Using Actor Selection in Akka.NET\nDESCRIPTION: Demonstrates different ways to look up actors using ActorSelection with absolute and relative paths, including wildcard patterns for broadcasting messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/untyped-actor-api.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n// will look up this absolute path\nContext.ActorSelection(\"/user/serviceA/actor\");\n\n// will look up sibling beneath same supervisor\nContext.ActorSelection(\"../joe\");\n```\n\nLANGUAGE: csharp\nCODE:\n```\n// will look all children to serviceB with names starting with worker\nContext.ActorSelection(\"/user/serviceB/worker*\");\n\n// will look up all siblings beneath same supervisor\nContext.ActorSelection(\"../*\");\n```\n\nLANGUAGE: csharp\nCODE:\n```\nContext.ActorSelection(\"akka.tcp://app@otherhost:1234/user/serviceB\");\n```\n\n----------------------------------------\n\nTITLE: Defining UdpConnected Message Base Class in Akka.NET\nDESCRIPTION: Root abstract base class for all UDP connection messages. Implements INoSerializationVerificationNeeded to indicate these messages don't need serialization verification.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_180\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Message : Akka.Actor.INoSerializationVerificationNeeded\n{\n    protected Message() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EqualsString Class in Akka.NET TestKit\nDESCRIPTION: A string matcher that checks for exact string equality. This class implements the IStringMatcher interface and provides a way to match strings based on exact equality comparison.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\npublic class EqualsString : Akka.TestKit.Internal.StringMatcher.IStringMatcher\n{\n    public EqualsString(string s) { }\n    public bool IsMatch(string s) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing VectorClock Comparison Operators in C#\nDESCRIPTION: Defines comparison operators for Akka.Cluster.VectorClock objects. These operators allow for comparing vector clocks to determine their relative ordering.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCluster.Core.verified.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic static bool >(Akka.Cluster.VectorClock left, Akka.Cluster.VectorClock right) { }\npublic static bool !=(Akka.Cluster.VectorClock left, Akka.Cluster.VectorClock right) { }\npublic static bool <(Akka.Cluster.VectorClock left, Akka.Cluster.VectorClock right) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Actor Task System Message in Akka.NET\nDESCRIPTION: Defines a system message that wraps a Task to be executed by an actor. Part of the SysMsg namespace for internal actor system communication.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_115\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ActorTask : Akka.Dispatch.SysMsg.SystemMessage\n{\n    public ActorTask(System.Threading.Tasks.Task task) { }\n    public System.Threading.Tasks.Task Task { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Release Notes Format Example 2\nDESCRIPTION: Example of RELEASE_NOTES.md format for a beta release version\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/contributing/build-process.md#2025-04-16_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n#### 0.1.0-beta1 October 05 2019 ####\nFirst release\n```\n\n----------------------------------------\n\nTITLE: Configuring Stash Capacity via HOCON in Akka.NET\nDESCRIPTION: Demonstrates how to configure the stash capacity of an actor using HOCON configuration, limiting the number of messages that can be stored in the stash.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_32\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.deployment{{\n    /configStashingActor {{\n        stash-capacity = 2\n    }}\n}}\n```\n\n----------------------------------------\n\nTITLE: IListeners Interface in Akka.NET Routing\nDESCRIPTION: Defines an interface for actors that support listeners. Implementing classes must provide a Listeners property of type ListenerSupport to manage subscribed listeners.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_176\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IListeners\n{\n    Akka.Routing.ListenerSupport Listeners { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Journal Plugin in Akka.NET Persistence\nDESCRIPTION: Example configuration for a custom journal plugin in Akka.NET Persistence. This configuration specifies the class and plugin-dispatcher for a memory-based journal implementation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/storage-plugins.md#2025-04-16_snippet_0\n\nLANGUAGE: json\nCODE:\n```\nakka.persistence.journal.inmem {\n  class = \"Akka.Persistence.Journal.MemoryJournal, Akka.Persistence\"\n  plugin-dispatcher = \"akka.actor.default-dispatcher\"\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Domain Messages for Persistent FSM in C#\nDESCRIPTION: Implementation of state data to represent items in a customer's shopping cart for a WebStoreCustomerFSMActor. Shows how to structure data that's maintained across state transitions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/persistence/persistent-fsm.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: UnderlyingTransportError Class Definition in C#\nDESCRIPTION: Sealed class representing transport errors in Akka.NET remote communication system that implements INoSerializationVerificationNeeded and IHandleEvent interfaces.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.verified.txt#2025-04-16_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class UnderlyingTransportError : Akka.Actor.INoSerializationVerificationNeeded, Akka.Remote.Transport.IHandleEvent\n{\n    public UnderlyingTransportError(System.Exception cause, string message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Actor Suspend System Message in Akka.NET\nDESCRIPTION: System message for suspending an actor. When an actor receives this message, it temporarily stops processing new messages.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_106\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class Suspend : Akka.Dispatch.SysMsg.SystemMessage\n{\n    public Suspend() { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Describing Stream Stage Operations in Akka.NET\nDESCRIPTION: Documentation for stream processing stages that handle stream transformation, combination, and timing-related operations in Akka.NET streams\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/builtinstages.md#2025-04-16_snippet_9\n\nLANGUAGE: markdown\nCODE:\n```\n## Nesting and Flattening Stages\n\nThese stages either take a stream and turn it into a stream of streams (nesting) or they take a stream that contains\nnested streams and turn them into a stream of elements instead (flattening).\n```\n\n----------------------------------------\n\nTITLE: Implementing Warning Filter in C#\nDESCRIPTION: Implementation of warning filter class that extends EventFilterBase for filtering warning messages during testing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.Net.verified.txt#2025-04-16_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\npublic class WarningFilter : Akka.TestKit.Internal.EventFilterBase\n{\n    public WarningFilter(Akka.TestKit.Internal.StringMatcher.IStringMatcher messageMatcher = null, Akka.TestKit.Internal.StringMatcher.IStringMatcher sourceMatcher = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TickTimeTokenBucket Class in C#\nDESCRIPTION: A token bucket implementation using ticks for time measurement, typically used for rate limiting.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_236\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class TickTimeTokenBucket : Akka.Util.TokenBucket\n{\n    public TickTimeTokenBucket(long capacity, long period) { }\n    public override long CurrentTime { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Headless Service Host\nDESCRIPTION: Program setup for hosting the headless service, including dependency injection and service configuration in a .NET application.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/deployment/headless-service.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/examples/HeadlessService/AkkaHeadlesssService/Program.cs?name=headless-service-program)]\n```\n\n----------------------------------------\n\nTITLE: Setting Up Akka.Cluster.Sharding Defaults - HOCON\nDESCRIPTION: This HOCON snippet shows the default settings retained for Akka.Cluster.Sharding to ensure backwards compatibility during the upgrade.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/community/whats-new/akkadotnet-v1.5-upgrade-advisories.md#2025-04-16_snippet_5\n\nLANGUAGE: hocon\nCODE:\n```\nakka.cluster.sharding{\n  state-store-mode = persistence\n  # remember-entities-store (not set - also uses legacy Akka.Persistence)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing ObjectExtensions Class in C#\nDESCRIPTION: Extension methods for objects to convert them to Option<T> instances, supporting the functional programming paradigm.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_242\n\nLANGUAGE: C#\nCODE:\n```\npublic class static ObjectExtensions\n{\n    public static Akka.Util.Option<T> AsOption<T>(this T obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ThreadLocalRandom Static Class in C#\nDESCRIPTION: A utility for thread-local random number generation, avoiding contention when multiple threads need random numbers.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_235\n\nLANGUAGE: C#\nCODE:\n```\npublic class static ThreadLocalRandom\n{\n    public static System.Random Current { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterSingletonMessageSerializer Class\nDESCRIPTION: Serializer for cluster singleton messages implementing string manifest-based serialization for cluster communication.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.verified.txt#2025-04-16_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClusterSingletonMessageSerializer : Akka.Serialization.SerializerWithStringManifest\n{\n    public ClusterSingletonMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }\n    public override object FromBinary(byte[] bytes, string manifest) { }\n    public override string Manifest(object o) { }\n    public override byte[] ToBinary(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Core Discovery Extension Implementation\nDESCRIPTION: Main Discovery extension class that provides access to service discovery mechanisms and configuration.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.Net.verified.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class Discovery : Akka.Actor.IExtension\n{\n    public Discovery(Akka.Actor.ExtendedActorSystem system) { }\n    public Akka.Discovery.ServiceDiscovery Default { get; }\n    public static Akka.Discovery.Discovery Get(Akka.Actor.ActorSystem system) { }\n    public Akka.Discovery.ServiceDiscovery LoadServiceDiscovery(string method) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Actor Debug Logging in Akka.NET\nDESCRIPTION: HOCON configuration snippet for enabling full debug logging of actor activities, including autoreceive and lifecycle events.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/testing-actor-systems.md#2025-04-16_snippet_7\n\nLANGUAGE: hocon\nCODE:\n```\nakka {\n  loglevel = \"DEBUG\"\n  actor {\n    debug {\n      autoreceive = on\n      lifecycle = on\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Sequences in Akka.NET Persistence\nDESCRIPTION: Provides classes for handling event sequences including EmptyEventSequence, generic EventSequence<T>, and utility methods through the static EventSequence class.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistence.DotNet.verified.txt#2025-04-16_snippet_47\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class EmptyEventSequence : Akka.Persistence.Journal.IEmptyEventSequence, Akka.Persistence.Journal.IEventSequence, System.IEquatable<Akka.Persistence.Journal.IEventSequence>\n{\n    public static readonly Akka.Persistence.Journal.EmptyEventSequence Instance;\n    public System.Collections.Generic.IEnumerable<object> Events { get; }\n    public bool Equals(Akka.Persistence.Journal.IEventSequence other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic class static EventSequence\n{\n    public static Akka.Persistence.Journal.IEventSequence Empty;\n    public static Akka.Persistence.Journal.IEventSequence Create(params object[] events) { }\n    public static Akka.Persistence.Journal.IEventSequence Create(System.Collections.Generic.IEnumerable<object> events) { }\n    public static Akka.Persistence.Journal.IEventSequence Single(object e) { }\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic class EventSequence<T> : Akka.Persistence.Journal.IEventSequence, System.IEquatable<Akka.Persistence.Journal.IEventSequence>\n{\n    public EventSequence(System.Collections.Generic.IEnumerable<object> events) { }\n    public System.Collections.Generic.IEnumerable<object> Events { get; }\n    public bool Equals(Akka.Persistence.Journal.IEventSequence other) { }\n    public override bool Equals(object obj) { }\n    public override int GetHashCode() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Akka.NET Windows Service Implementation\nDESCRIPTION: Core Windows Service implementation using Akka.NET. Defines the service behavior and actor system lifecycle management.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/deployment/windows-service.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[Main](../../../src/examples/WindowsService/AkkaWindowsService/AkkaService.cs?name=akka-windows-service)]\n```\n\n----------------------------------------\n\nTITLE: Time-Aware Stream Stages in Akka.NET\nDESCRIPTION: Comprehensive documentation of stream stages that incorporate time-based operations and timeout mechanisms\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/builtinstages.md#2025-04-16_snippet_11\n\nLANGUAGE: markdown\nCODE:\n```\n### InitialTimeout\n\nIf the first element has not passed through this stage before the provided timeout, the stream is failed\nwith a ``TimeoutException``.\n```\n\nLANGUAGE: markdown\nCODE:\n```\n### CompletionTimeout\n\nIf the completion of the stream does not happen until the provided timeout, the stream is failed\nwith a ``TimeoutException``.\n```\n\n----------------------------------------\n\nTITLE: Importing Required Namespaces for Akka.NET FSM\nDESCRIPTION: These using statements import the necessary Akka.NET namespaces for implementing a Finite State Machine actor.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/finite-state-machine.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Actor;\nusing Akka.Event;\n```\n\n----------------------------------------\n\nTITLE: Implementing SchemeAugmenter in Akka.NET Remote\nDESCRIPTION: Utility class for modifying transport scheme identifiers. Provides methods to add and remove scheme identifiers from address URIs, allowing transport adapters to mark addresses with their specific scheme.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveRemote.Core.verified.txt#2025-04-16_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic class SchemeAugmenter\n{\n    public readonly string AddedSchemeIdentifier;\n    public SchemeAugmenter(string addedSchemeIdentifier) { }\n    public string AugmentScheme(string originalScheme) { }\n    public Akka.Actor.Address AugmentScheme(Akka.Actor.Address address) { }\n    public string RemoveScheme(string scheme) { }\n    public Akka.Actor.Address RemoveScheme(Akka.Actor.Address address) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ClusterSingletonState Enumeration\nDESCRIPTION: Enumeration defining possible states of a cluster singleton\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveClusterTools.Net.verified.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic enum ClusterSingletonState\n{\n    Start = 0,\n    AcquiringLease = 1,\n    Oldest = 2,\n    Younger = 3,\n    BecomingOldest = 4,\n    WasOldest = 5,\n    HandingOver = 6,\n    TakeOver = 7,\n    Stopping = 8,\n    End = 9,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IConsistentHashable Message\nDESCRIPTION: Example of a message class implementing IConsistentHashable interface for consistent hash routing.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\npublic class SomeMessage : IConsistentHashable\n{\n    public Guid GroupID { get; private set; }\n    public object ConsistentHashKey {  get { return GroupID; } }\n}\n```\n\n----------------------------------------\n\nTITLE: Predicate-based Message Handling\nDESCRIPTION: Examples of using predicates to filter messages and control handler execution.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/receive-actor-api.md#2025-04-16_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\nReceive<string>(s => s.Length > 5, s => Console.WriteLine(\"Received string: \" + s);\n```\n\nLANGUAGE: csharp\nCODE:\n```\nReceive<string>(s => s.Length > 5, s => Console.WriteLine(\"1: \" + s));    //1\nReceive<string>(s => s.Length > 2, s => Console.WriteLine(\"2: \" + s));    //2\nReceive<string>(s => Console.WriteLine(\"3: \" + s));                     //3\n```\n\nLANGUAGE: csharp\nCODE:\n```\nReceive<string>(s => s.Length > 5, s => Console.WriteLine(\"Received string: \" + s));\nReceive<string>(s => Console.WriteLine(\"Received string: \" + s), s => s.Length > 5);\n```\n\n----------------------------------------\n\nTITLE: Aggregate Service Discovery Implementation\nDESCRIPTION: Internal API implementation of aggregate service discovery that combines multiple discovery methods.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDiscovery.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class AggregateServiceDiscovery : Akka.Discovery.ServiceDiscovery\n{\n    public AggregateServiceDiscovery(Akka.Actor.ExtendedActorSystem system) { }\n    public override System.Threading.Tasks.Task<Akka.Discovery.ServiceDiscovery.Resolved> Lookup(Akka.Discovery.Lookup query, System.TimeSpan resolveTimeout) { }\n}\n```\n\n----------------------------------------\n\nTITLE: TailChopping Router Configuration\nDESCRIPTION: HOCON and code configuration examples for TailChopping router implementation.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/routers.md#2025-04-16_snippet_23\n\nLANGUAGE: hocon\nCODE:\n```\nakka.actor.deployment {\n  /some-pool {\n    router = tail-chopping-pool\n    nr-of-instances = 5\n    within = 10s\n    tail-chopping-router.interval = 20ms\n  }\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvar within = TimeSpan.FromSeconds(10);\nvar interval = TimeSpan.FromMilliseconds(20);\nvar router = system.ActorOf(Props.Create<Worker>().WithRouter(new TailChoppingPool(5, within, interval)), \"some-pool\");\n```\n\n----------------------------------------\n\nTITLE: Defining System Message Interface in Akka.NET\nDESCRIPTION: Defines the core interface for system messages that are used for internal actor system communication. Extends INoSerializationVerificationNeeded to prevent serialization.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.DotNet.verified.txt#2025-04-16_snippet_120\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ISystemMessage : Akka.Actor.INoSerializationVerificationNeeded { }\n```\n\n----------------------------------------\n\nTITLE: Synchronized Dispatcher Configuration\nDESCRIPTION: Configuration for a dispatcher that uses the current SynchronizationContext.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/actors/dispatchers.md#2025-04-16_snippet_7\n\nLANGUAGE: hocon\nCODE:\n```\nsynchronized-dispatcher {\n  type = \"SynchronizedDispatcher\"\n  throughput = 10\n}\n```\n\n----------------------------------------\n\nTITLE: Contextual Logging Setup for Akka.NET v1.4\nDESCRIPTION: Example of using ForContext extension method for contextual logging in legacy Akka.NET versions.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/utilities/serilog.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Logger.Serilog;\n...\nprivate readonly ILoggingAdapter _logger = Context.GetLogger<SerilogLoggingAdapter>();\n...\nprivate void ProcessMessage(string correlationId)\n{\n    var contextLogger = _logger.ForContext(\"CorrelationId\", correlationId);\n    contextLogger.Info(\"Processing message\");\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling xUnit Analyzer Warning for FsCheck\nDESCRIPTION: Code snippet showing how to disable the xUnit1028 warning when using FsCheck.Xunit due to Roslyn analyzer restrictions on unit test return types.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/RELEASE_NOTES.md#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n#pragma warning disable xUnit1028\n```\n\n----------------------------------------\n\nTITLE: Exposing a Sink as a Subscriber in C#\nDESCRIPTION: Shows how to convert an Akka Streams Sink into a Reactive Streams Subscriber using Source.AsSubscriber.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/streams/integration.md#2025-04-16_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\nvar tweetSubscriber = authors.To(Sink.FromSubscriber(storage))\n    .RunWith(Source.AsSubscriber<Tweet>(), materializer);\n\ntweets.Subscribe(tweetSubscriber);\n```\n\n----------------------------------------\n\nTITLE: Problematic IMessageExtractor Implementation with Manually Handled Built-in Messages\nDESCRIPTION: An example of an incorrect MessageExtractor implementation that unnecessarily handles ShardingEnvelope and ShardRegion.StartEntity messages, which are automatically handled by Akka.Cluster.Sharding as of version 1.5.15.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/docs/articles/debugging/rules/AK2001.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing Akka.Cluster.Sharding;\n\npublic sealed class MessageExtractor : HashCodeMessageExtractor\n{\n    public MessageExtractor() : base(maxNumberOfShards: 100) { }\n\n    public string EntityId(object message) \n    {\n        return message switch\n        {\n            string sharded => sharded,\n            ShardingEnvelope e => e.EntityId,\n            ShardRegion.StartEntity start => start.EntityId,\n            _ => null,\n        };\n    } \n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Filter Methods in C#\nDESCRIPTION: This snippet shows various methods for expecting and intercepting events in Akka.NET TestKit. It includes synchronous and asynchronous versions with different parameter combinations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveTestKit.DotNet.verified.txt#2025-04-16_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\nprotected bool AwaitDone(System.TimeSpan timeout, System.Nullable<int> expectedOccurrences, Akka.TestKit.Internal.InternalEventFilterApplier.MatchedEventHandler matchedEventHandler, System.Threading.CancellationToken cancellationToken = null) { }\nprotected System.Threading.Tasks.Task<bool> AwaitDoneAsync(System.TimeSpan timeout, System.Nullable<int> expectedOccurrences, Akka.TestKit.Internal.InternalEventFilterApplier.MatchedEventHandler matchedEventHandler, System.Threading.CancellationToken cancellationToken = null) { }\npublic void Expect(int expectedCount, System.Action action, System.Threading.CancellationToken cancellationToken = null) { }\npublic void Expect(int expectedCount, System.TimeSpan timeout, System.Action action, System.Threading.CancellationToken cancellationToken = null) { }\npublic T Expect<T>(int expectedCount, System.Func<T> func, System.Threading.CancellationToken cancellationToken = null) { }\npublic T Expect<T>(int expectedCount, System.TimeSpan timeout, System.Func<T> func, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.Task ExpectAsync(int expectedCount, System.Func<System.Threading.Tasks.Task> actionAsync, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.Task ExpectAsync(int expectedCount, System.Func<System.Threading.Tasks.Task> actionAsync, System.Nullable<System.TimeSpan> timeout, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.Task ExpectAsync(int expectedCount, System.TimeSpan timeout, System.Func<System.Threading.Tasks.Task> action, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.Task ExpectAsync(int expectedCount, System.TimeSpan timeout, System.Action action, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.Task<T> ExpectAsync<T>(int expectedCount, System.Func<System.Threading.Tasks.Task<T>> func, System.Threading.CancellationToken cancellationToken = null) { }\npublic System.Threading.Tasks.Task<T> ExpectAsync<T>(int expectedCount, System.TimeSpan timeout, System.Func<System.Threading.Tasks.Task<T>> func, System.Threading.CancellationToken cancellationToken = null) { }\n```\n\n----------------------------------------\n\nTITLE: Defining Assembly Attributes for Akka.NET Persistence SQL Common\nDESCRIPTION: Sets assembly-level attributes for the Akka.NET Persistence SQL Common library, including repository URL, COM visibility, GUID, and target framework.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommon.verified.txt#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https://github.com/akkadotnet/akka.net\")]\n[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]\n[assembly: System.Runtime.InteropServices.GuidAttribute(\"e438d2c3-1075-4b01-bb84-e9efd3a36691\")]\n[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\"\")]\n```\n\n----------------------------------------\n\nTITLE: Implementing SqlReadJournal Class for Akka.NET Persistence Query\nDESCRIPTION: Defines the SqlReadJournal class which implements multiple interfaces for querying persistent events. It includes methods for retrieving events by various criteria and persistence IDs.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApprovePersistenceSqlCommonQuery.Core.verified.txt#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class SqlReadJournal : Akka.Persistence.Query.IAllEventsQuery, Akka.Persistence.Query.ICurrentAllEventsQuery, Akka.Persistence.Query.ICurrentEventsByPersistenceIdQuery, Akka.Persistence.Query.ICurrentEventsByTagQuery, Akka.Persistence.Query.ICurrentPersistenceIdsQuery, Akka.Persistence.Query.IEventsByPersistenceIdQuery, Akka.Persistence.Query.IEventsByTagQuery, Akka.Persistence.Query.IPersistenceIdsQuery, Akka.Persistence.Query.IReadJournal\n{\n    public const string Identifier = \"akka.persistence.query.journal.sql\";\n    public SqlReadJournal(Akka.Actor.ExtendedActorSystem system, Akka.Configuration.Config config) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> AllEvents(Akka.Persistence.Query.Offset offset = null) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentAllEvents(Akka.Persistence.Query.Offset offset) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentEventsByPersistenceId(string persistenceId, long fromSequenceNr, long toSequenceNr) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> CurrentEventsByTag(string tag, Akka.Persistence.Query.Offset offset = null) { }\n    public Akka.Streams.Dsl.Source<string, Akka.NotUsed> CurrentPersistenceIds() { }\n    public static Akka.Configuration.Config DefaultConfiguration() { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> EventsByPersistenceId(string persistenceId, long fromSequenceNr, long toSequenceNr) { }\n    public Akka.Streams.Dsl.Source<Akka.Persistence.Query.EventEnvelope, Akka.NotUsed> EventsByTag(string tag, Akka.Persistence.Query.Offset offset = null) { }\n    public Akka.Streams.Dsl.Source<string, Akka.NotUsed> PersistenceIds() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IRemovedNodePruning Interface in C#\nDESCRIPTION: This snippet defines the `IRemovedNodePruning` interface, which extends `IReplicatedData` and includes methods for managing pruning operations related to removed nodes in a cluster.  It provides mechanisms to track nodes that have modified the data, determine if pruning is needed from a specific removed node, and perform the pruning and cleanup operations.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveDistributedData.Core.verified.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\n    public interface IRemovedNodePruning : Akka.DistributedData.IReplicatedData\n    {\n        System.Collections.Immutable.ImmutableHashSet<Akka.Cluster.UniqueAddress> ModifiedByNodes { get; }\n        bool NeedPruningFrom(Akka.Cluster.UniqueAddress removedNode);\n        Akka.DistributedData.IReplicatedData Prune(Akka.Cluster.UniqueAddress removedNode, Akka.Cluster.UniqueAddress collapseInto);\n        Akka.DistributedData.IReplicatedData PruningCleanup(Akka.Cluster.UniqueAddress removedNode);\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Actor Recreation System Message in Akka.NET\nDESCRIPTION: System message for recreating an actor after a failure. Contains the cause of the failure that triggered the recreation event.\nSOURCE: https://github.com/akkadotnet/akka.net/blob/dev/src/core/Akka.API.Tests/verify/CoreAPISpec.ApproveCore.Core.verified.txt#2025-04-16_snippet_100\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class Recreate : Akka.Dispatch.SysMsg.SystemMessage\n{\n    public Recreate(System.Exception cause) { }\n    public System.Exception Cause { get; }\n    public override string ToString() { }\n}\n```"
  }
]