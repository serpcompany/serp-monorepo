[
  {
    "owner": "nats-io",
    "repo": "nats.py",
    "content": "TITLE: Basic NATS Publish/Subscribe Example in Python\nDESCRIPTION: Demonstrates connecting to a NATS server, publishing messages to subjects, and subscribing to receive messages using both callback and iterator-based approaches. Also shows making requests and using queue groups for load balancing.\nSOURCE: https://github.com/nats-io/nats.py/blob/main/README.md#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport nats\nfrom nats.errors import ConnectionClosedError, TimeoutError, NoServersError\n\nasync def main():\n    # It is very likely that the demo server will see traffic from clients other than yours.\n    # To avoid this, start your own locally and modify the example to use it.\n    nc = await nats.connect(\"nats://demo.nats.io:4222\")\n\n    # You can also use the following for TLS against the demo server.\n    #\n    # nc = await nats.connect(\"tls://demo.nats.io:4443\")\n\n    async def message_handler(msg):\n        subject = msg.subject\n        reply = msg.reply\n        data = msg.data.decode()\n        print(\"Received a message on '{subject} {reply}': {data}\".format(\n            subject=subject, reply=reply, data=data))\n\n    # Simple publisher and async subscriber via coroutine.\n    sub = await nc.subscribe(\"foo\", cb=message_handler)\n\n    # Stop receiving after 2 messages.\n    await sub.unsubscribe(limit=2)\n    await nc.publish(\"foo\", b'Hello')\n    await nc.publish(\"foo\", b'World')\n    await nc.publish(\"foo\", b'!!!!!')\n\n    # Synchronous style with iterator also supported.\n    sub = await nc.subscribe(\"bar\")\n    await nc.publish(\"bar\", b'First')\n    await nc.publish(\"bar\", b'Second')\n\n    try:\n        async for msg in sub.messages:\n            print(f\"Received a message on '{msg.subject} {msg.reply}': {msg.data.decode()}\")\n            await sub.unsubscribe()\n    except Exception as e:\n        pass\n\n    async def help_request(msg):\n        print(f\"Received a message on '{msg.subject} {msg.reply}': {msg.data.decode()}\")\n        await nc.publish(msg.reply, b'I can help')\n\n    # Use queue named 'workers' for distributing requests\n    # among subscribers.\n    sub = await nc.subscribe(\"help\", \"workers\", help_request)\n\n    # Send a request and expect a single response\n    # and trigger timeout if not faster than 500 ms.\n    try:\n        response = await nc.request(\"help\", b'help me', timeout=0.5)\n        print(\"Received response: {message}\".format(\n            message=response.data.decode()))\n    except TimeoutError:\n        print(\"Request timed out\")\n\n    # Remove interest in subscription.\n    await sub.unsubscribe()\n\n    # Terminate connection to NATS.\n    await nc.drain()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: NATS JetStream Operations in Python\nDESCRIPTION: Demonstrates using NATS JetStream to create streams, publish messages persistently, and work with pull and push-based consumers. Shows durable subscriptions, delivery groups, and ordered consumers with flow control.\nSOURCE: https://github.com/nats-io/nats.py/blob/main/README.md#2025-04-20_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport nats\nfrom nats.errors import TimeoutError\n\nasync def main():\n    nc = await nats.connect(\"localhost\")\n\n    # Create JetStream context.\n    js = nc.jetstream()\n\n    # Persist messages on 'foo's subject.\n    await js.add_stream(name=\"sample-stream\", subjects=[\"foo\"])\n\n    for i in range(0, 10):\n        ack = await js.publish(\"foo\", f\"hello world: {i}\".encode())\n        print(ack)\n\n    # Create pull based consumer on 'foo'.\n    psub = await js.pull_subscribe(\"foo\", \"psub\")\n\n    # Fetch and ack messagess from consumer.\n    for i in range(0, 10):\n        msgs = await psub.fetch(1)\n        for msg in msgs:\n            await msg.ack()\n            print(msg)\n\n    # Create single ephemeral push based subscriber.\n    sub = await js.subscribe(\"foo\")\n    msg = await sub.next_msg()\n    await msg.ack()\n\n    # Create single push based subscriber that is durable across restarts.\n    sub = await js.subscribe(\"foo\", durable=\"myapp\")\n    msg = await sub.next_msg()\n    await msg.ack()\n\n    # Create deliver group that will be have load balanced messages.\n    async def qsub_a(msg):\n        print(\"QSUB A:\", msg)\n        await msg.ack()\n\n    async def qsub_b(msg):\n        print(\"QSUB B:\", msg)\n        await msg.ack()\n    await js.subscribe(\"foo\", \"workers\", cb=qsub_a)\n    await js.subscribe(\"foo\", \"workers\", cb=qsub_b)\n\n    for i in range(0, 10):\n        ack = await js.publish(\"foo\", f\"hello world: {i}\".encode())\n        print(\"\\t\", ack)\n\n    # Create ordered consumer with flow control and heartbeats\n    # that auto resumes on failures.\n    osub = await js.subscribe(\"foo\", ordered_consumer=True)\n    data = bytearray()\n\n    while True:\n        try:\n            msg = await osub.next_msg()\n            data.extend(msg.data)\n        except TimeoutError:\n            break\n    print(\"All data in stream:\", len(data))\n\n    await nc.close()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Configuring TLS with Custom SSL Context for NATS in Python\nDESCRIPTION: Shows how to configure TLS connections to NATS using a custom SSL context with client certificates and server verification. Demonstrates loading certificates from files and configuring server authentication.\nSOURCE: https://github.com/nats-io/nats.py/blob/main/README.md#2025-04-20_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nssl_ctx = ssl.create_default_context(purpose=ssl.Purpose.SERVER_AUTH)\nssl_ctx.load_verify_locations('ca.pem')\nssl_ctx.load_cert_chain(certfile='client-cert.pem',\n                        keyfile='client-key.pem')\nawait nats.connect(servers=[\"tls://127.0.0.1:4443\"], tls=ssl_ctx, tls_hostname=\"localhost\")\n```\n\n----------------------------------------\n\nTITLE: Connecting to NATS with User Credentials\nDESCRIPTION: Shows how to connect to NATS using user credentials file for authentication, which contains JWT tokens and NKeys for secure authentication.\nSOURCE: https://github.com/nats-io/nats.py/blob/main/README.md#2025-04-20_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nawait nats.connect(\"tls://connect.ngs.global:4222\", user_credentials=\"/path/to/secret.creds\")\n```\n\n----------------------------------------\n\nTITLE: Using TLS with Default Context for NATS in Python\nDESCRIPTION: Shows how to connect to NATS with TLS using the default SSL context by simply specifying the 'tls://' URL scheme. This approach creates a default SSL context automatically.\nSOURCE: https://github.com/nats-io/nats.py/blob/main/README.md#2025-04-20_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport ssl\nfrom nats.aio.client import Client as NATS\n\nasync def run():\n    nc = NATS()\n    await nc.connect(\"tls://demo.nats.io:4443\")\n```\n\n----------------------------------------\n\nTITLE: Installing NATS Python Client with pip\nDESCRIPTION: Command for installing the NATS Python client library via pip package manager.\nSOURCE: https://github.com/nats-io/nats.py/blob/main/README.md#2025-04-20_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install nats-py\n```\n\n----------------------------------------\n\nTITLE: Installing NATS Python Client with NKEYS Support\nDESCRIPTION: Command for installing the NATS Python client with NKEYS support, which enables the use of NATS v2.0 authentication features.\nSOURCE: https://github.com/nats-io/nats.py/blob/main/README.md#2025-04-20_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npip install nats-py[nkeys]\n```\n\n----------------------------------------\n\nTITLE: NATS.py Implementation Checklist\nDESCRIPTION: Markdown checklist showing completed and pending features for the NATS Python client implementation. Tracks core functionality, protocol handling, authentication, and Python-specific features.\nSOURCE: https://github.com/nats-io/nats.py/blob/main/todo.md#2025-04-20_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- [X] connecting to server {info, connect, ping}\n- [X] ping/pong interval\n- [X] publishing\n- [X] subscriptions\n- [X] request/response\n- [X] protocol parsing\n- [X] client states\n- [X] pending buffer\n- [X] clustering reconnect\n- [X] authentication and connect options\n- [X] tests\n- [X] example tools\n- [X] pypi, etc...\n- [X] TLS\n- [X] async INFO protocol\n- [X] No Echo\n- [X] Python 3.7 updates\n- [X] Improved connect\n- [X] io_loop becomes loop parameter\n- [X] Drain Mode\n- [X] Connect timeout\n- [X] Adopt async/await in client\n- [X] Subscription object on subscribe\n- [X] Error handler yields the subscription\n- [ ] Use asyncio.Protocol\n```\n\n----------------------------------------\n\nTITLE: Git Commit Sign-off Command Example\nDESCRIPTION: Shows how to perform a sign-off with git when committing changes to certify your contribution is your original work and licensed under Apache-2.0. This is required for all contributions to the nats.py project.\nSOURCE: https://github.com/nats-io/nats.py/blob/main/CONTRIBUTING.md#2025-04-20_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit commit -s\n```\n\n----------------------------------------\n\nTITLE: Displaying External Dependencies Table in Markdown\nDESCRIPTION: This code snippet creates a Markdown table listing the external dependencies used in the NATS Python client repository. It includes the dependency name and its corresponding license.\nSOURCE: https://github.com/nats-io/nats.py/blob/main/dependencies.md#2025-04-20_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n| Dependency | License |\n|-|-|\n| asyncio | Python Software Foundation License |\n| https://github.com/pyca/pynacl | Apache License 2.0 |\n| github.com/aio-libs/aiohttp | Apache License 2.0 |\n```"
  }
]