[
  {
    "owner": "dry-python",
    "repo": "returns",
    "content": "TITLE: Advanced Functional Flow with FutureResult in Python\nDESCRIPTION: Shows an advanced pattern using flow and bind from returns library to create a more concise functional pipeline for async operations.\nSOURCE: https://github.com/dry-python/returns/blob/master/README.md#2025-04-21_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom returns.pointfree import bind\nfrom returns.pipeline import flow\n\ndef main(user_id: int) -> FutureResultE[bool]:\n    return flow(\n        fetch_user(user_id),\n        bind(get_user_permissions),\n        bind(ensure_allowed),\n    )\n```\n\n----------------------------------------\n\nTITLE: API Request with Result Container in Python\nDESCRIPTION: Refactored implementation using the returns library's Result container to handle errors safely. It uses flow and bind for function composition, and the @safe decorator to convert exceptions into Failure instances, creating a declarative error handling pipeline.\nSOURCE: https://github.com/dry-python/returns/blob/master/README.md#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport requests\nfrom returns.result import Result, safe\nfrom returns.pipeline import flow\nfrom returns.pointfree import bind\n\ndef fetch_user_profile(user_id: int) -> Result['UserProfile', Exception]:\n    \"\"\"Fetches `UserProfile` TypedDict from foreign API.\"\"\"\n    return flow(\n        user_id,\n        _make_request,\n        bind(_parse_json),\n    )\n\n@safe\ndef _make_request(user_id: int) -> requests.Response:\n    # TODO: we are not yet done with this example, read more about `IO`:\n    response = requests.get('/api/users/{0}'.format(user_id))\n    response.raise_for_status()\n    return response\n\n@safe\ndef _parse_json(response: requests.Response) -> 'UserProfile':\n    return response.json()\n```\n\n----------------------------------------\n\nTITLE: API Request with IOResult Container in Python\nDESCRIPTION: Advanced implementation using IOResult to handle both impurity and possible failures. This separates pure and impure code, using impure_safe for network requests that can fail, and bind_result for composing the operations together with proper type safety.\nSOURCE: https://github.com/dry-python/returns/blob/master/README.md#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport requests\nfrom returns.io import IOResult, impure_safe\nfrom returns.result import safe\nfrom returns.pipeline import flow\nfrom returns.pointfree import bind_result\n\ndef fetch_user_profile(user_id: int) -> IOResult['UserProfile', Exception]:\n    \"\"\"Fetches `UserProfile` TypedDict from foreign API.\"\"\"\n    return flow(\n        user_id,\n        _make_request,\n        # before: def (Response) -> UserProfile\n        # after safe: def (Response) -> ResultE[UserProfile]\n        # after bind_result: def (IOResultE[Response]) -> IOResultE[UserProfile]\n        bind_result(_parse_json),\n    )\n\n@impure_safe\ndef _make_request(user_id: int) -> requests.Response:\n    response = requests.get('/api/users/{0}'.format(user_id))\n    response.raise_for_status()\n    return response\n\n@safe\ndef _parse_json(response: requests.Response) -> 'UserProfile':\n    return response.json()\n```\n\n----------------------------------------\n\nTITLE: Using RequiresContextFutureResult for Asynchronous Error Handling\nDESCRIPTION: Example demonstrating how to use RequiresContextFutureResult to write synchronous code that executes asynchronously. This pattern allows for handling context-dependent async operations that might fail.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/context.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# From tests/test_examples/test_context/test_reader_future_result.py\n# (Referenced in documentation but not explicitly shown)\n```\n\n----------------------------------------\n\nTITLE: IOResultE Implementation\nDESCRIPTION: Shows how to properly handle impure operations that might fail using IOResultE container.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/io.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport requests\nimport db\nfrom returns.io import IOResultE\n\ndef can_book_seats(\n    number_of_seats: int,\n    place_id: int,\n) -> IOResultE[bool]:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Refactoring Code with Maybe Container\nDESCRIPTION: Example of refactoring nested None checks using the Maybe container for improved readability and safety.\nSOURCE: https://github.com/dry-python/returns/blob/master/README.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nuser: Optional[User]\n\n# Type hint here is optional, it only helps the reader here:\ndiscount_program: Maybe['DiscountProgram'] = Maybe.from_optional(\n    user,\n).bind_optional(  # This won't be called if `user is None`\n    lambda real_user: real_user.get_balance(),\n).bind_optional(  # This won't be called if `real_user.get_balance()` is None\n    lambda balance: balance.credit_amount(),\n).bind_optional(  # And so on!\n    lambda credit: choose_discount(credit) if credit > 0 else None,\n)\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of Result for Error Handling in Python\nDESCRIPTION: Demonstrates how to use Result, Success, and Failure types to handle potential failures in a user search function without raising exceptions.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/result.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom returns.result import Result, Success, Failure\n\ndef find_user(user_id: int) -> Result['User', str]:\n    user = User.objects.filter(id=user_id)\n    if user.exists():\n        return Success(user[0])\n    return Failure('User was not found')\n\nuser_search_result = find_user(1)\n# => Success(User{id: 1, ...})\n\nuser_search_result = find_user(0)  # id 0 does not exist!\n# => Failure('User was not found')\n```\n\n----------------------------------------\n\nTITLE: Handling Async Exceptions with FutureResult in Python\nDESCRIPTION: Demonstrates how to convert a throwing coroutine into a safe FutureResult using the future_safe decorator. The example shows error handling without try/except blocks.\nSOURCE: https://github.com/dry-python/returns/blob/master/README.md#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nimport anyio\nfrom returns.future import future_safe\nfrom returns.io import IOFailure\n\n@future_safe\nasync def raising():\n    raise ValueError('Not so fast!')\n\nioresult = anyio.run(raising.awaitable)  # all `Future`s return IO containers\nassert ioresult == IOFailure(ValueError('Not so fast!'))  # True\n```\n\n----------------------------------------\n\nTITLE: Mixing Sync and Async Code with Future Container in Python\nDESCRIPTION: Demonstration of using the Future container to call async functions from sync context. This example shows how to compose a synchronous function that uses an asynchronous function under the hood, without making the outer function async.\nSOURCE: https://github.com/dry-python/returns/blob/master/README.md#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nasync def first() -> int:\n    return 1\n\ndef second():  # How can we call `first()` from here?\n    return first() + 1  # Boom! Don't do this. We illustrate a problem here.\n```\n\n----------------------------------------\n\nTITLE: Resource Management with managed in Returns Library\nDESCRIPTION: Demonstrates the managed() function for safe resource handling with proper acquisition and release. This example shows how to read a file safely, ensuring it's closed properly regardless of the operation result.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/pipeline.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import TextIO\n>>> from returns.pipeline import managed, is_successful\n>>> from returns.result import ResultE\n>>> from returns.io import IOResultE, impure_safe\n\n>>> def read_file(file_obj: TextIO) -> IOResultE[str]:\n...     return impure_safe(file_obj.read)()  # this will be the final result\n\n>>> def close_file(\n...     file_obj: TextIO,\n...     file_contents: ResultE[str],\n... ) -> IOResultE[None]:  # sometimes might require to use `untap`\n...     return impure_safe(file_obj.close)()  # this value will be dropped\n\n>>> managed_read = managed(read_file, close_file)\n\n>>> read_result = managed_read(\n...     impure_safe(lambda filename: open(filename, 'r'))('pyproject.toml'),\n... )\n>>> assert is_successful(read_result)  # file content is inside `IOSuccess`\n```\n\n----------------------------------------\n\nTITLE: Unwrapping Container Values with unwrap in Returns\nDESCRIPTION: Shows how to extract values from containers using the unwrap method, which returns the value if possible or raises UnwrapFailedError otherwise. This demonstrates successful unwrapping with Success and Some containers.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/railway.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.result import Failure, Success\n>>> from returns.maybe import Some, Nothing\n\n>>> assert Success(1).value_or(None) == 1\n>>> assert Some(0).unwrap() == 0\n```\n\n----------------------------------------\n\nTITLE: Converting Sync Functions to Async with @asyncify Decorator in Python\nDESCRIPTION: Demonstrates the use of the @asyncify decorator to transform regular synchronous functions into asynchronous ones for composition with Future containers.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/future.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> import anyio\n>>> from inspect import iscoroutinefunction\n>>> from returns.future import asyncify\n\n>>> @asyncify\n... def your_function(x: int) -> int:\n...     return x + 1\n\n>>> assert iscoroutinefunction(your_function) is True\n>>> assert anyio.run(your_function, 1) == 2\n```\n\n----------------------------------------\n\nTITLE: Using @safe Decorator to Handle Exceptions with Result in Python\nDESCRIPTION: Shows how to use the @safe decorator to convert functions that might throw exceptions into functions that return Result types, with options to specify which exceptions to handle.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/result.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.result import Success, safe\n\n>>> @safe  # Will convert type to: Callable[[int], Result[float, Exception]]\n... def divide(number: int) -> float:\n...     return number / number\n\n>>> assert divide(1) == Success(1.0)\n>>> str(divide(0))\n'<Failure: division by zero>'\n```\n\n----------------------------------------\n\nTITLE: Differentiating Map vs Bind Methods with Result in Python\nDESCRIPTION: Explains when to use map (for pure functions) versus bind (for functions that return Result) with practical examples of JSON parsing.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/result.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> import json\n>>> from typing import Dict\n\n>>> from returns.result import Failure, Result, Success, safe\n\n>>> # `cast_to_bool` doesn't produce any side-effect\n>>> def cast_to_bool(arg: int) -> bool:\n...     return bool(arg)\n\n>>> # `parse_json` can produce Exceptions, so we use the `safe` decorator\n>>> # to prevent any kind of exceptions\n>>> @safe\n... def parse_json(arg: str) -> Dict[str, str]:\n...     return json.loads(arg)\n\n>>> assert Success(1).map(cast_to_bool) == Success(True)\n>>> assert Success('{\"example\": \"example\"}').bind(parse_json) == Success({\"example\": \"example\"})\n>>> assert Success('').bind(parse_json).alt(str) == Failure('Expecting value: line 1 column 1 (char 0)')\n```\n\n----------------------------------------\n\nTITLE: Composing Containers with pipe in Returns Library\nDESCRIPTION: Demonstrates using pipe() to compose regular functions with container-returning functions using the bind pointfree function. Creates a transaction pipeline that can be executed with different inputs.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/pipeline.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.pipeline import pipe\n>>> from returns.result import Result, Success, Failure\n>>> from returns.pointfree import bind\n\n>>> def regular_function(arg: int) -> float:\n...     return float(arg)\n\n>>> def returns_container(arg: float) -> Result[str, ValueError]:\n...     if arg != 0:\n...         return Success(str(arg))\n...     return Failure(ValueError('Wrong arg'))\n\n>>> def also_returns_container(arg: str) -> Result[str, ValueError]:\n...     return Success(arg + '!')\n\n>>> transaction = pipe(\n...     regular_function,  # composes easily\n...     returns_container,  # also composes easily, but returns a container\n...     # So we need to `bind` the next function to allow it to consume\n...     # the container from the previous step.\n...     bind(also_returns_container),\n... )\n>>> result = transaction(1)  # running the pipeline\n>>> assert result == Success('1.0!')\n```\n\n----------------------------------------\n\nTITLE: Handling Specific Exceptions with @safe Decorator in Python\nDESCRIPTION: Demonstrates how to configure the @safe decorator to handle only specific exceptions while allowing others to be raised normally.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/result.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> @safe(exceptions=(ZeroDivisionError,))  # Other exceptions will be raised\n... def divide(number: int) -> float:\n...     if number > 10:\n...         raise ValueError('Too big')\n...     return number / number\n\n>>> assert divide(5) == Success(1.0)\n>>> assert divide(0).failure()\n>>> divide(15)\nTraceback (most recent call last):\n  ...\nValueError: Too big\n```\n\n----------------------------------------\n\nTITLE: Using flow to Compose Multiple Functions in Python Returns Library\nDESCRIPTION: Demonstrates how flow() function allows sequential composition of multiple functions with an initial value. Flow processes functions from left to right, applying each to the result of the previous step.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/pipeline.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.pipeline import flow\n>>> assert flow(\n...     [1, 2, 3],\n...     lambda collection: max(collection),\n...     lambda max_number: -max_number,\n... ) == -3\n```\n\n----------------------------------------\n\nTITLE: Using maybe Decorator for Optional Return Values in Python\nDESCRIPTION: Shows how to use the maybe decorator to convert functions that return Optional values to functions that return Maybe values, improving type safety.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/maybe.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import Optional\n>>> from returns.maybe import Maybe, Some, maybe\n\n>>> @maybe\n... def number(num: int) -> Optional[int]:\n...     if num > 0:\n...         return num\n...     return None\n\n>>> result: Maybe[int] = number(1)\n>>> assert result == Some(1)\n```\n\n----------------------------------------\n\nTITLE: Functional Style Async Composition with FutureResult in Python\nDESCRIPTION: Demonstrates how to rewrite async code in a functional style using FutureResult container. This approach eliminates explicit await statements and provides built-in error handling.\nSOURCE: https://github.com/dry-python/returns/blob/master/README.md#2025-04-21_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nimport anyio\nfrom returns.future import FutureResultE, future_safe\nfrom returns.io import IOSuccess, IOFailure\n\n@future_safe\nasync def fetch_user(user_id: int) -> 'User':\n    ...\n\n@future_safe\nasync def get_user_permissions(user: 'User') -> 'Permissions':\n    ...\n\n@future_safe\nasync def ensure_allowed(permissions: 'Permissions') -> bool:\n    ...\n\ndef main(user_id: int) -> FutureResultE[bool]:\n    # We can now turn `main` into a sync function, it does not `await` at all.\n    # We also don't care about exceptions anymore, they are already handled.\n    return fetch_user(user_id).bind(get_user_permissions).bind(ensure_allowed)\n\ncorrect_user_id: int  # has required permissions\nbanned_user_id: int  # does not have required permissions\nwrong_user_id: int  # does not exist\n\n# We can have correct business results:\nassert anyio.run(main(correct_user_id).awaitable) == IOSuccess(True)\nassert anyio.run(main(banned_user_id).awaitable) == IOSuccess(False)\n\n# Or we can have errors along the way:\nassert anyio.run(main(wrong_user_id).awaitable) == IOFailure(\n    UserDoesNotExistError(...),\n)\n```\n\n----------------------------------------\n\nTITLE: Using Future Container for Async Composition in Python\nDESCRIPTION: Implementation using the Future container to properly handle async code from a sync context. It allows mapping over the future async value without making the calling function async, while maintaining proper async execution.\nSOURCE: https://github.com/dry-python/returns/blob/master/README.md#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom returns.future import Future\n\ndef second() -> Future[int]:\n    return Future(first()).map(lambda num: num + 1)\n```\n\n----------------------------------------\n\nTITLE: Using map Method with Result Container in Python\nDESCRIPTION: Demonstrates how to use the map method to transform values within a Result container. The double function transforms the internal state by multiplying it by 2, while preserving the Success context of the Result.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/container.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import Any\n>>> from returns.result import Success, Result\n\n>>> def double(state: int) -> int:\n...     return state * 2\n\n>>> result: Result[int, Any] = Success(1).map(double)\n>>> assert str(result) == '<Success: 2>'\n\n>>> result: Result[int, Any] = result.map(lambda state: state + 1)\n>>> assert str(result) == '<Success: 3>'\n```\n\n----------------------------------------\n\nTITLE: Using @future Decorator for Async Functions in Python\nDESCRIPTION: Demonstrates the use of the @future decorator to transform async functions into Future containers, simplifying async-to-sync conversion.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/future.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> import anyio\n>>> from returns.future import future, Future\n>>> from returns.io import IO\n\n>>> @future\n... async def test(arg: int) -> float:\n...     return arg / 2\n\n>>> future_instance = test(1)\n>>> assert isinstance(future_instance, Future)\n>>> assert anyio.run(future_instance.awaitable) == IO(0.5)\n```\n\n----------------------------------------\n\nTITLE: Working with Multiple Containers Using curry and apply\nDESCRIPTION: Demonstrates how to work with multiple container arguments using curry and apply methods. This example shows summing values from two IO containers while maintaining the IO context.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/container.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.curry import curry\n>>> from returns.io import IO\n\n>>> @curry\n... def sum_two_numbers(first: int, second: int) -> int:\n...     return first + second\n\n>>> one = IO(1)\n>>> two = IO(2)\n>>> assert two.apply(one.apply(IO(sum_two_numbers))) == IO(3)\n```\n\n----------------------------------------\n\nTITLE: Using flow with Pointfree Functions and Containers in Returns\nDESCRIPTION: Shows how to use flow() with pointfree functions and Result containers, demonstrating both success and failure cases. The example combines regular functions and container-returning functions using bind.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/pipeline.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.result import Result, Success, Failure\n>>> from returns.pointfree import bind\n>>> from returns.pipeline import flow\n\n>>> def regular_function(arg: int) -> float:\n...     return float(arg)\n\n>>> def returns_container(arg: float) -> Result[str, ValueError]:\n...     if arg != 0:\n...         return Success(str(arg))\n...     return Failure(ValueError('Wrong arg'))\n\n>>> def also_returns_container(arg: str) -> Result[str, ValueError]:\n...     return Success(arg + '!')\n\n>>> assert flow(\n...     1,  # initial value\n...     regular_function,  # composes easily\n...     returns_container,  # also composes easily, but returns a container\n...     # So we need to `bind` the next function to allow it to consume\n...     # the container from the previous step.\n...     bind(also_returns_container),\n... ) == Success('1.0!')\n\n>>> # And this will fail:\n>>> assert flow(\n...     0,  # initial value\n...     regular_function,  # composes easily\n...     returns_container,  # also composes easily, but returns a container\n...     # So we need to `bind` the next function to allow it to consume\n...     # the container from the previous step.\n...     bind(also_returns_container),\n... ).failure().args == ('Wrong arg', )\n```\n\n----------------------------------------\n\nTITLE: Creating Maybe Container Instances in Python\nDESCRIPTION: Demonstrates how to create Maybe container instances using the from_optional and from_value methods. The from_optional method returns Some for non-None values and Nothing for None, while from_value always returns Some even for None values.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/maybe.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.maybe import Maybe\n\n>>> assert str(Maybe.from_optional(1)) == '<Some: 1>'\n>>> assert str(Maybe.from_optional(None)) == '<Nothing>'\n```\n\n----------------------------------------\n\nTITLE: Transforming Error Types with alt Method in Returns\nDESCRIPTION: Demonstrates how to transform the error type in a failed container using the alt method. The alt method only works when the container is in a failed state and is the opposite of the map method.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/railway.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.result import Failure\n>>> assert Failure(1).alt(str) == Failure('1')\n```\n\n----------------------------------------\n\nTITLE: Impure Decorator Usage\nDESCRIPTION: Shows how to use the impure decorator to handle existing impure Python functions.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/io.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom returns.io import impure\n\nname: IO[str] = impure(input)('What is your name?')\n```\n\n----------------------------------------\n\nTITLE: Converting Between Maybe and Result Types in Python\nDESCRIPTION: This code demonstrates how to use the maybe_to_result and result_to_maybe converters to transform between Maybe and Result container types. It shows successful conversions and how to handle defaults for Nothing values.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/converters.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.converters import maybe_to_result, result_to_maybe\n>>> from returns.maybe import Maybe, Some, Nothing\n>>> from returns.result import Failure, Result, Success\n\n>>> result: Result[int, Exception] = Success(1)\n>>> maybe: Maybe[int] = result_to_maybe(result)\n>>> assert maybe == Some(1)\n\n>>> new_result: Result[int, None] = maybe_to_result(maybe)\n>>> assert new_result == Success(1)\n\n>>> failure_with_default: Result[int, str] = maybe_to_result(Nothing, 'abc')\n>>> assert failure_with_default == Failure('abc')\n```\n\n----------------------------------------\n\nTITLE: Handling Exceptions with @future_safe Decorator in Python\nDESCRIPTION: Shows how to use the @future_safe decorator to convert async functions into FutureResult containers, providing safe exception handling.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/future.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> import anyio\n>>> from returns.future import future_safe, FutureResult\n>>> from returns.io import IOSuccess, IOFailure\n\n>>> @future_safe\n... async def test(arg: int) -> float:\n...     return 1 / arg\n\n>>> future_instance = test(2)\n>>> assert isinstance(future_instance, FutureResult)\n>>> assert anyio.run(future_instance.awaitable) == IOSuccess(0.5)\n\n>>> str(anyio.run(test(0).awaitable))  # this will fail\n'<IOResult: <Failure: division by zero>>'\n```\n\n----------------------------------------\n\nTITLE: Combining managed with flow for Advanced Resource Handling\nDESCRIPTION: Shows how to combine managed() with flow() and other pipeline functions for a complete file processing pipeline. This example reads a TOML file, parses it, and extracts a project name while handling resources properly.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/pipeline.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> import tomlkit\n>>> from returns.pipeline import flow\n>>> from returns.pointfree import bind_result\n>>> from returns.result import safe\n>>> from returns.io import IOSuccess\n\n>>> @safe\n... def parse_toml(file_contents: str) -> dict:\n...     return tomlkit.parse(file_contents)\n\n>>> @safe\n... def get_project_name(parsed: dict) -> str:\n...     return parsed['tool']['poetry']['name']\n\n>>> pipeline_result = flow(\n...     'pyproject.toml',  # filename we work with\n...     impure_safe(lambda filename: open(filename, 'r')),\n...     managed_read,\n...     bind_result(parse_toml),\n...     bind_result(get_project_name),\n... )\n>>> assert pipeline_result == IOSuccess('returns')\n```\n\n----------------------------------------\n\nTITLE: Using value_or Method for Safe Value Extraction in Returns\nDESCRIPTION: Demonstrates the value_or helper method which provides a safe way to extract values from containers with a fallback value when the container is in a failed state.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/railway.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.result import Success, Failure\n>>> assert Success(1).value_or(None) == 1\n>>> assert Failure(1).value_or(None) is None\n```\n\n----------------------------------------\n\nTITLE: Implementing Celery Task with RequiresContext Dependencies\nDESCRIPTION: Demonstrates how to integrate RequiresContext with Celery tasks, including dependency container setup and error handling. Shows practical usage of the sync_permissions function in a task queue context.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/context.rst#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# tasks.py\nfrom celery import shared_task\nfrom returns.functions import raise_exception\n\nfrom logic.usecases.sync_permissions import sync_permissions\nfrom infrastructure.implemented import Container\nfrom infrastructure.services import bi\nfrom infrastructure.repositories import db\n\n@shared_task(autoretry_for=(ConnectionError,), max_retries=3)\ndef queue_sync_permissions():\n    # Building the container with dependencies to pass it into the context.\n    # We also make sure that we don't forget to raise internal exceptions\n    # and trigger celery retries.\n    return sync_permissions().alt(raise_exception)(Container(\n        fetch_metadata=db.select_user_metadata,\n        get_user_permissions=bi.permissions_from_user,\n        update_bi_permissions=bi.put_user_permissions,\n    ))\n```\n\n----------------------------------------\n\nTITLE: Creating Maybe Containers from Optional Values\nDESCRIPTION: Demonstrates how to create Maybe containers from Optional values using the from_optional method. It shows how a value creates a Some container while None creates a Nothing container.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/container.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.maybe import Maybe, Some, Nothing\n>>> assert Maybe.from_optional(1) == Some(1)\n>>> assert Maybe.from_optional(None) == Nothing\n```\n\n----------------------------------------\n\nTITLE: Using cond Method for Result Type Handling\nDESCRIPTION: Shows how to use the cond method to simplify conditional Result type handling, replacing traditional if-else statements with a more functional approach.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/methods.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom returns import methods\nfrom returns.result import Failure, Result, Success\n\ndef is_numeric(string: str) -> Result[str, str]:\n    return methods.cond(\n        Result,\n        string.isnumeric(),\n        'It is a number',\n        'It is not a number',\n   )\n\nassert is_numeric('42') == Success('It is a number')\nassert is_numeric('text') == Failure('It is not a number')\n```\n\n----------------------------------------\n\nTITLE: Demonstrating RequiresContext Composition\nDESCRIPTION: This snippet shows how to compose functions using RequiresContext, allowing for better composition of context-dependent functions.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/context.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom returns.context import RequiresContext\n\ndef first(limit: int) -> RequiresContext[bool, str]:\n    def inner(deps: str) -> bool:\n        return len(deps) > limit\n    return RequiresContext(inner)  # wrapping function here!\n\nassert first(1).map(bool_to_str)('abc') == 'ok'\nassert first(5).map(bool_to_str)('abc') == 'nope'\n```\n\n----------------------------------------\n\nTITLE: Refactoring View Function with RequiresContext\nDESCRIPTION: This snippet demonstrates how to refactor the Django view function to use RequiresContext, allowing for dependency injection of settings.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/context.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom django.conf import settings\nfrom django.http import HttpRequest, HttpResponse\nfrom words_app.logic import calculate_points\n\ndef view(request: HttpRequest) -> HttpResponse:\n    user_word: str = request.POST['word']  # just an example\n    points = calculate_points(user_words)(settings)  # passing the dependencies\n    ...  # later you show the result to user somehow\n```\n\n----------------------------------------\n\nTITLE: Function Composition with compose in Python\nDESCRIPTION: Demonstrates how to compose two functions together using the compose utility. Combines int and bool functions to create a new function that converts strings to boolean values.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/functions.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.functions import compose\n\n>>> bool_after_int = compose(int, bool)\n>>> assert bool_after_int('1') is True\n>>> assert bool_after_int('0') is False\n```\n\n----------------------------------------\n\nTITLE: Pipeline Composition Example with Python Returns\nDESCRIPTION: Demonstrates how to compose functions in a pipeline using the Returns library's pipe function with ResultE container.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/pointfree.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom returns.pipeline import pipe\nfrom returns.result import ResultE\n\ndef returns_result(arg: int) -> ResultE[int]:\n    ...\n\ndef works_with_result(arg: int) -> ResultE[int]:\n    ...\n\ndef finish_work(arg: int) -> ResultE[int]:\n    ...\n\npipe(\n    returns_result,\n    works_with_result,  # does not compose! Needs a container for input\n    finish_work,  # does not compose either!\n)\n```\n\n----------------------------------------\n\nTITLE: Distinguishing Some(None) from Nothing in Python\nDESCRIPTION: Shows how Some(None) is different from Nothing and how to work with both values in a dictionary context.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/maybe.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> assert Some(None) != Nothing\n```\n\n----------------------------------------\n\nTITLE: Using @attempt Decorator for Exception Handling in Python\nDESCRIPTION: Shows how to use the @attempt decorator which works similar to @safe but wraps the argument that caused the exception in a Failure container instead of the exception itself.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/result.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.result import Failure, Success, attempt\n\n>>> @attempt\n... def divide_itself(number: int) -> float:\n...     return number / number\n\n>>> assert divide_itself(2) == Success(1.0)\n>>> assert divide_itself(0) == Failure(0)\n```\n\n----------------------------------------\n\nTITLE: Creating Lazy IO Functions in Python\nDESCRIPTION: Demonstrates how to create a lazy IO function that will only be executed when called, rather than immediately. This pattern allows for delaying execution of IO operations until needed.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/io.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.io import IO\n>>> lazy = lambda: IO(1)\n>>> assert lazy() == IO(1)\n```\n\n----------------------------------------\n\nTITLE: Complete Container Implementation\nDESCRIPTION: Full implementation of a Container class that combines Applicative and Bindable interfaces with all required methods.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/interfaces.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable, TypeVar\n\nfrom returns.interfaces.container import Container1\nfrom returns.primitives.hkt import SupportsKind1, Kind1, dekind\nfrom returns.primitives.container import BaseContainer\n\n_NumberType = TypeVar('_NumberType')\n_NewNumberType = TypeVar('_NewNumberType')\n\nclass Number(\n    BaseContainer,\n    SupportsKind1['Number', _NumberType],\n    Container1[_NumberType],\n):\n    def __init__(self, inner_value: _NumberType) -> None:\n        super().__init__(inner_value)\n\n    def map(\n        self,\n        function: Callable[[_NumberType], _NewNumberType]\n    ) -> 'Number[_NewNumberType]':\n        return Number(function(self._inner_value))\n\n    def bind(\n        self,\n        function: Kind1[\n            'Number',\n            Callable[[_NumberType], 'Number[_NewNumberType]'],\n        ],\n    ) -> 'Number[_NewNumberType]':\n        return dekind(function(self._inner_value))\n\n    def apply(\n        self,\n        container: Kind1[\n            'Number',\n            Callable[[_NumberType], _NewNumberType],\n        ],\n    ) -> 'Number[_NewNumberType]':\n        return Number.from_value(\n            container._inner_value(self._inner_value),\n        )\n\n    @classmethod\n    def from_value(\n        cls,\n        inner_value: _NewNumberType,\n    ) -> 'Number[_NewNumberType]':\n        return Number(inner_value)\n```\n\n----------------------------------------\n\nTITLE: Unwrapping Failed States with failure Method in Returns\nDESCRIPTION: Shows how to extract the error value from failed containers using the failure method, which works on failed containers but raises an exception when used on successful ones.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/railway.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> assert Failure(1).failure() == 1\n>>> Success(1).failure()\nTraceback (most recent call last):\n  ...\nreturns.primitives.exceptions.UnwrapFailedError\n```\n\n----------------------------------------\n\nTITLE: Function Lifting with IO\nDESCRIPTION: Demonstrates how to lift regular functions to work with IO containers using map operations.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/io.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.io import IO\n>>> from returns.pointfree import map_\n\n>>> def regular_function(arg: int) -> float:\n...     return arg / 2  # not an `IO` operation\n\n>>> container = IO(1)\n>>> io = container.map(regular_function)\n>>> assert io == IO(0.5)\n\n>>> io = map_(regular_function)(container)\n>>> assert io == IO(0.5)\n```\n\n----------------------------------------\n\nTITLE: Using @curry Decorator for Partial Application\nDESCRIPTION: This snippet demonstrates how to use the @curry decorator to create functions that can be progressively applied with arguments, delaying execution until all required arguments are provided.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/curry.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.curry import curry\n\n>>> @curry\n... def function(first: int, second: str) -> bool:\n...     return len(second) > first\n\n>>> assert function(1)('a') is False\n>>> assert function(1, 'a') is False\n>>> assert function(2)('abc') is True\n>>> assert function(2, 'abc') is True\n```\n\n----------------------------------------\n\nTITLE: Implementing RequiresContext for Point Calculation\nDESCRIPTION: This snippet shows how to use RequiresContext to implement the point calculation logic, allowing for dependency injection of the word threshold.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/context.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Protocol\nfrom returns.context import RequiresContext\n\nclass _Deps(Protocol):  # we rely on abstractions, not direct values or types\n    WORD_THRESHOLD: int\n\ndef calculate_points(word: str) -> RequiresContext[int, _Deps]:\n    guessed_letters_count = len([letter for letter in word if letter != '.'])\n    return _award_points_for_letters(guessed_letters_count)\n\ndef _award_points_for_letters(guessed: int) -> RequiresContext[int, _Deps]:\n    return RequiresContext(\n        lambda deps: 0 if guessed < deps.WORD_THRESHOLD else guessed,\n    )\n```\n\n----------------------------------------\n\nTITLE: Creating Reusable Function Pipelines with pipe in Returns Library\nDESCRIPTION: Demonstrates how pipe() creates a reusable function pipeline that can be applied to different values. Unlike flow(), pipe() creates a callable that can be invoked later with any input value.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/pipeline.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.pipeline import pipe\n\n>>> pipeline = pipe(str, lambda x: x + 'b', str.upper)\n>>> assert pipeline(1) == '1B'\n```\n\n----------------------------------------\n\nTITLE: Using Type Annotations with RequiresContext.ask()\nDESCRIPTION: Example showing the recommended approach for using RequiresContext.ask() with proper type annotations, which helps mypy understand the context types being used.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/context.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom returns.context import RequiresContext\n\ndef some_context(*args, **kwargs) -> RequiresContext[str, int]:\n    def factory(deps: int) -> RequiresContext[str, int]:\n        ...\n    return RequiresContext[str, int].ask().bind(factory)\n```\n\n----------------------------------------\n\nTITLE: Working with Iterable of Containers Using Fold.loop\nDESCRIPTION: Shows how to process an iterable of IO containers and fold them into a single container. This example sums ten random number containers into a single IO container with their total.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/container.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> import random\n>>> from returns.io import IO\n\n>>> def random_number() -> IO[int]:\n...     return IO(2)  # Example, basically alias of ``random.randint(1, 5)``\n\n>>> numbers = [random_number() for _ in range(10)]\n>>> assert len(numbers) == 10\n>>> assert all(isinstance(number, IO) for number in numbers)\n```\n\n----------------------------------------\n\nTITLE: Using RequiresContext Container in Django\nDESCRIPTION: Example of using RequiresContext container for dependency injection in a Django-based game, allowing for configurable settings without passing through the entire call stack.\nSOURCE: https://github.com/dry-python/returns/blob/master/README.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom django.conf import settings\nfrom django.http import HttpRequest, HttpResponse\nfrom words_app.logic import calculate_points\n\ndef view(request: HttpRequest) -> HttpResponse:\n    user_word: str = request.POST['word']  # just an example\n    points = calculate_points(user_word)(settings)  # passing the dependencies\n    ...  # later you show the result to user somehow\n\n# Somewhere in your `words_app/logic.py`:\n\nfrom typing import Protocol\nfrom returns.context import RequiresContext\n\nclass _Deps(Protocol):  # we rely on abstractions, not direct values or types\n    WORD_THRESHOLD: int\n\ndef calculate_points(word: str) -> RequiresContext[int, _Deps]:\n    guessed_letters_count = len([letter for letter in word if letter != '.'])\n    return _award_points_for_letters(guessed_letters_count)\n\ndef _award_points_for_letters(guessed: int) -> RequiresContext[int, _Deps]:\n    return RequiresContext(\n        lambda deps: 0 if guessed < deps.WORD_THRESHOLD else guessed,\n    )\n```\n\n----------------------------------------\n\nTITLE: Unwrap or Failure with Error Handling\nDESCRIPTION: Shows a complete example of using unwrap_or_failure with bimap for proper error handling in Result types.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/methods.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom returns.result import Failure, Result, Success\nfrom returns import methods, pointfree\n\ninstance: Result[int, str] = Success(1)\nerror_handled = pointfree.bimap(lambda inr: inr + 1, lambda _: 0)(instance)\nassert isinstance(methods.unwrap_or_failure(error_handled), int)\n```\n\n----------------------------------------\n\nTITLE: Using IO[Result] vs IOResult in Python\nDESCRIPTION: Compares the syntax between using nested IO[Result] containers versus the more concise IOResult container. IOResult provides a more ergonomic API with simplified mapping operations.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/io.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nx: IO[Result[int, str]]\nx.map(lambda io: io.map(lambda number: number + 1))\n\n# Is the same as:\n\ny: IOResult[int, str]\ny.map(lambda number: number + 1)\n```\n\n----------------------------------------\n\nTITLE: Using Kind1 for Higher Kinded Types\nDESCRIPTION: A solution using the Kind1 type from returns.primitives.hkt to represent a container with one type parameter, allowing generic container transformations.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/hkt.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.primitives.hkt import Kind1\n>>> from returns.interfaces.container import ContainerN\n>>> from typing import TypeVar\n\n>>> T = TypeVar('T', bound=ContainerN)\n\n>>> def to_str(container: Kind1[T, int]) -> Kind1[T, str]:\n...     return container.map(str)\n```\n\n----------------------------------------\n\nTITLE: IOResult Lifting Example\nDESCRIPTION: Shows how to lift functions to work with IOResult containers and handle both success and failure cases.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/io.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.io import IOResult, IOSuccess\n>>> from returns.result import Result, Success, Failure\n>>> from returns.pointfree import bind_result\n\n>>> def regular_function(arg: int) -> Result[float, str]:\n...     if arg > 0:\n...         return Success(arg / 2)\n...     return Failure('zero')\n\n>>> assert bind_result(regular_function)(\n...     IOSuccess(1),\n... ) == IOResult.from_result(regular_function(1))\n```\n\n----------------------------------------\n\nTITLE: Flattening Nested Containers in Python with Returns Library\nDESCRIPTION: This snippet demonstrates how to use the flatten function to merge nested containers of the same type. It shows examples with IO, Some, and Success containers containing nested instances of the same container type.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/converters.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.converters import flatten\n>>> from returns.maybe import Some\n>>> from returns.result import Success\n>>> from returns.io import IO\n\n>>> assert flatten(IO(IO(1))) == IO(1)\n>>> assert flatten(Some(Some(1))) == Some(1)\n>>> assert flatten(Success(Success(1))) == Success(1)\n```\n\n----------------------------------------\n\nTITLE: Impure Functions with IO Container in Python\nDESCRIPTION: Examples of using the IO container to explicitly mark impure functions. This shows how to handle functions that use random values, datetime, or perform side effects like printing to the console, making impurity explicit in the type system.\nSOURCE: https://github.com/dry-python/returns/blob/master/README.md#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport random\nimport datetime as dt\n\nfrom returns.io import IO\n\ndef get_random_number() -> IO[int]:  # or use `@impure` decorator\n    return IO(random.randint(1, 10))  # isn't pure, because random\n\nnow: Callable[[], IO[dt.datetime]] = impure(dt.datetime.now)\n\n@impure\ndef return_and_show_next_number(previous: int) -> int:\n    next_number = previous + 1\n    print(next_number)  # isn't pure, because does IO\n    return next_number\n```\n\n----------------------------------------\n\nTITLE: Using or_else_call with Maybe in Python\nDESCRIPTION: Shows how to use the or_else_call method to provide an alternative value when a Maybe container is Nothing.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/maybe.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.maybe import Some, Nothing\n\n>>> assert Some(1).or_else_call(lambda: 2) == 1\n>>> assert Nothing.or_else_call(lambda: 2) == 2\n```\n\n----------------------------------------\n\nTITLE: Using partial Application with IO Containers\nDESCRIPTION: Shows an alternative approach to working with multiple IO containers using partial function application. This achieves the same result as the curry approach but using the partial function.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/container.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.curry import partial\n\n>>> one = IO(1)\n>>> two = IO(2)\n>>> assert two.apply(one.apply(\n...     IO(lambda x: partial(sum_two_numbers, x)),\n... )) == IO(3)\n```\n\n----------------------------------------\n\nTITLE: Creating IOResult Unit Objects in Python\nDESCRIPTION: Shows how to create IOResult instances using IOSuccess and IOFailure constructors or the equivalent from_value and from_failure methods. Includes proper type annotations for mypy.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/io.rst#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.io import IOResult, IOSuccess, IOFailure\n\n>>> first: IOResult[int, str] = IOSuccess(1)\n>>> second: IOResult[float, int] = IOFailure(1)\n\n>>> assert IOResult.from_value(1) == IOSuccess(1)\n>>> assert IOResult.from_failure(2) == IOFailure(2)\n```\n\n----------------------------------------\n\nTITLE: Complete Implementation of Pair Container with Laws in Python\nDESCRIPTION: The final, complete implementation of the Pair container with all methods, docstrings, and laws. This represents a fully functional, typed, documented, and lawful container type.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/create-your-own-container.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable, TypeVar, Tuple, Iterable, final\n\nfrom returns.interfaces import bindable, equable, lashable, swappable\nfrom returns.primitives.container import BaseContainer\nfrom returns.primitives.hkt import Kind2, SupportsKind2, dekind\nfrom returns.primitives.laws import Law, law\n\n_FirstType = TypeVar('_FirstType')\n_SecondType = TypeVar('_SecondType')\n\n_NewFirstType = TypeVar('_NewFirstType')\n_NewSecondType = TypeVar('_NewSecondType')\n\nN = TypeVar('N')\n\n\ndef _LawSpec(\n    container_type,\n    args=None,\n):\n    # Importing inside function to avoid circular imports.\n    from returns.methods import cond, tap\n    from returns.pointfree import alt, bind, lash, map_\n\n    first_arg, second_arg = args if args is not None else (1, 2)\n    pair = container_type.pair(first_arg, second_arg)\n    empty = lambda arg: arg  # noqa: WPS111, E731\n\n    swap_law = (\n        'Swap changes position of value',\n        lambda: container_type.pair(first_arg, second_arg).swap(),\n        lambda: container_type.pair(second_arg, first_arg),\n    )\n\n    swap_twice_law = (\n        'Swap twice returns original value',\n        lambda: container_type.pair(first_arg, second_arg).swap().swap(),\n        lambda: container_type.pair(first_arg, second_arg),\n    )\n\n    from_unpaired_law = (\n        'From unpaired should create same values',\n        lambda: container_type.from_unpaired(first_arg),\n        lambda: container_type.pair(first_arg, first_arg),\n    )\n\n    return (swap_law, swap_twice_law, from_unpaired_law)\n\n\nclass PairLikeN(swappable.SwappableN, bindable.BindableN, lashable.LashableN):\n    \"\"\"Interface for types that work like a Pair.\"\"\"\n\n    @classmethod\n    def from_unpaired(\n        cls,\n        inner_value: _FirstType,\n    ) -> Kind2[N, _FirstType, _FirstType]:\n        \"\"\"Creates a new Pair with the same values.\"\"\"\n\n    @law\n    def _laws(container_type) -> Iterable[Law]:\n        \"\"\"Returns an iterator of laws that should hold for this container.\"\"\"\n        for reg_law in _LawSpec(container_type):\n            yield reg_law\n\n    @classmethod\n    def pair(\n        cls,\n        first: _FirstType,\n        second: _SecondType,\n    ) -> Kind2[N, _FirstType, _SecondType]:\n        \"\"\"Creates a new Pair with two values.\"\"\"\n\n\nclass PairLike2(PairLikeN, SupportsKind2['PairLike2', _FirstType, _SecondType]):\n    \"\"\"Typed interface for types that work like a Pair.\"\"\"\n\n\n@final\nclass Pair(\n    BaseContainer,\n    PairLike2[_FirstType, _SecondType],\n    equable.Equable,\n):\n    \"\"\"\n    Pair is a container for two values.\n\n    >>> assert Pair((1, 2)) == Pair((1, 2))\n    >>> assert Pair((1, 2)) != Pair((2, 1))\n\n    \"\"\"\n\n    def __init__(\n        self, inner_value: Tuple[_FirstType, _SecondType],\n    ) -> None:\n        \"\"\"\n        Initialize a new Pair instance.\n\n        >>> pair = Pair((1, 2))\n        >>> str(pair)\n        '<Pair: (1, 2)>'\n\n        \"\"\"\n        super().__init__(inner_value)\n\n    def map(\n        self,\n        function: Callable[[_FirstType], _NewFirstType],\n    ) -> 'Pair[_NewFirstType, _SecondType]':\n        \"\"\"\n        Maps the first value in a Pair.\n\n        >>> def inc(x: int) -> int:\n        ...     return x + 1\n\n        >>> assert Pair.pair(1, 'a').map(inc) == Pair.pair(2, 'a')\n\n        \"\"\"\n        first, second = self._inner_value\n        return Pair((function(first), second))\n\n    def bind(\n        self,\n        function: Callable[\n            [_FirstType],\n            'Pair[_NewFirstType, _SecondType]',\n        ],\n    ) -> 'Pair[_NewFirstType, _SecondType]':\n        \"\"\"\n        Binds the first value in a Pair.\n\n        >>> def inc(x: int) -> Pair[int, str]:\n        ...     return Pair.pair(x + 1, 'b')\n\n        >>> assert Pair.pair(1, 'a').bind(inc) == Pair.pair(2, 'a')\n\n        \"\"\"\n        first, second = self._inner_value\n        return dekind(function(first)).map(\n            lambda new_first: Pair((new_first, second)),\n        ).bind(lambda new_pair: new_pair)\n\n    def alt(\n        self,\n        function: Callable[[_SecondType], _NewSecondType],\n    ) -> 'Pair[_FirstType, _NewSecondType]':\n        \"\"\"\n        Maps the second value in a Pair.\n\n        >>> def inc(x: str) -> int:\n        ...     return len(x)\n\n        >>> assert Pair.pair(1, 'a').alt(inc) == Pair.pair(1, 1)\n\n        \"\"\"\n        first, second = self._inner_value\n        return Pair((first, function(second)))\n\n    def lash(\n        self,\n        function: Callable[\n            [_SecondType],\n            'Pair[_FirstType, _NewSecondType]',\n        ],\n    ) -> 'Pair[_FirstType, _NewSecondType]':\n        \"\"\"\n        Binds the second value in a Pair.\n\n        >>> def inc(x: str) -> Pair[int, int]:\n        ...     return Pair.pair(10, len(x))\n\n        >>> assert Pair.pair(1, 'a').lash(inc) == Pair.pair(1, 1)\n\n        \"\"\"\n        first, second = self._inner_value\n        new = function(second)\n        _, new_second = new._inner_value  # noqa: WPS437\n        return Pair((first, new_second))\n\n    def swap(self) -> 'Pair[_SecondType, _FirstType]':\n        \"\"\"\n        Swap first and second values.\n\n        >>> assert Pair.pair(1, 'a').swap() == Pair.pair('a', 1)\n\n        \"\"\"\n        first, second = self._inner_value\n        return Pair((second, first))\n\n    def equals(self, other) -> bool:\n        \"\"\"\n        Check if two Pairs are equal.\n\n        >>> assert Pair.pair(1, 2).equals(Pair.pair(1, 2))\n\n        \"\"\"\n        if not isinstance(other, Pair):\n            return False\n        return self._inner_value == other._inner_value  # noqa: WPS437\n\n    @classmethod\n    def pair(\n        cls,\n        first: _FirstType,\n        second: _SecondType,\n    ) -> 'Pair[_FirstType, _SecondType]':\n        \"\"\"\n        Creates new instance of Pair with two values.\n\n        >>> assert Pair.pair(1, 2) == Pair((1, 2))\n\n        \"\"\"\n        return Pair((first, second))\n\n    @classmethod\n    def from_unpaired(\n        cls,\n        inner_value: _FirstType,\n    ) -> 'Pair[_FirstType, _FirstType]':\n        \"\"\"\n        Creates new instance of Pair with the same values.\n\n        >>> assert Pair.from_unpaired(1) == Pair((1, 1))\n\n        \"\"\"\n        return Pair((inner_value, inner_value))\n```\n\n----------------------------------------\n\nTITLE: Comprehensive Dictionary Key Checking with Maybe in Python\nDESCRIPTION: Demonstrates a complete pattern for checking if a key exists in a dictionary and handling both present values (including None) and missing keys.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/maybe.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import Optional, Dict, TypeVar\n>>> from returns.maybe import Maybe, Some, Nothing\n\n>>> _Key = TypeVar('_Key')\n>>> _Value = TypeVar('_Value')\n\n>>> def check_key(\n...    heystack: Dict[_Key, _Value],\n...    needle: _Key,\n... ) -> Maybe[_Value]:\n...     if needle not in heystack:\n...         return Nothing\n...     return Maybe.from_value(heystack[needle])  # try with `.from_optional`\n\n>>> real_values = {'a': 1}\n>>> opt_values = {'a': 1, 'b': None}\n\n>>> assert check_key(real_values, 'a') == Some(1)\n>>> assert check_key(real_values, 'b') == Nothing\n>>> # Type revealed: returns.maybe.Maybe[builtins.int]\n\n>>> assert check_key(opt_values, 'a') == Some(1)\n>>> assert check_key(opt_values, 'b') == Some(None)\n>>> assert check_key(opt_values, 'c') == Nothing\n>>> # Type revealed: returns.maybe.Maybe[Union[builtins.int, None]]\n```\n\n----------------------------------------\n\nTITLE: Reusing pipe Pipelines with Multiple Values\nDESCRIPTION: Shows how a pipeline created with pipe() can be reused with different input values, demonstrating the reusability of the composed function chain.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/pipeline.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> assert pipeline(2) == '2B'\n```\n\n----------------------------------------\n\nTITLE: Checking Success or Failure Status of Result in Python\nDESCRIPTION: Shows how to determine if a Result container is a Success or Failure using the is_successful function from the returns.pipeline module.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/result.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.result import Success, Failure\n>>> from returns.pipeline import is_successful\n\n>>> assert is_successful(Success(1)) is True\n>>> assert is_successful(Failure('text')) is False\n```\n\n----------------------------------------\n\nTITLE: Using Fold.collect_all to Gather Successful Values\nDESCRIPTION: Shows how to use Fold.collect_all to gather only the successful values from a collection of containers. This returns a container with all valid values, ignoring any failures.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/container.rst#2025-04-21_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> fetched_values: Maybe[int] = [\n...     maybe(source.get)(key)\n...     for key in ('a', 'c')  # 'c' is missing!\n... ]\n>>> assert Fold.collect_all(fetched_values, Some(())) == Some((1,))\n```\n\n----------------------------------------\n\nTITLE: Using RequiresContext.ask() for Accessing Dependencies\nDESCRIPTION: This snippet demonstrates how to use the .ask() method of RequiresContext to access current dependencies and configure unguessed character marking.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/context.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom returns.context import RequiresContext\n\nclass _Deps(Protocol):  # we rely on abstractions, not direct values or types\n    WORD_THRESHOLD: int\n    UNGUESSED_CHAR: str\n\ndef calculate_points(word: str) -> RequiresContext[int, _Deps]:\n    def factory(deps: _Deps) -> RequiresContext[int, _Deps]:\n        guessed_letters_count = len([\n            letter for letter in word if letter != deps.UNGUESSED_CHAR\n        ])\n        return _award_points_for_letters(guessed_letters_count)\n\n    return RequiresContext[int, _Deps].ask().bind(factory)\n```\n\n----------------------------------------\n\nTITLE: Using Fold for Declarative Loops in Python\nDESCRIPTION: Demonstrates how to use the Fold class from returns.iterables to perform a declarative loop operation on a list of IO objects, concatenating their string representations.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/types.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.iterables import Fold\n>>> from returns.io import IO\n\n>>> items = [IO(1), IO(2), IO(3)]\n>>> assert Fold.loop(\n...     items,\n...     IO(''),\n...     lambda num: lambda text: text + str(num),\n... ) == IO('123')\n```\n\n----------------------------------------\n\nTITLE: Using cond with Maybe Container in Returns Library\nDESCRIPTION: Shows how to use the pointfree.cond function with Maybe containers, creating Some or Nothing based on a boolean condition. This example demonstrates the flexibility of cond with different container types.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/pointfree.rst#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.pipeline import flow\n>>> from returns import pointfree\n>>> from returns.maybe import Maybe, Some, Nothing\n\n>>> assert flow(\n...     returns_boolean(1),\n...     pointfree.cond(Maybe, 'success')\n... ) == Some('success')\n\n>>> assert flow(\n...     returns_boolean(0),\n...     pointfree.cond(Maybe, 'success')\n... ) == Nothing\n```\n\n----------------------------------------\n\nTITLE: Using Fold.collect to Combine Maybe Containers\nDESCRIPTION: Shows how to use Fold.collect to combine multiple Maybe containers into a single container. The result is a Some container with a tuple of all values if all operations succeed.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/container.rst#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.iterables import Fold\n\n>>> assert Fold.collect(fetched_values, Some(())) == Some((1, 2))\n```\n\n----------------------------------------\n\nTITLE: Using Do-Notation with Async Containers in Python\nDESCRIPTION: Demonstrates the use of do-notation with async containers like Future. This example shows how to use 'async for' expressions within an async function context to work with Future containers.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/do-notation.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> import anyio\n>>> from returns.future import Future\n>>> from returns.io import IO\n\n>>> async def main() -> None:\n...     return await Future.do(\n...         first + second\n...         async for first in Future.from_value(1)\n...         async for second in Future.from_value(2)\n...     )\n\n>>> assert anyio.run(main) == IO(3)\n```\n\n----------------------------------------\n\nTITLE: Exception Raising with raise_exception in Python\nDESCRIPTION: Shows how to use raise_exception to handle and reraise exceptions from Failure[Exception] types in a typed function composition context.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/functions.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom returns.functions import raise_exception\n\ndef create_account_and_user(username: str) -> ...:\n    \"\"\"\n    Creates new Account-User pair.\n\n    Imagine, that you need to reraise ValidationErrors due to existing API.\n    \"\"\"\n    return _validate_user(\n        username,\n    ).alt(\n        # What happens here is interesting, since you do not let your\n        # unwrap to fail with UnwrapFailedError, but instead\n        # allows you to reraise a wrapped exception.\n        # In this case `ValidationError()` will be thrown\n        # before `UnwrapFailedError`\n        raise_exception,\n    )\n\ndef _validate_user(username: str) -> Result['User', ValidationError]:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Using returns.curry.partial with Types and Instances\nDESCRIPTION: This example demonstrates how returns.curry.partial can work with both class types and class instances, properly inferring return types for both scenarios.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/curry.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom returns.curry import partial\n\nclass Test(object):\n    def __init__(self, arg: int) -> None:\n        self.arg = arg\n\n    def __call__(self, other: int) -> int:\n        return self.arg + other\n\nreveal_type(partial(Test, 1))  # N: Revealed type is 'def () -> ex.Test'\nreveal_type(partial(Test(1), 1))  # N: Revealed type is 'def () -> builtins.int'\n```\n\n----------------------------------------\n\nTITLE: Using cond with Result Container in Returns Library\nDESCRIPTION: Demonstrates how to use the pointfree.cond function to create Result containers based on boolean expressions. The function acts as a functional if statement, returning Success or Failure based on a boolean condition.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/pointfree.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.pipeline import flow\n>>> from returns import pointfree\n>>> from returns.result import Result, Failure, Success\n\n>>> def returns_boolean(arg: int) -> bool:\n...     return bool(arg)\n\n>>> assert flow(\n...     returns_boolean(1),\n...     pointfree.cond(Result, 'success', 'failure')\n... ) == Success('success')\n\n>>> assert flow(\n...     returns_boolean(0),\n...     pointfree.cond(Result, 'success', 'failure')\n... ) == Failure('failure')\n```\n\n----------------------------------------\n\nTITLE: IO Function Composition\nDESCRIPTION: Demonstrates how IO containers infect other functions that call them, maintaining context.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/io.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> def modify_number(number: int) -> IO[float]:\n...     return get_random_number().map(lambda rnd: number / rnd)\n...\n>>> assert isinstance(modify_number(1), IO)\n```\n\n----------------------------------------\n\nTITLE: Creating Failure Containers from Values\nDESCRIPTION: Shows how to create failing containers using the from_failure method in the Result type. This creates a Failure container with the provided value.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/container.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.result import Result, Failure\n>>> assert Result.from_failure(1) == Failure(1)\n```\n\n----------------------------------------\n\nTITLE: Using Fold.loop to Sum Container Values\nDESCRIPTION: Demonstrates using the Fold.loop method to combine an iterable of IO containers. This allows processing multiple containers with an accumulator function to produce a single result container.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/container.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import Callable\n>>> from returns.iterables import Fold\n\n>>> def sum_two_numbers(first: int) -> Callable[[int], int]:\n...     return lambda second: first + second\n\n>>> assert Fold.loop(\n...     numbers,  # let's loop on our ``IO`` values\n...     IO(0),  # starting from ``0`` value\n...     sum_two_numbers,  # and getting the sum of each two numbers in a loop\n... ) == IO(20)\n```\n\n----------------------------------------\n\nTITLE: Typing with @curry Decorator\nDESCRIPTION: This example demonstrates the comprehensive type annotations generated for @curry decorated functions, showing how the type system tracks partially applied functions through various stages of argument application.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/curry.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.curry import curry\n\n>>> @curry\n... def zero(a: int, b: float, *, kw: bool) -> str:\n...     return str(a - b) if kw else ''\n\n>>> assert zero(1)(0.3)(kw=True) == '0.7'\n>>> assert zero(1)(0.3, kw=False) == ''\n\n# If we will reveal the type it would be quite big:\n\nreveal_type(zero)\n\n# Overload(\n#   def (a: builtins.int) -> Overload(\n#     def (b: builtins.float, *, kw: builtins.bool) -> builtins.str,\n#     def (b: builtins.float) -> def (*, kw: builtins.bool) -> builtins.str\n#   ),\n#   def (a: builtins.int, b: builtins.float) -> def (*, kw: builtins.bool)\n#     -> builtins.str,\n#   def (a: builtins.int, b: builtins.float, *, kw: builtins.bool)\n#     -> builtins.str\n# )\n```\n\n----------------------------------------\n\nTITLE: Implementing Similar Behavior with RequiresContext\nDESCRIPTION: Example demonstrating how to achieve similar functionality to a decorator with arguments using RequiresContext, allowing for more flexible behavior modification at runtime.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/context.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom returns.context import RequiresContext\n\ndef my_function(first: int, second: int) -> RequiresContext[int, bool]:\n    def factory(print_result: bool) -> int:\n        original = first + second\n        if print_result:\n            print(original)\n        return original\n    return RequiresContext(factory)\n\nassert my_function(2, 3)(False) == 5\nassert my_function(2, 3)(True) == 5\n5\n```\n\n----------------------------------------\n\nTITLE: Partition Method for Collection Handling\nDESCRIPTION: Demonstrates the partition method for separating lists of Unwrappable instances into successes and failures.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/methods.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom returns.result import Failure, Success\nfrom returns.methods import partition\nresults = [Success(1), Failure(2), Success(3), Failure(4)]\npartition(results)\n([1, 3], [2, 4])\n```\n\n----------------------------------------\n\nTITLE: Implementing Applicative Number Container\nDESCRIPTION: Shows implementation of a custom Number container that implements the Applicative1 interface with apply and from_value methods.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/interfaces.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import Callable, TypeVar\n\n>>> from returns.interfaces.applicative import Applicative1\n>>> from returns.primitives.hkt import SupportsKind1, Kind1, dekind\n>>> from returns.primitives.container import BaseContainer\n\n>>> _NumberType = TypeVar('_NumberType')\n>>> _NewNumberType = TypeVar('_NewNumberType')\n\n>>> class Number(\n...     BaseContainer,\n...     SupportsKind1['Number', _NumberType],\n...     Applicative1[_NumberType],\n... ):\n...     def __init__(self, inner_value: _NumberType) -> None:\n...         super().__init__(inner_value)\n...\n...     def map(  # This method is required by Mappable\n...         self,\n...         function: Callable[[_NumberType], _NewNumberType]\n...     ) -> 'Number[_NewNumberType]':\n...         return Number(function(self._inner_value))\n...\n...     def apply(  # This method is required by Applicative\n...         self,\n...         container: Kind1[\n...             'Number',\n...             Callable[[_NumberType], _NewNumberType],\n...         ],\n...     ) -> 'Number[_NewNumberType]':\n...         return Number.from_value(\n...             dekind(container._inner_value(self._inner_value)),\n...         )\n...\n...     @classmethod\n...     def from_value(  # This method is required by Applicative\n...         cls,\n...         inner_value: _NewNumberType,\n```\n\n----------------------------------------\n\nTITLE: Implementing Safe Recursion with Trampolines in Python\nDESCRIPTION: This example demonstrates how to use the Trampoline class and trampoline decorator to create a safe recursive function that accumulates values from a list. The function remains type-safe with ParamSpec ensuring correct argument types and the return type being properly narrowed.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/trampolines.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import Union, List\n>>> from returns.trampolines import Trampoline, trampoline\n\n>>> @trampoline\n... def accumulate(\n...     numbers: List[int],\n...     acc: int = 0,\n... ) -> Union[int, Trampoline[int]]:\n...    if not numbers:\n...        return acc\n...    number = number = numbers.pop()\n...    return Trampoline(accumulate, numbers, acc + number)\n\n>>> assert accumulate([1, 2]) == 3\n>>> assert accumulate([1, 2, 3]) == 6\n```\n\n----------------------------------------\n\nTITLE: Documenting the Pair.map Method with Doctests in Python\nDESCRIPTION: Enhanced implementation of the map method with comprehensive documentation and doctests. This demonstrates how to write self-documenting code that also serves as tests.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/create-your-own-container.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n    def map(\n        self,\n        function: Callable[[_FirstType], _NewFirstType],\n    ) -> 'Pair[_NewFirstType, _SecondType]':\n        \"\"\"\n        Maps the first value in a Pair.\n\n        >>> def inc(x: int) -> int:\n        ...     return x + 1\n\n        >>> assert Pair.pair(1, 'a').map(inc) == Pair.pair(2, 'a')\n\n        \"\"\"\n        first, second = self._inner_value\n        return Pair((function(first), second))\n```\n\n----------------------------------------\n\nTITLE: Flow Pipeline with Map Function\nDESCRIPTION: Demonstrates composing functions in a pipeline using flow and map_ with Maybe containers.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/pointfree.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns import pointfree\n>>> from returns.pipeline import flow\n>>> from returns.maybe import Maybe, Some, Nothing\n\n>>> def index_of_7(arg: str) -> Maybe[int]:\n...     if '7' in arg:\n...         return Some(arg.index('7'))\n...     return Nothing\n\n>>> def double(num: int) -> int:\n...     return num * 2\n\n>>> assert flow(\n...     '007',\n...     index_of_7,               # Some(2)\n...     pointfree.map_(double),   # Some(4)\n... ) == Some(4)\n\n>>> # Still passes along Nothing\n>>> assert flow(\n...     '006',\n...     index_of_7,               # Nothing\n...     pointfree.map_(double),   # Nothing\n... ) == Nothing\n```\n\n----------------------------------------\n\nTITLE: Creating Maybe Instances with from_value Method in Python\nDESCRIPTION: Shows how the from_value method differs from from_optional by wrapping None values in Some rather than converting them to Nothing.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/maybe.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.maybe import Maybe\n\n>>> assert str(Maybe.from_value(1)) == '<Some: 1>'\n>>> assert str(Maybe.from_value(None)) == '<Some: None>'\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Mixed Container Types in Do-Notation in Python\nDESCRIPTION: This example shows the correct way to use do-notation with mixed container types (Result and IOResult). It demonstrates how to properly handle the IO part while maintaining type consistency.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/do-notation.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.result import Success\n>>> from returns.io import IOResult, IOSuccess\n\n>>> assert IOResult.do(\n...     first + second\n...     for first in IOResult.from_result(Success(2))\n...     for second in IOSuccess(3)\n... ) == IOSuccess(5)\n```\n\n----------------------------------------\n\nTITLE: Basic API Request Implementation in Python\nDESCRIPTION: A straightforward function that fetches a user profile from an API. It uses requests to make a GET request, raises an exception for non-successful responses, and returns the JSON response as a UserProfile dictionary.\nSOURCE: https://github.com/dry-python/returns/blob/master/README.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport requests\n\ndef fetch_user_profile(user_id: int) -> 'UserProfile':\n    \"\"\"Fetches UserProfile dict from foreign API.\"\"\"\n    response = requests.get('/api/users/{0}'.format(user_id))\n    response.raise_for_status()\n    return response.json()\n```\n\n----------------------------------------\n\nTITLE: Working with Dictionary Values and Maybe in Python\nDESCRIPTION: Demonstrates how to use Maybe with dictionary values to properly handle both present and missing values.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/maybe.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> values = {'a': 1, 'b': None}\n\n>>> assert Maybe.from_value(values).map(lambda d: d.get('a')) == Some(1)\n>>> assert Maybe.from_value(values).map(lambda d: d.get('b')) == Some(None)\n```\n\n----------------------------------------\n\nTITLE: IO Container Mapping Operation\nDESCRIPTION: Shows how to work within the IO context using map operations while maintaining purity.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/io.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> assert get_random_number().map(lambda number: number / number) == IO(1.0)\n```\n\n----------------------------------------\n\nTITLE: Complete HKT solution with @kinded decorator\nDESCRIPTION: The final solution using both Kind1 and the @kinded decorator to properly transform container types while preserving their original type in the return value.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/hkt.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.primitives.hkt import kinded\n\n>>> @kinded\n... def to_str(container: Kind1[T, int]) -> Kind1[T, str]:\n...     return container.map(str)\n```\n\n----------------------------------------\n\nTITLE: Working with FutureResult in Python using the returns library\nDESCRIPTION: This code demonstrates how to create and use a FutureResult, which represents an asynchronous operation that can be awaited. The snippet shows type checking of the result and using anyio.run() to await the coroutine.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/interfaces.rst#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# we have to await it to get the real result\nresult_like: FutureResult[int, str] = FutureResult(coro(1))\nassert isinstance(result_like, FutureResultBasedN)\nassert isinstance(result_like, IOResultLikeN)\nassert isinstance(result_like, ResultLikeN)\n\n# `anyio.run(...)` will await our coroutine and give the real result to us\nresult: IOResult[int, str] = anyio.run(result_like.awaitable)\nassert isinstance(result, IOResultBasedN)\nassert isinstance(result, ResultLikeN)\n\n# Compare it with the real result:\nassert isinstance(Success(1), ResultBasedN)\n```\n\n----------------------------------------\n\nTITLE: Value Untapping with untap Function in Python\nDESCRIPTION: Demonstrates the untap function which converts any function's return type to None while still executing the original function.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/functions.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.functions import tap, untap\n\n>>> result = untap(tap(print))(1)  # will print and return None\n1\n>>> assert result is None\n```\n\n----------------------------------------\n\nTITLE: Value Tapping with tap Function in Python\nDESCRIPTION: Shows usage of tap function to execute side effects (like printing) while preserving the original value in a function chain.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/functions.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.functions import tap\n\n>>> result = tap(print)(1)  # will print and return 1\n1\n>>> assert result == 1\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Mappable Number Container\nDESCRIPTION: Shows how to create a custom Number container class that implements the Mappable1 interface with map functionality.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/interfaces.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import Callable, TypeVar\n\n>>> from returns.interfaces.mappable import Mappable1\n>>> from returns.primitives.hkt import SupportsKind1\n>>> from returns.primitives.container import BaseContainer\n\n>>> _NumberType = TypeVar('_NumberType')\n>>> _NewNumberType = TypeVar('_NewNumberType')\n\n>>> class Number(\n...     BaseContainer,\n...     SupportsKind1['Number', _NumberType],\n...     Mappable1[_NumberType],\n... ):\n...     def __init__(self, inner_value: _NumberType) -> None:\n...         super().__init__(inner_value)\n...\n...     def map(  # This method is required by Mappable\n...         self,\n...         function: Callable[[_NumberType], _NewNumberType]\n...     ) -> 'Number[_NewNumberType]':\n...         return Number(function(self._inner_value))\n```\n\n----------------------------------------\n\nTITLE: Custom PairLike Interface Definition in Python\nDESCRIPTION: Definition of a custom PairLikeN interface that extends other interfaces and introduces new methods specific to Pair operations. This demonstrates how to create custom interfaces for container types.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/create-your-own-container.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass PairLikeN(swappable.SwappableN, bindable.BindableN, lashable.LashableN):\n    \"\"\"Interface for types that work like a Pair.\"\"\"\n\n    @classmethod\n    def from_unpaired(\n        cls,\n        inner_value: _FirstType,\n    ) -> Kind2[N, _FirstType, _FirstType]:\n        \"\"\"Creates a new Pair with the same values.\"\"\"\n\n    @classmethod\n    def pair(\n        cls,\n        first: _FirstType,\n        second: _SecondType,\n    ) -> Kind2[N, _FirstType, _SecondType]:\n        \"\"\"Creates a new Pair with two values.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using bind Method with Result Container\nDESCRIPTION: Demonstrates how to use the bind method to chain operations that may fail. The bind method is used to connect containers when the function returns another container of the same type.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/container.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom returns.result import Result, Success\n\ndef may_fail(user_id: int) -> Result[float, str]:\n    ...\n\nvalue: Result[int, str] = Success(1)\n# Can be assumed as either Success[float] or Failure[str]:\nresult: Result[float, str] = value.bind(may_fail)\n```\n\n----------------------------------------\n\nTITLE: Bind Function Usage Example\nDESCRIPTION: Shows how to use the bind pointfree function with Maybe containers, comparing method and function approaches.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/pointfree.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns import pointfree\n>>> from returns.maybe import Maybe, Some\n\n>>> def index_of_1(arg: str) -> Maybe[int]:\n...     if '1' in arg:\n...         return Some(arg.index('1'))\n...     return Nothing\n\n>>> container = Some('A1 Steak Sauce')\n>>> # We now have two way of composing these entities.\n>>> # 1. Via ``.bind``:\n>>> assert container.bind(index_of_1) == Some(1)\n>>> # 2. Or via the ``bind`` function.\n>>> assert pointfree.bind(index_of_1)(container) == Some(1)\n```\n\n----------------------------------------\n\nTITLE: Using map with Built-in Functions in IO Container\nDESCRIPTION: Shows how to apply built-in Python functions to values inside an IO container using the map method. This example transforms a string into a list of characters while maintaining the IO context.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/container.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.io import IO\n\n>>> io = IO('bytes').map(list)\n>>> str(io)\n\"<IO: ['b', 'y', 't', 'e', 's']>\"\n```\n\n----------------------------------------\n\nTITLE: Creating an Iterable of Maybe Containers\nDESCRIPTION: Demonstrates creating a list of Maybe containers by attempting to access dictionary values. Each access operation returns a Some container with the value if present, or Nothing if absent.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/container.rst#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import List\n>>> from returns.maybe import Maybe, Some, Nothing, maybe\n\n>>> source = {'a': 1, 'b': 2}\n>>> fetched_values: List[Maybe[int]] = [\n...     maybe(source.get)(key)\n...     for key in ('a', 'b')\n... ]\n```\n\n----------------------------------------\n\nTITLE: Tracing Failures Using Context Manager in Python Returns\nDESCRIPTION: Demonstrates how to enable failure tracing using collect_traces as a context manager. Shows how to access trace information from a Failure instance and verify trace contents using FrameInfo objects.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/development.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from inspect import FrameInfo\n\n>>> from returns.result import Failure, Result\n>>> from returns.primitives.tracing import collect_traces\n\n>>> def get_failure(argument: str) -> Result[str, str]:\n...     return Failure(argument)\n\n>>> non_traced_failure = get_failure('Normal Failure')\n>>> with collect_traces():\n...     traced_failure = get_failure('Traced Failure')\n\n>>> assert non_traced_failure.trace is None\n>>> assert isinstance(traced_failure.trace, list)\n>>> assert all(isinstance(trace_line, FrameInfo) for trace_line in traced_failure.trace)\n\n>>> for trace_line in traced_failure.trace:\n...     print(f\"{trace_line.filename}:{trace_line.lineno} in `{trace_line.function}`\") # doctest: +SKIP\n...\n/returns/returns/result.py:529 in `Failure`\n/example_folder/example.py:5 in `get_failure`\n/example_folder/example.py:1 in `<module>`\n```\n\n----------------------------------------\n\nTITLE: Creating Result Unit Objects with Explicit Type Annotations in Python\nDESCRIPTION: Demonstrates how to create and use Result unit objects with explicit type annotations to ensure correct typing in complex operations.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/result.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.result import Result, Success\n\n>>> def callback(arg: int) -> Result[float, int]:\n...     return Success(float(arg))\n\n>>> first: Result[int, int] = Success(1)\n>>> assert first.bind(callback) == Success(1.0)\n```\n\n----------------------------------------\n\nTITLE: Container Associative Law Implementation\nDESCRIPTION: Shows the Associative Law implementation where sequential bindings equal nested binding operation.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/interfaces.rst#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef minus_one(arg: int) -> Number[int]:\n    return Number(arg - 1)\n\ndef half(arg: int) -> Number[int]:\n    return Number(arg // 2)\n\nnumber = Number(9)\nassert number.bind(minus_one).bind(half) == number.bind(\n   lambda value: minus_one(value).bind(half),\n)\n```\n\n----------------------------------------\n\nTITLE: Using Lambda Functions with IO Containers\nDESCRIPTION: Demonstrates using lambda functions for partial application with IO containers. This approach uses native lambda functions instead of the curry or partial utilities.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/container.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> one = IO(1)\n>>> two = IO(2)\n>>> assert two.apply(one.apply(\n...     IO(lambda x: lambda y: sum_two_numbers(x, y)),\n... )) == IO(3)\n```\n\n----------------------------------------\n\nTITLE: Using bind_optional with Dictionary Values in Python\nDESCRIPTION: Shows how bind_optional can simplify handling Optional values from dictionaries by automatically converting None to Nothing.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/maybe.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> assert Maybe.from_value(values).bind_optional(\n...     lambda d: d.get('a'),\n... ) == Some(1)\n\n>>> assert Maybe.from_value(values).bind_optional(\n...     lambda d: d.get('b'),\n... ) == Nothing\n```\n\n----------------------------------------\n\nTITLE: Pure Function Example\nDESCRIPTION: Shows a pure function implementation for booking seats without side effects.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/io.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef can_book_seats(\n    number_of_seats: int,\n    reservation: 'Reservation',\n) -> bool:\n    return reservation.capacity >= number_of_seats + reservation.booked\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Constructor Methods for Pair Container in Python\nDESCRIPTION: Implementation of the pair and from_unpaired class methods that create new Pair instances from one or two values. These methods provide convenient ways to instantiate the container.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/create-your-own-container.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n    @classmethod\n    def pair(\n        cls,\n        first: _FirstType,\n        second: _SecondType,\n    ) -> 'Pair[_FirstType, _SecondType]':\n        \"\"\"Creates new instance of Pair with two values.\"\"\"\n        return Pair((first, second))\n```\n\nLANGUAGE: python\nCODE:\n```\n    @classmethod\n    def from_unpaired(\n        cls,\n        inner_value: _FirstType,\n    ) -> 'Pair[_FirstType, _FirstType]':\n        \"\"\"Creates new instance of Pair with the same values.\"\"\"\n        return Pair((inner_value, inner_value))\n```\n\n----------------------------------------\n\nTITLE: Using the to_str function with different container types\nDESCRIPTION: An example showing how the to_str function works with different container types like Maybe and IO, converting the contained integer to string.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/hkt.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.maybe import Maybe\n>>> from returns.io import IO\n\n>>> assert to_str(Maybe.from_value(1)) == Maybe.from_value('1')\n>>> assert to_str(IO.from_value(1)) == IO.from_value('1')\n```\n\n----------------------------------------\n\nTITLE: Implementing Math Function with Number Mappable Class\nDESCRIPTION: Demonstrates how to use the Number mappable class to compose math functions, showing basic usage of apply method.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/interfaces.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef my_math_function(number: int) -> int:\n    return number - 1\n\nnumber = Number(3)\nnumber_function = Number.from_value(my_math_function)\n\nassert number.apply(number_function) == Number(2)\n```\n\n----------------------------------------\n\nTITLE: Running Future Container with anyio in Python\nDESCRIPTION: Shows how to execute a Future container using anyio.run, converting the result to an IO-based container.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/future.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> import anyio\n>>> from returns.io import IO\n\n>>> assert anyio.run(main().awaitable) == IO(2)\n```\n\n----------------------------------------\n\nTITLE: Applicative Composition Law Implementation\nDESCRIPTION: Demonstrates the Composition Law where applying two functions separately equals applying their composition once.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/interfaces.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom returns.functions import compose\n\ndef first(arg: int) -> int:\n    return arg * 2\n\ndef second(arg: int) -> int:\n    return arg + 1\n\ninstance = Number(5)\nassert instance.apply(\n    Number.from_value(compose(first, second)),\n) == instance.apply(\n    Number.from_value(first),\n).apply(\n    Number.from_value(second),\n)\n```\n\n----------------------------------------\n\nTITLE: Comparing RequiresContext[Result] with RequiresContextResult\nDESCRIPTION: Example showing the difference in API between using RequiresContext[Result] and the more convenient RequiresContextResult, which provides a simpler interface for the same functionality.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/context.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nx: RequiresContext[Result[int, str], int]\nx.map(lambda result: result.map(lambda number: number + 1))\n\n# Is the same as:\n\ny: RequiresContextResult[int, str, int]\ny.map(lambda number: number + 1)\n```\n\n----------------------------------------\n\nTITLE: Alt Function with IO Containers\nDESCRIPTION: Demonstrates using the alt pointfree function with IOSuccess and IOFailure containers.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/pointfree.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.io import IOFailure, IOSuccess\n>>> from returns import pointfree\n\n>>> def half_as_bad(error_code: int) -> float:\n...     return error_code / 2\n\n>>> # When acting on a successful state, nothing happens.\n>>> assert pointfree.alt(half_as_bad)(IOSuccess(1)) == IOSuccess(1)\n\n>>> # When acting on a failed state, the result changes\n>>> assert pointfree.alt(half_as_bad)(IOFailure(4)) == IOFailure(2.0)\n\n>>> # This is equivalent to IOFailure(4).alt(half_as_bad)\n>>> assert pointfree.alt(half_as_bad)(IOFailure(4)) == IOFailure(4).alt(half_as_bad)\n```\n\n----------------------------------------\n\nTITLE: Function Negation with not_ in Python\nDESCRIPTION: Demonstrates the not_ helper function which negates the boolean return value of single or multi-argument functions.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/functions.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import List\n>>> from returns.functions import compose, not_\n\n>>> def is_even(number: int) -> bool:\n...     return number % 2 == 0\n\n>>> def number_is_in_list(number: int, list_: List[int]) -> bool:\n...     return number in list_\n\n>>> assert not_(is_even)(2) is False\n>>> assert not_(number_is_in_list)(1, [2, 3, 4]) is True\n>>> assert compose(int, not_(is_even))(\"1\") is True\n```\n\n----------------------------------------\n\nTITLE: Checking Success Status with is_successful in Returns Library\nDESCRIPTION: Demonstrates how to use is_successful() to check if a container represents a successful value. This function works with Success, IOSuccess, and Some container types.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/pipeline.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.result import Success, Failure\n>>> from returns.pipeline import is_successful\n\n>>> assert is_successful(Success(1)) is True\n>>> assert is_successful(Failure('text')) is False\n```\n\n----------------------------------------\n\nTITLE: Compose Result Function Usage\nDESCRIPTION: Demonstrates using compose_result to manipulate inner Result containers within IOResult containers.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/pointfree.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns import pointfree\n>>> from returns.io import IOResult, IOSuccess, IOFailure\n>>> from returns.result import Result\n\n>>> def cast_to_str(container: Result[float, int]) -> IOResult[str, int]:\n...     return IOResult.from_result(container.map(str))\n\n>>> assert pointfree.compose_result(cast_to_str)(IOSuccess(42.0)) == IOSuccess('42.0')\n>>> assert pointfree.compose_result(cast_to_str)(IOFailure(1)) == IOFailure(1)\n```\n\n----------------------------------------\n\nTITLE: Error Handling in Do-Notation with Result Container in Python\nDESCRIPTION: Illustrates how do-notation handles errors when using the Result container. The example shows that the first encountered error (Failure) is returned, consistent with .map and other methods.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/do-notation.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.result import Success, Failure, Result\n\n>>> assert Result.do(\n...     first + second\n...     for first in Failure('a')\n...     for second in Success(3)\n... ) == Failure('a')\n```\n\n----------------------------------------\n\nTITLE: Initializing a Simple Django View Function\nDESCRIPTION: This snippet shows a basic Django view function that calculates points based on a user's word input. It demonstrates the initial implementation without context management.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/context.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom django.http import HttpRequest, HttpResponse\nfrom words_app.logic import calculate_points\n\ndef view(request: HttpRequest) -> HttpResponse:\n    user_word: str = request.POST['word']  # just an example\n    points = calculate_points(user_word)\n    ...  # later you show the result to user somehow\n```\n\n----------------------------------------\n\nTITLE: Composing Error Types with Pointfree Unify in Python\nDESCRIPTION: Shows how to use the unify pointfree function to compose Result containers with different error types, resulting in a union of error types.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/result.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.result import Result, Success, Failure\n>>> from returns.pointfree import unify\n\n>>> def div(number: int) -> Result[float, ZeroDivisionError]:\n...     if number:\n...         return Success(1 / number)\n...     return Failure(ZeroDivisionError('division by zero'))\n\n>>> container: Result[int, ValueError] = Success(1)\n>>> assert unify(div)(container) == Success(1.0)\n>>> # => Revealed type is:\n>>> # Result[float, Union[ValueError, ZeroDivisionError]]\n```\n\n----------------------------------------\n\nTITLE: Implementing Bindable Number Container\nDESCRIPTION: Demonstrates implementation of a custom Number container that implements the Bindable1 interface with bind functionality.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/interfaces.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import Callable, TypeVar\n\n>>> from returns.interfaces.bindable import Bindable1\n>>> from returns.primitives.hkt import SupportsKind1, Kind1, dekind\n>>> from returns.primitives.container import BaseContainer\n\n>>> _NumberType = TypeVar('_NumberType')\n>>> _NewNumberType = TypeVar('_NewNumberType')\n\n>>> class Number(\n...     BaseContainer,\n...     SupportsKind1['Number', _NumberType],\n...     Bindable1[_NumberType],\n... ):\n...     def __init__(self, inner_value: _NumberType) -> None:\n...         super().__init__(inner_value)\n...\n...     def bind(  # This method is required by Bindable\n...         self,\n...         function: Kind1[\n...             'Number',\n...             Callable[[_NumberType], 'Number[_NewNumberType]'],\n...         ],\n...     ) -> 'Number[_NewNumberType]':\n...         return dekind(function(self._inner_value))\n```\n\n----------------------------------------\n\nTITLE: Unsafe Perform IO Example\nDESCRIPTION: Demonstrates how to safely extract raw values from IO containers when necessary for compatibility.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/io.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.unsafe import unsafe_perform_io\n>>> from returns.io import IO\n\n>>> assert unsafe_perform_io(IO('abc')) == 'abc'\n```\n\n----------------------------------------\n\nTITLE: Applicative Interchange Law Implementation\nDESCRIPTION: Demonstrates the Interchange Law showing that composition can start with either raw value or function.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/interfaces.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef function(arg: int) -> int:\n    return arg + 1\n\nraw_value = 5\n\nassert Number.from_value(raw_value).apply(\n    Number.from_value(function),\n) == Number.from_value(function).apply(\n    Number.from_value(lambda inner: inner(raw_value)),\n)\n```\n\n----------------------------------------\n\nTITLE: Handling Failed Unwrapping in Returns\nDESCRIPTION: Demonstrates what happens when trying to unwrap failed containers. The unwrap method raises an UnwrapFailedError when called on a Failure or Nothing container.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/railway.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> Failure(1).unwrap()\nTraceback (most recent call last):\n  ...\nreturns.primitives.exceptions.UnwrapFailedError\n\n>>> Nothing.unwrap()\nTraceback (most recent call last):\n  ...\nreturns.primitives.exceptions.UnwrapFailedError\n```\n\n----------------------------------------\n\nTITLE: Impure Function Implementation\nDESCRIPTION: Shows how the pure function becomes impure when adding external dependencies like database and HTTP requests.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/io.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport requests\nimport db\n\ndef can_book_seats(\n    number_of_seats: int,\n    place_id: int,\n) -> bool:\n    capacity = db.get_place_capacity(place_id)  # sql query\n    booked = requests('https://partner.com/api').json()['booked']  # http req\n    return capacity >= number_of_seats + booked\n```\n\n----------------------------------------\n\nTITLE: Converting int to str in any Container1 type\nDESCRIPTION: A function that transforms Container1[int] to Container1[str] by applying the map method with str function, demonstrating operations on container generics.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/hkt.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.interfaces.container import Container1\n\n>>> def to_str(container: Container1[int]) -> Container1[str]:\n...     return container.map(str)\n```\n\n----------------------------------------\n\nTITLE: Applicative Homomorphism Law Implementation\nDESCRIPTION: Shows the Homomorphism Law implementation where applying wrapped function to wrapped value equals normal function application.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/interfaces.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef function(arg: int) -> int:\n    return arg + 1\n\nraw_value = 5\n\nassert Number.from_value(\n    function(raw_value),\n) == Number.from_value(raw_value).apply(\n    Number.from_value(function),\n)\n```\n\n----------------------------------------\n\nTITLE: Apply Function Basic Usage\nDESCRIPTION: Shows basic usage of the apply pointfree function with Maybe containers.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/pointfree.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns import pointfree\n>>> from returns.maybe import Some, Nothing\n\n>>> def wow(arg: int) -> str:\n...     return chr(arg) + '!'\n\n>>> assert pointfree.apply(Some(wow))(Some(97)) == Some('a!')\n>>> assert pointfree.apply(Some(wow))(Some(98)) == Some('b!')\n>>> assert pointfree.apply(Some(wow))(Nothing) == Nothing\n>>> assert pointfree.apply(Nothing)(Nothing) == Nothing\n```\n\n----------------------------------------\n\nTITLE: Defining Pair Container with Required Interfaces in Python\nDESCRIPTION: Initial skeleton implementation of a Pair container class that inherits from necessary interfaces like Bindable, Swappable, Lashable, and Equable. This defines the structure before implementing the required methods.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/create-your-own-container.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import Callable, TypeVar, Tuple, final\n\n>>> from returns.interfaces import bindable, equable, lashable, swappable\n>>> from returns.primitives.container import BaseContainer\n>>> from returns.primitives.hkt import SupportsKind2\n\n>>> _FirstType = TypeVar('_FirstType')\n>>> _SecondType = TypeVar('_SecondType')\n\n>>> _NewFirstType = TypeVar('_NewFirstType')\n>>> _NewSecondType = TypeVar('_NewSecondType')\n\n>>> @final\n... class Pair(\n...     BaseContainer,\n...     SupportsKind2['Pair', _FirstType, _SecondType],\n...     bindable.Bindable2[_FirstType, _SecondType],\n...     swappable.Swappable2[_FirstType, _SecondType],\n...     lashable.Lashable2[_FirstType, _SecondType],\n...     equable.Equable,\n... ):\n...     def __init__(\n...         self, inner_value: Tuple[_FirstType, _SecondType],\n...     ) -> None:\n...         super().__init__(inner_value)\n```\n\n----------------------------------------\n\nTITLE: Type Signatures of map and alt Methods in Returns\nDESCRIPTION: Illustrates the typing perspective of map and alt methods, showing how they modify different type arguments of a container. The map method works with the first type argument, while alt works with the second.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/railway.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom returns.result import Result\n\nfirst: Result[int, int]\nsecond: Result[int, int]\n\nreveal_type(first.map(str))\n# => Result[str, int]\n\nreveal_type(second.alt(str))\n# => Result[int, str]\n```\n\n----------------------------------------\n\nTITLE: Container Left Identity Law Implementation\nDESCRIPTION: Shows the Left Identity Law implementation for Container interface where binding a function equals direct function application.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/interfaces.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef can_be_bound(value: int) -> Number[int]:\n    return Number(value)\n\nassert Number.from_value(5).bind(can_be_bound) == can_be_bound(5)\n```\n\n----------------------------------------\n\nTITLE: Flow Pipeline with Alt Function\nDESCRIPTION: Shows how to compose functions in a pipeline using flow and alt with IOResult containers.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/pointfree.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.io import IOFailure, IOSuccess, IOResult\n>>> from returns import pointfree\n\n>>> def always_errors(user_input: str) -> IOResult:\n...     return IOFailure(len(user_input))\n\n>>> def twice_as_bad(exit_code: int) -> int:\n...     return exit_code * 2\n\n>>> def make_error_message(exit_code: int) -> str:\n...     return 'Badness level: {0}'.format(exit_code)\n\n>>> assert flow(\n...     '12345',\n...     always_errors,\n...     pointfree.alt(twice_as_bad),\n...     pointfree.alt(make_error_message)\n... ) == IOFailure('Badness level: 10')\n```\n\n----------------------------------------\n\nTITLE: Function specifically for Maybe container\nDESCRIPTION: A function that only works with Maybe containers, rejecting other container types, using KindN with a specific container type.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/hkt.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.maybe import Maybe\n\n>>> @kinded\n... def works_with_maybe(\n...     container: KindN[Maybe, _FirstType, _SecondType, _ThirdType],\n... ) -> KindN[Maybe, str, _SecondType, _ThirdType]:\n...     return container.map(str)\n\n>>> assert works_with_maybe(Maybe.from_value(1)) == Maybe.from_value('1')\n```\n\n----------------------------------------\n\nTITLE: Converting Maybe to Optional in Python\nDESCRIPTION: Demonstrates how to convert a Maybe value back to an Optional value using the value_or method with None.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/maybe.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.maybe import Maybe\n>>> assert Maybe.from_optional(1).value_or(None) == 1\n>>> assert Maybe.from_optional(None).value_or(None) == None\n```\n\n----------------------------------------\n\nTITLE: Generic function with interface-bound TypeVar\nDESCRIPTION: An example of a function that works with any type implementing the MappableN interface using KindN and TypeVar with bound parameter.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/hkt.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import TypeVar\n>>> from returns.primitives.hkt import KindN, kinded\n>>> from returns.interfaces.mappable import MappableN\n\n>>> _FirstType = TypeVar('_FirstType')\n>>> _SecondType = TypeVar('_SecondType')\n>>> _ThirdType = TypeVar('_ThirdType')\n>>> _MappableKind = TypeVar('_MappableKind', bound=MappableN)\n\n>>> @kinded\n... def works_with_interface(\n...     container: KindN[_MappableKind, _FirstType, _SecondType, _ThirdType],\n... ) -> KindN[_MappableKind, str, _SecondType, _ThirdType]:\n...     return container.map(str)\n```\n\n----------------------------------------\n\nTITLE: Apply Function with Curried Functions\nDESCRIPTION: Shows how to use apply with curried functions in a flow pipeline.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/pointfree.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.pipeline import flow\n>>> from returns.curry import curry\n>>> from returns.maybe import Some\n\n>>> @curry\n... def add_curried(first: int, second: int) -> int:\n...     return first + second\n\n>>> assert flow(\n...     Some(add_curried),\n...     Some(2).apply,\n...     Some(3).apply,\n... ) == Some(5)\n```\n\n----------------------------------------\n\nTITLE: Instantiating Containers with from_value Method\nDESCRIPTION: Shows how to create a new container from a raw value using the from_value method available in ApplicativeN containers. The example creates a Success container with a value of 1.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/container.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.result import Result\n>>> assert str(Result.from_value(1)) == '<Success: 1>'\n```\n\n----------------------------------------\n\nTITLE: Using returns.curry.partial with Overloaded Functions\nDESCRIPTION: This code shows how returns.curry.partial handles functions with multiple @overload definitions, correctly maintaining all matching overload cases while discriminating non-matching ones.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/curry.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import overload\nfrom returns.curry import partial\n\n@overload\ndef test(a: int, b: str) -> str:\n    ...\n\n@overload\ndef test(a: int) -> int:\n    ...\n\n@overload\ndef test(a: str) -> None:  # won't match!\n    ...\n\ndef test(a, b=None):\n    ...\n\nreveal_type(partial(test, 1))  # N: Revealed type is 'Overload(def (b: builtins.str) -> builtins.str, def () -> builtins.int)'\n```\n\n----------------------------------------\n\nTITLE: Testing the interface-bound function with various containers\nDESCRIPTION: Demonstrating how the works_with_interface function accepts different container types that implement the MappableN interface.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/hkt.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.maybe import Maybe\n>>> from returns.io import IO\n>>> from returns.result import Success\n\n>>> assert works_with_interface(Maybe.from_value(1)) == Maybe.from_value('1')\n>>> assert works_with_interface(IO.from_value(1)) == IO.from_value('1')\n>>> assert works_with_interface(Success(1)) == Success('1')\n```\n\n----------------------------------------\n\nTITLE: Type Discrimination with @curry Decorated Functions\nDESCRIPTION: This code shows how the type system for @curry functions narrows down to more specific types as arguments are provided, following the correct path through the overload tree.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/curry.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(zero(1, 2.0))\n# By providing this set of arguments we have chosen this path:\n#\n#   def (a: builtins.int, b: builtins.float) -> def (*, kw: builtins.bool)\n#     -> builtins.str,\n#\n# And the revealed type would be:\n#\n#   def (*, kw: builtins.bool) -> builtins.str\n#\n```\n\n----------------------------------------\n\nTITLE: Executing Future Container with anyio in Python\nDESCRIPTION: Example of how to execute a Future container using an async library like anyio. This shows that Future requires a proper event loop for execution, but can work with any async library or event loop implementation.\nSOURCE: https://github.com/dry-python/returns/blob/master/README.md#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nimport anyio  # or asyncio, or any other lib\n\n# We can then pass our `Future` to any library: asyncio, trio, curio.\n# And use any event loop: regular, uvloop, even a custom one, etc\nassert anyio.run(second().awaitable) == 2\n```\n\n----------------------------------------\n\nTITLE: Using Maybe for Complex Data Access in Python\nDESCRIPTION: Demonstrates using Maybe to safely access nested optional attributes in complex data structures, removing the need for multiple None checks.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/maybe.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from attr import dataclass\n>>> from typing import Optional\n>>> from returns.maybe import Maybe, Nothing\n\n>>> @dataclass\n... class Address(object):\n...     street: Optional[str]\n\n>>> @dataclass\n... class User(object):\n...     address: Optional[Address]\n\n>>> @dataclass\n... class Order(object):\n...     user: Optional[User]\n\n>>> def get_street_address(order: Order) -> Maybe[str]:\n...     return Maybe.from_optional(order.user).bind_optional(\n...         lambda user: user.address,\n...     ).bind_optional(\n...         lambda address: address.street,\n...     )\n\n>>> with_address = Order(User(Address('Some street')))\n>>> empty_user = Order(None)\n>>> empty_address = Order(User(None))\n>>> empty_street = Order(User(Address(None)))\n\n>>> str(get_street_address(with_address))  # all fields are not None\n'<Some: Some street>'\n\n>>> assert get_street_address(empty_user) == Nothing\n>>> assert get_street_address(empty_address) == Nothing\n>>> assert get_street_address(empty_street) == Nothing\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Laws for Pair Container in Python\nDESCRIPTION: Definition of law specs for the Pair container which defines expected behaviors that can be tested. These laws help ensure the container behaves correctly according to its algebraic properties.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/create-your-own-container.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef _LawSpec(\n    container_type,\n    args=None,\n):\n    # Importing inside function to avoid circular imports.\n    from returns.methods import cond, tap\n    from returns.pointfree import alt, bind, lash, map_\n\n    first_arg, second_arg = args if args is not None else (1, 2)\n    pair = container_type.pair(first_arg, second_arg)\n    empty = lambda arg: arg  # noqa: WPS111, E731\n\n    swap_law = (\n        'Swap changes position of value',\n        lambda: container_type.pair(first_arg, second_arg).swap(),\n        lambda: container_type.pair(second_arg, first_arg),\n    )\n\n    swap_twice_law = (\n        'Swap twice returns original value',\n        lambda: container_type.pair(first_arg, second_arg).swap().swap(),\n        lambda: container_type.pair(first_arg, second_arg),\n    )\n\n    from_unpaired_law = (\n        'From unpaired should create same values',\n        lambda: container_type.from_unpaired(first_arg),\n        lambda: container_type.pair(first_arg, first_arg),\n    )\n\n    return (swap_law, swap_twice_law, from_unpaired_law)\n```\n\n----------------------------------------\n\nTITLE: Traditional Optional Value Handling in Python\nDESCRIPTION: Illustrates the traditional way of handling Optional values with multiple None checks, which is more verbose and complex compared to using Maybe.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/maybe.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\norder: Order  # some existing Order instance\nstreet: Optional[str] = None\nif order.user is not None:\n    if order.user.address is not None:\n        street = order.user.address.street\n```\n\n----------------------------------------\n\nTITLE: Apply Function in Pipeline\nDESCRIPTION: Demonstrates using the apply function within a flow pipeline with Maybe containers.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/pointfree.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns import pointfree\n>>> from returns.pipeline import flow\n>>> from returns.maybe import Some, Nothing, Maybe\n>>> from typing import Callable\n\n>>> def wow(arg: int) -> str:\n...     return chr(arg) + '!'\n\n>>> def my_response(is_excited: bool) -> Maybe[Callable[[int], str]]:\n...     if is_excited:\n...         return Some(wow)\n...     return Nothing\n\n>>> assert flow(\n...     Some(97),\n...     pointfree.apply(my_response(True)),\n... ) == Some('a!')\n\n>>> assert flow(\n...     Nothing,\n...     pointfree.apply(my_response(False)),\n... ) == Nothing\n```\n\n----------------------------------------\n\nTITLE: Complete Pair Container Implementation in Python\nDESCRIPTION: The initial full implementation of the Pair container with all required interface methods including map, bind, alt, lash, swap, and equals. This provides the basic functionality needed to satisfy the defined interfaces.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/create-your-own-container.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable, TypeVar, Tuple, final\n\nfrom returns.interfaces import bindable, equable, lashable, swappable\nfrom returns.primitives.container import BaseContainer\nfrom returns.primitives.hkt import SupportsKind2\n\n_FirstType = TypeVar('_FirstType')\n_SecondType = TypeVar('_SecondType')\n\n_NewFirstType = TypeVar('_NewFirstType')\n_NewSecondType = TypeVar('_NewSecondType')\n\n\n@final\nclass Pair(\n    BaseContainer,\n    SupportsKind2['Pair', _FirstType, _SecondType],\n    bindable.Bindable2[_FirstType, _SecondType],\n    swappable.Swappable2[_FirstType, _SecondType],\n    lashable.Lashable2[_FirstType, _SecondType],\n    equable.Equable,\n):\n    \"\"\"Pair is a container for two values.\"\"\"\n\n    def __init__(\n        self, inner_value: Tuple[_FirstType, _SecondType],\n    ) -> None:\n        \"\"\"Initialize a new Pair instance.\"\"\"\n        super().__init__(inner_value)\n\n    def map(\n        self,\n        function: Callable[[_FirstType], _NewFirstType],\n    ) -> 'Pair[_NewFirstType, _SecondType]':\n        \"\"\"Map over the first value.\"\"\"\n        first, second = self._inner_value\n        return Pair((function(first), second))\n\n    def bind(\n        self,\n        function: Callable[\n            [_FirstType],\n            'Pair[_NewFirstType, _SecondType]',\n        ],\n    ) -> 'Pair[_NewFirstType, _SecondType]':\n        \"\"\"Bind the first value.\"\"\"\n        first, second = self._inner_value\n        return function(first)\n\n    def alt(\n        self,\n        function: Callable[[_SecondType], _NewSecondType],\n    ) -> 'Pair[_FirstType, _NewSecondType]':\n        \"\"\"Map over the second value.\"\"\"\n        first, second = self._inner_value\n        return Pair((first, function(second)))\n\n    def lash(\n        self,\n        function: Callable[\n            [_SecondType],\n            'Pair[_FirstType, _NewSecondType]',\n        ],\n    ) -> 'Pair[_FirstType, _NewSecondType]':\n        \"\"\"Bind the second value.\"\"\"\n        first, second = self._inner_value\n        new = function(second)\n        new_first, new_second = new._inner_value  # noqa: WPS437\n        return Pair((first, new_second))\n\n    def swap(self) -> 'Pair[_SecondType, _FirstType]':\n        \"\"\"Swap first and second values.\"\"\"\n        first, second = self._inner_value\n        return Pair((second, first))\n\n    def equals(self, other) -> bool:\n        \"\"\"Check if two Pairs are equal.\"\"\"\n        if not isinstance(other, Pair):\n            return False\n        return self._inner_value == other._inner_value  # noqa: WPS437\n```\n\n----------------------------------------\n\nTITLE: Enhanced PairLikeN Interface with Laws in Python\nDESCRIPTION: Updated PairLikeN interface that includes law specifications. This demonstrates how to add testable laws to interfaces to ensure implementations comply with expected behaviors.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/create-your-own-container.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass PairLikeN(swappable.SwappableN, bindable.BindableN, lashable.LashableN):\n    \"\"\"Interface for types that work like a Pair.\"\"\"\n\n    @classmethod\n    def from_unpaired(\n        cls,\n        inner_value: _FirstType,\n    ) -> Kind2[N, _FirstType, _FirstType]:\n        \"\"\"Creates a new Pair with the same values.\"\"\"\n\n    @law\n    def _laws(container_type) -> Iterable[Law]:\n        \"\"\"Returns an iterator of laws that should hold for this container.\"\"\"\n        for reg_law in _LawSpec(container_type):\n            yield reg_law\n\n    @classmethod\n    def pair(\n        cls,\n        first: _FirstType,\n        second: _SecondType,\n    ) -> Kind2[N, _FirstType, _SecondType]:\n        \"\"\"Creates a new Pair with two values.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using Fold.collect with Missing Values\nDESCRIPTION: Demonstrates how Fold.collect handles missing values. When any container in the collection is Nothing, the result is also Nothing, showing the fail-fast behavior.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/container.rst#2025-04-21_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> fetched_values: List[Maybe[int]] = [\n...     maybe(source.get)(key)\n...     for key in ('a', 'c')  # 'c' is missing!\n... ]\n>>> assert Fold.collect(fetched_values, Some(())) == Nothing\n```\n\n----------------------------------------\n\nTITLE: Creating a Decorator with Arguments Using Python Functions\nDESCRIPTION: Example of a traditional Python decorator with arguments that modifies function behavior based on configuration parameters. This is shown for comparison with RequiresContext usage.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/context.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef example(print_result: bool):\n    def decorator(function):\n        def factory(*args, **kwargs):\n            original = function(*args, **kwargs)\n            if print_result:\n                print(original)\n            return original\n        return factory\n    return decorator\n```\n\n----------------------------------------\n\nTITLE: Unwrap or Failure Method Usage\nDESCRIPTION: Demonstrates the unwrap_or_failure method with IO types, showing how to extract values from either successful or failed computations.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/methods.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom returns.io import IO, IOSuccess, IOFailure\nfrom returns import methods\n\nassert methods.unwrap_or_failure(IOSuccess(1)) == IO(1)\nassert methods.unwrap_or_failure(IOFailure('a')) == IO('a')\n```\n\n----------------------------------------\n\nTITLE: Defining MappableN Type Hints in Python\nDESCRIPTION: Demonstrates type hint usage for MappableN interface with different numbers of type parameters using Never type for unused parameters.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/interfaces.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing_extensions import Never\n\n>>> from returns.interfaces.mappable import (\n...    MappableN, Mappable1, Mappable2, Mappable3,\n... )\n\n>>> one_type: MappableN[int, Never, Never]\n>>> two_types: MappableN[int, str, Never]\n>>> three_types: MappableN[int, str, bool]\n\n>>> # We have a shortcut for each amount of arguments to reduce the boilerplate\n>>> one_type: Mappable1[int]\n>>> two_types: Mappable2[int, str]\n>>> three_type: Mappable3[int, str, bool]\n```\n\n----------------------------------------\n\nTITLE: Using Custom ContextAwareFold for Large Iterables in Python\nDESCRIPTION: Demonstrates the use of the custom ContextAwareFold class to process a large number of Reader instances without encountering recursion errors.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/types.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> items = [Reader.from_value(num) for num in range(sys.getrecursionlimit())]\n>>> assert ContextAwareFold.loop(\n...    items, Reader.from_value(0), lambda x: lambda y: x + y,\n... )(...) == sum(range(sys.getrecursionlimit()))\n```\n\n----------------------------------------\n\nTITLE: Converting a list of integers to strings using generics\nDESCRIPTION: A function that works with generic types, specifically transforming List[int] to List[str] by applying str() to each item in the list.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/hkt.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import List\n\n>>> def all_to_str(arg: List[int]) -> List[str]:\n...     return [str(item) for item in arg]\n\n>>> assert all_to_str([1, 2]) == ['1', '2']\n```\n\n----------------------------------------\n\nTITLE: Handling Errors with lash Method in Returns\nDESCRIPTION: Shows how to use the lash method to handle errors and potentially convert a failed container to a successful one. This example demonstrates error tolerance based on exception type.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/railway.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.result import Result, Failure, Success\n\n>>> def tolerate_exception(state: Exception) -> Result[int, Exception]:\n...     if isinstance(state, ZeroDivisionError):\n...         return Success(0)\n...     return Failure(state)\n\n>>> value: Result[int, Exception] = Failure(ZeroDivisionError())\n>>> result: Result[int, Exception] = value.lash(tolerate_exception)\n>>> assert result == Success(0)\n\n>>> value2: Result[int, Exception] = Failure(ValueError())\n>>> result2: Result[int, Exception] = value2.lash(tolerate_exception)\n>>> # => Failure(ValueError())\n```\n\n----------------------------------------\n\nTITLE: Comparing Generics Support in functools.partial vs returns.curry.partial\nDESCRIPTION: This comparison shows how returns.curry.partial handles generics correctly, while functools.partial fails to properly infer types with generic TypeVars.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/curry.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom functools import partial\nfrom typing import List, TypeVar\n\nT = TypeVar('T')\n\nx: List[int]\n\ndef some_function(first: List[T], second: int) -> T:\n    return first[second]\n\nreveal_type(partial(some_function, x))\n# => functools.partial[T`-1]\n# => Which is broken!\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom returns.curry import partial\n\nreveal_type(partial(some_function, x))\n# => def (second: builtins.int) -> builtins.int*\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom ContextAwareFold in Python\nDESCRIPTION: Defines a custom ContextAwareFold class that extends AbstractFold to handle Reader instances without recursion, avoiding RecursionError for large iterables.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/types.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.iterables import AbstractFold\n\n>>> class ContextAwareFold(AbstractFold):\n...     @classmethod\n...     def _loop(cls, iterable, acc, function, concat, deps=None):\n...         wrapped = acc.from_value(function)\n...         for current in iterable:\n...             assert isinstance(current, Reader)\n...             acc = Reader.from_value(concat(current, acc, wrapped)(deps))\n...         return acc\n```\n\n----------------------------------------\n\nTITLE: Lash Function Usage Example\nDESCRIPTION: Demonstrates using the lash pointfree function with Result containers.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/pointfree.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns import pointfree\n>>> from returns.result import Success, Failure, Result\n\n>>> def always_succeeds(arg: str) -> Result[int, str]:\n...     return Success(1)\n\n>>> failed: Result[int, str] = Failure('a')\n>>> # We now have two way of composing these entities.\n>>> # 1. Via ``.lash``:\n>>> assert failed.lash(always_succeeds) == Success(1)\n>>> # 2. Or via ``lash`` function, the same but in the inverse way:\n>>> assert pointfree.lash(always_succeeds)(failed) == Success(1)\n```\n\n----------------------------------------\n\nTITLE: Using Maybe Container in Python\nDESCRIPTION: Example of using the Maybe container to handle potentially None values, improving code readability and safety.\nSOURCE: https://github.com/dry-python/returns/blob/master/README.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\nfrom returns.maybe import Maybe, maybe\n\n@maybe  # decorator to convert existing Optional[int] to Maybe[int]\ndef bad_function() -> Optional[int]:\n    ...\n\nmaybe_number: Maybe[float] = bad_function().bind_optional(\n    lambda number: number / 2,\n)\n# => Maybe will return Some[float] only if there's a non-None value\n#    Otherwise, will return Nothing\n```\n\n----------------------------------------\n\nTITLE: Error Handling with @curry Decorator\nDESCRIPTION: This example shows how functions decorated with @curry handle incorrect argument calls, raising appropriate TypeError exceptions for invalid arguments.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/curry.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> function(1, 2, 3)\nTraceback (most recent call last):\n  ...\nTypeError: too many positional arguments\n\n>>> function(a=1)\nTraceback (most recent call last):\n  ...\nTypeError: got an unexpected keyword argument 'a'\n```\n\n----------------------------------------\n\nTITLE: Testing error handling with is_error_handled\nDESCRIPTION: Demonstrates using the is_error_handled function to verify that containers properly handle their error track. This helps ensure that error handling is implemented correctly in complex container pipelines.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/contrib/pytest_plugins.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.result import Failure, Success\n>>> from returns.contrib.pytest import ReturnsAsserts\n\n>>> def test_error_handled(returns: ReturnsAsserts):\n...     assert not returns.is_error_handled(Failure(1))\n...     assert returns.is_error_handled(\n...         Failure(1).lash(lambda _: Success('default value')),\n...     )\n\n>>> # We only run these tests manually, because it is a doc example:\n>>> returns_fixture = getfixture('returns')\n>>> test_error_handled(returns_fixture)\n```\n\n----------------------------------------\n\nTITLE: Comparing container equality with assert_equal\nDESCRIPTION: Shows how different Returns containers handle equality comparison and how to use the assert_equal helper to properly compare containers that don't support standard equality operators.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/contrib/pytest_plugins.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.result import Result\n>>> from returns.context import Reader\n\n>>> assert Result.from_value(1) == Result.from_value(1)\n>>> Reader.from_value(1) == Reader.from_value(1)\nFalse\n```\n\n----------------------------------------\n\nTITLE: Using a Decorator with Arguments\nDESCRIPTION: Example of applying a decorator with arguments to a function, which permanently modifies the function's behavior. This is compared to the more flexible RequiresContext approach.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/context.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n@example(print_result=True)\ndef my_function(first: int, second: int) -> int:\n    return first + second\n\nassert my_function(2, 3) == 5\n5\n```\n\n----------------------------------------\n\nTITLE: Basic Hypothesis Strategy Usage with Returns\nDESCRIPTION: Demonstrates how to use Hypothesis strategies with Returns containers like Result\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/contrib/hypothesis_plugins.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom returns.result import Result\nfrom hypothesis import strategies as st\n\nassert st.from_type(Result).example()\n```\n\n----------------------------------------\n\nTITLE: Using assert_equal from pytest fixture\nDESCRIPTION: Demonstrates using the assert_equal method from the Returns pytest fixture to compare containers that don't support standard equality operators, like Reader containers.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/contrib/pytest_plugins.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.result import Success\n>>> from returns.context import Reader\n>>> from returns.contrib.pytest import ReturnsAsserts\n\n>>> def test_container_equality(returns: ReturnsAsserts):\n...     returns.assert_equal(Success(1), Success(1))\n...     returns.assert_equal(Reader.from_value(1), Reader.from_value(1))\n\n>>> # We only run these tests manually, because it is a doc example:\n>>> returns_fixture = getfixture('returns')\n>>> test_container_equality(returns_fixture)\n```\n\n----------------------------------------\n\nTITLE: Tracing Failures Using Decorator in Python Returns\nDESCRIPTION: Shows how to implement failure tracing using collect_traces as a function decorator. Demonstrates tracing for IOFailure instances and how to access and verify trace information.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/development.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from inspect import FrameInfo\n\n>>> from returns.io import IOFailure, IOResult\n>>> from returns.result import Failure, Result\n>>> from returns.primitives.tracing import collect_traces\n\n>>> @collect_traces\n... def traced_function(value: str) -> IOResult[str, str]:\n...     return IOFailure(value)\n\n>>> non_traced_failure = Failure('Normal Failure')\n>>> traced_failure = traced_function('Traced Failure')\n\n>>> assert non_traced_failure.trace is None\n>>> assert isinstance(traced_failure.trace, list)\n>>> assert all(isinstance(trace_line, FrameInfo) for trace_line in traced_failure.trace)\n\n>>> for trace_line in traced_failure.trace:\n...     print(f\"{trace_line.filename}:{trace_line.lineno} in `{trace_line.function}`\") # doctest: +SKIP\n...\n/returns/returns/result.py:525 in `Failure`\n/returns/returns/io.py:852 in `IOFailure`\n/example_folder/example.py:7: in `traced_function`\n/usr/lib/python3.8/contextlib.py:75 in `inner`\n/example_folder/example.py:1 in `<module>`\n```\n\n----------------------------------------\n\nTITLE: Basic IO Container Usage with Random Numbers\nDESCRIPTION: Demonstrates how to use the IO container to mark impure operations that don't fail, using a random number generator example.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/io.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import random\n>>> from returns.io import IO\n>>> def get_random_number() -> IO[int]:\n...     return IO(random.randint(1, 10))\n...\n>>> assert isinstance(get_random_number(), IO)\n```\n\n----------------------------------------\n\nTITLE: Configuring Law Checking Settings\nDESCRIPTION: Example of configuring Hypothesis settings for law checking\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/contrib/hypothesis_plugins.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncheck_all_laws(YourCustomContainer, settings_kwargs={'max_examples': 500})\n```\n\n----------------------------------------\n\nTITLE: Global Strategy Registration\nDESCRIPTION: Examples of registering container strategies globally for Hypothesis\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/contrib/hypothesis_plugins.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom hypothesis import strategies as st\nfrom returns.contrib.hypothesis.containers import strategy_from_container\n\nst.register_type_strategy(\n    YourContainerClass,\n    strategy_from_container(YourContainerClass),\n)\n```\n\n----------------------------------------\n\nTITLE: Applicative Identity Law Implementation\nDESCRIPTION: Shows the implementation of the Identity Law for Applicatives where applying an identity function should return the same value.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/interfaces.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom returns.functions import identity\n\napplicative_number: Number[int] = Number(1)\nassert applicative_number.apply(\n    applicative_number.from_value(identity),\n) == Number(1)\n```\n\n----------------------------------------\n\nTITLE: Using Do-Notation with IO Container in Python\nDESCRIPTION: Demonstrates how to use the 'do' method of the IO container to compose two IO containers with the 'add' function. This example shows how do-notation simplifies working with multiple containers.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/do-notation.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.io import IO\n\n>>> assert IO.do(\n...     add(first, second)\n...     for first in IO(2)\n...     for second in IO(3)\n... ) == IO(5)\n```\n\n----------------------------------------\n\nTITLE: Global Strategy Registration with Init\nDESCRIPTION: Example of registering container strategy with init method enabled\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/contrib/hypothesis_plugins.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nst.register_type_strategy(\n    YourContainerClass,\n    strategy_from_container(YourContainerClass, use_init=True),\n)\n```\n\n----------------------------------------\n\nTITLE: Custom Container Implementation with Init\nDESCRIPTION: Example of implementing a custom container with __init__ method for law checking\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/contrib/hypothesis_plugins.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable, TypeVar, final\nfrom returns.interfaces.mappable import Mappable1\nfrom returns.primitives.container import BaseContainer\nfrom returns.primitives.hkt import SupportsKind1\n\n_ValueType = TypeVar('_ValueType')\n_NewValueType = TypeVar('_NewValueType')\n\n@final\nclass Number(\n    BaseContainer,\n    SupportsKind1['Number', _ValueType],\n    Mappable1[_ValueType],\n):\n    def __init__(self, inner_value: _ValueType) -> None:\n        super().__init__(inner_value)\n\n    def map(\n        self,\n        function: Callable[[_ValueType], _NewValueType],\n    ) -> 'Number[_NewValueType]':\n        return Number(function(self._inner_value))\n\n# We want to allow ``__init__`` method to be used:\ncheck_all_laws(Number, use_init=True)\n```\n\n----------------------------------------\n\nTITLE: Generic copy function using TypeVar\nDESCRIPTION: A function that copies any value using a TypeVar to maintain the same type for input and output parameters.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/hkt.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import TypeVar\n>>> ValueType = TypeVar('ValueType')\n\n>>> def copy(arg: ValueType) -> ValueType:\n...    ...\n```\n\n----------------------------------------\n\nTITLE: Composing Sync and Async Functions with Future Container in Python\nDESCRIPTION: Demonstrates how to use the Future container to compose synchronous and asynchronous functions, allowing async interactions in a sync context.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/future.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.future import Future\n\n>>> async def first() -> int:\n...     return 1\n\n>>> async def second(arg: int) -> int:\n...     return arg + 1\n\n>>> def main() -> Future[int]:  # sync function!\n...    return Future(first()).bind_awaitable(second)\n```\n\n----------------------------------------\n\nTITLE: Installing Returns with Compatible Mypy Support\nDESCRIPTION: Command to install Returns library with the compatible mypy version included as an extra dependency.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/contrib/mypy_plugins.rst#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install 'returns[compatible-mypy]'\n```\n\n----------------------------------------\n\nTITLE: Law Checking for Custom Containers\nDESCRIPTION: Shows how to use the check_all_laws function to verify container implementations\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/contrib/hypothesis_plugins.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom returns.contrib.hypothesis.laws import check_all_laws\nfrom your.module import YourCustomContainer\n\ncheck_all_laws(YourCustomContainer)\n```\n\n----------------------------------------\n\nTITLE: Implementing Point Calculation Logic\nDESCRIPTION: This snippet shows the initial implementation of the point calculation logic, which counts guessed letters and awards points based on a fixed threshold.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/context.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef calculate_points(word: str) -> int:\n    guessed_letters_count = len([letter for letter in word if letter != '.'])\n    return _award_points_for_letters(guessed_letters_count)\n\ndef _award_points_for_letters(guessed: int) -> int:\n    return 0 if guessed < 5 else guessed  # minimum 6 points possible!\n```\n\n----------------------------------------\n\nTITLE: Testing container creation with assert_trace\nDESCRIPTION: Shows how to use assert_trace to verify that containers are created correctly at specific points in a flow. This helps identify when and where specific container types are created in complex operations.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/contrib/pytest_plugins.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.result import Result, Success, Failure\n>>> from returns.contrib.pytest import ReturnsAsserts\n\n>>> def desired_function(arg: str) -> Result[int, str]:\n...     if arg.isnumeric():\n...         return Success(int(arg))\n...     return Failure('\"{0}\" is not a number'.format(arg))\n\n>>> def test_if_failure_is_created_at_convert_function(\n...     returns: ReturnsAsserts,\n... ):\n...     with returns.assert_trace(Failure, desired_function):\n...         Success('not a number').bind(desired_function)\n\n>>> def test_if_success_is_created_at_convert_function(\n...     returns: ReturnsAsserts,\n... ):\n...     with returns.assert_trace(Success, desired_function):\n...         Success('42').bind(desired_function)\n\n>>> # We only run these tests manually, because it is a doc example:\n>>> returns_fixture = getfixture('returns')\n>>> test_if_failure_is_created_at_convert_function(returns_fixture)\n>>> test_if_success_is_created_at_convert_function(returns_fixture)\n```\n\n----------------------------------------\n\nTITLE: Enabling Returns Mypy Plugin in TOML Configuration\nDESCRIPTION: Configuration for adding the Returns mypy plugin to your pyproject.toml file to enable its type checking features.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/contrib/mypy_plugins.rst#2025-04-21_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[tool.mypy]\nplugins = [\"returns.contrib.mypy.returns_plugin\"]\n```\n\n----------------------------------------\n\nTITLE: Hypothetical TypeVar usage with subscripting (not working)\nDESCRIPTION: A non-working example showing how we might want to write a generic container transformation function if Python supported subscripting TypeVars.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/hkt.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar\nfrom returns.interfaces.container import Container1\n\nT = TypeVar('T', bound=Container1)\n\ndef all_to_str(arg: T[int]) -> T[str]:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Traditional Async Code Pattern in Python\nDESCRIPTION: Shows the traditional way of writing async code with multiple await statements and manual error handling. This represents the imperative style that some developers want to avoid.\nSOURCE: https://github.com/dry-python/returns/blob/master/README.md#2025-04-21_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nasync def fetch_user(user_id: int) -> 'User':\n    ...\n\nasync def get_user_permissions(user: 'User') -> 'Permissions':\n    ...\n\nasync def ensure_allowed(permissions: 'Permissions') -> bool:\n    ...\n\nasync def main(user_id: int) -> bool:\n    # Also, don't forget to handle all possible errors with `try / except`!\n    user = await fetch_user(user_id)  # We will await each time we use a coro!\n    permissions = await get_user_permissions(user)\n    return await ensure_allowed(permissions)\n```\n\n----------------------------------------\n\nTITLE: Using Fold.loop with Different Initial Value\nDESCRIPTION: Shows how to use Fold.loop with a different initial value. By changing the starting value from 0 to 5, the final sum is increased accordingly.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/container.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> assert Fold.loop(\n...     numbers,\n...     IO(5),  # now we will start from ``5``, not ``0``\n...     sum_two_numbers,\n... ) == IO(25)\n```\n\n----------------------------------------\n\nTITLE: Configuring Nitpick for Consistent Mypy Settings\nDESCRIPTION: Add Nitpick configuration to pyproject.toml to enforce consistent mypy settings across your projects that match wemake-python-styleguide standards.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/contrib/mypy_plugins.rst#2025-04-21_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[tool.nitpick]\nstyle = \"https://raw.githubusercontent.com/wemake-services/wemake-python-styleguide/master/styles/mypy.toml\"\n```\n\n----------------------------------------\n\nTITLE: Illustrating Requirement for Literal Expressions in Do-Notation in Python\nDESCRIPTION: This example demonstrates why literal generator expressions are required in do-notation. While the code works at runtime, it raises a mypy error due to the use of a variable instead of a literal expression.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/do-notation.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.result import Result, Success\n\n>>> expr = (\n...     first + second\n...     for first in Success(2)\n...     for second in Success(3)\n... )\n>>>\n>>> assert Result.do(expr) == Success(5)\n```\n\n----------------------------------------\n\nTITLE: Using the 'returns' pytest fixture in tests\nDESCRIPTION: Demonstrates how to request and use the 'returns' fixture in pytest test functions. The fixture provides access to the plugin's functionality for testing Returns containers.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/contrib/pytest_plugins.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef test_my_container(returns):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Container Right Identity Law Implementation\nDESCRIPTION: Demonstrates the Right Identity Law where binding with container constructor equals direct container instantiation.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/interfaces.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nnumber = Number(2)\nassert number.bind(Number) == Number(2)\n```\n\n----------------------------------------\n\nTITLE: Installing Returns Python Package\nDESCRIPTION: Command to install the Returns library using pip package manager. The library can be installed as a pure Python package.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/quickstart.rst#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install returns  # or better use poetry\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Use of If Conditions in Do-Notation in Python\nDESCRIPTION: This example shows why using 'if' conditions inside generator expressions passed to .do method is not allowed. It results in a StopIteration error when the condition is not met.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/do-notation.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.io import IO\n\n>>> IO.do(\n...     first + second\n...     for first in IO(2)\n...     for second in IO(3)\n...     if second > 10\n... )\nTraceback (most recent call last):\n  ...\nStopIteration\n```\n\n----------------------------------------\n\nTITLE: Handling Recursion Limits with RequiresContext in Python\nDESCRIPTION: Shows how recursive operations on a large number of RequiresContext instances can lead to recursion errors, setting up the context for a custom solution.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/types.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> import sys\n>>> from returns.context import Reader\n>>> from returns.iterables import Fold\n\n>>> items = [Reader.from_value(num) for num in range(sys.getrecursionlimit())]\n>>> Fold.loop(items, Reader.from_value(0), lambda x: lambda y: x + y)(...)\nTraceback (most recent call last):\n  ...\nRecursionError: ...\n```\n\n----------------------------------------\n\nTITLE: Basic Result Type Conditional Example\nDESCRIPTION: Demonstrates basic usage of Result type for numeric validation using traditional if-else approach.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/methods.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom returns.result import Failure, Result, Success\n\ndef is_numeric(string: str) -> Result[str, str]:\n    if string.isnumeric():\n         return Success('It is a number')\n    return Failure('It is not a number')\n```\n\n----------------------------------------\n\nTITLE: Installing Returns with pip\nDESCRIPTION: Commands to install the Returns library using pip, including an option to install with the latest supported mypy version.\nSOURCE: https://github.com/dry-python/returns/blob/master/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install returns\n```\n\nLANGUAGE: bash\nCODE:\n```\npip install returns[compatible-mypy]\n```\n\n----------------------------------------\n\nTITLE: Overloading the to_str function for specific container types\nDESCRIPTION: Using @overload to define type-specific versions of the to_str function for Maybe and IO containers, improving type checking but limiting extensibility.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/hkt.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import overload\n>>> from returns.maybe import Maybe\n>>> from returns.io import IO\n\n>>> @overload\n... def to_str(arg: Maybe[int]) -> Maybe[str]:\n...    ...\n\n>>> @overload\n... def to_str(arg: IO[int]) -> IO[str]:\n...    ...\n```\n\n----------------------------------------\n\nTITLE: Incorrect Mixing of Container Types in Do-Notation in Python\nDESCRIPTION: This example demonstrates an incorrect usage of do-notation where different container types (Result and IOResult) are mixed. This code will raise a mypy error due to type mismatch.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/do-notation.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns.result import Result, Success\n>>> from returns.io import IOResult, IOSuccess\n\n>>> assert Result.do(\n...     first + second\n...     for first in Success(2)\n...     for second in IOSuccess(3)  # Notice the IO part here\n... ) == Success(5)\n```\n\n----------------------------------------\n\nTITLE: Custom Strategy Registration for Law Checking\nDESCRIPTION: Examples of registering custom strategies for law checking\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/contrib/hypothesis_plugins.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom hypothesis import strategies as st\n\ncheck_all_laws(Number, container_strategy=st.builds(Number, st.integers()))\n```\n\n----------------------------------------\n\nTITLE: Converting integer to string in Python\nDESCRIPTION: A basic function example that transforms a value of type int to type str, demonstrating regular type annotations in Python.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/hkt.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> def from_a_to_b(arg: int) -> str:\n...      return str(arg)\n\n>>> assert from_a_to_b(1) == '1'\n```\n\n----------------------------------------\n\nTITLE: Breaking Changes List - Latest Version\nDESCRIPTION: A markdown list of breaking changes for the latest version, including renames and semantic changes.\nSOURCE: https://github.com/dry-python/returns/blob/master/CHANGELOG.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- **Breaking**: renames mypy plugin from `decorator_plugin` to `returns_plugin`\n- **Breaking**: changes `@safe`, `@impure`, `impure_safe`, `@maybe` semantics\n- **Breaking**: renames `Maybe.new` to `Maybe.from_value`\n- **Breaking**: renames `.from_success()` to `.from_value()`\n- **Breaking**: renames `.from_successful_io()` to `.from_io()`\n- **Breaking**: renames `.from_successful_context()` to `.from_context()`\n- **Breaking**: removes `*_squash` converters\n- **Breaking**: renamed `Instanceable` to `Applicative`\n- **Breaking**: changes `.from_io` and `.from_failed_io` of `IOResult`\n- **Breaking**: removes `.lift` and `.lift_*` methods\n- **Breaking**: removes `@pipeline` function\n```\n\n----------------------------------------\n\nTITLE: Configuring mypy plugin for Returns\nDESCRIPTION: Configuration examples for setting up the Returns mypy plugin in setup.cfg/mypy.ini and pyproject.toml files.\nSOURCE: https://github.com/dry-python/returns/blob/master/README.md#2025-04-21_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n# In setup.cfg or mypy.ini:\n[mypy]\nplugins =\n  returns.contrib.mypy.returns_plugin\n```\n\nLANGUAGE: toml\nCODE:\n```\n[tool.mypy]\nplugins = [\"returns.contrib.mypy.returns_plugin\"]\n```\n\n----------------------------------------\n\nTITLE: Custom Strategy Registration with Multiple Types\nDESCRIPTION: Example of registering multiple custom strategies for law checking\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/contrib/hypothesis_plugins.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom hypothesis import strategies as st\n\ncheck_all_laws(\n    Number,\n    container_strategy=st.builds(Number, st.integers()),\n    type_strategies={Foo: st.builds(Foo, st.text())},\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Addition Function in Python\nDESCRIPTION: Defines a basic function 'add' that takes two integer arguments and returns their sum. This function is used in subsequent examples to demonstrate do-notation.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/do-notation.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> def add(one: int, two: int) -> int:\n...     return one + two\n```\n\n----------------------------------------\n\nTITLE: New Features List - Latest Version\nDESCRIPTION: A markdown list of new features added in the latest version, including new plugins, functions and containers.\nSOURCE: https://github.com/dry-python/returns/blob/master/CHANGELOG.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n- Adds typed `partial` and `curry` mypy plugins\n- Adds typed `flow` plugin\n- Adds typed `pipe` plugin\n- Adds `managed` pipeline function\n- Adds typed pointfree functions\n- Adds `pytest` plugin\n- Adds `Future` container\n- Adds `FutureResult` container\n- Adds `RequiresContextFutureResult` container\n```\n\n----------------------------------------\n\nTITLE: Running Type-Safety Tests with Pytest\nDESCRIPTION: Command to run type-safety tests using pytest-mypy-plugins on the typesafety directory.\nSOURCE: https://github.com/dry-python/returns/blob/master/CONTRIBUTING.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npoetry run pytest typesafety\n```\n\n----------------------------------------\n\nTITLE: Enabling Returns Mypy Plugin in INI Configuration\nDESCRIPTION: Configuration for adding the Returns mypy plugin to your mypy.ini or setup.cfg file to enable its type checking features.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/contrib/mypy_plugins.rst#2025-04-21_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n[mypy]\nplugins =\n  returns.contrib.mypy.returns_plugin\n```\n\n----------------------------------------\n\nTITLE: API Request with Annotated Error Cases in Python\nDESCRIPTION: The same API request function with comments highlighting potential failure points. It shows how the function can fail if the user doesn't exist, network is down, server returns an error, or if the response contains invalid JSON.\nSOURCE: https://github.com/dry-python/returns/blob/master/README.md#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport requests\n\ndef fetch_user_profile(user_id: int) -> 'UserProfile':\n    \"\"\"Fetches UserProfile dict from foreign API.\"\"\"\n    response = requests.get('/api/users/{0}'.format(user_id))\n\n    # What if we try to find user that does not exist?\n    # Or network will go down? Or the server will return 500?\n    # In this case the next line will fail with an exception.\n    # We need to handle all possible errors in this function\n    # and do not return corrupt data to consumers.\n    response.raise_for_status()\n\n    # What if we have received invalid JSON?\n    # Next line will raise an exception!\n    return response.json()\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies with Poetry\nDESCRIPTION: Commands to install project dependencies using Poetry, including optional extras for hypothesis and mypy plugin.\nSOURCE: https://github.com/dry-python/returns/blob/master/CONTRIBUTING.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npoetry install\n```\n\nLANGUAGE: bash\nCODE:\n```\npoetry install --extras check-laws\n```\n\nLANGUAGE: bash\nCODE:\n```\npoetry install --extras compatible-mypy\n```\n\n----------------------------------------\n\nTITLE: Running Standard Tests with Pytest\nDESCRIPTION: Command to run standard tests using pytest on the returns, docs/pages, and tests directories.\nSOURCE: https://github.com/dry-python/returns/blob/master/CONTRIBUTING.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npoetry run pytest returns docs/pages tests\n```\n\n----------------------------------------\n\nTITLE: Bugfixes List - Latest Version\nDESCRIPTION: A markdown list documenting bug fixes in the latest version.\nSOURCE: https://github.com/dry-python/returns/blob/master/CHANGELOG.md#2025-04-21_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n- Fixes that `@safe` decorator was generating incorrect signatures\n- Fixes that `.rescue()` of `RequiresContextResult` was returning `Any`\n- Fixes that `.rescue()` of `RequiresContextIOResult` was returning `Any`\n- Fixes that `RequiresContextResult` and `RequiresContextIOResult` were not `final`\n- Fixes that `ImmutableStateError` was not a subclass of `AttributeError`\n- Fixes that `IOResult` was not showing `str` representation\n```\n\n----------------------------------------\n\nTITLE: Including External Markdown File in RST Documentation\nDESCRIPTION: Uses the Sphinx include directive to incorporate a CHANGELOG.md file located two directories up in the project structure. The myst_parser.sphinx_ parser is specified to handle Markdown content.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/changelog.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. include:: ../../CHANGELOG.md\n   :parser: myst_parser.sphinx_\n```\n\n----------------------------------------\n\nTITLE: Implementing Permission Sync with RequiresContext in Python\nDESCRIPTION: Shows how to implement a permission synchronization system using RequiresContext and Protocol for type safety. The code demonstrates fetching metadata, processing user permissions, and updating a BI system with proper dependency handling.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/context.rst#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable, Dict, Protocol, final\nfrom returns.io import IOResultE\nfrom returns.context import ReaderIOResultE\n\n\nclass _SyncPermissionsDeps(Protocol):\n    fetch_metadata: Callable[[], IOResultE['Metadata']]\n    get_user_permissions: Callable[['Metadata'], Dict[int, str]]  # pure\n    update_bi_permissions: Callable[[Dict[int, str]], IOResultE['Payload']]\n\ndef sync_permissions() -> ReaderIOResultE[_SyncPermissionsDeps, 'Payload']:\n    \"\"\"\n    This functions runs a scheduled task once a day.\n\n    It syncs permissions from the metadata storage to our BI system.\n    \"\"\"\n    def factory(deps: _SyncPermissionsDeps) -> IOResultE['Payload']:\n        return deps.fetch_metadata().map(\n            deps.get_user_permissions,\n        ).bind_ioresult(\n            deps.update_bi_permissions,\n        )\n    return ReaderIOResult(factory)\n```\n\n----------------------------------------\n\nTITLE: Running Type Checks with Mypy\nDESCRIPTION: Command to run type checks using mypy on the returns directory and test files.\nSOURCE: https://github.com/dry-python/returns/blob/master/CONTRIBUTING.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npoetry run mypy returns tests/**/*.py\n```\n\n----------------------------------------\n\nTITLE: Comparing functools.partial vs returns.curry.partial Type Annotations\nDESCRIPTION: This example demonstrates the difference in type annotations between Python's built-in functools.partial and returns.curry.partial. The returns version provides more precise type information for the partially applied function.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/curry.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom functools import partial\n\ndef some_function(first: int, second: int) -> float:\n    return first / second\n\nreveal_type(partial(some_function, 1))\n# => functools.partial[builtins.float*]\n# => Which is really: `def (*Any, **Any) -> builtins.float`\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom returns.curry import partial\n\ndef some_function(first: int, second: int) -> float:\n    return first / second\n\nreveal_type(partial(some_function, 1))\n# => def (second: builtins.int) -> builtins.float*\n# => Which is fair!\n```\n\n----------------------------------------\n\nTITLE: Map Function Usage with Maybe Container\nDESCRIPTION: Shows how to use the map_ pointfree function to transform values within a Maybe container, comparing method and function approaches.\nSOURCE: https://github.com/dry-python/returns/blob/master/docs/pages/pointfree.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from returns import pointfree\n>>> from returns.maybe import Maybe, Some\n\n>>> def as_int(arg: str) -> int:\n...     return ord(arg)\n\n>>> container: Maybe[str] = Some('a')\n>>> # We now have two ways to compose container and as_int\n>>> # 1. Via ``.map()``:\n>>> assert container.map(as_int) == Some(97)\n>>> # 2. Or via ``map_()``, like above but in the reverse order:\n>>> assert pointfree.map_(as_int)(container) == Some(97)\n```\n\n----------------------------------------\n\nTITLE: Running Linting with Flake8\nDESCRIPTION: Command to run linting checks using flake8 on the entire project directory.\nSOURCE: https://github.com/dry-python/returns/blob/master/CONTRIBUTING.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npoetry run flake8 .\n```"
  }
]