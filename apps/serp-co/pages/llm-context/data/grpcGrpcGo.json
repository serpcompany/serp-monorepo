[
  {
    "owner": "grpc",
    "repo": "grpc-go",
    "content": "TITLE: Defining gRPC Service and Methods in Protocol Buffers\nDESCRIPTION: Defines the RouteGuide service and its various RPC methods (simple, server-side streaming, client-side streaming, bidirectional streaming) using Protocol Buffers syntax. Specifies request and response message types, demonstrating how to set up service interfaces and message schemas in a .proto file.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nservice RouteGuide {\n   ...\n}\n\n// Simple RPC method\nrpc GetFeature(Point) returns (Feature) {}\n\n// Server-side streaming RPC method\nrpc ListFeatures(Rectangle) returns (stream Feature) {}\n\n// Client-side streaming RPC method\nrpc RecordRoute(stream Point) returns (RouteSummary) {}\n\n// Bidirectional streaming RPC method\nrpc RouteChat(stream RouteNote) returns (stream RouteNote) {}\n\n// Message type example\nmessage Point {\n  int32 latitude = 1;\n  int32 longitude = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Basic RPC Errors in Go\nDESCRIPTION: Demonstrates a standard gRPC call in Go. It includes creating a context with a timeout, executing the RPC (`client.MyRPC`), and performing a basic check for any returned error. If an error occurs, it is logged.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/anti-patterns.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nctx, cancel := context.WithTimeout(context.Background(), time.Second)\ndefer cancel()\n\nres, err := client.MyRPC(ctx, &MyRequest{})\nif err != nil {\n    // Handle the error appropriately,\n    // log it & return an error to the caller, etc.\n    log.Printf(\"Error calling MyRPC: %v\", err)\n    return nil, err\n}\n\n// Use the response as appropriate\nlog.Printf(\"MyRPC response: %v\", res)\n```\n\n----------------------------------------\n\nTITLE: Implementing Manual RPC Retries with Backoff in Go\nDESCRIPTION: Illustrates a manual retry loop for a gRPC call in Go. It retries the RPC up to `maxRetries` times only if the error's status code is in a predefined set of `retryableStatusCodes` (e.g., `codes.Unavailable`). A simple linear backoff (`time.Duration(i+1) * time.Second`) is applied between retries. The final error is handled if all retries fail.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/anti-patterns.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nvar res *MyResponse\nvar err error\n\nretryableStatusCodes := map[codes.Code]bool{\n  codes.Unavailable: true, // etc\n}\n\n// Retry the RPC a maximum number of times.\nfor i := 0; i < maxRetries; i++ {\n    // Make the RPC.\n    res, err = client.MyRPC(context.TODO(), &MyRequest{})\n\n    // Check if the RPC was successful.\n    if !retryableStatusCodes[status.Code(err)] {\n        // The RPC was successful or errored in a non-retryable way;\n        // do not retry.\n        break\n    }\n\n    // The RPC is retryable; wait for a backoff period before retrying.\n    backoff := time.Duration(i+1) * time.Second\n    log.Printf(\"Error calling MyRPC: %v; retrying in %v\", err, backoff)\n    time.Sleep(backoff)\n}\n\n// Check if the RPC was successful after all retries.\nif err != nil {\n    // All retries failed, so handle the error appropriately\n    log.Printf(\"Error calling MyRPC: %v\", err)\n    return nil, err\n}\n\n// Use the response as appropriate.\nlog.Printf(\"MyRPC response: %v\", res)\n```\n\n----------------------------------------\n\nTITLE: Initializing gRPC Server with TLS in Go\nDESCRIPTION: Shows how to set up a gRPC server with TLS enabled. It involves loading server credentials from certificate and key files using `credentials.NewServerTLSFromFile`, handling potential errors, creating a network listener, initializing the gRPC server using `grpc.NewServer` with the loaded credentials via `grpc.Creds`, and finally starting the server with `server.Serve`.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-auth-support.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\ncreds, err := credentials.NewServerTLSFromFile(certFile, keyFile)\nif err != nil {\n  log.Fatalf(\"Failed to generate credentials %v\", err)\n}\nlis, err := net.Listen(\"tcp\", \":0\")\nserver := grpc.NewServer(grpc.Creds(creds))\n...\nserver.Serve(lis)\n```\n\n----------------------------------------\n\nTITLE: Generating gRPC Client and Server Interface Code with protoc\nDESCRIPTION: Shows the command to generate Go code from the .proto service definition using protoc and the gRPC plugin. Produces files including message types, service client stubs, and server interfaces, essential for implementing gRPC communication in Go projects.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nprotoc --go_out=.  --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative \"route_guide.proto\"\n```\n\n----------------------------------------\n\nTITLE: Importing gRPC in Go\nDESCRIPTION: This snippet shows how to import the gRPC library in a Go project. This import statement allows automatic fetching of necessary dependencies when building, running, or testing the application.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport \"google.golang.org/grpc\"\n```\n\n----------------------------------------\n\nTITLE: Initializing gRPC Client with TLS in Go\nDESCRIPTION: Demonstrates how to establish a secure gRPC client connection using TLS. It utilizes `grpc.Dial` along with the `grpc.WithTransportCredentials` option, configured with client TLS credentials obtained from `credentials.NewClientTLSFromCert`. Assumes `serverAddr` contains the target server address.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-auth-support.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\nconn, err := grpc.Dial(serverAddr, grpc.WithTransportCredentials(credentials.NewClientTLSFromCert(nil, \"\")))\n```\n\n----------------------------------------\n\nTITLE: Implementing the GetFeature RPC Method in a gRPC Server in Go\nDESCRIPTION: Implements the server-side logic for the GetFeature RPC, which receives a Point and returns the corresponding Feature if found, or an unnamed Feature if not. Uses context and request parameters, returning the feature data along with error handling. Demonstrates server method structure conforming to the generated interface.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nfunc (s *routeGuideServer) GetFeature(ctx context.Context, point *pb.Point) (*pb.Feature, error) {\n    for _, feature := range s.savedFeatures {\n        if proto.Equal(feature.Location, point) {\n            return feature, nil\n        }\n    }\n    // No feature was found, return an unnamed feature\n    return &pb.Feature{\"\", point}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Calling a Simple RPC from a gRPC Client in Go\nDESCRIPTION: This code demonstrates how to call a simple (unary) RPC method from a gRPC client in Go. It shows how to pass a request object and a context to the `GetFeature` method and handle the response or any potential errors. The `pb.Point` is the request type.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nfeature, err := client.GetFeature(ctx, &pb.Point{409146138, -746188906})\nif err != nil {\n        ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Server-Side Streaming RPC with gRPC-Go\nDESCRIPTION: This code snippet demonstrates how to implement a server-side streaming RPC using gRPC-Go. The `ListFeatures` function receives a request (`Rectangle`) and returns a stream of `Feature` objects. The `stream.Send()` method is used to send multiple responses to the client. The function returns `nil` when finished or an error if one occurs during the process.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc (s *routeGuideServer) ListFeatures(rect *pb.Rectangle, stream pb.RouteGuide_ListFeaturesServer) error {\n    for _, feature := range s.savedFeatures {\n        if inRange(feature.Location, rect) {\n            if err := stream.Send(feature); err != nil {\n                return err\n            }\n        }\n    }\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Bidirectional Streaming RPC with gRPC-Go\nDESCRIPTION: This code demonstrates a bidirectional streaming RPC implementation using gRPC-Go. The `RouteChat` function receives and sends messages using the same stream. The `stream.Recv()` method receives messages, and `stream.Send()` sends responses back to the client.  It continues until the client closes the connection.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nfunc (s *routeGuideServer) RouteChat(stream pb.RouteGuide_RouteChatServer) error {\n    for {\n        in, err := stream.Recv()\n        if err == io.EOF {\n            return nil\n        }\n        if err != nil {\n            return err\n        }\n        key := serialize(in.Location)\n                ... // look for notes to be sent to client\n        for _, note := range s.routeNotes[key] {\n            if err := stream.Send(note); err != nil {\n                return err\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking gRPC Status Codes in Go\nDESCRIPTION: Shows how to inspect the specific gRPC status code returned within an error. It uses `status.FromError` to attempt extracting gRPC status information. If successful, it checks the status code (e.g., `codes.NotFound`) to implement specific error handling logic. It also demonstrates handling non-RPC errors.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/anti-patterns.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nresp, err := client.MakeRPC(context.TODO(), request)\nif err != nil {\n  if status, ok := status.FromError(err); ok {\n    // Handle the error based on its status code\n    if status.Code() == codes.NotFound {\n      log.Println(\"Requested resource not found\")\n    } else {\n      log.Printf(\"RPC error: %v\", status.Message())\n    }\n  } else {\n    // Handle non-RPC errors\n    log.Printf(\"Non-RPC error: %v\", err)\n  }\n  return\n}\n\n// Use the response as needed\nlog.Printf(\"Response received: %v\", resp)\n```\n\n----------------------------------------\n\nTITLE: Implementing Client-Side Streaming RPC with gRPC-Go\nDESCRIPTION: This code shows how to implement a client-side streaming RPC in gRPC-Go. The `RecordRoute` function receives a stream of `Point` objects from the client and returns a single `RouteSummary`. The `stream.Recv()` method is used to receive messages from the client, and `stream.SendAndClose()` is used to send the final response.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nfunc (s *routeGuideServer) RecordRoute(stream pb.RouteGuide_RecordRouteServer) error {\n    var pointCount, featureCount, distance int32\n    var lastPoint *pb.Point\n    startTime := time.Now()\n    for {\n        point, err := stream.Recv()\n        if err == io.EOF {\n            endTime := time.Now()\n            return stream.SendAndClose(&pb.RouteSummary{\n                PointCount:   pointCount,\n                FeatureCount: featureCount,\n                Distance:     distance,\n                ElapsedTime:  int32(endTime.Sub(startTime).Seconds()),\n            })\n        }\n        if err != nil {\n            return err\n        }\n        pointCount++\n        for _, feature := range s.savedFeatures {\n            if proto.Equal(feature.Location, point) {\n                featureCount++\n            }\n        }\n        if lastPoint != nil {\n            distance += calcDistance(lastPoint, point)\n        }\n        lastPoint = point\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Bidirectional Streaming RPC with gRPC in Go\nDESCRIPTION: This example illustrates bidirectional streaming in gRPC using Go by establishing a stream with the server, concurrently receiving messages, and sending multiple notes. It utilizes `Recv()`, `Send()`, and `CloseSend()` to manage the stream and handle incoming and outgoing messages independently.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#_snippet_12\n\nLANGUAGE: Go\nCODE:\n```\nstream, err := client.RouteChat(ctx)\nwaitc := make(chan struct{})\ngo func() {\n    for {\n        in, err := stream.Recv()\n        if err == io.EOF {\n            // read done.\n            close(waitc)\n            return\n        }\n        if err != nil {\n            log.Fatalf(\"Failed to receive a note : %v\", err)\n        }\n        log.Printf(\"Got message %s at point(%d, %d)\", in.Message, in.Location.Latitude, in.Location.Longitude)\n    }\n}()\nfor _, note := range notes {\n    if err := stream.Send(note); err != nil {\n        log.Fatalf(\"Failed to send a note: %v\", err)\n    }\n}\nstream.CloseSend()\n<-waitc\n```\n\n----------------------------------------\n\nTITLE: Creating a gRPC Client Connection in Go\nDESCRIPTION: This snippet demonstrates how to establish a connection to a gRPC server using the `grpc.NewClient()` function in Go. It shows the basic setup for creating a gRPC channel to communicate with the server.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nconn, err := grpc.NewClient(*serverAddr)\nif err != nil {\n    ...\n}\ndefer conn.Close()\n```\n\n----------------------------------------\n\nTITLE: Applying Retry Policy with grpc.WithDefaultServiceConfig in Go\nDESCRIPTION: This snippet demonstrates how to pass a retry policy JSON string to the gRPC client using the grpc.WithDefaultServiceConfig DialOption. It sets up a connection with transport credentials and the specified retry policy, enabling automatic retries according to the configuration when making RPC calls.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/retry/README.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\nconn, err := grpc.NewClient(target, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithDefaultServiceConfig(retryPolicy))\n```\n\n----------------------------------------\n\nTITLE: Starting a gRPC Server in Go\nDESCRIPTION: This code snippet showcases the steps required to start a gRPC server in Go. It involves specifying the port to listen on, creating a gRPC server instance, registering the service implementation, and then serving the requests on the specified port. It uses the `net`, `fmt`, `log`, and `grpc` packages.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nflag.Parse()\nlis, err := net.Listen(\"tcp\", fmt.Sprintf(\"localhost:%d\", *port))\nif err != nil {\n        log.Fatalf(\"failed to listen: %v\", err)\n}\ngrpcServer := grpc.NewServer()\npb.RegisterRouteGuideServer(grpcServer, &routeGuideServer{})\n... // determine whether to use TLS\ngrpcServer.Serve(lis)\n```\n\n----------------------------------------\n\nTITLE: Creating a gRPC Client Stub in Go\nDESCRIPTION: This snippet illustrates how to create a client stub for making RPC calls using the generated `NewRouteGuideClient` method from the protobuf definitions. It requires an established gRPC connection (`conn`).\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nclient := pb.NewRouteGuideClient(conn)\n```\n\n----------------------------------------\n\nTITLE: Creating gRPC Status Errors with status.New and status.Error in Go\nDESCRIPTION: This snippet demonstrates how to generate gRPC status errors using the status package by creating a `status.Status` object with a specific error code and description, then converting it to an error to be returned from service handlers. It compares the explicit creation of `status.Status` followed by `Err()` against the convenience method `status.Error` for simplicity.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/rpc-errors.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\nst := status.New(codes.NotFound, \"some description\")\nerr := st.Err()\n\n// vs.\n\nerr := status.Error(codes.NotFound, \"some description\")\n```\n\n----------------------------------------\n\nTITLE: Running gRPC RBAC Server with File Watcher Policy (Go)\nDESCRIPTION: Starts the gRPC server configured to load its RBAC policy from a specified file and watch for changes, reloading the policy dynamically. The `--authz-option filewatcher` flag enables this mode, and `GRPC_GO_LOG_SEVERITY_LEVEL=info` enables logging for policy reload events.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/authz/README.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nGRPC_GO_LOG_SEVERITY_LEVEL=info go run server/main.go --authz-option filewatcher\n```\n\n----------------------------------------\n\nTITLE: Defining Metadata Structure in gRPC-Go (Go)\nDESCRIPTION: Demonstrates the definition of the MD type in the gRPC-Go metadata package. MD is a map from strings to slices of strings, allowing multiple values per metadata key. This structure is fundamental to all operations involving gRPC metadata in Go and is used extensively in all the subsequent code snippets.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\ntype MD map[string][]string\n```\n\n----------------------------------------\n\nTITLE: Calling a Server-Side Streaming RPC from a gRPC Client in Go\nDESCRIPTION: This code shows how to call a server-side streaming RPC method (`ListFeatures`) from a gRPC client in Go. It initializes a request (`pb.Rectangle`), calls the streaming method, and then iterates through the stream to receive multiple responses from the server. It uses `stream.Recv()` to read the responses and checks for `io.EOF` to determine when the stream has ended.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nrect := &pb.Rectangle{ ... }  // initialize a pb.Rectangle\nstream, err := client.ListFeatures(ctx, rect)\nif err != nil {\n    ...\n}\nfor {\n    feature, err := stream.Recv()\n    if err == io.EOF {\n        break\n    }\n    if err != nil {\n        log.Fatalf(\"%v.ListFeatures(_) = _, %v\", client, err)\n    }\n    log.Println(feature)\n}\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Keepalive Server (Go)\nDESCRIPTION: This snippet provides the command to execute the gRPC keepalive server. The command `go run server/main.go` compiles and runs the server application.  The server is responsible for handling gRPC requests and enforcing keepalive settings. No specific dependencies are listed in this command, but it assumes the user has the Go gRPC libraries installed.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/keepalive/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\ngo run server/main.go\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Health Check Server Instances in Go\nDESCRIPTION: These commands demonstrate how to start multiple gRPC health check server instances on different ports with specified initial sleep durations. The servers simulate their health status based on the sleep parameter to showcase health reporting behavior to clients.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/health/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngo run server/main.go -port=50051 -sleep=5s\ngo run server/main.go -port=50052 -sleep=10s\n```\n\n----------------------------------------\n\nTITLE: Register gRPC Reflection Service in Go\nDESCRIPTION: This Go snippet demonstrates how to register the gRPC reflection service on a gRPC server.  It imports the necessary reflection package and then calls `reflection.Register(s)` to enable reflection.  This allows clients to introspect the server's services. The prerequisite is a running gRPC server and the grpc and reflection packages.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/reflection/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport \"google.golang.org/grpc/reflection\"\n\ns := grpc.NewServer()\npb.RegisterYourOwnServer(s, &server{})\n\n// Register reflection service on gRPC server.\nreflection.Register(s)\n\ns.Serve(lis)\n```\n\n----------------------------------------\n\nTITLE: Initializing gRPC Client with JWT OAuth Credentials in Go\nDESCRIPTION: Demonstrates configuring a gRPC client to authenticate using JWT-based service account credentials and OAuth2, secured with TLS. It first creates JWT credentials from a service account key file using `oauth.NewServiceAccountFromFile`, handles potential errors, and then passes these credentials along with TLS transport credentials to `grpc.Dial` via `grpc.WithPerRPCCredentials`.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-auth-support.md#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\njwtCreds, err := oauth.NewServiceAccountFromFile(*serviceAccountKeyFile, *oauthScope)\nif err != nil {\n  log.Fatalf(\"Failed to create JWT credentials: %v\", err)\n}\nconn, err := grpc.Dial(serverAddr, grpc.WithTransportCredentials(credentials.NewClientTLSFromCert(nil, \"\")), grpc.WithPerRPCCredentials(jwtCreds))\n```\n\n----------------------------------------\n\nTITLE: Configuring gRPC Client-Side Health Checking in Go\nDESCRIPTION: This Go snippet shows how to configure a gRPC client to perform transparent client-side health checking by importing the health package and setting a service configuration. The service config specifies the healthCheckConfig with a serviceName indicating which backend service's health to monitor. Key dependencies include the gRPC and health packages. The snippet exemplifies setting up a connection that automatically monitors server health based on service config.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/health/README.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n// import grpc/health to enable transparent client side checking\nimport _ \"google.golang.org/grpc/health\"\n\n// set up appropriate service config\nserviceConfig := grpc.WithDefaultServiceConfig(`{\n  \"loadBalancingPolicy\": \"round_robin\",\n  \"healthCheckConfig\": {\n    \"serviceName\": \"\"\n  }\n}`)\n\nconn, err := grpc.NewClient(..., serviceConfig)\n```\n\n----------------------------------------\n\nTITLE: Receiving Header and Trailer Metadata in gRPC-Go Client: Unary Call (Go)\nDESCRIPTION: Shows how to receive header and trailer metadata from a unary gRPC call using the grpc.Header and grpc.Trailer CallOption helpers. The snippet declares variables to hold the results, invokes the RPC with those options, and allows processing of the returned metadata. Requires google.golang.org/grpc and a compatible generated client.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md#_snippet_6\n\nLANGUAGE: Go\nCODE:\n```\nvar header, trailer metadata.MD // variable to store header and trailer\nr, err := client.SomeRPC(\n    ctx,\n    someRequest,\n    grpc.Header(&header),    // will retrieve header\n    grpc.Trailer(&trailer),  // will retrieve trailer\n)\n\n// do something with header and trailer\n```\n\n----------------------------------------\n\nTITLE: Receiving Header and Trailer Metadata in gRPC-Go Client: Streaming Call (Go)\nDESCRIPTION: Demonstrates receiving header and trailer metadata from the stream object during client-side streaming, client-side, or bidirectional streaming RPCs. The snippet calls stream.Header to obtain the header, and stream.Trailer to obtain the trailer. Requires a gRPC client supporting streaming and google.golang.org/grpc.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md#_snippet_7\n\nLANGUAGE: Go\nCODE:\n```\nstream, err := client.SomeStreamingRPC(ctx)\n\n// retrieve header\nheader, err := stream.Header()\n\n// retrieve trailer\ntrailer := stream.Trailer()\n```\n\n----------------------------------------\n\nTITLE: Running gRPC-Go Server with Compression - Go\nDESCRIPTION: This command executes the gRPC-Go server example with compression support. Before running, ensure you have installed all Go dependencies and that server/main.go implements the necessary logic for accepting RPC requests and handling compression. This requires a working Go development environment and the grpc-go library. No input parameters are required for this command; output will depend on the server implementation and incoming client requests.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/compression/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\ngo run server/main.go\n```\n\n----------------------------------------\n\nTITLE: Receiving Metadata in gRPC-Go Server Handler: Unary Call (Go)\nDESCRIPTION: Shows how a gRPC server handler retrieves incoming metadata from the context via metadata.FromIncomingContext during a unary RPC. The metadata is extracted at the beginning of handler execution and can be inspected or processed as needed. Requires google.golang.org/grpc/metadata and a generated server interface.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md#_snippet_8\n\nLANGUAGE: Go\nCODE:\n```\nfunc (s *server) SomeRPC(ctx context.Context, in *pb.someRequest) (*pb.someResponse, error) {\n    md, ok := metadata.FromIncomingContext(ctx)\n    // do something with metadata\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Server Reflection in gRPC-Go Server\nDESCRIPTION: This Go code snippet illustrates how to import the reflection package, register the reflection service on a gRPC server, and integrate it within the main function to enable server reflection. Dependencies include the grpc and reflection packages, and the snippet is intended to be added to the server setup code to allow clients to introspect services.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/server-reflection-tutorial.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\nimport (\n\t\"google.golang.org/grpc\"\n\tpb \"google.golang.org/grpc/examples/helloworld/helloworld\"\n+\"google.golang.org/grpc/reflection\"\n)\n\nfunc main() {\n\t// ... existing setup code ...\n\t// Register reflection service on gRPC server.\n\treflection.Register(s)\n\t// ... remaining server start code ...\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Metadata with NewOutgoingContext (Go)\nDESCRIPTION: Demonstrates replacing outgoing metadata completely using metadata.NewOutgoingContext, and how to carefully merge new metadata into an existing context to avoid overwriting prior metadata. After creating the context with metadata, additional pairs can be joined and set as new outgoing metadata. This is less efficient than AppendToOutgoingContext and fully replaces metadata in the context. Requires google.golang.org/grpc/metadata, context, and a gRPC client.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md#_snippet_5\n\nLANGUAGE: Go\nCODE:\n```\n// create a new context with some metadata\nmd := metadata.Pairs(\"k1\", \"v1\", \"k1\", \"v2\", \"k2\", \"v3\")\nctx := metadata.NewOutgoingContext(context.Background(), md)\n\n// later, add some more metadata to the context (e.g. in an interceptor)\nsend, _ := metadata.FromOutgoingContext(ctx)\nnewMD := metadata.Pairs(\"k3\", \"v3\")\nctx = metadata.NewOutgoingContext(ctx, metadata.Join(send, newMD))\n\n// make unary RPC\nresponse, err := client.SomeRPC(ctx, someRequest)\n\n// or make streaming RPC\nstream, err := client.SomeStreamingRPC(ctx)\n```\n\n----------------------------------------\n\nTITLE: Implementing a gRPC Server with Logging, Metrics, and Tracing in Go\nDESCRIPTION: This snippet illustrates setting up a gRPC server in Go with integrated observability features. It includes initializing logs, metrics, and tracing components, registering services, and starting the server to handle incoming requests with instrumentation. Dependencies include gRPC and observability libraries, and the code requires a proper setup of monitoring backends.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/observability/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/examples/helloworld/helloworld\"\n\n\t// Assume these packages are imported for observability: logs, metrics, tracing\n\t\"yourorg/observability\"\n)\n\n// server is used to implement the HelloWorld gRPC service\ntype server struct {\n\thelloworld.UnimplementedGreeterServer\n}\n\n// SayHello implements the SayHello RPC method with added observability\nfunc (s *server) SayHello(ctx context.Context, in *helloworld.HelloRequest) (*helloworld.HelloReply, error) {\n\t// Log incoming request\n\tobservability.LogRequest(\"SayHello\", in.Name)\n\n\t// Record metrics: count number of requests\n\tobservability.RecordRequest(\"SayHello\")\n\n\t// Trace the request\n\tctx, span := observability.StartTrace(ctx, \"SayHello\")\n\tdefer span.End()\n\n\t// Generate greeting response\n\tresponse := &helloworld.HelloReply{Message: \"Hello \" + in.Name}\n\n\t// Log response\n\tobservability.LogResponse(\"SayHello\", response.Message)\n\n\treturn response, nil\n}\n\nfunc main() {\n\t// Initialize observability components (logs, metrics, tracing)\n\tobservability.Init()\n\n\t// Set up listener on TCP port\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\t// Create gRPC server with interceptors for observability if needed\n\tgrpcServer := grpc.NewServer()\n\n\t// Register gRPC service\n\thhelloworld.RegisterGreeterServer(grpcServer, &server{})\n\n\t// Start server\n\tlog.Println(\"gRPC server listening on :50051\")\n\terr = grpcServer.Serve(lis)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Unary Interceptor Metadata Update in gRPC (Go)\nDESCRIPTION: This code snippet demonstrates how to update metadata within a gRPC unary interceptor in Go. It retrieves the incoming metadata, appends a new key-value pair, creates a new context with the updated metadata, and passes it to the handler. The function uses `metadata.FromIncomingContext` to retrieve existing metadata and `metadata.NewIncomingContext` to create a new context with modified metadata. The updated context is then passed to the provided handler.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/metadata_interceptor/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc SomeInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n    // Get the incoming metadata from the RPC context, and add a new\n    // key-value pair to it.\n    md, ok := metadata.FromIncomingContext(ctx)\n    md.Append(\"key1\", \"value1\")\n\n    // Create a context with the new metadata and pass it to handler.\n    ctx = metadata.NewIncomingContext(ctx, md)\n    return handler(ctx, req)\n}\n```\n\n----------------------------------------\n\nTITLE: Client main.go - Connecting to gRPC server and handling error details\nDESCRIPTION: This code sets up a gRPC client in Go that connects to the server, invokes a method, and handles errors by extracting and printing detailed status information received from the server. It demonstrates error analysis and detail extraction from gRPC status responses.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/error_details/README.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/status\"\n)\n\nfunc main() {\n\tconn, err := grpc.Dial(\":50051\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := NewGreeterClient(conn)\n\n\t// Call the RPC method\n\tresp, err := client.SayHello(context.Background(), &HelloRequest{Name: \"World\"})\n\tif err != nil {\n\t\tst, ok := status.FromError(err)\n\t\tif ok {\n\t\t\tfmt.Printf(\"Error message: %s\\n\", st.Message())\n\t\t\t// Optionally, process error details here\n\t\t} else {\n\t\t\tfmt.Printf(\"Unknown error: %v\\n\", err)\n\t\t}\n\t} else {\n\t\tfmt.Printf(\"Response received: %s\\n\", resp.Message)\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Receiving Metadata in gRPC-Go Server Handler: Streaming Call (Go)\nDESCRIPTION: Demonstrates retrieval of incoming client metadata from the stream context within a server-side streaming RPC handler via metadata.FromIncomingContext. The stream.Context() method provides the appropriate context for metadata extraction. Requires google.golang.org/grpc/metadata and a generated server stream interface.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md#_snippet_9\n\nLANGUAGE: Go\nCODE:\n```\nfunc (s *server) SomeStreamingRPC(stream pb.Service_SomeStreamingRPCServer) error {\n    md, ok := metadata.FromIncomingContext(stream.Context()) // get context from stream\n    // do something with metadata\n}\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Go Route Guide Client with TLS\nDESCRIPTION: Compiles and runs the gRPC route guide client with TLS enabled using the `-tls=true` command-line flag. This requires the server to also be running with TLS enabled.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/route_guide/README.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ngo run client/client.go -tls=true\n```\n\n----------------------------------------\n\nTITLE: Building Docker Image for gRPC Go CSM Observability Client\nDESCRIPTION: Builds a Docker image for the gRPC client application configured with CSM Observability support. This command must be run from the grpc-go directory and requires specifying a suitable image tag. The Dockerfile is located at examples/features/csm_observability/client/Dockerfile.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/csm_observability/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\ndocker build -t <TAG> -f examples/features/csm_observability/client/Dockerfile .\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Client (Shell)\nDESCRIPTION: This shell command executes the Go program located at `client/main.go` to start the gRPC client. The client is configured via service config to use the `custom_round_robin` load balancing policy to distribute requests between the available server instances (e.g., localhost:20000 and localhost:20001).\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/customloadbalancer/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\ngo run client/main.go\n```\n\n----------------------------------------\n\nTITLE: Streaming Interceptor Metadata Update in gRPC (Go)\nDESCRIPTION: This code illustrates how to update metadata within a gRPC streaming interceptor in Go.  Since `grpc.ServerStream` doesn't allow direct modification of its RPC context, it wraps the stream and overrides the `Context()` method to return a context with updated metadata. This wrapper is then passed to the handler. It uses `metadata.FromIncomingContext` to retrieve existing metadata and `metadata.NewIncomingContext` to create a new context with the modified metadata.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/metadata_interceptor/README.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype wrappedStream struct {\n    grpc.ServerStream\n    ctx context.Context\n}\n\nfunc (s *wrappedStream) Context() context.Context {\n    return s.ctx\n}\n\nfunc SomeStreamInterceptor(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {\n    // Get the incoming metadata from the RPC context, and add a new\n    // key-value pair to it.\n    md, ok := metadata.FromIncomingContext(ctx)\n    md.Append(\"key1\", \"value1\")\n\n    // Create a context with the new metadata and pass it to handler.\n    ctx = metadata.NewIncomingContext(ctx, md)\n\n    return handler(srv, &wrappedStream{ss, ctx})\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing gRPC Client with GCE OAuth Credentials in Go\nDESCRIPTION: Illustrates connecting a gRPC client using Google Compute Engine (GCE) credentials for authentication, along with TLS for transport security. It configures `grpc.Dial` with both `grpc.WithTransportCredentials` (for TLS) and `grpc.WithPerRPCCredentials` using `oauth.NewComputeEngine` to automatically handle GCE authentication.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-auth-support.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nconn, err := grpc.Dial(serverAddr, grpc.WithTransportCredentials(credentials.NewClientTLSFromCert(nil, \"\")), grpc.WithPerRPCCredentials(oauth.NewComputeEngine()))\n```\n\n----------------------------------------\n\nTITLE: Listing Methods of a Specific Service with gRPCurl\nDESCRIPTION: This command lists all RPC methods provided by the specified service 'helloworld.Greeter' on the server, displaying available RPC functions like 'SayHello'. It helps clients understand service capabilities.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/server-reflection-tutorial.md#_snippet_3\n\nLANGUAGE: Shell Script\nCODE:\n```\n$ grpcurl -plaintext localhost:50051 list helloworld.Greeter\n```\n\n----------------------------------------\n\nTITLE: Executing gRPC Dualstack Client in Go via Shell\nDESCRIPTION: Runs the Go gRPC client component that connects to the previously started dualstack servers. Initially uses the default resolver and load balancing strategy connecting only to the first server, then switches to a custom name resolver with round-robin load balancing to alternate between all three servers serving IPv4 and IPv6 connections. This command requires Go with all dependencies and the client source at client/main.go. Expected output includes server responses labeling which IP version the server used to service the request.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/dualstack/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ngo run client/main.go\n```\n\n----------------------------------------\n\nTITLE: Describing a Service Using gRPCurl\nDESCRIPTION: This command retrieves the service definition for 'helloworld.Greeter', detailing its RPC methods and message types. It aids clients in understanding the service interface for request and response formats.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/server-reflection-tutorial.md#_snippet_4\n\nLANGUAGE: Shell Script\nCODE:\n```\n$ grpcurl -plaintext localhost:50051 describe helloworld.Greeter\n```\n\n----------------------------------------\n\nTITLE: Starting gRPC ORCA Server (Go Example)\nDESCRIPTION: This command runs the Go server application located at `server/main.go`. This server is implemented to demonstrate gRPC ORCA load reporting, potentially configuring either out-of-band or per-RPC metric mechanisms as described in the documentation.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/orca/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngo run server/main.go\n```\n\n----------------------------------------\n\nTITLE: Defining gRPC Retry Policy as a JSON String in Go\nDESCRIPTION: This snippet shows how to define a retry policy in JSON format within a Go variable. The policy specifies the maximum number of attempts, backoff timing, multiplier, and retryable status codes for a specific gRPC service method. It is used to configure client retries when making RPC calls.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/retry/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\n        var retryPolicy = `{\\n    \"methodConfig\": [{\\n        // config per method or all methods under service\\n        \"name\": [{\"service\": \"grpc.examples.echo.Echo\"}],\\n\\n        \"retryPolicy\": {\\n            \"MaxAttempts\": 4,\\n            \"InitialBackoff\": \".01s\",\\n            \"MaxBackoff\": \".01s\",\\n            \"BackoffMultiplier\": 1.0,\\n            // this value is grpc code\\n            \"RetryableStatusCodes\": [ \"UNAVAILABLE\" ]\\n        }\\n    }]\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Starting gRPC ORCA Client (Go Example)\nDESCRIPTION: This command executes the Go client application found at `client/main.go`. This client is designed to interact with the corresponding gRPC ORCA server, demonstrating how a client consumes and processes ORCA load reporting data.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/orca/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngo run client/main.go\n```\n\n----------------------------------------\n\nTITLE: Adding Error Details with status.WithDetails in Go\nDESCRIPTION: This snippet explains how to enrich gRPC errors with additional information using the `status.WithDetails` method. By attaching detailed payloads to a `status.Status`, clients can later extract comprehensive error information, aiding debugging or providing context-specific data.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/rpc-errors.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\nstatusWithDetails, err := status.WithDetails(status, detailsPayload)\n// The client can then convert the error back to a status and extract details.\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Go Route Guide Server with TLS\nDESCRIPTION: Compiles and runs the gRPC route guide server with TLS enabled using the `-tls=true` command-line flag. This requires corresponding TLS configuration on the client side.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/route_guide/README.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ngo run server/server.go -tls=true\n```\n\n----------------------------------------\n\nTITLE: Inspecting Message Type 'HelloRequest' with gRPCurl\nDESCRIPTION: This command provides detailed information about the message type 'HelloRequest', revealing its fields and structure. Useful for understanding the expected request message format for RPCs.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/server-reflection-tutorial.md#_snippet_6\n\nLANGUAGE: Shell Script\nCODE:\n```\n$ grpcurl -plaintext localhost:50051 describe helloworld.HelloRequest\n```\n\n----------------------------------------\n\nTITLE: Storing Binary Data in Metadata (Go)\nDESCRIPTION: Demonstrates how to store binary values in metadata by using a key suffixed with '-bin'. The gRPC-Go implementation encodes such values (typically to base64) before sending and decodes after receiving. The snippet shows both a string and a byte array value under different keys. The metadata.Pairs function handles the necessary encoding. Requires the google.golang.org/grpc/metadata package.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\nmd := metadata.Pairs(\n    \"key\", \"string value\",\n    \"key-bin\", string([]byte{96, 102}), // this binary data will be encoded (base64) before sending\n                                        // and will be decoded after being transferred.\n)\n```\n\n----------------------------------------\n\nTITLE: Sending Metadata from the gRPC-Go Client with AppendToOutgoingContext (Go)\nDESCRIPTION: Illustrates appending outgoing metadata key-value pairs to a context for use in gRPC requests. The first usage demonstrates adding metadata to a context before performing an RPC; the second adds additional metadata (e.g., in an interceptor). Then examples of both unary and streaming RPCs using the updated context are shown. Requires the google.golang.org/grpc/metadata package and a valid gRPC client.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md#_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\n// create a new context with some metadata\nctx := metadata.AppendToOutgoingContext(ctx, \"k1\", \"v1\", \"k1\", \"v2\", \"k2\", \"v3\")\n\n// later, add some more metadata to the context (e.g. in an interceptor)\nctx := metadata.AppendToOutgoingContext(ctx, \"k3\", \"v4\")\n\n// make unary RPC\nresponse, err := client.SomeRPC(ctx, someRequest)\n\n// or make streaming RPC\nstream, err := client.SomeStreamingRPC(ctx)\n```\n\n----------------------------------------\n\nTITLE: Running gRPC RBAC Server with Static Policy (Go)\nDESCRIPTION: This command starts the gRPC server configured to use a static RBAC authorization policy. The policy, roles, and secrets are hardcoded within the server code for simplicity in this example, demonstrating basic server-side authorization using gRPC interceptors.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/authz/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\ngo run server/main.go\n```\n\n----------------------------------------\n\nTITLE: Describing a Specific RPC Method with gRPCurl\nDESCRIPTION: This command fetches detailed information about the 'SayHello' RPC method of the Greeter service, including its input and output message types. It assists in crafting correct request messages.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/server-reflection-tutorial.md#_snippet_5\n\nLANGUAGE: Shell Script\nCODE:\n```\n$ grpcurl -plaintext localhost:50051 describe helloworld.Greeter.SayHello\n```\n\n----------------------------------------\n\nTITLE: Sample usage of gRPC error handling for rate limiting in Go\nDESCRIPTION: This example illustrates a client-server interaction where errors are generated due to rate limiting, with the server constructing detailed status errors. It shows how clients initially succeed and subsequently receive detailed error responses when limits are exceeded, demonstrating practical error handling in gRPC services.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/rpc-errors.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\n$ go run examples/rpc_errors/server/main.go\n\n// in a second session\n\n$ go run examples/rpc_errors/client/main.go\n\n// first run outputs:\n2018/03/12 19:39:33 Greeting: Hello world\n\n// second run outputs:\n2018/03/19 16:42:01 Quota failure: violations:<subject:\"name:world\" description:\"Limit one greeting per person\" >\nexit status 1\n```\n\n----------------------------------------\n\nTITLE: Connecting gRPC Client to Unix Abstract Socket - Go\nDESCRIPTION: Executes the gRPC client application designed to connect to the server running on a Unix abstract socket. The client uses the `unix-abstract` scheme for connecting to the abstract address. This command compiles and runs the client code located in the `client/main.go` file.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/unix_abstract/README.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\ngo run client/main.go\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Client with Credential Reloading\nDESCRIPTION: Command to run the gRPC client example that connects to the server using credential reloading from files.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/security/advancedtls/examples/credential_reloading_from_files/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngo run client/main.go\n```\n\n----------------------------------------\n\nTITLE: Server main.go - Setting up gRPC server with error status details\nDESCRIPTION: This code initializes a gRPC server in Go that demonstrates how to send detailed error status information to clients. It includes the server setup, registration, and error handling logic to embed and propagate error details via gRPC status objects.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/error_details/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n)\n\n// server is used to implement a gRPC service\ntype server struct{}\n\n// SayHello implements the greeting method\nfunc (s *server) SayHello(ctx context.Context, req *HelloRequest) (*HelloReply, error) {\n\t// Simulate an error with status details\n\tdetails := \"Additional error details here\"\n\tst := status.New(codes.Internal, \"An error occurred\")\n\tstWithDetails, err := st.WithDetails(&ErrorDetails{Detail: details})\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to add details: %v\", err)\n\t}\n\treturn nil, stWithDetails.Err()\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\tgrpcServer := grpc.NewServer()\n\tRegisterGreeterServer(grpcServer, &server{})\n\tif err := grpcServer.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Sending Header and Trailer Metadata from gRPC-Go Server: Unary Call (Go)\nDESCRIPTION: Explains how a server handler sends header and trailer metadata to a gRPC client in a unary call using grpc.SetHeader and grpc.SetTrailer. The functions require a context parameter and metadata to send. This approach allows explicit communication of response metadata. Requires google.golang.org/grpc and google.golang.org/grpc/metadata.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md#_snippet_10\n\nLANGUAGE: Go\nCODE:\n```\nfunc (s *server) SomeRPC(ctx context.Context, in *pb.someRequest) (*pb.someResponse, error) {\n    // create and set header\n    header := metadata.Pairs(\"header-key\", \"val\")\n    grpc.SetHeader(ctx, header)\n    // create and set trailer\n    trailer := metadata.Pairs(\"trailer-key\", \"val\")\n    grpc.SetTrailer(ctx, trailer)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Metadata Using metadata.New (Go)\nDESCRIPTION: Shows how to construct a new metadata instance from a map of string key-value pairs using the metadata.New function. This creates an MD object with keys converted to lowercase and each key mapped to a single string value. This approach is useful for initializing metadata in a simple, key-value format before attaching it to an outgoing context. Requires the google.golang.org/grpc/metadata package.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\nmd := metadata.New(map[string]string{\"key1\": \"val1\", \"key2\": \"val2\"})\n```\n\n----------------------------------------\n\nTITLE: Generating CSR with SAN Fields using OpenSSL Config\nDESCRIPTION: Creates a Certificate Signing Request (csr.pem) using the subject's private key and an OpenSSL configuration file ($CONFIG_FILE_NAME) to include Subject Alternative Name (SAN) fields in the request.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/security/advancedtls/testdata/README.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n$ openssl req -new -key subject_key.pem -out csr.pem -config $CONFIG_FILE_NAME\n```\n\n----------------------------------------\n\nTITLE: Building Client and Server Binaries with Shell\nDESCRIPTION: This shell script builds Go-based client and server binaries for the gRPC interop test suite using the 'go build' command. The output binaries are placed under the './binaries/' directory. Dependencies include a valid Go environment and the correct source code available at '../../interop/xds/client/' and '../../interop/xds/server/'. Key parameters: '-o' for output file location and the source directory path. Input is inferred from available source code; output is compiled binaries. Requires Go properly installed and project dependencies resolved.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/xds/internal/test/e2e/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngo build -o ./binaries/client ../../../../interop/xds/client/\ngo build -o ./binaries/server ../../../../interop/xds/server/\n```\n\n----------------------------------------\n\nTITLE: Generating Certificate Signing Request (CSR) using OpenSSL\nDESCRIPTION: Creates a Certificate Signing Request (csr.pem) using the subject's private key (subject_key.pem). This request will be sent to the CA for signing.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/security/advancedtls/testdata/README.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n$ openssl req -new -key subject_key.pem -out csr.pem\n```\n\n----------------------------------------\n\nTITLE: Using a Compressor for gRPC Client in Go\nDESCRIPTION: This snippet demonstrates how to specify a compressor such as gzip in a gRPC client call via `UseCompressor`. By registering the compressor in both client and server, gRPC will use it for message compression and decompression, including setting appropriate headers like `content-coding`.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/encoding.md#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\nresponse, err := myclient.MyCall(ctx, request, grpc.UseCompressor(\"gzip\"))\n\n// Setting default compressor globally\n// myclient := grpc.Dial(ctx, target, grpc.WithDefaultCallOptions(grpc.UseCompressor(\"gzip\")))\n```\n\n----------------------------------------\n\nTITLE: Constructing Metadata with metadata.Pairs (Go)\nDESCRIPTION: Illustrates how to create metadata with potentially multiple values per key using metadata.Pairs. Passing keys and values as variadic arguments allows automatic merging when duplicate keys are provided. All keys are converted to lowercase, and values for the same key are stored in a slice in insertion order. Requires the google.golang.org/grpc/metadata package.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nmd := metadata.Pairs(\n    \"key1\", \"val1\",\n    \"key1\", \"val1-2\", // \"key1\" will have map value []string{\"val1\", \"val1-2\"}\n    \"key2\", \"val2\",\n)\n```\n\n----------------------------------------\n\nTITLE: Generating CA Private Key and Certificate using OpenSSL\nDESCRIPTION: Generates a 4096-bit RSA private key (ca_key.pem) and a self-signed X.509 certificate (ca_cert.pem) for the Certificate Authority (CA). The '-nodes' flag prevents encrypting the private key, and '$DURATION_DAYS' specifies the validity duration.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/security/advancedtls/testdata/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ openssl req -x509 -newkey rsa:4096 -keyout ca_key.pem -out ca_cert.pem -nodes -days $DURATION_DAYS\n```\n\n----------------------------------------\n\nTITLE: Running gRPC-Go benchmarks with unary workload and payload curve files\nDESCRIPTION: This command runs the `benchmain` utility for unary RPCs using CSV files to define weighted random distributions for request and response payload sizes. It demonstrates how to use the `-reqPayloadCurveFiles` and `-respPayloadCurveFiles` flags to specify the paths to the CSV files containing the payload distributions.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/benchmark.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ go run google.golang.org/grpc/benchmark/benchmain/main.go \\\n    -workloads=unary \\\n    -reqPayloadCurveFiles=/path/to/csv \\\n    -respPayloadCurveFiles=/path/to/csv\n```\n\n----------------------------------------\n\nTITLE: Using protoc-gen-go-grpc with require_unimplemented_servers option\nDESCRIPTION: Example command showing how to use protoc-gen-go-grpc with the require_unimplemented_servers=false option to restore backward compatibility behavior. This disables the default requirement for embedding Unimplemented<ServiceName>Server in service implementations.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/cmd/protoc-gen-go-grpc/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nprotoc --go-grpc_out=. --go-grpc_opt=require_unimplemented_servers=false[,other options...] \\\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Server - Go\nDESCRIPTION: This snippet demonstrates how to execute the gRPC server component. It utilizes the `go run` command to run the `server/main.go` file, which presumably contains the server logic.  No specific dependencies beyond the Go runtime are needed.  The output includes the server's execution logs, useful for debugging. This command assumes the Go runtime is configured correctly and that the necessary gRPC and associated packages are installed.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/debugging/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ngo run server/main.go\n```\n\n----------------------------------------\n\nTITLE: X.509 Certificate Structure with RSA Public Key\nDESCRIPTION: A complete example of an X.509 v3 certificate issued to 'foo.bar.com' with a 4096-bit RSA public key. The certificate is issued by 'Internet Widgits Pty Ltd' and includes standard X.509v3 extensions for Subject Key Identifier, Authority Key Identifier, Basic Constraints, and Key Usage.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/security/advancedtls/testdata/server_cert_1.txt#_snippet_0\n\nLANGUAGE: ASN.1\nCODE:\n```\nCertificate:\n    Data:\n        Version: 3 (0x2)\n        Serial Number: 3 (0x3)\n        Signature Algorithm: sha256WithRSAEncryption\n        Issuer: C = US, ST = CA, L = SVL, O = Internet Widgits Pty Ltd\n        Validity\n            Not Before: Nov  4 21:43:00 2019 GMT\n            Not After : Aug 18 21:43:00 2293 GMT\n        Subject: C = US, ST = CA, L = DUMMYCITY, O = Internet Widgits Pty Ltd, CN = foo.bar.com\n        Subject Public Key Info:\n            Public Key Algorithm: rsaEncryption\n                RSA Public-Key: (4096 bit)\n                Modulus:\n                    00:ec:3f:24:2d:91:3a:bd:c3:fc:15:72:42:b3:fb:\n                    28:e6:04:a3:be:26:20:e6:ea:30:a8:aa:48:78:36:\n                    0e:0b:99:29:3b:4b:f9:f1:d5:bf:bd:0c:13:7c:ea:\n                    52:06:f4:bc:34:9e:2b:c0:b4:82:2c:87:fa:2f:e2:\n                    cd:7c:d7:b9:e1:8f:04:71:6d:85:77:ae:18:40:e4:\n                    b1:3a:4a:6b:e5:33:bf:3e:65:db:cf:94:64:87:1a:\n                    20:46:c0:37:3a:9f:93:3f:d4:4f:ac:c4:e4:e0:28:\n                    b6:0f:28:53:2a:cf:b9:fe:50:f2:ef:47:dc:7e:b6:\n                    60:c2:47:85:b8:cb:ca:48:5b:fa:9f:8a:97:30:01:\n                    f4:b3:51:0f:68:e1:60:ab:2f:a0:ad:fc:f0:10:4f:\n                    60:e1:92:db:be:83:04:5c:40:87:ce:51:3e:9a:9e:\n                    d6:1c:1b:19:cb:8c:c2:6c:57:74:6f:7b:af:94:3d:\n                    53:ad:17:a5:99:69:7c:41:f5:3e:7a:5b:48:c7:78:\n                    ff:d7:3b:a8:1f:f7:30:e7:83:26:78:e2:cb:a2:8f:\n                    58:92:61:cd:ca:e9:b8:d1:80:c0:40:58:e9:d8:d3:\n                    42:64:82:8f:e4:0c:b9:b1:36:db:9f:65:3f:3f:5b:\n                    24:59:31:b3:60:0c:fa:41:5a:1b:b8:9d:ec:99:37:\n                    90:fa:b5:e7:3f:cb:7c:e0:f9:ed:ea:27:ce:15:24:\n                    c7:77:3b:45:45:2d:19:8e:2e:7f:65:0e:85:df:66:\n                    50:69:24:2c:a4:6a:07:e5:3f:eb:28:84:53:94:4d:\n                    5f:9c:a8:65:a6:50:4c:c0:35:06:40:6a:a5:62:b1:\n                    93:60:e5:1c:85:28:34:9b:29:81:6f:e2:4f:cd:15:\n                    30:b9:19:d7:4b:bb:30:0c:4b:2d:64:fe:3b:dd:0e:\n                    a4:25:2c:4a:5c:de:d7:74:1f:5e:93:7b:1c:e8:c8:\n                    fa:72:1f:4a:eb:8d:3f:98:e4:55:98:b8:e0:8a:29:\n                    92:33:af:75:6b:05:84:05:d3:0c:2c:07:78:bc:0e:\n                    b2:6d:a7:00:35:c4:53:1f:7b:e6:ba:07:72:a8:24:\n                    c1:0a:a7:c4:46:e6:f2:6f:3a:79:23:00:0b:b8:e5:\n                    1f:e0:e2:ee:c6:13:a3:57:d9:86:1a:95:f7:a3:04:\n                    f1:46:d5:5f:21:d2:aa:d2:30:fb:f6:cb:e0:da:24:\n                    c6:c3:30:2f:d2:1f:21:fe:bc:0f:99:ac:ac:9b:65:\n                    9b:e4:83:9a:00:b8:2f:40:fc:3b:42:d3:7a:e8:b7:\n                    52:d7:f4:67:2a:a5:f7:eb:78:f1:0a:56:8b:56:12:\n                    d5:48:d8:48:70:ab:b8:69:5a:21:d3:71:b0:59:9d:\n                    17:b4:4b\n                Exponent: 65537 (0x10001)\n        X509v3 extensions:\n            X509v3 Subject Key Identifier:\n                C0:82:DA:FA:69:46:30:AE:FF:6F:CD:BB:93:49:94:A6:D0:E2:17:EB\n            X509v3 Authority Key Identifier:\n                keyid:5A:A5:DA:B1:99:D4:E5:0E:E6:1E:94:EA:FF:FC:62:E2:ED:09:F1:06\n\n            X509v3 Basic Constraints:\n                CA:FALSE\n            X509v3 Key Usage:\n                Digital Signature, Key Encipherment\n    Signature Algorithm: sha256WithRSAEncryption\n         36:fd:cf:ec:f5:20:4b:52:dc:2e:38:f3:92:b1:e4:b6:a1:06:\n         86:aa:2d:c0:e6:f5:0a:58:97:a9:e3:be:13:09:61:79:ed:d4:\n         41:83:26:ad:ee:0b:43:83:d1:dd:19:1a:e8:7b:b2:1f:fe:d4:\n         c1:57:7d:6d:6b:d4:42:ea:7d:cd:34:8c:a4:1f:5b:3b:fa:de:\n         bb:2f:ae:56:b6:18:e5:53:a9:a3:99:58:ad:36:be:19:54:61:\n         0d:52:b6:a7:53:fc:60:e5:ff:f5:7f:82:3f:c1:49:06:cd:b2:\n         af:25:ee:de:bd:e0:e5:5e:ad:0b:dc:2e:b1:ec:7a:52:6f:9d:\n         e0:b9:84:18:db:49:53:ee:df:93:ee:8b:9d:9b:8e:3b:2a:82:\n         86:7f:45:c8:dd:d1:b0:40:17:ed:63:52:a1:5b:6e:d3:5c:a2:\n         72:05:fb:3a:39:71:0d:b4:2c:9d:15:23:1b:1f:8d:ac:89:dc:\n         c9:56:f2:19:c7:f3:2f:bb:d5:de:40:17:f1:52:ea:e8:93:ff:\n         56:43:f5:1d:cb:c0:51:52:25:d7:b0:81:a9:0e:4d:92:24:e7:\n         10:81:c7:31:26:ac:cb:66:c1:3f:f6:5f:69:7b:74:87:0d:b0:\n         8c:27:d4:24:29:59:e9:5b:a2:cb:0c:c0:f5:9b:1d:42:38:6b:\n         e3:c3:43:1e:ba:df:b1:51:0a:b7:33:55:26:39:01:2f:9f:c7:\n         88:ac:2f:4a:89:f3:69:de:72:43:48:49:08:59:36:86:84:09:\n         db:6a:82:84:3e:71:6a:9d:f9:bd:d8:b5:1e:7c:2c:29:e1:27:\n         45:4c:47:5b:88:b8:e6:fa:9d:9b:ff:d4:e9:8d:2d:5e:64:7f:\n         27:87:b2:8c:d8:7e:f5:52:3c:c4:d8:30:03:24:d7:ac:f8:53:\n         91:80:98:42:24:5a:6b:cb:34:48:57:e0:82:ac:96:d9:55:6c:\n         c2:c3:8c:19:7c:56:39:0a:a8:f1:b8:77:64:70:83:a8:04:c8:\n         3a:5d:0b:00:4c:e5:ba:f1:40:e5:57:cd:d9:67:48:21:e9:9c:\n         d3:f2:b8:01:b8:d1:c0:d1:3a:44:c0:97:db:e6:bc:8f:2e:33:\n         d5:e2:38:3d:d7:7b:50:13:01:36:28:61:cc:28:98:3c:f8:21:\n         5d:8c:fe:f5:d0:ab:e0:60:ec:36:22:8d:0b:71:30:1b:3d:56:\n         ae:96:e9:d2:89:c2:43:8b:ef:25:b7:d6:0d:82:e6:5a:c6:91:\n         8a:ad:8c:28:2a:2b:5c:4e:a1:de:cb:7d:cb:29:11:a2:66:c8:\n         a1:33:35:75:16:fe:28:0b:78:31:0a:1f:fa:d0:a8:f4:f1:69:\n         c7:97:1e:5d:fb:53:08:b5\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Go Client for CSM Observability Example\nDESCRIPTION: Starts the gRPC client application locally using the Go runtime. The client connects to the gRPC server either through an xDS control plane (default) or by overriding the --server_addr flag. This client generates RPC calls instrumented for CSM Observability and can produce telemetry data with additional labels for monitoring.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/csm_observability/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\ngo run client/main.go\n```\n\n----------------------------------------\n\nTITLE: Getting gRPC Example Code (Go)\nDESCRIPTION: This snippet uses the `go get` command to retrieve the necessary Go packages for the gRPC Hello World example.  It downloads the client and server code from the specified Google repository.  Dependencies: Requires Go and a correctly set up Go environment (GOPATH).  Outputs the downloaded packages to the GOPATH.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/helloworld/README.md#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ go get google.golang.org/grpc/examples/helloworld/greeter_client\n$ go get google.golang.org/grpc/examples/helloworld/greeter_server\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Client (Go)\nDESCRIPTION: This snippet executes the gRPC Hello World client.  It uses the GOPATH to find the compiled client binary.  Dependency: Requires a compiled gRPC client executable (greeter_client) and a running server.  Output: The client sends a request to the server and prints the server's response to the console, which should be \"Greeting: Hello world\".\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/helloworld/README.md#_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ $(go env GOPATH)/bin/greeter_client\nGreeting: Hello world\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Codec for gRPC Client in Go\nDESCRIPTION: This snippet shows how to specify a custom `Codec` in a gRPC client call using `CallContentSubtype`. By registering the codec on both client and server, messages will be encoded/decoded with the selected codec, with content type headers indicating the codec used. It also demonstrates setting default call options client-wide.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/encoding.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\nresponse, err := myclient.MyCall(ctx, request, grpc.CallContentSubtype(\"mycodec\"))\n\n// Setting default call options globally\n// myclient := grpc.Dial(ctx, target, grpc.WithDefaultCallOptions(grpc.CallContentSubtype(\"mycodec\")))\n```\n\n----------------------------------------\n\nTITLE: Implementing a Compressor in Go for gRPC\nDESCRIPTION: This snippet illustrates creating a `Compressor` in Go by implementing methods to compress and decompress data, typically by wrapping `io.Writer` and `io.Reader`. The compressor is registered globally, enabling gRPC to utilize it for message compression to enhance efficiency.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/encoding.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\npackage gzip\n\nimport \"google.golang.org/grpc/encoding\"\n\nfunc init() {\n    encoding.RegisterCompressor(compressor{})\n}\n\n// ... implementation of compressor ... \n```\n\n----------------------------------------\n\nTITLE: Sending Header and Trailer Metadata from gRPC-Go Server: Streaming Call (Go)\nDESCRIPTION: Shows how to send headers and trailers from a streaming RPC handler to the client using the ServerStream interface. The SetHeader and SetTrailer methods are called on the stream, passing metadata objects to transmit data outside of the primary stream messages. Requires a generated streaming server with SetHeader and SetTrailer methods, as well as google.golang.org/grpc/metadata.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md#_snippet_11\n\nLANGUAGE: Go\nCODE:\n```\nfunc (s *server) SomeStreamingRPC(stream pb.Service_SomeStreamingRPCServer) error {\n    // create and set header\n    header := metadata.Pairs(\"header-key\", \"val\")\n    stream.SetHeader(header)\n    // create and set trailer\n    trailer := metadata.Pairs(\"trailer-key\", \"val\")\n    stream.SetTrailer(trailer)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Client-Side Streaming RPC with gRPC in Go\nDESCRIPTION: This snippet demonstrates how to perform client-side streaming in gRPC using Go by creating a stream, sending multiple points, and then closing the stream to receive a summary reply. It highlights the use of `Send()`, `CloseAndRecv()`, and error handling for robust communication.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#_snippet_11\n\nLANGUAGE: Go\nCODE:\n```\n// Create a random number of random points\nr := rand.New(rand.NewSource(time.Now().UnixNano()))\npointCount := int(r.Int31n(100)) + 2 // Traverse at least two points\nvar points []*pb.Point\nfor i := 0; i < pointCount; i++ {\n    points = append(points, randomPoint(r))\n}\nlog.Printf(\"Traversing %d points.\", len(points))\nstream, err := client.RecordRoute(ctx)\nif err != nil {\n    log.Fatalf(\"%v.RecordRoute(_) = _, %v\", client, err)\n}\nfor _, point := range points {\n    if err := stream.Send(point); err != nil {\n        log.Fatalf(\"%v.Send(%v) = %v\", stream, point, err)\n    }\n}\nreply, err := stream.CloseAndRecv()\nif err != nil {\n    log.Fatalf(\"%v.CloseAndRecv() got error %v, want %v\", stream, err, nil)\n}\nlog.Printf(\"Route summary: %v\", reply)\n```\n\n----------------------------------------\n\nTITLE: Running gRPC-Go Client with Compression - Go\nDESCRIPTION: This command launches the example gRPC-Go client configured to use compression when making RPC calls to a compatible server. Before execution, ensure all Go dependencies are present and that client/main.go is implemented to connect to the server and initiate compressed gRPC requests. No runtime arguments are needed; the program will perform its transactions and display results or errors based on the server response.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/compression/README.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\ngo run client/main.go\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Codec in Go for gRPC\nDESCRIPTION: This snippet demonstrates creating a custom `Codec` in Go by defining a type that implements `Marshal` and `Unmarshal` methods, registering it in the global registry within an `init` function. This allows gRPC to serialize and deserialize messages using the custom codec, facilitating alternative serialization formats.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/encoding.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage proto\n\nimport \"google.golang.org/grpc/encoding\"\n\nfunc init() {\n    encoding.RegisterCodec(protoCodec{})\n}\n\n// ... implementation of protoCodec ... \n```\n\n----------------------------------------\n\nTITLE: Running gRPC Client with OpenTelemetry (Go)\nDESCRIPTION: This snippet executes the gRPC client application. It uses the client's OpenTelemetry configuration to export metrics and traces. The client and server are configured to output traces to standard output and expose metrics. Requires the 'go' runtime and the client's main.go file to be present. The client continuously makes RPCs to the server.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/opentelemetry/README.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ngo run client/main.go\n```\n\n----------------------------------------\n\nTITLE: Starting gRPC Server with Reflection Enabled\nDESCRIPTION: This command demonstrates running a gRPC server in Go that has server reflection enabled, allowing tools like gRPCurl to introspect available services. The command executes the server main program via 'go run'.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/server-reflection-tutorial.md#_snippet_1\n\nLANGUAGE: Shell Script\nCODE:\n```\n$ cd <grpc-go-directory>/examples\n$ go run features/reflection/server/main.go\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Client with Custom stats.Handler in Go\nDESCRIPTION: This snippet shows the command to start the gRPC client, connecting to a server instrumented with stats.Handler. Dependencies include Go, grpc-go, and a client implementation that utilizes grpc.WithStatsHandler() with a concrete stats.Handler. Running this command triggers RPCs that the custom handler can monitor, reporting per-RPC and per-connection statistics. Input: none directly, client issues RPC requests. Output: network monitoring statistics reported via the handler. Limitation: handler and rpc logic must be set up in client/main.go.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/stats_monitoring/README.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ngo run client/main.go\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Server with Custom stats.Handler in Go\nDESCRIPTION: This snippet shows the command to launch the gRPC server that includes a stats.Handler implementation for monitoring events. Prerequisites: install Go, set up the grpc/stats package, and ensure server/main.go implements a stats.Handler and passes it to grpc.StatsHandler(). Execution begins the server and enables network and RPC event reporting. Input: none directly, server listens for gRPC calls. Output: console/networked events for monitoring. Limitation: actual stats.Handler logic must exist in server/main.go.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/stats_monitoring/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ngo run server/main.go\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Health Check Client in Go\nDESCRIPTION: This command runs the gRPC health check client that connects to the health check servers. The client can use this to interact with servers to check or watch their health status according to the deployed server states.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/health/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngo run client/main.go\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC xDS Go Client via Shell\nDESCRIPTION: This shell command demonstrates how to run the gRPC xDS Go client example. It first sets the `GRPC_XDS_BOOTSTRAP` environment variable to the path of the required bootstrap configuration file. Then, it executes the client binary (`client/main.go`), passing a message (\"xDS world\") and the target service URI (`xds:///target_service`) which uses the `xds` scheme to indicate reliance on the xDS resolver.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/xds/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ export GRPC_XDS_BOOTSTRAP=/path/to/bootstrap.json\n$ go run client/main.go \"xDS world\" xds:///target_service\n```\n\n----------------------------------------\n\nTITLE: Calling a Remote Unary Method with gRPCurl\nDESCRIPTION: This command sends an RPC request to the 'SayHello' method of the Greeter service, with input data specified in text format via the '-d' flag. The response shows the greeting message returned by the server.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/server-reflection-tutorial.md#_snippet_7\n\nLANGUAGE: Shell Script\nCODE:\n```\n$ grpcurl -plaintext -format text -d 'name: \"gRPCurl\"' \\\n  localhost:50051 helloworld.Greeter.SayHello\n```\n\n----------------------------------------\n\nTITLE: Importing gRPC xDS Package in Go Client\nDESCRIPTION: This Go code snippet shows the necessary import statement to include the gRPC xDS package. Importing this package (using the blank identifier `_`) installs the xDS resolvers and balancers required for the client to communicate using the xDS protocol.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/xds/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n_ \"google.golang.org/grpc/xds\" // To install the xds resolvers and balancers.\n```\n\n----------------------------------------\n\nTITLE: Listing All Services with gRPCurl\nDESCRIPTION: This command uses gRPCurl with the '-plaintext' flag to fetch a list of all services exposed by a gRPC server listening on port 50051. The output shows the available gRPC services such as Echo, Reflection, and Greeter.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/server-reflection-tutorial.md#_snippet_2\n\nLANGUAGE: Shell Script\nCODE:\n```\n$ grpcurl -plaintext localhost:50051 list\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Keepalive Client with Debugging (Go)\nDESCRIPTION: This snippet provides the command to execute the gRPC keepalive client, including HTTP/2 debugging. The command `GODEBUG=http2debug=2 go run client/main.go` sets the `GODEBUG` environment variable to enable HTTP/2 debugging output and then runs the client application. This client interacts with the gRPC server to test the keepalive mechanism.  It assumes the user has the Go gRPC libraries installed.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/keepalive/README.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\nGODEBUG=http2debug=2 go run client/main.go\n```\n\n----------------------------------------\n\nTITLE: Querying Prometheus Metrics Exporter for Telemetry Data\nDESCRIPTION: Sends an HTTP GET request to the local Prometheus exporter endpoint to retrieve metrics generated by the gRPC server and client applications. This command assumes the exporter is running on port 9464 and outputs telemetry data including CSM labels for observability analysis.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/csm_observability/README.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\ncurl localhost:9464/metrics\n```\n\n----------------------------------------\n\nTITLE: Querying Prometheus Metrics from gRPC Server (Shell)\nDESCRIPTION: This snippet uses curl to query the Prometheus metrics exposed by the gRPC server. It accesses the server's Prometheus endpoint, typically running on port 9464, to retrieve and display the collected metrics data. This allows you to monitor the performance of the gRPC server. Requires the 'curl' command line tool and the server to be running.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/opentelemetry/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncurl localhost:9464/metrics\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Go Route Guide Server\nDESCRIPTION: Compiles and runs the Go source file for the gRPC route guide server. Assumes execution from the `.../examples/route_guide/` directory. By default, it runs without TLS.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/route_guide/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngo run server/server.go\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Server with OpenTelemetry (Go)\nDESCRIPTION: This snippet executes the gRPC server application. It leverages the server's OpenTelemetry configuration to listen and provide metrics. The server typically exposes metrics on port 9464 and traces on standard output. The server is responsible for processing incoming RPC requests and responding to them.  Requires the 'go' runtime and the server's main.go file to be present.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/opentelemetry/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ngo run server/main.go\n```\n\n----------------------------------------\n\nTITLE: Running gRPC RBAC Client with File Watcher Policy (Go)\nDESCRIPTION: Runs the client against the server configured with the file watcher policy. This allows testing authorization based on the current state of the policy file, demonstrating how changes to the file affect subsequent client requests without needing to restart the server.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/authz/README.md#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\ngo run client/main.go\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Go Route Guide Client\nDESCRIPTION: Compiles and runs the Go source file for the gRPC route guide client. Assumes execution from the `.../examples/route_guide/` directory. By default, it runs without TLS and expects the server to be running similarly.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/route_guide/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ngo run client/client.go\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Server in Go\nDESCRIPTION: This command runs the gRPC server application. The server listens for incoming connections and handles requests. It's a prerequisite for the client example as the clients will connect to this server.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/name_resolving/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ngo run server/main.go\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Error Handling Client (Shell)\nDESCRIPTION: Executes the Go gRPC client application located at './client/main.go' using 'go run'. The client connects to the running server and sends two requests: one with an empty 'Name' field (expected to trigger an error) and one populated with the current username. It then prints the status codes received for both requests.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/error_handling/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ngo run ./client/main.go\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Client Example in Go\nDESCRIPTION: This command executes the Go program located in the `client/main.go` file. It connects to the gRPC server and demonstrates client-side connection sharing. The server must be running before this client can function. \nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/multiplex/README.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\ngo run client/main.go\n```\n\n----------------------------------------\n\nTITLE: Running gRPC RBAC Client with Static Policy (Go)\nDESCRIPTION: Executes the client application designed to interact with the gRPC server running with a static RBAC policy. This client demonstrates sending requests with valid and invalid tokens to illustrate successful authorization and `codes.PermissionDenied` errors based on the configured static policy.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/authz/README.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\ngo run client/main.go\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Error Handling Server (Shell)\nDESCRIPTION: Starts the Go gRPC server application located at './server/main.go' using the 'go run' command. This server is part of an error handling example and is configured to return an error if an incoming RPC request has an empty 'Name' field.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/error_handling/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngo run ./server/main.go\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Client - Go\nDESCRIPTION: This snippet demonstrates how to execute the gRPC client component using the `go run` command.  It runs the `client/main.go` file, which presumably contains the client logic. No dependencies beyond the Go runtime are needed. The command assumes Go is installed and configured correctly and the necessary packages are available. The output includes any client-side execution logs and responses. \nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/debugging/README.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ngo run client/main.go\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Server Application in Go\nDESCRIPTION: This command runs the gRPC server application. The command executes the `main.go` file located in the `server` subdirectory of each example's subdirectory. This needs the grpc package to run.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/encryption/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ngo run server/main.go\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Client Example in Go\nDESCRIPTION: Command to run the gRPC client example application. This starts the client implementation that demonstrates interceptor usage when connecting to the server.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/interceptor/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngo run client/main.go\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Flow Control Example Server (Go/Shell)\nDESCRIPTION: This shell command compiles and runs the Go server application located in the current directory (`.`). This server participates in the bidirectional stream example designed to demonstrate gRPC flow control blocking when the client stops reading.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/flow_control/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngo run ./server\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Server Example in Go\nDESCRIPTION: Command to run the gRPC server example application. This starts the server implementation that demonstrates interceptor usage.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/interceptor/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngo run server/main.go\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Server Example in Go\nDESCRIPTION: This command runs the gRPC server example provided. It's a simple command that will execute the server program, allowing you to test gRPC reflection. No specific dependencies are needed at the command line as the go module system handles that.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/reflection/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ngo run server/main.go\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Client - Go\nDESCRIPTION: This command starts the gRPC client. The client will connect to the gRPC server and make RPC calls, demonstrating cancellation functionality by canceling the context passed to the RPC.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/cancellation/README.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\ngo run client/main.go\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Client Application in Go\nDESCRIPTION: This command runs the gRPC client application. The command executes the `main.go` file located in the `client` subdirectory of each example's subdirectory. This command requires the grpc package.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/encryption/README.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ngo run client/main.go\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Server - Go\nDESCRIPTION: This command starts the gRPC server. The server will listen for incoming RPC requests and handle them until it is manually stopped or encounters an error.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/cancellation/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\ngo run server/main.go\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Server (Go)\nDESCRIPTION: This snippet executes the gRPC Hello World server.  It uses the GOPATH to find the compiled server binary and runs it in the background using '&'. Dependency: Requires a compiled gRPC server executable (greeter_server).  Output: The server starts running in the background, waiting for client requests.  It does not produce any output to the console unless errors occur.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/helloworld/README.md#_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ $(go env GOPATH)/bin/greeter_server &\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Server with Credential Reloading\nDESCRIPTION: Command to run the gRPC server example that demonstrates credential reloading from files using the advancedtls library.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/security/advancedtls/examples/credential_reloading_from_files/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngo run server/main.go\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Go Server for CSM Observability Example\nDESCRIPTION: Runs the gRPC server application locally using the Go runtime. This server is configured for CSM Observability and acts as the RPC endpoint exposing telemetry data for client interactions. No additional parameters are required when running the command from the example's server directory.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/csm_observability/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ngo run server/main.go\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Flow Control Example Client (Go/Shell)\nDESCRIPTION: This shell command compiles and runs the Go client application located in the current directory (`.`). This client connects to the example server and initiates a bidirectional stream, demonstrating flow control by sending messages until blocked.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/flow_control/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ngo run ./client\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Client in Go\nDESCRIPTION: This command runs the gRPC client application. The client attempts to connect to the gRPC server using different name resolvers. It demonstrates the usage of custom resolvers to connect to the server.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/name_resolving/README.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ngo run client/main.go\n```\n\n----------------------------------------\n\nTITLE: Execute gRPC Client (Go)\nDESCRIPTION: This command runs the gRPC client application, likely designed to interact with the previously started server. The `go run client/main.go` command executes the Go program located at `client/main.go`. This program presumably sends requests to the gRPC server and reads metadata from the responses. It requires that the server is running beforehand.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/metadata/README.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ngo run client/main.go\n```\n\n----------------------------------------\n\nTITLE: Executing gRPC Dualstack Server in Go via Shell\nDESCRIPTION: Runs the Go gRPC server component that initializes three server instances binding to different localhost IP versions. Each server listens on a specific port with IPv4, IPv6, or both. This shell command requires a Go environment with the necessary dependencies installed. It expects the server source code to be located under server/main.go. Execution outputs logs from multiple gRPC servers indicating their bound IP addresses and ports.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/dualstack/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngo run server/main.go\n```\n\n----------------------------------------\n\nTITLE: Execute gRPC Server (Go)\nDESCRIPTION: This command initiates the gRPC server application. The `go run server/main.go` command executes the Go program located at `server/main.go`. This program likely implements the gRPC server logic for handling incoming requests and managing metadata within the server.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/metadata/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ngo run server/main.go\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Server Example in Go\nDESCRIPTION: This command executes the Go program located in the `server/main.go` file. It starts a gRPC server that demonstrates connection sharing.  It's a prerequisite for running the client and testing the multiplexing.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/multiplex/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\ngo run server/main.go\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Server and Client\nDESCRIPTION: These shell commands are used to run the gRPC server and client examples. The server is executed with a flag specifying the credentials directory, and the client is executed similarly. These commands assume that the user is in the correct directory context.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/advancedtls/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Run the server\n$ go run server/main.go -credentials_directory $(pwd)/creds\n# Run the clients from the `grpc-go/examples/features/advancedtls` directory\n$ go run client/main.go -credentials_directory $(pwd)/creds\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Server on Unix Abstract Socket - Go\nDESCRIPTION: Executes the gRPC server application which is configured to listen on a Unix abstract socket. This command compiles and runs the server code located in the `server/main.go` file.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/unix_abstract/README.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\ngo run server/main.go\n```\n\n----------------------------------------\n\nTITLE: Querying Prometheus Metrics from gRPC Client (Shell)\nDESCRIPTION: This snippet uses curl to query the Prometheus metrics exposed by the gRPC client. It accesses the client's Prometheus endpoint, typically running on port 9465, to retrieve and display the collected metrics data. This allows you to monitor the performance of the gRPC client. Requires the 'curl' command line tool and the client to be running.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/opentelemetry/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncurl localhost:9465/metrics\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Wait for Ready Example with go run\nDESCRIPTION: This snippet illustrates executing the main Go program that contains the gRPC client and server setup with 'wait for ready' enabled. It triggers the example execution to observe the RPC behavior under different conditions, such as server delay and context timeout.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/wait_for_ready/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\ngo run main.go\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Go Interop Test Suite with Shell\nDESCRIPTION: This snippet uses the 'go test' command to run all tests in the current directory with verbose output for the gRPC Go interop suite. No dependencies except a working Go test environment and test files in the working directory. The '-v' flag enables verbose logging for easier debugging and detailed output. Input is the current package of test files; output is the test result. Requires Go installed and being in the correct project directory.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/xds/internal/test/e2e/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ngo test . -v\n```\n\n----------------------------------------\n\nTITLE: Extracting Base64-Encoded RSA Modulus from Certificate Public Key in Go\nDESCRIPTION: This Go code defines a function to extract the base64url-encoded modulus parameter ('n') from the RSA public key of an X.509 certificate. It then shows how to decode a PEM certificate, parse the certificate, obtain the RSA public key, and print the modulus. Dependencies include the Go standard library packages 'crypto/rsa', 'crypto/x509', 'encoding/pem', 'encoding/base64', and 'fmt'. The input is a PEM-encoded certificate (rawPemCert) and the output is the modulus value printed to standard output. Key limitations: assumes the certificate uses RSA keys and omits error handling for brevity.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/testdata/spiffe_end2end/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\nfunc(GetBase64ModulusFromPublicKey(key *rsa.PublicKey) string {\n    return base64.RawURLEncoding.EncodeToString(key.N.Bytes())\n}\n\nblock, _ := pem.Decode(rawPemCert) cert, _ := x509.ParseCertificate(block.Bytes)\npublicKey := cert.PublicKey.(*rsa.PublicKey)\nfmt.Println(GetBase64ModulusFromPublicKey(publicKey))\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Go Interop Test Suite with Custom Client Flag using Shell\nDESCRIPTION: This command runs 'go test' with additional flags to specify the client binary path for interop testing. The '-client' flag is set to a custom xds-test-client path, allowing for compatibility tests against another implementation (here, grpc-java). Requires Go and the referenced client/server binaries to exist. Inputs are standard Go test files with a user-defined client flag; output is verbose test results. Proper setup of client/server locations and permissions is necessary.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/xds/internal/test/e2e/README.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ngo test . -v -client=$HOME/grpc-java/interop-testing/build/install/grpc-interop-testing/bin/xds-test-client\n```\n\n----------------------------------------\n\nTITLE: Extracting RSA Modulus from Public Key in Go\nDESCRIPTION: This Go code snippet demonstrates how to extract the RSA modulus (n) from a public key within an X.509 certificate. It requires the `crypto/rsa`, `crypto/x509`, `encoding/pem`, and `encoding/base64` packages. The code decodes the PEM-encoded certificate, parses it as an X.509 certificate, extracts the public key, and then base64 encodes the modulus.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/testdata/spiffe/README.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc GetBase64ModulusFromPublicKey(key *rsa.PublicKey) string { return\nbase64.RawURLEncoding.EncodeToString(key.N.Bytes()) }\n\nblock, _ := pem.Decode(rawPemCert) cert, _ := x509.ParseCertificate(block.Bytes)\npublicKey := cert.PublicKey.(*rsa.PublicKey)\nfmt.Println(GetBase64ModulusFromPublicKey(publicKey))\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Server (Shell)\nDESCRIPTION: This shell command executes the Go program located at `server/main.go` to start the gRPC echo server component for the custom load balancing example. It listens on a specific port (e.g., localhost:20000 or localhost:50050 based on context) and includes its address in responses.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/customloadbalancer/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ngo run server/main.go\n```\n\n----------------------------------------\n\nTITLE: Running gRPC-Go benchmarks with streaming workload\nDESCRIPTION: This command executes the `benchmain` utility to simulate streaming RPCs with specified request and response sizes, enabling gzip compression. It showcases the configuration of `benchmain` for a specific workload type, including setting payload sizes and enabling compression.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/benchmark.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ go run google.golang.org/grpc/benchmark/benchmain/main.go \\\n    -workloads=streaming \\\n    -reqSizeBytes=1024 \\\n    -respSizeBytes=1024 \\\n    -compression=gzip\n```\n\n----------------------------------------\n\nTITLE: Building Docker Image for gRPC Go CSM Observability Server\nDESCRIPTION: Builds a Docker image for the gRPC server application configured for CSM Observability. This command must be executed from the grpc-go directory and requires specifying an image tag. The Dockerfile is located at examples/features/csm_observability/server/Dockerfile.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/csm_observability/README.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\ndocker build -t <TAG> -f examples/features/csm_observability/server/Dockerfile .\n```\n\n----------------------------------------\n\nTITLE: Generating SPIFFE certificates using OpenSSL\nDESCRIPTION: This snippet shows how to generate SPIFFE certificates using OpenSSL commands. It requires OpenSSL to be installed and configured with the provided `spiffe-openssl.cnf` configuration file. The commands generate certificate signing requests (CSRs) and then sign them with a CA to create the final certificates.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/testdata/spiffe/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ openssl req -new -key client.key -out spiffe-cert.csr \\\n -subj /C=US/ST=CA/L=SVL/O=gRPC/CN=testclient/ \\\n -config spiffe-openssl.cnf -reqexts spiffe_client_e2e\n$ openssl x509 -req -CA ca.pem -CAkey ca.key -CAcreateserial \\\n -in spiffe-cert.csr -out client_spiffe.pem -extensions spiffe_client_e2e \\\n  -extfile spiffe-openssl.cnf -days 3650 -sha256\n$ openssl req -new -key server1.key -out spiffe-cert.csr \\\n -subj /C=US/ST=CA/L=SVL/O=gRPC/CN=*.test.google.com/ \\\n -config spiffe-openssl.cnf -reqexts spiffe_server_e2e\n$ openssl x509 -req -CA ca.pem -CAkey ca.key -CAcreateserial \\\n -in spiffe-cert.csr -out server1_spiffe.pem -extensions spiffe_server_e2e \\\n  -extfile spiffe-openssl.cnf -days 3650 -sha256\n```\n\n----------------------------------------\n\nTITLE: Configuring gRPC Compression with Deprecated DialOption Functions in Go\nDESCRIPTION: Shows the legacy client-side DialOption functions used to set compressors and decompressors for gRPC connections in Go. Dependencies include grpc.Compressor and grpc.Decompressor types. The code defines three functions for configuring compression on outgoing requests and decompression on incoming responses. It serves as a reference for backward compatibility and clarifies rules for compressor usage order.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/compression.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc WithCompressor(grpc.Compressor) DialOption {}\nfunc WithDecompressor(grpc.Decompressor) DialOption {}\nfunc UseCompressor(name) CallOption {}\n```\n\n----------------------------------------\n\nTITLE: Running multiple benchmarks using multiple CSV files\nDESCRIPTION: This command showcases how to run multiple benchmarks by specifying multiple CSV files for request and response payload curves. The utility executes a benchmark for each combination of request and response payload curve files, effectively running four benchmarks independently.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/benchmark.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ go run google.golang.org/grpc/benchmark/benchmain/main.go \\\n    -workloads=unary \\\n    -reqPayloadCurveFiles=/path/to/csv1,/path/to/csv2 \\\n    -respPayloadCurveFiles=/path/to/csv3,/path/to/csv4\n```\n\n----------------------------------------\n\nTITLE: Generating Credentials for gRPC Examples\nDESCRIPTION: This shell command is used to generate the credentials required for the gRPC security examples. The `generate.sh` script is executed from the specified directory, creating the necessary certificates and CRLs in the `creds` directory.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/advancedtls/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nIf the credentials need to be re-generated, run `./generate.sh` from `/path/to/grpc-go/examples/features/advancedtls` to re-create the `creds` directory containing the certificates and CRLs needed for these examples.\n```\n\n----------------------------------------\n\nTITLE: Combining PayloadCurveFiles with SizeBytes options\nDESCRIPTION: This shows how to use payload curve files for requests and fixed size for responses.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/benchmark.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ go run google.golang.org/grpc/benchmark/benchmain/main.go \\\n    -workloads=unary \\\n    -reqPayloadCurveFiles=/path/to/csv \\\n    -respSizeBytes=1\n```\n\n----------------------------------------\n\nTITLE: Generating Subject Private Key using OpenSSL\nDESCRIPTION: Generates a 4096-bit RSA private key (subject_key.pem) for the subject whose certificate will be signed by the CA.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/security/advancedtls/testdata/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n$ openssl genrsa -out subject_key.pem 4096\n```\n\n----------------------------------------\n\nTITLE: Working with Go Modules for gRPC in Restricted Networks\nDESCRIPTION: A shell script showing how to use Go modules to create aliases for golang.org packages when direct access is blocked. This approach uses the replace feature to reference the GitHub repository instead.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ngo mod edit -replace=google.golang.org/grpc=github.com/grpc/grpc-go@latest\ngo mod tidy\ngo mod vendor\ngo build -mod=vendor\n```\n\n----------------------------------------\n\nTITLE: Signing CSR with CA Key and Certificate using OpenSSL\nDESCRIPTION: Uses the CA's private key (ca_key.pem) and certificate (ca_cert.pem), along with a CA configuration file (openssl-ca.cnf), to sign the CSR (csr.pem) and generate the final subject certificate (subject_cert.pem). Requires specific policy and extension configurations defined in the config file.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/security/advancedtls/testdata/README.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n$ openssl ca -config openssl-ca.cnf -policy signing_policy -extensions signing_req -out subject_cert.pem -in csr.pem -keyfile ca_key.pem -cert ca_cert.pem\n```\n\n----------------------------------------\n\nTITLE: Configuring gRPC Compression with Deprecated ServerOption Functions in Go\nDESCRIPTION: Demonstrates the legacy server-side ServerOption functions available for configuring RPC-level compressors and decompressors in gRPC for Go. These functions allow setting compression behavior for incoming requests and outgoing responses explicitly. The snippet serves as guidance for deprecated method usage and outlines how server behavior is selected based on these options and registered compressors.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/compression.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc RPCCompressor(grpc.Compressor) ServerOption {}\nfunc RPCDecompressor(grpc.Decompressor) ServerOption {}\n```\n\n----------------------------------------\n\nTITLE: Verifying Subject Certificate against CA using OpenSSL\nDESCRIPTION: Verifies that the generated subject certificate (subject_cert.pem) is trusted by the CA certificate (ca_cert.pem). The '-verbose' flag provides detailed output.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/security/advancedtls/testdata/README.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\n$ openssl verify -verbose -CAfile ca_cert.pem  subject_cert.pem\n```\n\n----------------------------------------\n\nTITLE: Printing Certificate Chain Information with OpenSSL\nDESCRIPTION: Command to display certificate chain information from a PEM file using OpenSSL tools. This example uses revokedLeaf.pem to demonstrate how to extract and view certificate details.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/security/advancedtls/testdata/crl/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nopenssl crl2pkcs7 -nocrl -certfile security/crl/x509/client/testdata/revokedLeaf.pem | openssl pkcs7 -print_certs -text -noout\n```\n\n----------------------------------------\n\nTITLE: Expected Server Output for Flow Control Example\nDESCRIPTION: Shows the anticipated log output from the example server. It reflects the server's perspective: stream initiation, reading messages sent by the client, detection of send blocking when replying due to client inactivity, confirmation of message sending after the client resumes reading, and successful stream termination.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/flow_control/README.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n2023/09/19 15:49:49 New stream began.\n2023/09/19 15:49:51 Read 25 messages.\n2023/09/19 15:49:52 Sending is blocked.\n2023/09/19 15:49:53 Sent 25 messages.\n2023/09/19 15:49:53 Stream ended successfully.\n```\n\n----------------------------------------\n\nTITLE: Running Vet Script and Tests for gRPC-Go\nDESCRIPTION: Commands for running code quality checks and tests before submitting a PR. Includes running the vet script to catch errors and running tests in both regular and race mode with multiple CPU configurations.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/vet.sh\n```\n\nLANGUAGE: bash\nCODE:\n```\ngo test -cpu 1,4 -timeout 7m ./...\n```\n\nLANGUAGE: bash\nCODE:\n```\ngo test -race -cpu 1,4 -timeout 7m ./...\n```\n\n----------------------------------------\n\nTITLE: CSV payload distribution file format\nDESCRIPTION: This CSV file defines a weighted random distribution for payload sizes, used with the `benchmain` utility. Each row specifies a range of payload sizes (min, max) and a weight associated with that range, influencing the probability of generating requests or responses within that size range. It uses a comma as a delimiter.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/Documentation/benchmark.md#_snippet_1\n\nLANGUAGE: csv\nCODE:\n```\n1,32,12.5\n128,256,12.5\n1024,2048,25.0\n```\n\n----------------------------------------\n\nTITLE: Expected Client Output for Flow Control Example\nDESCRIPTION: Shows the anticipated log output from the example client. It demonstrates the sequence: stream initiation, detection of send blocking due to flow control, confirmation of message sending after the server reads, reading messages received from the server, and successful stream termination.\nSOURCE: https://github.com/grpc/grpc-go/blob/master/examples/features/flow_control/README.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n2023/09/19 15:49:49 New stream began.\n2023/09/19 15:49:50 Sending is blocked.\n2023/09/19 15:49:51 Sent 25 messages.\n2023/09/19 15:49:53 Read 25 messages.\n2023/09/19 15:49:53 Stream ended successfully.\n```"
  }
]