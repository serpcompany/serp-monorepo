[
  {
    "owner": "coding-kitties",
    "repo": "investing-algorithm-framework",
    "content": "TITLE: Implementing a Basic Trading Algorithm with Investing Algorithm Framework\nDESCRIPTION: Example Python script demonstrating how to create a simple trading algorithm that buys BTC every 2 hours using the Investing Algorithm Framework. It includes setting up market data sources, portfolio configuration, and defining a trading strategy.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/README.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport logging.config\nfrom dotenv import load_dotenv\n\nfrom investing_algorithm_framework import create_app, PortfolioConfiguration, \\\n    TimeUnit, CCXTOHLCVMarketDataSource, Context, CCXTTickerMarketDataSource, \\\n    MarketCredential, DEFAULT_LOGGING_CONFIG, Algorithm, Context\n\nload_dotenv()\nlogging.config.dictConfig(DEFAULT_LOGGING_CONFIG)\n\n# OHLCV data for candles\nbitvavo_btc_eur_ohlcv_2h = CCXTOHLCVMarketDataSource(\n    identifier=\"BTC-ohlcv\",\n    market=\"BITVAVO\",\n    symbol=\"BTC/EUR\",\n    time_frame=\"2h\",\n    window_size=200\n)\n# Ticker data for orders, trades and positions\nbitvavo_btc_eur_ticker = CCXTTickerMarketDataSource(\n    identifier=\"BTC-ticker\",\n    market=\"BITVAVO\",\n    symbol=\"BTC/EUR\",\n)\napp = create_app()\n\n# Bitvavo market credentials are read from .env file, or you can\n# set them  manually as params\napp.add_market_credential(MarketCredential(market=\"bitvavo\"))\napp.add_portfolio_configuration(\n    PortfolioConfiguration(\n        market=\"bitvavo\", trading_symbol=\"EUR\", initial_balance=40\n    )\n)\n\nalgorithm = Algorithm(name=\"test_algorithm\")\n\n# Define a strategy for the algorithm that will run every 10 seconds\n@algorithm.strategy(\n    time_unit=TimeUnit.SECOND,\n    interval=10,\n    market_data_sources=[bitvavo_btc_eur_ticker, bitvavo_btc_eur_ohlcv_2h]\n)\ndef perform_strategy(context: Context, market_data: dict):\n    # Access the data sources with the indentifier\n    polars_df = market_data[\"BTC-ohlcv\"]\n    ticker_data = market_data[\"BTC-ticker\"]\n    unallocated_balance = context.get_unallocated()\n    positions = context.get_positions()\n    trades = context.get_trades()\n    open_trades = context.get_open_trades()\n    closed_trades = context.get_closed_trades()\n\napp.add_algorithm(algorithm)\n\nif __name__ == \"__main__\":\n    app.run()\n```\n\n----------------------------------------\n\nTITLE: Creating Entry Signal Visualization Based on MACD and Williams %R in Python\nDESCRIPTION: This function identifies and visualizes trading entry signals based on MACD crossovers and Williams %R indicator values. It analyzes each data point sequentially to find bullish crossovers and evaluates Williams %R to confirm entry signals.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/examples/example_strategies/macd_wr/macd_wr.ipynb#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef create_entry_graph(data: pd.DataFrame):\n    \"\"\"\n    Create an entry graph indicating bullish crossover signals.\n    \"\"\"\n    entry_indexes = []\n\n    for idx, row in enumerate(data.itertuples(index=True), start=1):\n        selected_rows = data.iloc[:idx]\n\n        # Check if there is a bullish crossover between MACD and MACD Signal line\n        if Strategy.is_crossover(selected_rows, \"MACD\", \"MACD_SIGNAL\"):\n            # Get the last higher high or lower high index\n            # Select the rows where WILLR_highs is either -1 or 1\n            peaks = selected_rows[(data['WILLR_highs'] == -1) | (selected_rows['WILLR_highs'] == 1)]\n\n            if len(peaks) == 0 or row.WILLR > -20 or row.MACD == 0:\n                continue\n            \n            # Select the last row from the filtered data\n            last_row = peaks.iloc[-1]\n            \n            # Check if the peak was within the last 12 rows\n            if last_row.name in data.index[max(0, idx-24):idx]:\n                entry_indexes.append(row.Index)  # Append the actual index value\n\n    entry_close_values = data.loc[entry_indexes, 'Close']\n\n    return go.Scatter(\n        x=entry_indexes,\n        y=entry_close_values,\n        mode='markers',\n        marker=dict(symbol='circle', size=10, color='green'),\n        name='Entry Signal'\n    )\n```\n\n----------------------------------------\n\nTITLE: Creating MACD Chart Visualization with Crossover Signals in Python\nDESCRIPTION: This function creates a MACD chart visualization using Plotly. It generates scatter plots for the MACD line, signal line, histogram, and bullish/bearish crossover points. The function validates input data structure before generating the visualization components.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/examples/example_strategies/macd_wr/macd_wr.ipynb#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom plotly import graph_objects as go\nfrom investing_algorithm_framework.indicators import get_peaks\nimport pandas as pd\n\ndef create_macd_chart(data: pd.DataFrame):\n\n    # Check if the index is of type datetime\n    if not isinstance(data.index, pd.DatetimeIndex):\n        raise ValueError(\"The index of the data should be of type datetime\")\n\n    # Check if the data has the required columns\n    if 'MACD' not in data.columns:\n        raise ValueError(\"The data should have a 'MACD' column\")\n    if 'MACD_SIGNAL' not in data.columns:\n        raise ValueError(\"The data should have a 'MACD_SIGNAL' column\")\n    \n    # Create crossover signals\n    bearish_crossover_index = data[(data['MACD'] < data['MACD_SIGNAL']) & (data['MACD'].shift(1) > data['MACD_SIGNAL'].shift(1))].index\n    bearish_crossover_values = data.loc[bearish_crossover_index, 'MACD']\n    bullish_crossunder_index = data[(data['MACD'] > data['MACD_SIGNAL']) & (data['MACD'].shift(1) < data['MACD_SIGNAL'].shift(1))].index\n    bullish_crossunder_values = data.loc[bullish_crossunder_index, 'MACD']\n\n    bearish_crossover_graph = go.Scatter(\n        x=bearish_crossover_index,\n        y=bearish_crossover_values,\n        mode='markers',\n        marker=dict(symbol='circle', size=10, color='red'),\n        name='MACD bearish Crossover'\n    )\n\n    bullish_crossunder_graph = go.Scatter(\n        x=bullish_crossunder_index,\n        y=bullish_crossunder_values,\n        mode='markers',\n        marker=dict(symbol='circle', size=10, color='green'),\n        name='MACD bullish Crossover'\n    )\n\n    # Add MACD line\n    macd_graph = go.Scatter(\n        x=data.index,\n        y=data['MACD'],\n        mode='lines',\n        name='MACD'\n    )\n\n    # Add MACD Signal line\n    macd_signal_graph = go.Scatter(\n        x=data.index,\n        y=data['MACD_SIGNAL'],\n        mode='lines',\n        name='MACD Signal'\n    )\n\n    # Add MACD Histogram\n    macd_histogram_graph = go.Bar(\n        x=data.index,\n        y=data['MACD_HISTOGRAM'],\n        name='MACD Histogram'\n    )\n\n    return macd_graph, macd_signal_graph, macd_histogram_graph, bearish_crossover_graph, bullish_crossunder_graph\n```\n\n----------------------------------------\n\nTITLE: Creating Exit Signal Visualization Based on MACD and Williams %R in Python\nDESCRIPTION: This function identifies and visualizes potential exit signals for a trading strategy. It detects when MACD crosses under its signal line or when Williams %R rises above -20, signaling potential selling opportunities.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/examples/example_strategies/macd_wr/macd_wr.ipynb#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef create_exit_graph(data: pd.DataFrame):\n    \"\"\"\n    \"\"\"\n    exit_indexes = []\n\n    for idx, row in enumerate(data.itertuples(index=True), start=1):\n        selected_rows = data.iloc[:idx]\n\n        # Check if there is a bearish crossover between MACD and MACD Signal line\n        if Strategy.is_crossunder(selected_rows, \"MACD\", \"MACD_SIGNAL\") or row.WILLR > -20:\n        \n            # # Check if in the past 12 rows (24 hours) there was a crossover above the -50 range of the Williams %R\n            # selection = data.iloc[max(0, idx-12):idx]\n\n            # if Strategy.has_crossed_upward(selection, \"WILLR\", -50):\n            exit_indexes.append(row.Index)\n        \n    exit_close_values = data.loc[exit_indexes, 'Close']\n    return go.Scatter(\n        x=exit_indexes,\n        y=exit_close_values,\n        mode='markers',\n\n```\n\n----------------------------------------\n\nTITLE: Generating a Backtesting Report Output in Investing Algorithm Framework\nDESCRIPTION: This example shows the output from using the pretty_print_backtest function on a moving average trading bot. The report displays a detailed summary of backtesting performance including portfolio balance, trades, positions, stop losses, and take profits. It tracks metrics such as growth, trade durations, and high-water marks.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/README.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n                  :%%%#+-          .=*#%%%        Backtest report\n                  *%%%%%%%+------=*%%%%%%%-       ---------------------------\n                  *%%%%%%%%%%%%%%%%%%%%%%%-       Start date: 2023-08-24 00:00:00\n                  .%%%%%%%%%%%%%%%%%%%%%%#        End date: 2023-12-02 00:00:00\n                   #%%%####%%%%%%%%**#%%%+        Number of days: 100\n             .:-+*%%%%- -+..#%%%+.+-  +%%%#*=-:   Number of runs: 1201\n              .:-=*%%%%. += .%%#  -+.-%%%%=-:..   Number of orders: 15\n              .:=+#%%%%%*###%%%%#*+#%%%%%%*+-:    Initial balance: 400.0\n                    +%%%%%%%%%%%%%%%%%%%=         Final balance: 453.07\n                :++  .=#%%%%%%%%%%%%%*-           Total net gain: 18.85 4.7%\n               :++:      :+%%%%%%#-.              Growth: 53.07 13.27%\n              :++:        .%%%%%#=                Number of trades closed: 2\n             :++:        .#%%%%%#*=               Number of trades open(end of backtest): 2\n            :++-        :%%%%%%%%%+=              Percentage positive trades: 75.0%\n           .++-        -%%%%%%%%%%%+=             Percentage negative trades: 25.0%\n          .++-        .%%%%%%%%%%%%%+=            Average trade size: 98.79 EUR\n         .++-         *%%%%%%%%%%%%%*+:           Average trade duration: 189.0 hours\n        .++-          %%%%%%%%%%%%%%#+=\n        =++........:::%%%%%%%%%%%%%%*+-\n        .=++++++++++**#%%%%%%%%%%%%%++.\n\nPositions overview\n╭────────────┬──────────┬──────────────────────┬───────────────────────┬──────────────┬───────────────┬───────────────────────────┬────────────────┬───────────────╮\n│ Position   │   Amount │   Pending buy amount │   Pending sell amount │   Cost (EUR) │ Value (EUR)   │ Percentage of portfolio   │ Growth (EUR)   │ Growth_rate   │\n├────────────┼──────────┼──────────────────────┼───────────────────────┼──────────────┼───────────────┼───────────────────────────┼────────────────┼───────────────┤\n│ EUR        │ 253.09   │                    0 │                     0 │       253.09 │ 253.09 EUR    │ 55.86%                    │ 0.00 EUR       │ 0.00%         │\n├────────────┼──────────┼──────────────────────┼───────────────────────┼──────────────┼───────────────┼───────────────────────────┼────────────────┼───────────────┤\n│ BTC        │   0.0028 │                    0 │                     0 │        97.34 │ 99.80 EUR     │ 22.03%                    │ 2.46 EUR       │ 2.52%         │\n├────────────┼──────────┼──────────────────────┼───────────────────────┼──────────────┼───────────────┼───────────────────────────┼────────────────┼───────────────┤\n│ DOT        │  19.9521 │                    0 │                     0 │       100    │ 100.18 EUR    │ 22.11%                    │ 0.18 EUR       │ 0.18%         │\n╰────────────┴──────────┴──────────────────────┴───────────────────────┴──────────────┴───────────────┴───────────────────────────┴────────────────┴───────────────╯\nTrades overview\n╭───────────────────┬────────────────┬───────────────────────┬───────────────────────────┬──────────────────┬──────────────────┬─────────────┬────────────────────┬──────────────────────────────┬─────────────────────────────────╮\n│ Pair (Trade id)   │ Status         │ Amount (remaining)    │ Net gain (EUR)            │ Open date        │ Close date       │ Duration    │   Open price (EUR) │ Close price's (EUR)          │ High water mark                 │\n├───────────────────┼────────────────┼───────────────────────┼───────────────────────────┼──────────────────┼──────────────────┼─────────────┼────────────────────┼──────────────────────────────┼─────────────────────────────────┤\n│ BTC/EUR (1)       │ CLOSED         │ 0.0040 (0.0000) BTC   │ 1.98 (2.02%)              │ 2023-09-13 14:00 │ 2023-09-22 12:00 │ 214.0 hours │           24490.4  │ 24984.93                     │ 25703.77 EUR (2023-09-19 14:00) │\n├───────────────────┼────────────────┼───────────────────────┼───────────────────────────┼──────────────────┼──────────────────┼─────────────┼────────────────────┼──────────────────────────────┼─────────────────────────────────┤\n│ DOT/EUR (2)       │ CLOSED, SL, TP │ 24.7463 (0.0000) DOT  │ 13.53 (13.53%)            │ 2023-10-30 04:00 │ 2023-11-15 02:00 │ 382.0 hours │               4.04 │ 4.23, 4.38, 4.24, 4.25, 4.79 │ 5.45 EUR (2023-11-12 10:00)     │\n├───────────────────┼────────────────┼───────────────────────┼───────────────────────────┼──────────────────┼──────────────────┼─────────────┼────────────────────┼──────────────────────────────┼─────────────────────────────────┤\n│ BTC/EUR (3)       │ CLOSED         │ 0.0030 (0.0000) BTC   │ -0.20 (-0.20%)            │ 2023-11-06 14:00 │ 2023-11-06 16:00 │ 2.0 hours   │           32691.5  │ 32625.87                     │ 32625.87 EUR (2023-11-06 16:00) │\n├───────────────────┼────────────────┼───────────────────────┼───────────────────────────┼──────────────────┼──────────────────┼─────────────┼────────────────────┼──────────────────────────────┼─────────────────────────────────┤\n│ BTC/EUR (4)       │ CLOSED, TP     │ 0.0030 (0.0000) BTC   │ 3.54 (3.56%)              │ 2023-11-07 22:00 │ 2023-11-14 12:00 │ 158.0 hours │           33126.6  │ 34746.64, 33865.42           │ 34967.12 EUR (2023-11-10 22:00) │\n├───────────────────┼────────────────┼───────────────────────┼───────────────────────────┼──────────────────┼──────────────────┼─────────────┼────────────────────┼──────────────────────────────┼─────────────────────────────────┤\n│ BTC/EUR (5)       │ OPEN           │ 0.0028 (0.0028) BTC   │ 2.46 (2.52%) (unrealized) │ 2023-11-29 12:00 │                  │ 60.0 hours  │           34765.9  │                              │ 35679.63 EUR (2023-12-01 16:00) │\n├───────────────────┼────────────────┼───────────────────────┼───────────────────────────┼──────────────────┼──────────────────┼─────────────┼────────────────────┼──────────────────────────────┼─────────────────────────────────┤\n│ DOT/EUR (6)       │ OPEN           │ 19.9521 (19.9521) DOT │ 0.18 (0.18%) (unrealized) │ 2023-11-30 18:00 │                  │ 30.0 hours  │               5.01 │                              │ 5.05 EUR (2023-11-30 20:00)     │\n╰───────────────────┴────────────────┴───────────────────────┴───────────────────────────┴──────────────────┴──────────────────┴─────────────┴────────────────────┴──────────────────────────────┴─────────────────────────────────╯\nStop losses overview\n╭────────────────────┬───────────────┬──────────┬──────────┬─────────────────────────────────┬──────────────┬────────────────┬───────────────────────────────┬──────────────┬───────────┬───────────────╮\n│ Trade (Trade id)   │ Status        │ Active   │ Type     │ Stop Loss (Initial Stop Loss)   │ Open price   │ Sell price's   │ High water mark               │ Percentage   │ Size      │ Sold amount   │\n├────────────────────┼───────────────┼──────────┼──────────┼─────────────────────────────────┼──────────────┼────────────────┼───────────────────────────────┼──────────────┼───────────┼───────────────┤\n│ BTC/EUR (1)        │ NOT TRIGGERED │ False    │ TRAILING │ 24418.58 (23265.85) (5.0)% EUR  │ 24490.37 EUR │ None           │ 25703.77 EUR 2023-09-19 14:00 │ 50.0%        │ 0.00 BTC  │               │\n├────────────────────┼───────────────┼──────────┼──────────┼─────────────────────────────────┼──────────────┼────────────────┼───────────────────────────────┼──────────────┼───────────┼───────────────┤\n│ DOT/EUR (2)        │ TRIGGERED     │ False    │ TRAILING │ 4.28 (3.84) (5.0)% EUR          │ 4.04 EUR     │ 4.239,4.254    │ 4.51 EUR 2023-11-01 20:00     │ 50.0%        │ 12.37 DOT │ 12.3732 DOT   │\n├────────────────────┼───────────────┼──────────┼──────────┼─────────────────────────────────┼──────────────┼────────────────┼───────────────────────────────┼──────────────┼───────────┼───────────────┤\n│ BTC/EUR (3)        │ NOT TRIGGERED │ False    │ TRAILING │ 31056.93 (31056.93) (5.0)% EUR  │ 32691.51 EUR │ None           │ 32691.51 EUR                  │ 50.0%        │ 0.00 BTC  │               │\n├────────────────────┼───────────────┼──────────┼──────────┼─────────────────────────────────┼──────────────┼────────────────┼───────────────────────────────┼──────────────┼───────────┼───────────────┤\n│ BTC/EUR (4)        │ NOT TRIGGERED │ False    │ TRAILING │ 33218.76 (31470.27) (5.0)% EUR  │ 33126.60 EUR │ None           │ 34967.12 EUR 2023-11-10 22:00 │ 50.0%        │ 0.00 BTC  │               │\n├────────────────────┼───────────────┼──────────┼──────────┼─────────────────────────────────┼──────────────┼────────────────┼───────────────────────────────┼──────────────┼───────────┼───────────────┤\n│ BTC/EUR (5)        │ NOT TRIGGERED │ True     │ TRAILING │ 33895.65 (33027.62) (5.0)% EUR  │ 34765.92 EUR │ None           │ 35679.63 EUR 2023-12-01 16:00 │ 50.0%        │ 0.00 BTC  │               │\n├────────────────────┼───────────────┼──────────┼──────────┼─────────────────────────────────┼──────────────┼────────────────┼───────────────────────────────┼──────────────┼───────────┼───────────────┤\n│ DOT/EUR (6)        │ NOT TRIGGERED │ True     │ TRAILING │ 4.80 (4.76) (5.0)% EUR          │ 5.01 EUR     │ None           │ 5.05 EUR 2023-11-30 20:00     │ 50.0%        │ 9.98 DOT  │               │\n╰────────────────────┴───────────────┴──────────┴──────────┴─────────────────────────────────┴──────────────┴────────────────┴───────────────────────────────┴──────────────┴───────────┴───────────────╯\nTake profits overview\n╭────────────────────┬───────────────┬──────────┬──────────┬─────────────────────────────────────┬──────────────┬────────────────┬─────────────────────────────────┬──────────────┬─────────────┬───────────────╮\n```\n\n----------------------------------------\n\nTITLE: Advanced Entry Signal Strategy (v3) with Slope Analysis in Python\nDESCRIPTION: This function implements a more sophisticated entry signal detection algorithm that analyzes the slope of Williams %R between peak points. It identifies entry signals when MACD crosses its signal line, Williams %R is below -30, and the indicator has a steep negative slope.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/examples/example_strategies/macd_wr/macd_wr.ipynb#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef create_entry_graph_v3(data: pd.DataFrame):\n    \"\"\"\n    Create an entry graph indicating bullish crossover signals.\n    \"\"\"\n    entry_indexes = []\n\n    for idx, row in enumerate(data.itertuples(index=True), start=1):\n        selected_rows = data.iloc[:idx]\n\n        # Check if there is a bullish crossover between MACD and MACD Signal line\n        if Strategy.is_crossover(selected_rows, \"MACD\", \"MACD_SIGNAL\") and row.WILLR < -30:\n\n            if row.WILLR > -20 or row.MACD == 0:\n                continue\n\n            # Select the rows where WILLR_highs is either -1 or 1\n            peaks = selected_rows[(data['WILLR_highs'] == -1) | (selected_rows['WILLR_highs'] == 1)]\n            \n            # Select the last higher high or lower high index\n            if len(peaks) == 0:\n                continue\n\n            # Select the last row from the filtered data\n            last_peak_row = peaks.iloc[-1]\n\n            # Caclulate the slope between the current row WILLR and the last peak WILLR\n            # 2 hours\n            delta = (row.Index - last_peak_row.name).total_seconds() / 7200\n\n            if delta == 0:\n                continue\n            \n            slope = Strategy.calculate_slope(((row.WILLR, delta), (last_peak_row.WILLR, 0)))\n\n            if slope < -0.5:\n            # Slope should be smaller then negative 0.5, meaning a large decrease in the WILLR value\n                entry_indexes.append(row.Index)  # Append the actual index value\n\n    entry_close_values = data.loc[entry_indexes, 'Close']\n\n    return go.Scatter(\n        x=entry_indexes,\n        y=entry_close_values,\n        mode='markers',\n        marker=dict(symbol='circle', size=10, color='green'),\n        name='Entry Signal'\n    )\n```\n\n----------------------------------------\n\nTITLE: Creating Interactive Technical Analysis Charts with Plotly\nDESCRIPTION: Creates interactive charts displaying price data, MACD, and Williams%R indicators using Plotly. Implements tabbed visualization with multiple date ranges and includes peak detection for trend analysis.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/examples/example_strategies/macd_wr/macd_wr.ipynb#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom plotly.subplots import make_subplots\nfrom plotly import graph_objects as go\nfrom investing_algorithm_framework.indicators import get_peaks\nfrom strategy import Strategy\n\ndf = Strategy.add_macd(df)\ndf = Strategy.add_willr(df)\ndf = get_peaks(df, key=\"WILLR\", order=3, k=2)\n\n# Create tabbed results\ntab_contents = []\ntab_titles = []\n\nfor i, date_range in enumerate(trend_data_ranges):\n    title = f\"Range ({date_range.name} {date_range.start_date.date()} to {date_range.end_date.date()})\"\n    tab_titles.append(title)\n    \n    # Slice DataFrame for the date range\n    df_slice = df.loc[date_range.start_date:date_range.end_date]    \n\n    # Add price graph\n    close_price = go.Scatter(\n        x=df_slice.index,\n        y=df_slice[\"Close\"],\n        mode='lines',\n        line=dict(color=\"blue\", width=2),\n        name=\"Close Price\"\n    )\n\n    # Add Williams%R graph\n    willr_graph = go.Scatter(\n        x=df_slice.index,\n        y=df_slice[\"WILLR\"],\n        mode='lines',\n        line=dict(color=\"orange\", width=2),\n        name=\"Williams%R\"\n    )\n\n    willr_higher_high_graph, willr_lower_high_graph, willr_lower_lows_graph, willr_higher_lows = create_peaks_chart(df_slice, key=\"WILLR\")\n    macd_graph, macd_signal_graph, macd_histogram_graph, bearish_crossover_graph, bullish_crossover_graph = create_macd_chart(df_slice)\n\n    fig = make_subplots(rows=4, cols=1, shared_xaxes=True, vertical_spacing=0.2)\n    fig.add_trace(close_price, row=1, col=1)\n    fig.add_trace(willr_graph, row=2, col=1)\n    fig.add_trace(macd_graph, row=3, col=1)\n    fig.add_trace(macd_signal_graph, row=3, col=1)\n    fig.add_trace(bearish_crossover_graph, row=3, col=1)\n    fig.add_trace(bullish_crossover_graph, row=3, col=1)\n    fig.add_trace(willr_higher_high_graph, row=4, col=1)\n    fig.add_trace(willr_lower_high_graph, row=4, col=1)\n    fig.add_trace(willr_lower_lows_graph, row=4, col=1)\n    fig.add_trace(willr_higher_lows, row=4, col=1)\n    fig.add_trace(willr_graph, row=4, col=1)\n    \n    fig.update_layout(\n        title=f\"Close Prices from {date_range.start_date.date()} to {date_range.end_date.date()} ({date_range.name})\",\n        xaxis_title='Date',\n        yaxis_title='Close Price'\n    )\n```\n\n----------------------------------------\n\nTITLE: Visualizing Market Data with SMA Indicators Using Plotly and IPython Widgets\nDESCRIPTION: This code calculates 50-day and 200-day Simple Moving Averages (SMA), then creates an interactive visualization for each backtest date range using Plotly and IPython widgets. The visualization displays close prices alongside both moving averages in a tabbed interface.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/examples/example_strategies/macd_wr/macd_wr.ipynb#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport ipywidgets as widgets\nfrom IPython.display import display\nimport plotly.graph_objects as go\nfrom investing_algorithm_framework.indicators import get_sma\n\n# Add sma 50 and sma 200\ntotal_data_pandas_df = get_sma(total_data_pandas_df, period=50, source_column_name=\"Close\", result_column_name=\"SMA_50\")\ntotal_data_pandas_df = get_sma(total_data_pandas_df, period=200, source_column_name=\"Close\", result_column_name=\"SMA_200\")\n\n# Create tabbed results\ntab_contents = []\ntab_titles = []\n\nfor i, date_range in enumerate(backtest_date_ranges):\n\n    if date_range.up_trend is None and date_range.down_trend is None:\n        title = f\"All Data\"\n    else:\n        if date_range.up_trend:\n            title = f\"Up Trend ({date_range.start_date.date()} to {date_range.end_date.date()})\"\n        else:\n            title = f\"Down Trend ({date_range.start_date.date()} to {date_range.end_date.date()})\"\n\n    tab_titles.append(title)\n    \n    # Slice DataFrame for the date range\n    df_slice = total_data_pandas_df.loc[date_range.start_date:date_range.end_date]    \n\n    # Add price graph\n    graph = go.Scatter(\n        x=df_slice.index,\n        y=df_slice[\"Close\"],\n        mode='lines',\n        line=dict(color=\"blue\", width=2),\n        name=\"Close Price\"\n    )\n\n    # Add 50-day moving average graph\n    graph_sma_50 = go.Scatter(\n        x=df_slice.index,\n        y=df_slice[f\"SMA_50\"],\n        mode='lines',\n        line=dict(color=\"red\", width=2),\n        name=\"50-day SMA\"\n    )\n\n    # Add 200-day moving average graph\n    graph_sma_200 = go.Scatter(\n        x=df_slice.index,\n        y=df_slice[f\"SMA_200\"],\n        mode='lines',\n        line=dict(color=\"green\", width=2),\n        name=\"200-day SMA\"\n    )\n\n    # Create a Plotly figure for the DataFrame slice\n    fig = go.FigureWidget()\n    fig.add_trace(graph)\n    fig.add_trace(graph_sma_50)\n    fig.add_trace(graph_sma_200)\n    fig.update_layout(\n        title=f\"Close Prices from {date_range.start_date.date()} to {date_range.end_date.date()} ({date_range.name})\",\n        xaxis_title='Date',\n        yaxis_title='Close Price'\n    )\n    \n    # Create a widget for the Plotly figure\n    tab_contents.append(widgets.Output())\n    \n    with tab_contents[-1]:\n        display(fig)\n\n# Create and display tabs\ntabs = widgets.Tab()\ntabs.children = tab_contents\n\nfor i, title in enumerate(tab_titles):\n    tabs.set_title(i, title)\n\ndisplay(tabs)\n```\n\n----------------------------------------\n\nTITLE: Alternative Entry Signal Strategy (v2) Using MACD and Williams %R in Python\nDESCRIPTION: A simplified version of the entry signal detection that uses MACD crossovers and Williams %R thresholds without peak analysis. This function identifies potential buy signals when MACD crosses its signal line while Williams %R is below -30.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/examples/example_strategies/macd_wr/macd_wr.ipynb#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef create_entry_graph_v2(data: pd.DataFrame):\n    \"\"\"\n    Create an entry graph indicating bullish crossover signals.\n    \"\"\"\n    entry_indexes = []\n\n    for idx, row in enumerate(data.itertuples(index=True), start=1):\n        selected_rows = data.iloc[:idx]\n\n        # Check if there is a bullish crossover between MACD and MACD Signal line\n        if Strategy.is_crossover(selected_rows, \"MACD\", \"MACD_SIGNAL\") and row.WILLR < -30:\n\n            if row.WILLR > -20 or row.MACD == 0:\n                continue\n        \n            entry_indexes.append(row.Index)  # Append the actual index value\n\n    entry_close_values = data.loc[entry_indexes, 'Close']\n\n    return go.Scatter(\n        x=entry_indexes,\n        y=entry_close_values,\n        mode='markers',\n        marker=dict(symbol='circle', size=10, color='green'),\n        name='Entry Signal'\n    )\n```\n\n----------------------------------------\n\nTITLE: Peak Detection using SciPy and Matplotlib\nDESCRIPTION: Implements peak detection algorithm using SciPy's argrelextrema function to identify local maxima and minima in Williams%R indicator data, visualizing results with Matplotlib.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/examples/example_strategies/macd_wr/macd_wr.ipynb#2025-04-23_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom scipy.signal import argrelextrema\n\nn = 8 # number of points to be checked before and after\n\n# Find local peaks\ndf[\"hh\"] =  df.iloc[argrelextrema(df[\"WILLR\"].values, np.greater_equal, order=n)[0]][\"WILLR\"]\ndf[\"ll\"] =  df.iloc[argrelextrema(df[\"WILLR\"].values, np.less, order=n)[0]][\"WILLR\"]\ndf[\"lh\"] = df.iloc[argrelextrema(df[\"WILLR\"].values, np.greater, order=n)[0]][\"WILLR\"]\ndf[\"hl\"] = df.iloc[argrelextrema(df[\"WILLR\"].values, np.less, order=n)[0]][\"WILLR\"]\n\n# Plot results\nplt.scatter(df.index, df['hh'], c='r')\nplt.scatter(df.index, df['ll'], c='g')\nplt.scatter(df.index, df['lh'], c='b')\nplt.scatter(df.index, df['hl'], c='y')\nplt.plot(df.index, df['WILLR'])\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Creating Peak Analysis Chart for Technical Indicators in Python\nDESCRIPTION: This function creates a chart to visualize higher highs, lower highs, higher lows, and lower lows in price data. It uses the input dataframe with pre-calculated peak indicators to generate scatter plots marking different types of peak confirmations on a price chart.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/examples/example_strategies/macd_wr/macd_wr.ipynb#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef create_peaks_chart(data: pd.DataFrame, key):\n\n    # Check if the index is of type datetime\n    if not isinstance(data.index, pd.DatetimeIndex):\n        raise ValueError(\"The index of the data should be of type datetime\")\n\n    keys = [f'{key}_highs', f'{key}_lows']\n\n    for key_column in keys:\n        if key_column not in data.columns:\n            raise ValueError(f\"The data should have a '{key_column}' column\")\n\n    # Get all peak indexes\n    hh_close_index = data[data[f'{key}_highs'] == 1].index\n    lh_close_index = data[data[f'{key}_highs'] == -1].index\n    ll_close_index = data[data[f'{key}_lows'] == 1].index\n    hl_close_index = data[data[f'{key}_lows'] == -1].index\n\n    # Subtract for each index 10 hours\n    hh_close_index = hh_close_index - pd.Timedelta(hours=2 * 3)\n    lh_close_index = lh_close_index - pd.Timedelta(hours=2 * 3)\n    ll_close_index = ll_close_index - pd.Timedelta(hours=2 * 3)\n    hl_close_index = hl_close_index - pd.Timedelta(hours=2 * 3)\n\n    # Function to find nearest values\n    def get_nearest_values(indexes, data, key):\n        values = []\n        for idx in indexes:\n            if idx in data.index:\n                values.append(data.loc[idx, key])\n            else:\n                nearest_idx = data.index.get_indexer([idx], method='nearest')\n                if nearest_idx[0] != -1:\n                    values.append(data.iloc[nearest_idx[0]][key])\n        return values\n\n    # Use the function to get the corresponding 'Close' values\n    hh_close_values = get_nearest_values(hh_close_index, data, key)\n    lh_close_values = get_nearest_values(lh_close_index, data, key)\n    ll_close_values = get_nearest_values(ll_close_index, data, key)\n    hl_close_values = get_nearest_values(hl_close_index, data, key)\n\n    # Add higher highs\n    higher_high_graph = go.Scatter(\n        x=hh_close_index,\n        # x=dates[hh_close_index - order].values,\n        y=hh_close_values,\n        mode='markers',\n        marker=dict(symbol='circle', size=5, color='blue'),\n        name='Higher High Confirmation'\n    )\n\n    # Add lower highs\n    lower_high_graph = go.Scatter(\n        x=lh_close_index,\n        y=lh_close_values,\n        mode='markers',\n        marker=dict(symbol='circle', size=5, color='red'),\n        name='Lower High Confirmation'\n    )\n\n    # Add lower lows\n    lower_lows_graph = go.Scatter(\n        x=ll_close_index,\n        y=ll_close_values,\n        mode='markers',\n        marker=dict(symbol='circle', size=5, color='green'),\n        name='Lower Lows Confirmation'\n    )\n\n    # Add higher lows\n    higher_lows = go.Scatter(\n        x=hl_close_index,\n        y=hl_close_values,\n        mode='markers',\n        marker=dict(symbol='circle', size=5, color='purple'),\n        name='Higher Lows Confirmation'\n    )\n\n    return higher_high_graph, lower_high_graph, lower_lows_graph, higher_lows\n```\n\n----------------------------------------\n\nTITLE: Defining CCXT OHLCV Market Data Sources for BTC/EUR\nDESCRIPTION: This code defines two data sources using the CCXT library to fetch OHLCV (Open, High, Low, Close, Volume) data for the BTC/EUR trading pair from Bitvavo exchange at 2-hour and 1-day intervals, storing the data in a local directory.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/examples/example_strategies/macd_wr/macd_wr.ipynb#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom investing_algorithm_framework import CCXTOHLCVMarketDataSource\n\n# Define data storage path. The data provider will write all its downloaded data to this directory. \n# If at this location all files already exist it will just read from the files instead of downloading everything.\nstorage_path = os.path.join(os.getcwd(), \"data\")\ntwo_hour_btc_eur_data_source = CCXTOHLCVMarketDataSource(\n    identifier=\"BTC/EUR_OHLCV\",\n    symbol=\"BTC/EUR\",\n    market=\"BITVAVO\",\n    time_frame=\"2h\",\n    storage_path=storage_path\n)\n\none_day_btc_eur_data_source = CCXTOHLCVMarketDataSource(\n    identifier=\"BTC/EUR_OHLCV\",\n    symbol=\"BTC/EUR\",\n    market=\"BITVAVO\",\n    time_frame=\"1d\",\n    storage_path=storage_path    \n)\n```\n\n----------------------------------------\n\nTITLE: Detecting Market Trends and Creating Backtest Date Ranges\nDESCRIPTION: This code identifies uptrends and downtrends in the market data and creates backtest date ranges for each trend period. It converts the Polars DataFrame to a Pandas DataFrame and uses the detect_up_and_downtrends function to find market trends.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/examples/example_strategies/macd_wr/macd_wr.ipynb#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom investing_algorithm_framework import BacktestDateRange, convert_polars_to_pandas\nfrom investing_algorithm_framework.indicators import detect_up_and_downtrends\n\nbacktest_date_ranges = [BacktestDateRange(name=\"total_date_range\", start_date=total_date_range[0], end_date=total_date_range[1])]\n\n# Detect up and down trends \ntotal_data_pandas_df = convert_polars_to_pandas(total_data_polars_df)\ntrends = detect_up_and_downtrends(total_data_pandas_df)\n\nfor tred_indicator in trends:\n    backtest_date_ranges.append(\n        BacktestDateRange(name=tred_indicator, start_date=trends[tred_indicator][0], end_date=trends[tred_indicator][1])\n    )\n```\n\n----------------------------------------\n\nTITLE: Downloading BTC/EUR Daily Market Data for Analysis\nDESCRIPTION: This code downloads daily OHLCV (Open, High, Low, Close, Volume) market data for the BTC/EUR trading pair from the start to end date of the defined total date range, storing it in a Polars DataFrame for further analysis.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/examples/example_strategies/macd_wr/macd_wr.ipynb#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ntotal_data_polars_df = one_day_btc_eur_data_source.get_data(\n    start_date=total_date_range[0], end_date=total_date_range[1],\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing Investing Algorithm Framework Project\nDESCRIPTION: Commands to initialize a new Investing Algorithm Framework project, with an option for web version.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ investing-algorithm-framewor init\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ investing-algorithm-framework init --web\n```\n\n----------------------------------------\n\nTITLE: Setting Up Date Ranges for Backtesting with Adjusted Start Date\nDESCRIPTION: This code creates a date range for backtesting from 2021 to mid-2024, and also defines an extended start date for data collection that accounts for the 200-day lookback period needed for calculating long-term moving averages.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/examples/example_strategies/macd_wr/macd_wr.ipynb#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime, timedelta\nfrom investing_algorithm_framework import DateRange\n\ntotal_date_range = DateRange(\n    start_date=datetime(year=2021, month=1, day=1), \n    end_date=datetime(year=2024, month=6, day=1), \n    name=\"Total date range\"\n)\n\n# Our start date for our data is different then our start_date for our backtest range. This is because we will be using indicators such as the 200 sma, \n# which need to have atleast 200 data points before the start date of our backtest range. If we don't do this,\n# we can't calculate indicators such as the 200 sma for our strategy.\nstart_date_data = total_date_range.start_date - timedelta(days=200)\n```\n\n----------------------------------------\n\nTITLE: Exception Handling Best Practices in Python\nDESCRIPTION: Shows anti-patterns and proper exception handling techniques, including exception encapsulation and specific error handling.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/docs/STYLE_GUIDE.md#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Never do ...\ntry:\n    process_data()\nexcept:\n    pass\n\n# Encapsulate orginal exception trace\ndef process_data() -> None:\n    try:\n        do_something()\n    except KeyError as e:\n        # Raise a specific exception from do_something,\n        # encapsulate trace to a custom exception\n        raise MyApplicationException(\"Item not present\") from e\n```\n\n----------------------------------------\n\nTITLE: Installing Investing Algorithm Framework via pip\nDESCRIPTION: Command to install the Investing Algorithm Framework using pip package manager.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install investing-algorithm-framework\n```\n\n----------------------------------------\n\nTITLE: Installing Required Python Packages for Investing Algorithm Framework\nDESCRIPTION: This code snippet checks if the investing_algorithm_framework and ipywidgets packages are already installed, and installs them if they are not present in the environment.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/examples/example_strategies/macd_wr/macd_wr.ipynb#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import investing_algorithm_framework  \n    print(f\"investing_algorithm_framork is already installed.\")\nexcept ImportError:\n    print(\"investing_algorithm_framork is not installed. Installing...\")\n    import sys\n    !{sys.executable} -m pip install investing_algorithm_framework\n\ntry:\n    import ipywidgets\n    print(f\"ipywidgets is already installed.\")\nexcept ImportError:\n    print(\"ipywidgets is not installed. Installing...\")\n    import sys\n    !{sys.executable} -m pip install ipywidgets\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Service Handler Context Manager in Python\nDESCRIPTION: Implementation of a custom context manager for handling service operations, demonstrating __enter__ and __exit__ methods to manage service state during configuration updates.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/docs/STYLE_GUIDE.md#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass ServiceHandler:\n    def __enter__(self) -> ServiceHandler:\n        run(\"systemctl stop my.service\")\n        return self\n\n    def __exit__(self, exc_type: str, ex_value: str, ex_traceback: str) -> None:\n        run(\"systemctl start my.service\")\n\ndef update_service_conf() -> None:\n    # Body to update service's configuration\n\nif __name__ == '__main__':\n    with ServiceHandler():\n        update_service_conf()\n```\n\n----------------------------------------\n\nTITLE: Running a Backtest Example\nDESCRIPTION: Command to run a backtest example script provided in the framework's examples folder.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npython examples/backtest_example/run_backtest.py\n```\n\n----------------------------------------\n\nTITLE: Unit Testing Implementation with Python unittest\nDESCRIPTION: Example of writing unit tests using Python's unittest framework, showing setup methods and test case implementation.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/docs/STYLE_GUIDE.md#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom unittest import TestCase\n\n\nclass TestMyClass(TestCase):\n\n    def setup(self):\n        # Setup\n\n    @classmethod\n    def setup_class(cls):\n        # Setup class\n        pass\n\n    def test_my_function(self):\n        # Test the function\n        self.assertEqual(my_function(1), 2)\n```\n\n----------------------------------------\n\nTITLE: Python Naming Conventions Example\nDESCRIPTION: Demonstrates proper class, method, and variable naming conventions in Python with type hints.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/docs/STYLE_GUIDE.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nmy_variable = 10\n\nGLOBAL_CONSTANT = 10\n\nclass CatalogInformation:\n    def __init__(self, name: str) -> None:\n        # Body constructor\n\n    def get_metadata_count(self) -> int:\n        # Body method\n        return 1\n\n    def __check_internal_property(self) -> bool:\n        # Body private method\n        return True\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiple Context Managers in Python\nDESCRIPTION: Demonstrates how to use multiple context managers in a single with statement using parentheses for better readability.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/docs/STYLE_GUIDE.md#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nwith (\n    CtxManager1() as example1,\n    CtxManager2() as example2,\n    CtxManager3() as example3,\n):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Python Multiple Return Values Example\nDESCRIPTION: Demonstrates returning multiple values from a function with type hints and docstring.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/docs/STYLE_GUIDE.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef get_info(self) -> str, int:\n    \"\"\"\n    Return a string and an integer\n\n    Args:\n        - str: a string\n        - int: an integer\n    \"\"\"\n    return \"hello world\", 30\n```\n\n----------------------------------------\n\nTITLE: Python Docstring Example\nDESCRIPTION: Shows Google-style docstring format for function documentation with type hints.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/docs/STYLE_GUIDE.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef is_valid(a: int, b: str) -> bool:\n    \"\"\"\n    Explanation of the function\n\n    Args:\n        a (int): The first number.\n        b (int): The second number.\n\n    Returns:\n        Type: The return type.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Python Context Manager Example\nDESCRIPTION: Shows the usage of context managers for file handling using the 'with' statement.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/docs/STYLE_GUIDE.md#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nwith open(filename) as fd:\n    process_file(fd)\n\n# Note that parentheses are supported in Python 3.10 for context manager,\n```\n\n----------------------------------------\n\nTITLE: Running Test Suite - Bash\nDESCRIPTION: Command to run the project's test suite using Python's unittest framework to verify changes.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/docs/CONTRIBUTING.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython -m unittest discover -s tests\n```\n\n----------------------------------------\n\nTITLE: Running Code Linting - Bash\nDESCRIPTION: Command to run flake8 linting tool on the project's main package to ensure code style compliance.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/docs/CONTRIBUTING.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nflake8 investing_algorithm_framework\n```\n\n----------------------------------------\n\nTITLE: Python Code Layout Example\nDESCRIPTION: Demonstrates proper import ordering and function spacing in Python code following best practices.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/docs/STYLE_GUIDE.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Standard libs\nimport std_lib_1\nimport std_lib_2\n\n# Third party libs\nimport third_party_lib_1\nimport third_party_lib_2\n\n# Local lib\nfrom local_lib import class_1, function_1\n\n\n# After two blank lines\ndef top_level_function(args: int) -> str:\n    # Body\n```\n\n----------------------------------------\n\nTITLE: Cloning Repository for Contributing - Bash\nDESCRIPTION: Commands for forking and cloning the repository to begin contributing to the project.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/docs/CONTRIBUTING.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/your-username/your-project.git\ncd your-project\n```\n\n----------------------------------------\n\nTITLE: Framework Project Structure using YAML\nDESCRIPTION: Standard project structure layout showing key directories and files for a Python framework project.\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/docs/STYLE_GUIDE.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\ninvesting-algorithm-framework/\n│\n├── investing_algorithm_framework/\n│   ├── my_module/\n│   │   ├── __init__.py\n│   │   └── my_module.py\n│   │\n│   ├── my_other_module/\n│   │   ├── __init__.py\n│   │   └── my_other_module.py\n│   │\n│   └── __init__.py                # Entry point for the application\n│\n├── tests/\n│   ├── test_my_module.py\n│   └── test_my_other_module.py\n│\n├── docs/                      # Documentation (Sphinx, Markdown, etc.)\n│\n├── .gitignore                 # Ignore unnecessary files\n├── README.md                  # Project documentation\n├── pyproject.toml           # Build system and tool configurations\n└── LICENSE                    # License file\n```\n\n----------------------------------------\n\nTITLE: Social Media Profile Links with Badges in Markdown\nDESCRIPTION: HTML/Markdown hybrid code that displays LinkedIn and GitHub profile badges with links\nSOURCE: https://github.com/coding-kitties/investing-algorithm-framework/blob/main/AUTHORS.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Marc van Duyn | Mod and Contributor\n<a href=\"https://linkedin.com/in/marc-van-duyn\">\n  <img src=\"https://img.shields.io/badge/LinkedIn-0077B5?style=for-the-badge&logo=linkedin&logoColor=white\" width=\"200px\" />\n</a>\n<br/>\n<a href=\"https://github.com/MDUYN\">\n  <img src=\"https://img.shields.io/badge/GitHub-100000?style=for-the-badge&logo=github&logoColor=white\" width=\"200px\" />\n</a>\n```"
  }
]