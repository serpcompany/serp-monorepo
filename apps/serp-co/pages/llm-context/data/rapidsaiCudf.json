[
  {
    "owner": "rapidsai",
    "repo": "cudf",
    "content": "TITLE: Using cuDF Directly for Data Analysis in Python\nDESCRIPTION: This snippet demonstrates how to use cuDF directly to read a CSV file, perform calculations, and display grouped statistics. It showcases cuDF's pandas-like API for GPU-accelerated data operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/README.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cudf\n\ntips_df = cudf.read_csv(\"https://github.com/plotly/datasets/raw/master/tips.csv\")\ntips_df[\"tip_percentage\"] = tips_df[\"tip\"] / tips_df[\"total_bill\"] * 100\n\n# display average tip by dining party size\nprint(tips_df.groupby(\"size\").tip_percentage.mean())\n```\n\n----------------------------------------\n\nTITLE: Loading and Manipulating Data with Direct cuDF API\nDESCRIPTION: This example demonstrates importing cuDF directly and using it like pandas to load a CSV dataset, calculate tip percentages, and display average tips by dining party size.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/libcudf/README.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cudf\n\ntips_df = cudf.read_csv(\"https://github.com/plotly/datasets/raw/master/tips.csv\")\ntips_df[\"tip_percentage\"] = tips_df[\"tip\"] / tips_df[\"total_bill\"] * 100\n\n# display average tip by dining party size\nprint(tips_df.groupby(\"size\").tip_percentage.mean())\n```\n\n----------------------------------------\n\nTITLE: Reading Multiple CSV Files with Dask-cuDF\nDESCRIPTION: Shows how to read multiple CSV files into a single Dask-cuDF DataFrame using wildcard pattern matching.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_76\n\nLANGUAGE: python\nCODE:\n```\nddf = dask_cudf.read_csv(\"example_output/*.csv\")\nddf.head()\n```\n\n----------------------------------------\n\nTITLE: Using cuDF as a No-Code-Change Accelerator for Pandas in Python\nDESCRIPTION: This example shows how to use cuDF as a drop-in replacement for pandas, accelerating pandas operations on the GPU without changing the existing code. It utilizes the cudf.pandas extension to automatically use GPU acceleration where possible.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/README.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n%load_ext cudf.pandas  # pandas operations now use the GPU!\n\nimport pandas as pd\n\ntips_df = pd.read_csv(\"https://github.com/plotly/datasets/raw/master/tips.csv\")\ntips_df[\"tip_percentage\"] = tips_df[\"tip\"] / tips_df[\"total_bill\"] * 100\n\n# display average tip by dining party size\nprint(tips_df.groupby(\"size\").tip_percentage.mean())\n```\n\n----------------------------------------\n\nTITLE: Basic cuDF DataFrame Operations Example\nDESCRIPTION: Demonstrates loading CSV data and performing basic DataFrame operations using cuDF's native API. Shows how to read data, calculate derived columns, and perform groupby aggregations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_polars/README.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cudf\n\ntips_df = cudf.read_csv(\"https://github.com/plotly/datasets/raw/master/tips.csv\")\ntips_df[\"tip_percentage\"] = tips_df[\"tip\"] / tips_df[\"total_bill\"] * 100\n\n# display average tip by dining party size\nprint(tips_df.groupby(\"size\").tip_percentage.mean())\n```\n\n----------------------------------------\n\nTITLE: Using cuDF directly for DataFrame operations in Python\nDESCRIPTION: This snippet demonstrates how to import cuDF, read a CSV file, perform calculations, and display grouped results using GPU acceleration.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/README.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cudf\n\ntips_df = cudf.read_csv(\"https://github.com/plotly/datasets/raw/master/tips.csv\")\ntips_df[\"tip_percentage\"] = tips_df[\"tip\"] / tips_df[\"total_bill\"] * 100\n\n# display average tip by dining party size\nprint(tips_df.groupby(\"size\").tip_percentage.mean())\n```\n\n----------------------------------------\n\nTITLE: Initializing Multi-GPU Data Processing with Dask cuDF\nDESCRIPTION: Example demonstrating how to set up a GPU-aware Dask cluster for processing data across multiple GPUs using Dask cuDF. Includes cluster configuration, DataFrame backend setup, and basic data operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/dask_cudf/README.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport dask\nimport dask.dataframe as dd\nfrom dask_cuda import LocalCUDACluster\nfrom distributed import Client\n\nif __name__ == \"__main__\":\n\n  # Define a GPU-aware cluster to leverage multiple GPUs\n  client = Client(\n    LocalCUDACluster(\n      CUDA_VISIBLE_DEVICES=\"0,1\",  # Use two workers (on devices 0 and 1)\n      rmm_pool_size=0.9,  # Use 90% of GPU memory as a pool for faster allocations\n      enable_cudf_spill=True,  # Improve device memory stability\n      local_directory=\"/fast/scratch/\",  # Use fast local storage for spilling\n    )\n  )\n\n  # Set the default dataframe backend to \"cudf\"\n  dask.config.set({\"dataframe.backend\": \"cudf\"})\n\n  # Create your DataFrame collection from on-disk\n  # or in-memory data\n  df = dd.read_parquet(\"/my/parquet/dataset/\")\n\n  # Use cudf-like syntax to transform and/or query your data\n  query = df.groupby('item')['price'].mean()\n\n  # Compute, persist, or write out the result\n  query.head()\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries for cuDF and Dask cuDF\nDESCRIPTION: Imports necessary libraries including cudf, cupy, dask_cudf, and pandas. Also seeds the cupy random number generator.  These libraries are essential for creating and manipulating GPU DataFrames using cuDF and for distributed data processing using Dask cuDF.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\n\nimport cudf\nimport cupy as cp\nimport dask_cudf\nimport pandas as pd\n\ncp.random.seed(12)\n\n#### Portions of this were borrowed and adapted from the\n#### cuDF cheatsheet, existing cuDF documentation,\n#### and 10 Minutes to Pandas.\n```\n\n----------------------------------------\n\nTITLE: Creating a Dask cuDF DataFrame from a cuDF DataFrame\nDESCRIPTION: Creates a `dask_cudf.DataFrame` from an existing `cudf.DataFrame`, partitioning the data into two partitions. The `head()` method is used to display the first few entries.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndask_gdf = dask_cudf.from_cudf(gdf, npartitions=2)\ndask_gdf.head(n=2)\n```\n\n----------------------------------------\n\nTITLE: Reading CSV File with cuDF\nDESCRIPTION: Shows how to read a CSV file into a cuDF DataFrame using GPU acceleration.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_74\n\nLANGUAGE: python\nCODE:\n```\ndf = cudf.read_csv(\"example_output/foo.csv\")\ndf\n```\n\n----------------------------------------\n\nTITLE: Reading Parquet Files with cuDF\nDESCRIPTION: Shows how to read a Parquet file into a cuDF DataFrame using the GPU-accelerated Parquet reader, which loads data directly into GPU memory.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_49\n\nLANGUAGE: python\nCODE:\n```\ndf = cudf.read_parquet(\"example_output/temp_parquet\")\ndf\n```\n\n----------------------------------------\n\nTITLE: Creating GroupBy Objects in cuDF\nDESCRIPTION: This snippet demonstrates how to create GroupBy objects in cuDF using different methods: grouping by a single column, grouping by multiple columns, and grouping by an external Series.  The resulting GroupBy objects can then be used for aggregation or other group-wise operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/groupby.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import cudf\n>>> df = cudf.DataFrame({'a': [1, 1, 1, 2, 2], 'b': [1, 1, 2, 2, 3], 'c': [1, 2, 3, 4, 5]})\n>>> df\n   a  b  c\n0  1  1  1\n1  1  1  2\n2  1  2  3\n3  2  2  4\n4  2  3  5\n>>> gb1 = df.groupby('a')  # grouping by a single column\n>>> gb2 = df.groupby(['a', 'b'])  # grouping by multiple columns\n>>> gb3 = df.groupby(cudf.Series(['a', 'a', 'b', 'b', 'b']))  # grouping by an external column\n```\n\n----------------------------------------\n\nTITLE: Enabling Copy-on-Write in cuDF with Python\nDESCRIPTION: This snippet demonstrates how to enable copy-on-write in cuDF using the `cudf.set_option` method. It also specifies that this option should be set at the beginning of a script to avoid inconsistent behavior.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/copy-on-write.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import cudf\n>>> cudf.set_option(\"copy_on_write\", True)\n```\n\n----------------------------------------\n\nTITLE: Reading CSV with cuDF\nDESCRIPTION: Shows how to read a CSV file into a cuDF DataFrame using the read_csv function, which loads the data directly into GPU memory.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_45\n\nLANGUAGE: python\nCODE:\n```\ndf = cudf.read_csv(\"example_output/foo.csv\")\ndf\n```\n\n----------------------------------------\n\nTITLE: Using cuDF directly with pandas-like API\nDESCRIPTION: Example showing how to import cuDF and use it directly with a pandas-like API. This snippet demonstrates loading CSV data, performing calculations, and grouping operations on the GPU.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf/README.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cudf\n\ntips_df = cudf.read_csv(\"https://github.com/plotly/datasets/raw/master/tips.csv\")\ntips_df[\"tip_percentage\"] = tips_df[\"tip\"] / tips_df[\"total_bill\"] * 100\n\n# display average tip by dining party size\nprint(tips_df.groupby(\"size\").tip_percentage.mean())\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for GPU DataFrame Operations\nDESCRIPTION: Sets up the environment by importing necessary libraries for GPU-accelerated DataFrame operations: cuDF for single GPU operations, Dask cuDF for distributed GPU operations, CuPy for GPU-accelerated array operations, and Pandas for CPU operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\n\nimport cudf\nimport cupy as cp\nimport dask_cudf\nimport pandas as pd\n\ncp.random.seed(12)\n\n#### Portions of this were borrowed and adapted from the\n#### cuDF cheatsheet, existing cuDF documentation,\n#### and 10 Minutes to Pandas.\n```\n\n----------------------------------------\n\nTITLE: Creating cuDF DataFrame from Pandas DataFrame\nDESCRIPTION: Creates a pandas DataFrame then converts it to a cuDF DataFrame. The resulting `gdf` is a GPU-backed DataFrame with the same data as the original pandas DataFrame.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npdf = pd.DataFrame({\"a\": [0, 1, 2, 3], \"b\": [0.1, 0.2, None, 0.3]})\ngdf = cudf.DataFrame.from_pandas(pdf)\ngdf\n```\n\n----------------------------------------\n\nTITLE: Reading Parquet File with cuDF\nDESCRIPTION: Shows how to read a Parquet file into a cuDF DataFrame using GPU acceleration.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_78\n\nLANGUAGE: python\nCODE:\n```\ndf = cudf.read_parquet(\"example_output/temp_parquet\")\ndf\n```\n\n----------------------------------------\n\nTITLE: Creating and Merging DataFrames with cuDF\nDESCRIPTION: Demonstrates how to create cuDF DataFrames and perform a left join operation on them using a common key column.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_45\n\nLANGUAGE: python\nCODE:\n```\ndf_a = cudf.DataFrame()\ndf_a[\"key\"] = [\"a\", \"b\", \"c\", \"d\", \"e\"]\ndf_a[\"vals_a\"] = [float(i + 10) for i in range(5)]\n\ndf_b = cudf.DataFrame()\ndf_b[\"key\"] = [\"a\", \"c\", \"e\"]\ndf_b[\"vals_b\"] = [float(i + 100) for i in range(3)]\n\nmerged = df_a.merge(df_b, on=[\"key\"], how=\"left\")\nmerged\n```\n\n----------------------------------------\n\nTITLE: Applying Functions to Groups using GroupBy.apply in cuDF\nDESCRIPTION: This snippet illustrates how to apply a custom function to each group in a cuDF DataFrame using the `GroupBy.apply()` method.  The provided lambda function calculates the difference between the maximum and minimum values for each column within each group.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/groupby.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> df\n   a  b  c\n0  1  1  1\n1  1  1  2\n2  1  2  3\n3  2  2  4\n4  2  3  5\n>>> df.groupby('a').apply(lambda x: x.max() - x.min())\n   a  b  c\na\n0  0  1  2\n1  0  1  1\n```\n\n----------------------------------------\n\nTITLE: Creating and Transforming a Large Dask-cuDF DataFrame\nDESCRIPTION: Shows how to create a large DataFrame and perform a transformation, demonstrating Dask's lazy evaluation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_83\n\nLANGUAGE: python\nCODE:\n```\nnrows = 10000000\n\ndf2 = cudf.DataFrame({\"a\": cp.arange(nrows), \"b\": cp.arange(nrows)})\nddf2 = dask_cudf.from_cudf(df2, npartitions=16)\nddf2[\"c\"] = ddf2[\"a\"] + 5\nddf2\n```\n\n----------------------------------------\n\nTITLE: Column-specific Aggregation with Dask-cuDF\nDESCRIPTION: Demonstrates how to apply different aggregate functions to specific columns in a Dask-cuDF DataFrame after grouping, computing the results with the compute() method.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nddf.groupby(\"agg_col1\").agg({\"a\": \"max\", \"b\": \"mean\", \"c\": \"sum\"}).compute()\n```\n\n----------------------------------------\n\nTITLE: Creating a cuDF DataFrame\nDESCRIPTION: Creates a `cudf.DataFrame` with three columns ('a', 'b', 'c') initialized with integer ranges. The 'b' column contains reversed values. This showcases DataFrame creation in cuDF with specified column data.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndf = cudf.DataFrame(\n    {\n        \"a\": list(range(20)),\n        \"b\": list(reversed(range(20))),\n        \"c\": list(range(20)),\n    }\n)\ndf\n```\n\n----------------------------------------\n\nTITLE: Creating cuDF and Dask cuDF Series Objects\nDESCRIPTION: Demonstrates how to create a cuDF Series and convert it to a Dask cuDF Series with multiple partitions. Shows basic initialization with a list of values including None for missing data.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ns = cudf.Series([1, 2, 3, None, 4])\ns\n```\n\nLANGUAGE: python\nCODE:\n```\nds = dask_cudf.from_cudf(s, npartitions=2)\n# Note the call to head here to show the first few entries, unlike\n# cuDF objects, Dask-cuDF objects do not have a printing\n# representation that shows values since they may not be in local\n# memory.\nds.head(n=3)\n```\n\n----------------------------------------\n\nTITLE: Sorting cuDF DataFrame by Values\nDESCRIPTION: Sorts a `cudf.DataFrame` by the values in the 'b' column in ascending order. This demonstrates a basic sorting operation on a GPU DataFrame.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndf.sort_values(by=\"b\")\n```\n\n----------------------------------------\n\nTITLE: Applying Function with Arguments to cuDF Series\nDESCRIPTION: Demonstrates the application of the function defined with additional scalar arguments to a cuDF Series, utilizing the args parameter.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsr.apply(g, args=(42,))\n```\n\n----------------------------------------\n\nTITLE: Implementing Rolling Window UDF\nDESCRIPTION: Defines a custom function for rolling window operations that includes loops, math functions, and conditionals.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nimport math\n\n\ndef example_func(window):\n    b = 0\n    for a in window:\n        b = max(b, math.sqrt(a))\n    if b == 8:\n        return 100\n    return b\n```\n\n----------------------------------------\n\nTITLE: Reading CSV File with Dask-cuDF\nDESCRIPTION: Demonstrates how to read a CSV file into a Dask-cuDF DataFrame for distributed processing.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_75\n\nLANGUAGE: python\nCODE:\n```\nddf = dask_cudf.read_csv(\"example_output/foo_dask.csv\")\nddf.head()\n```\n\n----------------------------------------\n\nTITLE: Calculating Value Counts for Dask cuDF Series\nDESCRIPTION: Calculates the number of occurrences of each unique value in the 'a' column of a `dask_cudf.DataFrame` using the `value_counts` method and then displaying the first few values using head(). This allows for calculating histograms on distributed data.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nddf.a.value_counts().head()\n```\n\n----------------------------------------\n\nTITLE: Using cuDF as a no-code-change accelerator for pandas\nDESCRIPTION: Example demonstrating how to use cuDF as a drop-in replacement for pandas with the cudf.pandas extension. This allows GPU acceleration of pandas operations without changing existing code.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf/README.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n%load_ext cudf.pandas  # pandas operations now use the GPU!\n\nimport pandas as pd\n\ntips_df = pd.read_csv(\"https://github.com/plotly/datasets/raw/master/tips.csv\")\ntips_df[\"tip_percentage\"] = tips_df[\"tip\"] / tips_df[\"total_bill\"] * 100\n\n# display average tip by dining party size\nprint(tips_df.groupby(\"size\").tip_percentage.mean())\n```\n\n----------------------------------------\n\nTITLE: Reading Nested Data from Parquet Files into cuDF\nDESCRIPTION: This code snippet demonstrates how to read nested data from a Parquet file into a cuDF DataFrame. It shows the process of creating a Pandas DataFrame, saving it as Parquet, and loading it into cuDF while preserving the List data type. The code requires 'cudf' and 'pandas' libraries.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/data-types.md#2025-04-21_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n>>> pdf = pd.DataFrame({\"a\": [[1, 2], [3, 4, 5], [6, 7, 8]]})\n>>> pdf.to_parquet(\"lists.pq\")\n>>> gdf = cudf.read_parquet(\"lists.pq\")\n>>> gdf[\"a\"].dtype\nListDtype(int64)\n```\n\n----------------------------------------\n\nTITLE: Using cuDF as a pandas accelerator\nDESCRIPTION: This example shows how to use cuDF's pandas accelerator which supports 100% of the pandas API while leveraging GPU acceleration for supported operations, falling back to pandas when needed.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_kafka/README.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n%load_ext cudf.pandas  # pandas operations now use the GPU!\n\nimport pandas as pd\n\ntips_df = pd.read_csv(\"https://github.com/plotly/datasets/raw/master/tips.csv\")\ntips_df[\"tip_percentage\"] = tips_df[\"tip\"] / tips_df[\"total_bill\"] * 100\n\n# display average tip by dining party size\nprint(tips_df.groupby(\"size\").tip_percentage.mean())\n```\n\n----------------------------------------\n\nTITLE: Working with DateTime Columns in cuDF\nDESCRIPTION: Shows how to create a DataFrame with datetime columns and filter rows based on a specific date condition.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_56\n\nLANGUAGE: python\nCODE:\n```\nimport datetime as dt\n\ndate_df = cudf.DataFrame()\ndate_df[\"date\"] = pd.date_range(\"11/20/2018\", periods=72, freq=\"D\")\ndate_df[\"value\"] = cp.random.sample(len(date_df))\n\nsearch_date = dt.datetime.strptime(\"2018-11-23\", \"%Y-%m-%d\")\ndate_df.query(\"date <= @search_date\")\n```\n\n----------------------------------------\n\nTITLE: Detecting Missing Values with cudf in Python\nDESCRIPTION: This snippet shows how to detect missing values in a DataFrame using the `isna()` and `notna()` functions. The `isna()` function identifies null values, whereas `notna()` is used to find non-null entries. It also explains Python and NumPy's behavior in comparing None and `np.nan`.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/missing-data.ipynb#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndf.isna()\n```\n\nLANGUAGE: Python\nCODE:\n```\ndf[\"a\"].notna()\n```\n\n----------------------------------------\n\nTITLE: Converting cuDF DataFrame to Pandas\nDESCRIPTION: Demonstrates how to convert a cuDF DataFrame to a Pandas DataFrame for CPU-based processing.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_63\n\nLANGUAGE: python\nCODE:\n```\ndf.head().to_pandas()\n```\n\n----------------------------------------\n\nTITLE: GroupBy Excluding NA with cudf in Python\nDESCRIPTION: This snippet illustrates group by operations excluding `NA` values in cudf DataFrames while computing mean. It shows that by default `NA` values are dropped, but you can include them by setting `dropna=False`.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/missing-data.ipynb#2025-04-21_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\ndf1.groupby(\"a\").mean()\n```\n\nLANGUAGE: Python\nCODE:\n```\ndf1.groupby(\"a\", dropna=False).mean()\n```\n\n----------------------------------------\n\nTITLE: cuDF Pandas Accelerator Usage\nDESCRIPTION: Shows how to use cuDF as a drop-in replacement for pandas using the cudf.pandas extension. This allows pandas code to run on GPU without code changes.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_polars/README.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n%load_ext cudf.pandas  # pandas operations now use the GPU!\n\nimport pandas as pd\n\ntips_df = pd.read_csv(\"https://github.com/plotly/datasets/raw/master/tips.csv\")\ntips_df[\"tip_percentage\"] = tips_df[\"tip\"] / tips_df[\"total_bill\"] * 100\n\n# display average tip by dining party size\nprint(tips_df.groupby(\"size\").tip_percentage.mean())\n```\n\n----------------------------------------\n\nTITLE: Sorting Dask cuDF DataFrame by Values\nDESCRIPTION: Sorts a `dask_cudf.DataFrame` by the values in the 'b' column and displays the first few rows using `head()`.  The sorting is performed in parallel across the Dask cluster.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nddf.sort_values(by=\"b\").head()\n```\n\n----------------------------------------\n\nTITLE: Importing cudf.pandas Proxy Module Example\nDESCRIPTION: Demonstrates how to load the cudf.pandas extension and import pandas, showing how pandas is replaced with a proxy module that enables GPU acceleration.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/how-it-works.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nIn [1]: %load_ext cudf.pandas\n\nIn [2]: import pandas as pd\n\nIn [3]: pd\nOut[3]: <module 'pandas' (ModuleAccelerator(fast=cudf, slow=pandas))>\n```\n\n----------------------------------------\n\nTITLE: Using cuDF as a Pandas Accelerator\nDESCRIPTION: This example shows how to use cuDF as a no-code-change accelerator for pandas via cudf.pandas extension, which utilizes GPU for supported operations while maintaining 100% pandas API compatibility.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/libcudf/README.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n%load_ext cudf.pandas  # pandas operations now use the GPU!\n\nimport pandas as pd\n\ntips_df = pd.read_csv(\"https://github.com/plotly/datasets/raw/master/tips.csv\")\ntips_df[\"tip_percentage\"] = tips_df[\"tip\"] / tips_df[\"total_bill\"] * 100\n\n# display average tip by dining party size\nprint(tips_df.groupby(\"size\").tip_percentage.mean())\n```\n\n----------------------------------------\n\nTITLE: Replacing Values with replace in cudf in Python\nDESCRIPTION: Illustrates various ways to replace values using the `replace()` function for cudf Series and DataFrames. Demonstrates simple value replacement, replacement of lists, and use of a mapping dictionary for targeted value changes.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/missing-data.ipynb#2025-04-21_snippet_14\n\nLANGUAGE: Python\nCODE:\n```\nseries = cudf.Series([0.0, 1.0, 2.0, 3.0, 4.0])\n```\n\nLANGUAGE: Python\nCODE:\n```\nseries.replace(0, 5)\n```\n\nLANGUAGE: Python\nCODE:\n```\nseries.replace(0, None)\n```\n\nLANGUAGE: Python\nCODE:\n```\nseries.replace([0, 1, 2, 3, 4], [4, 3, 2, 1, 0])\n```\n\nLANGUAGE: Python\nCODE:\n```\nseries.replace({0: 10, 1: 100})\n```\n\nLANGUAGE: Python\nCODE:\n```\ndf = cudf.DataFrame({\"a\": [0, 1, 2, 3, 4], \"b\": [5, 6, 7, 8, 9]})\n```\n\nLANGUAGE: Python\nCODE:\n```\ndf.replace({\"a\": 0, \"b\": 5}, 100)\n```\n\n----------------------------------------\n\nTITLE: Calculating Statistics for cuDF Series\nDESCRIPTION: Calculates the mean and variance of a `cudf.Series`. This demonstrates basic statistical operations on a GPU Series.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_33\n\nLANGUAGE: python\nCODE:\n```\ns.mean(), s.var()\n```\n\n----------------------------------------\n\nTITLE: Using cuDF as a pandas accelerator in Python\nDESCRIPTION: This example shows how to use cuDF as a no-code-change accelerator for pandas, enabling GPU acceleration for supported operations while maintaining pandas API compatibility.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/README.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n%load_ext cudf.pandas  # pandas operations now use the GPU!\n\nimport pandas as pd\n\ntips_df = pd.read_csv(\"https://github.com/plotly/datasets/raw/master/tips.csv\")\ntips_df[\"tip_percentage\"] = tips_df[\"tip\"] / tips_df[\"total_bill\"] * 100\n\n# display average tip by dining party size\nprint(tips_df.groupby(\"size\").tip_percentage.mean())\n```\n\n----------------------------------------\n\nTITLE: Transposing a cuDF DataFrame\nDESCRIPTION: Demonstrates how to transpose a cuDF DataFrame, switching rows and columns.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_55\n\nLANGUAGE: python\nCODE:\n```\nsample.transpose()\n```\n\n----------------------------------------\n\nTITLE: Accessing String Methods in cuDF Series\nDESCRIPTION: Demonstrates how to use string methods on a cuDF Series by accessing the .str namespace. Allows applying various string manipulation and analysis functions directly on series of string data.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/api_docs/string_handling.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nSeries.str.<function/property>\n```\n\n----------------------------------------\n\nTITLE: String Operations in cuDF and Dask cuDF\nDESCRIPTION: Shows string processing methods available in the str attribute of Series for both cuDF and Dask cuDF. Examples include converting to lowercase and matching strings using regular expressions.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ns = cudf.Series([\"A\", \"B\", \"C\", \"Aaba\", \"Baca\", None, \"CABA\", \"dog\", \"cat\"])\ns.str.lower()\n```\n\nLANGUAGE: python\nCODE:\n```\nds = dask_cudf.from_cudf(s, npartitions=2)\nds.str.lower().head(n=4)\n```\n\nLANGUAGE: python\nCODE:\n```\ns.str.match(\"^[aAc].+\")\n```\n\nLANGUAGE: python\nCODE:\n```\nds.str.match(\"^[aAc].+\").head()\n```\n\n----------------------------------------\n\nTITLE: Basic Grouping and Summation with Dask-cuDF\nDESCRIPTION: Shows how to perform the same groupby-sum operation with a Dask-cuDF DataFrame, using compute() to execute the operation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_49\n\nLANGUAGE: python\nCODE:\n```\nddf.groupby(\"agg_col1\").sum().compute()\n```\n\n----------------------------------------\n\nTITLE: Using cuDF Pandas Accelerator Mode\nDESCRIPTION: Demonstrates how to enable and use cuDF's pandas accelerator mode. The code loads the cudf.pandas extension, imports pandas, and shows various operations that will be automatically accelerated on the GPU or fallback to CPU as needed.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/index.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%load_ext cudf.pandas\n# pandas API is now GPU accelerated\n\nimport pandas as pd\n\ndf = pd.read_csv(\"filepath\")  # uses the GPU!\ndf.groupby(\"col\").mean()  # uses the GPU!\ndf.rolling(window=3).sum()  # uses the GPU!\ndf.apply(set, axis=1)  # uses the CPU (fallback)\n```\n\n----------------------------------------\n\nTITLE: Column-specific Aggregation with cuDF\nDESCRIPTION: Applies different aggregation functions to specific columns after grouping. Uses the agg method to compute maximum for column 'a', mean for column 'b', and sum for column 'c'.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_23\n\nLANGUAGE: python\nCODE:\n```\ndf.groupby(\"agg_col1\").agg({\"a\": \"max\", \"b\": \"mean\", \"c\": \"sum\"})\n```\n\n----------------------------------------\n\nTITLE: Querying cuDF DataFrame\nDESCRIPTION: Selects rows from a `cudf.DataFrame` where the value in column 'b' is equal to 3, using the `query` method. This provides an alternative way to filter rows based on a condition.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_21\n\nLANGUAGE: python\nCODE:\n```\ndf.query(\"b == 3\")\n```\n\n----------------------------------------\n\nTITLE: Boolean Indexing in cuDF DataFrame\nDESCRIPTION: Selects rows from a `cudf.DataFrame` where the values in column 'b' are greater than 15. This demonstrates how to filter rows based on a boolean condition.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_19\n\nLANGUAGE: python\nCODE:\n```\ndf[df.b > 15]\n```\n\n----------------------------------------\n\nTITLE: GroupBy UDAF Implementation\nDESCRIPTION: User Defined Aggregation Function for grouped data operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_21\n\nLANGUAGE: python\nCODE:\n```\ndef udaf(df):\n    return df[\"b\"].max() - df[\"b\"].min() / 2\n```\n\n----------------------------------------\n\nTITLE: Calculating Statistics for Dask cuDF Series\nDESCRIPTION: Calculates the mean and variance of a `dask_cudf.Series` using `compute()`. The `compute()` method is called to materialize the result, as Dask cuDF operations are lazily evaluated.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nds.mean().compute(), ds.var().compute()\n```\n\n----------------------------------------\n\nTITLE: Boolean Indexing in cuDF and Dask cuDF\nDESCRIPTION: Shows how to filter DataFrames using boolean conditions in both cuDF and Dask cuDF. Examples include direct boolean indexing and using the query API with different comparison operators.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndf[df.b > 15]\n```\n\nLANGUAGE: python\nCODE:\n```\nddf[ddf.b > 15].head(n=3)\n```\n\nLANGUAGE: python\nCODE:\n```\ndf.query(\"b == 3\")\n```\n\nLANGUAGE: python\nCODE:\n```\nddf.query(\"b == 3\").compute()\n```\n\nLANGUAGE: python\nCODE:\n```\ncudf_comparator = 3\ndf.query(\"b == @cudf_comparator\")\n```\n\nLANGUAGE: python\nCODE:\n```\ndask_cudf_comparator = 3\nddf.query(\"b == @val\", local_dict={\"val\": dask_cudf_comparator}).compute()\n```\n\nLANGUAGE: python\nCODE:\n```\ndf[df.a.isin([0, 5])]\n```\n\n----------------------------------------\n\nTITLE: Basic GPU Collection with Polars\nDESCRIPTION: Demonstrates basic usage of cudf-polars by scanning a Parquet file and filtering data using GPU acceleration.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_polars/usage.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport polars as pl\n\nq = pl.scan_parquet(\"ny-taxi/2024/*.parquet\").filter(pl.col(\"total_amount\") > 15.0)\nresult = q.collect(engine=\"gpu\")\n```\n\n----------------------------------------\n\nTITLE: Enabling Memory Profiling in cuDF using Python\nDESCRIPTION: This snippet demonstrates how to enable memory profiling in cuDF by activating RMM statistics and setting the cuDF memory profiling option. It also includes an example of creating a DataFrame to simulate workload and print the memory report.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/memory-profiling.md#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n>>> import cudf\n>>> from cudf.utils.performance_tracking import print_memory_report\n>>> from rmm.statistics import enable_statistics\n>>> enable_statistics()\n>>> cudf.set_option(\"memory_profiling\", True)\n>>> cudf.DataFrame({\"a\": [1, 2, 3]})  # Some work\n   a\n0  1\n1  2\n2  3\n>>> print_memory_report()  # Pretty print the result of the profiling\n```\n\n----------------------------------------\n\nTITLE: Enabling cudf.pandas in Jupyter/IPython with basic usage examples\nDESCRIPTION: Shows how to load the cudf.pandas extension in a Jupyter notebook or IPython session and use it with common pandas operations. Operations will automatically use the GPU where possible, with fallback to CPU for unsupported operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/usage.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%load_ext cudf.pandas\n\nimport pandas as pd\n\nURL = \"https://github.com/plotly/datasets/raw/master/tips.csv\"\ndf = pd.read_csv(URL)                 # uses the GPU\ndf[\"size\"].value_counts()             # uses the GPU\ndf.groupby(\"size\").total_bill.mean()  # uses the GPU\ndf.apply(list, axis=1)                # uses the CPU (fallback)\n```\n\n----------------------------------------\n\nTITLE: Setting Up a Local CUDA Cluster for Dask\nDESCRIPTION: Creates a local CUDA cluster and Dask client for distributed GPU computation. The LocalCUDACluster creates one dask-worker per GPU on the local machine.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_53\n\nLANGUAGE: python\nCODE:\n```\nimport time\n\nfrom dask.distributed import Client, wait\nfrom dask_cuda import LocalCUDACluster\n\ncluster = LocalCUDACluster()\nclient = Client(cluster)\n```\n\n----------------------------------------\n\nTITLE: Querying cuDF DataFrame with Local Variable\nDESCRIPTION: Queries a `cudf.DataFrame` using a local variable passed to the `query` method. The `@` symbol is used to reference the local variable within the query string.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_23\n\nLANGUAGE: python\nCODE:\n```\ncudf_comparator = 3\ndf.query(\"b == @cudf_comparator\")\n```\n\n----------------------------------------\n\nTITLE: Converting Dask-cuDF Series to NumPy Array\nDESCRIPTION: Demonstrates computing a Dask-cuDF Series and converting it to a NumPy ndarray.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_69\n\nLANGUAGE: python\nCODE:\n```\nddf[\"a\"].compute().to_numpy()\n```\n\n----------------------------------------\n\nTITLE: Applying Scalar Function to cuDF Series\nDESCRIPTION: Shows how to apply the defined scalar function using the apply method of cuDF Series, returning a new Series object with incremented values.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nsr.apply(f)\n```\n\n----------------------------------------\n\nTITLE: Creating and Transforming a Dask-cuDF DataFrame\nDESCRIPTION: Creates a large cuDF DataFrame, converts it to a Dask-cuDF DataFrame with 16 partitions, and adds a new column with a simple transformation. The operation is lazy and not executed immediately.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_54\n\nLANGUAGE: python\nCODE:\n```\nnrows = 10000000\n\ndf2 = cudf.DataFrame({\"a\": cp.arange(nrows), \"b\": cp.arange(nrows)})\nddf2 = dask_cudf.from_cudf(df2, npartitions=16)\nddf2[\"c\"] = ddf2[\"a\"] + 5\nddf2\n```\n\n----------------------------------------\n\nTITLE: Creating Categorical Data with cuDF\nDESCRIPTION: Creates a DataFrame with a categorical column. Demonstrates how to convert a string column to a categorical data type, which can be more memory-efficient and faster for operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_29\n\nLANGUAGE: python\nCODE:\n```\ngdf = cudf.DataFrame(\n    {\"id\": [1, 2, 3, 4, 5, 6], \"grade\": [\"a\", \"b\", \"b\", \"a\", \"a\", \"e\"]}\n)\ngdf[\"grade\"] = gdf[\"grade\"].astype(\"category\")\ngdf\n```\n\n----------------------------------------\n\nTITLE: Column-Specific Aggregation with Dask-cuDF\nDESCRIPTION: Shows how to apply different aggregation functions to specific columns in a Dask-cuDF DataFrame.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_53\n\nLANGUAGE: python\nCODE:\n```\nddf.groupby(\"agg_col1\").agg({\"a\": \"max\", \"b\": \"mean\", \"c\": \"sum\"}).compute()\n```\n\n----------------------------------------\n\nTITLE: Configuring Dask Backend to Use cuDF\nDESCRIPTION: This Python code snippet demonstrates how to set the Dask DataFrame backend to use the cuDF library. The `dask.config.set` method is used to change the default backend for DataFrame operations to cuDF, enabling GPU acceleration capabilities inherent to cuDF. It requires the Dask and cuDF libraries to be installed. No input parameters are required, and no output is produced other than the configuration change.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/dask_cudf/source/api.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n   >>> import dask\n   >>> dask.config.set({\"dataframe.backend\": \"cudf\"})\n```\n\n----------------------------------------\n\nTITLE: Converting CuPy Array to cuDF DataFrame\nDESCRIPTION: Demonstrates converting a CuPy array to a cuDF DataFrame using the DataFrame constructor and displays the first few rows of the result.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/cupy-interop.ipynb#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nreshaped_df = cudf.DataFrame(reshaped_arr)\nreshaped_df.head()\n```\n\n----------------------------------------\n\nTITLE: Concatenating cuDF and Dask cuDF Objects\nDESCRIPTION: Demonstrates how to concatenate Series objects row-wise using the concat function in both cuDF and Dask cuDF. This operation is useful for combining multiple datasets.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ns = cudf.Series([1, 2, 3, None, 5])\ncudf.concat([s, s])\n```\n\nLANGUAGE: python\nCODE:\n```\nds2 = dask_cudf.from_cudf(s, npartitions=2)\ndask_cudf.concat([ds2, ds2]).head(n=3)\n```\n\n----------------------------------------\n\nTITLE: Converting cuDF DataFrame to CuPy Array using dlpack\nDESCRIPTION: Demonstrates converting a cuDF DataFrame to a CuPy array using the dlpack interface and displays the resulting array.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/cupy-interop.ipynb#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\narr_cupy = cupy_from_dlpack(df.to_dlpack())\narr_cupy\n```\n\n----------------------------------------\n\nTITLE: Creating cuDF and Dask cuDF DataFrame Objects\nDESCRIPTION: Shows how to create a cuDF DataFrame by specifying column values and convert it to a Dask cuDF DataFrame with multiple partitions. The example uses simple range values to populate the DataFrame.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndf = cudf.DataFrame(\n    {\n        \"a\": list(range(20)),\n        \"b\": list(reversed(range(20))),\n        \"c\": list(range(20)),\n    }\n)\ndf\n```\n\nLANGUAGE: python\nCODE:\n```\nddf = dask_cudf.from_cudf(df, npartitions=2)\nddf.head()\n```\n\n----------------------------------------\n\nTITLE: Converting cuDF DataFrame to CuPy Array using dlpack\nDESCRIPTION: This snippet demonstrates how to convert a cuDF DataFrame to a CuPy array using the dlpack interface.  It first creates a cuDF DataFrame with three columns, then it times the conversion using dlpack.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/cupy-interop.ipynb#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnelem = 10000\ndf = cudf.DataFrame(\n    {\n        \"a\": range(nelem),\n        \"b\": range(500, nelem + 500),\n        \"c\": range(1000, nelem + 1000),\n    }\n)\n\n%timeit arr_cupy = cupy_from_dlpack(df.to_dlpack())\n%timeit arr_cupy = df.values\n%timeit arr_cupy = df.to_cupy()\n```\n\n----------------------------------------\n\nTITLE: Setting Up Dask CUDA Cluster for Multi-GPU Processing\nDESCRIPTION: Demonstrates how to create a local CUDA cluster with Dask for distributing work across multiple GPUs.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_82\n\nLANGUAGE: python\nCODE:\n```\nimport time\n\nfrom dask.distributed import Client, wait\nfrom dask_cuda import LocalCUDACluster\n\ncluster = LocalCUDACluster()\nclient = Client(cluster)\n```\n\n----------------------------------------\n\nTITLE: Selecting Rows by Label in cuDF DataFrame\nDESCRIPTION: Selects rows from index 2 to index 5 (inclusive) and columns 'a' and 'b' from a `cudf.DataFrame` using label-based indexing.  This demonstrates how to select a subset of rows and columns using `.loc`.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndf.loc[2:5, [\"a\", \"b\"]]\n```\n\n----------------------------------------\n\nTITLE: Converting cuDF DataFrame to NumPy Array\nDESCRIPTION: Shows how to convert a cuDF DataFrame to a NumPy ndarray for compatibility with NumPy operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_66\n\nLANGUAGE: python\nCODE:\n```\ndf.to_numpy()\n```\n\n----------------------------------------\n\nTITLE: Converting Dask-cuDF DataFrame to PyArrow Table\nDESCRIPTION: Demonstrates converting a sample of a Dask-cuDF DataFrame to a PyArrow Table.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_71\n\nLANGUAGE: python\nCODE:\n```\nddf.head().to_arrow()\n```\n\n----------------------------------------\n\nTITLE: Grouping by Index Levels in cuDF\nDESCRIPTION: This code demonstrates how to group a cuDF DataFrame by index levels using the `groupby` method.  The `level` parameter specifies the level(s) of the MultiIndex to group by. This allows grouping based on hierarchical index structures.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/groupby.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> df = cudf.DataFrame(\n...     {'a': [1, 1, 1, 2, 2], 'b': [1, 1, 2, 2, 3], 'c': [1, 2, 3, 4, 5]}\n... ).set_index(['a', 'b'])\n...\n>>> df.groupby(level='a')\n```\n\n----------------------------------------\n\nTITLE: Applying Function to cuDF Series\nDESCRIPTION: Defines a function `add_ten` and applies it to the 'a' column of a `cudf.DataFrame` using the `apply` method. This demonstrates how to apply a custom function to a GPU Series.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_35\n\nLANGUAGE: python\nCODE:\n```\ndef add_ten(num):\n    return num + 10\n\n\ndf[\"a\"].apply(add_ten)\n```\n\n----------------------------------------\n\nTITLE: Creating a cuDF Series\nDESCRIPTION: Creates a `cudf.Series` object containing integer values, including a null value. This demonstrates basic Series creation using the cuDF library, similar to pandas Series.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ns = cudf.Series([1, 2, 3, None, 4])\ns\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Data in cudf Series with Python\nDESCRIPTION: This snippet reveals how cudf Series can handle missing values using `None` and `np.nan`. It covers the option of treating `np.nan` as `<NA>` through the `nan_as_null` parameter and demonstrates equality checks which behave differently based on this option.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/missing-data.ipynb#2025-04-21_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ns = cudf.Series([None, 1, 2])\n```\n\nLANGUAGE: Python\nCODE:\n```\ns == None\n```\n\nLANGUAGE: Python\nCODE:\n```\ns = cudf.Series([1, 2, np.nan], nan_as_null=False)\n```\n\nLANGUAGE: Python\nCODE:\n```\ns == np.nan\n```\n\n----------------------------------------\n\nTITLE: Setting Up Multi-GPU Dask Cluster\nDESCRIPTION: Demonstrates how to set up a local CUDA cluster for multi-GPU processing with Dask cuDF.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/dask_cudf/source/index.rst#2025-04-21_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nfrom dask_cuda import LocalCUDACluster\nfrom distributed import Client\n\nif __name__ == \"__main__\":\n\n    client = Client(\n      LocalCUDACluster(\n        CUDA_VISIBLE_DEVICES=\"0,1\",  # Use two workers (on devices 0 and 1)\n        rmm_pool_size=0.9,  # Use 90% of GPU memory as a pool for faster allocations\n        enable_cudf_spill=True,  # Improve device memory stability\n        local_directory=\"/fast/scratch/\",  # Use fast local storage for spilling\n      )\n    )\n\n    df = dd.read_parquet(\"/my/parquet/dataset/\")\n    agg = df.groupby('B').sum()\n    agg.compute()  # This will use the cluster defined above\n```\n\n----------------------------------------\n\nTITLE: Installing cuDF with Conda\nDESCRIPTION: Command to install cuDF using conda from the rapidsai channel, specifying the cuDF version, Python version, and CUDA version.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/libcudf/README.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nconda install -c rapidsai -c conda-forge -c nvidia \\\n    cudf=25.06 python=3.12 cuda-version=12.8\n```\n\n----------------------------------------\n\nTITLE: Working with MultiIndex in cuDF\nDESCRIPTION: Demonstrates how to create and use hierarchical indexing with MultiIndex in cuDF. Shows creation from tuples and using MultiIndex for both rows and columns of a DataFrame.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\narrays = [[\"a\", \"a\", \"b\", \"b\"], [1, 2, 3, 4]]\ntuples = list(zip(*arrays))\nidx = cudf.MultiIndex.from_tuples(tuples)\nidx\n```\n\nLANGUAGE: python\nCODE:\n```\ngdf1 = cudf.DataFrame(\n    {\"first\": cp.random.rand(4), \"second\": cp.random.rand(4)}\n)\ngdf1.index = idx\ngdf1\n```\n\nLANGUAGE: python\nCODE:\n```\ngdf2 = cudf.DataFrame(\n    {\"first\": cp.random.rand(4), \"second\": cp.random.rand(4)}\n).T\ngdf2.columns = idx\ngdf2\n```\n\nLANGUAGE: python\nCODE:\n```\ngdf1.loc[(\"b\", 3)]\n```\n\nLANGUAGE: python\nCODE:\n```\ngdf1.iloc[0:2]\n```\n\n----------------------------------------\n\nTITLE: Querying Dask cuDF DataFrame with Local Dictionary\nDESCRIPTION: Queries a `dask_cudf.DataFrame` using a local variable passed to the `query` method via the `local_dict` keyword argument.  The result is computed by calling `compute()`.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_24\n\nLANGUAGE: python\nCODE:\n```\ndask_cudf_comparator = 3\nddf.query(\"b == @val\", local_dict={\"val\": dask_cudf_comparator}).compute()\n```\n\n----------------------------------------\n\nTITLE: Converting Pandas DataFrames to cuDF and Dask cuDF\nDESCRIPTION: Demonstrates how to convert a Pandas DataFrame to a cuDF DataFrame, and then to a Dask cuDF DataFrame. This shows interoperability between CPU and GPU DataFrame libraries.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npdf = pd.DataFrame({\"a\": [0, 1, 2, 3], \"b\": [0.1, 0.2, None, 0.3]})\ngdf = cudf.DataFrame.from_pandas(pdf)\ngdf\n```\n\nLANGUAGE: python\nCODE:\n```\ndask_gdf = dask_cudf.from_cudf(gdf, npartitions=2)\ndask_gdf.head(n=2)\n```\n\n----------------------------------------\n\nTITLE: Writing cuDF DataFrame to CSV\nDESCRIPTION: Creates an output directory if it doesn't exist and writes a cuDF DataFrame to a CSV file without including the index. Uses GPU acceleration for the write operation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_43\n\nLANGUAGE: python\nCODE:\n```\nif not os.path.exists(\"example_output\"):\n    os.mkdir(\"example_output\")\n\ndf.to_csv(\"example_output/foo.csv\", index=False)\n```\n\n----------------------------------------\n\nTITLE: Converting cuDF Series to CuPy Array with Performance Benchmarks\nDESCRIPTION: Benchmarks three methods for converting a cuDF Series to a CuPy array: using cupy.asarray with CUDA array interface, using dlpack, and using Series.values.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/cupy-interop.ipynb#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncol = \"a\"\n\n%timeit cola_cupy = cp.asarray(df[col])\n%timeit cola_cupy = cupy_from_dlpack(df[col].to_dlpack())\n%timeit cola_cupy = df[col].values\n```\n\n----------------------------------------\n\nTITLE: Writing cuDF DataFrame to Parquet\nDESCRIPTION: Demonstrates writing a cuDF DataFrame to a Parquet file using the GPU-accelerated Parquet writer, which preserves column type information and enables efficient storage.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_48\n\nLANGUAGE: python\nCODE:\n```\ndf.to_parquet(\"example_output/temp_parquet\")\n```\n\n----------------------------------------\n\nTITLE: Filling Null Values with fillna in cudf in Python\nDESCRIPTION: Discusses filling NA values in a DataFrame column with cudf using `fillna()`. Replaces nulls in column 'b' with a specific value, demonstrating effective missing data handling with cudf.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/missing-data.ipynb#2025-04-21_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\ndf1[\"b\"].fillna(10)\n```\n\n----------------------------------------\n\nTITLE: Selecting Rows by Position in cuDF\nDESCRIPTION: Demonstrates integer-based indexing in cuDF using iloc. This shows both single row selection and slicing for both rows and columns. Note that this functionality is not available for Dask cuDF.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndf.iloc[0]\n```\n\nLANGUAGE: python\nCODE:\n```\ndf.iloc[0:3, 0:2]\n```\n\nLANGUAGE: python\nCODE:\n```\ndf[3:5]\n```\n\nLANGUAGE: python\nCODE:\n```\ns[3:5]\n```\n\n----------------------------------------\n\nTITLE: Applying Function to Dask cuDF Series using map_partitions\nDESCRIPTION: Defines a function `add_ten` and applies it to the 'a' column of a `dask_cudf.DataFrame` using the `map_partitions` method, followed by calling `head()` to view the first few results. This demonstrates how to apply a function to each partition of a distributed DataFrame.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_36\n\nLANGUAGE: python\nCODE:\n```\ndef add_ten(num):\n    return num + 10\n\n\nddf[\"a\"].map_partitions(add_ten).head()\n```\n\n----------------------------------------\n\nTITLE: Reading ORC Files with cuDF\nDESCRIPTION: Demonstrates reading an ORC file into a cuDF DataFrame using the read_orc function, which loads data directly into GPU memory.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_52\n\nLANGUAGE: python\nCODE:\n```\ndf2 = cudf.read_orc(\"example_output/temp_orc\")\ndf2\n```\n\n----------------------------------------\n\nTITLE: Writing cuDF DataFrame to CSV\nDESCRIPTION: Shows how to write a cuDF DataFrame to a CSV file on disk.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_72\n\nLANGUAGE: python\nCODE:\n```\nif not os.path.exists(\"example_output\"):\n    os.mkdir(\"example_output\")\n\ndf.to_csv(\"example_output/foo.csv\", index=False)\n```\n\n----------------------------------------\n\nTITLE: Filling Missing Data in cuDF Series\nDESCRIPTION: Fills missing values (None) in a `cudf.Series` with the value 999 using the `fillna` method. This shows how to handle missing data in cuDF Series.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_31\n\nLANGUAGE: python\nCODE:\n```\ns.fillna(999)\n```\n\n----------------------------------------\n\nTITLE: Writing cuDF DataFrame to ORC Format\nDESCRIPTION: Shows how to write a cuDF DataFrame to an ORC (Optimized Row Columnar) file, a columnar storage format that provides efficient compression and performance.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_51\n\nLANGUAGE: python\nCODE:\n```\ndf.to_orc(\"example_output/temp_orc\")\n```\n\n----------------------------------------\n\nTITLE: Aggregation using GroupBy in cuDF\nDESCRIPTION: This snippet demonstrates how to perform aggregations on groups in cuDF using the `agg` method. It showcases different ways to specify aggregations: applying the same aggregation to all columns, applying different aggregations to different columns, and using a dictionary to specify multiple aggregations for specific columns.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/groupby.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> df\n   a  b  c\n0  1  1  1\n1  1  1  2\n2  1  2  3\n3  2  2  4\n4  2  3  5\n>>> df.groupby('a').agg('sum')\n   b  c\na\n1  4  6\n2  5  9\n>>> df.groupby('a').agg({'b': ['sum', 'min'], 'c': 'mean'})\n    b        c\n  sum min mean\na\n1   4   1  2.0\n2   5   2  4.5\n>>> df.groupby(\"a\").corr(method=\"pearson\")\n          b          c\na\n1 b  1.000000  0.866025\n  c  0.866025  1.000000\n2 b  1.000000  1.000000\n  c  1.000000  1.000000\n```\n\n----------------------------------------\n\nTITLE: Selecting Columns in cuDF and Dask cuDF\nDESCRIPTION: Demonstrates how to select a single column from both cuDF and Dask cuDF DataFrames, which returns a Series object. Shows the difference in output display between the two libraries.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndf[\"a\"]\n```\n\nLANGUAGE: python\nCODE:\n```\nddf[\"a\"].head()\n```\n\n----------------------------------------\n\nTITLE: Selecting Rows and Columns by Position in cuDF DataFrame\nDESCRIPTION: Selects rows from index 0 up to (but not including) 3, and columns from index 0 up to (but not including) 2 from a `cudf.DataFrame` using position-based indexing. This is similar to selecting a slice of rows and columns in pandas using `.iloc`.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndf.iloc[0:3, 0:2]\n```\n\n----------------------------------------\n\nTITLE: Basic Grouping and Summation with cuDF\nDESCRIPTION: Demonstrates how to group a cuDF DataFrame by a single column and apply the sum function to all other columns.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_48\n\nLANGUAGE: python\nCODE:\n```\ndf.groupby(\"agg_col1\").sum()\n```\n\n----------------------------------------\n\nTITLE: String Methods in cuDF Series\nDESCRIPTION: Creates a `cudf.Series` of strings and converts them to lowercase using the `str.lower()` method. This demonstrates string manipulation in cuDF, similar to pandas.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_39\n\nLANGUAGE: python\nCODE:\n```\ns = cudf.Series([\"A\", \"B\", \"C\", \"Aaba\", \"Baca\", None, \"CABA\", \"dog\", \"cat\"])\ns.str.lower()\n```\n\n----------------------------------------\n\nTITLE: Viewing Data in cuDF and Dask cuDF DataFrames\nDESCRIPTION: Shows how to preview data using head() and sort DataFrames by values in both cuDF and Dask cuDF. These operations demonstrate the similarity in API between the two libraries.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndf.head(2)\n```\n\nLANGUAGE: python\nCODE:\n```\nddf.head(2)\n```\n\nLANGUAGE: python\nCODE:\n```\ndf.sort_values(by=\"b\")\n```\n\nLANGUAGE: python\nCODE:\n```\nddf.sort_values(by=\"b\").head()\n```\n\n----------------------------------------\n\nTITLE: Reading Parquet Data with Different Backends\nDESCRIPTION: Demonstrates how to read Parquet data using both default pandas backend and cuDF backend after configuration.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/dask_cudf/source/index.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nimport dask.dataframe as dd\n\n# By default, we obtain a pandas-backed dataframe\ndf = dd.read_parquet(\"data.parquet\", ...)\n\nimport dask\n\ndask.config.set({\"dataframe.backend\": \"cudf\"})\n# This now gives us a cuDF-backed dataframe\ndf = dd.read_parquet(\"data.parquet\", ...)\n```\n\n----------------------------------------\n\nTITLE: Writing Dask-cuDF DataFrame to Parquet\nDESCRIPTION: Demonstrates how to write a Dask-cuDF DataFrame to Parquet files for distributed storage.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_79\n\nLANGUAGE: python\nCODE:\n```\nddf.to_parquet(\"example_output/ddf_parquet_files\")\n```\n\n----------------------------------------\n\nTITLE: Writing cuDF DataFrame to ORC Format\nDESCRIPTION: Shows how to write a cuDF DataFrame to an ORC file, a columnar storage format.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_80\n\nLANGUAGE: python\nCODE:\n```\ndf.to_orc(\"example_output/temp_orc\")\n```\n\n----------------------------------------\n\nTITLE: Using transform Method with GroupBy in cuDF\nDESCRIPTION: Demonstrates how to use the transform method to perform group-wise aggregation and broadcast results. The example shows grouping by column 'a' and applying the 'max' aggregation to column 'b', resulting in a DataFrame with the same size as the input but with values replaced by the maximum of their respective groups.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/groupby.md#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> import cudf\n>>> df = cudf.DataFrame({'a': [2, 1, 1, 2, 2], 'b': [1, 2, 3, 4, 5]})\n>>> df.groupby('a').transform('max')\n   b\n0  5\n1  3\n2  3\n3  5\n4  5\n```\n\n----------------------------------------\n\nTITLE: Converting to Dask-cuDF with Categorical Data\nDESCRIPTION: Demonstrates how to convert a cuDF DataFrame with categorical columns to a Dask-cuDF DataFrame.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_59\n\nLANGUAGE: python\nCODE:\n```\ndgdf = dask_cudf.from_cudf(gdf, npartitions=2)\ndgdf.head(n=3)\n```\n\n----------------------------------------\n\nTITLE: Merging Dask-cuDF DataFrames\nDESCRIPTION: Shows how to convert cuDF DataFrames to Dask-cuDF DataFrames and perform a distributed left join operation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nddf_a = dask_cudf.from_cudf(df_a, npartitions=2)\nddf_b = dask_cudf.from_cudf(df_b, npartitions=2)\n\nmerged = ddf_a.merge(ddf_b, on=[\"key\"], how=\"left\").head(n=4)\nmerged\n```\n\n----------------------------------------\n\nTITLE: Time Series Operations with cuDF\nDESCRIPTION: Creates a DataFrame with date values and demonstrates filtering based on date comparison. Uses the query method with a variable passed via the @ syntax to filter rows with dates less than or equal to a specific date.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nimport datetime as dt\n\ndate_df = cudf.DataFrame()\ndate_df[\"date\"] = pd.date_range(\"11/20/2018\", periods=72, freq=\"D\")\ndate_df[\"value\"] = cp.random.sample(len(date_df))\n\nsearch_date = dt.datetime.strptime(\"2018-11-23\", \"%Y-%m-%d\")\ndate_df.query(\"date <= @search_date\")\n```\n\n----------------------------------------\n\nTITLE: Writing cuDF DataFrame to Parquet\nDESCRIPTION: Demonstrates how to write a cuDF DataFrame to a Parquet file using GPU acceleration.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_77\n\nLANGUAGE: python\nCODE:\n```\ndf.to_parquet(\"example_output/temp_parquet\")\n```\n\n----------------------------------------\n\nTITLE: Writing Dask-cuDF DataFrame to Parquet\nDESCRIPTION: Demonstrates writing a Dask-cuDF DataFrame to Parquet files, which creates multiple partition files in a directory. Uses cuDF's Parquet writer underneath for GPU acceleration.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_50\n\nLANGUAGE: python\nCODE:\n```\nddf.to_parquet(\"example_output/ddf_parquet_files\")\n```\n\n----------------------------------------\n\nTITLE: Filling Missing Data in Dask cuDF Series\nDESCRIPTION: Fills missing values (None) in a `dask_cudf.Series` with the value 999 using the `fillna` method and displays the first 3 rows using `head()`. This shows how to handle missing data in Dask cuDF Series.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nds.fillna(999).head(n=3)\n```\n\n----------------------------------------\n\nTITLE: Installing cuDF with Pip for CUDA 11.x\nDESCRIPTION: Command to install cuDF for CUDA 11.x environments using pip with NVIDIA's Python Package Index.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/libcudf/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install --extra-index-url=https://pypi.nvidia.com cudf-cu11\n```\n\n----------------------------------------\n\nTITLE: Matching Strings with Regular Expressions in cuDF Series\nDESCRIPTION: Matches strings in a `cudf.Series` against a regular expression using the `str.match()` method. This demonstrates regular expression matching in cuDF.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_41\n\nLANGUAGE: python\nCODE:\n```\ns.str.match(\"^[aAc].+\")\n```\n\n----------------------------------------\n\nTITLE: Filtering cuDF DataFrame with isin\nDESCRIPTION: Selects rows from a `cudf.DataFrame` where the values in column 'a' are present in the list [0, 5] using the `isin` method. This provides a way to filter rows based on multiple possible values.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_25\n\nLANGUAGE: python\nCODE:\n```\ndf[df.a.isin([0, 5])]\n```\n\n----------------------------------------\n\nTITLE: Accessing cuDF DataFrame with MultiIndex using .loc\nDESCRIPTION: Accesses a specific element of a `cudf.DataFrame` with a `cudf.MultiIndex` using `.loc`.  This demonstrates how to select data based on MultiIndex labels.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_29\n\nLANGUAGE: python\nCODE:\n```\ngdf1.loc[(\"b\", 3)]\n```\n\n----------------------------------------\n\nTITLE: Selecting Rows by Position in cuDF DataFrame\nDESCRIPTION: Selects the row at index 0 from a `cudf.DataFrame` using position-based indexing. This is similar to selecting a row in pandas using `.iloc`.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndf.iloc[0]\n```\n\n----------------------------------------\n\nTITLE: Reading Data from Parquet using libcudf\nDESCRIPTION: This code snippet demonstrates how to read parquet data using the C++ libcudf library, leveraging the GPU for performance. It similarly creates a source info object and builder for the parquet reader options, followed by calling the read function to load the data into a table.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/index.rst#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <cudf/io/parquet.hpp>\n\nint main()\n{\n   auto source  = cudf::io::source_info(\"dataset.parquet\");\n   auto options = cudf::io::parquet_reader_options::builder(source).build();\n   auto table  = cudf::io::read_parquet(options);\n}\n```\n\n----------------------------------------\n\nTITLE: Column-Specific Aggregation with cuDF\nDESCRIPTION: Demonstrates using the agg method to apply different aggregation functions to specific columns after grouping.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_52\n\nLANGUAGE: python\nCODE:\n```\ndf.groupby(\"agg_col1\").agg({\"a\": \"max\", \"b\": \"mean\", \"c\": \"sum\"})\n```\n\n----------------------------------------\n\nTITLE: Initializing DataFrame with cudf in Python\nDESCRIPTION: This snippet demonstrates how to initialize a DataFrame in cudf with missing values represented as `None`. The DataFrame is created with two columns containing integer and float data types.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/missing-data.ipynb#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ndf = cudf.DataFrame({\"a\": [1, 2, None, 4], \"b\": [0.1, None, 2.3, 17.17]})\n```\n\n----------------------------------------\n\nTITLE: Converting cuDF Series to NumPy Array\nDESCRIPTION: Shows how to convert a single column (Series) from a cuDF DataFrame to a NumPy ndarray.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_68\n\nLANGUAGE: python\nCODE:\n```\ndf[\"a\"].to_numpy()\n```\n\n----------------------------------------\n\nTITLE: Inserting Null Values in cudf Series in Python\nDESCRIPTION: Demonstrates insertion of null values in a cudf Series by assignment. Specific locations can be set to null using `None`, showcasing the versatility in handling missing data.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/missing-data.ipynb#2025-04-21_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\nseries = cudf.Series([1, 2, 3, 4])\n```\n\nLANGUAGE: Python\nCODE:\n```\nseries[2] = None\n```\n\n----------------------------------------\n\nTITLE: Applying Partition Mapping and Persistence\nDESCRIPTION: Maps the transformation function across DataFrame partitions and persists the results in memory. Uses map_partitions to distribute processing across partitions.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_88\n\nLANGUAGE: python\nCODE:\n```\nresults_ddf = ddf2.map_partitions(func)\nresults_ddf = results_ddf.persist()\n```\n\n----------------------------------------\n\nTITLE: Accessing Categorical Codes in Dask-cuDF\nDESCRIPTION: Shows how to access the underlying integer codes of a categorical column in a Dask-cuDF DataFrame, computing the result to return a cuDF Series.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_33\n\nLANGUAGE: python\nCODE:\n```\ndgdf.grade.cat.codes.compute()\n```\n\n----------------------------------------\n\nTITLE: Selecting a Column in Dask cuDF DataFrame\nDESCRIPTION: Selects a single column ('a') from a `dask_cudf.DataFrame` and displays the first few rows using `head()`.  The column selection is performed in parallel across the Dask cluster.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nddf[\"a\"].head()\n```\n\n----------------------------------------\n\nTITLE: Converting cuDF Series to CuPy Array\nDESCRIPTION: This snippet demonstrates converting a cuDF Series to a CuPy array using `cp.asarray`, dlpack interface, and `Series.values`. It also measures the time taken by each conversion method using the `%timeit` magic command.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/cupy-interop.ipynb#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncol = \"a\"\n\n%timeit cola_cupy = cp.asarray(df[col])\n%timeit cola_cupy = cupy_from_dlpack(df[col].to_dlpack())\n%timeit cola_cupy = df[col].values\n```\n\n----------------------------------------\n\nTITLE: Basic Groupby Sum with Dask-cuDF\nDESCRIPTION: Groups data by the agg_col1 column and applies the sum function to all other columns using Dask-cuDF. Includes .compute() to execute the distributed computation and return a cuDF DataFrame with results.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nddf.groupby(\"agg_col1\").sum().compute()\n```\n\n----------------------------------------\n\nTITLE: Converting cuDF DataFrame to PyArrow Table\nDESCRIPTION: Shows how to convert a cuDF DataFrame to a PyArrow Table for interoperability with Arrow-based systems.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_70\n\nLANGUAGE: python\nCODE:\n```\ndf.to_arrow()\n```\n\n----------------------------------------\n\nTITLE: Creating a Series with Copy-on-Write in cuDF\nDESCRIPTION: This code snippet demonstrates how to create a Series object in cuDF. It sets the framework for understanding copy-on-write behavior by initializing a series of integers.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/copy-on-write.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> series = cudf.Series([1, 2, 3, 4])\n```\n\n----------------------------------------\n\nTITLE: Null-Aware UDF Operation\nDESCRIPTION: UDF showing conditional handling of null values using cudf.NA check and value replacement.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndef f(row):\n    x = row[\"a\"]\n    if x is cudf.NA:\n        return 0\n    else:\n        return x + 1\n```\n\n----------------------------------------\n\nTITLE: Selecting a Column in cuDF DataFrame\nDESCRIPTION: Selects a single column ('a') from a `cudf.DataFrame`, resulting in a `cudf.Series`. This demonstrates how to access a specific column in a GPU DataFrame.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndf[\"a\"]\n```\n\n----------------------------------------\n\nTITLE: Numeric Value Replacement in cudf DataFrame with Python\nDESCRIPTION: Illustrates use of `replace()` in cudf DataFrames to substitute numeric values, similar to `fillna()`. Demonstrates replacing single and multiple values both in-place and retaining the original DataFrame for further operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/missing-data.ipynb#2025-04-21_snippet_16\n\nLANGUAGE: Python\nCODE:\n```\ncp_rng = cp.random.default_rng()\ndf = cudf.DataFrame(cp_rng.standard_normal((10, 2)))\ndf[rng.random(df.shape[0]) > 0.5] = 1.5\ndf.replace(1.5, None)\n```\n\nLANGUAGE: Python\nCODE:\n```\ndf00 = df.iloc[0, 0]\ndf.replace([1.5, df00], [5, 10])\n```\n\nLANGUAGE: Python\nCODE:\n```\ndf.replace(1.5, None, inplace=True)\n```\n\n----------------------------------------\n\nTITLE: Converting Dask-cuDF DataFrame to NumPy Array\nDESCRIPTION: Demonstrates converting a Dask-cuDF DataFrame to a NumPy ndarray by first computing it to a cuDF DataFrame and then converting to NumPy.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nddf.compute().to_numpy()\n```\n\n----------------------------------------\n\nTITLE: Rolling Window Calculations with GroupBy in cuDF\nDESCRIPTION: Demonstrates rolling window calculations on grouped data using GroupBy.rolling(). The example applies a rolling sum with a window size of 2 on each group defined by column 'a'. The first row of each group shows NA values as there's not enough data to compute a window of size 2.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/groupby.md#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> df.groupby('a').rolling(2).sum()\n        a     b     c\na\n1 0  <NA>  <NA>  <NA>\n  1     2     2     3\n  2     2     3     5\n2 3  <NA>  <NA>  <NA>\n  4     4     5     9\n```\n\n----------------------------------------\n\nTITLE: Performing SQL-style Joins with Dask-cuDF\nDESCRIPTION: Demonstrates a distributed left join using Dask-cuDF DataFrames. First converts cuDF DataFrames to Dask-cuDF DataFrames with two partitions, then performs the merge operation and shows the first 4 rows of the result.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nddf_a = dask_cudf.from_cudf(df_a, npartitions=2)\nddf_b = dask_cudf.from_cudf(df_b, npartitions=2)\n\nmerged = ddf_a.merge(ddf_b, on=[\"key\"], how=\"left\").head(n=4)\nmerged\n```\n\n----------------------------------------\n\nTITLE: Basic Row Addition UDF in CUDF DataFrame\nDESCRIPTION: Simple UDF demonstrating column addition using row access pattern with A and B columns.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef f(row):\n    return row[\"A\"] + row[\"B\"]\n```\n\n----------------------------------------\n\nTITLE: Defining a Function to Convert cuDF to CuPy Sparse Matrix\nDESCRIPTION: Creates a helper function that converts a cuDF DataFrame to either a CuPy sparse CSC (column) or CSR (row) matrix, depending on the format specified.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/cupy-interop.ipynb#2025-04-21_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndef cudf_to_cupy_sparse_matrix(data, sparseformat=\"column\"):\n    \"\"\"Converts a cuDF object to a CuPy Sparse Column matrix.\"\"\"\n    if sparseformat not in (\n        \"row\",\n        \"column\",\n    ):\n        raise ValueError(\"Let's focus on column and row formats for now.\")\n\n    _sparse_constructor = cp.sparse.csc_matrix\n    if sparseformat == \"row\":\n        _sparse_constructor = cp.sparse.csr_matrix\n\n    return _sparse_constructor(cupy_from_dlpack(data.to_dlpack()))\n```\n\n----------------------------------------\n\nTITLE: Converting cuDF DataFrame to CuPy Array\nDESCRIPTION: This snippet demonstrates converting a cuDF DataFrame to a CuPy array using the dlpack interface and displays the resulting CuPy array. It relies on the previously defined DataFrame `df`.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/cupy-interop.ipynb#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\narr_cupy = cupy_from_dlpack(df.to_dlpack())\narr_cupy\n```\n\n----------------------------------------\n\nTITLE: Hierarchical Groupby Sum with Dask-cuDF\nDESCRIPTION: Performs hierarchical grouping on a Dask-cuDF DataFrame using two columns and computes the sum of all other columns, returning the results as a cuDF DataFrame via the compute() method.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nddf.groupby([\"agg_col1\", \"agg_col2\"]).sum().compute()\n```\n\n----------------------------------------\n\nTITLE: Converting cuDF DataFrame to PyArrow Table\nDESCRIPTION: Shows how to convert a cuDF DataFrame to a PyArrow Table using the to_arrow() method, which maintains the columnar format for efficient inter-system data transfer.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_41\n\nLANGUAGE: python\nCODE:\n```\ndf.to_arrow()\n```\n\n----------------------------------------\n\nTITLE: Building cuDF from Source\nDESCRIPTION: Commands to build and install the libcudf, cudf, and dask_cudf libraries from source code. The script builds and installs to the conda prefix by default.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/CONTRIBUTING.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd $CUDF_HOME\n\n# Choose one of the following commands, depending on whether\n# you want to build and install the libcudf C++ library only,\n# or include the cudf and/or dask_cudf Python libraries:\n\n./build.sh  # libcudf, cudf and dask_cudf\n./build.sh libcudf  # libcudf only\n./build.sh libcudf cudf  # libcudf and cudf only\n```\n\n----------------------------------------\n\nTITLE: String Processing UDF\nDESCRIPTION: String length calculation with conditional scaling based on length threshold.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_20\n\nLANGUAGE: python\nCODE:\n```\ndef f(row):\n    st = row[\"str_col\"]\n    scale = row[\"scale\"]\n\n    if len(st) > 5:\n        return len(st) + scale\n    else:\n        return len(st)\n```\n\n----------------------------------------\n\nTITLE: GroupBy Sorting Behavior in cuDF\nDESCRIPTION: This snippet highlights the difference in default sorting behavior between cuDF and Pandas GroupBy operations. cuDF uses `sort=False` by default for better performance, which may result in a different group order compared to Pandas. Setting `sort=True` in cuDF will produce Pandas-like output with a performance penalty.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/groupby.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> df = cudf.DataFrame({'a' : [2, 2, 1], 'b' : [42, 21, 11]})\n>>> df.groupby('a').sum()\n   b\na\n2  63\n1  11\n>>> df.to_pandas().groupby('a').sum()\n   b\na\n1  11\n2  63\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> df.groupby('a', sort=True).sum()\n   b\na\n1  11\n2  63\n```\n\n----------------------------------------\n\nTITLE: Applying Null Sensitive Function to cuDF Series\nDESCRIPTION: Applies the null sensitive function to a cuDF Series with nullable data, showing how the function responds to null values.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nsr.apply(f_null_sensitive)\n```\n\n----------------------------------------\n\nTITLE: Creating Columns for Grouping Operations\nDESCRIPTION: Prepares a DataFrame with additional columns for aggregation operations by assigning values based on index modulo.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_47\n\nLANGUAGE: python\nCODE:\n```\ndf[\"agg_col1\"] = [1 if x % 2 == 0 else 0 for x in range(len(df))]\ndf[\"agg_col2\"] = [1 if x % 3 == 0 else 0 for x in range(len(df))]\n\nddf = dask_cudf.from_cudf(df, npartitions=2)\n```\n\n----------------------------------------\n\nTITLE: Boolean Indexing in Dask cuDF DataFrame\nDESCRIPTION: Selects rows from a `dask_cudf.DataFrame` where the values in column 'b' are greater than 15, and displays the first 3 rows using `head()`.  This demonstrates boolean indexing on a distributed DataFrame.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nddf[ddf.b > 15].head(n=3)\n```\n\n----------------------------------------\n\nTITLE: Alignable Fillna with cudf DataFrame Using Python\nDESCRIPTION: Exhibits the use of `fillna()` with a cudf DataFrame filled using mean of columns, aligned by column names. It utilizes a dictionary and Series for targeted filling.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/missing-data.ipynb#2025-04-21_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\nimport cupy as cp\ncp_rng = cp.random.default_rng()\ndff = cudf.DataFrame(cp_rng.standard_normal((10, 3)), columns=list(\"ABC\"))\n```\n\nLANGUAGE: Python\nCODE:\n```\ndff.iloc[3:5, 0] = np.nan\n```\n\nLANGUAGE: Python\nCODE:\n```\ndff.iloc[4:6, 1] = np.nan\n```\n\nLANGUAGE: Python\nCODE:\n```\ndff.iloc[5:8, 2] = np.nan\n```\n\nLANGUAGE: Python\nCODE:\n```\ndff.fillna(dff.mean())\n```\n\nLANGUAGE: Python\nCODE:\n```\ndff.fillna(dff.mean()[1:3])\n```\n\n----------------------------------------\n\nTITLE: Time Series Operations with Dask-cuDF\nDESCRIPTION: Demonstrates date-based filtering on a Dask-cuDF DataFrame. Creates a Dask-cuDF DataFrame from a cuDF DataFrame with datetime data and filters rows using query with a local dictionary to pass the search_date parameter.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_28\n\nLANGUAGE: python\nCODE:\n```\ndate_ddf = dask_cudf.from_cudf(date_df, npartitions=2)\ndate_ddf.query(\n    \"date <= @search_date\", local_dict={\"search_date\": search_date}\n).compute()\n```\n\n----------------------------------------\n\nTITLE: Shallow Copy of a cuDF Series\nDESCRIPTION: This snippet illustrates how performing a shallow copy on a cuDF Series shares memory between the original and the copied series. It provides an example where the copied series is created without duplicating the underlying data.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/copy-on-write.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> copied_series = series.copy(deep=False)\n>>> series\n0    1\n1    2\n2    3\n3    4\ndtype: int64\n>>> copied_series\n0    1\n1    2\n2    3\n3    4\ndtype: int64\n```\n\n----------------------------------------\n\nTITLE: Numba Kernel Row Processing\nDESCRIPTION: Parallel GPU kernel implementation for conditional addition of columns.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_22\n\nLANGUAGE: python\nCODE:\n```\ndef conditional_add(x, y, out):\n    for i, (a, e) in enumerate(zip(x, y)):\n        if a > 0:\n            out[i] = a + e\n        else:\n            out[i] = a\n```\n\n----------------------------------------\n\nTITLE: Applying Functions to cuDF and Dask cuDF Series\nDESCRIPTION: Shows how to apply custom functions to cuDF Series using apply() and to Dask cuDF Series using map_partitions(). The example adds 10 to each value in the Series.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef add_ten(num):\n    return num + 10\n\n\ndf[\"a\"].apply(add_ten)\n```\n\nLANGUAGE: python\nCODE:\n```\nddf[\"a\"].map_partitions(add_ten).head()\n```\n\n----------------------------------------\n\nTITLE: Comparison of Deep and Shallow Copies with Copy-on-Write\nDESCRIPTION: This code snippet compares the effects of deep and shallow copying when copy-on-write is enabled and disabled. It shows how memory sharing occurs with shallow copies and how modifications trigger true copies under specific conditions.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/copy-on-write.md#2025-04-21_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\n|                     | Copy-on-Write enabled                                                                                                                                                                                          | Copy-on-Write disabled (default)                                                                               |\n|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------|\n| `.copy(deep=True)`  | A true copy is made and changes don't propagate to the original object.                                                                                                                            | A true copy is made and changes don't propagate to the original object.                  |\n| `.copy(deep=False)` | Memory is shared between the two objects and but any write operation on one object will trigger a true physical copy before the write is performed. Hence changes will not propagate to the original object. | Memory is shared between the two objects and changes performed on one will propagate to the other object.\n```\n\n----------------------------------------\n\nTITLE: Defining Function to Convert cuDF to CuPy Sparse Matrix\nDESCRIPTION: Defines a function `cudf_to_cupy_sparse_matrix` that converts a cuDF DataFrame or Series to a CuPy sparse matrix. The function supports \"row\" and \"column\" sparse formats, defaulting to \"column\".\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/cupy-interop.ipynb#2025-04-21_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndef cudf_to_cupy_sparse_matrix(data, sparseformat=\"column\"):\n    \"\"\"Converts a cuDF object to a CuPy Sparse Column matrix.\"\"\"\n    if sparseformat not in (\n        \"row\",\n        \"column\",\n    ):\n        raise ValueError(\"Let's focus on column and row formats for now.\")\n\n    _sparse_constructor = cp.sparse.csc_matrix\n    if sparseformat == \"row\":\n        _sparse_constructor = cp.sparse.csr_matrix\n\n    return _sparse_constructor(cupy_from_dlpack(data.to_dlpack()))\n```\n\n----------------------------------------\n\nTITLE: Hierarchical Grouping with cuDF\nDESCRIPTION: Demonstrates grouping by multiple columns to create a hierarchical index before applying the sum aggregation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_50\n\nLANGUAGE: python\nCODE:\n```\ndf.groupby([\"agg_col1\", \"agg_col2\"]).sum()\n```\n\n----------------------------------------\n\nTITLE: Converting Dask-cuDF DataFrame to PyArrow Table\nDESCRIPTION: Demonstrates converting a subset of a Dask-cuDF DataFrame to a PyArrow Table by first getting a cuDF DataFrame with head() and then converting.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_42\n\nLANGUAGE: python\nCODE:\n```\nddf.head().to_arrow()\n```\n\n----------------------------------------\n\nTITLE: Applying String Processing Function to cuDF Series\nDESCRIPTION: Demonstrates the application of a custom string processing function on a cuDF Series and prints the result.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nresult = sr.apply(f)\\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Importing cuDF and Numba Configuration\nDESCRIPTION: Imports necessary libraries and sets a configuration parameter for Numba to suppress low occupancy warnings. Required to create user-defined functions for cuDF.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cudf\\nimport numpy as np\\nfrom cudf.datasets import randomdata\\nfrom numba import config\\n\\nconfig.CUDA_LOW_OCCUPANCY_WARNINGS = 0\n```\n\n----------------------------------------\n\nTITLE: String Replacement with Regular Expression in cudf in Python\nDESCRIPTION: Exhibits the replacement of string values in cudf DataFrames using the `replace` API, allowing for both value matching and regex-based replacements. This functionality is showcased through substitutions across multiple columns using both list and dictionary syntax.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/missing-data.ipynb#2025-04-21_snippet_15\n\nLANGUAGE: Python\nCODE:\n```\nd = {\"a\": list(range(4)), \"b\": list(\"ab..\"), \"c\": [\"a\", \"b\", None, \"d\"]}\ndf = cudf.DataFrame(d)\n```\n\nLANGUAGE: Python\nCODE:\n```\ndf.replace(\".\", \"A Dot\")\n```\n\nLANGUAGE: Python\nCODE:\n```\ndf.replace([\".\", \"b\"], [\"A Dot\", None])\n```\n\nLANGUAGE: Python\nCODE:\n```\ndf.replace([\"a\", \".\"], [\"b\", \"--\"])\n```\n\nLANGUAGE: Python\nCODE:\n```\ndf.replace({\"b\": \".\"}, {\"b\": \"replacement value\"})\n```\n\n----------------------------------------\n\nTITLE: Converting cuDF DataFrame to CuPy Array with Performance Benchmarks\nDESCRIPTION: Creates a cuDF DataFrame and benchmarks three methods for converting it to a CuPy array: using dlpack, DataFrame.values, and to_cupy(). Each method is timed using the %timeit magic command.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/cupy-interop.ipynb#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnelem = 10000\ndf = cudf.DataFrame(\n    {\n        \"a\": range(nelem),\n        \"b\": range(500, nelem + 500),\n        \"c\": range(1000, nelem + 1000),\n    }\n)\n\n%timeit arr_cupy = cupy_from_dlpack(df.to_dlpack())\n%timeit arr_cupy = df.values\n%timeit arr_cupy = df.to_cupy()\n```\n\n----------------------------------------\n\nTITLE: Querying Dask cuDF DataFrame\nDESCRIPTION: Selects rows from a `dask_cudf.DataFrame` where the value in column 'b' is equal to 3, using the `query` method and `compute()`.  Because compute is called here instead of head, the entire result is retrieved instead of the first few rows.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nddf.query(\"b == 3\").compute()\n```\n\n----------------------------------------\n\nTITLE: Selecting Rows by Label in Dask cuDF DataFrame\nDESCRIPTION: Selects rows from index 2 to index 5 (inclusive) and columns 'a' and 'b' from a `dask_cudf.DataFrame` using label-based indexing, then displays the first few rows using `head()`. This demonstrates label-based selection on a distributed DataFrame.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nddf.loc[2:5, [\"a\", \"b\"]].head()\n```\n\n----------------------------------------\n\nTITLE: Hierarchical Groupby Sum with cuDF\nDESCRIPTION: Demonstrates hierarchical grouping using two columns (agg_col1 and agg_col2) and then applying the sum function to all other columns in the cuDF DataFrame.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_21\n\nLANGUAGE: python\nCODE:\n```\ndf.groupby([\"agg_col1\", \"agg_col2\"]).sum()\n```\n\n----------------------------------------\n\nTITLE: Writing Dask-cuDF DataFrame to CSV\nDESCRIPTION: Demonstrates how to compute a Dask-cuDF DataFrame and write it to a CSV file.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_73\n\nLANGUAGE: python\nCODE:\n```\nddf.compute().to_csv(\"example_output/foo_dask.csv\", index=False)\n```\n\n----------------------------------------\n\nTITLE: Persisting a Dask-cuDF DataFrame in GPU Memory\nDESCRIPTION: Demonstrates how to force computation and keep results in distributed GPU memory using persist().\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_85\n\nLANGUAGE: python\nCODE:\n```\nddf2 = ddf2.persist()\nddf2\n```\n\n----------------------------------------\n\nTITLE: Computing Statistics in cuDF and Dask cuDF\nDESCRIPTION: Demonstrates how to calculate descriptive statistics like mean and variance for both cuDF and Dask cuDF Series. Shows when to use compute() with Dask cuDF to retrieve results.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ns.mean(), s.var()\n```\n\nLANGUAGE: python\nCODE:\n```\nds.mean().compute(), ds.var().compute()\n```\n\n----------------------------------------\n\nTITLE: Selecting Rows by Label in cuDF and Dask cuDF\nDESCRIPTION: Shows how to select rows by label using the loc indexer in both cuDF and Dask cuDF. The example selects rows from index 2 to 5 for specific columns.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndf.loc[2:5, [\"a\", \"b\"]]\n```\n\nLANGUAGE: python\nCODE:\n```\nddf.loc[2:5, [\"a\", \"b\"]].head()\n```\n\n----------------------------------------\n\nTITLE: Creating and Copying Series with Copy-on-Write in cuDF\nDESCRIPTION: Demonstrates the creation of a cuDF Series and making shallow copies with copy-on-write enabled. Shows how memory addresses remain the same until a write operation occurs.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/library_design.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> import cudf\n>>> cudf.set_option(\"copy_on_write\", True)\n>>> s1 = cudf.Series([1, 2, 3, 4])\n>>> s2 = s1.copy(deep=False)\n>>> s3 = s2.copy(deep=False)\n\n>>> s1\n0    1\n1    2\n2    3\n3    4\ndtype: int64\n>>> s2\n0    1\n1    2\n2    3\n3    4\ndtype: int64\n>>> s3\n0    1\n1    2\n2    3\n3    4\ndtype: int64\n\n>>> s1.data._ptr\n139796315897856\n>>> s2.data._ptr\n139796315897856\n>>> s3.data._ptr\n139796315897856\n```\n\n----------------------------------------\n\nTITLE: Setting Low Memory Mode for JSON Files in cuDF\nDESCRIPTION: Code example showing how to enable low memory mode for reading JSON files in cuDF, which processes data in chunks to reduce peak memory usage on systems with limited memory.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/io/io.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncudf.set_option(\"io.json.low_memory\", True)\n```\n\n----------------------------------------\n\nTITLE: Converting cuDF DataFrame to CuPy Sparse Matrix\nDESCRIPTION: Converts the sparse cuDF DataFrame to a CuPy sparse matrix using the previously defined helper function and prints the resulting matrix summary.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/cupy-interop.ipynb#2025-04-21_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nsparse_data = cudf_to_cupy_sparse_matrix(df)\nprint(sparse_data)\n```\n\n----------------------------------------\n\nTITLE: Calculating Value Counts for cuDF Series\nDESCRIPTION: Calculates the number of occurrences of each unique value in the 'a' column of a `cudf.DataFrame` using the `value_counts` method. This provides a way to perform histogramming on a GPU Series.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_37\n\nLANGUAGE: python\nCODE:\n```\ndf.a.value_counts()\n```\n\n----------------------------------------\n\nTITLE: Converting Dask-cuDF Series to NumPy Array\nDESCRIPTION: Demonstrates converting a single column from a Dask-cuDF DataFrame to a NumPy ndarray, first computing to get a cuDF Series and then converting.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_40\n\nLANGUAGE: python\nCODE:\n```\nddf[\"a\"].compute().to_numpy()\n```\n\n----------------------------------------\n\nTITLE: Cumulative Methods with cudf in Python\nDESCRIPTION: Illustrates the use of cumulative methods such as `cumsum` on Series with missing values. Explains how these methods handle null values with the `skipna` parameter, which is set to True by default to ignore nulls.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/missing-data.ipynb#2025-04-21_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\ndf1[\"a\"].cumsum()\n```\n\nLANGUAGE: Python\nCODE:\n```\ndf1[\"a\"].cumsum(skipna=False)\n```\n\n----------------------------------------\n\nTITLE: Using Grouper Object in cuDF\nDESCRIPTION: This snippet illustrates the use of the `Grouper` object in cuDF to disambiguate between columns and index levels that share the same name.  It shows how to use `cudf.Grouper` with both `key` and `level` parameters to avoid ambiguity when grouping.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/groupby.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> df\n   b  c\nb\n1  1  1\n1  1  2\n1  2  3\n2  2  4\n2  3  5\n>>> df.groupby('b', level='b')  # ValueError: Cannot specify both by and level\n>>> df.groupby([cudf.Grouper(key='b'), cudf.Grouper(level='b')])  # OK\n```\n\n----------------------------------------\n\nTITLE: Function Object Example for Type Dispatcher\nDESCRIPTION: This code snippet illustrates how to create a function object, `size_of_functor`, for use with the `type_dispatcher`. The functor's `operator()` template returns the size of the dispatched type, demonstrating a practical application of type dispatching to determine type sizes at runtime.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_27\n\nLANGUAGE: c++\nCODE:\n```\nstruct size_of_functor{\n  template <typename T>\n  int operator()(){ return sizeof(T); }\n};\n\ncudf::type_dispatcher(data_type{type_id::INT8}, size_of_functor{});  // returns 1\ncudf::type_dispatcher(data_type{type_id::INT32}, size_of_functor{});  // returns 4\ncudf::type_dispatcher(data_type{type_id::FLOAT64}, size_of_functor{});  // returns 8\n```\n\n----------------------------------------\n\nTITLE: Creating cudf Series with NaN Values in Python\nDESCRIPTION: This code snippet demonstrates how to create a cudf Series containing `np.nan`, which by default is treated as `<NA>`. It also shows how to set the `nan_as_null` parameter to `False` to maintain them as `NaN` values.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/missing-data.ipynb#2025-04-21_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ncudf.Series([1, 2, np.nan])\n```\n\nLANGUAGE: Python\nCODE:\n```\ncudf.Series([1, 2, np.nan], nan_as_null=False)\n```\n\n----------------------------------------\n\nTITLE: Converting CuPy Array to cuDF Series\nDESCRIPTION: Demonstrates converting a CuPy array (the diagonal of a 2D array) to a cuDF Series using the Series constructor and displays the first few elements.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/cupy-interop.ipynb#2025-04-21_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ncudf.Series(reshaped_arr.diagonal()).head()\n```\n\n----------------------------------------\n\nTITLE: Creating cuDF Series from Pandas Series with Nested Data Types\nDESCRIPTION: This snippet demonstrates how to create a cuDF Series from a Pandas Series containing dictionaries and check the resulting structure. This showcases the ability to handle nested data types like Struct in cuDF. The only prerequisite is the 'cudf' and 'pandas' libraries.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/data-types.md#2025-04-21_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n>>> import pandas as pd\n>>> psr = pd.Series([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}])\n>>> gsr = cudf.from_pandas(psr)\n>>> gsr.dtypes\nStructDtype({'a': dtype('int64'), 'b': dtype('int64')})\n```\n\n----------------------------------------\n\nTITLE: Matching Strings with Regular Expressions in Dask cuDF Series\nDESCRIPTION: Matches strings in a `dask_cudf.Series` against a regular expression using the `str.match()` method, and displays the first few results using head().\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_42\n\nLANGUAGE: python\nCODE:\n```\nds.str.match(\"^[aAc].+\").head()\n```\n\n----------------------------------------\n\nTITLE: Converting cuDF Series to CuPy Array using asarray\nDESCRIPTION: Demonstrates converting a cuDF Series to a CuPy array using cp.asarray and the CUDA array interface, then displays the resulting array.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/cupy-interop.ipynb#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncola_cupy = cp.asarray(df[col])\ncola_cupy\n```\n\n----------------------------------------\n\nTITLE: Hierarchical Grouping with Dask-cuDF\nDESCRIPTION: Shows how to perform hierarchical grouping with a Dask-cuDF DataFrame across multiple partitions.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_51\n\nLANGUAGE: python\nCODE:\n```\nddf.groupby([\"agg_col1\", \"agg_col2\"]).sum().compute()\n```\n\n----------------------------------------\n\nTITLE: Accessing Categorical Column Codes in Dask-cuDF\nDESCRIPTION: Shows how to access the underlying integer codes of a categorical column in a Dask-cuDF DataFrame.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_62\n\nLANGUAGE: python\nCODE:\n```\ndgdf.grade.cat.codes.compute()\n```\n\n----------------------------------------\n\nTITLE: Applying Transformation and Persisting Results in Dask with Python\nDESCRIPTION: This code applies the previously defined transformation function to each partition of the Dask DataFrame using map_partitions. The results are then persisted to trigger computation and caching of the results.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_59\n\nLANGUAGE: python\nCODE:\n```\nresults_ddf = ddf2.map_partitions(func)\nresults_ddf = results_ddf.persist()\n```\n\n----------------------------------------\n\nTITLE: Checking for Literal Nodes in Expressions with Pre-order Traversal in Python\nDESCRIPTION: A function that determines if an expression contains a Literal node by using pre-order traversal to visit all unique nodes in the expression tree.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_polars/docs/overview.md#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef has_literal(node: Expr) -> bool:\n    return any(isinstance(e, Literal) for e in traversal(node))\n```\n\n----------------------------------------\n\nTITLE: Querying DateTime Data with Dask-cuDF\nDESCRIPTION: Demonstrates how to filter datetime data in a distributed DataFrame using Dask-cuDF's query method.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_57\n\nLANGUAGE: python\nCODE:\n```\ndate_ddf = dask_cudf.from_cudf(date_df, npartitions=2)\ndate_ddf.query(\n    \"date <= @search_date\", local_dict={\"search_date\": search_date}\n).compute()\n```\n\n----------------------------------------\n\nTITLE: Identifying Data Type of cuDF Series Containing Strings\nDESCRIPTION: This snippet shows how to initialize a cuDF Series with string data and check its data type. The use of the 'np.object' type provides compatibility with Pandas, noting a limitation in storing arbitrary Python objects. The 'cudf' library is the only prerequisite.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/data-types.md#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n>>> import cudf\n>>> s = cudf.Series([\"abc\", \"def\", \"ghi\"])\n>>> s.dtype\ndtype(\"object\")\n```\n\n----------------------------------------\n\nTITLE: Runtime Condition Enforcement with CUDF_EXPECTS Macro\nDESCRIPTION: This code shows how to use the `CUDF_EXPECTS` macro to enforce runtime conditions in libcudf. The macro checks a conditional expression, and if it evaluates to `false`, it throws an exception with a provided error message and exception class. This is used to check preconditions required for the function to operate correctly.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_22\n\nLANGUAGE: c++\nCODE:\n```\nCUDF_EXPECTS(cudf::have_same_types(lhs, rhs), \"Type mismatch\", cudf::data_type_error);\n\n```\n\n----------------------------------------\n\nTITLE: Concatenating cuDF Series\nDESCRIPTION: Concatenates a `cudf.Series` with itself using the `cudf.concat` method. This demonstrates how to combine multiple GPU Series.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_43\n\nLANGUAGE: python\nCODE:\n```\ns = cudf.Series([1, 2, 3, None, 5])\ncudf.concat([s, s])\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Data in cuDF and Dask cuDF\nDESCRIPTION: Shows how to replace missing values using the fillna method in both cuDF and Dask cuDF Series objects. The example replaces None values with 999.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ns.fillna(999)\n```\n\nLANGUAGE: python\nCODE:\n```\nds.fillna(999).head(n=3)\n```\n\n----------------------------------------\n\nTITLE: Converting Dask-cuDF DataFrame to NumPy Array\nDESCRIPTION: Demonstrates computing a Dask-cuDF DataFrame and converting it to a NumPy ndarray.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_67\n\nLANGUAGE: python\nCODE:\n```\nddf.compute().to_numpy()\n```\n\n----------------------------------------\n\nTITLE: Assigning MultiIndex to cuDF DataFrame Columns\nDESCRIPTION: Creates a `cudf.DataFrame` and assigns a `cudf.MultiIndex` to its columns after transposing the DataFrame. This demonstrates how to use a MultiIndex to create a hierarchical column structure for a DataFrame.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_28\n\nLANGUAGE: python\nCODE:\n```\ngdf2 = cudf.DataFrame(\n    {\"first\": cp.random.rand(4), \"second\": cp.random.rand(4)}\n).T\ngdf2.columns = idx\ngdf2\n```\n\n----------------------------------------\n\nTITLE: Complete Doxygen Documentation Example for C++ Code\nDESCRIPTION: Comprehensive example demonstrating proper Doxygen documentation for a source file, class, member functions, free functions, and enums in libcudf. Shows proper tag usage and formatting.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DOCUMENTATION.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n/**\n * @file source_file.cpp\n * @brief Description of source file contents\n *\n * Longer description of the source file contents.\n */\n\n/**\n * @brief One line description of the class\n *\n * @ingroup optional_predefined_group_id\n *\n * Longer, more detailed description of the class.\n *\n * @tparam T Short description of each template parameter\n * @tparam U Short description of each template parameter\n */\ntemplate <typename T, typename U>\nclass example_class {\n\n  void get_my_int();            ///< Simple members can be documented like this\n  void set_my_int( int value ); ///< Try to use descriptive member names\n\n  /**\n   * @brief Short, one line description of the member function\n   *\n   * A more detailed description of what this function does and what\n   * its logic does.\n   *\n   * @code\n   * example_class<int> inst;\n   * inst.set_my_int(5);\n   * int output = inst.complicated_function(1,dptr,fptr);\n   * @endcode\n   *\n   * @param[in]     first  This parameter is an input parameter to the function\n   * @param[in,out] second This parameter is used both as an input and output\n   * @param[out]    third  This parameter is an output of the function\n   *\n   * @return The result of the complex function\n   */\n  T complicated_function(int first, double* second, float* third)\n  {\n      // Do not use doxygen-style block comments\n      // for code logic documentation.\n  }\n\n private:\n  int my_int;                ///< An example private member variable\n};\n\n/**\n * @brief Short, one line description of this free function\n *\n * @ingroup optional_predefined_group_id\n *\n * A detailed description must start after a blank line.\n *\n * @code\n * template<typename T>\n * struct myfunctor {\n *   bool operator()(T input) { return input % 2 > 0; }\n * };\n * free_function<myfunctor,int>(myfunctor{},12);\n * @endcode\n *\n * @throw cudf::logic_error if `input_argument` is negative or zero\n *\n * @tparam functor_type The type of the functor\n * @tparam input_type The datatype of the input argument\n *\n * @param[in] functor        The functor to be called on the input argument\n * @param[in] input_argument The input argument passed into the functor\n * @return The result of calling the functor on the input argument\n */\ntemplate <class functor_type, typename input_type>\nbool free_function(functor_type functor, input_type input_argument)\n{\n  CUDF_EXPECTS( input_argument > 0, \"input_argument must be positive\");\n  return functor(input_argument);\n}\n\n/**\n * @brief Short, one line description\n *\n * @ingroup optional_predefined_group_id\n *\n * Optional, longer description.\n */\nenum class example_enum {\n  first_enum,   ///< Description of the first enum\n  second_enum,  ///< Description of the second enum\n  third_enum    ///< Description of the third enum\n};\n```\n\n----------------------------------------\n\nTITLE: Using the cudf.pandas line profiler in Jupyter\nDESCRIPTION: Shows how to use the cudf.pandas.line_profile magic in Jupyter/IPython to profile the execution time of each line of code on both GPU and CPU, providing detailed performance insights.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/usage.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n%%cudf.pandas.line_profile\ndf = pd.DataFrame({'a': [0, 1, 2], 'b': [3, 4, 3]})\n\ndf.min(axis=1)\nout = df.groupby('a').filter(\n    lambda group: len(group) > 1\n)\n```\n\n----------------------------------------\n\nTITLE: Converting Fortran-ordered CuPy Array to cuDF DataFrame\nDESCRIPTION: Demonstrates converting a CuPy array to Fortran-contiguous memory layout and then to a cuDF DataFrame, displaying the first few rows of the result.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/cupy-interop.ipynb#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfortran_arr = cp.asfortranarray(reshaped_arr)\nreshaped_df = cudf.DataFrame(fortran_arr)\nreshaped_df.head()\n```\n\n----------------------------------------\n\nTITLE: Performing Arithmetic with Missing Data in cudf in Python\nDESCRIPTION: Illustrates arithmetic operations on DataFrames containing `NA` values using cudf. Shows two DataFrames with misaligned `NA` values, demonstrating the resulting sum and treatment of `NA` as `0` in calculations where `skipna` is set to True.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/missing-data.ipynb#2025-04-21_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\ndf1 = cudf.DataFrame(\n    {\n        \"a\": [1, None, 2, 3, None],\n        \"b\": cudf.Series([np.nan, 2, 3.2, 0.1, 1], nan_as_null=False),\n    }\n)\n```\n\nLANGUAGE: Python\nCODE:\n```\ndf2 = cudf.DataFrame(\n    {\"a\": [1, 11, 2, 34, 10], \"b\": cudf.Series([0.23, 22, 3.2, None, 1])}\n)\n```\n\nLANGUAGE: Python\nCODE:\n```\ndf1 + df2\n```\n\nLANGUAGE: Python\nCODE:\n```\ndf1[\"a\"].sum()\n```\n\nLANGUAGE: Python\nCODE:\n```\ndf1[\"a\"].mean()\n```\n\nLANGUAGE: Python\nCODE:\n```\ndf1[\"a\"].sum(skipna=False)\n```\n\nLANGUAGE: Python\nCODE:\n```\ndf1[\"a\"].mean(skipna=False)\n```\n\n----------------------------------------\n\nTITLE: Reading Multiple CSV Files with Dask-cuDF\nDESCRIPTION: Shows how to read multiple CSV files in a directory into a single Dask-cuDF DataFrame using wildcard pattern matching, which leverages parallel loading across files.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_47\n\nLANGUAGE: python\nCODE:\n```\nddf = dask_cudf.read_csv(\"example_output/*.csv\")\nddf.head()\n```\n\n----------------------------------------\n\nTITLE: Persisting a Dask-cuDF DataFrame in Memory\nDESCRIPTION: Forces computation of the Dask-cuDF DataFrame and keeps the result in distributed GPU memory using the persist() method. This converts the lazy operation into an actual in-memory result.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_56\n\nLANGUAGE: python\nCODE:\n```\nddf2 = ddf2.persist()\nddf2\n```\n\n----------------------------------------\n\nTITLE: Calculating Row-wise Sum of cuDF DataFrame using CuPy\nDESCRIPTION: Converts a cuDF DataFrame (`reshaped_df`) to a CuPy array using dlpack, then calculates the row-wise sum of the array using CuPy's `sum` function with the `axis=1` argument. It leverages the `cupy_from_dlpack` function and the `to_dlpack()` method.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/cupy-interop.ipynb#2025-04-21_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nnew_arr = cupy_from_dlpack(reshaped_df.to_dlpack())\nnew_arr.sum(axis=1)\n```\n\n----------------------------------------\n\nTITLE: Accessing Categorical Column Categories in cuDF\nDESCRIPTION: Shows how to access the unique categories in a categorical column using the cat.categories property.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_60\n\nLANGUAGE: python\nCODE:\n```\ngdf.grade.cat.categories\n```\n\n----------------------------------------\n\nTITLE: Accessing Categorical Codes in cuDF\nDESCRIPTION: Demonstrates how to access the underlying integer codes of a categorical column in a cuDF DataFrame. Each unique category value is represented by a unique integer code.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_32\n\nLANGUAGE: python\nCODE:\n```\ngdf.grade.cat.codes\n```\n\n----------------------------------------\n\nTITLE: Converting DataFrame Backend in Dask\nDESCRIPTION: Demonstrates how to convert a Dask DataFrame between different backends (pandas/cuDF) using the to_backend method.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/dask_cudf/source/best_practices.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ndf = df.to_backend(\"pandas\")  # This gives us a pandas-backed collection\n```\n\n----------------------------------------\n\nTITLE: Using the cudf.pandas function profiler in Jupyter\nDESCRIPTION: Demonstrates how to use the cudf.pandas.profile magic in Jupyter/IPython to profile which pandas operations used the GPU versus the CPU, helping identify opportunities for optimization.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/usage.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n%%cudf.pandas.profile\ndf = pd.DataFrame({'a': [0, 1, 2], 'b': [3, 4, 3]})\n\ndf.min(axis=1)\nout = df.groupby('a').filter(\n    lambda group: len(group) > 1\n)\n```\n\n----------------------------------------\n\nTITLE: Allocating Temporary Memory in libcudf Functions (C++)\nDESCRIPTION: Demonstrates how to allocate temporary memory in libcudf functions using the default resource obtained from cudf::get_current_device_resource_ref().\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nrmm::device_buffer some_function(\n  ..., rmm::device_async_resource_ref mr = cudf::get_current_device_resource_ref()) {\n    rmm::device_buffer returned_buffer(..., mr); // Returned buffer uses the passed in MR\n    ...\n    rmm::device_buffer temporary_buffer(...); // Temporary buffer uses default MR\n    ...\n    return returned_buffer;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Additional Scalar Arguments\nDESCRIPTION: Defines a function that takes multiple arguments, demonstrating how to use the args parameter in the apply method to pass constant values.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef g(x, const):\\n    return x + const\n```\n\n----------------------------------------\n\nTITLE: Converting Fortran-ordered Array to DataFrame with Benchmarking\nDESCRIPTION: Benchmarks the process of converting a CuPy array to Fortran memory order and then to a cuDF DataFrame using the DataFrame constructor.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/cupy-interop.ipynb#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n%%timeit\n\nfortran_arr = cp.asfortranarray(reshaped_arr)\nreshaped_df = cudf.DataFrame(fortran_arr)\n```\n\n----------------------------------------\n\nTITLE: Pre-allocating Output Array for Kernel Execution\nDESCRIPTION: Prepares an output Series filled with zeroes to store results from the multiplication kernel, setting up for kernel execution.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nsize = len(df[\"a\"])\\ndf[\"e\"] = 0.0\\nmultiply.forall(size)(df[\"a\"], df[\"e\"], 10.0)\n```\n\n----------------------------------------\n\nTITLE: CUDA Error Checking with CUDF_CUDA_TRY Macro\nDESCRIPTION: This code demonstrates the use of the `CUDF_CUDA_TRY` macro to check for successful completion of CUDA runtime API functions. If the CUDA API returns a value other than `cudaSuccess`, the macro throws a `cudf::cuda_error` exception with a description of the CUDA error code.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_24\n\nLANGUAGE: c++\nCODE:\n```\nCUDF_CUDA_TRY( cudaMemcpy(&dst, &src, num_bytes) );\n\n```\n\n----------------------------------------\n\nTITLE: Benchmark Function Example with Object Decorator\nDESCRIPTION: Demonstrates how to write a benchmark function using the benchmark_with_object decorator to test DataFrame operations with specific parameters.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/benchmarking.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@benchmark_with_object(cls=\"dataframe\", dtype=\"int\", cols=6)\ndef bench_foo(benchmark, dataframe):\n    benchmark(dataframe.foo)\n```\n\n----------------------------------------\n\nTITLE: GPU Profiling Example\nDESCRIPTION: Demonstrates how to profile query execution on GPU and access profiling results.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_polars/usage.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport polars as pl\nq = pl.scan_parquet(\"ny-taxi/2024/*.parquet\").filter(pl.col(\"total_amount\") > 15.0)\nprofile = q.profile(engine=\"gpu\")\n```\n\n----------------------------------------\n\nTITLE: Using cudf.pandas with multiprocessing\nDESCRIPTION: Demonstrates how to use cudf.pandas with multiprocessing or concurrent.futures, ensuring GPU acceleration works in worker processes by installing cudf.pandas programmatically at the beginning of the script.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/usage.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# This is equivalent to python -m cudf.pandas, but will run on the\n# workers too. These two lines must run before pandas is imported,\n# either directly or transitively.\nimport cudf.pandas\ncudf.pandas.install()\n\nfrom multiprocessing import Pool\n\nwith Pool(4) as pool:\n    # use pool here\n    ...\n```\n\n----------------------------------------\n\nTITLE: Handling Datetime NA with cudf in Python\nDESCRIPTION: This snippet demonstrates how cudf handles `NaT` values in `datetime64` types, treating them as nulls (`<NA>`). It converts cudf Series with Timestamps and `NaT` to pandas objects while retaining the underlying value of `NaT` as `min(int64)`.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/missing-data.ipynb#2025-04-21_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nimport pandas as pd\ndatetime_series = cudf.Series([\n    pd.Timestamp(\"20120101\"), pd.NaT, pd.Timestamp(\"20120101\")\n])\ndatetime_series\n```\n\nLANGUAGE: Python\nCODE:\n```\ndatetime_series.to_pandas()\n```\n\nLANGUAGE: Python\nCODE:\n```\ndatetime_series - datetime_series\n```\n\n----------------------------------------\n\nTITLE: Viewing Top Rows of cuDF DataFrame\nDESCRIPTION: Displays the first 2 rows of a `cudf.DataFrame`. This is a basic operation for quickly inspecting the contents of a DataFrame.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndf.head(2)\n```\n\n----------------------------------------\n\nTITLE: Using cuDF directly for data manipulation\nDESCRIPTION: This snippet demonstrates how to use cuDF directly with its pandas-like API for loading CSV data, performing calculations, and generating aggregations on GPU.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_kafka/README.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cudf\n\ntips_df = cudf.read_csv(\"https://github.com/plotly/datasets/raw/master/tips.csv\")\ntips_df[\"tip_percentage\"] = tips_df[\"tip\"] / tips_df[\"total_bill\"] * 100\n\n# display average tip by dining party size\nprint(tips_df.groupby(\"size\").tip_percentage.mean())\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Multiplication Kernel with Numba\nDESCRIPTION: Defines a simple Numba CUDA kernel that multiplies elements of an input array by a specified multiplier, demonstrating low-level CUDA programming with cuDF.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom numba import cuda\\n\\n\\n@cuda.jit\\ndef multiply(in_col, out_col, multiplier):\\n    i = cuda.grid(1)\\n    if i < in_col.size:  # boundary guard\\n        out_col[i] = in_col[i] * multiplier\n```\n\n----------------------------------------\n\nTITLE: Viewing Top Rows of Dask cuDF DataFrame\nDESCRIPTION: Displays the first 2 rows of a `dask_cudf.DataFrame`. This allows for inspecting a small portion of a larger distributed DataFrame.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nddf.head(2)\n```\n\n----------------------------------------\n\nTITLE: Working with Categorical Data in Dask-cuDF\nDESCRIPTION: Converts a cuDF DataFrame with a categorical column to a Dask-cuDF DataFrame and displays the first 3 rows. Shows how categorical data is preserved when creating a distributed DataFrame.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_30\n\nLANGUAGE: python\nCODE:\n```\ndgdf = dask_cudf.from_cudf(gdf, npartitions=2)\ndgdf.head(n=3)\n```\n\n----------------------------------------\n\nTITLE: Reading CSV with Dask-cuDF\nDESCRIPTION: Demonstrates reading a CSV file into a Dask-cuDF DataFrame and viewing the first few rows. Using dask_cudf.read_csv allows for parallel loading across multiple GPUs.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nddf = dask_cudf.read_csv(\"example_output/foo_dask.csv\")\nddf.head()\n```\n\n----------------------------------------\n\nTITLE: Table Sort Function Signature in C++\nDESCRIPTION: Example of a typical libcudf function signature showing the pattern of taking views as input and returning unique_ptr to owning objects.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nstd::unique_ptr<table> sort(table_view const& input);\n```\n\n----------------------------------------\n\nTITLE: Converting cuDF DataFrame to Pandas\nDESCRIPTION: Demonstrates how to convert a cuDF DataFrame to a pandas DataFrame using the to_pandas() method. Shows conversion of just the first few rows using head() to limit memory usage.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_34\n\nLANGUAGE: python\nCODE:\n```\ndf.head().to_pandas()\n```\n\n----------------------------------------\n\nTITLE: DataFrame Rolling Window Operations\nDESCRIPTION: Creates a DataFrame and applies rolling window operations across multiple columns.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_26\n\nLANGUAGE: python\nCODE:\n```\ndf2 = cudf.DataFrame()\ndf2[\"a\"] = np.arange(55, 65, dtype=\"float64\")\ndf2[\"b\"] = np.arange(55, 65, dtype=\"float64\")\ndf2.head()\n```\n\nLANGUAGE: python\nCODE:\n```\nrolling = df2.rolling(window=3, min_periods=3, center=False)\nrolling.apply(example_func)\n```\n\n----------------------------------------\n\nTITLE: Calculating Matrix Norm with CuPy\nDESCRIPTION: Calculates and displays the Frobenius norm of a 2D CuPy array using cp.linalg.norm.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/cupy-interop.ipynb#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ncp.linalg.norm(reshaped_arr)\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Test Fixture in C++\nDESCRIPTION: Example of creating a basic test fixture that inherits from cudf::test::BaseFixture, which ensures proper RMM initialization.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/TESTING.md#2025-04-21_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nclass MyTestFixture : public cudf::test::BaseFixture {...};\n```\n\n----------------------------------------\n\nTITLE: Importing cuDF and CuPy with Version Compatibility\nDESCRIPTION: Imports necessary libraries and handles CuPy version differences for the dlpack functionality. For CuPy versions 10.0.0 and above, it uses cp.from_dlpack; otherwise, it uses cp.fromDlpack.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/cupy-interop.ipynb#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cudf\nimport cupy as cp\nfrom packaging import version\n\nif version.parse(cp.__version__) >= version.parse(\"10.0.0\"):\n    cupy_from_dlpack = cp.from_dlpack\nelse:\n    cupy_from_dlpack = cp.fromDlpack\n```\n\n----------------------------------------\n\nTITLE: Creating a Nullable cuDF Series\nDESCRIPTION: Illustrates the creation of a cuDF Series that includes null values, which is important for demonstrating null handling in user-defined functions.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Create a cuDF series with nulls\\nsr = cudf.Series([1, cudf.NA, 3])\\nsr\n```\n\n----------------------------------------\n\nTITLE: Creating Rolling Window Series Example\nDESCRIPTION: Demonstrates creation of a basic Series and rolling window object in cuDF for time-series analysis.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nser = cudf.Series([16, 25, 36, 49, 64, 81], dtype=\"float64\")\nser\n```\n\nLANGUAGE: python\nCODE:\n```\nrolling = ser.rolling(window=3, min_periods=3, center=False)\nrolling\n```\n\n----------------------------------------\n\nTITLE: Defining a Null Sensitive Function\nDESCRIPTION: Defines a function that explicitly handles null values using the cudf.NA singleton, returning a predetermined value if the input is null.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef f_null_sensitive(x):\\n    # do something if the input is null\\n    if x is cudf.NA:\\n        return 42\\n    else:\\n        return x + 1\n```\n\n----------------------------------------\n\nTITLE: Counting Value Frequencies in cuDF and Dask cuDF\nDESCRIPTION: Demonstrates how to count occurrences of unique values using value_counts() in both cuDF and Dask cuDF. This operation is useful for analyzing categorical data.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndf.a.value_counts()\n```\n\nLANGUAGE: python\nCODE:\n```\nddf.a.value_counts().head()\n```\n\n----------------------------------------\n\nTITLE: Using 'wait' Function for Task Synchronization in Dask with Python\nDESCRIPTION: This snippet demonstrates the use of the 'wait' function to ensure all partitions have completed processing before proceeding with subsequent tasks in the workflow. This is crucial for maintaining data consistency in distributed computing environments.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_60\n\nLANGUAGE: python\nCODE:\n```\nwait(results_ddf)\n```\n\n----------------------------------------\n\nTITLE: Setting Low Memory Mode for Parquet Files in cuDF\nDESCRIPTION: Code example showing how to enable low memory mode for reading parquet files in cuDF, which processes data in chunks to reduce peak memory usage on systems with limited memory.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/io/io.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncudf.set_option(\"io.parquet.low_memory\", True)\n```\n\n----------------------------------------\n\nTITLE: Initializing CUDA DataFrame with Random Processing Function\nDESCRIPTION: Creates a CUDA DataFrame with numeric data and defines a function that applies random sleep delays and arithmetic transformations. The function is designed to simulate varying processing times across partitions.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_87\n\nLANGUAGE: python\nCODE:\n```\nimport random\n\nnrows = 10000000\n\ndf1 = cudf.DataFrame({\"a\": cp.arange(nrows), \"b\": cp.arange(nrows)})\nddf1 = dask_cudf.from_cudf(df1, npartitions=100)\n\n\ndef func(df):\n    time.sleep(random.randint(1, 10))\n    return (df + 5) * 3 - 11\n```\n\n----------------------------------------\n\nTITLE: Displaying Results from DataFrame After Kernel Execution\nDESCRIPTION: Displays the head of the modified DataFrame after executing the Numba kernel, showcasing the result of the multiplication operation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndf.head()\n```\n\n----------------------------------------\n\nTITLE: Converting Dask-cuDF Head to Pandas\nDESCRIPTION: Shows how to convert just the first few rows of a Dask-cuDF DataFrame to Pandas.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_64\n\nLANGUAGE: python\nCODE:\n```\nddf.head().to_pandas()\n```\n\n----------------------------------------\n\nTITLE: Using GPU Engine in Polars\nDESCRIPTION: Python code demonstrating how to use the GPU engine for executing Polars queries, including configuring device and memory resource.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_polars/docs/overview.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport polars as pl\n\nresult = q.collect(engine=\"gpu\")\n\n# Using GPUEngine with custom configuration\nresult = q.collect(engine=pl.GPUEngine(device=1, memory_resource=mr))\n\n# Debugging: Raise on failure instead of falling back to CPU\nresult = q.collect(engine=pl.GPUEngine(raise_on_fail=True))\n```\n\n----------------------------------------\n\nTITLE: Memory Management Configuration Note\nDESCRIPTION: Important note about CUDA Managed Memory limitations on Windows Subsystem for Linux (WSL2), explaining why cudf.pandas uses a non-managed pool allocator in this environment.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/how-it-works.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nCUDA Managed Memory on Windows, and more specifically Windows Subsystem for\nLinux (WSL2), does not support oversubscription,\nonly unified addressing. Furthermore, managed memory on WSL2 has undesirable\nperformance characteristics. Therefore, `cudf.pandas` uses a non-managed pool\nallocator on WSL2, so `cudf.pandas` is limited to the physical size of GPU memory.\n```\n\n----------------------------------------\n\nTITLE: GroupBy Rolling Average UDF\nDESCRIPTION: Implements a rolling average function for grouped DataFrame operations using CUDA kernels.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_28\n\nLANGUAGE: python\nCODE:\n```\ndef rolling_avg(e, rolling_avg_e):\n    win_size = 3\n    for i in range(cuda.threadIdx.x, len(e), cuda.blockDim.x):\n        if i < win_size - 1:\n            # If there is not enough data to fill the window,\n            # take the average to be NaN\n            rolling_avg_e[i] = np.nan\n        else:\n            total = 0\n            for j in range(i - win_size + 1, i + 1):\n                total += e[j]\n            rolling_avg_e[i] = total / win_size\n```\n\n----------------------------------------\n\nTITLE: Converting Dask-cuDF DataFrame to Pandas\nDESCRIPTION: Shows the recommended pattern for converting a Dask-cuDF DataFrame to pandas. First gets a small cuDF DataFrame using head() and then converts it to pandas to avoid high memory usage.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nddf.head().to_pandas()\n```\n\n----------------------------------------\n\nTITLE: Configuring Reduction Tests in CUDA DataFrame\nDESCRIPTION: Sets up tests for reduction operations in cuDF. This includes collect operations, exponentially weighted moving window (EWM), ranking, scanning, and segmented reductions. The configuration specifies to use 1 GPU and allocate 70% of test resources.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\nConfigureTest(\n  REDUCTIONS_TEST\n  reductions/collect_ops_tests.cpp\n  reductions/ewm_tests.cpp\n  reductions/host_udf_example_tests.cu\n  reductions/list_rank_test.cpp\n  reductions/rank_tests.cpp\n  reductions/reduction_tests.cpp\n  reductions/scan_tests.cpp\n  reductions/segmented_reduction_tests.cpp\n  reductions/tdigest_tests.cu\n  GPUS 1\n  PERCENT 70\n)\n```\n\n----------------------------------------\n\nTITLE: Modifying a cuDF Series with Copy-on-Write\nDESCRIPTION: This snippet presents an example of modifying a cuDF Series after creating a shallow copy. It highlights the behavior of copy-on-write by showing that a true copy is only made when a write operation is performed.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/copy-on-write.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> series[0:2] = 10\n>>> series\n0    10\n1    10\n2     3\n3     4\ndtype: int64\n>>> copied_series\n0    1\n1    2\n2    3\n3    4\ndtype: int64\n```\n\n----------------------------------------\n\nTITLE: Performing Row-wise Sum using CuPy\nDESCRIPTION: Converts a cuDF DataFrame to a CuPy array using dlpack, then performs a row-wise sum operation using CuPy's axis parameter, demonstrating interoperability advantages.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/cupy-interop.ipynb#2025-04-21_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nnew_arr = cupy_from_dlpack(reshaped_df.to_dlpack())\nnew_arr.sum(axis=1)\n```\n\n----------------------------------------\n\nTITLE: Creating Nullable Series in cuDF\nDESCRIPTION: Demonstrates how cuDF supports nullable series across all data types, with missing values represented by cudf.NA\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/pandas-comparison.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ns = cudf.Series([1, 2, cudf.NA])\n```\n\n----------------------------------------\n\nTITLE: Conditional NA Return UDF\nDESCRIPTION: UDF demonstrating conditional return of NA values based on arithmetic comparison.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ndef f(row):\n    x = row[\"a\"]\n    y = row[\"b\"]\n    if x + y > 3:\n        return cudf.NA\n    else:\n        return x + y\n```\n\n----------------------------------------\n\nTITLE: GroupBy Custom Formula UDF\nDESCRIPTION: Defines a user-defined function that performs a custom calculation on grouped data using key and value columns.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/performance-comparisons/performance-comparisons.ipynb#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef custom_formula_udf(df):\n    df[\"out\"] = df[\"key\"] * df[\"val\"] - 10\n    return df\n```\n\n----------------------------------------\n\nTITLE: Creating Categorical Data in cuDF\nDESCRIPTION: Shows how to create a DataFrame with categorical columns, which are more memory-efficient for repeated string values.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_58\n\nLANGUAGE: python\nCODE:\n```\ngdf = cudf.DataFrame(\n    {\"id\": [1, 2, 3, 4, 5, 6], \"grade\": [\"a\", \"b\", \"b\", \"a\", \"a\", \"e\"]}\n)\ngdf[\"grade\"] = gdf[\"grade\"].astype(\"category\")\ngdf\n```\n\n----------------------------------------\n\nTITLE: Converting Full Dask-cuDF DataFrame to Pandas\nDESCRIPTION: Demonstrates how to compute the entire Dask-cuDF DataFrame and convert it to Pandas (not recommended for large datasets).\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_65\n\nLANGUAGE: python\nCODE:\n```\nddf.compute().to_pandas().head()\n```\n\n----------------------------------------\n\nTITLE: Data Manipulation Functions in cuDF\nDESCRIPTION: Collection of data manipulation functions for transforming and processing dataframes, including concatenation, pivoting, and factorization\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/api_docs/general_functions.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nconcat, crosstab, cut, factorize, get_dummies, melt, merge, pivot, pivot_table, unstack\n```\n\n----------------------------------------\n\nTITLE: Creating DataFrames from Different Sources\nDESCRIPTION: Shows how backend selection works when creating DataFrames from pandas and cuDF sources.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/dask_cudf/source/index.rst#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nimport pandas as pd\nimport cudf\n\n# This gives us a pandas-backed dataframe\ndd.from_pandas(pd.DataFrame({\"a\": range(10)}))\n\n# This gives us a cuDF-backed dataframe\ndd.from_pandas(cudf.DataFrame({\"a\": range(10)}))\n```\n\n----------------------------------------\n\nTITLE: Creating Large Random DataFrame with Pandas\nDESCRIPTION: Creates a large pandas DataFrame with random integer data containing 25 million rows and 12 columns. Uses NumPy's random number generator with a fixed seed for reproducibility.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf/cudf_pandas_tests/data/repr_slow_down_test.ipynb#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport pandas as pd\n\nrng = np.random.default_rng(seed=0)\n\nnum_rows = 25_000_000\nnum_columns = 12\n\n# Create a DataFrame with random data\ndf = pd.DataFrame(\n    rng.integers(0, 100, size=(num_rows, num_columns)),\n    columns=[f\"Column_{i}\" for i in range(1, num_columns + 1)],\n)\n```\n\n----------------------------------------\n\nTITLE: Checking GPU Memory After Persisting Data\nDESCRIPTION: Shows how to check GPU memory usage after persisting a large DataFrame, with a sleep to ensure the operation completes.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_86\n\nLANGUAGE: python\nCODE:\n```\n# Sleep to ensure the persist finishes and shows in the memory usage\n!sleep 5; nvidia-smi\n```\n\n----------------------------------------\n\nTITLE: Using Generator Functions for Flexible Test Input Construction in Python\nDESCRIPTION: Example showing how to use generator functions instead of fixtures to create more flexible test input construction for different subsets of test cases.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/testing.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef get_values(predicate):\n    values = range(10)\n    yield from filter(predicate, values)\n\ndef test_evens():\n    for v in get_values(lambda x: x % 2 == 0):\n        # Execute test\n\ndef test_odds():\n    for v in get_values(lambda x: x % 2 == 1):\n        # Execute test\n```\n\n----------------------------------------\n\nTITLE: Creating a cuDF Series with Float32 Data Type\nDESCRIPTION: This snippet demonstrates how to create a cuDF Series using the float32 data type, a commonly used data type for floating-point numbers. It illustrates the initialization of a Series object and its resulting structure when printed. The code requires the 'cudf' library.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/data-types.md#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n>>> import cudf\n>>> s = cudf.Series([1, 2, 3], dtype=\"float32\")\n>>> s\n0    1.0\n1    2.0\n2    3.0\ndtype: float32\n```\n\n----------------------------------------\n\nTITLE: Verifying numpy array compatibility with cuDF pandas proxy arrays (Python)\nDESCRIPTION: This snippet demonstrates that cuDF pandas creates proxy arrays that subclass numpy.ndarray for compatibility. It shows how to verify this using an isinstance check, and explains the implications for performance due to potential device-to-host transfers.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/faq.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n%load_ext cudf.pandas\nimport pandas as pd\nimport numpy as np\n\narr = pd.Series([1, 1, 2]).unique() # returns a proxy array\nisinstance(arr, np.ndarray) # returns True, where arr is a proxy array\n```\n\n----------------------------------------\n\nTITLE: Null-Handling GPU Kernel\nDESCRIPTION: GPU kernel demonstrating null value handling in parallel operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_23\n\nLANGUAGE: python\nCODE:\n```\ndef gpu_add(a, b, out):\n    for i, (x, y) in enumerate(zip(a, b)):\n        out[i] = x + y\n```\n\n----------------------------------------\n\nTITLE: Creating Typed Test Suite in C++\nDESCRIPTION: Demonstrates how to create a typed test suite using templates to run tests across multiple data types. Uses custom cudf type list implementation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/TESTING.md#2025-04-21_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\ntemplate <typename T>\nclass TypedTestFixture : cudf::test::BaseFixture {...};\nusing TestTypes = cudf::test:Types<int,float,double>;\nTYPED_TEST_SUITE(TypedTestFixture, TestTypes);\nTYPED_TEST(TypedTestFixture, FirstTest){\n    using T = TypeParam;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Rolling Window Tests in CMake\nDESCRIPTION: Sets up tests for rolling window operations including collection operations, grouped rolling, lead/lag, nth element, offset row windows, and range bounds functionality.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_31\n\nLANGUAGE: CMake\nCODE:\n```\n# ##################################################################################################\n# * rolling tests ---------------------------------------------------------------------------------\nConfigureTest(\n  ROLLING_TEST\n  rolling/collect_ops_test.cpp\n  rolling/empty_input_test.cpp\n  rolling/grouped_rolling_range_test.cpp\n  rolling/grouped_rolling_test.cpp\n  rolling/lead_lag_test.cpp\n  rolling/nth_element_test.cpp\n  rolling/offset_row_window_test.cpp\n  rolling/range_comparator_test.cu\n  rolling/range_rolling_window_test.cpp\n  rolling/range_window_bounds_test.cpp\n  rolling/range_window_type_test.cpp\n  rolling/rolling_test.cpp\n  GPUS 1\n  PERCENT 70\n)\n```\n\n----------------------------------------\n\nTITLE: Creating cuDF MultiIndex\nDESCRIPTION: Creates a `cudf.MultiIndex` from a list of tuples. MultiIndex allows for hierarchical indexing of DataFrames.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_26\n\nLANGUAGE: python\nCODE:\n```\narrays = [[\"a\", \"a\", \"b\", \"b\"], [1, 2, 3, 4]]\ntuples = list(zip(*arrays))\nidx = cudf.MultiIndex.from_tuples(tuples)\nidx\n```\n\n----------------------------------------\n\nTITLE: Displaying Sparse DataFrame\nDESCRIPTION: Displays the first few rows of the sparse DataFrame that will be converted to a CuPy sparse matrix.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/cupy-interop.ipynb#2025-04-21_snippet_19\n\nLANGUAGE: python\nCODE:\n```\ndf.head()\n```\n\n----------------------------------------\n\nTITLE: Checking GPU Memory Usage\nDESCRIPTION: Executes the nvidia-smi command to display current GPU memory usage, showing the state before forcing computation of the lazy Dask operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_55\n\nLANGUAGE: python\nCODE:\n```\n!nvidia-smi\n```\n\n----------------------------------------\n\nTITLE: Complex Arithmetic UDF\nDESCRIPTION: Multi-column arithmetic operation with modulo and division operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_19\n\nLANGUAGE: python\nCODE:\n```\ndef f(row):\n    return row[\"a\"] + (row[\"b\"] - (row[\"c\"] / row[\"d\"])) % row[\"e\"]\n```\n\n----------------------------------------\n\nTITLE: Performance Testing Utility Function\nDESCRIPTION: Defines a helper function to measure and compare execution times between pandas and cuDF operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/performance-comparisons/performance-comparisons.ipynb#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef timeit_pandas_cudf(pd_obj, gd_obj, func, **kwargs):\n    \"\"\"\n    A utility function to measure execution time of an\n    API(`func`) in pandas & cudf.\n\n    Parameters\n    ----------\n    pd_obj : Pandas object\n    gd_obj : cuDF object\n    func : callable\n    \"\"\"\n    pandas_time = timeit.timeit(lambda: func(pd_obj), **kwargs)\n    cudf_time = timeit.timeit(lambda: func(gd_obj), **kwargs)\n    return pandas_time, cudf_time\n```\n\n----------------------------------------\n\nTITLE: Defining a String Processing Function\nDESCRIPTION: Defines a function for processing strings, which applies several conditions based on the content of the strings in the Series.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef f(st):\\n    if len(st) > 0:\\n        if st.startswith(\"a\"):\\n            return 1\\n        elif \"example\" in st:\\n            return 2\\n        else:\\n            return -1\\n    else:\\n        return 42\n```\n\n----------------------------------------\n\nTITLE: Converting CuPy Array to cuDF DataFrame\nDESCRIPTION: This snippet converts a CuPy array (`reshaped_arr`) to a cuDF DataFrame using the cuDF DataFrame constructor. It also measures the time taken for the conversion.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/cupy-interop.ipynb#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n%timeit reshaped_df = cudf.DataFrame(reshaped_arr)\n```\n\n----------------------------------------\n\nTITLE: Enabling Copy-on-Write via Environment Variable\nDESCRIPTION: This snippet shows how to enable the copy-on-write functionality by setting the environment variable `CUDF_COPY_ON_WRITE` to `1` before starting the Python interpreter. This method allows for enabling the setting at the system level.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/copy-on-write.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport CUDF_COPY_ON_WRITE=\"1\" python -c \"import cudf\"\n```\n\n----------------------------------------\n\nTITLE: Data Type Conversion Functions in cuDF\nDESCRIPTION: Utility functions for converting between different data representations and types, supporting conversions from pandas and DLPack formats\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/api_docs/general_functions.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nto_numeric, from_dlpack, from_pandas\n```\n\n----------------------------------------\n\nTITLE: Documenting Function Parameters in CUDF\nDESCRIPTION: Example showing proper format for documenting function parameters with input/output specifications.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DOCUMENTATION.md#2025-04-21_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n*\n* @param[in]     first  This parameter is an input parameter to the function\n* @param[in,out] second This parameter is used both as an input and output\n* @param[out]    third  This parameter is an output of the function\n*\n```\n\n----------------------------------------\n\nTITLE: Dropping Labels with dropna in cudf in Python\nDESCRIPTION: Demonstrates the use of `dropna()` to remove axis labels containing missing data in a cudf DataFrame. The examples show how `dropna()` can operate across different axes, removing null-containing labels from Series and DataFrames.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/missing-data.ipynb#2025-04-21_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\ndf1.dropna(axis=0)\n```\n\nLANGUAGE: Python\nCODE:\n```\ndf1.dropna(axis=1)\n```\n\nLANGUAGE: Python\nCODE:\n```\ndf1[\"a\"].dropna()\n```\n\n----------------------------------------\n\nTITLE: Installing cuDF via conda in Bash\nDESCRIPTION: This command installs cuDF using conda from the rapidsai channel, specifying the version, Python version, and CUDA version.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/README.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nconda install -c rapidsai -c conda-forge -c nvidia \\\n    cudf=25.06 python=3.12 cuda-version=12.8\n```\n\n----------------------------------------\n\nTITLE: String Case Analysis UDF\nDESCRIPTION: Implements a user-defined function to check if a string is uppercase and return a binary classification.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/performance-comparisons/performance-comparisons.ipynb#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef str_isupper_udf(row):\n    if row.isupper():\n        return 0\n    else:\n        return 1\n```\n\n----------------------------------------\n\nTITLE: Calculate Sum and Product of Null Series in cudf with Python\nDESCRIPTION: Demonstrates calculating the sum and product of Series with all-NA or empty values. By default, the sum is 0 and the product is 1, illustrating null handling with the `skipna` flag in cudf.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/missing-data.ipynb#2025-04-21_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\ncudf.Series([np.nan], nan_as_null=False).sum()\n```\n\nLANGUAGE: Python\nCODE:\n```\ncudf.Series([np.nan], nan_as_null=False).sum(skipna=False)\n```\n\nLANGUAGE: Python\nCODE:\n```\ncudf.Series([], dtype=\"float64\").sum()\n```\n\nLANGUAGE: Python\nCODE:\n```\ncudf.Series([np.nan], nan_as_null=False).prod()\n```\n\nLANGUAGE: Python\nCODE:\n```\ncudf.Series([np.nan], nan_as_null=False).prod(skipna=False)\n```\n\nLANGUAGE: Python\nCODE:\n```\ncudf.Series([], dtype=\"float64\").prod()\n```\n\n----------------------------------------\n\nTITLE: Creating RAPIDS cuDF NLP Modules using Cython\nDESCRIPTION: This snippet uses the rapids_cython_create_modules function to generate the NLP modules. It specifies the source files, linked libraries, module prefix, and associated targets. The resulting modules will be C++ extensions compiled from the Cython sources.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/pylibcudf/nvtext/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nrapids_cython_create_modules(\n  CXX\n  SOURCE_FILES \"${cython_sources}\"\n  LINKED_LIBRARIES \"${linked_libraries}\" MODULE_PREFIX pylibcudf_nvtext_ ASSOCIATED_TARGETS cudf\n)\n```\n\n----------------------------------------\n\nTITLE: Accessing String Elements from a strings_column_view in CUDF C++\nDESCRIPTION: This snippet demonstrates how to safely access string elements from a strings_column_view using column_device_view. It shows proper null checking before accessing an element and obtaining a string_view instance.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_33\n\nLANGUAGE: c++\nCODE:\n```\n   cudf::strings_column_view scv;\n   auto d_strings = cudf::column_device_view::create(scv.parent(), stream);\n   ...\n   if( d_strings.is_valid(row_index) ) {\n      string_view d_str = d_strings.element<string_view>(row_index);\n      ...\n   }\n```\n\n----------------------------------------\n\nTITLE: Creating a Dask cuDF DataFrame from cuDF DataFrame\nDESCRIPTION: Converts a `cudf.DataFrame` to a `dask_cudf.DataFrame` with two partitions. The `head()` method is used to inspect the first few rows.  This illustrates how to distribute a cuDF DataFrame across multiple GPUs using Dask cuDF.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nddf = dask_cudf.from_cudf(df, npartitions=2)\nddf.head()\n```\n\n----------------------------------------\n\nTITLE: Importing cuDF and CuPy\nDESCRIPTION: Imports the necessary libraries: cudf for DataFrame manipulation and cupy (as cp) for GPU array operations. It also checks CuPy version and uses the appropriate function for dlpack conversion.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/cupy-interop.ipynb#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cudf\nimport cupy as cp\nfrom packaging import version\n\nif version.parse(cp.__version__) >= version.parse(\"10.0.0\"):\n    cupy_from_dlpack = cp.from_dlpack\nelse:\n    cupy_from_dlpack = cp.fromDlpack\n```\n\n----------------------------------------\n\nTITLE: Converting Sparse cuDF DataFrame to CuPy Sparse Matrix\nDESCRIPTION: Converts the sparse cuDF DataFrame `df` to a CuPy sparse matrix using the `cudf_to_cupy_sparse_matrix` function and prints the resulting sparse matrix to the console.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/cupy-interop.ipynb#2025-04-21_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nsparse_data = cudf_to_cupy_sparse_matrix(df)\nprint(sparse_data)\n```\n\n----------------------------------------\n\nTITLE: Installing cuDF via conda with specific versions\nDESCRIPTION: Command for installing cuDF via conda, specifying the version of cuDF, Python, and CUDA. Uses multiple channels including rapidsai, conda-forge, and nvidia.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf/README.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nconda install -c rapidsai -c conda-forge -c nvidia \\\n    cudf=25.06 python=3.12 cuda-version=12.8\n```\n\n----------------------------------------\n\nTITLE: Creating a cuDF Series with Decimal Data Types\nDESCRIPTION: This snippet illustrates how to create a cuDF Series with decimal values using the Decimal data type for higher precision. It includes an example of using the 'Decimal' class from Python's decimal library. The resulting Series shows the precision and scale of its numeric values. The code requires 'cudf' and 'decimal' libraries.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/data-types.md#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n>>> from decimal import Decimal\n>>> s = cudf.Series([Decimal(\"1.01\"), Decimal(\"4.23\"), Decimal(\"0.5\")])\n>>> s\n0    1.01\n1    4.23\n2    0.50\ndtype: decimal128\n>>> s.dtype\nDecimal128Dtype(precision=3, scale=2)\n```\n\n----------------------------------------\n\nTITLE: Sample DataFrame for Rolling Window Example in cuDF\nDESCRIPTION: Shows the structure of a sample DataFrame used for demonstrating rolling window calculations with GroupBy. The DataFrame contains three columns 'a', 'b', and 'c' with numeric values.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/groupby.md#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> df\n   a  b  c\n0  1  1  1\n1  1  1  2\n2  1  2  3\n3  2  2  4\n4  2  3  5\n```\n\n----------------------------------------\n\nTITLE: Creating and Converting cudf::column Objects in C++\nDESCRIPTION: Demonstrates the creation, copying, moving, and conversion of cudf::column objects. Shows how to create deep copies and move contents between columns, as well as implicit conversion to non-owning views.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\ncudf::column col{...};\n\ncudf::column copy{col}; // Copies the contents of `col`\ncudf::column const moved_to{std::move(col)}; // Moves contents from `col`\n\ncolumn_view v = moved_to; // Implicit conversion to non-owning column_view\n// mutable_column_view m = moved_to; // Cannot create mutable view to const column\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Copy-on-Write Behavior with Series Modification\nDESCRIPTION: Shows how modifying one Series triggers a copy operation, changing its memory address while leaving other copies unchanged. Illustrates the lazy copying mechanism of copy-on-write.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/library_design.md#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> s2[0:2] = 10\n>>> s2\n0    10\n1    10\n2     3\n3     4\ndtype: int64\n>>> s1\n0    1\n1    2\n2    3\n3    4\ndtype: int64\n>>> s3\n0    1\n1    2\n2    3\n3    4\ndtype: int64\n\n>>> s1.data._ptr\n139796315897856\n>>> s3.data._ptr\n139796315897856\n>>> s2.data._ptr\n139796315899392\n```\n\n----------------------------------------\n\nTITLE: Debugging Python Scripts with CUDA Tools\nDESCRIPTION: Commands to debug Python scripts using cuda-gdb and compute-sanitizer (cuda-memcheck) tools.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/CONTRIBUTING.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ncuda-gdb -ex r --args python <program_name>.py <program_arguments>\n```\n\nLANGUAGE: bash\nCODE:\n```\ncompute-sanitizer --tool memcheck python <program_name>.py <program_arguments>\n```\n\n----------------------------------------\n\nTITLE: Selecting Rows by Index Slice in cuDF Series\nDESCRIPTION: Selects rows from index 3 up to (and including) 4 from a `cudf.Series` using direct index access. This selects a slice of elements based on their index.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ns[3:5]\n```\n\n----------------------------------------\n\nTITLE: String Methods in Dask cuDF Series\nDESCRIPTION: Creates a `dask_cudf.Series` from a cudf series of strings and converts them to lowercase using the `str.lower()` method, then displaying the first 4 results using head().\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_40\n\nLANGUAGE: python\nCODE:\n```\nds = dask_cudf.from_cudf(s, npartitions=2)\nds.str.lower().head(n=4)\n```\n\n----------------------------------------\n\nTITLE: Initializing Data Analysis Environment\nDESCRIPTION: Sets up the required imports and displays cuDF version information for performance comparison testing.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/performance-comparisons/performance-comparisons.ipynb#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport timeit\n\nimport cudf\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\nprint(f\"{cudf.__version__=}\")\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Wrapped and Proxy Types in cuDF Pandas\nDESCRIPTION: Shows how to create and check wrapped objects and proxy objects using cuDF and Pandas. Demonstrates the difference between direct library objects and proxy objects.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/cudf_pandas.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cudf.pandas\ncudf.pandas.install()\nimport pandas as xpd\n\ncudf = xpd._fsproxy_fast\npd = xpd._fsproxy_slow\n\ns1 = cudf.Series([1,2])\ns2 = pd.Series([1,2])\ns3 = xpd.Series([1,2])\n\nfrom cudf.pandas import is_proxy_object\n\nis_proxy_object(s1) # returns False\n\nis_proxy_object(s2) # returns False\n\nis_proxy_object(s3) # returns True\n```\n\n----------------------------------------\n\nTITLE: Configuring Text Processing Stream Tests\nDESCRIPTION: Configuration of text processing tests including BPE tokenization, edit distance calculation, n-grams generation, and text manipulation operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_53\n\nLANGUAGE: cmake\nCODE:\n```\nConfigureTest(\n  STREAM_TEXT_TEST\n  streams/text/bpe_test.cpp\n  streams/text/edit_distance_test.cpp\n  streams/text/ngrams_test.cpp\n  streams/text/replace_test.cpp\n  streams/text/stemmer_test.cpp\n  streams/text/tokenize_test.cpp\n  STREAM_MODE\n  testing\n)\n```\n\n----------------------------------------\n\nTITLE: Selecting Rows by Index Slice in cuDF DataFrame\nDESCRIPTION: Selects rows from index 3 up to (and including) 4 from a `cudf.DataFrame` using direct index access. This selects a slice of rows based on their index.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndf[3:5]\n```\n\n----------------------------------------\n\nTITLE: Type Dispatcher Implementation Example\nDESCRIPTION: This example demonstrates a simplified implementation of a type dispatcher. It showcases how the `type_dispatcher` function maps a `data_type` to a concrete C++ type based on the `data_type::id()`, invoking the corresponding instantiation of the `operator()` template within the function object `F`.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_26\n\nLANGUAGE: c++\nCODE:\n```\ntemplate <typename F>\nvoid type_dispatcher(data_type t, F f){\n    switch(t.id())\n       case type_id::INT32: f.template operator()<int32_t>()\n       case type_id::INT64: f.template operator()<int64_t>()\n       case type_id::FLOAT: f.template operator()<float>()\n       ...\n}\n```\n\n----------------------------------------\n\nTITLE: Converting CuPy Array to Fortran Contiguous Array and then to cuDF DataFrame\nDESCRIPTION: Converts a CuPy array to a Fortran contiguous array using `cp.asfortranarray` and then creates a cuDF DataFrame from the Fortran contiguous array. Measures the time taken using the cell magic `%%timeit`.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/cupy-interop.ipynb#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n%%timeit\n\nfortran_arr = cp.asfortranarray(reshaped_arr)\nreshaped_df = cudf.DataFrame(fortran_arr)\n```\n\n----------------------------------------\n\nTITLE: Installing cuDF via pip for CUDA 11.x\nDESCRIPTION: Command for installing cuDF via pip for environments with CUDA 11.x. Uses NVIDIA's Python Package Index as an additional source.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install --extra-index-url=https://pypi.nvidia.com cudf-cu11\n```\n\n----------------------------------------\n\nTITLE: Detail Namespace Example in libcudf\nDESCRIPTION: This code snippet illustrates the use of the `detail` namespace for functions that are used across multiple translation units within libcudf.  Helper functions that are not part of the public API but need to be accessible in multiple source files should be placed in the `cudf::detail` namespace.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_20\n\nLANGUAGE: c++\nCODE:\n```\n// some_utilities.hpp\nnamespace cudf{\nnamespace detail{\nvoid reusable_helper_function(...);\n} // namespace detail\n} // namespace cudf\n\n```\n\n----------------------------------------\n\nTITLE: Transposing a cuDF DataFrame\nDESCRIPTION: Demonstrates the transpose operation on a cuDF DataFrame, which swaps rows and columns. The transpose method requires all columns to have the same data type.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nsample.transpose()\n```\n\n----------------------------------------\n\nTITLE: Installing cuDF via pip for CUDA 12.x\nDESCRIPTION: Command for installing cuDF via pip for environments with CUDA 12.x. Uses NVIDIA's Python Package Index as an additional source.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf/README.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npip install --extra-index-url=https://pypi.nvidia.com cudf-cu12\n```\n\n----------------------------------------\n\nTITLE: Using Structured Binding for Multiple Return Values in libcudf (C++17)\nDESCRIPTION: Shows how to use C++17 structured binding to handle multiple return values in libcudf, including a workaround for lambda captures.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\nauto [out0, out1] = cudf::return_two_outputs();\n\n// Direct capture of alias from structured binding might fail with:\n// \"error: structured binding cannot be captured\"\n// auto foo = [out0]() {...};\n\n// Use an initializing capture:\nauto foo = [&out0 = out0] {\n  // Use out0 to compute something.\n  // ...\n};\n```\n\n----------------------------------------\n\nTITLE: Extracting Diagonal Elements from CuPy Array\nDESCRIPTION: Extracts and displays the diagonal elements from a 2D CuPy array using the diagonal() method.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/cupy-interop.ipynb#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nreshaped_arr.diagonal()\n```\n\n----------------------------------------\n\nTITLE: Creating a Sparse DataFrame for Demonstration\nDESCRIPTION: Creates a cuDF DataFrame with sparse data by randomly generating values and setting most of them to zero, which will be used for sparse matrix conversion.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/cupy-interop.ipynb#2025-04-21_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ndf = cudf.DataFrame()\nnelem = 10000\nnonzero = 1000\nfor i in range(20):\n    arr = cp.random.normal(5, 5, nelem)\n    arr[cp.random.choice(arr.shape[0], nelem - nonzero, replace=False)] = 0\n    df[\"a\" + str(i)] = arr\n```\n\n----------------------------------------\n\nTITLE: Compiling and Executing a libcudf C++ Application with CMake\nDESCRIPTION: Commands for configuring, building, and executing a basic libcudf C++ application. The build process may take time if libcudf is not pre-built on the system.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/examples/basic/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Configure project\ncmake -S . -B build/\n# Build\ncmake --build build/ --parallel $PARALLEL_LEVEL\n# Execute\nbuild/basic_example\n```\n\n----------------------------------------\n\nTITLE: Accessing cuDF DataFrame with MultiIndex using .iloc\nDESCRIPTION: Accesses a slice of rows from a `cudf.DataFrame` with a `cudf.MultiIndex` using `.iloc`. This demonstrates how to select data based on MultiIndex positions.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_30\n\nLANGUAGE: python\nCODE:\n```\ngdf1.iloc[0:2]\n```\n\n----------------------------------------\n\nTITLE: Concatenating Dask cuDF Series\nDESCRIPTION: Concatenates a `dask_cudf.Series` with itself using the `dask_cudf.concat` method, and displays the first three values using head(). This combines distributed series.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_44\n\nLANGUAGE: python\nCODE:\n```\nds2 = dask_cudf.from_cudf(s, npartitions=2)\ndask_cudf.concat([ds2, ds2]).head(n=3)\n```\n\n----------------------------------------\n\nTITLE: Reshaping CuPy Array\nDESCRIPTION: Reshapes a 1D CuPy array into a 2D array with dimensions 50×200 and displays the result.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/cupy-interop.ipynb#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nreshaped_arr = cola_cupy.reshape(50, 200)\nreshaped_arr\n```\n\n----------------------------------------\n\nTITLE: Implementing Two-Type Test Fixture in C++\nDESCRIPTION: Shows how to create a test fixture that handles two-type combinations using nested type lists and GetType utility.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/TESTING.md#2025-04-21_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\ntemplate <typename TwoTypes>\nTwoTypesFixture : cudf::test::BaseFixture{...};\nusing TwoTypesList = Types< Types<int, int>, Types<int, float>,\n                            Types<float, int>, Types<float, float> >;\nTYPED_TEST_SUITE(TwoTypesFixture, TwoTypesList);\nTYPED_TEST(TwoTypesFixture, FirstTest){\n    using FirstType = GetType<TypeParam,0>;\n    using SecondType = GetType<TypeParam,1>;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring NVText Test with C++\nDESCRIPTION: This snippet organizes tests related to NVText functionalities in CUDF, covering various text processing techniques. It ensures comprehensive testing of textual data handling within CUDF.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_42\n\nLANGUAGE: cpp\nCODE:\n```\nConfigureTest(\n  TEXT_TEST\n  text/bpe_tests.cpp\n  text/edit_distance_tests.cpp\n  text/jaccard_tests.cpp\n  text/minhash_tests.cpp\n  text/ngrams_tests.cpp\n  text/ngrams_tokenize_tests.cpp\n  text/normalize_tests.cpp\n  text/replace_tests.cpp\n  text/stemmer_tests.cpp\n  text/subword_tests.cpp\n  text/tokenize_tests.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a cuDF Series\nDESCRIPTION: Demonstrates the creation of a simple cuDF Series to be used for applying user-defined functions. The series is instantiated with integer values.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Create a cuDF series\\nsr = cudf.Series([1, 2, 3])\n```\n\n----------------------------------------\n\nTITLE: Using rmm::device_buffer for Memory Management in libcudf (C++)\nDESCRIPTION: Shows examples of using rmm::device_buffer for allocating, copying, and moving device memory in libcudf.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\n// Allocates at least 100 bytes of uninitialized device memory\n// using the specified resource and stream\nrmm::device_buffer buff(100, stream, mr);\nvoid * raw_data = buff.data(); // Raw pointer to underlying device memory\n\n// Deep copies `buff` into `copy` on `stream`\nrmm::device_buffer copy(buff, stream);\n\n// Moves contents of `buff` into `moved_to`\nrmm::device_buffer moved_to(std::move(buff));\n\ncustom_memory_resource *mr...;\n// Allocates 100 bytes from the custom_memory_resource\nrmm::device_buffer custom_buff(100, mr, stream);\n```\n\n----------------------------------------\n\nTITLE: Using rmm::device_uvector for Uninitialized Device Memory in libcudf (C++)\nDESCRIPTION: Shows how to use rmm::device_uvector for allocating uninitialized device memory and initializing it in libcudf.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\ncuda_stream s;\n// Allocates uninitialized storage for 100 `int32_t` elements on stream `s` using the\n// default resource\nrmm::device_uvector<int32_t> v(100, s);\n// Initializes the elements to 0\nthrust::uninitialized_fill(thrust::cuda::par.on(s.value()), v.begin(), v.end(), int32_t{0});\n\nauto mr = new my_custom_resource{...};\n// Allocates uninitialized storage for 100 `int32_t` elements on stream `s` using the resource `mr`\nrmm::device_uvector<int32_t> v2{100, s, mr};\n```\n\n----------------------------------------\n\nTITLE: Converting cuDF Series to NumPy Array\nDESCRIPTION: Shows how to convert a single column (Series) from a cuDF DataFrame to a NumPy ndarray.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_39\n\nLANGUAGE: python\nCODE:\n```\ndf[\"a\"].to_numpy()\n```\n\n----------------------------------------\n\nTITLE: Configuring GPUEngine with Custom Parquet Reader Options in Python\nDESCRIPTION: This snippet demonstrates how to configure the polars.GPUEngine object with custom Parquet reader options. It sets the chunked reader with specific values for pass_read_limit and chunk_read_limit to control memory usage during Parquet file reading.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_polars/engine_options.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nengine = GPUEngine(\n    parquet_options={\n        'chunked': True,\n        'chunk_read_limit': int(1e9),\n        'pass_read_limit': int(4e9)\n    }\n)\nresult = query.collect(engine=engine)\n```\n\n----------------------------------------\n\nTITLE: Anonymous Namespace Example in libcudf\nDESCRIPTION: This code demonstrates the use of an anonymous namespace for functions that are only used within a single translation unit. Helper functions which are not part of the public API and are only used within a specific source file should be placed in an anonymous namespace within that source file.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_21\n\nLANGUAGE: c++\nCODE:\n```\n// some_file.cpp\nnamespace{\nvoid isolated_helper_function(...);\n} // anonymous namespace\n\n```\n\n----------------------------------------\n\nTITLE: Assigning MultiIndex to cuDF DataFrame Index\nDESCRIPTION: Creates a `cudf.DataFrame` and assigns a `cudf.MultiIndex` to its index. This demonstrates how to use a MultiIndex to create a hierarchical index for a DataFrame.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_27\n\nLANGUAGE: python\nCODE:\n```\ngdf1 = cudf.DataFrame(\n    {\"first\": cp.random.rand(4), \"second\": cp.random.rand(4)}\n)\ngdf1.index = idx\ngdf1\n```\n\n----------------------------------------\n\nTITLE: Installing cuDF via Pip for CUDA 11.x in Bash\nDESCRIPTION: This command installs cuDF via pip for systems with CUDA 11.x. It uses the NVIDIA Python Package Index to fetch the appropriate cuDF package compatible with CUDA 11.x.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install --extra-index-url=https://pypi.nvidia.com cudf-cu11\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Interface with Spans in C++\nDESCRIPTION: Shows how to define a generic function using device_span for input parameters, allowing for flexibility with different input container types. The example copies device data to a host std::vector.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\ntemplate <typename T>\nstd::vector<T> make_std_vector_async(device_span<T const> v, rmm::cuda_stream_view stream)\n```\n\n----------------------------------------\n\nTITLE: Getting Diagonal of CuPy Array\nDESCRIPTION: Gets the diagonal of the reshaped CuPy array `reshaped_arr`. It relies on the CuPy array `reshaped_arr` from the previous snippet.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/cupy-interop.ipynb#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nreshaped_arr.diagonal()\n```\n\n----------------------------------------\n\nTITLE: Consuming CSV Data from Kafka with cuStreamz\nDESCRIPTION: Example showing how to consume CSV data from a Kafka topic named 'custreamz_tips' into a cuDF dataframe, then perform basic data transformations and aggregations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/custreamz/README.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom custreamz import kafka\n\n# Full list of configurations can be found at: https://github.com/edenhill/librdkafka/blob/master/CONFIGURATION.md\nkafka_configs = {\n    \"metadata.broker.list\": \"localhost:9092\",\n    \"group.id\": \"custreamz-client\",\n}\n\n# Create a reusable Kafka Consumer client; \"datasource\"\nconsumer = kafka.Consumer(kafka_configs)\n\n# Read 10,000 messages from `custreamz_tips` topic in CSV format.\ntips_df = consumer.read_gdf(topic=\"custreamz_tips\",\n                        partition=0,\n                        start=0,\n                        end=10000,\n                        message_format=\"csv\")\n\nprint(tips_df.head())\ntips_df['tip_percentage'] = tips_df['tip'] / tips_df['total_bill'] * 100\n\n# display average tip by dining party size\nprint(tips_df.groupby('size').tip_percentage.mean())\n```\n\n----------------------------------------\n\nTITLE: Checking GPU Memory Usage After Persist\nDESCRIPTION: Waits briefly to ensure the persist operation completes, then checks GPU memory usage to show the increased memory consumption from the persisted DataFrame.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_57\n\nLANGUAGE: python\nCODE:\n```\n# Sleep to ensure the persist finishes and shows in the memory usage\n!sleep 5; nvidia-smi\n```\n\n----------------------------------------\n\nTITLE: Accessing Categorical Values in cuDF\nDESCRIPTION: Shows how to access the unique categories in a categorical column using the cat.categories accessor. This operation is not currently supported in Dask-cuDF.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_31\n\nLANGUAGE: python\nCODE:\n```\ngdf.grade.cat.categories\n```\n\n----------------------------------------\n\nTITLE: Random DataFrame Groupby with Non-Deterministic Order\nDESCRIPTION: Demonstrates cuDF's default non-deterministic ordering in groupby operations compared to Pandas\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/pandas-comparison.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport cupy as cp\ncp.random.seed(0)\nimport cudf\ndf = cudf.DataFrame({'a': cp.random.randint(0, 1000, 1000), 'b': range(1000)})\ndf.groupby(\"a\").mean().head()\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Stream-Based Function in C++ for libcudf\nDESCRIPTION: Demonstrates the pattern for implementing a libcudf function with stream support, including the public API, detail implementation, and proper use of CUDA streams and memory resources.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\n// cpp/include/cudf/header.hpp\nvoid external_function(...,\n  rmm::cuda_stream_view stream      = cudf::get_default_stream(),\n  rmm::device_async_resource_ref mr = cudf::get_current_device_resource_ref());\n\n// cpp/include/cudf/detail/header.hpp\nnamespace detail{\nvoid external_function(..., rmm::cuda_stream_view stream, rmm::device_async_resource_ref mr)\n} // namespace detail\n\n// cudf/src/implementation.cpp\nnamespace detail{\n// Use the stream parameter in the detail implementation.\nvoid external_function(..., rmm::cuda_stream_view stream, rmm::device_async_resource_ref mr){\n  // Implementation uses the stream with async APIs.\n  rmm::device_buffer buff(..., stream, mr);\n  CUDF_CUDA_TRY(cudaMemcpyAsync(...,stream.value()));\n  kernel<<<..., stream>>>(...);\n  thrust::algorithm(rmm::exec_policy(stream), ...);\n}\n} // namespace detail\n\nvoid external_function(..., rmm::cuda_stream_view stream, rmm::device_async_resource_ref mr)\n{\n  CUDF_FUNC_RANGE(); // Generates an NVTX range for the lifetime of this function.\n  detail::external_function(..., stream, mr);\n}\n```\n\n----------------------------------------\n\nTITLE: Using CrossProduct Type Lists in C++\nDESCRIPTION: Example of using the CrossProduct utility to automatically generate combinations of type lists for testing.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/TESTING.md#2025-04-21_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nusing TwoTypesList = Types< Types<int, int>, Types<int, float>,\n                            Types<float, int>, Types<float, float> >;\nusing CrossProductTypeList = CrossProduct< Types<int, float>, Types<int, float> >;\n```\n\n----------------------------------------\n\nTITLE: Implementing Deprecation Warning in Python\nDESCRIPTION: Example of properly emitting a FutureWarning when deprecating an API in cuDF. Shows the standard format for deprecation messages, including suggesting alternatives.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/contributing_guide.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nwarnings.warn(\n    \"`Series.foo` is deprecated and will be removed in a future version of cudf. \"\n    \"Use `Series.new_foo` instead.\",\n    FutureWarning\n)\n```\n\n----------------------------------------\n\nTITLE: Offset Normalizing Input Iterator Usage Example\nDESCRIPTION: This code creates an input iterator from the offsets of a string column using `cudf::detail::offsetalator_factory`. It shows the usage of an input offsetalator to address the output row bytes after converting the sizes to offsets using `cudf::strings::detail::make_offsets_child_column`.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_17\n\nLANGUAGE: c++\nCODE:\n```\n  // convert the sizes to offsets\n  auto [offsets, char_bytes] = cudf::strings::detail::make_offsets_child_column(\n    output_sizes.begin(), output_sizes.end(), stream, mr);\n  auto d_offsets =\n    cudf::detail::offsetalator_factory::make_input_iterator(offsets->view());\n  // use d_offsets to address the output row bytes\n\n```\n\n----------------------------------------\n\nTITLE: Using rmm::device_scalar for Single-Element Device Memory in libcudf (C++)\nDESCRIPTION: Demonstrates the usage of rmm::device_scalar for allocating and managing single-element device memory in libcudf.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\n// Allocates device memory for a single int using the specified resource and stream\n// and initializes the value to 42\nrmm::device_scalar<int> int_scalar{42, stream, mr};\n\n// scalar.data() returns pointer to value in device memory\nkernel<<<...>>>(int_scalar.data(),...);\n\n// scalar.value() synchronizes the scalar's stream and copies the\n// value from device to host and returns the value\nint host_value = int_scalar.value();\n```\n\n----------------------------------------\n\nTITLE: Creating Dask DataFrame and Defining Transformation Function in Python\nDESCRIPTION: This snippet demonstrates the creation of a cuDF DataFrame, converting it to a Dask DataFrame, and defining a function that applies a transformation with random delays. The function will be used to process each partition of the Dask DataFrame.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_58\n\nLANGUAGE: python\nCODE:\n```\nimport random\n\nnrows = 10000000\n\ndf1 = cudf.DataFrame({\"a\": cp.arange(nrows), \"b\": cp.arange(nrows)})\nddf1 = dask_cudf.from_cudf(df1, npartitions=100)\n\n\ndef func(df):\n    time.sleep(random.randint(1, 10))\n    return (df + 5) * 3 - 11\n```\n\n----------------------------------------\n\nTITLE: Checking if an Object is a cudf.pandas Proxy\nDESCRIPTION: Demonstrates how to use the is_proxy_instance API to check if an object is a cudf.pandas proxy object that wraps either a cudf or pandas object.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/faq.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom cudf.pandas import is_proxy_instance\n\nobj = ...  # Your object here\nif is_proxy_instance(obj, pd.Series):\n    print(\"The object is a cudf.pandas proxy Series object.\")\nelse:\n    print(\"The object is not a cudf.pandas proxy Series object.\")\n```\n\n----------------------------------------\n\nTITLE: Testing Translation Failure Modes in Python\nDESCRIPTION: Test utility for verifying that unsupported features correctly raise exceptions during translation from Polars to cuDF.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_polars/docs/overview.md#2025-04-21_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom cudf_polars.testing.asserts import assert_ir_translation_raises\n\n\ndef test_whatever():\n    unsupported_query = ...\n    assert_ir_translation_raises(unsupported_query, NotImplementedError)\n```\n\n----------------------------------------\n\nTITLE: Accessing Categorical Column Codes in cuDF\nDESCRIPTION: Demonstrates how to access the underlying integer codes of a categorical column in cuDF.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_61\n\nLANGUAGE: python\nCODE:\n```\ngdf.grade.cat.codes\n```\n\n----------------------------------------\n\nTITLE: Installing cuDF with CUDA 12.x via pip\nDESCRIPTION: Command to install cuDF package for CUDA 12.x environments using pip package manager\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_polars/README.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npip install --extra-index-url=https://pypi.nvidia.com cudf-cu12\n```\n\n----------------------------------------\n\nTITLE: Running Python scripts with cudf.pandas from command line\nDESCRIPTION: Demonstrates how to run a Python script with cudf.pandas acceleration using the command line, which enables GPU acceleration without code changes.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/usage.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython -m cudf.pandas script.py\n```\n\n----------------------------------------\n\nTITLE: Modifying pandas Scripts to Use cudf.pandas in Python\nDESCRIPTION: Shows diff of changes made to pandas scripts to use cudf.pandas and remove unsupported arguments.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/benchmarks.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndiff --git a/pandas/groupby-pandas.py b/pandas/groupby-pandas.py\nindex 58eeb26..2ddb209 100755\n--- a/pandas/groupby-pandas.py\n+++ b/pandas/groupby-pandas.py\n@@ -1,4 +1,4 @@\n-#!/usr/bin/env python3\n+#!/usr/bin/env -S python3 -m cudf.pandas\n \n print(\"# groupby-pandas.py\", flush=True)\n \ndiff --git a/pandas/join-pandas.py b/pandas/join-pandas.py\nindex f39beb0..a9ad651 100755\n--- a/pandas/join-pandas.py\n+++ b/pandas/join-pandas.py\n@@ -1,4 +1,4 @@\n-#!/usr/bin/env python3\n+#!/usr/bin/env -S python3 -m cudf.pandas\n \n print(\"# join-pandas.py\", flush=True)\n \n@@ -26,7 +26,7 @@ if len(src_jn_y) != 3:\n \n print(\"loading datasets \" + data_name + \", \" + y_data_name[0] + \", \" + y_data_name[1] + \", \" + y_data_name[2], flush=True)\n \n-x = pd.read_csv(src_jn_x, engine='pyarrow', dtype_backend='pyarrow')\n+x = pd.read_csv(src_jn_x, engine='pyarrow')\n \n # x['id1'] = x['id1'].astype('Int32')\n # x['id2'] = x['id2'].astype('Int32')\n@@ -35,17 +35,17 @@ x['id4'] = x['id4'].astype('category') # remove after datatable#1691\n x['id5'] = x['id5'].astype('category')\n x['id6'] = x['id6'].astype('category')\n \n-small = pd.read_csv(src_jn_y[0], engine='pyarrow', dtype_backend='pyarrow')\n+small = pd.read_csv(src_jn_y[0], engine='pyarrow')\n # small['id1'] = small['id1'].astype('Int32')\n small['id4'] = small['id4'].astype('category')\n # small['v2'] = small['v2'].astype('float64')\n-medium = pd.read_csv(src_jn_y[1], engine='pyarrow', dtype_backend='pyarrow')\n+medium = pd.read_csv(src_jn_y[1], engine='pyarrow')\n # medium['id1'] = medium['id1'].astype('Int32')\n # medium['id2'] = medium['id2'].astype('Int32')\n medium['id4'] = medium['id4'].astype('category')\n medium['id5'] = medium['id5'].astype('category')\n # medium['v2'] = medium['v2'].astype('float64')\n-big = pd.read_csv(src_jn_y[2], engine='pyarrow', dtype_backend='pyarrow')\n+big = pd.read_csv(src_jn_y[2], engine='pyarrow')\n # big['id1'] = big['id1'].astype('Int32')\n # big['id2'] = big['id2'].astype('Int32')\n # big['id3'] = big['id3'].astype('Int32')\n```\n\n----------------------------------------\n\nTITLE: Applying Conditional xfail Markers in Parametrized Tests in Python\nDESCRIPTION: Demonstrates how to conditionally mark specific parameter combinations as expected to fail using request.applymarker() with pytest.mark.xfail. This pattern allows tests to continue running even for failing conditions, helping detect when bugs are fixed.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/testing.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@pytest.mark.parametrize(\"v1\", [1, 2, 3])\n@pytest.mark.parametrize(\"v2\", [1, 2, 3])\ndef test_sum_lt_6(request, v1, v2):\n    request.applymarker(\n        pytest.mark.xfail(\n            condition=(v1 == 3 and v2 == 3),\n            reason=\"Add comment linking to relevant issue\",\n        )\n    )\n    assert v1 + v2 < 6\n```\n\n----------------------------------------\n\nTITLE: Setting Memory Size for String UDFs\nDESCRIPTION: Sets an upper limit on memory allocation for string UDFs using cuDF to prevent memory issues when handling large intermediate string data.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom cudf.core.udf.utils import set_malloc_heap_size\\n\\nset_malloc_heap_size(int(2e9))\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Scalar Function\nDESCRIPTION: Defines a basic scalar function that will be used with the apply method on a cuDF Series. The function increments its input by 1.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# define a scalar function\\n\\ndef f(x):\\n    return x + 1\n```\n\n----------------------------------------\n\nTITLE: Accessing Underlying GPU or CPU Objects from cudf.pandas\nDESCRIPTION: Shows how to access the true cudf or pandas objects from cudf.pandas proxy objects using as_gpu_object() and as_cpu_object() methods when working with GPU-aware libraries.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/faq.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Assuming `proxy_obj` is a cudf.pandas proxy object\ncudf_obj = proxy_obj.as_gpu_object()\npandas_obj = proxy_obj.as_cpu_object()\n\n# Now you can use `cudf_obj` and `pandas_obj` with libraries that are cudf or pandas aware\n```\n\n----------------------------------------\n\nTITLE: Specializing Type-Dispatched Code Paths with SFINAE\nDESCRIPTION: This snippet demonstrates how to use SFINAE with `std::enable_if_t` to partially specialize type-dispatched code paths for sets of types with common traits. The `integral_or_floating_point` struct showcases how to print different messages based on whether the type is integral, floating-point, or neither.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_30\n\nLANGUAGE: c++\nCODE:\n```\nstruct integral_or_floating_point {\ntemplate <typename ColumnType,\n          std::enable_if_t<not std::is_integral<ColumnType>::value and\n                           not std::is_floating_point<ColumnType>::value>* = nullptr>\nvoid operator()() { std::cout << \"neither integral nor floating point\\n\"; }\n\ntemplate <typename ColumnType,\n          std::enable_if_t<std::is_integral<ColumnType>::value>* = nullptr>\nvoid operator()() { std::cout << \"integral\\n\"; }\n\ntemplate < typename ColumnType,\n           std::enable_if_t<std::is_floating_point<ColumnType>::value>* = nullptr>\nvoid operator()() { std::cout << \"floating point\\n\"; }\n};\n```\n\n----------------------------------------\n\nTITLE: Comparing Null Handling in Categorical Series\nDESCRIPTION: Illustrates the difference in null value handling between cuDF and Pandas for categorical series\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/pandas-comparison.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ns = cudf.Series([1, 2, cudf.NA], dtype=\"category\")\ns = pd.Series([1, 2, pd.NA], dtype=\"category\")\n```\n\n----------------------------------------\n\nTITLE: Creating struct columns using column wrapper objects in CUDF\nDESCRIPTION: This example shows how to create a struct column directly from column wrapper objects without first releasing them as separate columns, providing validity through an initializer list.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/TESTING.md#2025-04-21_snippet_10\n\nLANGUAGE: c++\nCODE:\n```\n// The following constructs a column for struct< int, string >.\ncudf::test::fixed_width_column_wrapper<int32_t> child_int_col_wrapper{ 1, 2, 3, 4, 5 };\ncudf::test::string_column_wrapper child_string_col_wrapper {\"All\", \"the\", \"leaves\", \"are\", \"brown\"};\n\ncudf::test::struct_column_wrapper wrapper{\n  {child_int_col_wrapper, child_string_col_wrapper}\n  {1,0,1,0,1} // Validity\n};\n\nauto struct_col {wrapper.release()};\n```\n\n----------------------------------------\n\nTITLE: Creating a Sample DataFrame for Transposition\nDESCRIPTION: Creates a simple cuDF DataFrame to demonstrate the transpose operation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_54\n\nLANGUAGE: python\nCODE:\n```\nsample = cudf.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\nsample\n```\n\n----------------------------------------\n\nTITLE: Creating struct columns with iterator-based validity in CUDF\nDESCRIPTION: This example demonstrates creating a struct column using column wrappers and providing validity through a transform iterator that can dynamically compute which rows are valid.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/TESTING.md#2025-04-21_snippet_11\n\nLANGUAGE: c++\nCODE:\n```\n// The following constructs a column for struct< int, string >.\ncudf::test::fixed_width_column_wrapper<int32_t> child_int_col_wrapper{ 1, 2, 3, 4, 5 };\ncudf::test::string_column_wrapper child_string_col_wrapper {\"All\", \"the\", \"leaves\", \"are\", \"brown\"};\n\ncudf::test::struct_column_wrapper wrapper{\n  {child_int_col_wrapper, child_string_col_wrapper}\n  cudf::detail::make_counting_transform_iterator(0, [](auto i){ return i % 2; }) // Validity\n};\n\nauto struct_col {wrapper.release()};\n```\n\n----------------------------------------\n\nTITLE: Public API Namespace Example in libcudf\nDESCRIPTION: This code demonstrates how to define a public API function within the `cudf` namespace.  All public facing functions in libcudf should reside within this namespace. This example illustrates a simple function declaration within the `cudf` namespace.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_19\n\nLANGUAGE: c++\nCODE:\n```\nnamespace cudf{\n   void public_function(...);\n} // namespace cudf\n\n```\n\n----------------------------------------\n\nTITLE: Performance Visualization Function\nDESCRIPTION: Creates a bar plot to visualize performance comparisons between cuDF and pandas operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/performance-comparisons/performance-comparisons.ipynb#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef performance_plot(df, xlabel=None):\n    # ylim is 20% above max value\n    ylim_max = df[\"cudf speedup vs. pandas\"].max() + (\n        df[\"cudf speedup vs. pandas\"].max() / 20\n    )\n    ax = df.plot.bar(\n        color=\"#7400ff\",\n        ylim=(1, ylim_max),\n        rot=0,\n        xlabel=xlabel,\n        ylabel=\"Speedup factor\",\n    )\n    ax.bar_label(ax.containers[0], fmt=\"%.0f\")\n    plt.show()\n```\n\n----------------------------------------\n\nTITLE: Fixing Duration Components Calculation in cuDF (Python)\nDESCRIPTION: An issue with incorrect calculation of duration components has been fixed. This snippet demonstrates the old and new behavior of the dt.components attribute for timedelta Series.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/pandas-2.0-breaking-changes.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nIn [18]: sr = cudf.Series([136457654736252, 134736784364431, 245345345545332, 223432411, 2343241, 3634548734, 23234], dtype='timedelta64[ms]')\n\nIn [19]: sr\nOut[19]:\n0    1579371 days 00:05:36.252\n1    1559453 days 12:32:44.431\n2    2839645 days 04:52:25.332\n3          2 days 14:03:52.411\n4          0 days 00:39:03.241\n5         42 days 01:35:48.734\n6          0 days 00:00:23.234\ndtype: timedelta64[ms]\n\nIn [21]: sr.dt.components\nOut[21]:\n    days  hours  minutes  seconds  milliseconds  microseconds  nanoseconds\n0  84843      3        3       40           285           138          688\n1  64925     15       30       48           464           138          688\n2  64093     10       23        7           107           828          992\n3      2     14        3       52           411             0            0\n4      0      0       39        3           241             0            0\n5     42      1       35       48           734             0            0\n6      0      0        0       23           234             0            0\n```\n\nLANGUAGE: python\nCODE:\n```\nIn [21]: sr.dt.components\nOut[21]:\n      days  hours  minutes  seconds  milliseconds  microseconds  nanoseconds\n0  1579371      0        5       36           252             0            0\n1  1559453     12       32       44           431             0            0\n2  2839645      4       52       25           332             0            0\n3        2     14        3       52           411             0            0\n4        0      0       39        3           241             0            0\n5       42      1       35       48           734             0            0\n6        0      0        0       23           234             0            0\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Inconsistencies without Copy-on-Write\nDESCRIPTION: This snippet compares the behavior of cuDF and pandas with respect to slicing and modification when copy-on-write is not enabled. It shows how modifications in one instance affect shared data structures in pandas but not in cuDF.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/copy-on-write.md#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> import pandas as pd\n>>> s = pd.Series([1, 2, 3, 4, 5])\n>>> s1 = s[0:2]\n>>> s1[0] = 10\n>>> s1\n0    10\n1     2\ndtype: int64\n>>> s\n0    10\n1     2\n2     3\n3     4\n4     5\ndtype: int64\n>>> import cudf\n>>> s = cudf.Series([1, 2, 3, 4, 5])\n>>> s1 = s[0:2]\n>>> s1[0] = 10\n>>> s1\n0    10\n1     2\ndtype: int64\n>>> s\n0    1\n1    2\n2    3\n3    4\n4    5\ndtype: int64\n```\n\n----------------------------------------\n\nTITLE: Disabling Copy-on-Write in cuDF with Python\nDESCRIPTION: This snippet illustrates how to disable the copy-on-write feature in cuDF by setting the `copy_on_write` option to False. It can be used to revert any previous opt-in setting.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/copy-on-write.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> cudf.set_option(\"copy_on_write\", False)\n```\n\n----------------------------------------\n\nTITLE: Profiling cudf.pandas from command line\nDESCRIPTION: Shows how to enable profiling when running a Python script with cudf.pandas from the command line, which generates a report showing which operations used GPU versus CPU.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/usage.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\npython -m cudf.pandas --profile script.py\n```\n\n----------------------------------------\n\nTITLE: Demonstrating global variable access limitations in cuDF pandas mode (Python)\nDESCRIPTION: This code snippet illustrates that while global variables can be accessed during CPU fallback in cuDF pandas mode, they cannot be modified. The example shows a user-defined function that attempts to modify a global list, but the modification doesn't persist.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/faq.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n%load_ext cudf.pandas\nimport pandas as pd\n\nlst = [10]\n\ndef udf(x):\n    lst.append(x)\n    return x + lst[0]\n\ns = pd.Series(range(2)).apply(udf)\nprint(s) # we can access the value in lst\n0    10\n1    11\ndtype: int64\nprint(lst) # lst is unchanged, as this specific UDF could not run on the GPU\n[10]\n```\n\n----------------------------------------\n\nTITLE: List Column Structure Example\nDESCRIPTION: This example demonstrates the internal structure of a list column in libcudf, showing the parent column with offsets and a child column containing the actual data.  It illustrates how nested lists are represented and how null values are handled at both the list and element levels. The example uses integers for the inner list values.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_31\n\nLANGUAGE: none\nCODE:\n```\n\"lists_column = { {{{1, 2}, {3, 4}}, NULL}, {{{10, 20}, {30, 40}}, {{50, 60, 70}, {0}}} }\\n\\n   List<List<List<int>>>  (2 rows):\\n   Length : 2\\n   Offsets : 0, 2, 4\\n   Children :\\n      List<List<int>>:\\n      Length : 4\\n      Offsets : 0, 2, 2, 4, 6\\n      Null count: 1\\n        1101\\n      Children :\\n        List<int>:\\n        Length : 6\\n        Offsets : 0, 2, 4, 6, 8, 11, 12\\n        Children :\\n          Column of ints\\n          1, 2, 3, 4, 10, 20, 30, 40, 50, 60, 70, 0\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Doxygen Timestamp Documentation in RST\nDESCRIPTION: RST directive that configures Doxygen to generate documentation for members of the timestamp_classes group in cuDF.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/timestamp_classes.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: timestamp_classes\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Converting cuDF Series to CuPy Array using cupy.asarray\nDESCRIPTION: Converts a cuDF Series to a CuPy array using `cupy.asarray` and stores it in `cola_cupy`. Then prints out `cola_cupy`.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/cupy-interop.ipynb#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncola_cupy = cp.asarray(df[col])\ncola_cupy\n```\n\n----------------------------------------\n\nTITLE: Reading Data from Parquet using pylibcudf\nDESCRIPTION: This code snippet utilizes the pylibcudf library to read data from a parquet file into a GPU-accelerated table in Python. It constructs a source information object for the parquet file and creates a reader options builder to configure the reading process.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/index.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pylibcudf as plc\n\nsource = plc.io.SourceInfo([\"dataset.parquet\"])\noptions = plc.io.parquet.ParquetReaderOptions.builder(source).build()\ntable = plc.io.parquet.read_parquet(options)\n```\n\n----------------------------------------\n\nTITLE: Enforcing Compile-Time Conditions with static_assert\nDESCRIPTION: This snippet demonstrates how to use `static_assert` to enforce compile-time conditions, specifically checking if a type `T` is a trivial type.  This ensures that the function `trivial_types_only` is only used with trivial types, preventing potential runtime errors.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_25\n\nLANGUAGE: c++\nCODE:\n```\ntemplate <typename T>\nvoid trivial_types_only(T t){\n  static_assert(std::is_trivial<T>::value, \"This function requires a trivial type.\");\n...\n}\n```\n\n----------------------------------------\n\nTITLE: Fixed Point Column Wrapper Examples in C++\nDESCRIPTION: Shows how to create fixed-point columns (DECIMAL32/DECIMAL64) with specified scale values. Includes examples for both nullable and non-nullable columns.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/TESTING.md#2025-04-21_snippet_5\n\nLANGUAGE: c++\nCODE:\n```\n// Creates a non-nullable column of 4 DECIMAL32 elements of scale 3: {1000, 2000, 3000, 4000}\nauto elements = cudf::detail::make_counting_transform_iterator(0, [](auto i){ return i; });\ncudf::test::fixed_point_column_wrapper<int32_t> w(elements, elements + 4, 3);\n\n// Creates a nullable column of 5 DECIMAL32 elements of scale 2: {null, 100, null, 300, null}\nauto elements = cudf::detail::make_counting_transform_iterator(0, [](auto i){ return i; });\nauto validity = cudf::detail::make_counting_transform_iterator(0, [](auto i){ return i % 2; });\ncudf::test::fixed_point_column_wrapper<int32_t> w(elements, elements + 5, validity, 2);\n```\n\n----------------------------------------\n\nTITLE: Configuring DLPack and Nanoarrow Integration for Specific Modules\nDESCRIPTION: Configures include directories and libraries for specific Python modules that require DLPack and Nanoarrow interoperability support. This setup is crucial for data interchange between different libraries.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/pylibcudf/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(${rapids-cmake-dir}/export/find_package_root.cmake)\ninclude(../../../cpp/cmake/thirdparty/get_nanoarrow.cmake)\n\nforeach(source interop _interop_helpers table column)\n  target_include_directories(pylibcudf_${source} PUBLIC \"$<BUILD_INTERFACE:${DLPACK_INCLUDE_DIR}>\")\n  target_link_libraries(pylibcudf_${source} PUBLIC nanoarrow)\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Index Normalizing Iterator Usage Example\nDESCRIPTION: This code demonstrates how to create and use an input iterator with `indexalator_factory`. It creates iterators `begin` and `end` from a `gather_map` column_view and then uses these iterators as input to a `detail::gather` function, which gathers elements from `source` based on the indices provided by the iterators.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_15\n\nLANGUAGE: c++\nCODE:\n```\nauto begin = indexalator_factory::create_input_iterator(gather_map);\nauto end   = begin + gather_map.size();\nauto result = detail::gather( source, begin, end, IGNORE, stream, mr );\n\n```\n\n----------------------------------------\n\nTITLE: Creating struct columns using pre-constructed child columns in CUDF\nDESCRIPTION: This snippet demonstrates how to construct a struct column by first creating individual child columns for ints and strings, then combining them with optional validity indicators.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/TESTING.md#2025-04-21_snippet_9\n\nLANGUAGE: c++\nCODE:\n```\n// The following constructs a column for struct< int, string >.\nauto child_int_col = cudf::test::fixed_width_column_wrapper<int32_t>{ 1, 2, 3, 4, 5 }.release();\nauto child_string_col = cudf::test::string_column_wrapper {\"All\", \"the\", \"leaves\", \"are\", \"brown\"}.release();\n\nstd::vector<std::unique_ptr<cudf::column>> child_columns;\nchild_columns.push_back(std::move(child_int_col));\nchild_columns.push_back(std::move(child_string_col));\n\ncudf::test::struct_col wrapper wrapper{\n  child_cols,\n  {1,0,1,0,1} // Validity\n};\n\nauto struct_col {wrapper.release()};\n```\n\n----------------------------------------\n\nTITLE: Error Indication with CUDF_FAIL Macro\nDESCRIPTION: This example illustrates how to use the `CUDF_FAIL` macro to indicate an error when a specific code path should not be reached. This macro is equivalent to calling `CUDF_EXPECTS(false, reason)` and throws an exception with the provided error message.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_23\n\nLANGUAGE: c++\nCODE:\n```\nCUDF_FAIL(\"This code path should not be reached.\");\n\n```\n\n----------------------------------------\n\nTITLE: Using cudf.pandas CLI with -c flag for inline code\nDESCRIPTION: Demonstrates how to execute Python code with cudf.pandas using the -c flag to provide inline code directly on the command line.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/usage.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\npython -m cudf.pandas -c \"import pandas; print(pandas)\"\n```\n\n----------------------------------------\n\nTITLE: Listing Available Libcudf Examples in Markdown\nDESCRIPTION: A markdown list documenting the available example projects in the libcudf examples directory. The examples cover basic usage patterns, string operations, and working with nested data types.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/examples/README.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- Basic: demonstrates a basic use case with libcudf and building a custom application with libcudf\n- Strings: demonstrates using libcudf for accessing and creating strings columns and for building custom kernels for strings\n- Nested Types: demonstrates using libcudf for some operations on nested types\n```\n\n----------------------------------------\n\nTITLE: Basic Fuzz Test Implementation with pythonfuzz Decorator\nDESCRIPTION: Shows how to implement a basic fuzz test using the pythonfuzz decorator with a CSVWriter data handler. The decorator registers the test function to be continuously run by the Fuzzer at runtime.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf/cudf/_fuzz_testing/tests/readme.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom cudf.testing.csv import CSVWriter\n\n@pythonfuzz(data_handle=CSVWriter)\ndef csv_writer_test(data_from_generate_input):\n    ...\n    ...\n    ...\n\nif __name__ == \"__main__\":\n    ...\n    ...\n```\n\n----------------------------------------\n\nTITLE: CuPy Array Operations with Numba\nDESCRIPTION: Demonstrates Numba kernel execution on CuPy arrays with CUDA integration.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nimport cupy as cp\n\ns = cudf.Series([1.0, 2, 3, 4, 10])\narr = cp.asarray(s)\narr\n```\n\nLANGUAGE: python\nCODE:\n```\n@cuda.jit\ndef multiply_by_5(x, out):\n    i = cuda.grid(1)\n    if i < x.size:\n        out[i] = x[i] * 5\n\n\nout = cudf.Series(cp.zeros(len(s), dtype=\"int32\"))\nmultiply_by_5.forall(s.shape[0])(s, out)\nout\n```\n\nLANGUAGE: python\nCODE:\n```\nout = cp.empty_like(arr)\nmultiply_by_5.forall(arr.size)(arr, out)\nout\n```\n\n----------------------------------------\n\nTITLE: Using cudf.pandas CLI with stdin for code input\nDESCRIPTION: Shows how to provide code to execute with cudf.pandas through standard input (stdin), allowing for piping commands or scripts.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/usage.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\necho \"import pandas; print(pandas)\" | python -m cudf.pandas\n```\n\n----------------------------------------\n\nTITLE: Forcing CPU execution for cuDF pandas (Bash)\nDESCRIPTION: This bash command demonstrates how to force CPU execution when using cuDF pandas by setting the CUDF_PANDAS_FALLBACK_MODE environment variable. This can be useful for testing or benchmarking purposes.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/faq.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nCUDF_PANDAS_FALLBACK_MODE=1 python -m cudf.pandas some_script.py\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for Utility Bitmask in cuDF\nDESCRIPTION: This reStructuredText directive instructs Doxygen to generate documentation for all members of the utility_bitmask group. It is used to create API documentation for the bitmask utilities in the RAPIDS cuDF library.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/utility_bitmask.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: utility_bitmask\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Checking if CuPy Array is Fortran Contiguous\nDESCRIPTION: Checks if the CuPy array `reshaped_arr` is Fortran contiguous in memory using `cp.isfortran` function.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/cupy-interop.ipynb#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ncp.isfortran(reshaped_arr)\n```\n\n----------------------------------------\n\nTITLE: Building and Executing libcudf Examples\nDESCRIPTION: Commands for configuring, building, and executing the different processing modes (single-load, chunked, and pipeline) of the 1 billion row challenge implementation. The build process uses CMake and supports parallel compilation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/examples/billion_rows/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Configure project\ncmake -S . -B build/\n# Build\ncmake --build build/ --parallel $PARALLEL_LEVEL\n# Execute\nbuild/brc input.txt\n# Execute in chunked mode with 25 chunks (default)\nbuild/brc_chunks input.txt 25\n# Execute in pipeline mode with 25 chunks and 2 threads (defaults)\nbuild/brc_pipeline input.txt 25 2\n```\n\n----------------------------------------\n\nTITLE: Customizing Type Dispatch with IdTypeMap\nDESCRIPTION: This snippet showcases how to customize the type dispatching process by providing a user-defined trait for the `IdTypeMap`. By defining `always_int`, the dispatcher will always invoke `operator()<int32_t>`, regardless of the `cudf::type_id` value, effectively overriding the default type mapping.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_28\n\nLANGUAGE: c++\nCODE:\n```\ntemplate<cudf::type_id t> struct always_int{ using type = int32_t; }\n\n// This will always invoke `operator()<int32_t>`\ncudf::type_dispatcher<always_int>(data_type, f);\n```\n\n----------------------------------------\n\nTITLE: Creating a Sample DataFrame for Transpose\nDESCRIPTION: Creates a simple cuDF DataFrame with two columns to demonstrate the transpose operation, which requires all columns to have the same data type.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nsample = cudf.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\nsample\n```\n\n----------------------------------------\n\nTITLE: Managing Dependencies for CUDF Project in CMake\nDESCRIPTION: Finds and configures various dependencies required for the CUDF project, including ZLIB, Threads (for testutil), and initializes CPM for third-party dependency management.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nrapids_find_package(ZLIB REQUIRED)\n\nif(CUDF_BUILD_TESTUTIL)\n  rapids_find_package(\n    Threads REQUIRED\n    BUILD_EXPORT_SET cudf-exports\n    INSTALL_EXPORT_SET cudf-exports\n  )\nendif()\n\nrapids_cpm_init()\n\ninclude(${rapids-cmake-dir}/cpm/rapids_logger.cmake)\nrapids_cpm_rapids_logger(BUILD_EXPORT_SET cudf-exports INSTALL_EXPORT_SET cudf-exports)\ncreate_logger_macros(CUDF \"cudf::default_logger()\" include/cudf)\n```\n\n----------------------------------------\n\nTITLE: Implementing Selective Parameter XFailing with pytest.param in Python\nDESCRIPTION: Example demonstrating how to mark specific parameters as expected to fail in a parameterized test using pytest.param with xfail markers.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/testing.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@pytest.mark.parametrize(\n    \"value\",\n    [\n        1,\n        2,\n        pytest.param(\n            3, marks=pytest.mark.xfail(reason=\"code doesn't work for 3\")\n        ),\n    ],\n)\ndef test_value(value):\n    assert value < 3\n```\n\n----------------------------------------\n\nTITLE: Doxygen @copydoc Example for Stream Parameter Functions\nDESCRIPTION: Example showing how to use @copydoc tag for a detail function that differs only by the stream parameter. The full function signature must be specified for Doxygen to locate it.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DOCUMENTATION.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n/**\n * @copydoc cudf::segmented_count_set_bits(bitmask_type const*,std::vector<size_type> const&)\n *\n * @param[in] stream Optional CUDA stream on which to execute kernels\n */\nstd::vector<size_type> segmented_count_set_bits(bitmask_type const* bitmask,\n                                                std::vector<size_type> const& indices,\n                                                rmm::cuda_stream_view stream = cudf::get_default_stream());\n```\n\n----------------------------------------\n\nTITLE: Implementing Column Renaming in Expressions with Singledispatch in Python\nDESCRIPTION: A comprehensive example showing how to implement expression transformation using singledispatch. This code renames column references in an expression tree based on a provided mapping.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_polars/docs/overview.md#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Mapping\nfrom functools import singledispatch\nfrom cudf_polars.dsl.traversal import (\n    CachingVisitor, make_recursive, reuse_if_unchanged\n)\nfrom cudf_polars.dsl.expr import Col, Expr\nfrom cudf_polars.typing import ExprTransformer\n\n\n@singledispatch\ndef _rename(e: Expr, rec: ExprTransformer) -> Expr:\n    raise NotImplementedError(f\"No handler for {type(e)}\")\n```\n\n----------------------------------------\n\nTITLE: Maven Dependency Configuration for CUDF\nDESCRIPTION: Basic Maven dependency configuration for including CUDF in Java projects. This references the default jar that works with most modern CUDA drivers.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/README.md#2025-04-21_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<dependency>\n    <groupId>ai.rapids</groupId>\n    <artifactId>cudf</artifactId>\n    <version>${cudf.version}</version>\n</dependency>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Memory Resource Usage in C++ for libcudf Functions\nDESCRIPTION: Shows examples of how to properly include memory resource parameters in libcudf function signatures, depending on whether they allocate output memory or not.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\n// Returned `column` contains newly allocated memory,\n// therefore the API must accept a memory resource pointer\nstd::unique_ptr<column> returns_output_memory(\n  ..., rmm::device_async_resource_ref mr = cudf::get_current_device_resource_ref());\n\n// This API does not allocate any new *output* memory, therefore\n// a memory resource is unnecessary\nvoid does_not_allocate_output_memory(...);\n```\n\n----------------------------------------\n\nTITLE: Describing Options in cuDF\nDESCRIPTION: This snippet demonstrates how to use the `describe_option` method in the cuDF library to print out available options and their descriptions. It highlights the ability to view all options by calling the function without arguments.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/api_docs/options.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cudf\ncudf.describe_option()\n```\n\n----------------------------------------\n\nTITLE: Creating a Dask cuDF Series from cuDF Series\nDESCRIPTION: Creates a `dask_cudf.Series` object from an existing `cudf.Series`, partitioning the data into two partitions. The `head()` method is used to display the first few entries, as Dask cuDF objects may not have a full printing representation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nds = dask_cudf.from_cudf(s, npartitions=2)\n# Note the call to head here to show the first few entries, unlike\n# cuDF objects, Dask-cuDF objects do not have a printing\n# representation that shows values since they may not be in local\n# memory.\nds.head(n=3)\n```\n\n----------------------------------------\n\nTITLE: Displaying DataFrame for Row-wise Operations\nDESCRIPTION: Displays the first few rows of a DataFrame that will be used to demonstrate row-wise operations through CuPy interoperability.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/cupy-interop.ipynb#2025-04-21_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nreshaped_df.head()\n```\n\n----------------------------------------\n\nTITLE: Documenting CUDF String Modification Functions (C++)\nDESCRIPTION: This code snippet uses Doxygen to generate documentation for the 'strings_modify' group of functions in CUDF. It includes all members of the group in the generated documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/strings_modify.rst#2025-04-21_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n.. doxygengroup:: strings_modify\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Installing cuDF with Pip for CUDA 12.x\nDESCRIPTION: Command to install cuDF for CUDA 12.x environments using pip with NVIDIA's Python Package Index.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/libcudf/README.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npip install --extra-index-url=https://pypi.nvidia.com cudf-cu12\n```\n\n----------------------------------------\n\nTITLE: Installing cuDF via Pip for CUDA 12.x in Bash\nDESCRIPTION: This command installs cuDF via pip for systems with CUDA 12.x. It uses the NVIDIA Python Package Index to fetch the appropriate cuDF package compatible with CUDA 12.x.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/README.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npip install --extra-index-url=https://pypi.nvidia.com cudf-cu12\n```\n\n----------------------------------------\n\nTITLE: Generating NVText API Documentation with Doxygen in reStructuredText\nDESCRIPTION: This snippet uses Doxygen to generate documentation for the nvtext_apis group. It includes all members of the group in the generated documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/nvtext_apis.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: nvtext_apis\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Converting CuPy Array to Fortran Contiguous and then to cuDF DataFrame, Displaying Head\nDESCRIPTION: Converts a CuPy array to a Fortran contiguous array using `cp.asfortranarray`, then creates a cuDF DataFrame and displays the head of the DataFrame. This uses the DataFrame constructor for conversion.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/cupy-interop.ipynb#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfortran_arr = cp.asfortranarray(reshaped_arr)\nreshaped_df = cudf.DataFrame(fortran_arr)\nreshaped_df.head()\n```\n\n----------------------------------------\n\nTITLE: Writing Assertions for GPU Execution in Python Tests\nDESCRIPTION: Test utility pattern that runs a Polars LazyFrame query using both the cuDF executor and Polars CPU executor, then verifies that the results match.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_polars/docs/overview.md#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom cudf_polars.testing.asserts import assert_gpu_result_equal\n\n\ndef test_whatever():\n    query = pl.LazyFrame(...).(...)  # Build a query\n\n    assert_gpu_result_equal(query)\n```\n\n----------------------------------------\n\nTITLE: Index Normalizing Output Iterator Example\nDESCRIPTION: This code shows how to create and use an output iterator with `indexalator_factory`. It creates an output iterator `result_itr` from a `mutable_view` of an `indices` column. The iterator is then used as the output for a `thrust::lower_bound` algorithm, where the results of the lower bound search are written to the `indices` column.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_16\n\nLANGUAGE: c++\nCODE:\n```\nauto result_itr = indexalator_factory::create_output_iterator(indices->mutable_view());\nthrust::lower_bound(rmm::exec_policy(stream),\n                    input->begin<Element>(),\n                    input->end<Element>(),\n                    values->begin<Element>(),\n                    values->end<Element>(),\n                    result_itr,\n                    cuda::std::less<Element>());\n\n```\n\n----------------------------------------\n\nTITLE: Illustrating Capturing Group in Regex\nDESCRIPTION: Shows a capturing group which groups the regex and captures the matched text into a numbered group.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/regex.md#2025-04-21_snippet_11\n\nLANGUAGE: regex\nCODE:\n```\n(abc⎮def)ghi\n```\n\n----------------------------------------\n\nTITLE: ConfigureTest Function for Setting Up CUDA Tests\nDESCRIPTION: Defines a custom CMake function that configures test executables with appropriate properties. It handles GPU requirements, test percentage allocation, stream mode settings, and links the test with necessary libraries. The function simplifies the process of creating consistent test configurations throughout the project.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(ConfigureTest CMAKE_TEST_NAME)\n  set(options)\n  set(one_value GPUS PERCENT STREAM_MODE)\n  set(multi_value EXTRA_LIBS)\n  cmake_parse_arguments(_CUDF_TEST \"${options}\" \"${one_value}\" \"${multi_value}\" ${ARGN})\n\n  if(NOT DEFINED _CUDF_TEST_GPUS AND NOT DEFINED _CUDF_TEST_PERCENT)\n    set(_CUDF_TEST_GPUS 1)\n    set(_CUDF_TEST_PERCENT 15)\n  endif()\n\n  if(NOT DEFINED _CUDF_TEST_GPUS)\n    set(_CUDF_TEST_GPUS 1)\n  endif()\n\n  if(NOT DEFINED _CUDF_TEST_PERCENT)\n    set(_CUDF_TEST_PERCENT 100)\n  endif()\n\n  if(NOT DEFINED _CUDF_TEST_STREAM_MODE)\n    set(_CUDF_TEST_STREAM_MODE cudf)\n  endif()\n\n  add_executable(${CMAKE_TEST_NAME} ${_CUDF_TEST_UNPARSED_ARGUMENTS})\n  set_target_properties(\n    ${CMAKE_TEST_NAME}\n    PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"$<BUILD_INTERFACE:${CUDF_BINARY_DIR}/gtests>\"\n               INSTALL_RPATH \"\\$ORIGIN/../../../lib\"\n               CXX_STANDARD 17\n               CXX_STANDARD_REQUIRED ON\n               # For std:: support of __int128_t. Can be removed once using cuda::std\n               CXX_EXTENSIONS ON\n               CUDA_STANDARD 17\n               CUDA_STANDARD_REQUIRED ON\n  )\n\n  target_link_libraries(\n    ${CMAKE_TEST_NAME} PRIVATE cudf::cudftestutil_objects nvtx3::nvtx3-cpp\n                               $<TARGET_NAME_IF_EXISTS:conda_env> \"${_CUDF_TEST_EXTRA_LIBS}\"\n  )\n  rapids_cuda_set_runtime(${CMAKE_TEST_NAME} USE_STATIC ${CUDA_STATIC_RUNTIME})\n  rapids_test_add(\n    NAME ${CMAKE_TEST_NAME}\n    COMMAND ${CMAKE_TEST_NAME}\n    GPUS ${_CUDF_TEST_GPUS}\n    PERCENT ${_CUDF_TEST_PERCENT}\n    INSTALL_COMPONENT_SET testing\n  )\n\n  if(CUDF_BUILD_STREAMS_TEST_UTIL)\n    set_tests_properties(\n      ${CMAKE_TEST_NAME}\n      PROPERTIES\n        ENVIRONMENT\n        \"GTEST_CUDF_STREAM_MODE=new_${_CUDF_TEST_STREAM_MODE}_default;LD_PRELOAD=$<TARGET_FILE:cudf_identify_stream_usage_mode_${_CUDF_TEST_STREAM_MODE}>\"\n    )\n  endif()\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Showing Lazy Quantifier (*?) in Regex\nDESCRIPTION: Demonstrates the lazy quantifier '*?' which repeats the previous item zero or more times, attempting to skip the item first.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/regex.md#2025-04-21_snippet_4\n\nLANGUAGE: regex\nCODE:\n```\n\".*?\"\n```\n\n----------------------------------------\n\nTITLE: Showing Numbered Backreference in Regex Replacement\nDESCRIPTION: Demonstrates the use of numbered backreferences (\\1 through \\99) to insert text matched by capturing groups in replacements.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/regex.md#2025-04-21_snippet_13\n\nLANGUAGE: regex\nCODE:\n```\n(a)(b)(c)\n```\n\n----------------------------------------\n\nTITLE: Dictionary Column Wrapper Examples in C++\nDESCRIPTION: Demonstrates creation of dictionary columns with various data types and configurations, including string dictionaries and validity masks.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/TESTING.md#2025-04-21_snippet_6\n\nLANGUAGE: c++\nCODE:\n```\n// Creates a non-nullable dictionary column of INT32 elements with 5 elements\n// keys = {0, 2, 6}, indices = {0, 1, 1, 2, 2}\nstd::vector<int32_t> elements{0, 2, 2, 6, 6};\ncudf::test::dictionary_column_wrapper<int32_t> w(element.begin(), elements.end());\n\n// Creates a nullable dictionary column with 5 elements and a validity iterator.\nstd::vector<int32_t> elements{0, 2, 0, 6, 0};\n// Validity iterator here sets even rows to null.\nauto validity = cudf::detail::make_counting_transform_iterator(0, [](auto i){return i % 2;})\n// keys = {2, 6}, indices = {NULL, 0, NULL, 1, NULL}\ncudf::test::dictionary_column_wrapper<int32_t> w(elements, elements + 5, validity);\n\n// Creates a non-nullable dictionary column with 4 elements.\n// keys = {1, 2, 3}, indices = {0, 1, 2, 0}\ncudf::test::dictionary_column_wrapper<int32_t> w{{1, 2, 3, 1}};\n\n// Creates a nullable dictionary column with 4 elements and validity initializer.\n// keys = {1, 3}, indices = {0, NULL, 1, NULL}\ncudf::test::dictionary_column_wrapper<int32_t> w{ {1, 0, 3, 0}, {1, 0, 1, 0}};\n\n// Creates a nullable column of dictionary elements with 5 elements and validity initializer.\nstd::vector<int32_t> elements{0, 2, 2, 6, 6};\n// keys = {2, 6}, indices = {NULL, 0, NULL, 1, NULL}\ncudf::test::dictionary_width_column_wrapper<int32_t> w(elements, elements + 5, {0, 1, 0, 1, 0});\n\n// Creates a non-nullable dictionary column with 7 string elements\nstd::vector<std::string> strings{\"\", \"aaa\", \"bbb\", \"aaa\", \"bbb\", \"ccc\", \"bbb\"};\n// keys = {\"\",\"aaa\",\"bbb\",\"ccc\"}, indices = {0, 1, 2, 1, 2, 3, 2}\ncudf::test::dictionary_column_wrapper<std::string> d(strings.begin(), strings.end());\n\n// Creates a nullable dictionary column with 7 string elements and a validity iterator.\n// Validity iterator here sets even rows to null.\n// keys = {\"a\", \"bb\"}, indices = {NULL, 1, NULL, 1, NULL, 0, NULL}\nauto validity = cudf::detail::make_counting_transform_iterator(0, [](auto i){return i % 2;});\ncudf::test::dictionary_column_wrapper<std::string> d({\"\", \"bb\", \"\", \"bb\", \"\", \"a\", \"\"}, validity);\n```\n\n----------------------------------------\n\nTITLE: Handling Non-String Column Names in Parquet Writing\nDESCRIPTION: Demonstrates cuDF's behavior with non-string column names when writing to Parquet files\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/pandas-comparison.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport cudf\ndf = cudf.DataFrame({1: [1, 2, 3], \"1\": [\"a\", \"b\", \"c\"]})\ncudf.set_option(\"mode.pandas_compatible\", True)\ndf.to_parquet(\"df.parquet\")\n```\n\n----------------------------------------\n\nTITLE: Creating Data for Groupby Operations\nDESCRIPTION: Creates test data for demonstrating groupby operations with cuDF and Dask-cuDF. Adds two columns with binary values based on modulo operations, then converts the cuDF DataFrame to a Dask-cuDF DataFrame with 2 partitions.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ndf[\"agg_col1\"] = [1 if x % 2 == 0 else 0 for x in range(len(df))]\ndf[\"agg_col2\"] = [1 if x % 3 == 0 else 0 for x in range(len(df))]\n\nddf = dask_cudf.from_cudf(df, npartitions=2)\n```\n\n----------------------------------------\n\nTITLE: Modifying get_dummies Default Return Type in cuDF (Python)\nDESCRIPTION: The default return type of get_dummies has been changed from int8 to boolean. This snippet demonstrates the old and new behavior of the function.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/pandas-2.0-breaking-changes.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nIn [2]: s = cudf.Series([1, 2, 10, 11, None])\n\nIn [6]: cudf.get_dummies(s)\nOut[6]:\n   1   2   10  11\n0   1   0   0   0\n1   0   1   0   0\n2   0   0   1   0\n3   0   0   0   1\n4   0   0   0   0\n```\n\nLANGUAGE: python\nCODE:\n```\nIn [3]: cudf.get_dummies(s)\nOut[3]:\n      1      2      10     11\n0   True  False  False  False\n1  False   True  False  False\n2  False  False   True  False\n3  False  False  False   True\n4  False  False  False  False\n```\n\n----------------------------------------\n\nTITLE: pylibcudf.strings.replace Module Documentation\nDESCRIPTION: This snippet uses the `automodule` directive in Sphinx to generate documentation for the `pylibcudf.strings.replace` module. It includes documentation for all members of the module. This is part of the project's documentation build process.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/api_docs/strings/replace.rst#2025-04-21_snippet_0\n\nLANGUAGE: Sphinx\nCODE:\n```\n.. automodule:: pylibcudf.strings.replace\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Installing cudf Package with pip in Bash\nDESCRIPTION: Installs the cudf package using pip, specifying the NVIDIA PyPI index.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/benchmarks.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install --extra-index-url=https://pypi.nvidia.com cudf-cu12  # or cudf-cu11\n```\n\n----------------------------------------\n\nTITLE: Including Doxygen Documentation for column_hash Group in ReStructuredText\nDESCRIPTION: This snippet uses ReStructuredText directives to include Doxygen-generated documentation for the 'column_hash' group, displaying all members of this group.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/column_hash.rst#2025-04-21_snippet_0\n\nLANGUAGE: ReStructuredText\nCODE:\n```\n.. doxygengroup:: column_hash\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Converting Fortran-ordered Array to DataFrame using dlpack\nDESCRIPTION: Benchmarks the process of converting a CuPy array to Fortran memory order and then to a cuDF DataFrame using the dlpack interface.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/cupy-interop.ipynb#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n%%timeit\n\nfortran_arr = cp.asfortranarray(reshaped_arr)\nreshaped_df = cudf.from_dlpack(fortran_arr.__dlpack__())\n```\n\n----------------------------------------\n\nTITLE: Handling Version-Specific Tests with pytest.mark in Python\nDESCRIPTION: Examples of how to handle version-specific test issues using pytest's skipif and xfail markers. These patterns help manage tests that need to behave differently depending on the pandas version being used.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/testing.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@pytest.mark.skipif(PANDAS_VERSION < PANDAS_CURRENT_SUPPORTED_VERSION, reason=\"bug in older version of pandas\")\ndef test_bug_from_older_pandas_versions(...):\n    ...\n\n@pytest.mark.xfail(PANDAS_VERSION >= PANDAS_CURRENT_SUPPORTED_VERSION, reason=\"bug in latest version of pandas\")\ndef test_bug_in_current_and_maybe_future_versions(...):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Code Style Examples in C++\nDESCRIPTION: Demonstrates libcudf code style conventions including snake_case naming, template parameters, and class member variables with underscore prefixes.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate <typename IteratorType>\nvoid algorithm_function(int x, rmm::cuda_stream_view s, rmm::device_async_resource_ref mr)\n{\n  ...\n}\n\nclass utility_class\n{\n  ...\nprivate:\n  int _rating{};\n  std::unique_ptr<cudf::column> _column{};\n}\n\nTYPED_TEST_SUITE(RepeatTypedTestFixture, cudf::test::FixedWidthTypes);\n\nTYPED_TEST(RepeatTypedTestFixture, RepeatScalarCount)\n{\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Greedy Quantifier (?) in Regex\nDESCRIPTION: Shows the usage of the greedy quantifier '?' which makes the preceding item optional. It matches the optional item if possible.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/regex.md#2025-04-21_snippet_0\n\nLANGUAGE: regex\nCODE:\n```\nabc?\n```\n\n----------------------------------------\n\nTITLE: Installing cuDF via pip for CUDA 12.x\nDESCRIPTION: Command to install cuDF via pip from the NVIDIA Python Package Index for environments with CUDA 12.x.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_kafka/README.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npip install --extra-index-url=https://pypi.nvidia.com cudf-cu12\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Numpy-style Docstring Format in Python\nDESCRIPTION: This snippet shows an example of the numpy-style docstring format used in cuDF, including class and method documentation with various sections like Parameters, Returns, Raises, and Examples.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/documentation.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    \"\"\"Brief description of A.\n\n    Longer description of A.\n\n    Parameters\n    ----------\n    x : int\n        Description of x, the first constructor parameter.\n    \"\"\"\n    def __init__(self, x: int):\n        pass\n\n    def foo(self, bar: str):\n        \"\"\"Short description of foo.\n\n        Longer description of foo.\n\n        Parameters\n        ----------\n        bar : str\n            Description of bar.\n\n        Returns\n        -------\n        float\n            Description of the return value of foo.\n\n        Raises\n        ------\n        ValueError\n            Explanation of when a ValueError is raised.\n            In this case, a ValueError is raised if bar is \"fail\".\n\n        Examples\n        --------\n        The examples section is _strongly_ encouraged.\n        Where appropriate, it may mimic the examples for the corresponding pandas API.\n        >>> a = A()\n        >>> a.foo('baz')\n        0.0\n        >>> a.foo('fail')\n        ...\n        ValueError: Failed!\n        \"\"\"\n        if bar == \"fail\":\n            raise ValueError(\"Failed!\")\n        return 0.0\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Fixed Quantifier in Regex\nDESCRIPTION: Illustrates the fixed quantifier '{n}' which repeats the previous item exactly n times.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/regex.md#2025-04-21_snippet_6\n\nLANGUAGE: regex\nCODE:\n```\na{5}\n```\n\n----------------------------------------\n\nTITLE: Comparing None and np.nan in Python\nDESCRIPTION: The following code compares `None` and `np.nan`, explaining their differing equality behaviors in Python and NumPy. Python treats `None` as equal to itself, while `np.nan` does not equal another `np.nan`, impacting scalar equality comparisons.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/missing-data.ipynb#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nNone == None\n```\n\nLANGUAGE: Python\nCODE:\n```\nnp.nan == np.nan\n```\n\nLANGUAGE: Python\nCODE:\n```\ndf[\"b\"] == np.nan\n```\n\n----------------------------------------\n\nTITLE: Implementing Wait Operation\nDESCRIPTION: Demonstrates the use of wait function to ensure all partitions have completed processing before continuing with subsequent operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_89\n\nLANGUAGE: python\nCODE:\n```\nwait(results_ddf)\n```\n\n----------------------------------------\n\nTITLE: Fixed Width Column Wrapper Examples in C++\nDESCRIPTION: Demonstrates creation of fixed-width columns with various data types including nullable and non-nullable variants. Shows usage with iterators and initializer lists.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/TESTING.md#2025-04-21_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\n// Creates a non-nullable column of INT32 elements with 5 elements: {0, 1, 2, 3, 4}\nauto elements = cudf::detail::make_counting_transform_iterator(0, [](auto i){return i;});\ncudf::test::fixed_width_column_wrapper<int32_t> w(elements, elements + 5);\n\n// Creates a nullable column of INT32 elements with 5 elements: {null, 1, null, 3, null}\nauto elements = cudf::detail::make_counting_transform_iterator(0, [](auto i){return i;});\nauto validity = cudf::detail::make_counting_transform_iterator(0, [](auto i){return i % 2;})\ncudf::test::fixed_width_column_wrapper<int32_t> w(elements, elements + 5, validity);\n\n// Creates a non-nullable INT32 column with 4 elements: {1, 2, 3, 4}\ncudf::test::fixed_width_column_wrapper<int32_t> w{{1, 2, 3, 4}};\n\n// Creates a nullable INT32 column with 4 elements: {1, NULL, 3, NULL}\ncudf::test::fixed_width_column_wrapper<int32_t> w{ {1,2,3,4}, {1, 0, 1, 0}};\n```\n\n----------------------------------------\n\nTITLE: Reading ORC File with cuDF\nDESCRIPTION: Demonstrates how to read an ORC file into a cuDF DataFrame using GPU acceleration.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_81\n\nLANGUAGE: python\nCODE:\n```\ndf2 = cudf.read_orc(\"example_output/temp_orc\")\ndf2\n```\n\n----------------------------------------\n\nTITLE: Creating a cuDF Series with String Data\nDESCRIPTION: Creates a cuDF Series that contains string data, which is necessary for demonstrating the application of user-defined functions that handle strings.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nsr = cudf.Series([\"\", \"abc\", \"some_example\"])\n```\n\n----------------------------------------\n\nTITLE: Datetime Processing Functions in cuDF\nDESCRIPTION: Functions for handling and generating datetime-like data, enabling date range creation and datetime conversions\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/api_docs/general_functions.rst#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nto_datetime, date_range\n```\n\n----------------------------------------\n\nTITLE: Converting Strings to Floating Point Values with cuDF\nDESCRIPTION: Automodule documentation for string to float conversion utilities in the cuDF library, providing GPU-accelerated type conversion methods\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/api_docs/strings/convert/convert_floats.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n.. automodule:: pylibcudf.strings.convert.convert_floats\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Parameterized Fuzz Testing with Custom Values\nDESCRIPTION: Demonstrates how to customize test parameters using the pythonfuzz decorator, allowing for testing different combinations of parameter values.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf/cudf/_fuzz_testing/tests/readme.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom cudf._fuzz_testing.main import pythonfuzz\nfrom cudf._fuzz_testing.utils import ALL_POSSIBLE_VALUES\n@pythonfuzz(\n    data_handle=CSVWriter,\n    params={\n        \"columns\": ALL_POSSIBLE_VALUES,\n        \"is_folder\": [True, False, None],\n        \"chunksize\": ALL_POSSIBLE_VALUES,\n    },\n)\ndef your_custom_fuzz_test(data_from_data_handle, dtype, is_folder, header):\n    ...\n    ...\n    ...\n```\n\n----------------------------------------\n\nTITLE: Illustrating Open-ended Greedy Quantifier in Regex\nDESCRIPTION: Shows the open-ended greedy quantifier '{n,}' which repeats the previous item at least n times, matching as many as possible.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/regex.md#2025-04-21_snippet_8\n\nLANGUAGE: regex\nCODE:\n```\na{2,}\n```\n\n----------------------------------------\n\nTITLE: Displaying Head of Sparse cuDF DataFrame\nDESCRIPTION: Displays the first few rows of the sparsely populated cuDF DataFrame `df` using the `.head()` method.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/cupy-interop.ipynb#2025-04-21_snippet_19\n\nLANGUAGE: python\nCODE:\n```\ndf.head()\n```\n\n----------------------------------------\n\nTITLE: Implementing Dependent Fixtures for Complex Test Parametrization in Python\nDESCRIPTION: Example demonstrating how to create dependent pytest fixtures where one fixture depends on another to handle complex parametrization scenarios.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/testing.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@pytest.fixture(params=[\"a\", \"b\"])\ndef foo(request):\n    if request.param == \"a\":\n        # Some complex initialization\n    elif request.param == \"b\":\n        # Some other complex initialization\n\n@pytest.fixture\ndef bar(foo):\n   # do something with foo like initialize a cudf object.\n\ndef test_some_property(bar):\n    # will be run for each value of bar that results from each value of foo.\n    assert some_property_of(bar)\n```\n\n----------------------------------------\n\nTITLE: Namespace Export Declaration in C++\nDESCRIPTION: Example showing how to properly mark symbols with CUDF_EXPORT in external/public libcudf C++ API header files by placing the macro on the cudf namespace.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#pragma once\n\nnamespace CUDF_EXPORT cudf {\nnamespace lists {\n\n...\n\n\n} // namespace lists\n} // namespace CUDF_EXPORT cudf\n```\n\n----------------------------------------\n\nTITLE: Adding Deprecation Notice in Docstring\nDESCRIPTION: Example of adding a deprecation admonition to API docstrings, specifying when the deprecation occurred.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/contributing_guide.md#2025-04-21_snippet_1\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. deprecated:: 23.08\n    `foo` is deprecated and will be removed in a future version of cudf.\n```\n\n----------------------------------------\n\nTITLE: Setting CUDF Kafka Library Properties\nDESCRIPTION: Configures the library properties including RPATH settings and C++ standard requirements.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/libcudf_kafka/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset_target_properties(\n  cudf_kafka\n  PROPERTIES BUILD_RPATH \"\\$ORIGIN\"\n             INSTALL_RPATH \"\\$ORIGIN\" # set target compile options\n             CXX_STANDARD 17\n             CXX_STANDARD_REQUIRED ON\n)\n\nadd_library(cudf_kafka::cudf_kafka ALIAS cudf_kafka)\n```\n\n----------------------------------------\n\nTITLE: Updating Groupby.nth and Groupby.dtypes Behavior in cuDF (Python)\nDESCRIPTION: Groupby.nth and Groupby.dtypes now include the grouped column in the result, preserving the original Index. This snippet demonstrates the old and new behavior of these functions.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/pandas-2.0-breaking-changes.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nIn [31]: df = cudf.DataFrame(\n    ...:         {\n    ...:             \"a\": [1, 1, 1, 2, 3],\n    ...:             \"b\": [1, 2, 2, 2, 1],\n    ...:             \"c\": [1, 2, None, 4, 5],\n    ...:             \"d\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n    ...:         }\n    ...:     )\n    ...: \n\nIn [32]: df\nOut[32]:\n   a  b     c  d\n0  1  1     1  a\n1  1  2     2  b\n2  1  2  <NA>  c\n3  2  2     4  d\n4  3  1     5  e\n\nIn [33]: df.groupby('a').nth(1)\nOut[33]:\n   b  c  d\na\n1  2  2  b\n\nIn [34]: df.groupby('a').dtypes\nOut[34]:\n       b      c       d\na\n1  int64  int64  object\n2  int64  int64  object\n3  int64  int64  object\n```\n\nLANGUAGE: python\nCODE:\n```\nIn [33]: df.groupby('a').nth(1)\nOut[33]:\n   a  b    c  d\n1  1  2  2.0  b\n\nIn [34]: df.groupby('a').dtypes\nOut[34]:\n       a      b      c       d\na\n1  int64  int64  int64  object\n2  int64  int64  int64  object\n3  int64  int64  int64  object\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lazy Range Quantifier in Regex\nDESCRIPTION: Illustrates the lazy range quantifier '{n,m}?' which repeats the previous item between n and m times, trying n times first.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/regex.md#2025-04-21_snippet_9\n\nLANGUAGE: regex\nCODE:\n```\na{2,4}?\n```\n\n----------------------------------------\n\nTITLE: Checking CuPy Array Memory Layout\nDESCRIPTION: Checks if a CuPy array is stored in Fortran-contiguous memory order using cp.isfortran(), which is important for certain conversions.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/cupy-interop.ipynb#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ncp.isfortran(reshaped_arr)\n```\n\n----------------------------------------\n\nTITLE: Specializing Type-Dispatched Code Paths with Explicit Specialization\nDESCRIPTION: This example illustrates how to specialize type-dispatched code paths using explicit, full template specialization. The `type_printer` struct prints different messages based on whether it is invoked with `int32_t`, `double`, or another type, demonstrating how to customize behavior for specific types during type dispatch.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_29\n\nLANGUAGE: c++\nCODE:\n```\nstruct type_printer {\ntemplate <typename ColumnType>\nvoid operator()() { std::cout << \"unhandled type\\n\"; }\n};\n\n// Due to a bug in g++, explicit member function specializations need to be\n// defined outside of the class definition\ntemplate <>\nvoid type_printer::operator()<int32_t>() { std::cout << \"int32_t\\n\"; }\n\ntemplate <>\nvoid type_printer::operator()<double>() { std::cout << \"double\\n\"; }\n```\n\n----------------------------------------\n\nTITLE: Offset Normalizing Output Iterator Usage Example\nDESCRIPTION: This snippet demonstrates the use of an output offsetalator.  After creating the offsets column, it obtains the output iterator from that column's mutable view. This iterator, `d_offsets`, is then used to write offset values.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_18\n\nLANGUAGE: c++\nCODE:\n```\n    // create offsets column as either INT32 or INT64 depending on the number of bytes\n    auto offsets_column = cudf::strings::detail::create_offsets_child_column(total_bytes,\n                                                                             offsets_count,\n                                                                             stream, mr);\n    auto d_offsets =\n      cudf::detail::offsetalator_factory::make_output_iterator(offsets_column->mutable_view());\n    // write appropriate offset values to d_offsets\n\n```\n\n----------------------------------------\n\nTITLE: Converting cuDF DataFrame to NumPy Array\nDESCRIPTION: Shows how to convert an entire cuDF DataFrame to a NumPy ndarray using the to_numpy() method, which transfers the data from GPU memory to CPU memory.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_37\n\nLANGUAGE: python\nCODE:\n```\ndf.to_numpy()\n```\n\n----------------------------------------\n\nTITLE: Converting CuPy Array Diagonal to cuDF Series and Displaying Head\nDESCRIPTION: Converts the diagonal of a reshaped CuPy array to a cuDF Series and displays its head. It uses the `cudf.Series` constructor to create the Series.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/cupy-interop.ipynb#2025-04-21_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ncudf.Series(reshaped_arr.diagonal()).head()\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Node Transformation Function with Single Dispatch in Python\nDESCRIPTION: Template for creating a rewrite rule using Python's singledispatch for type-based dispatching. The function takes an expression and a transformation function that handles recursion.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_polars/docs/overview.md#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom cudf_polars.typing import GenericTransformer\n\n@singledispatch\ndef rewrite(e: Expr, rec: GenericTransformer[Expr, T]) -> T:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for cuDF Transformation Replace Group\nDESCRIPTION: This Sphinx directive generates documentation for the transformation_replace group in the RAPIDS cuDF library. It includes all members of the group in the generated output.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/transformation_replace.rst#2025-04-21_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. doxygengroup:: transformation_replace\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring CUDA Interoperability Example Project in CMake\nDESCRIPTION: This CMake script sets up a CUDA interoperability example project that uses the RAPIDS cuDF library. It includes configuration for CUDA architectures, project metadata, dependency management, build settings, and target compilation specifications.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/examples/interop/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# Copyright (c) 2024-2025, NVIDIA CORPORATION.\n\ncmake_minimum_required(VERSION 3.30.4 FATAL_ERROR)\n\ninclude(../set_cuda_architecture.cmake)\n\nrapids_cuda_init_architectures(interop_example)\n\nproject(\n  interop_example\n  VERSION 0.0.1\n  LANGUAGES CXX CUDA\n)\n\ninclude(../fetch_dependencies.cmake)\n\ninclude(rapids-cmake)\nrapids_cmake_build_type(\"Release\")\n\n# The Arrow CMake is currently broken if the build type is not set\nset(CMAKE_BUILD_TYPE Release)\n# No need to install Arrow libs when only the final example executable is shipped.\nset(CUDF_EXCLUDE_ARROW_FROM_ALL ON)\ninclude(../../cmake/thirdparty/get_arrow.cmake)\n\nadd_executable(interop interop.cpp)\ntarget_link_libraries(interop PRIVATE cudf::cudf)\ntarget_compile_features(interop PRIVATE cxx_std_17)\ntarget_link_libraries(interop PRIVATE ${ARROW_LIBRARIES})\n```\n\n----------------------------------------\n\nTITLE: Installing cuDF via conda\nDESCRIPTION: Command to install cuDF using conda package manager with specific version requirements for Python and CUDA\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_polars/README.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nconda install -c rapidsai -c conda-forge -c nvidia \\\n    cudf=25.06 python=3.12 cuda-version=12.8\n```\n\n----------------------------------------\n\nTITLE: Configuring Sort Tests in CMake\nDESCRIPTION: Sets up tests for sorting operations including segmented sorting, nested type sorting, general sorting, stable sorting, and ranking. Specifies GPU requirements and test allocation percentage.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_21\n\nLANGUAGE: CMake\nCODE:\n```\n# ##################################################################################################\n# * sort tests ------------------------------------------------------------------------------------\nConfigureTest(\n  SORT_TEST sort/segmented_sort_tests.cpp sort/sort_nested_types_tests.cpp sort/sort_test.cpp\n  sort/stable_sort_tests.cpp sort/rank_test.cpp\n  GPUS 1\n  PERCENT 70\n)\n```\n\n----------------------------------------\n\nTITLE: Fast-Slow Function Call Implementation\nDESCRIPTION: Core implementation of the fallback mechanism that attempts operations first with cuDF and falls back to Pandas on failure. Includes argument transformation and result wrapping.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/cudf_pandas.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef _fast_slow_function_call(func: Callable, *args, **kwargs):\n    try:\n        ...\n        fast_args, fast_kwargs = _fast_arg(args), _fast_arg(kwargs)\n        result = func(*fast_args, **fast_kwargs)\n        ...\n    except Exception:\n        ...\n        slow_args, slow_kwargs = _slow_arg(args), _slow_arg(kwargs)\n        result = func(*slow_args, **slow_kwargs)\n        ...\n    return _maybe_wrap_result(result, func, *args, **kwargs), fast\n```\n\n----------------------------------------\n\nTITLE: Running Pre-commit on All Files\nDESCRIPTION: Command to run pre-commit checks on all files in the repository, not just staged changes.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/CONTRIBUTING.md#2025-04-21_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\npre-commit run --all-files\n```\n\n----------------------------------------\n\nTITLE: Configuring Timestamps Tests in CUDA DataFrame\nDESCRIPTION: Sets up tests for timestamp functionality in cuDF using a CUDA source file for testing timestamp wrappers.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nConfigureTest(TIMESTAMPS_TEST wrappers/timestamps_test.cu)\n```\n\n----------------------------------------\n\nTITLE: Creating cuDF DataFrame from CuPy Array and Displaying Head\nDESCRIPTION: Creates a cuDF DataFrame from the CuPy array `reshaped_arr` and then displays the first few rows of the newly created DataFrame using the `.head()` method. This depends on `reshaped_arr` being defined.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/cupy-interop.ipynb#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nreshaped_df = cudf.DataFrame(reshaped_arr)\nreshaped_df.head()\n```\n\n----------------------------------------\n\nTITLE: Listing cuDF String APIs with Unicode Limitations\nDESCRIPTION: A list of cuDF string APIs that are affected by Unicode limitations, including character testing and case conversion functions. These functions only support Unicode code-points in the range 0-65535.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/unicode.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- cudf::strings::all_characters_of_type()\n- cudf::strings::to_upper()\n- cudf::strings::to_lower()\n- cudf::strings::capitalize()\n- cudf::strings::title()\n- cudf::strings::swapcase()\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Benchmark with benchmark_with_object Decorator\nDESCRIPTION: Example showing how to use the benchmark_with_object decorator to create a DataFrame benchmark that tests the 'foo' method with specific parameters including integer dtype and 6 columns.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/benchmarking.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@benchmark_with_object(cls=\"dataframe\", dtype=\"int\", cols=6)\ndef bench_foo(benchmark, dataframe):\n    benchmark(dataframe.foo)\n```\n\n----------------------------------------\n\nTITLE: Copy If Else Implementation using Iterators in libcudf\nDESCRIPTION: This C++ template function `copy_if_else` exemplifies the use of iterators in libcudf for generic algorithms. It copies elements from either `lhs_begin` to `lhs_end` or `rhs` based on a boolean `filter`. The function is designed to handle different combinations of column and scalar parameters by using iterators, simplifying the implementation for diverse input types.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_14\n\nLANGUAGE: c++\nCODE:\n```\ntemplate <typename FilterFn, typename LeftIter, typename RightIter>\nstd::unique_ptr<column> copy_if_else(\n  bool nullable,\n  LeftIter lhs_begin,\n  LeftIter lhs_end,\n  RightIter rhs,\n  FilterFn filter,\n  ...);\n\n```\n\n----------------------------------------\n\nTITLE: Running cudf-polars Tests\nDESCRIPTION: Command to run the tests for the cudf-polars package using pytest.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_polars/docs/overview.md#2025-04-21_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\npytest -v tests\n```\n\n----------------------------------------\n\nTITLE: Configuring Join Tests in CUDA DataFrame\nDESCRIPTION: Sets up tests for different join operations in cuDF. This includes standard joins, conditional joins, cross joins, semi/anti joins, mixed joins, and distinct joins using both C++ and CUDA source files.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nConfigureTest(\n  JOIN_TEST join/join_tests.cpp join/conditional_join_tests.cu join/cross_join_tests.cpp\n  join/semi_anti_join_tests.cpp join/mixed_join_tests.cu join/distinct_join_tests.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Returning Multiple Values in libcudf Functions (C++)\nDESCRIPTION: Demonstrates how to return multiple values from a function using std::pair and std::tie in libcudf.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\nstd::pair<table, table> return_two_tables(void){\n  cudf::table out0;\n  cudf::table out1;\n  ...\n  // Do stuff with out0, out1\n\n  // Return a std::pair of the two outputs\n  return std::pair(std::move(out0), std::move(out1));\n}\n\ncudf::table out0;\ncudf::table out1;\nstd::tie(out0, out1) = cudf::return_two_outputs();\n```\n\n----------------------------------------\n\nTITLE: Activating pandas Virtual Environment in Bash\nDESCRIPTION: Activates the previously created pandas virtual environment.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/benchmarks.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsource pandas/py-pandas/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Group Documentation for Utility APIs in reStructuredText\nDESCRIPTION: This snippet uses a Doxygen directive to generate documentation for the 'utility_apis' group, including all its members. It's typically used in Sphinx documentation to incorporate API references.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/utility_apis.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: utility_apis\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Setting Logging Level Configuration for libcudf\nDESCRIPTION: Configures the logging level for the cuDF library, allowing users to choose between different verbosity levels (TRACE, DEBUG, INFO, WARN, ERROR, CRITICAL, OFF). The default level is set to INFO.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n# Set logging level\nset(LIBCUDF_LOGGING_LEVEL\n    \"INFO\"\n    CACHE STRING \"Choose the logging level.\"\n)\nset_property(\n  CACHE LIBCUDF_LOGGING_LEVEL PROPERTY STRINGS \"TRACE\" \"DEBUG\" \"INFO\" \"WARN\" \"ERROR\" \"CRITICAL\"\n                                       \"OFF\"\n)\nmessage(VERBOSE \"CUDF: LIBCUDF_LOGGING_LEVEL = '${LIBCUDF_LOGGING_LEVEL}'.\")'\n```\n\n----------------------------------------\n\nTITLE: Initializing CUDA Architecture for Nested Types Project in CMake\nDESCRIPTION: Sets up the CUDA architecture configuration for the nested_types project by including the set_cuda_architecture.cmake file and initializing CUDA architectures.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/examples/nested_types/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.30.4 FATAL_ERROR)\n\ninclude(../set_cuda_architecture.cmake)\n\n# initialize cuda architecture\nrapids_cuda_init_architectures(nested_types)\n```\n\n----------------------------------------\n\nTITLE: Configuring Dask DataFrame Backend for cuDF\nDESCRIPTION: Shows how to configure Dask to use cuDF as the DataFrame backend using Python configuration.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/dask_cudf/source/index.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport dask\n\ndask.config.set({\"dataframe.backend\": \"cudf\"})\n```\n\n----------------------------------------\n\nTITLE: Configuring Iterator Tests in CMake\nDESCRIPTION: Sets up tests for various iterator implementations including indexalator, offsetalator, optional iterators, pair iterators, scalar iterators, and value iterators with support for different data types.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_25\n\nLANGUAGE: CMake\nCODE:\n```\n# ##################################################################################################\n# * iterator tests --------------------------------------------------------------------------------\nConfigureTest(\n  ITERATOR_TEST\n  iterator/indexalator_test.cu\n  iterator/offsetalator_test.cu\n  iterator/optional_iterator_test_chrono.cu\n  iterator/optional_iterator_test_numeric.cu\n  iterator/pair_iterator_test_chrono.cu\n  iterator/pair_iterator_test_numeric.cu\n  iterator/scalar_iterator_test.cu\n  iterator/sizes_to_offsets_iterator_test.cu\n  iterator/value_iterator.cpp\n  iterator/value_iterator_test_chrono.cu\n  iterator/value_iterator_test_numeric.cu\n  iterator/value_iterator_test_strings.cu\n  iterator/value_iterator_test_transform.cu\n)\n```\n\n----------------------------------------\n\nTITLE: Creating New Final Proxy Types in cuDF Pandas\nDESCRIPTION: Example showing how to create a new final proxy type for DataFrame using make_final_proxy_type function, including conversion methods between fast and slow implementations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/cudf_pandas.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nDataFrame = make_final_proxy_type(\n    \"DataFrame\",\n    cudf.DataFrame,\n    pd.DataFrame,\n    fast_to_slow=lambda fast: fast.to_pandas(),\n    slow_to_fast=cudf.from_pandas,\n)\n```\n\n----------------------------------------\n\nTITLE: Building cuDF in Debug Mode\nDESCRIPTION: Command to build the libcudf C++ library in debug mode, which enables assert safety checks and includes symbols for debugging.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/CONTRIBUTING.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh libcudf -g\n```\n\n----------------------------------------\n\nTITLE: Configuring Device Atomics Tests in CMake\nDESCRIPTION: Sets up tests for device atomic operations used in CUDA calculations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_26\n\nLANGUAGE: CMake\nCODE:\n```\n# ##################################################################################################\n# * device atomics tests --------------------------------------------------------------------------\nConfigureTest(DEVICE_ATOMICS_TEST device_atomics/device_atomics_test.cu)\n```\n\n----------------------------------------\n\nTITLE: Documenting Class Methods and Attributes in Python Docstrings\nDESCRIPTION: This snippet demonstrates how to document class methods and attributes in Python docstrings, specifically for classes that should only include a subset of APIs.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/documentation.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n    Attributes\n    ----------\n    codes\n    categories\n\n    Methods\n    -------\n    None\n```\n\n----------------------------------------\n\nTITLE: Generating IO APIs Documentation with Doxygen and Sphinx in RST\nDESCRIPTION: This RST code snippet sets up the structure for documenting IO APIs in cuDF. It uses Doxygen to generate member documentation and Sphinx toctree for organizing the content into subcategories.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/io_apis.rst#2025-04-21_snippet_0\n\nLANGUAGE: RST\nCODE:\n```\nIo APIs\n=======\n\n.. doxygengroup:: io_apis\n   :members:\n\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n\n   io_types\n   io_readers\n   io_writers\n   io_datasources\n   io_datasinks\n```\n\n----------------------------------------\n\nTITLE: Running Modified pandas Benchmarks in Bash\nDESCRIPTION: Executes the modified pandas benchmarks for groupby and join operations with different dataset sizes.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/benchmarks.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./_launcher/solution.R --solution=pandas --task=groupby --nrow=1e7\n./_launcher/solution.R --solution=pandas --task=groupby --nrow=1e8\n./_launcher/solution.R --solution=pandas --task=join --nrow=1e7\n./_launcher/solution.R --solution=pandas --task=join --nrow=1e8\n```\n\n----------------------------------------\n\nTITLE: Referencing Core Data Structures in libcudf\nDESCRIPTION: Shows the two fundamental data structures provided by libcudf: cudf::column and cudf::table. These structures form the foundation of the column-oriented tabular data representation used for GPU data processing.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/main_page.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\ncudf::column, and cudf::table\n```\n\n----------------------------------------\n\nTITLE: Installing Pre-commit via Pip\nDESCRIPTION: Command to install pre-commit tool using pip package manager.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/CONTRIBUTING.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\npip install pre-commit\n```\n\n----------------------------------------\n\nTITLE: Configuring DateTime Operations Tests in CUDA DataFrame\nDESCRIPTION: Sets up tests for datetime operations in cuDF using a C++ source file to test functionality for handling dates and times.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nConfigureTest(DATETIME_OPS_TEST datetime/datetime_ops_test.cpp)\n```\n\n----------------------------------------\n\nTITLE: Further Copy-on-Write Operations with Multiple Series\nDESCRIPTION: Demonstrates how modifying another Series triggers another copy operation, changing its memory address while preserving the data in other copies. Shows the cascading effect of copy-on-write on multiple objects.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/library_design.md#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> s1[0:2] = 11\n>>> s1\n0    11\n1    11\n2     3\n3     4\ndtype: int64\n>>> s2\n0    10\n1    10\n2     3\n3     4\ndtype: int64\n>>> s3\n0    1\n1    2\n2    3\n3    4\ndtype: int64\n\n>>> s2.data._ptr\n139796315899392\n>>> s3.data._ptr\n139796315897856\n>>> s1.data._ptr\n139796315879723\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Build for pylibcudf in RAPIDS Project\nDESCRIPTION: This CMake script configures the build environment for the Python bindings of cuDF. It sets minimum CMake version, initializes CUDA architectures, defines the project and its version, finds required dependencies, and sets up necessary third-party libraries like dlpack for interoperability functions.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.30.4 FATAL_ERROR)\n\ninclude(../../cmake/rapids_config.cmake)\ninclude(rapids-cuda)\nrapids_cuda_init_architectures(pylibcudf)\n\nproject(\n  pylibcudf\n  VERSION \"${RAPIDS_VERSION}\"\n  LANGUAGES CXX CUDA\n)\n\nfind_package(cudf \"${RAPIDS_VERSION}\" REQUIRED)\n\n# an installed version of libcudf doesn't provide the dlpack headers so we need to download dlpack\n# for the interop.pyx\ninclude(rapids-cpm)\nrapids_cpm_init()\ninclude(../../cpp/cmake/thirdparty/get_dlpack.cmake)\n\ninclude(rapids-cython-core)\n\nrapids_cython_init()\n\nadd_subdirectory(pylibcudf)\n```\n\n----------------------------------------\n\nTITLE: String Column Offset Example in cuDF\nDESCRIPTION: Demonstrates the offset values used to index into the character array for a StringColumn implementation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/library_design.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n[0, 2, 5, 9, 12, 19]\n```\n\n----------------------------------------\n\nTITLE: Illustrating Greedy Quantifier (*) in Regex\nDESCRIPTION: Demonstrates the greedy quantifier '*' which repeats the previous item zero or more times, matching as many items as possible.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/regex.md#2025-04-21_snippet_1\n\nLANGUAGE: regex\nCODE:\n```\n\".*\"\n```\n\n----------------------------------------\n\nTITLE: Including Dependencies and Setting Build Type in CMake\nDESCRIPTION: Imports necessary dependency configurations and sets the build type to Release using RAPIDS CMake utilities.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/examples/nested_types/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(../fetch_dependencies.cmake)\n\ninclude(rapids-cmake)\nrapids_cmake_build_type(\"Release\")\n```\n\n----------------------------------------\n\nTITLE: Printing Spill Statistics in Dask Workers\nDESCRIPTION: Code snippet demonstrates how to gather and print spill statistics from each worker in a Dask cluster. This helps monitor memory spilling behavior across distributed compute nodes.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/library_design.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n    def spill_info():\n        from cudf.core.buffer.spill_manager import get_global_manager\n        print(get_global_manager().statistics)\n    client.submit(spill_info)\n```\n\n----------------------------------------\n\nTITLE: Configuring CUDF Tests and Benchmarks in CMake\nDESCRIPTION: Sets up test and benchmark targets for CUDF. Includes configuration for CTest, CUDA memory checking, and optional benchmark libraries like GoogleBench and nvbench. Adds subdirectories for tests and benchmarks if enabled.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_26\n\nLANGUAGE: CMake\nCODE:\n```\nif(CUDF_BUILD_TESTS)\n  include(CTest)\n\n  find_program(CUDA_SANITIZER compute-sanitizer)\n  set(MEMORYCHECK_COMMAND ${CUDA_SANITIZER})\n  set(MEMORYCHECK_TYPE CudaSanitizer)\n  set(CUDA_SANITIZER_COMMAND_OPTIONS \"--tool memcheck\")\n\n  list(APPEND CMAKE_CTEST_ARGUMENTS \"--output-on-failure\")\n  add_subdirectory(tests)\nendif()\n\nif(CUDF_BUILD_BENCHMARKS)\n  include(${rapids-cmake-dir}/cpm/gbench.cmake)\n  rapids_cpm_gbench(BUILD_STATIC)\n\n  include(cmake/thirdparty/get_nvbench.cmake)\n\n  add_subdirectory(benchmarks)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Enabling cudf.pandas through explicit import\nDESCRIPTION: Shows how to enable cudf.pandas programmatically through explicit import and installation, which is useful when command line flags cannot be controlled or when working in interactive environments.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/usage.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport cudf.pandas\ncudf.pandas.install()\n\nimport pandas as pd\n```\n\n----------------------------------------\n\nTITLE: Accessing Proxy Type Metadata\nDESCRIPTION: Demonstrates how to access proxy type metadata using metaclasses in cuDF Pandas.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/cudf_pandas.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport cudf.pandas\ncudf.pandas.install()\nimport pandas as xpd\n\nprint(xpd.Series._fsproxy_fast) # output is cudf.core.series.Series\n```\n\n----------------------------------------\n\nTITLE: Benchmarking CuPy Array to cuDF DataFrame Conversion\nDESCRIPTION: Benchmarks the performance of converting a CuPy array to a cuDF DataFrame using the DataFrame constructor.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/cupy-interop.ipynb#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n%timeit reshaped_df = cudf.DataFrame(reshaped_arr)\n```\n\n----------------------------------------\n\nTITLE: Lists Column Wrapper Examples in C++\nDESCRIPTION: Demonstrates creation of list columns with various nested structures, including empty lists, lists of integers, lists of lists, and lists with nullable elements.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/TESTING.md#2025-04-21_snippet_8\n\nLANGUAGE: c++\nCODE:\n```\n// Creates an empty LIST column\n// []\ncudf::test::lists_column_wrapper l{};\n\n// Creates a LIST column with 1 list composed of 2 total integers\n// [{0, 1}]\ncudf::test::lists_column_wrapper l{0, 1};\n\n// Creates a LIST column with 3 lists\n// [{0, 1}, {2, 3}, {4, 5}]\ncudf::test::lists_column_wrapper l{ {0, 1}, {2, 3}, {4, 5} };\n\n// Creates a LIST of LIST columns with 2 lists on the top level and\n// 4 below\n// [ {{0, 1}, {2, 3}}, {{4, 5}, {6, 7}} ]\ncudf::test::lists_column_wrapper l{ {{0, 1}, {2, 3}}, {{4, 5}, {6, 7}} };\n\n// Creates a LIST column with 1 list composed of 5 total integers\n// [{0, 1, 2, 3, 4}]\nauto elements = cudf::detail::make_counting_transform_iterator(0, [](auto i){return i*2;});\ncudf::test::lists_column_wrapper l(elements, elements+5);\n\n// Creates a LIST column with 1 lists composed of 2 total integers\n// [{0, NULL}]\nauto validity = cudf::detail::make_counting_transform_iterator(0, [](auto i){return i % 2;});\ncudf::test::lists_column_wrapper l{{0, 1}, validity};\n\n// Creates a LIST column with 1 lists composed of 5 total integers\n// [{0, NULL, 2, NULL, 4}]\nauto elements = cudf::detail::make_counting_transform_iterator(0, [](auto i){return i*2;});\nauto validity = cudf::detail::make_counting_transform_iterator(0, [](auto i){return i % 2;});\ncudf::test::lists_column_wrapper l(elements, elements+5, validity);\n\n// Creates a LIST column with 1 list composed of 2 total strings\n// [{\"abc\", \"def\"}]\ncudf::test::lists_column_wrapper l{\"abc\", \"def\"};\n\n// Creates a LIST of LIST columns with 2 lists on the top level and 4 below\n// [ {{0, 1}, NULL}, {{4, 5}, NULL} ]\nauto validity = cudf::detail::make_counting_transform_iterator(0, [](auto i){return i % 2;});\ncudf::test::lists_column_wrapper l{ {{{0, 1}, {2, 3}}, validity}, {{{4, 5}, {6, 7}}, validity} };\n```\n\n----------------------------------------\n\nTITLE: Generating IO Types Documentation with Doxygen in reStructuredText\nDESCRIPTION: This snippet uses a Doxygen directive to generate documentation for the 'io_types' group in cuDF. It includes all members of the group.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/io_types.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: io_types\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Stream Compaction Tests in CMake\nDESCRIPTION: Sets up tests for stream compaction operations including boolean mask application, distinct operations, NaN/null handling, and unique element operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_30\n\nLANGUAGE: CMake\nCODE:\n```\n# ##################################################################################################\n# * stream compaction tests -----------------------------------------------------------------------\nConfigureTest(\n  STREAM_COMPACTION_TEST\n  stream_compaction/apply_boolean_mask_tests.cpp\n  stream_compaction/distinct_count_tests.cpp\n  stream_compaction/distinct_tests.cpp\n  stream_compaction/drop_nans_tests.cpp\n  stream_compaction/drop_nulls_tests.cpp\n  stream_compaction/stable_distinct_tests.cpp\n  stream_compaction/unique_count_tests.cpp\n  stream_compaction/unique_tests.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Gather Algorithm with pylibcudf - Cython\nDESCRIPTION: This Cython function mirrors the libcudf 'gather' algorithm in the pylibcudf library. It processes inputs using a Python preprocessing step, releases the Global Interpreter Lock (GIL), and calls the libcudf algorithm. Inputs include a table and column for gathering and an out-of-bounds policy. The function returns a pylibcudf Table constructed from the result of the libcudf function, ensuring type consistency.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/developer_docs.md#2025-04-21_snippet_1\n\nLANGUAGE: cython\nCODE:\n```\ncpdef Table gather(\n    Table source_table,\n    Column gather_map,\n    OutOfBoundsPolicy bounds_policy\n):\n    cdef unique_ptr[table] c_result\n    with nogil:\n        c_result = move(\n            cpp_copying.gather(\n                source_table.view(),\n                gather_map.view(),\n                bounds_policy\n            )\n        )\n    return Table.from_libcudf(move(c_result))\n```\n\n----------------------------------------\n\nTITLE: Building Library and Executables for Billion Rows Example in CMake\nDESCRIPTION: Defines build targets for the billion rows example, including a shared object library for groupby results and three different executable applications (brc, brc_chunks, brc_pipeline). It configures dependencies and installation paths for each target.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/examples/billion_rows/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(groupby_results OBJECT groupby_results.cpp)\ntarget_link_libraries(groupby_results PRIVATE cudf::cudf)\n\nadd_executable(brc brc.cpp)\ntarget_link_libraries(brc PRIVATE cudf::cudf nvToolsExt $<TARGET_OBJECTS:groupby_results>)\ninstall(TARGETS brc DESTINATION bin/examples/libcudf)\n\nadd_executable(brc_chunks brc_chunks.cpp)\ntarget_link_libraries(brc_chunks PRIVATE cudf::cudf nvToolsExt $<TARGET_OBJECTS:groupby_results>)\ninstall(TARGETS brc_chunks DESTINATION bin/examples/libcudf)\n\nadd_executable(brc_pipeline brc_pipeline.cpp)\ntarget_link_libraries(brc_pipeline PRIVATE cudf::cudf nvToolsExt $<TARGET_OBJECTS:groupby_results>)\ninstall(TARGETS brc_pipeline DESTINATION bin/examples/libcudf)\n```\n\n----------------------------------------\n\nTITLE: Configuring GroupBy Tests in CUDA DataFrame\nDESCRIPTION: Sets up extensive tests for GroupBy operations in cuDF. The tests cover various aggregation functions like min, max, sum, mean, and specialized operations like correlation, covariance, histograms, and user-defined functions. This configuration explicitly specifies to use 1 GPU and 100% test allocation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nConfigureTest(\n  GROUPBY_TEST\n  groupby/argmin_tests.cpp\n  groupby/argmax_tests.cpp\n  groupby/collect_list_tests.cpp\n  groupby/collect_set_tests.cpp\n  groupby/correlation_tests.cpp\n  groupby/count_scan_tests.cpp\n  groupby/count_tests.cpp\n  groupby/covariance_tests.cpp\n  groupby/groupby_test_util.cpp\n  groupby/groups_tests.cpp\n  groupby/histogram_tests.cpp\n  groupby/host_udf_example_tests.cu\n  groupby/host_udf_tests.cpp\n  groupby/keys_tests.cpp\n  groupby/lists_tests.cpp\n  groupby/m2_tests.cpp\n  groupby/min_tests.cpp\n  groupby/max_scan_tests.cpp\n  groupby/max_tests.cpp\n  groupby/mean_tests.cpp\n  groupby/median_tests.cpp\n  groupby/merge_m2_tests.cpp\n  groupby/merge_lists_tests.cpp\n  groupby/merge_sets_tests.cpp\n  groupby/min_scan_tests.cpp\n  groupby/nth_element_tests.cpp\n  groupby/nunique_tests.cpp\n  groupby/product_scan_tests.cpp\n  groupby/product_tests.cpp\n  groupby/quantile_tests.cpp\n  groupby/rank_scan_tests.cpp\n  groupby/replace_nulls_tests.cpp\n  groupby/shift_tests.cpp\n  groupby/std_tests.cpp\n  groupby/structs_tests.cpp\n  groupby/sum_of_squares_tests.cpp\n  groupby/sum_scan_tests.cpp\n  groupby/sum_tests.cpp\n  groupby/tdigest_tests.cu\n  groupby/var_tests.cpp\n  GPUS 1\n  PERCENT 100\n)\n```\n\n----------------------------------------\n\nTITLE: Custom GPU Engine Configuration\nDESCRIPTION: Shows how to create a custom GPUEngine instance with specific configuration options for more control over GPU execution.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_polars/usage.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport polars as pl\n\nengine = pl.GPUEngine(raise_on_fail=True)\n\nq = pl.scan_parquet(\"ny-taxi/2024/*.parquet\").filter(pl.col(\"total_amount\") > 15.0)\nresult = q.collect(engine=engine)\n```\n\n----------------------------------------\n\nTITLE: Defining Cython Sources for cudf String Conversion Modules\nDESCRIPTION: This snippet defines a list of Cython source files for various string conversion functionalities in cudf. These files handle conversions for different data types such as booleans, datetime, durations, fixed-point numbers, floats, integers, IPv4 addresses, lists, and URLs.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/pylibcudf/strings/convert/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(cython_sources\n    convert_booleans.pyx convert_datetime.pyx convert_durations.pyx convert_fixed_point.pyx\n    convert_floats.pyx convert_integers.pyx convert_ipv4.pyx convert_lists.pyx convert_urls.pyx\n)\n```\n\n----------------------------------------\n\nTITLE: Accessing Spill Statistics in cuDF\nDESCRIPTION: Shows how to access spilling statistics through the global spill manager when automatic buffer spilling is enabled. This is useful for performance profiling and memory management analysis.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/library_design.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> import cudf\n>>> from cudf.core.buffer.spill_manager import get_global_manager\n>>> stats = get_global_manager().statistics\n>>> print(stats)\n    Spill Statistics (level=1):\n     Spilling (level >= 1):\n      gpu => cpu: 24B in 0.0033\n```\n\n----------------------------------------\n\nTITLE: Enabling Per-Thread Default CUDA Stream\nDESCRIPTION: Conditionally adds compile definitions to enable per-thread default CUDA streams if the option is enabled.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/src/main/native/CMakeLists.txt#2025-04-21_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nif(CUDF_USE_PER_THREAD_DEFAULT_STREAM)\n  message(STATUS \"Using per-thread default stream\")\n  add_compile_definitions(CUDA_API_PER_THREAD_DEFAULT_STREAM CUDF_USE_PER_THREAD_DEFAULT_STREAM)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Exemplifying Greedy Quantifier (+) in Regex\nDESCRIPTION: Shows the usage of the greedy quantifier '+' which repeats the previous item once or more, matching as many items as possible.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/regex.md#2025-04-21_snippet_2\n\nLANGUAGE: regex\nCODE:\n```\n\".+\"\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Target for Running cuDF Benchmarks\nDESCRIPTION: Creates a custom CMake target named 'run_benchmarks' that depends on the CUDF_BENCHMARKS target. This provides a convenient way to run all cuDF benchmarks through a single command.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/benchmarks/CMakeLists.txt#2025-04-21_snippet_13\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_target(\n  run_benchmarks\n  DEPENDS CUDF_BENCHMARKS\n  COMMENT \"Custom command for running cudf benchmarks.\"\n)\n```\n\n----------------------------------------\n\nTITLE: String Column Data Example in cuDF\nDESCRIPTION: Example code showing the structure of a StringColumn containing text data, illustrating how string data is stored using character array and offset columns.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/library_design.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n['do', 'you', 'have', 'any', 'cheese?']\n```\n\n----------------------------------------\n\nTITLE: Configuring Binary Operation Tests in CMake\nDESCRIPTION: Sets up binary operation test executables covering input verification, null handling, compiled operations, fixed-point operations, and generic PTX tests.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_17\n\nLANGUAGE: CMake\nCODE:\n```\n# ##################################################################################################\n# * binary tests ----------------------------------------------------------------------------------\nConfigureTest(\n  BINARYOP_TEST\n  binaryop/binop-verify-input-test.cpp\n  binaryop/binop-null-test.cpp\n  binaryop/binop-compiled-test.cpp\n  binaryop/binop-compiled-fixed_point-test.cpp\n  binaryop/binop-generic-ptx-test.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Sorting Groupby Results in cuDF\nDESCRIPTION: Shows how to explicitly sort groupby results in cuDF to match Pandas behavior\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/pandas-comparison.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndf.groupby(\"a\", sort=True).mean().head()\ncudf.set_option(\"mode.pandas_compatible\", True)\ndf.groupby(\"a\").mean().head()\n```\n\n----------------------------------------\n\nTITLE: Updating reset_index Column Naming in cuDF (Python)\nDESCRIPTION: The reset_index function now names columns as None when name=None is passed, instead of using 0 or self.name. This snippet shows the old and new behavior of the function.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/pandas-2.0-breaking-changes.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nIn [2]: s = cudf.Series([1, 2, 3])\n\nIn [4]: s.reset_index(name=None)\nOut[4]:\n   index  0\n0      0  1\n1      1  2\n2      2  3\n```\n\nLANGUAGE: python\nCODE:\n```\nIn [7]: s.reset_index(name=None)\nOut[7]:\n   index  None\n0      0     1\n1      1     2\n2      2     3\n```\n\n----------------------------------------\n\nTITLE: Configuring Static Linking with CUDF Library\nDESCRIPTION: Implements special handling for statically linking against libcudf when building shared JNI libraries, creating a stub library for backwards compatibility.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/src/main/native/CMakeLists.txt#2025-04-21_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nif(CUDF_JNI_LIBCUDF_STATIC AND BUILD_SHARED_LIBS)\n  # When linking against libcudf.a, the JNI library will include the old libcudf.so. For\n  # backwards-compatibility for software that expects to find libcudf.so in the JVM environment\n  # after cudf has loaded, the JNI code and libcudf.a will be combined into libcudf.so. A stub\n  # library will be created for libcudfjni.so that will simply require libcudf.so for backwards\n  # compatibility with software that expects to find libcudfjni.so at runtime.\n  set_target_properties(cudfjni PROPERTIES OUTPUT_NAME \"cudf\")\n  add_library(cudfjnistub SHARED src/emptyfile.cpp)\n  set_target_properties(cudfjnistub PROPERTIES OUTPUT_NAME \"cudfjni\")\n  target_link_libraries(cudfjnistub -Wl,--no-as-needed cudfjni -Wl,--as-needed)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Casting and Accessing cudf::scalar Objects in C++\nDESCRIPTION: Demonstrates how to cast a unique_ptr<scalar> to its specific scalar class type using the scalar_type_t mapping utility. This is necessary for accessing the value of a scalar object.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\n//unique_ptr<scalar> s = make_numeric_scalar(...);\n\nusing ScalarType = cudf::scalar_type_t<T>;\n// ScalarType is now numeric_scalar<T>\nauto s1 = static_cast<ScalarType *>(s.get());\n```\n\n----------------------------------------\n\nTITLE: Doxygen Group Reference for Column Merge Operations in cuDF\nDESCRIPTION: A Sphinx/Doxygen directive that references the 'column_merge' group of functions in the cuDF library. The :members: option ensures that all members of this group are included in the generated documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/column_merge.rst#2025-04-21_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. doxygengroup:: column_merge\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Decimal Benchmark with NVBench in cuDF\nDESCRIPTION: Sets up the decimal conversion benchmarks for floating point operations using NVBench framework. This snippet configures the benchmark location at decimal/convert_floating.cpp.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/benchmarks/CMakeLists.txt#2025-04-21_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\nConfigureNVBench(DECIMAL_NVBENCH decimal/convert_floating.cpp)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Named Backreference in Regex Replacement\nDESCRIPTION: Shows the use of named backreferences (${1} through ${99}) to insert text matched by capturing groups in replacements.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/regex.md#2025-04-21_snippet_14\n\nLANGUAGE: regex\nCODE:\n```\n(a)(b)(c)\n```\n\n----------------------------------------\n\nTITLE: Disable Large Strings Support\nDESCRIPTION: This snippet disables large strings support by defining the `CUDF_LARGE_STRINGS_DISABLED` preprocessor macro. This can be used to reduce memory usage or improve performance in certain cases.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_22\n\nLANGUAGE: CMake\nCODE:\n```\nif(CUDF_LARGE_STRINGS_DISABLED)\n  target_compile_definitions(cudf PRIVATE CUDF_LARGE_STRINGS_DISABLED)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring CUDF Core Library Compilation in CMake\nDESCRIPTION: Sets up compilation definitions, dependencies, and linking options for the main CUDF library target. Includes settings for logging levels, remote I/O, and CUDA-specific optimizations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_23\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_definitions(\n  cudf PRIVATE \"CUDF_LOG_ACTIVE_LEVEL=RAPIDS_LOGGER_LOG_LEVEL_${LIBCUDF_LOGGING_LEVEL}\"\n)\n\ntarget_compile_definitions(cudf PRIVATE $<$<BOOL:${CUDF_KVIKIO_REMOTE_IO}>:CUDF_KVIKIO_REMOTE_IO>)\n\ntarget_compile_definitions(cudf PRIVATE THRUST_FORCE_32_BIT_OFFSET_TYPE=1 CCCL_AVOID_SORT_UNROLL=1)\n\nadd_dependencies(cudf jitify_preprocess_run)\n\ntarget_link_libraries(\n  cudf\n  PUBLIC CCCL::CCCL rapids_logger::rapids_logger rmm::rmm $<BUILD_LOCAL_INTERFACE:BS::thread_pool>\n  PRIVATE $<BUILD_LOCAL_INTERFACE:nvtx3::nvtx3-cpp> cuco::cuco ZLIB::ZLIB nvcomp::nvcomp\n          kvikio::kvikio nanoarrow zstd\n)\n```\n\n----------------------------------------\n\nTITLE: Displaying Head of reshaped_df\nDESCRIPTION: Displays the first few rows of the `reshaped_df` cuDF DataFrame using the `.head()` method.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/cupy-interop.ipynb#2025-04-21_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nreshaped_df.head()\n```\n\n----------------------------------------\n\nTITLE: Creating cudf String Conversion Cython Modules with RAPIDS CMake Function\nDESCRIPTION: This snippet uses a custom RAPIDS CMake function to create Cython modules for string conversion. It specifies the language (CXX), source files, linked libraries, module prefix, and associated targets. This function likely handles the compilation and linking process for the Cython modules.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/pylibcudf/strings/convert/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nrapids_cython_create_modules(\n  CXX\n  SOURCE_FILES \"${cython_sources}\"\n  LINKED_LIBRARIES \"${linked_libraries}\" MODULE_PREFIX pylibcudf_strings_ ASSOCIATED_TARGETS cudf\n)\n```\n\n----------------------------------------\n\nTITLE: Installing cuDF with CUDA 11.x via pip\nDESCRIPTION: Command to install cuDF package for CUDA 11.x environments using pip package manager\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_polars/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install --extra-index-url=https://pypi.nvidia.com cudf-cu11\n```\n\n----------------------------------------\n\nTITLE: Showing Greedy Range Quantifier in Regex\nDESCRIPTION: Demonstrates the greedy range quantifier '{n,m}' which repeats the previous item between n and m times, trying m times first.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/regex.md#2025-04-21_snippet_7\n\nLANGUAGE: regex\nCODE:\n```\na{2,4}\n```\n\n----------------------------------------\n\nTITLE: Index Class Inheritance Definition in Python\nDESCRIPTION: Shows the class inheritance structure for the Index class in cuDF, demonstrating how it inherits from both SingleColumnFrame and BaseIndex classes.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/library_design.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Index(SingleColumnFrame, BaseIndex)\n```\n\n----------------------------------------\n\nTITLE: Installing cuDF Header Files\nDESCRIPTION: Installs cuDF header directories including the main cuDF headers, test headers, and nvtext headers to the configured include directory.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_30\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(DIRECTORY ${CUDF_SOURCE_DIR}/include/cudf ${CUDF_SOURCE_DIR}/include/cudf_test\n                  ${CUDF_SOURCE_DIR}/include/nvtext DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n)\n```\n\n----------------------------------------\n\nTITLE: Building Polars in Release Mode\nDESCRIPTION: Command to build Polars in release mode with optimizations for the native CPU, which is best for benchmarking purposes.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_polars/docs/overview.md#2025-04-21_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nRUSTFLAGS='-C target-cpu=native' maturin develop -m Cargo.toml --release\n```\n\n----------------------------------------\n\nTITLE: Calculating Norm of CuPy Array\nDESCRIPTION: Calculates the norm (magnitude) of the reshaped CuPy array `reshaped_arr` using `cp.linalg.norm`.  It relies on the CuPy array `reshaped_arr` from the previous snippet.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/cupy-interop.ipynb#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ncp.linalg.norm(reshaped_arr)\n```\n\n----------------------------------------\n\nTITLE: Manual IR Translation and Execution for Debugging in Python\nDESCRIPTION: Debugging approach that manually translates a LazyFrame to the intermediate representation, executes it, and converts back to Polars, allowing for Python debugging of any issues.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_polars/docs/overview.md#2025-04-21_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom cudf_polars.dsl.translate import Translator\nimport polars as pl\n\nq = ...\n\n# Convert to our IR\nir = Translator(q._ldf.visit(), pl.GPUEngine()).translate_ir()\n\n# DataFrame living on the device\nresult = ir.evaluate(cache={})\n\n# Polars dataframe\nhost_result = result.to_polars()\n```\n\n----------------------------------------\n\nTITLE: Configuring Conda Environment and Compiler Options for CUDF in CMake\nDESCRIPTION: Sets up the conda environment, configures CMake module path, finds CUDA toolkit, and includes CUDA configuration module. This snippet establishes the basic build environment for CUDF.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nrapids_cmake_support_conda_env(conda_env MODIFY_PREFIX_PATH)\n\nset(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake/Modules ${CMAKE_MODULE_PATH})\nrapids_find_package(\n  CUDAToolkit REQUIRED\n  BUILD_EXPORT_SET cudf-exports\n  INSTALL_EXPORT_SET cudf-exports\n)\ninclude(cmake/Modules/ConfigureCUDA.cmake) # set other CUDA compilation flags\n```\n\n----------------------------------------\n\nTITLE: Configuring Project Settings for libcudf-python in CMake\nDESCRIPTION: Sets up the CMake project for libcudf-python with version information from RAPIDS_VERSION. Defines build options, dependency handling, and directory configurations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/libcudf/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.30.4 FATAL_ERROR)\n\ninclude(../../cmake/rapids_config.cmake)\n\nproject(\n  libcudf-python\n  VERSION \"${RAPIDS_VERSION}\"\n  LANGUAGES CXX\n)\n```\n\n----------------------------------------\n\nTITLE: Printing column data in CUDF tests\nDESCRIPTION: This example shows how to use the print function from debug utilities to display column content for both standard and split columns in test output.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/TESTING.md#2025-04-21_snippet_12\n\nLANGUAGE: c++\nCODE:\n```\n  cudf::test::fixed_width_column_wrapper<int32_t> input({1,2,3,4});\n  auto splits = cudf::split(input,{2});\n  cudf::test::print(input);\n  cudf::test::print(splits.front());\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for Set Operations in cuDF\nDESCRIPTION: This reStructuredText directive instructs Doxygen to generate documentation for all members of the 'set_operations' group in cuDF. It is used to create API documentation for set operation functions in the library.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/set_operations.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: set_operations\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Testing Framework for CUDA DataFrame\nDESCRIPTION: Initializes testing for the cuDF project by enabling testing and including the required rapids-test module. This sets up the foundation for all test configurations that follow.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nenable_testing()\n\ninclude(rapids-test)\nrapids_test_init()\n```\n\n----------------------------------------\n\nTITLE: Registering Column-Specific Handler for Renaming in Python\nDESCRIPTION: Specialized handler for Col nodes in the rename transformation, which accesses state from the transformer and creates a new column with the renamed field if applicable.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_polars/docs/overview.md#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n@_rename.register\ndef _(e: Col, rec: ExprTransformer) -> Expr:\n    mapping = rec.state[\"mapping\"] # state set on rec\n    if e.name in mapping:\n        # If we have a rename, return a new Col reference\n        # with a new name\n        return type(e)(e.dtype, mapping[e.name])\n    return e\n```\n\n----------------------------------------\n\nTITLE: Installing cuDF Core Library and Headers\nDESCRIPTION: Configures the installation of the main cuDF target and version header file to the specified library and include directories.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_28\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(\n  TARGETS cudf\n  DESTINATION ${lib_dir}\n  EXPORT cudf-exports\n)\ninstall(FILES ${CUDF_BINARY_DIR}/include/cudf/version_config.hpp\n        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/cudf\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Configuration for NVIDIA cuDF Library\nDESCRIPTION: Main CMake configuration file for cuDF library that sets up project requirements, includes required modules, and initializes CUDA architectures. It requires CMake 3.30.4+ and sets up the project with C, C++, and CUDA language support.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.30.4 FATAL_ERROR)\n\ninclude(../cmake/rapids_config.cmake)\ninclude(rapids-cmake)\ninclude(rapids-cpm)\ninclude(rapids-cuda)\ninclude(${rapids-cmake-dir}/cuda/set_runtime.cmake)\ninclude(rapids-export)\ninclude(rapids-find)\n\nrapids_cuda_init_architectures(CUDF)\n\nproject(\n  CUDF\n  VERSION \"${RAPIDS_VERSION}\"\n  LANGUAGES C CXX CUDA\n)\n```\n\n----------------------------------------\n\nTITLE: Custom Age Classification UDF\nDESCRIPTION: Defines a user-defined function for age classification into different groups based on age ranges.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/performance-comparisons/performance-comparisons.ipynb#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef age_udf(row):\n    if row[\"age\"] < 18:\n        return 0\n    elif 18 <= row[\"age\"] < 20:\n        return 1\n    elif 20 <= row[\"age\"] < 30:\n        return 2\n    elif 30 <= row[\"age\"] < 40:\n        return 3\n    elif 40 <= row[\"age\"] < 50:\n        return 4\n    elif 50 <= row[\"age\"] < 60:\n        return 5\n    elif 60 <= row[\"age\"] < 70:\n        return 6\n    else:\n        return 7\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Installation\nDESCRIPTION: Configuration for installing the test binaries in a relocatable manner to the specified destination.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_54\n\nLANGUAGE: cmake\nCODE:\n```\nrapids_test_install_relocatable(INSTALL_COMPONENT_SET testing DESTINATION bin/gtests/libcudf)\n```\n\n----------------------------------------\n\nTITLE: Installing cuStreamz via Conda\nDESCRIPTION: Commands for installing cuStreamz using conda package manager, showing both release and nightly installation options.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/custreamz/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nconda install -c rapidsai cudf_kafka custreamz\n```\n\nLANGUAGE: bash\nCODE:\n```\nconda install -c rapidsai-nightly cudf_kafka custreamz\n```\n\n----------------------------------------\n\nTITLE: Running Pre-commit Hooks\nDESCRIPTION: Command to manually run pre-commit hooks on staged files before committing code.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/CONTRIBUTING.md#2025-04-21_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\npre-commit run\n```\n\n----------------------------------------\n\nTITLE: Showing Open-ended Lazy Quantifier in Regex\nDESCRIPTION: Demonstrates the open-ended lazy quantifier '{n,}?' which repeats the previous item n or more times, starting with n matches.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/regex.md#2025-04-21_snippet_10\n\nLANGUAGE: regex\nCODE:\n```\na{2,}?\n```\n\n----------------------------------------\n\nTITLE: Set File Offset Bits for JITify\nDESCRIPTION: This snippet sets the `_FILE_OFFSET_BITS=64` compiler definition for specific source files that include JITify. This is necessary due to a limitation in how conda builds glibc, ensuring proper compilation for these files.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nset_source_files_properties(\n  src/binaryop/binaryop.cpp\n  src/jit/cache.cpp\n  src/rolling/detail/rolling_fixed_window.cu\n  src/rolling/detail/rolling_variable_window.cu\n  src/rolling/grouped_rolling.cu\n  src/rolling/rolling.cu\n  src/transform/transform.cpp\n  PROPERTIES COMPILE_DEFINITIONS \"_FILE_OFFSET_BITS=64\"\n)\n```\n\n----------------------------------------\n\nTITLE: Registering New Options in cudf\nDESCRIPTION: This code snippet shows how developers can register new options in the cudf options dictionary. The _register_option function is used to add new options.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/options.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncudf.options._register_option\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake for cuDF Strings Examples\nDESCRIPTION: Sets up the CMake project for building cuDF strings examples. Configures CUDA architectures, project properties, build options, and creates multiple executable targets with appropriate compilation flags and dependencies.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/examples/strings/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# Copyright (c) 2022-2025, NVIDIA CORPORATION.\n\ncmake_minimum_required(VERSION 3.30.4 FATAL_ERROR)\n\ninclude(../set_cuda_architecture.cmake)\n\n# initialize cuda architecture\nrapids_cuda_init_architectures(strings_examples)\n\nproject(\n  strings_examples\n  VERSION 0.0.1\n  LANGUAGES CXX CUDA\n)\n\ninclude(../fetch_dependencies.cmake)\n\ninclude(rapids-cmake)\nrapids_cmake_build_type(\"Release\")\n\nlist(APPEND CUDF_CUDA_FLAGS --expt-extended-lambda --expt-relaxed-constexpr)\n\nadd_executable(libcudf_apis libcudf_apis.cpp)\ntarget_compile_features(libcudf_apis PRIVATE cxx_std_17)\ntarget_link_libraries(libcudf_apis PRIVATE cudf::cudf nvToolsExt)\ninstall(TARGETS libcudf_apis DESTINATION bin/examples/libcudf)\n\nadd_executable(custom_with_malloc custom_with_malloc.cu)\ntarget_compile_features(custom_with_malloc PRIVATE cxx_std_17)\ntarget_compile_options(custom_with_malloc PRIVATE \"$<$<COMPILE_LANGUAGE:CUDA>:${CUDF_CUDA_FLAGS}>\")\ntarget_link_libraries(custom_with_malloc PRIVATE cudf::cudf nvToolsExt)\ninstall(TARGETS custom_with_malloc DESTINATION bin/examples/libcudf)\n\nadd_executable(custom_prealloc custom_prealloc.cu)\ntarget_compile_features(custom_prealloc PRIVATE cxx_std_17)\ntarget_compile_options(custom_prealloc PRIVATE \"$<$<COMPILE_LANGUAGE:CUDA>:${CUDF_CUDA_FLAGS}>\")\ntarget_link_libraries(custom_prealloc PRIVATE cudf::cudf nvToolsExt)\ninstall(TARGETS custom_prealloc DESTINATION bin/examples/libcudf)\n\nadd_executable(custom_optimized custom_optimized.cu)\ntarget_compile_features(custom_optimized PRIVATE cxx_std_17)\ntarget_compile_options(custom_optimized PRIVATE \"$<$<COMPILE_LANGUAGE:CUDA>:${CUDF_CUDA_FLAGS}>\")\ntarget_link_libraries(custom_optimized PRIVATE cudf::cudf nvToolsExt)\ninstall(TARGETS custom_optimized DESTINATION bin/examples/libcudf)\n\ninstall(FILES ${CMAKE_CURRENT_LIST_DIR}/names.csv DESTINATION bin/examples/libcudf)\n```\n\n----------------------------------------\n\nTITLE: Configuring Quantiles Tests in CUDA DataFrame\nDESCRIPTION: Sets up tests for quantile calculations in cuDF. This includes percentile approximation and general quantile testing. The configuration specifies to use 1 GPU, allocate 70% of test resources, and links against the Arrow libraries.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\nConfigureTest(\n  QUANTILES_TEST quantiles/percentile_approx_test.cpp quantiles/quantile_test.cpp\n  quantiles/quantiles_test.cpp\n  GPUS 1\n  PERCENT 70 EXTRA_LIBS ${ARROW_LIBRARIES}\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring CUDF Stream Usage Identification in CMake\nDESCRIPTION: Sets up libraries for stream-related testing in CUDF. Builds the library twice with different stream mode settings for testing purposes. Includes configuration for per-thread default streams and linking with CUDA runtime.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_25\n\nLANGUAGE: CMake\nCODE:\n```\nif(CUDF_BUILD_STREAMS_TEST_UTIL)\n  if(CUDA_STATIC_RUNTIME)\n    message(\n      FATAL_ERROR\n        \"Stream identification cannot be used with a static CUDA runtime. Please set CUDA_STATIC_RUNTIME=OFF or CUDF_BUILD_STREAMS_TEST_UTIL=OFF.\"\n    )\n  endif()\n\n  foreach(_mode cudf testing)\n    set(_tgt \"cudf_identify_stream_usage_mode_${_mode}\")\n    add_library(\n      ${_tgt} SHARED src/utilities/stacktrace.cpp tests/utilities/identify_stream_usage.cpp\n    )\n    if(CUDF_USE_PER_THREAD_DEFAULT_STREAM)\n      target_compile_definitions(\n        ${_tgt} PUBLIC CUDA_API_PER_THREAD_DEFAULT_STREAM CUDF_USE_PER_THREAD_DEFAULT_STREAM\n      )\n    endif()\n\n    set_target_properties(\n      ${_tgt}\n      PROPERTIES CXX_STANDARD 17\n                 CXX_STANDARD_REQUIRED ON\n                 POSITION_INDEPENDENT_CODE ON\n    )\n    target_compile_options(\n      ${_tgt} PRIVATE \"$<BUILD_INTERFACE:$<$<COMPILE_LANGUAGE:CXX>:${CUDF_CXX_FLAGS}>>\"\n    )\n    target_include_directories(${_tgt} PRIVATE \"$<BUILD_INTERFACE:${CUDF_SOURCE_DIR}/include>\")\n    target_link_libraries(${_tgt} PUBLIC CUDA::cudart rmm::rmm)\n    if(CUDF_BUILD_STACKTRACE_DEBUG)\n      target_link_libraries(${_tgt} PRIVATE cudf_backtrace)\n    endif()\n    rapids_cuda_set_runtime(${_tgt} USE_STATIC ${CUDA_STATIC_RUNTIME})\n    add_library(cudf::${_tgt} ALIAS ${_tgt})\n\n    if(\"${_mode}\" STREQUAL \"testing\")\n      target_compile_definitions(${_tgt} PUBLIC STREAM_MODE_TESTING)\n    endif()\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Testing for CUDF Kafka\nDESCRIPTION: Sets up the testing environment using the rapids-test CMake module. Enables testing functionality and initializes the testing framework for CUDF Kafka component.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/libcudf_kafka/tests/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nenable_testing()\n\ninclude(rapids-test)\nrapids_test_init()\n```\n\n----------------------------------------\n\nTITLE: Using Wait Function with Persist Operation\nDESCRIPTION: Shows how to properly synchronize a persist operation using the distributed.wait function when working with Dask DataFrames.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/dask_cudf/source/best_practices.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nddf = ddf.persist()\nwait(ddf)\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure for Labeling APIs\nDESCRIPTION: Sphinx/Doxygen documentation structure that defines the labeling APIs documentation group and includes a table of contents pointing to label_bins documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/labeling_apis.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: labeling_apis\n   :members:\n\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n\n   label_bins\n```\n\n----------------------------------------\n\nTITLE: Configuring Cython Module Build for CUDF Strings UDF\nDESCRIPTION: Sets up the necessary variables and calls the rapids_cython_create_modules function to build the strings_udf Cython module. It specifies the source file, links against the cudf library, and establishes the target dependencies.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf/cudf/_lib/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(cython_sources strings_udf.pyx)\nset(linked_libraries cudf::cudf)\n\nrapids_cython_create_modules(\n  CXX\n  SOURCE_FILES \"${cython_sources}\"\n  LINKED_LIBRARIES \"${linked_libraries}\" ASSOCIATED_TARGETS cudf\n)\n\ntarget_link_libraries(strings_udf PUBLIC cudf_strings_udf)\n```\n\n----------------------------------------\n\nTITLE: Set Target Include Directories\nDESCRIPTION: This snippet sets the include directories for the `cudf` target. It distinguishes between public, private, and interface include directories, specifying the paths required for building and using the library.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_16\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(\n  cudf\n  PUBLIC \"$<BUILD_INTERFACE:${DLPACK_INCLUDE_DIR}>\"\n         \"$<BUILD_INTERFACE:${JITIFY_INCLUDE_DIR}>\"\n         \"$<BUILD_INTERFACE:${CUDF_SOURCE_DIR}/include>\"\n         \"$<BUILD_INTERFACE:${CUDF_GENERATED_INCLUDE_DIR}/include>\"\n  PRIVATE \"$<BUILD_INTERFACE:${CUDF_SOURCE_DIR}/src>\"\n          \"$<BUILD_INTERFACE:${nanoarrow_SOURCE_DIR}/src>\"\n          \"$<BUILD_INTERFACE:${FlatBuffers_SOURCE_DIR}/include>\"\n          \"$<BUILD_INTERFACE:${ZSTD_INCLUDE_DIR}>\"\n  INTERFACE \"$<INSTALL_INTERFACE:include>\"\n)\n```\n\n----------------------------------------\n\nTITLE: Including Third-Party Dependencies for CUDF in CMake\nDESCRIPTION: Includes various CMake modules to find or fetch third-party dependencies such as Jitify, NVTX, nvCOMP, CCCL, RMM, Flatbuffers, DLPack, cuCollections, GoogleTest, KvikIO, nanoarrow, thread_pool, and zstd.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(cmake/thirdparty/get_jitify.cmake)\ninclude(cmake/thirdparty/get_nvtx.cmake)\ninclude(cmake/thirdparty/get_nvcomp.cmake)\ninclude(cmake/thirdparty/get_cccl.cmake)\ninclude(cmake/thirdparty/get_rmm.cmake)\ninclude(cmake/thirdparty/get_flatbuffers.cmake)\ninclude(cmake/thirdparty/get_dlpack.cmake)\ninclude(cmake/thirdparty/get_cucollections.cmake)\nif(CUDF_BUILD_TESTUTIL)\n  include(cmake/thirdparty/get_gtest.cmake)\nendif()\ninclude(cmake/Modules/JitifyPreprocessKernels.cmake)\ninclude(cmake/thirdparty/get_kvikio.cmake)\ninclude(cmake/thirdparty/get_nanoarrow.cmake)\ninclude(cmake/thirdparty/get_thread_pool.cmake)\ninclude(cmake/thirdparty/get_zstd.cmake)\n```\n\n----------------------------------------\n\nTITLE: Configuring Replace Tests in CUDA DataFrame\nDESCRIPTION: Sets up multiple test configurations for value replacement operations in cuDF. This includes general replace functionality, null replacement, NaN replacement, normalization replacement, and clamping operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_14\n\nLANGUAGE: CMake\nCODE:\n```\nConfigureTest(REPLACE_TEST replace/replace_tests.cpp)\n\nConfigureTest(REPLACE_NULLS_TEST replace/replace_nulls_tests.cpp)\n\nConfigureTest(REPLACE_NANS_TEST replace/replace_nans_tests.cpp)\n\nConfigureTest(NORMALIZE_REPLACE_TEST replace/normalize_replace_tests.cpp)\n\nConfigureTest(CLAMP_TEST replace/clamp_test.cpp)\n```\n\n----------------------------------------\n\nTITLE: Configuring AST Tests with C++\nDESCRIPTION: This snippet sets up tests for Abstract Syntax Tree (AST) functionalities in CUDF, enabling validation of AST transformations and structure. It is essential for parsing and manipulating expressions.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_46\n\nLANGUAGE: cpp\nCODE:\n```\nConfigureTest(AST_TEST ast/transform_tests.cpp ast/ast_tree_tests.cpp)\n```\n\n----------------------------------------\n\nTITLE: Running Python Tests for cuDF Components\nDESCRIPTION: Commands to run Python tests for cudf, dask_cudf, and custreamz components.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/CONTRIBUTING.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncd $CUDF_HOME/python\npytest -v ${CUDF_HOME}/python/cudf/cudf/tests\npytest -v ${CUDF_HOME}/python/dask_cudf/dask_cudf/ # There are tests in both tests/ and io/tests/\npytest -v ${CUDF_HOME}/python/custreamz/custreamz/tests\n```\n\n----------------------------------------\n\nTITLE: Creating the cuDF Library Target using CMake\nDESCRIPTION: This CMake command creates a library target named `cudf`.  It specifies all the source files that should be compiled and linked into the `cudf` library. This library provides GPU-accelerated dataframe operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(\n  cudf\n  src/aggregation/aggregation.cpp\n  src/aggregation/aggregation.cu\n  src/aggregation/result_cache.cpp\n  src/ast/expression_parser.cpp\n  src/ast/expressions.cpp\n  src/ast/operators.cpp\n  src/binaryop/binaryop.cpp\n  src/binaryop/compiled/ATan2.cu\n  src/binaryop/compiled/Add.cu\n  src/binaryop/compiled/BitwiseAnd.cu\n  src/binaryop/compiled/BitwiseOr.cu\n  src/binaryop/compiled/BitwiseXor.cu\n  src/binaryop/compiled/Div.cu\n  src/binaryop/compiled/FloorDiv.cu\n  src/binaryop/compiled/Greater.cu\n  src/binaryop/compiled/GreaterEqual.cu\n  src/binaryop/compiled/IntPow.cu\n  src/binaryop/compiled/Less.cu\n  src/binaryop/compiled/LessEqual.cu\n  src/binaryop/compiled/LogBase.cu\n  src/binaryop/compiled/LogicalAnd.cu\n  src/binaryop/compiled/LogicalOr.cu\n  src/binaryop/compiled/Mod.cu\n  src/binaryop/compiled/Mul.cu\n  src/binaryop/compiled/NullEquals.cu\n  src/binaryop/compiled/NullNotEquals.cu\n  src/binaryop/compiled/NullLogicalAnd.cu\n  src/binaryop/compiled/NullLogicalOr.cu\n  src/binaryop/compiled/NullMax.cu\n  src/binaryop/compiled/NullMin.cu\n  src/binaryop/compiled/PMod.cu\n  src/binaryop/compiled/Pow.cu\n  src/binaryop/compiled/PyMod.cu\n  src/binaryop/compiled/ShiftLeft.cu\n  src/binaryop/compiled/ShiftRight.cu\n  src/binaryop/compiled/ShiftRightUnsigned.cu\n  src/binaryop/compiled/Sub.cu\n  src/binaryop/compiled/TrueDiv.cu\n  src/binaryop/compiled/binary_ops.cu\n  src/binaryop/compiled/equality_ops.cu\n  src/binaryop/compiled/util.cpp\n  src/labeling/label_bins.cu\n  src/bitmask/null_mask.cu\n  src/bitmask/is_element_valid.cpp\n  src/column/column.cu\n  src/column/column_device_view.cu\n  src/column/column_factories.cpp\n  src/column/column_factories.cu\n  src/column/column_view.cpp\n  src/copying/concatenate.cu\n  src/copying/contiguous_split.cu\n  src/copying/copy.cpp\n  src/copying/copy.cu\n  src/copying/copy_range.cu\n  src/copying/gather.cu\n  src/copying/get_element.cu\n  src/copying/pack.cpp\n  src/copying/purge_nonempty_nulls.cu\n  src/copying/reverse.cu\n  src/copying/sample.cu\n  src/copying/scatter.cu\n  src/copying/shift.cu\n  src/copying/slice.cu\n  src/copying/split.cpp\n  src/copying/segmented_shift.cu\n  src/datetime/datetime_ops.cu\n  src/dictionary/add_keys.cu\n  src/dictionary/decode.cu\n  src/dictionary/detail/concatenate.cu\n  src/dictionary/detail/merge.cu\n  src/dictionary/dictionary_column_view.cpp\n  src/dictionary/dictionary_factories.cu\n  src/dictionary/encode.cu\n  src/dictionary/remove_keys.cu\n  src/dictionary/replace.cu\n  src/dictionary/search.cu\n  src/dictionary/set_keys.cu\n  src/filling/calendrical_month_sequence.cu\n  src/filling/fill.cu\n  src/filling/repeat.cu\n  src/filling/sequence.cu\n  src/groupby/groupby.cu\n  src/groupby/hash/compute_aggregations.cu\n  src/groupby/hash/compute_aggregations_null.cu\n  src/groupby/hash/compute_global_memory_aggs.cu\n  src/groupby/hash/compute_global_memory_aggs_null.cu\n  src/groupby/hash/compute_groupby.cu\n  src/groupby/hash/compute_mapping_indices.cu\n  src/groupby/hash/compute_mapping_indices_null.cu\n  src/groupby/hash/compute_shared_memory_aggs.cu\n  src/groupby/hash/create_sparse_results_table.cu\n  src/groupby/hash/flatten_single_pass_aggs.cpp\n  src/groupby/hash/groupby.cu\n  src/groupby/hash/hash_compound_agg_finalizer.cu\n  src/groupby/hash/sparse_to_dense_results.cu\n  src/groupby/sort/aggregate.cpp\n  src/groupby/sort/group_argmax.cu\n  src/groupby/sort/group_argmin.cu\n  src/groupby/sort/group_collect.cu\n  src/groupby/sort/group_correlation.cu\n  src/groupby/sort/group_count.cu\n  src/groupby/sort/group_histogram.cu\n  src/groupby/sort/group_m2.cu\n  src/groupby/sort/group_max.cu\n  src/groupby/sort/group_min.cu\n  src/groupby/sort/group_merge_lists.cu\n  src/groupby/sort/group_merge_m2.cu\n  src/groupby/sort/group_nth_element.cu\n  src/groupby/sort/group_nunique.cu\n  src/groupby/sort/group_product.cu\n  src/groupby/sort/group_quantiles.cu\n  src/groupby/sort/group_std.cu\n  src/groupby/sort/group_sum.cu\n  src/groupby/sort/group_count_scan.cu\n  src/groupby/sort/group_max_scan.cu\n  src/groupby/sort/group_min_scan.cu\n  src/groupby/sort/group_product_scan.cu\n  src/groupby/sort/group_rank_scan.cu\n  src/groupby/sort/group_replace_nulls.cu\n  src/groupby/sort/group_sum_scan.cu\n  src/groupby/sort/host_udf_aggregation.cpp\n  src/groupby/sort/scan.cpp\n  src/groupby/sort/sort_helper.cu\n  src/hash/md5_hash.cu\n  src/hash/murmurhash3_x86_32.cu\n  src/hash/murmurhash3_x64_128.cu\n  src/hash/sha1_hash.cu\n  src/hash/sha224_hash.cu\n  src/hash/sha256_hash.cu\n  src/hash/sha384_hash.cu\n  src/hash/sha512_hash.cu\n  src/hash/xxhash_32.cu\n  src/hash/xxhash_64.cu\n  src/interop/dlpack.cpp\n  src/interop/arrow_utilities.cpp\n  src/interop/arrow_data_structures.cpp\n  src/interop/to_arrow_device.cu\n  src/interop/to_arrow_host.cu\n  src/interop/from_arrow_device.cu\n  src/interop/from_arrow_host.cu\n  src/interop/from_arrow_host_strings.cu\n  src/interop/from_arrow_stream.cu\n  src/interop/to_arrow_schema.cpp\n  src/io/avro/avro.cpp\n  src/io/avro/avro_gpu.cu\n  src/io/avro/reader_impl.cu\n  src/io/comp/brotli_dict.cpp\n  src/io/comp/comp.cpp\n  src/io/comp/comp.cu\n  src/io/comp/common.cpp\n  src/io/comp/cpu_unbz2.cpp\n  src/io/comp/debrotli.cu\n  src/io/comp/gpuinflate.cu\n  src/io/comp/nvcomp_adapter.cpp\n  src/io/comp/nvcomp_adapter.cu\n  src/io/comp/snap.cu\n  src/io/comp/uncomp.cpp\n  src/io/comp/unsnap.cu\n  src/io/csv/csv_gpu.cu\n  src/io/csv/durations.cu\n  src/io/csv/reader_impl.cu\n  src/io/csv/writer_impl.cu\n  src/io/functions.cpp\n  src/io/json/host_tree_algorithms.cu\n  src/io/json/json_column.cu\n  src/io/json/column_tree_construction.cu\n  src/io/json/json_normalization.cu\n  src/io/json/json_tree.cu\n  src/io/json/nested_json_gpu.cu\n  src/io/json/read_json.cu\n  src/io/json/parser_features.cpp\n  src/io/json/process_tokens.cu\n  src/io/json/write_json.cu\n  src/io/orc/aggregate_orc_metadata.cpp\n  src/io/orc/dict_enc.cu\n  src/io/orc/orc.cpp\n  src/io/orc/reader_impl.cu\n  src/io/orc/reader_impl_chunking.cu\n  src/io/orc/reader_impl_decode.cu\n  src/io/orc/reader_impl_helpers.cpp\n  src/io/orc/stats_enc.cu\n  src/io/orc/stripe_data.cu\n  src/io/orc/stripe_enc.cu\n  src/io/orc/stripe_init.cu\n  src/datetime/timezone.cpp\n  src/io/orc/writer_impl.cu\n  src/io/parquet/arrow_schema_writer.cpp\n  src/io/parquet/bloom_filter_reader.cu\n  src/io/parquet/compact_protocol_reader.cpp\n  src/io/parquet/compact_protocol_writer.cpp\n  src/io/parquet/decode_preprocess.cu\n  src/io/parquet/page_data.cu\n  src/io/parquet/chunk_dict.cu\n  src/io/parquet/page_enc.cu\n  src/io/parquet/page_hdr.cu\n  src/io/parquet/page_delta_decode.cu\n  src/io/parquet/page_string_decode.cu\n  src/io/parquet/predicate_pushdown.cpp\n  src/io/parquet/reader.cpp\n  src/io/parquet/reader_impl.cpp\n  src/io/parquet/reader_impl_chunking.cu\n  src/io/parquet/reader_impl_helpers.cpp\n  src/io/parquet/reader_impl_preprocess.cu\n  src/io/parquet/stats_filter_helpers.cpp\n  src/io/parquet/writer_impl.cu\n  src/io/parquet/writer_impl_helpers.cpp\n  src/io/parquet/decode_fixed.cu\n  src/io/statistics/orc_column_statistics.cu\n  src/io/statistics/parquet_column_statistics.cu\n  src/io/text/byte_range_info.cpp\n  src/io/text/data_chunk_source_factories.cpp\n  src/io/text/bgzip_data_chunk_source.cu\n  src/io/text/bgzip_utils.cpp\n  src/io/text/multibyte_split.cu\n  src/io/utilities/base64_utilities.cpp\n  src/io/utilities/column_buffer.cpp\n  src/io/utilities/column_buffer_strings.cu\n  src/io/utilities/config_utils.cpp\n  src/io/utilities/data_casting.cu\n  src/io/utilities/data_sink.cpp\n  src/io/utilities/datasource.cpp\n  src/io/utilities/row_selection.cpp\n  src/io/utilities/type_inference.cu\n  src/io/utilities/trie.cu\n  src/jit/cache.cpp\n  src/jit/parser.cpp\n  src/jit/runtime_support.cpp\n  src/jit/util.cpp\n  src/join/conditional_join.cu\n  src/join/cross_join.cu\n  src/join/distinct_hash_join.cu\n  src/join/hash_join.cu\n  src/join/join.cu\n  src/join/join_utils.cu\n  src/join/mixed_join.cu\n  src/join/mixed_join_kernel.cu\n  src/join/mixed_join_kernel_nulls.cu\n  src/join/mixed_join_kernels_semi.cu\n  src/join/mixed_join_semi.cu\n  src/join/mixed_join_size_kernel.cu\n  src/join/mixed_join_size_kernel_nulls.cu\n  src/join/semi_join.cu\n  src/json/json_path.cu\n  src/lists/contains.cu\n  src/lists/combine/concatenate_list_elements.cu\n  src/lists/combine/concatenate_rows.cu\n  src/lists/copying/concatenate.cu\n  src/lists/copying/copying.cu\n  src/lists/copying/gather.cu\n  src/lists/copying/segmented_gather.cu\n  src/lists/copying/scatter_helper.cu\n  src/lists/count_elements.cu\n  src/lists/dremel.cu\n  src/lists/explode.cu\n  src/lists/extract.cu\n  src/lists/interleave_columns.cu\n  src/lists/lists_column_factories.cu\n  src/lists/lists_column_view.cu\n  src/lists/reverse.cu\n  src/lists/segmented_sort.cu\n  src/lists/sequences.cu\n  src/lists/set_operations.cu\n  src/lists/stream_compaction/apply_boolean_mask.cu\n  src/lists/stream_compaction/distinct.cu\n  src/lists/utilities.cu\n  src/merge/merge.cu\n  src/partitioning/partitioning.cu\n  src/partitioning/round_robin.cu\n  src/quantiles/tdigest/tdigest.cu\n  src/quantiles/tdigest/tdigest_aggregation.cu\n  src/quantiles/tdigest/tdigest_column_view.cpp\n  src/quantiles/quantile.cu\n  src/quantiles/quantiles.cu\n  src/reductions/all.cu\n  src/reductions/any.cu\n  src/reductions/collect_ops.cu\n  src/reductions/histogram.cu\n  src/reductions/max.cu\n  src/reductions/mean.cu\n  src/reductions/min.cu\n  src/reductions/minmax.cu\n  src/reductions/nth_element.cu\n  src/reductions/product.cu\n  src/reductions/reductions.cpp\n  src/reductions/scan/rank_scan.cu\n  src/reductions/scan/ewm.cu\n  src/reductions/scan/scan.cpp\n  src/reductions/scan/scan_exclusive.cu\n  src/reductions/scan/scan_inclusive.cu\n  src/reductions/segmented/all.cu\n  src/reductions/segmented/any.cu\n  src/reductions/segmented/counts.cu\n  src/reductions/segmented/max.cu\n  src/reductions/segmented/mean.cu\n  src/reductions/segmented/min.cu\n  src/reductions/segmented/nunique.cu\n  src/reductions/segmented/product.cu\n  src/reductions/segmented/reductions.cpp\n)\n\n```\n\n----------------------------------------\n\nTITLE: Enable Per-Thread Default Stream\nDESCRIPTION: This snippet conditionally enables the per-thread default CUDA stream by defining the `CUDA_API_PER_THREAD_DEFAULT_STREAM` and `CUDF_USE_PER_THREAD_DEFAULT_STREAM` preprocessor macros. This allows each thread to have its own default CUDA stream.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_20\n\nLANGUAGE: CMake\nCODE:\n```\nif(CUDF_USE_PER_THREAD_DEFAULT_STREAM)\n  target_compile_definitions(\n    cudf PUBLIC CUDA_API_PER_THREAD_DEFAULT_STREAM CUDF_USE_PER_THREAD_DEFAULT_STREAM\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project for RAPIDS cuDF Basic Example\nDESCRIPTION: This CMake script sets up a basic example project that uses the RAPIDS cuDF library. It defines the project requirements including CUDA architecture settings, dependencies, and compilation features. The project builds a process_csv executable that demonstrates cuDF functionality.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/examples/basic/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# Copyright (c) 2020-2025, NVIDIA CORPORATION.\n\ncmake_minimum_required(VERSION 3.30.4 FATAL_ERROR)\n\ninclude(../set_cuda_architecture.cmake)\n\n# initialize cuda architecture\nrapids_cuda_init_architectures(basic_example)\n\nproject(\n  basic_example\n  VERSION 0.0.1\n  LANGUAGES CXX CUDA\n)\n\ninclude(../fetch_dependencies.cmake)\n\ninclude(rapids-cmake)\nrapids_cmake_build_type(\"Release\")\n\n# Configure your project here\nadd_executable(basic_example src/process_csv.cpp)\ntarget_link_libraries(basic_example PRIVATE cudf::cudf)\ntarget_compile_features(basic_example PRIVATE cxx_std_17)\n\ninstall(TARGETS basic_example DESTINATION bin/examples/libcudf)\ninstall(FILES ${CMAKE_CURRENT_LIST_DIR}/4stock_5day.csv DESTINATION bin/examples/libcudf)\n```\n\n----------------------------------------\n\nTITLE: Configuring Reshape Test with C++\nDESCRIPTION: This snippet outlines the configuration for reshape tests in CUDF, listing source files that address various column interleaving and tile operations. It ensures proper testing of data manipulation capabilities.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_34\n\nLANGUAGE: cpp\nCODE:\n```\nConfigureTest(\n  RESHAPE_TEST reshape/byte_cast_tests.cpp reshape/interleave_columns_tests.cpp\n  reshape/tile_tests.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Transpose Tests in CMake\nDESCRIPTION: Sets up tests for matrix transpose operations with GPU resource specifications.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_27\n\nLANGUAGE: CMake\nCODE:\n```\n# ##################################################################################################\n# * transpose tests -------------------------------------------------------------------------------\nConfigureTest(\n  TRANSPOSE_TEST transpose/transpose_test.cpp\n  GPUS 1\n  PERCENT 70\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring CUDF Installation in CMake\nDESCRIPTION: Sets up installation targets and packaging for CUDF. Includes configuration for CPack and GNU installation directories. Sets the default component name for installation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_27\n\nLANGUAGE: CMake\nCODE:\n```\nrapids_cmake_install_lib_dir(lib_dir)\ninclude(CPack)\ninclude(GNUInstallDirs)\n\nset(CMAKE_INSTALL_DEFAULT_COMPONENT_NAME cudf)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Benchmark Results Directory and Command in CMake\nDESCRIPTION: Creates a custom command to set up the benchmark results directory and track benchmark execution. This serves as a dependency for other benchmark targets.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/benchmarks/CMakeLists.txt#2025-04-21_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_command(\n  OUTPUT CUDF_BENCHMARKS\n  COMMAND echo Running benchmarks\n  COMMAND mkdir -p results\n  VERBATIM\n  COMMENT \"Running cudf benchmarks.\"\n  USES_TERMINAL\n)\n```\n\n----------------------------------------\n\nTITLE: Accessing Option Values in Python using cudf\nDESCRIPTION: This snippet demonstrates how to retrieve option values from the cudf options dictionary. The get_option function is used to access specific option values.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/options.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ncudf.get_option\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for Label Bins in cuDF\nDESCRIPTION: This reStructuredText snippet uses the doxygengroup directive to generate API documentation for the label_bins group in cuDF. It includes all members of the group in the generated documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/label_bins.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: label_bins\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Setting Up Doxygen Documentation Generation\nDESCRIPTION: Creates a custom command and target for building cuDF API documentation using Doxygen, passing version information as environment variables.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_35\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_command(\n  OUTPUT CUDF_DOXYGEN\n  WORKING_DIRECTORY ${CUDF_SOURCE_DIR}/doxygen\n  COMMAND ${CMAKE_COMMAND} -E env \"RAPIDS_VERSION=${RAPIDS_VERSION}\"\n          \"RAPIDS_VERSION_MAJOR_MINOR=${RAPIDS_VERSION_MAJOR_MINOR}\" doxygen Doxyfile\n  VERBATIM\n  COMMENT \"Custom command for building cudf doxygen docs.\"\n)\n\nadd_custom_target(\n  docs_cudf\n  DEPENDS CUDF_DOXYGEN\n  COMMENT \"Custom command for building cudf doxygen docs.\"\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Common Benchmark Utilities Library with CMake\nDESCRIPTION: Sets up an OBJECT library for common benchmark utilities to avoid recompiling helper source files. Includes synchronization, I/O, and table utility components needed by various benchmarks.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/benchmarks/CMakeLists.txt#2025-04-21_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(\n  cudf_benchmark_common OBJECT\n  synchronization/synchronization.cpp io/cuio_common.cpp common/table_utilities.cpp\n  common/benchmark_utilities.cpp common/nvbench_utilities.cpp\n)\ntarget_link_libraries(\n  cudf_benchmark_common PRIVATE cudf_datagen $<TARGET_NAME_IF_EXISTS:conda_env> GTest::gmock\n                                GTest::gtest\n)\n```\n\n----------------------------------------\n\nTITLE: Installing Polars Build Dependencies\nDESCRIPTION: Commands to install build dependencies for Polars in the cudf environment using uv, a faster alternative to pip.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_polars/docs/overview.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n# cudf environment (conda or pip) is active\npip install --upgrade uv\nuv pip install --upgrade -r py-polars/requirements-dev.txt\n```\n\n----------------------------------------\n\nTITLE: Installing cuDF via conda\nDESCRIPTION: Command to install cuDF using conda from the rapidsai channel, including necessary dependencies with specific version requirements.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_kafka/README.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nconda install -c rapidsai -c conda-forge -c nvidia \\\n    cudf=25.06 python=3.12 cuda-version=12.8\n```\n\n----------------------------------------\n\nTITLE: Defining Data Structures in pylibcudf - Cython\nDESCRIPTION: This Cython snippet demonstrates the definition of a data type class in pylibcudf. It maps a C++ data type to a Cython class, enabling interaction with the libcudf library. The class provides methods for accessing data type identifiers and constructing instances from underlying libcudf types. Dependencies include libcudf for data types and a C++ to Cython interface.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/developer_docs.md#2025-04-21_snippet_0\n\nLANGUAGE: cython\nCODE:\n```\ncdef class DataType:\n    cdef data_type c_obj\n\n    cpdef TypeId id(self)\n    cpdef int32_t scale(self)\n\n    @staticmethod\n    cdef DataType from_libcudf(data_type dt)\n```\n\n----------------------------------------\n\nTITLE: Cloning the cuDF Repository\nDESCRIPTION: Commands to clone the cuDF repository and set up the development environment.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/CONTRIBUTING.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nCUDF_HOME=$(pwd)/cudf\ngit clone https://github.com/rapidsai/cudf.git $CUDF_HOME\ncd $CUDF_HOME\n```\n\n----------------------------------------\n\nTITLE: Configuring Static Code Analysis with clang-tidy and IWYU for cuDF\nDESCRIPTION: Sets up static code analysis tools for cuDF, specifically clang-tidy and include-what-you-use (IWYU). It defines a function to enable these tools for specific targets, checks for required versions, and configures compiler arguments for static analysis.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\n# * linter configuration ---------------------------------------------------------------------------\nif(CUDF_CLANG_TIDY)\n  find_program(\n    CLANG_TIDY_EXE\n    NAMES \"clang-tidy\"\n    DOC \"Path to clang-tidy executable\" REQUIRED\n  )\n\n  execute_process(\n    COMMAND ${CLANG_TIDY_EXE} --version\n    OUTPUT_VARIABLE CLANG_TIDY_OUTPUT\n    OUTPUT_STRIP_TRAILING_WHITESPACE\n  )\n  string(REGEX MATCH \"LLVM version ([0-9]+\\\\.[0-9]+)\\\\.[0-9]+\" LLVM_VERSION_MATCH\n               \"${CLANG_TIDY_OUTPUT}\"\n  )\n  # Discard the patch version and allow it to float. Empirically, results between patch versions are\n  # mostly stable, and looking at available packages on some package managers sometimes patch\n  # versions are skipped so we don't want to constrain to a patch version that the user can't\n  # install.\n  set(LLVM_VERSION \"${CMAKE_MATCH_1}\")\n  set(expected_clang_tidy_version 19.1)\n  if(NOT expected_clang_tidy_version VERSION_EQUAL LLVM_VERSION)\n    message(\n      FATAL_ERROR\n        \"clang-tidy version ${expected_clang_tidy_version} is required, but found ${LLVM_VERSION}\"\n    )\n  endif()\nendif()\n\nif(CUDF_IWYU)\n  find_program(IWYU_EXE NAMES include-what-you-use iwyu REQUIRED)\nendif()\n\n# Turn on the clang-tidy property for a target excluding the files specified in SKIPPED_FILES.\nfunction(enable_static_checkers target)\n  set(_tidy_options IWYU CLANG_TIDY)\n  set(_tidy_one_value)\n  set(_tidy_multi_value SKIPPED_FILES)\n  cmake_parse_arguments(\n    _LINT \"${_tidy_options}\" \"${_tidy_one_value}\" \"${_tidy_multi_value}\" ${ARGN}\n  )\n\n  if(_LINT_CLANG_TIDY)\n    # clang will complain about unused link libraries on the compile line unless we specify\n    # -Qunused-arguments.\n    if(CUDF_CLANG_TIDY_AUTOFIX)\n      set_target_properties(\n        ${target} PROPERTIES CXX_CLANG_TIDY\n                             \"${CLANG_TIDY_EXE};--extra-arg=-Qunused-arguments;--fix\"\n      )\n    else()\n      set_target_properties(\n        ${target} PROPERTIES CXX_CLANG_TIDY \"${CLANG_TIDY_EXE};--extra-arg=-Qunused-arguments\"\n      )\n    endif()\n  endif()\n  if(_LINT_IWYU)\n    # A few extra warnings pop up when building with IWYU. I'm not sure why, but they are not\n    # relevant since they don't show up in any other build so it's better to suppress them until we\n    # can figure out the cause. Setting this as part of CXX_INCLUDE_WHAT_YOU_USE does not appear to\n    # be sufficient, we must also ensure that it is set to the underlying target's CXX compile\n    # flags. To do this completely cleanly we should modify the flags on the target rather than the\n    # global CUDF_CXX_FLAGS, but this solution is good enough for now since we never run the linters\n    # on real builds.\n    foreach(_flag -Wno-missing-braces -Wno-unneeded-internal-declaration)\n      list(FIND CUDF_CXX_FLAGS \"${_flag}\" _flag_index)\n      if(_flag_index EQUAL -1)\n        list(APPEND CUDF_CXX_FLAGS ${_flag})\n      endif()\n    endforeach()\n    set(CUDF_CXX_FLAGS\n        \"${CUDF_CXX_FLAGS}\"\n        PARENT_SCOPE\n    )\n    set_target_properties(${target} PROPERTIES CXX_INCLUDE_WHAT_YOU_USE \"${IWYU_EXE}\")\n  endif()\n  foreach(file IN LISTS _LINT_SKIPPED_FILES)\n    set_source_files_properties(${file} PROPERTIES SKIP_LINTING ON)\n  endforeach()\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Defining Project Properties for Billion Rows Example in CMake\nDESCRIPTION: Configures the project properties including name, version, and supported languages (C++ and CUDA). It also includes necessary dependency files and sets the build type to Release.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/examples/billion_rows/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nproject(\n  billion_rows\n  VERSION 0.0.1\n  LANGUAGES CXX CUDA\n)\n\ninclude(../fetch_dependencies.cmake)\n\ninclude(rapids-cmake)\nrapids_cmake_build_type(\"Release\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Factories Test with C++\nDESCRIPTION: This snippet registers tests for verifying factory functionalities in CUDF, specifically for scalar and column factories. It is essential for ensuring that object creation patterns are reliable.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_36\n\nLANGUAGE: cpp\nCODE:\n```\nConfigureTest(FACTORIES_TEST scalar/factories_test.cpp column/factories_test.cpp)\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake for cuDF Parquet I/O Example\nDESCRIPTION: Complete CMake configuration for building the parquet I/O examples for cuDF. Sets up CUDA architecture, defines utility and executable targets, and configures installation paths. Requires cuDF library and supports C++17.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/examples/parquet_io/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# Copyright (c) 2024-2025, NVIDIA CORPORATION.\n\ncmake_minimum_required(VERSION 3.30.4 FATAL_ERROR)\n\ninclude(../set_cuda_architecture.cmake)\n\n# initialize cuda architecture\nrapids_cuda_init_architectures(parquet_io)\n\nproject(\n  parquet_io\n  VERSION 0.0.1\n  LANGUAGES CXX CUDA\n)\n\ninclude(../fetch_dependencies.cmake)\n\ninclude(rapids-cmake)\nrapids_cmake_build_type(\"Release\")\n\nadd_library(parquet_io_utils OBJECT common_utils.cpp io_source.cpp)\ntarget_compile_features(parquet_io_utils PRIVATE cxx_std_17)\ntarget_link_libraries(parquet_io_utils PRIVATE cudf::cudf)\n\n# Build and install parquet_io\nadd_executable(parquet_io parquet_io.cpp)\ntarget_link_libraries(parquet_io PRIVATE cudf::cudf nvToolsExt $<TARGET_OBJECTS:parquet_io_utils>)\ntarget_compile_features(parquet_io PRIVATE cxx_std_17)\ninstall(TARGETS parquet_io DESTINATION bin/examples/libcudf)\n\n# Build and install parquet_io_multithreaded\nadd_executable(parquet_io_multithreaded parquet_io_multithreaded.cpp)\ntarget_link_libraries(\n  parquet_io_multithreaded PRIVATE cudf::cudf nvToolsExt $<TARGET_OBJECTS:parquet_io_utils>\n)\ntarget_compile_features(parquet_io_multithreaded PRIVATE cxx_std_17)\ninstall(TARGETS parquet_io_multithreaded DESTINATION bin/examples/libcudf)\n\n# Install the example.parquet file\ninstall(FILES ${CMAKE_CURRENT_LIST_DIR}/example.parquet DESTINATION bin/examples/libcudf)\n```\n\n----------------------------------------\n\nTITLE: Configuring Bitmask Tests with C++\nDESCRIPTION: This snippet sets up tests for testing bitmask functionalities within CUDF. It ensures that bitmask operations work reliably and efficiently across various scenarios.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_43\n\nLANGUAGE: cpp\nCODE:\n```\nConfigureTest(\n  BITMASK_TEST bitmask/valid_if_tests.cu bitmask/set_nullmask_tests.cu bitmask/bitmask_tests.cpp\n  bitmask/is_element_valid_tests.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Up CUDF Data Generation Library with CMake\nDESCRIPTION: Configures the cudf_datagen static library for generating test data in CUDF benchmarks. Sets compile features, options, links required libraries, and configures include directories.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/benchmarks/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(cudf_datagen STATIC common/generate_input.cu)\ntarget_compile_features(cudf_datagen PUBLIC cxx_std_17 cuda_std_17)\n\ntarget_compile_options(\n  cudf_datagen PUBLIC \"$<$<COMPILE_LANGUAGE:CXX>:${CUDF_CXX_FLAGS}>\"\n                      \"$<$<COMPILE_LANGUAGE:CUDA>:${CUDF_CUDA_FLAGS}>\"\n)\n\ntarget_link_libraries(\n  cudf_datagen\n  PUBLIC GTest::gmock GTest::gtest benchmark::benchmark nvbench::nvbench Threads::Threads cudf\n         cudf::cudftestutil nvtx3::nvtx3-cpp\n  PRIVATE $<TARGET_NAME_IF_EXISTS:conda_env>\n)\n\ntarget_include_directories(\n  cudf_datagen\n  PUBLIC \"$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>\" \"$<BUILD_INTERFACE:${CUDF_SOURCE_DIR}>\"\n         \"$<BUILD_INTERFACE:${CUDF_SOURCE_DIR}/src>\"\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring File I/O Benchmarks\nDESCRIPTION: Configures benchmarks for various file format readers and writers including Parquet, ORC, CSV, and JSON.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/benchmarks/CMakeLists.txt#2025-04-21_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nConfigureNVBench(PARQUET_WRITER_NVBENCH io/parquet/parquet_writer.cpp io/parquet/parquet_writer_chunks.cpp)\nConfigureNVBench(PARQUET_READER_NVBENCH io/parquet/parquet_reader_input.cpp io/parquet/parquet_reader_options.cpp)\nConfigureNVBench(CSV_READER_NVBENCH io/csv/csv_reader_input.cpp io/csv/csv_reader_options.cpp)\nConfigureNVBench(CSV_WRITER_NVBENCH io/csv/csv_writer.cpp)\n```\n\n----------------------------------------\n\nTITLE: Disable Jitify Log Printing\nDESCRIPTION: This snippet disables Jitify log printing by defining the `JITIFY_PRINT_LOG=0` preprocessor macro. This prevents Jitify from printing log messages during compilation, which can be useful for reducing output verbosity.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_18\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_definitions(cudf PRIVATE \"JITIFY_PRINT_LOG=0\")\n```\n\n----------------------------------------\n\nTITLE: Struct Column Structure Example\nDESCRIPTION: This example shows the structure of a struct column with two fields (FLOAT32 and INT32). It demonstrates how null values are represented at both the struct level and the field level. The example clarifies how a null struct row implies null fields, while a non-null struct row can have null fields independently.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DEVELOPER_GUIDE.md#2025-04-21_snippet_32\n\nLANGUAGE: none\nCODE:\n```\n\"{\\n  type = STRUCT\\n  null_mask = [1, 1, 0, 1]\\n  null_count = 1\\n  children = {\\n    {\\n      type = FLOAT32\\n      data =       [1.0, 4.0, X, 8.0]\\n      null_mask  = [  1,   1, 0,   1]\\n      null_count = 1\\n    },\\n    {\\n      type = INT32\\n      data =       [2, 5, X, X]\\n      null_mask  = [1, 1, 0, 0]\\n      null_count = 2\\n    }\\n  }\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Pandas Object Series Example\nDESCRIPTION: Shows Pandas support for storing mixed-type collections in object dtype\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/pandas-comparison.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\ns = pd.Series([\"a\", 1, [1, 2, 3]])\n```\n\n----------------------------------------\n\nTITLE: Defining cuDF Documentation String\nDESCRIPTION: Sets up a detailed documentation string that describes cuDF functionality and imported targets. This documentation is used in the export configuration.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_32\n\nLANGUAGE: CMake\nCODE:\n```\nset(doc_string\n    [=[\nProvide targets for the cudf library.\n\nBuilt based on the Apache Arrow columnar memory format, cuDF is a GPU DataFrame\nlibrary for loading, joining, aggregating, filtering, and otherwise\nmanipulating data.\n\ncuDF provides a pandas-like API that will be familiar to data engineers &\ndata scientists, so they can use it to easily accelerate their workflows\nwithout going into the details of CUDA programming.\n\n\nImported Targets\n^^^^^^^^^^^^^^^^\n\nIf cudf is found, this module defines the following IMPORTED GLOBAL\ntargets:\n\n cudf::cudf             - The main cudf library.\n\nThis module offers an optional testing component which defines the\nfollowing IMPORTED GLOBAL  targets:\n\n cudf::cudftestutil          - The main cudf testing library\n cudf::cudftestutil_impl     - C++ and CUDA sources to compile for definitions in cudf::cudftestutil\n    ]=]\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Large Strings Test with C++\nDESCRIPTION: This snippet configures tests for handling large strings in CUDF, involving numerous source files that evaluate operations on larger datasets. It is crucial for checking performance and correctness under larger input sizes.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_39\n\nLANGUAGE: cpp\nCODE:\n```\nConfigureTest(\n  LARGE_STRINGS_TEST\n  large_strings/concatenate_tests.cpp\n  large_strings/case_tests.cpp\n  large_strings/json_tests.cu\n  large_strings/large_strings_fixture.cpp\n  large_strings/merge_tests.cpp\n  large_strings/parquet_tests.cpp\n  large_strings/replace_tests.cpp\n  large_strings/reshape_tests.cpp\n  large_strings/split_strings_tests.cpp\n  GPUS 1\n  PERCENT 100\n)\n```\n\n----------------------------------------\n\nTITLE: Building cuDF for Development\nDESCRIPTION: Command to build Python packages in development mode with the --pydevelop flag and build C++ tests for all cuDF components.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/CONTRIBUTING.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh --pydevelop libcudf libcudf_kafka cudf dask_cudf cudf_kafka custreamz\n```\n\n----------------------------------------\n\nTITLE: Installing cuDF via Conda in Bash\nDESCRIPTION: This command installs cuDF using conda from the rapidsai channel. It specifies the cuDF version, Python version, and CUDA version to ensure compatibility.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/README.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nconda install -c rapidsai -c conda-forge -c nvidia \\\n    cudf=25.06 python=3.12 cuda-version=12.8\n```\n\n----------------------------------------\n\nTITLE: Implementing Cython Scoped Enums in pylibcudf\nDESCRIPTION: Example of how to properly declare and use scoped enumerations in Cython for pylibcudf. This includes proper handling across header files, implementation files, and Python API exposure.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/developer_docs.md#2025-04-21_snippet_4\n\nLANGUAGE: cython\nCODE:\n```\n# pylibcudf/libcudf/copying.pxd\ncdef extern from \"cudf/copying.hpp\" namespace \"cudf\" nogil:\n    # cpdef here so that we export both a cdef enum class and a Python enum.Enum.\n    cpdef enum class out_of_bounds_policy(bool):\n        NULLIFY\n        DONT_CHECK\n\n\n# pylibcudf/libcudf/copying.pyx\n# This file is empty, but is required to compile the Python enum in pylibcudf/libcudf/copying.pxd\n# Ensure this file is included in pylibcudf/libcudf/CMakeLists.txt\n\n\n# pylibcudf/copying.pxd\n\n# cimport the enum using the exact name\n# Once https://github.com/cython/cython/issues/5609 is resolved,\n# this import should instead be\n# from pylibcudf.libcudf.copying cimport out_of_bounds_policy as OutOfBoundsPolicy\nfrom pylibcudf.libcudf.copying cimport out_of_bounds_policy\n\n\n# pylibcudf/copying.pyx\n# Access cpp.copying members that aren't part of this module's public API via\n# this module alias\nfrom pylibcudf.libcudf cimport copying as cpp_copying\nfrom pylibcudf.libcudf.copying cimport out_of_bounds_policy\n\n# This import exposes the enum in the public API of this module.\n# It requires a no-cython-lint tag because it will be unused: all typing of\n# parameters etc will need to use the Cython name `out_of_bounds_policy` until\n# the Cython bug is resolved.\nfrom pylibcudf.libcudf.copying import \\\n    out_of_bounds_policy as OutOfBoundsPolicy  # no-cython-lint\n```\n\n----------------------------------------\n\nTITLE: Validating CUDA Version Requirements for cuDF\nDESCRIPTION: Checks if the NVIDIA CUDA compiler version meets the minimum requirement of 11.5 for libcudf. If the requirement is not met, it stops the build process with a fatal error.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_CUDA_COMPILER_ID STREQUAL \"NVIDIA\" AND CMAKE_CUDA_COMPILER_VERSION VERSION_LESS 11.5)\n  message(\n    FATAL_ERROR\n      \"libcudf requires CUDA Toolkit 11.5+ to compile (nvcc ${CMAKE_CUDA_COMPILER_VERSION} provided)\"\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Sorting Tests in CUDA DataFrame\nDESCRIPTION: Sets up tests for checking if data is sorted in cuDF using a C++ source file.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nConfigureTest(IS_SORTED_TEST sort/is_sorted_tests.cpp)\n```\n\n----------------------------------------\n\nTITLE: Configuring CUDF Test Utilities in CMake\nDESCRIPTION: Sets up compilation and linking for CUDF test utilities, including a default stream library and interface libraries for test support. Configures include directories and source files for test utilities.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_24\n\nLANGUAGE: CMake\nCODE:\n```\nif(CUDF_BUILD_TESTUTIL)\n  add_library(\n    cudftest_default_stream\n    tests/utilities/default_stream.cpp\n  )\n  set_target_properties(\n    cudftest_default_stream\n    PROPERTIES BUILD_RPATH \"\\$ORIGIN\"\n               INSTALL_RPATH \"\\$ORIGIN\"\n               CXX_STANDARD 17\n               CXX_STANDARD_REQUIRED ON\n               CUDA_STANDARD 17\n               CUDA_STANDARD_REQUIRED ON\n               POSITION_INDEPENDENT_CODE ON\n               INTERFACE_POSITION_INDEPENDENT_CODE ON\n  )\n  target_link_libraries(\n    cudftest_default_stream\n    PUBLIC cudf\n    PRIVATE $<TARGET_NAME_IF_EXISTS:conda_env>\n  )\n  rapids_cuda_set_runtime(cudftest_default_stream USE_STATIC ${CUDA_STATIC_RUNTIME})\n\n  add_library(cudf::cudftest_default_stream ALIAS cudftest_default_stream)\n\n  add_library(cudftestutil INTERFACE)\n\n  # ... (additional configuration for cudftestutil)\n\nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating a Public Interface for Expression Renaming in Python\nDESCRIPTION: Public function that wraps the internal renaming logic with a CachingVisitor to handle the transformation state and DAG-aware caching of intermediate results.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_polars/docs/overview.md#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef rename(e: Expr, mapping: Mapping[str, str]) -> Expr:\n    \"\"\"Rename column references in an expression.\"\"\"\n    mapper = CachingVisitor(_rename, state={\"mapping\": mapping})\n    # or\n    # mapper = make_recursive(_rename, state={\"mapping\": mapping})\n    return mapper(e)\n```\n\n----------------------------------------\n\nTITLE: Configuring Linked Libraries for cuDF String Operations\nDESCRIPTION: This snippet sets the linked libraries for the cuDF string operations module. It specifies that the module should be linked against the cuDF library.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/pylibcudf/strings/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(linked_libraries cudf::cudf)\n```\n\n----------------------------------------\n\nTITLE: Configuring Cython Sources and Building cuDF C++ Modules with CMake\nDESCRIPTION: This CMake script defines Cython source files to be compiled and configures the build process for cuDF C++ modules. It sets up the source files list, specifies the cuDF library dependency, calls the rapids_cython_create_modules function to create the modules with a 'cpp' prefix, and adds subdirectories for specialized components.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/pylibcudf/libcudf/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(cython_sources\n    aggregation.pyx binaryop.pyx copying.pyx datetime.pyx expressions.pyx jit.pyx labeling.pyx\n    reduce.pyx replace.pyx round.pyx stream_compaction.pyx types.pyx unary.pyx\n)\n\nset(linked_libraries cudf::cudf)\nrapids_cython_create_modules(\n  CXX\n  SOURCE_FILES \"${cython_sources}\"\n  LINKED_LIBRARIES \"${linked_libraries}\" ASSOCIATED_TARGETS cudf MODULE_PREFIX cpp\n)\nadd_subdirectory(io)\nadd_subdirectory(lists)\nadd_subdirectory(strings)\n```\n\n----------------------------------------\n\nTITLE: PTDS Build Commands\nDESCRIPTION: Commands for building CUDF with Per-Thread Default Stream (PTDS) support for improved concurrency.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/README.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncd src/cudf/cpp/build\ncmake .. -DCMAKE_INSTALL_PREFIX=$CONDA_PREFIX -DCUDF_USE_PER_THREAD_DEFAULT_STREAM=ON\nmake -j`nproc`\nmake install\n```\n\n----------------------------------------\n\nTITLE: Checking GPU Memory Usage with nvidia-smi\nDESCRIPTION: Shows how to check GPU memory usage from within a Jupyter notebook using a shell command.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/10min.ipynb#2025-04-21_snippet_84\n\nLANGUAGE: python\nCODE:\n```\n!nvidia-smi\n```\n\n----------------------------------------\n\nTITLE: Building Polars in Debug Mode\nDESCRIPTION: Command to build Polars in debug mode using maturin, which is best for development and debugging purposes.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_polars/docs/overview.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncd py-polars\n# build in debug mode, best option for development/debugging\nmaturin develop -m Cargo.toml\n```\n\n----------------------------------------\n\nTITLE: Benchmark Output Path Example\nDESCRIPTION: Shows the format of the output message when saving benchmark results to a file.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/benchmarking.md#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nSaved benchmark data in: /path/to/XXXX_*.json\n```\n\n----------------------------------------\n\nTITLE: Configuring cudf-kafka-python Project with CMake\nDESCRIPTION: This CMake script configures the cudf-kafka-python project. It defines the minimum required CMake version, includes the RAPIDS configuration, sets the project name and version, checks for required cudf_kafka dependency, initializes Cython for Python bindings, and adds the appropriate subdirectory for building.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_kafka/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.30.4 FATAL_ERROR)\n\ninclude(../../cmake/rapids_config.cmake)\n\nproject(\n  cudf-kafka-python\n  VERSION \"${RAPIDS_VERSION}\"\n  LANGUAGES CXX\n)\n\nfind_package(cudf_kafka \"${RAPIDS_VERSION}\" REQUIRED)\n\nif(NOT cudf_kafka_FOUND)\n  message(\n    FATAL_ERROR\n      \"cudf_kafka package not found. cudf_kafka C++ is required to build this Python package.\"\n  )\nendif()\n\ninclude(rapids-cython-core)\nrapids_cython_init()\n\nadd_subdirectory(cudf_kafka/_lib)\n```\n\n----------------------------------------\n\nTITLE: Setting Up NDSH Data Generator Library with CMake\nDESCRIPTION: Configures the ndsh_data_generator static library for NVBENCH Data Science benchmark dataset generation. Specifies source files, compilation features, options, library linkage, and include paths.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/benchmarks/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(\n  ndsh_data_generator STATIC\n  common/ndsh_data_generator/ndsh_data_generator.cpp common/ndsh_data_generator/table_helpers.cpp\n  common/ndsh_data_generator/random_column_generator.cu\n)\ntarget_compile_features(ndsh_data_generator PUBLIC cxx_std_17 cuda_std_17)\n\ntarget_compile_options(\n  ndsh_data_generator PUBLIC \"$<$<COMPILE_LANGUAGE:CXX>:${CUDF_CXX_FLAGS}>\"\n                             \"$<$<COMPILE_LANGUAGE:CUDA>:${CUDF_CUDA_FLAGS}>\"\n)\n\ntarget_link_libraries(\n  ndsh_data_generator\n  PUBLIC cudf cudf::cudftestutil nvtx3::nvtx3-cpp\n  PRIVATE $<TARGET_NAME_IF_EXISTS:conda_env>\n)\n\ntarget_include_directories(\n  ndsh_data_generator\n  PUBLIC \"$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>\" \"$<BUILD_INTERFACE:${CUDF_SOURCE_DIR}>\"\n         \"$<BUILD_INTERFACE:${CUDF_SOURCE_DIR}/src>\"\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Parameterized Fixture with Complex Initialization in Python\nDESCRIPTION: Example of creating a parameterized pytest fixture that handles complex initialization based on different parameter values.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/testing.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@pytest.fixture(params=[\"a\", \"b\"])\ndef foo(request):\n    if request.param == \"a\":\n        # Some complex initialization\n    elif request.param == \"b\":\n        # Some other complex initialization\n```\n\n----------------------------------------\n\nTITLE: Using pandas-compat Directive in Python Docstrings\nDESCRIPTION: This snippet shows how to use the pandas-compat directive in Python docstrings to document differences between cuDF and pandas APIs.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/documentation.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"\nBrief\n\nDocstring body\n\n.. pandas-compat::\n    :meth:`pandas.DataFrame.METHOD`\n\n    Explanation of differences\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Disable NVTX Support\nDESCRIPTION: This snippet disables NVTX support by defining the `NVTX_DISABLE` preprocessor macro if `USE_NVTX` is not enabled. This prevents the inclusion of NVTX instrumentation in the compiled code.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_21\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT USE_NVTX)\n  target_compile_definitions(cudf PUBLIC NVTX_DISABLE)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Doxygen @copydoc Example for Function Definitions\nDESCRIPTION: Example showing how to use @copydoc tag to avoid duplicating comment blocks for function definitions or detail functions that differ only by stream parameter.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DOCUMENTATION.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n/**\n * @copydoc complicated_function(int,double*,float*)\n *\n * Any extra documentation.\n */\n```\n\n----------------------------------------\n\nTITLE: Configuring Hashing Tests in CUDA DataFrame\nDESCRIPTION: Sets up tests for various hashing algorithms in cuDF. This includes MD5, MurmurHash, SHA (multiple variants), and xxHash implementations using C++ source files.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nConfigureTest(\n  HASHING_TEST\n  hashing/md5_test.cpp\n  hashing/murmurhash3_x86_32_test.cpp\n  hashing/murmurhash3_x64_128_test.cpp\n  hashing/sha1_test.cpp\n  hashing/sha224_test.cpp\n  hashing/sha256_test.cpp\n  hashing/sha384_test.cpp\n  hashing/sha512_test.cpp\n  hashing/xxhash_32_test.cpp\n  hashing/xxhash_64_test.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Configure Stacktrace Debugging\nDESCRIPTION: This snippet conditionally configures stacktrace debugging for the `cudf` target when `CUDF_BUILD_STACKTRACE_DEBUG` is enabled. It removes optimization flags, creates a `cudf_backtrace` library, and sets compile definitions, options, and link options for stacktrace generation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_15\n\nLANGUAGE: CMake\nCODE:\n```\nif(CUDF_BUILD_STACKTRACE_DEBUG)\n  # Remove any optimization level to avoid nvcc warning \"incompatible redefinition for option\n  # 'optimize'.\"\n  string(REGEX REPLACE \"(\\-O[0123])\" \"\" CMAKE_CUDA_FLAGS \"${CMAKE_CUDA_FLAGS}\")\n  string(REGEX REPLACE \"(\\-O[0123])\" \"\" CMAKE_CUDA_FLAGS_RELEASE \"${CMAKE_CUDA_FLAGS_RELEASE}\")\n  string(REGEX REPLACE \"(\\-O[0123])\" \"\" CMAKE_CUDA_FLAGS_MINSIZEREL\n                       \"${CMAKE_CUDA_FLAGS_MINSIZEREL}\"\n  )\n  string(REGEX REPLACE \"(\\-O[0123])\" \"\" CMAKE_CUDA_FLAGS_RELWITHDEBINFO\n                       \"${CMAKE_CUDA_FLAGS_RELWITHDEBINFO}\"\n  )\n\n  add_library(cudf_backtrace INTERFACE)\n  target_compile_definitions(cudf_backtrace INTERFACE CUDF_BUILD_STACKTRACE_DEBUG)\n  target_compile_options(\n    cudf_backtrace INTERFACE \"<$<COMPILE_LANGUAGE:CXX>:-Og>\"\n                             \"<$<COMPILE_LANGUAGE:CUDA>:-Xcompiler=-Og>\"\n  )\n  target_link_options(\n    cudf_backtrace INTERFACE \"<$<LINK_LANGUAGE:CXX>:-rdynamic>\"\n    \"<$<LINK_LANGUAGE:CUDA>:-Xlinker=-rdynamic>\"\n  )\n  target_link_libraries(cudf PRIVATE cudf_backtrace)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Sort Node in cudf-polars IR\nDESCRIPTION: Python code defining the Sort node in the cudf-polars internal representation (IR), demonstrating the structure of node definitions.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_polars/docs/overview.md#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass Expr(Node):\n    children: tuple[Expr, ...]\n\nclass Sort(Expr):\n    _non_child = (\"dtype\", \"options\")\n    children: tuple[Expr]\n    def __init__(self, dtype, options, column: Expr):\n        self.dtype = dtype\n        self.options = options\n        self.children = (column,)\n```\n\n----------------------------------------\n\nTITLE: Running C++ Tests for cuDF\nDESCRIPTION: Commands to run the C++ tests for libcudf and libcudf_kafka after building the test targets.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/CONTRIBUTING.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nctest --test-dir ${CUDF_HOME}/cpp/build  # libcudf\nctest --test-dir ${CUDF_HOME}/cpp/libcudf_kafka/build  # libcudf_kafka\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project for cudf-python\nDESCRIPTION: Configures the CMake project for cudf-python, which provides Python bindings for the NVIDIA RAPIDS cudf library. It sets the minimum required CMake version, includes necessary configuration files, initializes CUDA architectures, defines the project with version information, and sets up compilation for subdirectories.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.30.4 FATAL_ERROR)\n\ninclude(../../cmake/rapids_config.cmake)\ninclude(rapids-cuda)\nrapids_cuda_init_architectures(cudf-python)\n\nproject(\n  cudf-python\n  VERSION \"${RAPIDS_VERSION}\"\n  LANGUAGES CXX CUDA\n)\n\nfind_package(cudf \"${RAPIDS_VERSION}\" REQUIRED)\n\ninclude(rapids-cython-core)\nrapids_cython_init()\n\nadd_subdirectory(cudf/_lib)\nadd_subdirectory(udf_cpp)\n```\n\n----------------------------------------\n\nTITLE: LIBCUDF CMake Build Options\nDESCRIPTION: Essential CMake configuration options for building libcudf with proper string handling and Arrow integration.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/README.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n-DCUDF_LARGE_STRINGS_DISABLED=ON -DCUDF_USE_ARROW_STATIC=ON -DCUDF_ENABLE_ARROW_S3=OFF\n```\n\n----------------------------------------\n\nTITLE: Installing cudf-polars Executor\nDESCRIPTION: Commands to install the cudf-polars executor package in editable mode after building cudf.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_polars/docs/overview.md#2025-04-21_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ncd cudf/python/cudf_polars\npip install --no-build-isolation --no-deps -e .\n```\n\n----------------------------------------\n\nTITLE: Installing cuDF in Development Environment\nDESCRIPTION: Commands to activate the conda environment and install a recent version of cuDF for documentation-only contributions.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/CONTRIBUTING.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nconda activate cudf_dev\nconda install cudf -c rapidsai-nightly -c conda-forge\n```\n\n----------------------------------------\n\nTITLE: Installing nvcomp Shared Library\nDESCRIPTION: Adds a pre-link command to copy the nvcomp shared library to the project's binary directory when nvcomp::nvcomp target is available.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/src/main/native/CMakeLists.txt#2025-04-21_snippet_13\n\nLANGUAGE: cmake\nCODE:\n```\nif(TARGET nvcomp::nvcomp)\n  add_custom_command(\n    TARGET cudfjni\n    PRE_LINK\n    COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_FILE:nvcomp::nvcomp>\n            \"${PROJECT_BINARY_DIR}/libnvcomp.so\"\n    COMMENT \"Copying nvcomp libraries to ${PROJECT_BINARY_DIR}\"\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Rolling Benchmark with NVBench in cuDF\nDESCRIPTION: Sets up the rolling benchmark suite with multiple source files for different rolling operations including grouped and range-based calculations. This configures four benchmark source files for the rolling operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/benchmarks/CMakeLists.txt#2025-04-21_snippet_12\n\nLANGUAGE: cmake\nCODE:\n```\nConfigureNVBench(\n  ROLLING_NVBENCH rolling/grouped_range_rolling_sum.cu rolling/grouped_rolling_sum.cpp\n  rolling/range_rolling_sum.cu rolling/rolling_sum.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Testing pylibcudf Bindings with Pytest - Python\nDESCRIPTION: This Python test setup demonstrates the use of Pytest for checking pylibcudf bindings. It uses pyarrow for creating test data and verifying results, providing functions to assert equality of columns between pyarrow and pylibcudf. Dependencies include pyarrow and pytest. Expected inputs are arrays and table data; outputs are validation results for consistency of the Cython-Python interface.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/developer_docs.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport pyarrow as pa\nimport pyarrow.compute as pc\nimport pytest\nfrom cudf._lib import pylibcudf as plc\nfrom utils import assert_column_eq\n```\n\n----------------------------------------\n\nTITLE: Documenting pylibcudf.column_factories Module in Python\nDESCRIPTION: This code snippet uses Sphinx's automodule directive to automatically generate documentation for all members of the pylibcudf.column_factories module. This approach ensures comprehensive documentation of the module's contents, including classes, functions, and other members.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/api_docs/column_factories.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n.. automodule:: pylibcudf.column_factories\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Building HTML Documentation with Sphinx\nDESCRIPTION: Commands to build the cuDF documentation using Sphinx from the docs directory.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/documentation.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nmake html\n```\n\n----------------------------------------\n\nTITLE: Namespace Documentation Example\nDESCRIPTION: Example showing how to document CUDF namespaces.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DOCUMENTATION.md#2025-04-21_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\n/**\n * @brief cuDF interfaces\n *\n * This is the top-level namespace which contains all cuDF functions and types.\n */\nnamespace CUDF_EXPORT cudf {\n```\n\n----------------------------------------\n\nTITLE: Configuring Lists Tests with C++\nDESCRIPTION: This snippet organizes tests regarding list functionalities within CUDF, covering a range of functionalities such as concatenation and extraction. It ensures lists are handled correctly in various configurations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_47\n\nLANGUAGE: cpp\nCODE:\n```\nConfigureTest(\n  LISTS_TEST\n  lists/combine/concatenate_list_elements_tests.cpp\n  lists/combine/concatenate_rows_tests.cpp\n  lists/contains_tests.cpp\n  lists/count_elements_tests.cpp\n  lists/explode_tests.cpp\n  lists/extract_tests.cpp\n  lists/reverse_tests.cpp\n  lists/sequences_tests.cpp\n  lists/set_operations/difference_distinct_tests.cpp\n  lists/set_operations/have_overlap_tests.cpp\n  lists/set_operations/intersect_distinct_tests.cpp\n  lists/set_operations/union_distinct_tests.cpp\n  lists/sort_lists_tests.cpp\n  lists/stream_compaction/apply_boolean_mask_tests.cpp\n  lists/stream_compaction/distinct_tests.cpp\n  GPUS 1\n  PERCENT 70\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring CUDF Source and Build Directories\nDESCRIPTION: Sets up the CUDF source directory and determines the build directory location, with fallback options for environment variables.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/src/main/native/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nset(CUDF_SOURCE_DIR \"${PROJECT_SOURCE_DIR}/../../../../cpp\")\nif(NOT DEFINED CUDF_CPP_BUILD_DIR OR CUDF_CPP_BUILD_DIR STREQUAL \"\")\n  if(DEFINED ENV{CUDF_CPP_BUILD_DIR})\n    set(CUDF_CPP_BUILD_DIR \"$ENV{CUDF_CPP_BUILD_DIR}\")\n  else()\n    set(CUDF_CPP_BUILD_DIR \"${CUDF_SOURCE_DIR}/build\")\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating Type Stubs for pylibcudf with TypeVar and Union\nDESCRIPTION: Examples of creating Python type stubs (.pyi files) for Cython code to enable static type checking. Shows how to handle both single-occurrence and multi-occurrence fused types.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/developer_docs.md#2025-04-21_snippet_6\n\nLANGUAGE: cython\nCODE:\n```\nctypedef fused ColumnOrTable:\n    Table\n    Column\n\ncpdef list split(ColumnOrTable input, list splits): ...\n```\n\nLANGUAGE: python\nCODE:\n```\nColumnOrTable = TypeVar(\"ColumnOrTable\", Column, Table)\n\ndef split(input: ColumnOrTable, splits: list[int]) -> list[ColumnOrTable]: ...\n```\n\nLANGUAGE: cython\nCODE:\n```\nctypedef fused TableOrListOfScalars:\n    Table\n    list\n\ncpdef Table scatter(\n    TableOrListOfScalars source, Column scatter_map, Table target\n)\n```\n\nLANGUAGE: python\nCODE:\n```\ndef scatter(\n    source: Table | list[Scalar], scatter_map: Column, target: Table\n) -> Table: ...\n```\n\n----------------------------------------\n\nTITLE: Creating and Activating the Conda Environment\nDESCRIPTION: Commands to create and activate the conda development environment for cuDF using the provided environment file.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/CONTRIBUTING.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# create the conda environment (assuming in base `cudf` directory)\n# note: RAPIDS currently doesn't support `channel_priority: strict`;\n# use `channel_priority: flexible` instead\nconda env create --name cudf_dev --file conda/environments/all_cuda-128_arch-x86_64.yaml\n# activate the environment\nconda activate cudf_dev\n```\n\n----------------------------------------\n\nTITLE: Setting GPU Architecture Configuration for CUDA JNI Project\nDESCRIPTION: Initializes the CUDA architecture settings for the CUDF JNI project, using predefined GPU_ARCHS if available.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/src/main/native/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\n# Use GPU_ARCHS if it is defined\nif(DEFINED GPU_ARCHS)\n  set(CMAKE_CUDA_ARCHITECTURES \"${GPU_ARCHS}\")\nendif()\nrapids_cuda_init_architectures(CUDF_JNI)\n```\n\n----------------------------------------\n\nTITLE: Running Docker Container with NVIDIA GPU Support\nDESCRIPTION: Command to start a Docker container with GPU support using nvidia-docker. This launches an interactive bash session in the previously built cuDF build environment.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/ci/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnvidia-docker run -it cudf-build:11.8.0-devel-rocky8 bash\n```\n\n----------------------------------------\n\nTITLE: Running Regression Tests with Specific Crash Files\nDESCRIPTION: Shows how to run regression tests by specifying directories containing crash files using the pythonfuzz decorator.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf/cudf/_fuzz_testing/tests/readme.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@pythonfuzz(data_handle=CSVWriter, regression=True, dir=[\"/cudf/python/cudf/cudf/_fuzz_testing\"])\n```\n\n----------------------------------------\n\nTITLE: Installing Pre-commit Git Hooks\nDESCRIPTION: Command to install pre-commit hooks to run automatically on git commit.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/CONTRIBUTING.md#2025-04-21_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\npre-commit install\n```\n\n----------------------------------------\n\nTITLE: Cloning cuDF Repository in Docker Container\nDESCRIPTION: Command to clone the cuDF repository with its submodules into the Docker container. It specifies branch-25.06 as the target branch.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/ci/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone --recursive https://github.com/rapidsai/cudf.git -b branch-25.06\n```\n\n----------------------------------------\n\nTITLE: Configuring Reshape Benchmark with NVBench in cuDF\nDESCRIPTION: Sets up the reshape benchmarks for interleave operations using NVBench framework. This snippet configures the benchmark source at reshape/interleave.cpp.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/benchmarks/CMakeLists.txt#2025-04-21_snippet_11\n\nLANGUAGE: cmake\nCODE:\n```\nConfigureNVBench(RESHAPE_NVBENCH reshape/interleave.cpp)\n```\n\n----------------------------------------\n\nTITLE: Configuring String Operations Stream Tests\nDESCRIPTION: Configuration of comprehensive string manipulation tests including case conversion, combining, filtering, and pattern matching operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_52\n\nLANGUAGE: cmake\nCODE:\n```\nConfigureTest(\n  STREAM_STRINGS_TEST\n  streams/strings/attributes_test.cpp\n  streams/strings/case_test.cpp\n  streams/strings/combine_test.cpp\n  streams/strings/contains_test.cpp\n  streams/strings/convert_test.cpp\n  streams/strings/extract_test.cpp\n  streams/strings/factory_test.cpp\n  streams/strings/filter_test.cpp\n  streams/strings/find_test.cpp\n  streams/strings/replace_test.cpp\n  streams/strings/reverse_test.cpp\n  streams/strings/split_test.cpp\n  streams/strings/strings_tests.cpp\n  STREAM_MODE\n  testing\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Autodoc for CuDF Filling Module in Python\nDESCRIPTION: This snippet uses Sphinx's automodule directive to generate documentation for the pylibcudf.filling module. It includes all members of the module in the documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/api_docs/filling.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n.. automodule:: pylibcudf.filling\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Structuring API Documentation with Autosummary in reStructuredText\nDESCRIPTION: This snippet demonstrates how to organize API documentation using the autosummary directive in reStructuredText, which is used to generate separate pages for each documented API.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/documentation.md#2025-04-21_snippet_1\n\nLANGUAGE: restructuredtext\nCODE:\n```\nSection name\n~~~~~~~~~~~~\n.. autosummary::\n   API1\n   API2\n   ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Linked Libraries for RAPIDS cuDF NLP Modules\nDESCRIPTION: This snippet specifies the libraries to be linked with the Cython modules. In this case, it's linking against the cudf library, which is the core RAPIDS DataFrame library for GPU-accelerated data processing.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/pylibcudf/nvtext/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(linked_libraries cudf::cudf)\n```\n\n----------------------------------------\n\nTITLE: Configuring Stream Test Identification\nDESCRIPTION: Conditional configuration for stream identification test that checks default stream usage behavior.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_50\n\nLANGUAGE: cmake\nCODE:\n```\nif(CUDF_BUILD_STREAMS_TEST_UTIL)\n  ConfigureTest(\n    STREAM_IDENTIFICATION_TEST identify_stream_usage/test_default_stream_identification.cu\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Strings Column Wrapper Examples in C++\nDESCRIPTION: Shows creation of string columns with various configurations including nullable and non-nullable variants using iterators and initializer lists.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/TESTING.md#2025-04-21_snippet_7\n\nLANGUAGE: c++\nCODE:\n```\n// Creates a non-nullable STRING column with 7 string elements:\n// {\"\", \"this\", \"is\", \"a\", \"column\", \"of\", \"strings\"}\nstd::vector<std::string> strings{\"\", \"this\", \"is\", \"a\", \"column\", \"of\", \"strings\"};\ncudf::test::strings_column_wrapper s(strings.begin(), strings.end());\n\n// Creates a nullable STRING column with 7 string elements:\n// {NULL, \"this\", NULL, \"a\", NULL, \"of\", NULL}\nstd::vector<std::string> strings{\"\", \"this\", \"is\", \"a\", \"column\", \"of\", \"strings\"};\nauto validity = cudf::detail::make_counting_transform_iterator(0, [](auto i){return i % 2;});\ncudf::test::strings_column_wrapper s(strings.begin(), strings.end(), validity);\n\n// Creates a non-nullable STRING column with 7 string elements:\n// {\"\", \"this\", \"is\", \"a\", \"column\", \"of\", \"strings\"}\ncudf::test::strings_column_wrapper s({\"\", \"this\", \"is\", \"a\", \"column\", \"of\", \"strings\"});\n\n// Creates a nullable STRING column with 7 string elements:\n// {NULL, \"this\", NULL, \"a\", NULL, \"of\", NULL}\nauto validity = cudf::detail::make_counting_transform_iterator(0, [](auto i){return i % 2;});\ncudf::test::strings_column_wrapper s({\"\", \"this\", \"is\", \"a\", \"column\", \"of\", \"strings\"}, validity);\n```\n\n----------------------------------------\n\nTITLE: Setting up PyTest Fixtures for pylibcudf Testing\nDESCRIPTION: Example of creating module-scoped fixtures for PyArrow and pylibcudf columns to be used in tests. These fixtures follow the recommended practice of treating module-scoped fixtures as immutable.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/developer_docs.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@pytest.fixture(scope=\"module\")\ndef pa_column(pa_dtype):\n    pa.array([1, 2, 3])\n\n\n@pytest.fixture(scope=\"module\")\ndef column(pa_column):\n    return plc.interop.from_arrow(pa_column)\n\n\ndef test_foo(pa_column, column):\n    index = 1\n    result = plc.foo(column)\n    expected = pa.foo(pa_column)\n\n    assert_column_eq(result, expected)\n```\n\n----------------------------------------\n\nTITLE: Installing cuDF via pip for CUDA 11.x in Bash\nDESCRIPTION: This command installs cuDF for CUDA 11.x environments using pip and the NVIDIA Python Package Index.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install --extra-index-url=https://pypi.nvidia.com cudf-cu11\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories for CUDF JNI\nDESCRIPTION: Configures include directories for the cudfjni target, including JNI headers and project-specific include paths.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/src/main/native/CMakeLists.txt#2025-04-21_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(\n  cudfjni PUBLIC \"${CMAKE_BINARY_DIR}/include\" \"${CMAKE_SOURCE_DIR}/include\"\n                 \"${CMAKE_SOURCE_DIR}/src\" \"${JNI_INCLUDE_DIRS}\"\n)\n```\n\n----------------------------------------\n\nTITLE: Pseudo Code Example\nDESCRIPTION: Example showing how to include pseudo code in documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DOCUMENTATION.md#2025-04-21_snippet_9\n\nLANGUAGE: pseudo\nCODE:\n```\n*\n* Sometimes pseudocode is clearer.\n* @code{.pseudo}\n* s = int column of [ 1, 2, null, 4 ]\n* r = fill( s, [1, 2], 0 )\n* r is now [ 1, 0, 0, 4 ]\n* @endcode\n*\n```\n\n----------------------------------------\n\nTITLE: Running Doxygen Linter\nDESCRIPTION: Command to run doxygen as a documentation linter on C++/CUDA code.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/CONTRIBUTING.md#2025-04-21_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n./ci/checks/doxygen.sh\n```\n\n----------------------------------------\n\nTITLE: Installing cuDF via pip for CUDA 11.x\nDESCRIPTION: Command to install cuDF via pip from the NVIDIA Python Package Index for environments with CUDA 11.x.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_kafka/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install --extra-index-url=https://pypi.nvidia.com cudf-cu11\n```\n\n----------------------------------------\n\nTITLE: Displaying DataFrame\nDESCRIPTION: Displays the created DataFrame. This allows for inspection of the data structure that will be processed with GPU acceleration.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf/cudf_pandas_tests/data/repr_slow_down_test.ipynb#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndf\n```\n\n----------------------------------------\n\nTITLE: Creating RAPIDS Cython Modules for cuDF String Processing\nDESCRIPTION: Uses the rapids_cython_create_modules CMake function to generate Cython modules for cuDF string processing. It specifies C++ as the language, sets source files and linked libraries, and associates the modules with the cudf target using the cpp_strings prefix.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/pylibcudf/libcudf/strings/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nrapids_cython_create_modules(\n  CXX\n  SOURCE_FILES \"${cython_sources}\"\n  LINKED_LIBRARIES \"${linked_libraries}\" ASSOCIATED_TARGETS cudf MODULE_PREFIX cpp_strings\n)\n```\n\n----------------------------------------\n\nTITLE: Compiling and Executing libcudf C++ Examples\nDESCRIPTION: Terminal commands for configuring, building, and executing the different string processing examples. This includes project setup with CMake and options for running any of the four example implementations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/examples/strings/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Configure project\ncmake -S . -B build/\n# Build\ncmake --build build/ --parallel $PARALLEL_LEVEL\n# Execute\nbuild/libcudf_apis names.csv\n--OR--\nbuild/custom_with_malloc names.csv\n--OR--\nbuild/custom_prealloc names.csv\n--OR--\nbuild/custom_optimized names.csv\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for cuDF Contiguous Split Module\nDESCRIPTION: This code snippet uses Sphinx's automodule directive to automatically generate documentation for all members of the pylibcudf.contiguous_split module. This includes functions, classes, and other objects defined in the module.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/api_docs/contiguous_split.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: pylibcudf.contiguous_split\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Sphinx Class Documentation Template in RST\nDESCRIPTION: A reStructuredText template for generating class documentation using Sphinx directives and numpydoc extension. The template includes placeholders for module name, full class name, and underline decoration while letting numpydoc handle methods and attributes sections automatically.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/_templates/autosummary/class.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n{{ fullname }}\n{{ underline }}\n\n.. currentmodule:: {{ module }}\n\n.. autoclass:: {{ objname }}\n\n..\n   Don't include the methods or attributes sections, numpydoc adds them for us instead.\n```\n\n----------------------------------------\n\nTITLE: Configuring Utility Tests in CMake\nDESCRIPTION: Sets up tests for various utility functions including batched memory operations, column utilities, debug helpers, type checking, and pinned memory functionality.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_23\n\nLANGUAGE: CMake\nCODE:\n```\n# ##################################################################################################\n# * utilities tests -------------------------------------------------------------------------------\nConfigureTest(\n  UTILITIES_TEST\n  utilities_tests/batched_memcpy_tests.cu\n  utilities_tests/batched_memset_tests.cu\n  utilities_tests/column_debug_tests.cpp\n  utilities_tests/column_utilities_tests.cpp\n  utilities_tests/column_wrapper_tests.cpp\n  utilities_tests/default_stream_tests.cpp\n  utilities_tests/io_utilities_tests.cpp\n  utilities_tests/lists_column_wrapper_tests.cpp\n  utilities_tests/pinned_memory_tests.cpp\n  utilities_tests/type_check_tests.cpp\n  utilities_tests/type_list_tests.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Core Stream Tests\nDESCRIPTION: Configuration of multiple stream-based tests for core cuDF operations including binary operations, column views, concatenation, and data manipulation tests.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_51\n\nLANGUAGE: cmake\nCODE:\n```\nConfigureTest(STREAM_BINARYOP_TEST streams/binaryop_test.cpp STREAM_MODE testing)\nConfigureTest(STREAM_COLUMN_VIEW_TEST streams/column_view_test.cpp STREAM_MODE testing)\nConfigureTest(STREAM_CONCATENATE_TEST streams/concatenate_test.cpp STREAM_MODE testing)\nConfigureTest(STREAM_COPYING_TEST streams/copying_test.cpp STREAM_MODE testing)\n```\n\n----------------------------------------\n\nTITLE: Maven Dependency for CUDA 11.0\nDESCRIPTION: Maven dependency configuration specifically for CUDA 11.0 compatibility, using the cuda11 classifier.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/README.md#2025-04-21_snippet_1\n\nLANGUAGE: xml\nCODE:\n```\n<dependency>\n    <groupId>ai.rapids</groupId>\n    <artifactId>cudf</artifactId>\n    <classifier>cuda11</classifier>\n    <version>${cudf.version}</version>\n</dependency>\n```\n\n----------------------------------------\n\nTITLE: Configuring CUDF Benchmark Targets with CMake\nDESCRIPTION: Configures various benchmark targets for different CUDF operations by calling the benchmark configuration functions. Includes benchmarks for copying, gathering, scattering, joining, lists operations, and more.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/benchmarks/CMakeLists.txt#2025-04-21_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\n# * copying benchmarks\n# -----------------------------------------------------------------------------\nConfigureNVBench(COPYING_NVBENCH copying/concatenate.cpp)\n\n# * gather benchmark ------------------------------------------------------------------------------\nConfigureBench(GATHER_BENCH copying/gather.cu)\n\n# * scatter benchmark -----------------------------------------------------------------------------\nConfigureBench(SCATTER_BENCH copying/scatter.cu)\n\n# * lists scatter benchmark -----------------------------------------------------------------------\nConfigureBench(SCATTER_LISTS_BENCH lists/copying/scatter_lists.cu)\n\n# * Other list-related operartions benchmark ------------------------------------------------------\nConfigureNVBench(SET_OPS_NVBENCH lists/set_operations.cpp)\n\n# * contiguous_split benchmark  -------------------------------------------------------------------\nConfigureBench(CONTIGUOUS_SPLIT_BENCH copying/contiguous_split.cu)\n\n# * shift benchmark -------------------------------------------------------------------------------\nConfigureBench(SHIFT_BENCH copying/shift.cu)\n\n# * copy-if-else benchmark\n# -----------------------------------------------------------------------------\nConfigureBench(COPY_IF_ELSE_BENCH copying/copy_if_else.cpp)\n\n# * transpose benchmark ---------------------------------------------------------------------------\nConfigureBench(TRANSPOSE_BENCH transpose/transpose.cpp)\n\n# * nds-h benchmark --------------------------------------------------------------------------------\nConfigureNVBench(NDSH_Q01_NVBENCH ndsh/q01.cpp ndsh/utilities.cpp)\nConfigureNVBench(NDSH_Q05_NVBENCH ndsh/q05.cpp ndsh/utilities.cpp)\nConfigureNVBench(NDSH_Q06_NVBENCH ndsh/q06.cpp ndsh/utilities.cpp)\nConfigureNVBench(NDSH_Q09_NVBENCH ndsh/q09.cpp ndsh/utilities.cpp)\nConfigureNVBench(NDSH_Q10_NVBENCH ndsh/q10.cpp ndsh/utilities.cpp)\n\n# * stream_compaction benchmark -------------------------------------------------------------------\nConfigureNVBench(\n  STREAM_COMPACTION_NVBENCH\n  stream_compaction/apply_boolean_mask.cpp\n  stream_compaction/distinct.cpp\n  stream_compaction/distinct_count.cpp\n  stream_compaction/stable_distinct.cpp\n  stream_compaction/stream_compaction_common.cpp\n  stream_compaction/unique.cpp\n  stream_compaction/unique_count.cpp\n)\n\n# * join benchmark --------------------------------------------------------------------------------\nConfigureNVBench(\n  JOIN_NVBENCH join/left_join.cu join/conditional_join.cu join/join.cu join/mixed_join.cu\n  join/distinct_join.cu join/multiplicity_join.cu\n)\n\n# * iterator benchmark ----------------------------------------------------------------------------\nConfigureBench(ITERATOR_BENCH iterator/iterator.cu)\n\n# * search benchmark ------------------------------------------------------------------------------\nConfigureBench(SEARCH_BENCH search/search.cpp)\nConfigureNVBench(SEARCH_NVBENCH search/contains_scalar.cpp search/contains_table.cpp)\n```\n\n----------------------------------------\n\nTITLE: Interval Data Functions in cuDF\nDESCRIPTION: Function for generating interval ranges, supporting advanced interval-based data manipulations\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/api_docs/general_functions.rst#2025-04-21_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ninterval_range\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Properties for CUDF JNI\nDESCRIPTION: Sets target properties for the cudfjni library, including RPATH settings, C++ and CUDA standards, and position-independent code requirements.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/src/main/native/CMakeLists.txt#2025-04-21_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\nset_target_properties(\n  cudfjni\n  PROPERTIES BUILD_RPATH \"\\$ORIGIN\"\n             INSTALL_RPATH \"\\$ORIGIN\"\n             # set target compile options\n             CXX_STANDARD 17\n             CXX_STANDARD_REQUIRED ON\n             CUDA_STANDARD 17\n             CUDA_STANDARD_REQUIRED ON\n             POSITION_INDEPENDENT_CODE ON\n             INTERFACE_POSITION_INDEPENDENT_CODE ON\n)\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for pylibcudf.expressions Module using Sphinx\nDESCRIPTION: This reStructuredText snippet uses the automodule directive to automatically generate documentation for all members of the pylibcudf.expressions module. It's typically used in Sphinx documentation projects.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/api_docs/expressions.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n===========\nexpressions\n===========\n\n.. automodule:: pylibcudf.expressions\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring JIT Parser Test with C++\nDESCRIPTION: This snippet configures JIT (Just-In-Time) parser tests for CUDF, validating the parsing of PTX functions. It is necessary for dynamic compilation and execution of GPU codes in CUDF.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_49\n\nLANGUAGE: cpp\nCODE:\n```\nConfigureTest(JIT_PARSER_TEST jit/parse_ptx_function.cpp)\ntarget_include_directories(JIT_PARSER_TEST PRIVATE \"$<BUILD_INTERFACE:${CUDF_SOURCE_DIR}/src>\")\n```\n\n----------------------------------------\n\nTITLE: Installing cuDF via pip for CUDA 12.x in Bash\nDESCRIPTION: This command installs cuDF for CUDA 12.x environments using pip and the NVIDIA Python Package Index.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/README.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npip install --extra-index-url=https://pypi.nvidia.com cudf-cu12\n```\n\n----------------------------------------\n\nTITLE: Code Example in Python\nDESCRIPTION: Example showing how to include Python code snippets in documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DOCUMENTATION.md#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n*\n* @code{.py}\n* import cudf\n* s = cudf.Series([1,2,3])\n* @endcode\n*\n```\n\n----------------------------------------\n\nTITLE: Configuring CUDA String UDF Library Build\nDESCRIPTION: Defines the main CUDA strings UDF library build configuration including compiler flags, dependencies, and installation settings.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf/udf_cpp/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(cudf_strings_udf SHARED strings/src/strings/udf/udf_apis.cu)\ntarget_include_directories(\n  cudf_strings_udf PUBLIC \"$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/strings/include>\"\n)\n\nset_target_properties(\n  cudf_strings_udf\n  PROPERTIES BUILD_RPATH \"\\$ORIGIN/../\"\n             INSTALL_RPATH \"\\$ORIGIN/../\"\n             CXX_STANDARD 17\n             CXX_STANDARD_REQUIRED ON\n             CUDA_STANDARD 17\n             CUDA_STANDARD_REQUIRED ON\n             POSITION_INDEPENDENT_CODE ON\n             INTERFACE_POSITION_INDEPENDENT_CODE ON\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Encode Tests with C++\nDESCRIPTION: This snippet configures encode tests for CUDF, ensuring that encoding functionalities work as expected across various scenarios. It is critical for data handling and transformation processes.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_45\n\nLANGUAGE: cpp\nCODE:\n```\nConfigureTest(ENCODE_TEST encode/encode_tests.cpp)\n```\n\n----------------------------------------\n\nTITLE: Generating Sphinx Documentation for pylibcudf.concatenate Module\nDESCRIPTION: This snippet uses Sphinx's automodule directive to automatically generate documentation for all members of the pylibcudf.concatenate module. It's typically used in a Sphinx configuration file or RST document to create API documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/api_docs/concatenate.rst#2025-04-21_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: pylibcudf.concatenate\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Running py-spy for Profiling with pytest\nDESCRIPTION: Command example showing how to use py-spy to record profiling information for pytest benchmarks, which provides an alternative to pytest-profiling for performance analysis.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/benchmarking.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npy-spy record -- pytest bench_foo.py\n```\n\n----------------------------------------\n\nTITLE: Configuring Span Tests with Filter Settings in CMake\nDESCRIPTION: Sets up tests for span functionality with special handling for device vector tests. The tests are split into two executables to accommodate preload library requirements and handle synchronous operations on the default stream.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_24\n\nLANGUAGE: CMake\nCODE:\n```\n# ##################################################################################################\n# * span tests -------------------------------------------------------------------------------\n\n# This test must be split into two executables so that one can use the preload library and one does\n# not. The one that doesn't includes a thrust::device_vector copy, which is always synchronous on\n# the default stream and is out of libcudf's control (but must be tested).\nset(_allowlist_filter SpanTest.CanConstructFromDeviceContainers)\n\nConfigureTest(SPAN_TEST utilities_tests/span_tests.cu)\nConfigureTest(SPAN_TEST_DEVICE_VECTOR utilities_tests/span_tests.cu)\n\n# Overwrite the environments set by ConfigureTest\nset_property(\n  TEST SPAN_TEST SPAN_TEST_DEVICE_VECTOR\n  APPEND\n  PROPERTY ENVIRONMENT \"GTEST_FILTER=-${_allowlist_filter}\"\n)\n```\n\n----------------------------------------\n\nTITLE: Defining ConfigureTest CMake Function for CUDF Kafka Tests\nDESCRIPTION: Creates a function that configures test properties, linking, and runtime settings for CUDF Kafka tests. The function sets up output directories, linking with GTest libraries, and registers the test with the RAPIDS testing framework.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/libcudf_kafka/tests/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(ConfigureTest test_name)\n  add_executable(${test_name} ${ARGN})\n  set_target_properties(\n    ${test_name}\n    PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"$<BUILD_INTERFACE:${CUDF_KAFKA_BINARY_DIR}/gtests>\"\n               INSTALL_RPATH \"\\$ORIGIN/../../../lib\"\n  )\n  target_link_libraries(\n    ${test_name} PRIVATE GTest::gmock GTest::gmock_main GTest::gtest_main cudf_kafka\n  )\n  rapids_test_add(\n    NAME ${test_name}\n    COMMAND ${test_name}\n    GPUS 1\n    PERCENT 25\n    INSTALL_COMPONENT_SET testing\n  )\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Installing Pre-commit via Conda\nDESCRIPTION: Command to install pre-commit tool using conda package manager from conda-forge channel.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/CONTRIBUTING.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nconda install -c conda-forge pre-commit\n```\n\n----------------------------------------\n\nTITLE: Defining Cython Sources and Linked Libraries for cuDF String Processing Modules\nDESCRIPTION: Sets up variables for Cython source files and linked libraries required for building cuDF string processing modules. It includes files for character types, combination operations, regex flags, side types, and translation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/pylibcudf/libcudf/strings/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(cython_sources char_types.pyx combine.pyx regex_flags.pyx side_type.pyx translate.pyx)\n\nset(linked_libraries cudf::cudf)\n```\n\n----------------------------------------\n\nTITLE: Importing cuDF Binary Operations Module\nDESCRIPTION: This code snippet demonstrates how to import the binaryop module from pylibcudf. It uses Python's automodule directive to automatically generate documentation for all members of the module.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/api_docs/binaryop.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n.. automodule:: pylibcudf.binaryop\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring CUDF Linking Mode\nDESCRIPTION: Sets up special linking flags for the CUDF library, with different handling for static linking to ensure proper symbol resolution.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/src/main/native/CMakeLists.txt#2025-04-21_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\nset(CUDF_LINK PUBLIC cudf::cudf)\nif(CUDF_JNI_LIBCUDF_STATIC)\n  # Whole-link libcudf.a into the shared library but not its dependencies\n  set(CUDF_LINK PRIVATE -Wl,--whole-archive cudf::cudf -Wl,--no-whole-archive PUBLIC cudf::cudf)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for String Types in RAPIDS cuDF\nDESCRIPTION: This reStructuredText directive instructs Doxygen to generate documentation for all members of the 'strings_types' group in the RAPIDS cuDF library. It is used to create API documentation for string-related types and functions.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/strings_types.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: strings_types\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring JSON Path Test with C++\nDESCRIPTION: This snippet sets up tests for JSON path functionality in CUDF, ensuring that the library can manipulate and retrieve data accurately from JSON structures. It is vital for developers working with JSON data.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_40\n\nLANGUAGE: cpp\nCODE:\n```\nConfigureTest(JSON_PATH_TEST json/json_tests.cpp)\n```\n\n----------------------------------------\n\nTITLE: Configuring Sorted-Merge Tests in CMake\nDESCRIPTION: Sets up tests for sorted-merge operations, including dictionary merging and string merging functionality.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_29\n\nLANGUAGE: CMake\nCODE:\n```\n# ##################################################################################################\n# * sorted-merge tests ----------------------------------------------------------------------------\nConfigureTest(\n  MERGE_TEST merge/merge_test.cpp merge/merge_dictionary_test.cpp merge/merge_string_test.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure for Column Reshape\nDESCRIPTION: RST format documentation structure that defines the layout for column reshape documentation, including a doxygen group reference and a toctree with reshape/transpose subsection.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/column_reshape.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\nColumn Reshape\n==============\n\n.. doxygengroup:: column_reshape\n   :members:\n\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n\n   reshape_transpose\n```\n\n----------------------------------------\n\nTITLE: Configuring Doxygen Documentation for cuDF Expressions Group\nDESCRIPTION: This RST (reStructuredText) directive configures Doxygen to generate documentation for the 'expressions' group and all its members. It's used to incorporate C++/CUDA API documentation into the Sphinx documentation system.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/expressions.rst#2025-04-21_snippet_0\n\nLANGUAGE: RST\nCODE:\n```\n.. doxygengroup:: expressions\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake and RAPIDS Dependencies\nDESCRIPTION: Sets up basic CMake configuration and includes required RAPIDS modules for build system initialization.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf/udf_cpp/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.30.4 FATAL_ERROR)\n\ninclude(rapids-cmake)\ninclude(rapids-cpm)\ninclude(rapids-find)\n\nrapids_cpm_init()\n```\n\n----------------------------------------\n\nTITLE: Configuring Structs Test with C++\nDESCRIPTION: This snippet configures testing for structs in CUDF, confirming that struct manipulations work as intended. It is key for type safety and proper handling of complex data structures.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_41\n\nLANGUAGE: cpp\nCODE:\n```\nConfigureTest(STRUCTS_TEST structs/structs_column_tests.cpp structs/utilities_tests.cpp)\n```\n\n----------------------------------------\n\nTITLE: Sphinx Module Documentation for PyLibCuDF Reshape\nDESCRIPTION: Sphinx documentation directive for automatically generating documentation for the pylibcudf.reshape module, exposing all available members and methods\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/api_docs/reshape.rst#2025-04-21_snippet_0\n\nLANGUAGE: Sphinx\nCODE:\n```\n.. automodule:: pylibcudf.reshape\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Equivalent Benchmark Function Using Explicit Fixture Name\nDESCRIPTION: Example showing the equivalent implementation of a benchmark without using the benchmark_with_object decorator, demonstrating how it would require using the full fixture name directly.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/benchmarking.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef bench_foo(benchmark, dataframe_dtype_int_cols_6):\n    benchmark(dataframe_dtype_int_cols_6.foo)\n```\n\n----------------------------------------\n\nTITLE: Serving Documentation on Specific Port\nDESCRIPTION: Command to serve documentation on a specified port using Python's HTTP server.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/documentation.md#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\npython -m http.server $PORT\n```\n\n----------------------------------------\n\nTITLE: Configuration Options for cuDF Python Bindings\nDESCRIPTION: Defines build options and checks for existing cuDF installations. Sets up various flags to control test utilities, benchmarks, and nvcomp integration.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/libcudf/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\noption(USE_NVCOMP_RUNTIME_WHEEL \"Use the nvcomp wheel at runtime instead of the system library\" OFF)\n\n# Check if cudf is already available. If so, it is the user's responsibility to ensure that the\n# CMake package is also available at build time of the Python cudf package.\nfind_package(cudf \"${RAPIDS_VERSION}\")\n\nif(cudf_FOUND)\n  return()\nendif()\n\nunset(cudf_FOUND)\n\nset(BUILD_TESTS OFF)\nset(BUILD_BENCHMARKS OFF)\nset(CUDF_BUILD_TESTUTIL OFF)\nset(CUDF_BUILD_STREAMS_TEST_UTIL OFF)\nif(USE_NVCOMP_RUNTIME_WHEEL)\n  set(CUDF_EXPORT_NVCOMP OFF)\nendif()\nset(CUDA_STATIC_RUNTIME ON)\n\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/lib)\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories for Additional cuDF String Operations\nDESCRIPTION: This snippet adds subdirectories for additional string operation modules, specifically 'convert' and 'split'. These subdirectories likely contain additional CMake files for building related string manipulation functions.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/pylibcudf/strings/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(convert)\nadd_subdirectory(split)\n```\n\n----------------------------------------\n\nTITLE: Sphinx Documentation Structure for cuDF Datetime APIs\nDESCRIPTION: Defines the structure of the Sphinx documentation for cuDF's Datetime APIs. It includes a Doxygen directive to generate API documentation from code comments and organizes content into a table of contents with references to datetime extraction and computation sub-pages.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/datetime_apis.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: datetime_apis\n   :members:\n\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n\n   datetime_extract\n   datetime_compute\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project for CUDF Kafka\nDESCRIPTION: Sets up the basic CMake project configuration including version requirements, project name, and included Rapids CMake modules.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/libcudf_kafka/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.30.4 FATAL_ERROR)\n\ninclude(../../cmake/rapids_config.cmake)\ninclude(rapids-cmake)\ninclude(rapids-cpm)\ninclude(rapids-cuda)\ninclude(rapids-export)\ninclude(rapids-find)\n\nproject(\n  CUDF_KAFKA\n  VERSION \"${RAPIDS_VERSION}\"\n  LANGUAGES CXX\n)\n```\n\n----------------------------------------\n\nTITLE: Doxygen Group Declaration for Structs and Classes Documentation\nDESCRIPTION: A reStructuredText directive that tells Doxygen to include documentation for members of the 'structs_classes' group.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/structs_classes.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: structs_classes\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Building Docker Image for cuDF Java Compilation\nDESCRIPTION: Command to build a Docker image with the necessary environment for compiling cuDF Java bindings. It uses a Rocky Linux base image with CUDA 11.8.0 support.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/ci/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker build -f java/ci/Dockerfile.rocky --build-arg CUDA_VERSION=11.8.0 -t cudf-build:11.8.0-devel-rocky8 .\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for cuDF String Find Functions\nDESCRIPTION: This snippet uses a Doxygen directive to generate documentation for all members of the 'strings_find' group in the RAPIDS cuDF library. This group likely contains functions related to searching and finding patterns within strings in GPU-accelerated dataframes.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/strings_find.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: strings_find\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Dictionary Tests with C++\nDESCRIPTION: This snippet organizes tests for dictionary functionalities within CUDF, covering aspects like key encoding and decoding, along with basic dictionary operations. It verifies that dictionary structures behave as expected.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_44\n\nLANGUAGE: cpp\nCODE:\n```\nConfigureTest(\n  DICTIONARY_TEST\n  dictionary/add_keys_test.cpp\n  dictionary/decode_test.cpp\n  dictionary/encode_test.cpp\n  dictionary/factories_test.cpp\n  dictionary/fill_test.cpp\n  dictionary/gather_test.cpp\n  dictionary/remove_keys_test.cpp\n  dictionary/scatter_test.cpp\n  dictionary/search_test.cpp\n  dictionary/set_keys_test.cpp\n  dictionary/slice_test.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Arrow Dependency for Tests\nDESCRIPTION: Sets up the Arrow library dependency for the cuDF tests. The configuration excludes Arrow from the installation when only test executables are shipped.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# No need to install Arrow libs when only the final test executables are shipped.\nset(CUDF_EXCLUDE_ARROW_FROM_ALL ON)\ninclude(../cmake/thirdparty/get_arrow.cmake)\n```\n\n----------------------------------------\n\nTITLE: Documenting String Containment Functions in cuDF (C++)\nDESCRIPTION: This code snippet uses Doxygen to generate documentation for the 'strings_contains' group of functions in cuDF. It will include all members of this group in the generated documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/strings_contains.rst#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n.. doxygengroup:: strings_contains\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring I/O Tests for Various File Formats in CMake\nDESCRIPTION: Sets up comprehensive tests for I/O operations across multiple file formats including CSV, ORC, Parquet, and JSON. Includes tests for compression, row selection, chunked readers/writers, and specialized JSON functionality.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_20\n\nLANGUAGE: CMake\nCODE:\n```\n# ##################################################################################################\n# * io tests --------------------------------------------------------------------------------------\nConfigureTest(COMPRESSION_TEST io/comp/comp_test.cpp)\nConfigureTest(ROW_SELECTION_TEST io/row_selection_test.cpp)\n\nConfigureTest(\n  CSV_TEST io/csv_test.cpp\n  GPUS 1\n  PERCENT 30 EXTRA_LIBS ${ARROW_LIBRARIES}\n)\nConfigureTest(\n  ORC_TEST io/orc_chunked_reader_test.cu io/orc_test.cpp\n  GPUS 1\n  PERCENT 100\n)\nConfigureTest(\n  PARQUET_TEST\n  io/parquet_bloom_filter_test.cu\n  io/parquet_chunked_reader_test.cu\n  io/parquet_chunked_writer_test.cpp\n  io/parquet_common.cpp\n  io/parquet_misc_test.cpp\n  io/parquet_reader_test.cpp\n  io/parquet_test.cpp\n  io/parquet_v2_test.cpp\n  io/parquet_writer_test.cpp\n  GPUS 1\n  PERCENT 30\n)\nConfigureTest(\n  JSON_TEST io/json/json_test.cpp io/json/json_chunked_reader.cu\n  GPUS 1\n  PERCENT 30 EXTRA_LIBS ${ARROW_LIBRARIES}\n)\nConfigureTest(JSON_WRITER_TEST io/json/json_writer.cpp)\nConfigureTest(JSON_TYPE_CAST_TEST io/json/json_type_cast_test.cu)\nConfigureTest(NESTED_JSON_TEST io/json/nested_json_test.cpp io/json/json_tree.cpp)\nConfigureTest(MULTIBYTE_SPLIT_TEST io/text/multibyte_split_test.cpp)\nConfigureTest(JSON_QUOTE_NORMALIZATION io/json/json_quote_normalization_test.cpp)\nConfigureTest(JSON_WHITESPACE_NORMALIZATION io/json/json_whitespace_normalization_test.cu)\nConfigureTest(JSON_TREE_CSR io/json/json_tree_csr.cu)\nConfigureTest(\n  DATA_CHUNK_SOURCE_TEST io/text/data_chunk_source_test.cpp\n  GPUS 1\n  PERCENT 100\n)\ntarget_link_libraries(DATA_CHUNK_SOURCE_TEST PRIVATE ZLIB::ZLIB)\nConfigureTest(LOGICAL_STACK_TEST io/fst/logical_stack_test.cu)\nConfigureTest(FST_TEST io/fst/fst_test.cu)\nConfigureTest(TYPE_INFERENCE_TEST io/type_inference_test.cu)\n```\n\n----------------------------------------\n\nTITLE: Configuring Doxygen Documentation for cuDF Dictionary Update API\nDESCRIPTION: Uses ReStructuredText directives to configure the Doxygen documentation for the dictionary_update group members in cuDF. This snippet instructs Doxygen to generate documentation for all members of the dictionary_update group.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/dictionary_update.rst#2025-04-21_snippet_0\n\nLANGUAGE: ReStructuredText\nCODE:\n```\n.. doxygengroup:: dictionary_update\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Setting CUDA Runtime Library Type\nDESCRIPTION: Configures whether to use static or shared CUDA runtime library based on CUDA_STATIC_RUNTIME flag. Default behavior favors dynamic linking for Python ecosystem compatibility.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/src/main/native/CMakeLists.txt#2025-04-21_snippet_12\n\nLANGUAGE: cmake\nCODE:\n```\nif(CUDA_STATIC_RUNTIME)\n  # Tell CMake what CUDA language runtime to use\n  set_target_properties(cudfjni PROPERTIES CUDA_RUNTIME_LIBRARY Static)\nelse()\n  # Tell CMake what CUDA language runtime to use\n  set_target_properties(cudfjni PROPERTIES CUDA_RUNTIME_LIBRARY Shared)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Search Test with C++\nDESCRIPTION: This snippet sets up the search tests in CUDF, indicating the source files involved in testing different search-related functionalities. It includes a varied set of tests to validate searching in different structures.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_33\n\nLANGUAGE: cpp\nCODE:\n```\nConfigureTest(\n  SEARCH_TEST search/search_dictionary_test.cpp search/search_list_test.cpp\n  search/search_struct_test.cpp search/search_test.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Documenting Jaccard Module\nDESCRIPTION: This snippet utilizes the Sphinx `automodule` directive to automatically generate documentation for the `pylibcudf.nvtext.jaccard` module. The `:members:` option ensures that all members of the module are included in the generated documentation. This facilitates easy access to documentation of functions related to Jaccard Index calculations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/api_docs/nvtext/jaccard.rst#2025-04-21_snippet_0\n\nLANGUAGE: Sphinx\nCODE:\n```\n.. automodule:: pylibcudf.nvtext.jaccard\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Evaluating I/O Supported Datatypes Table\nDESCRIPTION: Defines a ReStructuredText (ReST) table that indicates compatibility between cuDF data types and different I/O formats like CSV, Parquet, and JSON. It categorizes data types into int, uint, float, bool, and others, marking their compatibility for reading and writing operations across various formats. This is primarily used for documentation purposes and requires a ReST compatible environment.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/io/io.md#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. table::\n    :class: io-supported-types-table special-table\n    :widths: 15 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10\n\n    +-----------------------+--------+--------+--------+--------+---------+--------+--------+--------+--------+-------------------+--------+--------+---------+---------+\n    |                       |       CSV       |      Parquet    |       JSON       |       ORC       |  AVRO  |        HDF        |       DLPack    |      Feather      |\n    +-----------------------+--------+--------+--------+--------+---------+--------+--------+--------+--------+---------+---------+--------+--------+---------+---------+\n    | Data Type             | Writer | Reader | Writer | Reader | Writer\\u00b9 | Reader | Writer | Reader | Reader | Writer\\u00b2 | Reader\\u00b2 | Writer | Reader | Writer\\u00b2 | Reader\\u00b2 |\n    +=======================+========+========+========+========+=========+========+========+========+========+=========+=========+========+========+=========+=========+\n    | int8                  | \\u2705     | \\u2705     | \\u2705     | \\u2705     | \\u2705      | \\u2705     | \\u2705     | \\u2705     | \\u2705     | \\u2705      | \\u2705      | \\u2705     | \\u2705     | \\u2705      | \\u2705      |\n    +-----------------------+--------+--------+--------+--------+---------+--------+--------+--------+--------+---------+---------+--------+--------+---------+---------+\n    | int16                 | \\u2705     | \\u2705     | \\u2705     | \\u2705     | \\u2705      | \\u2705     | \\u2705     | \\u2705     | \\u2705     | \\u2705      | \\u2705      | \\u2705     | \\u2705     | \\u2705      | \\u2705      |\n    +-----------------------+--------+--------+--------+--------+---------+--------+--------+--------+--------+---------+---------+--------+--------+---------+---------+\n    | int32                 | \\u2705     | \\u2705     | \\u2705     | \\u2705     | \\u2705      | \\u2705     | \\u2705     | \\u2705     | \\u2705     | \\u2705      | \\u2705      | \\u2705     | \\u2705     | \\u2705      | \\u2705      |\n    +-----------------------+--------+--------+--------+--------+---------+--------+--------+--------+--------+---------+---------+--------+--------+---------+---------+\n    | int64                 | \\u2705     | \\u2705     | \\u2705     | \\u2705     | \\u2705      | \\u2705     | \\u2705     | \\u2705     | \\u2705     | \\u2705      | \\u2705      | \\u2705     | \\u2705     | \\u2705      | \\u2705      |\n    +-----------------------+--------+--------+--------+--------+---------+--------+--------+--------+--------+---------+---------+--------+--------+---------+---------+\n    | uint8                 | \\u2705     | \\u2705     | \\u2705     | \\u2705     | \\u2705      | \\u2705     | \\u274c     | \\u2705     | \\u274c     | \\u2705      | \\u2705      | \\u2705     | \\u2705     | \\u2705      | \\u2705      |\n    +-----------------------+--------+--------+--------+--------+---------+--------+--------+--------+--------+---------+---------+--------+--------+---------+---------+\n    | uint16                | \\u2705     | \\u2705     | \\u2705     | \\u2705     | \\u2705      | \\u2705     | \\u274c     | \\u2705     | \\u274c     | \\u2705      | \\u2705      | \\u2705     | \\u2705     | \\u2705      | \\u2705      |\n    +-----------------------+--------+--------+--------+--------+---------+--------+--------+--------+--------+---------+---------+--------+--------+---------+---------+\n    | uint32                | \\u2705     | \\u2705     | \\u2705     | \\u2705     | \\u2705      | \\u2705     | \\u274c     | \\u2705     | \\u274c     | \\u2705      | \\u2705      | \\u2705     | \\u2705     | \\u2705      | \\u2705      |\n    +-----------------------+--------+--------+--------+--------+---------+--------+--------+--------+--------+---------+---------+--------+--------+---------+---------+\n    | uint64                | \\u2705     | \\u2705     | \\u2705     | \\u2705     | \\u2705      | \\u2705     | \\u274c     | \\u274c     | \\u274c     | \\u2705      | \\u2705      | \\u2705     | \\u2705     | \\u2705      | \\u2705      |\n    +-----------------------+--------+--------+--------+--------+---------+--------+--------+--------+--------+---------+---------+--------+--------+---------+---------+\n    | float32               | \\u2705     | \\u2705     | \\u2705     | \\u2705     | \\u2705      | \\u2705     | \\u2705     | \\u2705     | \\u2705     | \\u2705      | \\u2705      | \\u2705     | \\u2705     | \\u2705      | \\u2705      |\n    +-----------------------+--------+--------+--------+--------+---------+--------+--------+--------+--------+---------+---------+--------+--------+---------+---------+\n    | float64               | \\u2705     | \\u2705     | \\u2705     | \\u2705     | \\u2705      | \\u2705     | \\u2705     | \\u2705     | \\u2705     | \\u2705      | \\u2705      | \\u2705     | \\u2705     | \\u2705      | \\u2705      |\n    ...(truncated for brevity)\n```\n\n----------------------------------------\n\nTITLE: Creating Table of Contents for NVText API Documentation in reStructuredText\nDESCRIPTION: This snippet creates a table of contents for the NVText API documentation, setting the maximum depth to 2 levels and providing a caption. It lists various NVText functionalities as separate documentation pages.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/nvtext_apis.rst#2025-04-21_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n\n   nvtext_ngrams\n   nvtext_normalize\n   nvtext_stemmer\n   nvtext_edit_distance\n   nvtext_tokenize\n   nvtext_replace\n   nvtext_minhash\n   nvtext_jaccard\n```\n\n----------------------------------------\n\nTITLE: Configuring Cython Sources and Dependencies for cuDF JSON Module\nDESCRIPTION: Configures CMake build settings for Cython modules related to JSON handling in cuDF. Specifies source files, links against the cuDF library, and creates modules with specific prefixes using the RAPIDS Cython creation utility.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/pylibcudf/libcudf/io/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(cython_sources json.pyx types.pyx)\n\nset(linked_libraries cudf::cudf)\n\nrapids_cython_create_modules(\n  CXX\n  SOURCE_FILES \"${cython_sources}\"\n  LINKED_LIBRARIES \"${linked_libraries}\" ASSOCIATED_TARGETS cudf MODULE_PREFIX cpp_io_\n)\n```\n\n----------------------------------------\n\nTITLE: Doxygen Documentation Group Declaration for Lists Modification\nDESCRIPTION: RST directive that generates documentation for the lists_modify group members using Doxygen. This documents the API functions related to modifying list-type columns in CUDF.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/lists_modify.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: lists_modify\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Modifying fillna Behavior for datetime/timedelta in cuDF (Python)\nDESCRIPTION: The fillna function now preserves the original resolution when filling datetime/timedelta Series with a lower-resolution scalar. This snippet shows the old and new behavior of the function.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/pandas-2.0-breaking-changes.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nIn [22]: sr = cudf.Series([1000000, 200000, None], dtype='timedelta64[s]')\n\nIn [23]: sr\nOut[23]:\n0    11 days 13:46:40\n1     2 days 07:33:20\n2                <NA>\ndtype: timedelta64[s]\n\nIn [24]: sr.fillna(np.timedelta64(1,'ms'))\nOut[24]:\n0       11 days 13:46:40\n1        2 days 07:33:20\n2    0 days 00:00:00.001\ndtype: timedelta64[ms]\n```\n\nLANGUAGE: python\nCODE:\n```\nIn [24]: sr.fillna(np.timedelta64(1,'ms'))\nOut[24]:\n0    11 days 13:46:40\n1     2 days 07:33:20\n2     0 days 00:00:00\ndtype: timedelta64[s]\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for cuDF Strings Regex Group\nDESCRIPTION: This reStructuredText directive instructs Doxygen to generate documentation for all members of the 'strings_regex' group in the cuDF library. It creates a section titled 'Strings Regex' and includes detailed documentation for each function in this group.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/strings_regex.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: strings_regex\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Creating Table of Contents for Dictionary API Documentation in reStructuredText\nDESCRIPTION: Configures a table of contents for the dictionary API documentation, setting the depth to 2 levels and providing a caption. It includes links to separate pages for dictionary encoding, searching, and updating operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/dictionary_apis.rst#2025-04-21_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n\n   dictionary_encode\n   dictionary_search\n   dictionary_update\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for cuDF Strings Extract Group\nDESCRIPTION: This snippet uses a Doxygen directive to generate documentation for the strings_extract group in cuDF. It includes all members of the group in the generated output.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/strings_extract.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: strings_extract\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Detecting if cudf.pandas is Active\nDESCRIPTION: Shows how to verify that cudf.pandas is active by importing pandas after loading the cudf.pandas extension and examining the module output, which will indicate it's using the ModuleAccelerator.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/faq.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%load_ext cudf.pandas\nimport pandas as pd\n\nprint(pd)\n<module 'pandas' (ModuleAccelerator(fast=cudf, slow=pandas))>\n```\n\n----------------------------------------\n\nTITLE: Configuring Bin Tests with C++\nDESCRIPTION: This snippet configures tests for bin labeling functionalities in CUDF. It aims to validate correctness in how data is categorized into bins, which is key for analysis tasks.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_48\n\nLANGUAGE: cpp\nCODE:\n```\nConfigureTest(LABEL_BINS_TEST labeling/label_bins_tests.cpp)\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for CUDF Lists Extract Group\nDESCRIPTION: This ReStructuredText directive instructs Doxygen to generate documentation for all members of the 'lists_extract' group in the CUDF library. It's typically used in API documentation to provide detailed information about functions and classes related to list extraction operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/lists_extract.rst#2025-04-21_snippet_0\n\nLANGUAGE: ReStructuredText\nCODE:\n```\n.. doxygengroup:: lists_extract\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Copying Operation Tests in CMake\nDESCRIPTION: Sets up extensive tests for data copying operations including concatenation, copying, gathering, scattering, slicing, splitting, and reversing across various data types and structures.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_22\n\nLANGUAGE: CMake\nCODE:\n```\n# ##################################################################################################\n# * copying tests ---------------------------------------------------------------------------------\nConfigureTest(\n  COPYING_TEST\n  copying/concatenate_tests.cpp\n  copying/copy_if_else_nested_tests.cpp\n  copying/copy_range_tests.cpp\n  copying/copy_tests.cpp\n  copying/detail_gather_tests.cu\n  copying/gather_list_tests.cpp\n  copying/gather_str_tests.cpp\n  copying/gather_struct_tests.cpp\n  copying/gather_tests.cpp\n  copying/get_value_tests.cpp\n  copying/pack_tests.cpp\n  copying/purge_nonempty_nulls_tests.cpp\n  copying/sample_tests.cpp\n  copying/scatter_tests.cpp\n  copying/scatter_list_tests.cpp\n  copying/scatter_list_scalar_tests.cpp\n  copying/scatter_struct_tests.cpp\n  copying/scatter_struct_scalar_tests.cpp\n  copying/segmented_gather_list_tests.cpp\n  copying/shift_tests.cpp\n  copying/slice_tests.cpp\n  copying/split_tests.cpp\n  copying/utility_tests.cpp\n  copying/reverse_tests.cpp\n  GPUS 1\n  PERCENT 70\n)\n```\n\n----------------------------------------\n\nTITLE: RST Doxygen Directive for Datetime Compute Documentation\nDESCRIPTION: Sphinx documentation directive that includes Doxygen-generated documentation for the datetime_compute group with all its members.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/datetime_compute.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: datetime_compute\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Defining the CUDF JNI Library Target\nDESCRIPTION: Creates the main cudfjni library target with all the source files needed for the JNI bindings, including both C++ and CUDA source files.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/src/main/native/CMakeLists.txt#2025-04-21_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(\n  cudfjni\n  src/Aggregation128UtilsJni.cpp\n  src/AggregationJni.cpp\n  src/ChunkedPackJni.cpp\n  src/ChunkedReaderJni.cpp\n  src/CudfJni.cpp\n  src/CudaJni.cpp\n  src/ColumnVectorJni.cpp\n  src/ColumnViewJni.cpp\n  src/ColumnViewJni.cu\n  src/CompiledExpression.cpp\n  src/ContiguousTableJni.cpp\n  src/DataSourceHelperJni.cpp\n  src/HashJoinJni.cpp\n  src/HostMemoryBufferNativeUtilsJni.cpp\n  src/HostUDFWrapperJni.cpp\n  src/NvcompJni.cpp\n  src/NvtxRangeJni.cpp\n  src/NvtxUniqueRangeJni.cpp\n  src/PackedColumnMetadataJni.cpp\n  src/RmmJni.cpp\n  src/ScalarJni.cpp\n  src/TableJni.cpp\n  src/aggregation128_utils.cu\n  src/check_nvcomp_output_sizes.cu\n  src/maps_column_view.cu\n  src/multi_host_buffer_source.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Cython Source Files for cuDF Python Bindings in CMake\nDESCRIPTION: Defines a list of Cython source files that comprise the Python bindings for RAPIDS cuDF. This list includes modules for various DataFrame operations such as aggregation, joining, sorting, and more.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/pylibcudf/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(cython_sources\n    aggregation.pyx\n    binaryop.pyx\n    column.pyx\n    column_factories.pyx\n    contiguous_split.pyx\n    concatenate.pyx\n    copying.pyx\n    datetime.pyx\n    experimental.pyx\n    expressions.pyx\n    filling.pyx\n    gpumemoryview.pyx\n    groupby.pyx\n    hashing.pyx\n    interop.pyx\n    _interop_helpers.pyx\n    jit.pyx\n    join.pyx\n    json.pyx\n    labeling.pyx\n    lists.pyx\n    merge.pyx\n    null_mask.pyx\n    partitioning.pyx\n    quantiles.pyx\n    reduce.pyx\n    replace.pyx\n    reshape.pyx\n    rolling.pyx\n    round.pyx\n    scalar.pyx\n    search.pyx\n    stream_compaction.pyx\n    sorting.pyx\n    table.pyx\n    traits.pyx\n    transform.pyx\n    transpose.pyx\n    types.pyx\n    unary.pyx\n    utils.pyx\n)\n```\n\n----------------------------------------\n\nTITLE: Automatic Module Documentation Generation for MinHash\nDESCRIPTION: Generates automatic documentation for all members of the pylibcudf.nvtext.minhash module using Sphinx automodule directive\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/api_docs/nvtext/minhash.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: pylibcudf.nvtext.minhash\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Standard Benchmark in CUDF with CMake\nDESCRIPTION: A CMake function that configures a standard benchmark executable. It sets up the target properties, links necessary libraries, adds a custom command for benchmark execution, and installs the benchmark binary.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/benchmarks/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(ConfigureBench CMAKE_BENCH_NAME)\n  add_executable(${CMAKE_BENCH_NAME} ${ARGN})\n  set_target_properties(\n    ${CMAKE_BENCH_NAME}\n    PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"$<BUILD_INTERFACE:${CUDF_BINARY_DIR}/benchmarks>\"\n               INSTALL_RPATH \"\\$ORIGIN/../../../lib\"\n               CXX_STANDARD 17\n               CXX_STANDARD_REQUIRED ON\n               # For std:: support of __int128_t. Can be removed once using cuda::std\n               CXX_EXTENSIONS ON\n               CUDA_STANDARD 17\n               CUDA_STANDARD_REQUIRED ON\n  )\n  target_link_libraries(\n    ${CMAKE_BENCH_NAME} PRIVATE cudf_benchmark_common cudf_datagen benchmark::benchmark_main\n                                cudf::cudftestutil_objects $<TARGET_NAME_IF_EXISTS:conda_env>\n  )\n  add_custom_command(\n    OUTPUT CUDF_BENCHMARKS\n    COMMAND ${CMAKE_BENCH_NAME} --benchmark_out_format=json\n            --benchmark_out=results/${CMAKE_BENCH_NAME}.json\n    APPEND\n    COMMENT \"Adding ${CMAKE_BENCH_NAME}\"\n  )\n\n  install(\n    TARGETS ${CMAKE_BENCH_NAME}\n    COMPONENT testing\n    DESTINATION bin/benchmarks/libcudf\n    EXCLUDE_FROM_ALL\n  )\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Generating Lists APIs Documentation with Doxygen in reStructuredText\nDESCRIPTION: This snippet uses Doxygen to generate documentation for the 'lists_apis' group. It includes all members of the group in the generated documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/lists_apis.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: lists_apis\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Defining Cython Sources for NLP Modules in RAPIDS cuDF\nDESCRIPTION: This snippet lists the Cython source files for various NLP functionalities such as byte pair encoding, edit distance calculation, n-gram generation, and tokenization. These files will be compiled into Python modules for use in the cuDF library.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/pylibcudf/nvtext/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(cython_sources\n    byte_pair_encode.pyx\n    edit_distance.pyx\n    generate_ngrams.pyx\n    jaccard.pyx\n    minhash.pyx\n    ngrams_tokenize.pyx\n    normalize.pyx\n    replace.pyx\n    stemmer.pyx\n    tokenize.pyx\n    subword_tokenize.pyx\n    wordpiece_tokenize.pyx\n)\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for Reshape and Transpose Operations in RAPIDS cuDF\nDESCRIPTION: This reStructuredText directive instructs Doxygen to generate documentation for all members of the 'reshape_transpose' group in the RAPIDS cuDF library. It includes API references and details for reshape and transpose operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/reshape_transpose.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: reshape_transpose\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Table of Contents Organization for cuDF Developer Guide\nDESCRIPTION: Defines the table of contents structure for the cuDF developer guide, organizing documentation into sections including library design, contributing guides, documentation, testing, benchmarking, options, and cuDF-pandas comparison.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/index.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{toctree}\n:maxdepth: 2\n\nlibrary_design\ncontributing_guide\ndocumentation\ntesting\nbenchmarking\noptions\ncudf_pandas\n```\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for CuDF Aggregation Module\nDESCRIPTION: This snippet uses Sphinx's automodule directive to automatically generate documentation for all members of the pylibcudf.aggregation module. This includes classes, functions, and other objects defined in the module.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/api_docs/aggregation.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: pylibcudf.aggregation\n   :members:\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Block for Dictionary Classes\nDESCRIPTION: Sphinx/RST directive to generate documentation for dictionary-related classes using Doxygen groups. The directive includes all members of the dictionary_classes group.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/dictionary_classes.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: dictionary_classes\n   :members:\n```\n\n----------------------------------------\n\nTITLE: RST Doxygen Directive for String Slice Documentation\nDESCRIPTION: RST directive that generates documentation for the strings_slice group and all its members using Doxygen.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/strings_slice.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: strings_slice\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Cython Sources and Dependencies for cuDF I/O Modules in CMake\nDESCRIPTION: Defines the list of Cython source files for various file formats (Avro, CSV, JSON, ORC, Parquet, etc.) and specifies the library dependencies for building the Python bindings. Uses the rapids_cython_create_modules function to generate the necessary build targets with appropriate prefixes and associations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/pylibcudf/io/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(cython_sources avro.pyx csv.pyx datasource.pyx json.pyx orc.pyx parquet.pyx\n                   parquet_metadata.pyx text.pyx timezone.pyx types.pyx\n)\n\nset(linked_libraries cudf::cudf)\nrapids_cython_create_modules(\n  CXX\n  SOURCE_FILES \"${cython_sources}\"\n  LINKED_LIBRARIES \"${linked_libraries}\" MODULE_PREFIX pylibcudf_io_ ASSOCIATED_TARGETS cudf\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Doxygen Group for Dictionary APIs in reStructuredText\nDESCRIPTION: Sets up a Doxygen group for dictionary APIs, displaying all members of the group. This directive is used to generate API documentation for the dictionary-related functions in cuDF.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/dictionary_apis.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: dictionary_apis\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Strings Test with C++\nDESCRIPTION: This snippet organizes tests that validate string operations within CUDF, covering a wide array of functionalities related to string processing. It scrutinizes core string handling capabilities across diverse scenarios.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_38\n\nLANGUAGE: cpp\nCODE:\n```\nConfigureTest(\n  STRINGS_TEST\n  strings/array_tests.cpp\n  strings/attrs_tests.cpp\n  strings/booleans_tests.cpp\n  strings/case_tests.cpp\n  strings/chars_types_tests.cpp\n  strings/combine/concatenate_tests.cpp\n  strings/combine/join_list_elements_tests.cpp\n  strings/combine/join_strings_tests.cpp\n  strings/concatenate_tests.cpp\n  strings/contains_tests.cpp\n  strings/datetime_tests.cpp\n  strings/durations_tests.cpp\n  strings/extract_tests.cpp\n  strings/factories_test.cu\n  strings/fill_tests.cpp\n  strings/findall_tests.cpp\n  strings/find_tests.cpp\n  strings/find_multiple_tests.cpp\n  strings/fixed_point_tests.cpp\n  strings/floats_tests.cpp\n  strings/format_lists_tests.cpp\n  strings/integers_tests.cpp\n  strings/ipv4_tests.cpp\n  strings/like_tests.cpp\n  strings/pad_tests.cpp\n  strings/repeat_strings_tests.cpp\n  strings/replace_regex_tests.cpp\n  strings/replace_tests.cpp\n  strings/reverse_tests.cpp\n  strings/slice_tests.cpp\n  strings/split_tests.cpp\n  strings/strip_tests.cpp\n  strings/translate_tests.cpp\n  strings/urls_tests.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Doxygen Documentation for Copy Scatter Module\nDESCRIPTION: RST directive to generate documentation for the copy_scatter module members using Doxygen. This directive tells Doxygen to extract and format the documentation for all members in the copy_scatter group.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/copy_scatter.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: copy_scatter\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Filling Test with C++\nDESCRIPTION: This snippet configures the filling tests for CUDF, specifying the source files related to filling functionalities to be tested. It is part of a testing setup which ensures that various filling operations function correctly.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_32\n\nLANGUAGE: cpp\nCODE:\n```\nConfigureTest(\n  FILLING_TEST filling/fill_tests.cpp filling/repeat_tests.cpp filling/sequence_tests.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Set Target Compile Definitions\nDESCRIPTION: This snippet sets compile definitions for the `cudf` target based on the compile language (CXX or CUDA). It uses the `target_compile_definitions` function to define different preprocessor macros for C++ and CUDA compilation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_17\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_definitions(\n  cudf PUBLIC \"<$<COMPILE_LANGUAGE:CXX>:${CUDF_CXX_DEFINITIONS}>\"\n              \"$<BUILD_INTERFACE:$<$<COMPILE_LANGUAGE:CUDA>:${CUDF_CUDA_DEFINITIONS}>>\"\n)\n```\n\n----------------------------------------\n\nTITLE: Setting up Doxygen documentation for cuDF aggregation factories in RST\nDESCRIPTION: This RST directive configures Doxygen to generate documentation for the 'aggregation_factories' group, including all its member functions. The snippet is used in Sphinx documentation to include C++ API references.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/aggregation_factories.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: aggregation_factories\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Sort Benchmarks in CMake\nDESCRIPTION: Configures compilation settings for sorting and ranking benchmarks, including both standard and NVBench variants.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/benchmarks/CMakeLists.txt#2025-04-21_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nConfigureBench(SORT_BENCH sort/rank.cpp sort/sort.cpp sort/sort_strings.cpp)\nConfigureNVBench(\n  SORT_NVBENCH sort/rank_lists.cpp sort/rank_structs.cpp sort/segmented_sort.cpp\n  sort/sort_lists.cpp sort/sort_structs.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Doxygen Documentation for Lists Contains in cuDF\nDESCRIPTION: Sphinx/Doxygen directive to include documentation for all members of the 'lists_contains' group from the cuDF library. This directive instructs the documentation system to pull in all relevant API documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/lists_contains.rst#2025-04-21_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. doxygengroup:: lists_contains\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Defining Build Options for CUDF JNI\nDESCRIPTION: Sets various build options for the CUDF JNI project, including NVTX support, shared library building, testing, stream handling, and CUDA runtime linking.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/src/main/native/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\noption(USE_NVTX \"Build with NVTX support\" ON)\noption(BUILD_SHARED_LIBS \"Build cuDF JNI shared libraries\" ON)\noption(BUILD_TESTS \"Configure CMake to build tests\" ON)\noption(CUDF_USE_PER_THREAD_DEFAULT_STREAM \"Build with per-thread default stream\" OFF)\noption(CUDA_STATIC_RUNTIME \"Statically link the CUDA runtime\" OFF)\noption(USE_GDS \"Build with GPUDirect Storage (GDS)/cuFile support\" OFF)\noption(CUDF_JNI_LIBCUDF_STATIC \"Link with libcudf.a\" OFF)\noption(CUDF_JNI_ENABLE_PROFILING \"Build with profiling support\" ON)\noption(CUDA_STATIC_CUFILE \"Statically link cuFile\" OFF)\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for Utility Types in cudf\nDESCRIPTION: This reStructuredText directive instructs Doxygen to generate documentation for all members of the 'utility_types' group in the cudf library.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/utility_types.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: utility_types\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for Utility Dispatcher in RAPIDS cuDF\nDESCRIPTION: This reStructuredText directive instructs Doxygen to generate documentation for all members of the 'utility_dispatcher' group in the RAPIDS cuDF project. It creates a section titled 'Utility Dispatcher' in the generated documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/utility_dispatcher.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: utility_dispatcher\n   :members:\n```\n\n----------------------------------------\n\nTITLE: RST Doxygen Group Definition\nDESCRIPTION: Doxygen directive to generate documentation for the strings_split group members\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/strings_split.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: strings_split\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Creating Table of Contents for Lists APIs in reStructuredText\nDESCRIPTION: This snippet creates a table of contents for the Lists APIs documentation. It specifies a maximum depth of 2 and includes various categories of list operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/lists_apis.rst#2025-04-21_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n\n   lists_combine\n   lists_modify\n   lists_extract\n   lists_filling\n   lists_contains\n   lists_gather\n   lists_elements\n   lists_filtering\n   lists_sort\n   set_operations\n```\n\n----------------------------------------\n\nTITLE: Including Doxygen Documentation for Lists Gather Group in cuDF\nDESCRIPTION: Directive to include auto-generated documentation for the 'lists_gather' group from the RAPIDS cuDF library. The directive specifies that all members of this group should be included in the documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/lists_gather.rst#2025-04-21_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. doxygengroup:: lists_gather\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring NVBENCH Benchmark in CUDF with CMake\nDESCRIPTION: A CMake function for configuring NVBENCH-based benchmarks. It sets up the executable with a specified benchmark source and the NVBENCH main fixture, configures target properties, links required libraries, and installs the binary.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/benchmarks/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(ConfigureNVBench CMAKE_BENCH_NAME)\n  add_executable(${CMAKE_BENCH_NAME} ${ARGN} fixture/nvbench_main.cpp)\n  set_target_properties(\n    ${CMAKE_BENCH_NAME}\n    PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"$<BUILD_INTERFACE:${CUDF_BINARY_DIR}/benchmarks>\"\n               INSTALL_RPATH \"\\$ORIGIN/../../../lib\"\n  )\n  target_link_libraries(\n    ${CMAKE_BENCH_NAME}\n    PRIVATE cudf_benchmark_common ndsh_data_generator cudf_datagen nvbench::nvbench\n            $<TARGET_NAME_IF_EXISTS:conda_env> cudf::cudftestutil_objects\n  )\n  install(\n    TARGETS ${CMAKE_BENCH_NAME}\n    COMPONENT testing\n    DESTINATION bin/benchmarks/libcudf\n    EXCLUDE_FROM_ALL\n  )\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Configuring GDB Pretty Printer Script\nDESCRIPTION: Conditionally configures a GDB pretty printer loading script when both Thrust and RMM source directories are available, helping with debugging.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_36\n\nLANGUAGE: CMake\nCODE:\n```\nif(Thrust_SOURCE_DIR AND rmm_SOURCE_DIR)\n  configure_file(scripts/load-pretty-printers.in load-pretty-printers @ONLY)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining doxygen documentation group for Arrow interoperability in cuDF\nDESCRIPTION: This reStructuredText code uses the doxygengroup directive to extract and display all documentation for members in the interop_arrow group, which handles integration between RAPIDS cuDF and Apache Arrow.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/interop_arrow.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: interop_arrow\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Options for cuDF Library\nDESCRIPTION: Defines various build options for the cuDF library including NVTX support, test building, benchmarking, shared libraries, JIT compilation caching, and various optimization flags. These options control the build behavior and features enabled in the library.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\noption(USE_NVTX \"Build with NVTX support\" ON)\noption(BUILD_TESTS \"Configure CMake to build tests\" ON)\noption(BUILD_BENCHMARKS \"Configure CMake to build (google & nvbench) benchmarks\" OFF)\noption(BUILD_SHARED_LIBS \"Build cuDF shared libraries\" ON)\noption(JITIFY_USE_CACHE \"Use a file cache for JIT compiled kernels\" ON)\noption(CUDF_BUILD_TESTUTIL \"Whether to build the test utilities contained in libcudf\" ON)\nmark_as_advanced(CUDF_BUILD_TESTUTIL)\noption(CUDF_USE_PROPRIETARY_NVCOMP \"Download and use NVCOMP with proprietary extensions\" ON)\noption(CUDF_EXPORT_NVCOMP \"Export NVCOMP as a dependency\" ON)\noption(CUDF_LARGE_STRINGS_DISABLED \"Build with large string support disabled\" OFF)\nmark_as_advanced(CUDF_LARGE_STRINGS_DISABLED)\noption(\n  CUDF_USE_PER_THREAD_DEFAULT_STREAM\n  \"Build cuDF with per-thread default stream, including passing the per-thread default\n         stream to external libraries.\"\n  OFF\n)\n# Option to add all symbols to the dynamic symbol table in the library file, allowing to retrieve\n# human-readable stacktrace for debugging.\noption(\n  CUDF_BUILD_STACKTRACE_DEBUG\n  \"Replace the current optimization flags by the options '-rdynamic -Og -NDEBUG', useful for debugging with stacktrace retrieval\"\n  OFF\n)\noption(DISABLE_DEPRECATION_WARNINGS \"Disable warnings generated from deprecated declarations.\" OFF)\n# Option to enable line info in CUDA device compilation to allow introspection when profiling /\n# memchecking\noption(CUDA_ENABLE_LINEINFO\n       \"Enable the -lineinfo option for nvcc (useful for cuda-memcheck / profiler)\" OFF\n)\noption(CUDA_WARNINGS_AS_ERRORS \"Enable -Werror=all-warnings for all CUDA compilation\" ON)\n# cudart can be statically linked or dynamically linked. The python ecosystem wants dynamic linking\noption(CUDA_STATIC_RUNTIME \"Statically link the CUDA runtime\" OFF)\n\nset(DEFAULT_CUDF_BUILD_STREAMS_TEST_UTIL ON)\nif(CUDA_STATIC_RUNTIME OR NOT BUILD_SHARED_LIBS)\n  set(DEFAULT_CUDF_BUILD_STREAMS_TEST_UTIL OFF)\nendif()\noption(\n  CUDF_BUILD_STREAMS_TEST_UTIL\n  \"Whether to build the utilities for stream testing contained in libcudf\"\n  ${DEFAULT_CUDF_BUILD_STREAMS_TEST_UTIL}\n)\nmark_as_advanced(CUDF_BUILD_STREAMS_TEST_UTIL)\noption(CUDF_CLANG_TIDY \"Enable clang-tidy during compilation\" OFF)\noption(CUDF_IWYU \"Enable IWYU during compilation\" OFF)\noption(CUDF_CLANG_TIDY_AUTOFIX \"Enable clang-tidy autofixes\" OFF)\n\noption(\n  CUDF_KVIKIO_REMOTE_IO\n  \"Enable remote IO (e.g. AWS S3) support through KvikIO. If disabled, cudf-python will still be able to do remote IO through fsspec.\"\n  ON\n)\n```\n\n----------------------------------------\n\nTITLE: Documenting String Combine Functions using Doxygen RST\nDESCRIPTION: ReStructuredText directive for generating API documentation of the strings_combine group of functions using Doxygen. The directive will include all members of the specified group.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/strings_combine.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: strings_combine\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Scalar Tests in CUDA DataFrame\nDESCRIPTION: Sets up tests for scalar functionality in cuDF. This includes tests for scalar operations and scalar device views using both C++ and CUDA source files.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nConfigureTest(SCALAR_TEST scalar/scalar_test.cpp scalar/scalar_device_view_test.cu)\n```\n\n----------------------------------------\n\nTITLE: Set cuDF Target Properties\nDESCRIPTION: This snippet sets various properties for the `cudf` target, including build and install RPATH, C++ and CUDA standards, visibility presets, position-independent code, and link flags. It configures the target for compilation with specific standards and visibility settings.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\nset_target_properties(\n  cudf\n  PROPERTIES BUILD_RPATH \"\\$ORIGIN\"\n             INSTALL_RPATH \"\\$ORIGIN\"\n             # set target compile options\n             CXX_STANDARD 17\n             CXX_STANDARD_REQUIRED ON\n             # For std:: support of __int128_t. Can be removed once using cuda::std\n             CXX_EXTENSIONS ON\n             CXX_VISIBILITY_PRESET hidden\n             CUDA_STANDARD 17\n             CUDA_STANDARD_REQUIRED ON\n             CUDA_VISIBILITY_PRESET hidden\n             POSITION_INDEPENDENT_CODE ON\n             INTERFACE_POSITION_INDEPENDENT_CODE ON\n             LINK_FLAGS \"-Wl,--exclude-libs,libzstd.a\"\n)\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Include for CUDF Rolling Aggregation\nDESCRIPTION: ReStructuredText directive to include Doxygen documentation for the aggregation_rolling group members.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/aggregation_rolling.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: aggregation_rolling\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Column Tests in CUDA DataFrame\nDESCRIPTION: Sets up tests for the column functionality in cuDF. This includes tests for bit casting, column device views, column views, and compound columns using both C++ and CUDA source files.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nConfigureTest(\n  COLUMN_TEST\n  column/bit_cast_test.cpp\n  column/column_device_view_test.cu\n  column/column_test.cpp\n  column/column_view_device_span_test.cpp\n  column/column_view_shallow_test.cpp\n  column/compound_test.cu\n)\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for Nvtext Minhash in reStructuredText\nDESCRIPTION: This snippet uses reStructuredText to create a documentation page for the Nvtext Minhash functionality. It defines a section title and uses a Doxygen directive to include all members of the nvtext_minhash group.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/nvtext_minhash.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\nNvtext Minhash\n==============\n\n.. doxygengroup:: nvtext_minhash\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Setting CUDF JNI Project Configuration\nDESCRIPTION: Configures the CUDF_JNI project with version information from RAPIDS_VERSION and enables C, C++, and CUDA language support.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/src/main/native/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nproject(\n  CUDF_JNI\n  VERSION \"${RAPIDS_VERSION}\"\n  LANGUAGES C CXX CUDA\n)\n```\n\n----------------------------------------\n\nTITLE: Doxygen Documentation Directive for reorder_partition in cuDF\nDESCRIPTION: This restructuredtext directive instructs Doxygen to generate documentation for all members of the 'reorder_partition' group in the cuDF library. The directive includes all members of the specified group.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/reorder_partition.rst#2025-04-21_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. doxygengroup:: reorder_partition\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Set cuDF Version Compile Definition\nDESCRIPTION: This snippet sets the `CUDF_VERSION` compile definition for the `src/io/parquet/writer_impl.cu` source file. This allows the source file to access the project version during compilation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\nset_property(\n  SOURCE src/io/parquet/writer_impl.cu\n  APPEND\n  PROPERTY COMPILE_DEFINITIONS \"CUDF_VERSION=${PROJECT_VERSION}\"\n)\n```\n\n----------------------------------------\n\nTITLE: Sphinx Directive for cuDF Lists Combine Documentation\nDESCRIPTION: A reStructuredText directive that imports and displays the documentation for the 'lists_combine' group from cuDF. This directive instructs Sphinx to use Doxygen to generate documentation for all members in this group.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/lists_combine.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: lists_combine\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Documenting Datetime Extraction Functions in cuDF using Doxygen\nDESCRIPTION: ReStructuredText directive that includes the documentation for all members of the datetime_extract group from Doxygen. This generates API reference documentation for date/time component extraction functions.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/datetime_extract.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: datetime_extract\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Generating Architecture-Specific PTX Files\nDESCRIPTION: Creates CUDA PTX files for different architectures by configuring and building architecture-specific shim libraries.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf/udf_cpp/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nset(SHIM_CUDA_FLAGS --expt-relaxed-constexpr -rdc=true)\n\nforeach(arch IN LISTS CMAKE_CUDA_ARCHITECTURES)\n  set(tgt shim_${arch})\n\n  add_library(${tgt} OBJECT shim.cu)\n\n  set_target_properties(${tgt} PROPERTIES CUDA_ARCHITECTURES ${arch} CUDA_PTX_COMPILATION ON)\n\n  target_include_directories(\n    ${tgt} PUBLIC \"$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/strings/include>\"\n  )\n  target_compile_options(${tgt} PRIVATE \"$<$<COMPILE_LANGUAGE:CUDA>:${SHIM_CUDA_FLAGS}>\")\n  target_link_libraries(${tgt} PUBLIC cudf::cudf)\n\n  install(\n    FILES $<TARGET_OBJECTS:${tgt}>\n    DESTINATION cudf/core/udf/\n    RENAME ${tgt}.ptx\n  )\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Defining Column Transformation Documentation Structure with RST\nDESCRIPTION: Sets up a documentation page for CUDF column transformations using reStructuredText. It creates a Doxygen group reference and a table of contents linking to various transformation subtopics.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/column_transformation.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\nColumn Transformation\n=====================\n\n.. doxygengroup:: column_transformation\n   :members:\n\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n\n   transformation_unaryops\n   transformation_binaryops\n   transformation_transform\n   transformation_replace\n   transformation_fill\n```\n\n----------------------------------------\n\nTITLE: Set Target Compile Options\nDESCRIPTION: This snippet sets compile options for the `cudf` target based on the compile language (CXX or CUDA). It uses the `target_compile_options` function to apply different flags for C++ and CUDA compilation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_14\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_options(\n  cudf PRIVATE \"<$<COMPILE_LANGUAGE:CXX>:${CUDF_CXX_FLAGS}>\"\n               \"<$<COMPILE_LANGUAGE:CUDA>:${CUDF_CUDA_FLAGS}>\"\n)\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for lists_filling Group in RST\nDESCRIPTION: This RST directive instructs Doxygen to generate documentation for all members of the lists_filling group. It's used to create API documentation for the cuDF library's list filling functions.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/lists_filling.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: lists_filling\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Installing cuDF Testing Components\nDESCRIPTION: Conditionally installs cuDF testing utility targets if they are available. Sets up export string components for later use in rapids_export command.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_29\n\nLANGUAGE: CMake\nCODE:\n```\nset(_components_export_string)\nif(TARGET cudftestutil)\n  install(\n    TARGETS cudftest_default_stream cudftestutil cudftestutil_impl\n    DESTINATION ${lib_dir}\n    EXPORT cudf-testing-exports\n  )\n  set(_components_export_string COMPONENTS testing COMPONENTS_EXPORT_SET cudf-testing-exports)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for Transformation Binaryops in cuDF\nDESCRIPTION: This reStructuredText snippet sets up a Doxygen documentation section for the transformation_binaryops group in cuDF. It uses the doxygengroup directive to include all members of this group in the generated documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/transformation_binaryops.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: transformation_binaryops\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Partitioning Tests in CUDA DataFrame\nDESCRIPTION: Sets up tests for data partitioning in cuDF. This includes hash partitioning, round-robin partitioning, and general partition testing. The configuration specifies to use 1 GPU and allocate 70% of test resources.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\nConfigureTest(\n  PARTITIONING_TEST partitioning/hash_partition_test.cpp partitioning/round_robin_test.cpp\n  partitioning/partition_test.cpp\n  GPUS 1\n  PERCENT 70\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Doxygen Documentation for nvtext_ngrams Module\nDESCRIPTION: A reStructuredText directive that specifies how to generate documentation for the nvtext_ngrams module. It uses the Doxygen directive to include all members of the nvtext_ngrams group.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/nvtext_ngrams.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: nvtext_ngrams\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Fixed Point Tests in CUDA DataFrame\nDESCRIPTION: Sets up tests for fixed-point numeric operations in cuDF using both C++ and CUDA source files to test fixed-point arithmetic and related functionality.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_15\n\nLANGUAGE: CMake\nCODE:\n```\nConfigureTest(FIXED_POINT_TEST fixed_point/fixed_point_tests.cpp fixed_point/fixed_point_tests.cu)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Library Dependencies and Creating Cython Modules in CMake\nDESCRIPTION: Specifies the C++ cuDF library as a dependency and uses the RAPIDS CMake helper to create Cython modules with appropriate linkage and naming conventions.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/pylibcudf/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(linked_libraries cudf::cudf)\nrapids_cython_create_modules(\n  CXX\n  SOURCE_FILES \"${cython_sources}\"\n  LINKED_LIBRARIES \"${linked_libraries}\" MODULE_PREFIX pylibcudf_ ASSOCIATED_TARGETS cudf\n)\n```\n\n----------------------------------------\n\nTITLE: Doxygen Directive for copy_slice Documentation in cuDF\nDESCRIPTION: A reStructuredText directive that instructs Doxygen to generate API documentation for all members in the 'copy_slice' group of the RAPIDS cuDF library.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/copy_slice.rst#2025-04-21_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. doxygengroup:: copy_slice\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Building cuDF Java Artifact with GCC Toolset\nDESCRIPTION: Commands to build the cuDF Java artifact using the GCC 11 toolset. It sets the workspace environment variable and runs the build script within the appropriate toolset environment.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/ci/README.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd cudf\nexport WORKSPACE=`pwd`\nscl enable gcc-toolset-11 \"java/ci/build-in-docker.sh\"\n```\n\n----------------------------------------\n\nTITLE: Defining Doxygen Group for JSON Object in reStructuredText\nDESCRIPTION: A reStructuredText directive to generate API documentation for the json_object group in cuDF. This directive instructs Doxygen to include all members of the specified group in the generated documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/json_object.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: json_object\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Documenting Parquet Metadata Module with automodule\nDESCRIPTION: This snippet uses the `automodule` directive to automatically generate documentation for the `pylibcudf.io.parquet_metadata` module. The `:members:` option ensures that all members of the module are included in the documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/api_docs/io/parquet_metadata.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: pylibcudf.io.parquet_metadata\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Strings Processing Benchmarks\nDESCRIPTION: Sets up benchmarks for string operations including case conversion, tokenization, pattern matching, and string manipulation functions.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/benchmarks/CMakeLists.txt#2025-04-21_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\nConfigureNVBench(\n  STRINGS_NVBENCH\n  string/case.cpp\n  string/char_types.cpp\n  string/combine.cpp\n  string/contains.cpp\n  string/convert_datetime.cpp\n  string/convert_durations.cpp\n  string/convert_fixed_point.cpp\n  string/convert_numerics.cpp\n  string/copy.cpp\n  string/copy_if_else.cpp\n  string/copy_range.cpp\n  string/count.cpp\n  string/extract.cpp\n  string/factory.cpp\n  string/filter.cpp\n  string/find.cpp\n  string/find_multiple.cpp\n  string/join_strings.cpp\n  string/lengths.cpp\n  string/like.cpp\n  string/make_strings_column.cu\n  string/repeat_strings.cpp\n  string/replace.cpp\n  string/replace_re.cpp\n  string/reverse.cpp\n  string/slice.cpp\n  string/split.cpp\n  string/split_re.cpp\n  string/translate.cpp\n  string/url_decode.cu\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring nvcomp Library Links\nDESCRIPTION: Links required libraries including CUDF, NVTX3, and nvcomp to the cudfjni target. Handles both direct nvcomp and namespaced nvcomp::nvcomp variants.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/src/main/native/CMakeLists.txt#2025-04-21_snippet_11\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_link_libraries(\n  cudfjni ${CUDF_LINK} PRIVATE nvtx3::nvtx3-cpp $<TARGET_NAME_IF_EXISTS:nvcomp>\n                               $<TARGET_NAME_IF_EXISTS:nvcomp::nvcomp>\n)\n```\n\n----------------------------------------\n\nTITLE: Note Block for cuDF Developer Guide Scope\nDESCRIPTION: A note block indicating the current scope of the developer guide is limited to the main cuDF library, with potential future expansion to cover related libraries.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/index.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n```{note}\nAt present, this guide only covers the main cuDF library.\nIn the future, it may be expanded to also cover dask_cudf, cudf_kafka, and custreamz.\n```\n```\n\n----------------------------------------\n\nTITLE: Configure Jitify Cache Versioning\nDESCRIPTION: This snippet configures the Jitify cache versioning by setting compile definitions for `src/jit/cache.cpp`. It defines `JITIFY_USE_CACHE` and `CUDF_VERSION` to isolate the cache based on the cuDF version, which avoid cache collisions between different cuDF versions.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_19\n\nLANGUAGE: CMake\nCODE:\n```\nif(JITIFY_USE_CACHE)\n  # Instruct src/jit/cache what version of cudf we are building so it can compute a cal-ver cache\n  # directory. We isolate this definition to the single source so it doesn't effect compiling\n  # caching for all of libcudf\n  set_property(\n    SOURCE src/jit/cache.cpp\n    APPEND\n    PROPERTY COMPILE_DEFINITIONS \"JITIFY_USE_CACHE\" \"CUDF_VERSION=${PROJECT_VERSION}\"\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Doxygen Documentation for cuDF Column Classes in RST\nDESCRIPTION: RST configuration for displaying Doxygen-generated documentation for column classes in the cuDF library, with a table of contents linking to specialized column type documentation pages.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/column_classes.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: column_classes\n   :members:\n\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n\n   column_factories\n   dictionary_classes\n   lists_classes\n   strings_classes\n   structs_classes\n   timestamp_classes\n```\n\n----------------------------------------\n\nTITLE: Creating Kafka Host Test Configuration\nDESCRIPTION: Applies the ConfigureTest function to set up a Kafka host test using the kafka_consumer_tests.cpp source file. This creates an executable test target with all the necessary testing configurations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/libcudf_kafka/tests/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nConfigureTest(KAFKA_HOST_TEST kafka_consumer_tests.cpp)\n```\n\n----------------------------------------\n\nTITLE: Creating Cython Modules for cuDF String Operations\nDESCRIPTION: This snippet uses the rapids_cython_create_modules function to set up the build process for the Cython modules. It specifies the source files, linked libraries, module prefix, and associated targets for the cuDF string operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/pylibcudf/strings/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nrapids_cython_create_modules(\n  CXX\n  SOURCE_FILES \"${cython_sources}\"\n  LINKED_LIBRARIES \"${linked_libraries}\" MODULE_PREFIX pylibcudf_strings_ ASSOCIATED_TARGETS cudf\n)\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for CUDF Transformation Transform Group\nDESCRIPTION: This snippet uses a Sphinx directive to generate documentation for the transformation_transform group in CUDF. It includes all members of the group in the generated documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/transformation_transform.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: transformation_transform\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Unary and Round Tests in CMake\nDESCRIPTION: Configures test executables for unary operations and rounding functions. The unary tests cover math operations, general unary operations, and type casting functionality.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_16\n\nLANGUAGE: CMake\nCODE:\n```\n# * unary tests -----------------------------------------------------------------------------------\nConfigureTest(UNARY_TEST unary/math_ops_test.cpp unary/unary_ops_test.cpp unary/cast_tests.cpp)\n\n# ##################################################################################################\n# * round tests -----------------------------------------------------------------------------------\nConfigureTest(ROUND_TEST round/round_tests.cpp)\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for Transformation Unaryops in reStructuredText\nDESCRIPTION: This snippet uses a Sphinx directive to generate documentation for the 'transformation_unaryops' group from Doxygen comments. It includes all members of the group.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/transformation_unaryops.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: transformation_unaryops\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Maven Build Command\nDESCRIPTION: Basic Maven command to build the Java bindings for CUDF.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/README.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nmvn clean install\n```\n\n----------------------------------------\n\nTITLE: Configuring Doxygen RST Documentation for cuDF I/O Data Sinks\nDESCRIPTION: RST directive to generate Doxygen documentation for the io_datasinks group members. This directive tells Sphinx to include all members of the specified Doxygen group in the generated documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/io_datasinks.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: io_datasinks\n   :members:\n```\n\n----------------------------------------\n\nTITLE: pylibcudf.strings.strip module members\nDESCRIPTION: This snippet represents the documentation directive for the `pylibcudf.strings.strip` module.  It indicates that the members of the module should be included in the generated documentation. No actual code is provided, just the directive to include the module's contents.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/api_docs/strings/strip.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n\n.. automodule:: pylibcudf.strings.strip\n   :members:\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Non-capturing Group in Regex\nDESCRIPTION: Illustrates a non-capturing group which groups the regex without capturing the matched text.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/regex.md#2025-04-21_snippet_12\n\nLANGUAGE: regex\nCODE:\n```\n(?:abc⎮def)ghi\n```\n\n----------------------------------------\n\nTITLE: Code Example in C++\nDESCRIPTION: Example showing how to include C++ code snippets in documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DOCUMENTATION.md#2025-04-21_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n*\n* @code\n* auto result = cudf::make_column( );\n* @endcode\n*\n```\n\n----------------------------------------\n\nTITLE: Installing Stream Testing Utilities\nDESCRIPTION: Conditionally installs stream usage mode detection utilities for cuDF and testing if the CUDF_BUILD_STREAMS_TEST_UTIL option is enabled.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_31\n\nLANGUAGE: CMake\nCODE:\n```\nif(CUDF_BUILD_STREAMS_TEST_UTIL)\n  install(TARGETS cudf_identify_stream_usage_mode_cudf DESTINATION ${lib_dir})\n  install(TARGETS cudf_identify_stream_usage_mode_testing DESTINATION ${lib_dir})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for cuDF String Classes\nDESCRIPTION: This RST directive instructs Doxygen to generate documentation for all members of the 'strings_classes' group in the RAPIDS cuDF library. It includes the full documentation for each member of this group.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/strings_classes.rst#2025-04-21_snippet_0\n\nLANGUAGE: RST\nCODE:\n```\n.. doxygengroup:: strings_classes\n   :members:\n```\n\n----------------------------------------\n\nTITLE: GroupBy DataFrame Setup\nDESCRIPTION: Creates and groups a DataFrame for grouped operations using random data.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/guide-to-udfs.ipynb#2025-04-21_snippet_27\n\nLANGUAGE: python\nCODE:\n```\ndf = randomdata(\n    nrows=10, dtypes={\"a\": float, \"b\": bool, \"c\": str, \"e\": float}, seed=12\n)\ndf.head()\n```\n\nLANGUAGE: python\nCODE:\n```\ngrouped = df.groupby([\"b\"])\n```\n\n----------------------------------------\n\nTITLE: Demonstrating PyTorch compatibility with cuDF pandas proxy arrays (Python)\nDESCRIPTION: This code snippet shows how cuDF pandas proxy arrays can be used with third-party libraries like PyTorch, thanks to the numpy array compatibility approach.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/faq.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport torch\nx = torch.from_numpy(arr)\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for CUDF Utility Span Group\nDESCRIPTION: This reStructuredText snippet uses the doxygengroup directive to generate documentation for all members of the utility_span group in the CUDF project. It creates a section titled 'Utility Span' and includes all members of the specified group.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/utility_span.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\nUtility Span\n============\n\n.. doxygengroup:: utility_span\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Unary Transform Tests in CMake\nDESCRIPTION: Configures tests for data transformation operations including unary transforms, NaN handling, mask operations, bit counting, and one-hot encoding functionality.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_18\n\nLANGUAGE: CMake\nCODE:\n```\n# ##################################################################################################\n# * unary transform tests -------------------------------------------------------------------------\nConfigureTest(\n  TRANSFORM_TEST\n  transform/integration/unary_transform_test.cpp\n  transform/nans_to_null_test.cpp\n  transform/mask_to_bools_test.cpp\n  transform/bools_to_mask_test.cpp\n  transform/row_bit_count_test.cu\n  transform/segmented_row_bit_count_test.cu\n  transform/one_hot_encode_tests.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Lazy Quantifier (+?) in Regex\nDESCRIPTION: Shows the lazy quantifier '+?' which repeats the previous item once or more, matching it only once before trying more matches.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/regex.md#2025-04-21_snippet_5\n\nLANGUAGE: regex\nCODE:\n```\n\".+?\"\n```\n\n----------------------------------------\n\nTITLE: Documentation Structure Definition in RST\nDESCRIPTION: ReStructuredText table of contents tree definition that organizes the libcudf documentation into logical sections covering different APIs and functionalities.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/index.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n\n   cudf_namespace\n   default_stream\n   memory_resource\n   cudf_classes\n   column_apis\n   datetime_apis\n   strings_apis\n   dictionary_apis\n   io_apis\n   json_apis\n   lists_apis\n   nvtext_apis\n   utility_apis\n   labeling_apis\n   expressions\n   tdigest\n```\n\n----------------------------------------\n\nTITLE: Converting CuPy Array to Fortran Contiguous and then to cuDF DataFrame via dlpack\nDESCRIPTION: Converts a CuPy array to a Fortran contiguous array using `cp.asfortranarray` and then creates a cuDF DataFrame from the Fortran contiguous array by leveraging dlpack. Measures the time taken using the cell magic `%%timeit`.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/cupy-interop.ipynb#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n%%timeit\n\nfortran_arr = cp.asfortranarray(reshaped_arr)\nreshaped_df = cudf.from_dlpack(fortran_arr.__dlpack__())\n```\n\n----------------------------------------\n\nTITLE: Configuring Table Tests in CMake\nDESCRIPTION: Sets up tests for table operations including table view functionality, row operations, and experimental row operators.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_28\n\nLANGUAGE: CMake\nCODE:\n```\n# ##################################################################################################\n# * table tests -----------------------------------------------------------------------------------\nConfigureTest(\n  TABLE_TEST\n  table/table_tests.cpp\n  table/table_view_tests.cu\n  table/row_operators_tests.cpp\n  table/experimental_row_operator_tests.cu\n  table/row_operator_tests_utilities.cu\n  table/row_operator_tests_utilities2.cu\n)\n```\n\n----------------------------------------\n\nTITLE: Group Documentation Example\nDESCRIPTION: Example showing how to document group membership for CUDF functions.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DOCUMENTATION.md#2025-04-21_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\nnamespace CUDF_EXPORT cudf {\n\n/**\n * @brief ...\n *\n * @ingroup transformation_fill\n *\n * @param ...\n * @return ...\n */\nstd::unique_ptr<column> fill(table_view const& input,...);\n\n}  // namespace cudf\n```\n\n----------------------------------------\n\nTITLE: Configuring Install-Time Exports for cuDF\nDESCRIPTION: Uses the rapids_export function to define how cuDF targets are exported when installed. Includes namespace setup, documentation, and component handling.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_33\n\nLANGUAGE: CMake\nCODE:\n```\nrapids_export(\n  INSTALL cudf\n  EXPORT_SET cudf-exports ${_components_export_string}\n  GLOBAL_TARGETS cudf cudftestutil cudftestutil_impl\n  NAMESPACE cudf::\n  DOCUMENTATION doc_string\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Doxygen Lists Classes Documentation in RST\nDESCRIPTION: RST directive to generate documentation for all members of the lists_classes group using Doxygen.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/lists_classes.rst#2025-04-21_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. doxygengroup:: lists_classes\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Converting Full Dask-cuDF DataFrame to Pandas\nDESCRIPTION: Demonstrates the less-recommended approach of converting an entire Dask-cuDF DataFrame to pandas. This method has high memory requirements and doesn't leverage GPU acceleration for subsequent operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nddf.compute().to_pandas().head()\n```\n\n----------------------------------------\n\nTITLE: Configuring Doxygen Documentation for cuDF I/O Writers in reStructuredText\nDESCRIPTION: Doxygen directive to generate documentation for the io_writers group and its members in cuDF. This directive instructs the documentation system to include all members of the io_writers group in the generated documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/io_writers.rst#2025-04-21_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. doxygengroup:: io_writers\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Doxygen Documentation for copy_shift Group\nDESCRIPTION: RST directive to include doxygen documentation for the copy_shift group and its members using Sphinx.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/copy_shift.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: copy_shift\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Interop Tests for Arrow and DLPack in CMake\nDESCRIPTION: Sets up tests for interoperability with Arrow and DLPack libraries, covering data structure conversion, host/device transfers, and streaming operations. Includes external library dependencies.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_19\n\nLANGUAGE: CMake\nCODE:\n```\n# ##################################################################################################\n# * interop tests -------------------------------------------------------------------------\nConfigureTest(\n  INTEROP_TEST\n  interop/arrow_data_structures_test.cpp\n  interop/to_arrow_device_test.cpp\n  interop/to_arrow_test.cpp\n  interop/to_arrow_host_test.cpp\n  interop/from_arrow_test.cpp\n  interop/from_arrow_device_test.cpp\n  interop/from_arrow_host_test.cpp\n  interop/from_arrow_stream_test.cpp\n  interop/dlpack_test.cpp\n  EXTRA_LIBS\n  nanoarrow\n  ${ARROW_LIBRARIES}\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a Table of Contents for Utility API Documentation in reStructuredText\nDESCRIPTION: This snippet creates a table of contents for the utility API documentation. It sets the maximum depth to 2 levels and includes links to various utility-related documentation pages.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/utility_apis.rst#2025-04-21_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n\n   utility_types\n   utility_dispatcher\n   utility_bitmask\n   utility_error\n   utility_span\n```\n\n----------------------------------------\n\nTITLE: Copyright License Header for C++ Source Files\nDESCRIPTION: Standard copyright license header that should appear at the beginning of every C++ source file in the libcudf project. The comment should start with /* (not /**) to prevent Doxygen processing.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DOCUMENTATION.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n/*\n * Copyright (c) 2021-2022, NVIDIA CORPORATION.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n```\n\n----------------------------------------\n\nTITLE: Loading cuDF Pandas Extension\nDESCRIPTION: Loads the cuDF extension for pandas compatibility, enabling GPU acceleration for pandas operations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf/cudf_pandas_tests/data/repr_slow_down_test.ipynb#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%load_ext cudf.pandas\n```\n\n----------------------------------------\n\nTITLE: Configuring Traits Test with C++\nDESCRIPTION: This snippet configures tests to validate types and traits within CUDF. By focusing on the specifics of type handling, it assures that the library of types functions correctly.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_35\n\nLANGUAGE: cpp\nCODE:\n```\nConfigureTest(TRAITS_TEST types/traits_test.cpp)\n```\n\n----------------------------------------\n\nTITLE: Configuring CUDF Kafka Installation\nDESCRIPTION: Sets up the installation configuration for the CUDF Kafka library, including targets, headers, and exports.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/libcudf_kafka/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nrapids_cmake_install_lib_dir(lib_dir)\ninstall(\n  TARGETS cudf_kafka\n  DESTINATION ${lib_dir}\n  EXPORT cudf_kafka-exports\n)\n\ninstall(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/include/ DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\n\nrapids_export(\n  INSTALL cudf_kafka\n  EXPORT_SET cudf_kafka-exports\n  GLOBAL_TARGETS cudf_kafka\n  NAMESPACE cudf_kafka::\n)\n\nrapids_export(\n  BUILD cudf_kafka\n  EXPORT_SET cudf_kafka-exports\n  GLOBAL_TARGETS cudf_kafka\n  NAMESPACE cudf_kafka::\n)\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for cuDF Strings Replace Functions\nDESCRIPTION: This snippet uses a Doxygen directive to generate documentation for the 'strings_replace' group of functions in cuDF. It includes all members of the group in the generated documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/strings_replace.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: strings_replace\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Generating JSON API Documentation with Doxygen and Sphinx in reStructuredText\nDESCRIPTION: This snippet sets up the structure for documenting JSON APIs in cuDF using Doxygen and Sphinx. It includes a directive to generate member documentation for the 'json_apis' group and creates a table of contents with a link to the 'json_object' module.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/json_apis.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\nJSON APIs\n=========\n\n.. doxygengroup:: json_apis\n   :members:\n\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n\n   json_object\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for TDigest in cuDF\nDESCRIPTION: This reStructuredText directive generates documentation for all members of the 'tdigest' group using Doxygen. It includes the full API documentation for the TDigest implementation in cuDF.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/tdigest.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: tdigest\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Dispatcher Test with C++\nDESCRIPTION: This snippet configures the dispatcher tests for CUDF, focusing on type dispatching within the library. It ensures that type resolution behaves as expected in various scenarios.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/tests/CMakeLists.txt#2025-04-21_snippet_37\n\nLANGUAGE: cpp\nCODE:\n```\nConfigureTest(DISPATCHER_TEST types/type_dispatcher_test.cu)\n```\n\n----------------------------------------\n\nTITLE: Documenting Exception Throws in CUDF\nDESCRIPTION: Example showing proper format for documenting exceptions using @throw tag in Doxygen comments.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DOCUMENTATION.md#2025-04-21_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n*\n* @throw cudf::logic_error if `input_argument` is negative or zero\n*\n```\n\n----------------------------------------\n\nTITLE: Enable Static Checkers\nDESCRIPTION: This snippet conditionally enables static analysis tools (clang-tidy and IWYU) for the `cudf` target. It uses the `enable_static_checkers` function to perform static analysis, excluding certain files from the analysis.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\nif(CUDF_CLANG_TIDY OR CUDF_IWYU)\n  set(linters)\n  if(CUDF_CLANG_TIDY)\n    list(APPEND linters CLANG_TIDY)\n  endif()\n  if(CUDF_IWYU)\n    list(APPEND linters IWYU)\n  endif()\n  enable_static_checkers(\n    cudf SKIPPED_FILES src/io/comp/cpu_unbz2.cpp src/io/comp/brotli_dict.cpp ${linters}\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing Relocatable Rapids Tests\nDESCRIPTION: Configures installation of the CUDF Kafka tests into a relocatable directory structure. The tests will be installed as part of the 'testing' component set in the bin/gtests/libcudf_kafka directory.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/libcudf_kafka/tests/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nrapids_test_install_relocatable(INSTALL_COMPONENT_SET testing DESTINATION bin/gtests/libcudf_kafka)\n```\n\n----------------------------------------\n\nTITLE: Configuring Doxygen Documentation for cuDF Table Classes in RST\nDESCRIPTION: RST directive that configures Doxygen to generate documentation for all members of the table_classes group in cuDF. Uses the doxygengroup directive to specify the documentation target.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/table_classes.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: table_classes\n   :members:\n```\n\n----------------------------------------\n\nTITLE: ReStructuredText Directive for Column Search Documentation\nDESCRIPTION: RST directive that includes Doxygen-generated documentation for the column_search group members. This directive tells Sphinx to include all members of the column_search documentation group.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/column_search.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: column_search\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Setting Installation Targets in CMake\nDESCRIPTION: Configures the installation destinations for both the compiled deduplication executable and an example JSON file.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/examples/nested_types/CMakeLists.txt#2025-04-21_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(TARGETS deduplication DESTINATION bin/examples/libcudf)\ninstall(FILES ${CMAKE_CURRENT_LIST_DIR}/example.json DESTINATION bin/examples/libcudf)\n```\n\n----------------------------------------\n\nTITLE: Pandas Compatibility List using reStructuredText\nDESCRIPTION: This snippet utilizes the `pandas-compat-list` directive within reStructuredText to create a compatibility list. The directive likely uses a custom extension to query or generate the list from a separate data source, outlining the level of compatibility between cuDF and Pandas.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/PandasCompat.md#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n\n```{eval-rst}\n.. pandas-compat-list::\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Build-Time Exports with Dependencies\nDESCRIPTION: Defines a code block to include testing dependencies and targets when building against cuDF, then configures build-time exports with the rapids_export function.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_34\n\nLANGUAGE: CMake\nCODE:\n```\nset(build_code_string\n    [=[\nif(EXISTS \"${CMAKE_CURRENT_LIST_DIR}/cudf-testing-dependencies.cmake\")\n  include(\"${CMAKE_CURRENT_LIST_DIR}/cudf-testing-dependencies.cmake\")\nendif()\nif(EXISTS \"${CMAKE_CURRENT_LIST_DIR}/cudf-testing-targets.cmake\")\n  include(\"${CMAKE_CURRENT_LIST_DIR}/cudf-testing-targets.cmake\")\nendif()\n]=]\n)\n\nrapids_export(\n  BUILD cudf\n  EXPORT_SET cudf-exports ${_components_export_string}\n  GLOBAL_TARGETS cudf cudftestutil cudftestutil_impl\n  NAMESPACE cudf::\n  DOCUMENTATION doc_string\n  FINAL_CODE_BLOCK build_code_string\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring cudf String Operations Python Modules in CMake\nDESCRIPTION: This CMake snippet sets up the build configuration for cudf string operations Python bindings. It defines the Cython source files (partition.pyx and split.pyx), specifies linking against the cudf library, and uses rapids_cython_create_modules to generate the Python modules with the 'pylibcudf_strings_' prefix.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/pylibcudf/strings/split/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(cython_sources partition.pyx split.pyx)\n\nset(linked_libraries cudf::cudf)\nrapids_cython_create_modules(\n  CXX\n  SOURCE_FILES \"${cython_sources}\"\n  LINKED_LIBRARIES \"${linked_libraries}\" MODULE_PREFIX pylibcudf_strings_ ASSOCIATED_TARGETS cudf\n)\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for CUDF Utility Error Group\nDESCRIPTION: This snippet uses a Doxygen directive to generate documentation for the 'utility_error' group in CUDF. It includes all members of the group in the generated output.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/utility_error.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: utility_error\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Doxygen Group Directive in reStructuredText\nDESCRIPTION: This snippet uses the `doxygengroup` directive in reStructuredText to include documentation generated by Doxygen for the `scalar_factories` group. The `:members:` option includes the members of the group in the documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/scalar_factories.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: scalar_factories\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring CUDF Kafka Library Target\nDESCRIPTION: Defines the main library target for CUDF Kafka, sets up include paths, and configures library dependencies including CUDF and RDKafka.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/libcudf_kafka/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(cudf_kafka SHARED src/kafka_consumer.cpp src/kafka_callback.cpp)\n\ntarget_include_directories(\n  cudf_kafka PUBLIC \"$<BUILD_INTERFACE:${CUDF_KAFKA_SOURCE_DIR}/include>\"\n                    \"$<INSTALL_INTERFACE:include>\"\n)\n\ntarget_link_libraries(cudf_kafka PUBLIC cudf::cudf RDKAFKA::RDKAFKA)\n\nif(TARGET conda_env)\n  target_link_libraries(cudf_kafka PRIVATE conda_env)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Exporting Packages for Static Builds in CUDF CMake Configuration\nDESCRIPTION: Implements a workaround for exporting packages when building static libraries. It exports dependencies like KvikIO, ZLIB, nvcomp, nanoarrow, and zstd for both build and install configurations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/CMakeLists.txt#2025-04-21_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT BUILD_SHARED_LIBS)\n  include(\"${rapids-cmake-dir}/export/find_package_file.cmake\")\n  list(APPEND METADATA_KINDS BUILD INSTALL)\n  list(APPEND dependencies KvikIO ZLIB nvcomp nanoarrow zstd)\n\n  foreach(METADATA_KIND IN LISTS METADATA_KINDS)\n    foreach(dep IN LISTS dependencies)\n      rapids_export_package(${METADATA_KIND} ${dep} cudf-exports)\n    endforeach()\n  endforeach()\n\n  if(TARGET conda_env)\n    install(TARGETS conda_env EXPORT cudf-exports)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Cython Sources and Libraries for CUDF List Operations in CMake\nDESCRIPTION: This CMake snippet defines the Cython source files and linked libraries for CUDF list operations. It then uses a custom Rapids function to create Cython modules with specific settings.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/pylibcudf/libcudf/lists/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(cython_sources combine.pyx contains.pyx)\n\nset(linked_libraries cudf::cudf)\n\nrapids_cython_create_modules(\n  CXX\n  SOURCE_FILES \"${cython_sources}\"\n  LINKED_LIBRARIES \"${linked_libraries}\" ASSOCIATED_TARGETS cudf MODULE_PREFIX cpp_lists\n)\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for cuDF Copying Module in Python\nDESCRIPTION: This code snippet uses Sphinx's automodule directive to automatically generate documentation for the pylibcudf.copying module. It includes all members of the module in the generated documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/api_docs/copying.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n.. automodule:: pylibcudf.copying\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Generating NVTEXT Jaccard Documentation with Doxygen\nDESCRIPTION: RST directive to generate documentation for the nvtext_jaccard module using Doxygen. The directive will include all members of the nvtext_jaccard documentation group.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/nvtext_jaccard.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: nvtext_jaccard\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Cython Sources and Libraries for cudf Kafka Module in CMake\nDESCRIPTION: This snippet sets up the Cython source files and linked libraries for the cudf Kafka module. It then uses the rapids_cython_create_modules function to generate the necessary Cython modules with specified parameters.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_kafka/cudf_kafka/_lib/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(cython_sources kafka.pyx)\nset(linked_libraries cudf_kafka::cudf_kafka)\n\nrapids_cython_create_modules(\n  CXX ASSOCIATED_TARGETS cudf_kafka\n  SOURCE_FILES \"${cython_sources}\"\n  LINKED_LIBRARIES \"${linked_libraries}\"\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Cython Source Files for cuDF String Operations\nDESCRIPTION: This snippet lists all the Cython source files (.pyx) that comprise the cuDF string operations module. These files implement various string manipulation functions such as capitalization, case conversion, pattern matching, and more.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/pylibcudf/strings/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(cython_sources\n    attributes.pyx\n    capitalize.pyx\n    case.pyx\n    char_types.pyx\n    contains.pyx\n    combine.pyx\n    extract.pyx\n    find.pyx\n    find_multiple.pyx\n    findall.pyx\n    padding.pyx\n    regex_flags.pyx\n    regex_program.pyx\n    repeat.pyx\n    replace.pyx\n    replace_re.pyx\n    side_type.pyx\n    slice.pyx\n    strip.pyx\n    translate.pyx\n    wrap.pyx\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents in RST for libcudf Documentation\nDESCRIPTION: This RST code defines the table of contents for the libcudf documentation. It includes links to API documentation, regex information, and Unicode limitations. The maxdepth is set to 2 and a caption is provided.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/index.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n\n   api_docs/index.rst\n   md_regex\n   unicode_limitations\n```\n\n----------------------------------------\n\nTITLE: Configuring Project Settings for Nested Types in CMake\nDESCRIPTION: Defines the project metadata including name, version, and required programming languages (C++ and CUDA).\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/examples/nested_types/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nproject(\n  nested_types\n  VERSION 0.0.1\n  LANGUAGES CXX CUDA\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring CUDA Architecture for Billion Rows Example in CMake\nDESCRIPTION: Sets up the CMake project for billion rows example with CUDA architecture initialization. It defines minimum CMake version requirements and includes configuration for setting CUDA architecture.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/examples/billion_rows/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.30.4 FATAL_ERROR)\n\ninclude(../set_cuda_architecture.cmake)\n\n# initialize cuda architecture\nrapids_cuda_init_architectures(billion_rows)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lazy Quantifier (??) in Regex\nDESCRIPTION: Illustrates the lazy quantifier '??' which makes the preceding item optional, excluding it from the match if possible.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/regex.md#2025-04-21_snippet_3\n\nLANGUAGE: regex\nCODE:\n```\nabc??\n```\n\n----------------------------------------\n\nTITLE: Configuring Linked Libraries for cudf String Conversion Modules\nDESCRIPTION: This snippet sets the linked libraries for the string conversion modules. It specifies that the modules should be linked against the cudf library.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/pylibcudf/strings/convert/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(linked_libraries cudf::cudf)\n```\n\n----------------------------------------\n\nTITLE: Setting Device Debug Symbols in CMake\nDESCRIPTION: Demonstrates how to add device debug symbols to specific CUDA source files by setting the -G compile option in CMakeLists.txt. This allows debugging into kernels in the specified source file using cuda-dbg.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/CONTRIBUTING.md#2025-04-21_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nset_source_files_properties(src/copying/copy.cu PROPERTIES COMPILE_OPTIONS \"-G\")\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Whole Match Backreference in Regex Replacement\nDESCRIPTION: Illustrates the use of ${0} to insert the whole regex match in replacements.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/regex.md#2025-04-21_snippet_15\n\nLANGUAGE: regex\nCODE:\n```\n(\\d)(a)\n```\n\n----------------------------------------\n\nTITLE: Autodocumenting pylibcudf.column Module in Python\nDESCRIPTION: This code snippet uses Sphinx's autodoc extension to automatically generate documentation for the pylibcudf.column module. It includes all members of the module in the generated documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/api_docs/column.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n.. automodule:: pylibcudf.column\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Adding Component Subdirectories to the Build\nDESCRIPTION: Adds additional component subdirectories to the build process, including libcudf core functionality, string operations, I/O functionality, and NVIDIA text processing utilities.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/pylibcudf/pylibcudf/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(libcudf)\nadd_subdirectory(strings)\nadd_subdirectory(io)\nadd_subdirectory(nvtext)\n```\n\n----------------------------------------\n\nTITLE: Autosummary-generated Stub Page Example in reStructuredText\nDESCRIPTION: This snippet shows an example of an autosummary-generated stub page for a specific API (cudf.concat), which uses the autofunction directive to pull the docstring from the actual function.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/documentation.md#2025-04-21_snippet_2\n\nLANGUAGE: restructuredtext\nCODE:\n```\ncudf.concat\n===========\n\n.. currentmodule:: cudf\n\n.. autofunction:: concat\n```\n\n----------------------------------------\n\nTITLE: GDS Build Command\nDESCRIPTION: Maven command to build CUDF with GPUDirect Storage (GDS) support for direct GPU-filesystem transfers.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/README.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ncd src/cudf/java\nmvn clean install -DUSE_GDS=ON\n```\n\n----------------------------------------\n\nTITLE: Adding GPUDirect Storage Support Library\nDESCRIPTION: Conditionally creates and configures the cufilejni library target for GPUDirect Storage (GDS) support when the USE_GDS option is enabled.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/java/src/main/native/CMakeLists.txt#2025-04-21_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nif(USE_GDS)\n  add_library(cufilejni src/CuFileJni.cpp)\n  set_target_properties(\n    cufilejni\n    PROPERTIES BUILD_RPATH \"\\$ORIGIN\"\n               INSTALL_RPATH \"\\$ORIGIN\"\n               # set target compile options\n               CXX_STANDARD 17\n               CXX_STANDARD_REQUIRED ON\n               POSITION_INDEPENDENT_CODE ON\n               INTERFACE_POSITION_INDEPENDENT_CODE ON\n  )\n  target_link_libraries(cufilejni PRIVATE cudfjni CUDA::cuFile${_cufile_suffix})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Documenting Template Parameters in CUDF\nDESCRIPTION: Example showing proper format for documenting template parameters using @tparam tag.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/doxygen/developer_guide/DOCUMENTATION.md#2025-04-21_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n*\n* @tparam functor_type The type of the functor\n* @tparam input_type The datatype of the input argument\n*\n```\n\n----------------------------------------\n\nTITLE: Handling Overloaded Functions in pylibcudf with Cython Fused Types\nDESCRIPTION: Demonstrates how to handle C++ function overloading in Cython using fused types. This allows a single Python function to map to multiple C++ functions based on argument types.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/developer_docs.md#2025-04-21_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nstd::unique_ptr<table> empty_like(table_view const& input_table);\nstd::unique_ptr<column> empty_like(column_view const& input);\n```\n\nLANGUAGE: cython\nCODE:\n```\nctypedef fused ColumnOrTable:\n    Table\n    Column\n\ncpdef ColumnOrTable empty_like(ColumnOrTable input)\n```\n\n----------------------------------------\n\nTITLE: SSH Port Forwarding for Remote Documentation\nDESCRIPTION: Command to set up SSH port forwarding to view remote documentation locally by mapping remote port to local port.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/documentation.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nssh -N -f -L localhost:$LOCAL_PORT:localhost:$REMOTE_PORT $REMOTE_IP\n```\n\n----------------------------------------\n\nTITLE: Including Unicode Limitations Documentation in reStructuredText\nDESCRIPTION: This snippet demonstrates how to include external documentation about Unicode limitations in cuDF. It uses a reStructuredText directive to include a Markdown file and specifies a custom parser for processing the content.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/unicode_limitations.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. include:: ../../../../cpp/doxygen/unicode.md\n   :parser: myst_parser.sphinx_\n```\n\n----------------------------------------\n\nTITLE: Implementing set_rand_params in a Data Handler Class\nDESCRIPTION: Shows how to implement the set_rand_params method in a data handler class to generate random parameter values based on the test data.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf/cudf/_fuzz_testing/tests/readme.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef set_rand_params(self, params):\n    params_dict = {}\n    for param, values in params.items():\n        if values == ALL_POSSIBLE_VALUES:\n            if param == \"columns\":\n                col_size = self._rand(len(self._current_buffer.columns))\n                params_dict[param] = list(\n                    np.unique(\n                        np.random.choice(\n                            self._current_buffer.columns, col_size\n                        )\n                    )\n                )\n            elif param == \"chunksize\":\n                params_dict[param] = np.random.choice(\n                    [\n                        None,\n                        np.random.randint(\n                            low=1, high=max(1, len(self._current_buffer))\n                        ),\n                    ]\n                )\n        else:\n            params_dict[param] = np.random.choice(values)\n    self._current_params[\"test_kwargs\"] = self.process_kwargs(params_dict)\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for reorder_compact Group in reStructuredText\nDESCRIPTION: This snippet uses a Doxygen directive to generate documentation for all members of the reorder_compact group. It's typically used in Sphinx documentation to incorporate API references from source code comments.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/reorder_compact.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: reorder_compact\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Doxygen Group Documentation in RST\nDESCRIPTION: RST directive to include and document all members of the strings_copy Doxygen group\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/strings_copy.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: strings_copy\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Generating Datetime Module Documentation for CuDF\nDESCRIPTION: This snippet uses Sphinx's automodule directive to automatically generate documentation for the datetime module in pylibcudf. It includes all members of the module in the documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/api_docs/datetime.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: pylibcudf.datetime\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Automodule directive for pylibcudf.groupby\nDESCRIPTION: This snippet uses the Sphinx `automodule` directive to automatically generate documentation for the `pylibcudf.groupby` module. The `:members:` option tells Sphinx to include all public members (functions, classes, etc.) of the module in the generated documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/pylibcudf/api_docs/groupby.rst#2025-04-21_snippet_0\n\nLANGUAGE: Sphinx\nCODE:\n```\n\n.. automodule:: pylibcudf.groupby\n   :members:\n\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for nvtext_tokenize in reStructuredText\nDESCRIPTION: This snippet uses the doxygengroup directive to generate API documentation for all members of the nvtext_tokenize group in the RAPIDS cuDF library. It's typically used in Sphinx documentation to include Doxygen-generated content.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/nvtext_tokenize.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: nvtext_tokenize\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Defining String Case Documentation Section in reST\nDESCRIPTION: Sphinx/Doxygen directive to generate documentation for the strings_case group of functions that handle string case transformations.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/strings_case.rst#2025-04-21_snippet_0\n\nLANGUAGE: reST\nCODE:\n```\n.. doxygengroup:: strings_case\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Performing SQL-style Joins with cuDF\nDESCRIPTION: Demonstrates left join between two cuDF DataFrames based on a common key column. The operation matches records from both dataframes where keys are the same, maintaining all rows from the left dataframe.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndf_a = cudf.DataFrame()\ndf_a[\"key\"] = [\"a\", \"b\", \"c\", \"d\", \"e\"]\ndf_a[\"vals_a\"] = [float(i + 10) for i in range(5)]\n\ndf_b = cudf.DataFrame()\ndf_b[\"key\"] = [\"a\", \"c\", \"e\"]\ndf_b[\"vals_b\"] = [float(i + 100) for i in range(3)]\n\nmerged = df_a.merge(df_b, on=[\"key\"], how=\"left\")\nmerged\n```\n\n----------------------------------------\n\nTITLE: RST Doxygen Group Documentation Directive\nDESCRIPTION: Sphinx/RST directive that specifies documentation should be generated for the fixed_point_classes Doxygen group and include all its members.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/fixed_point_classes.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: fixed_point_classes\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Doxygen Group Reference for Lists Sort in RST\nDESCRIPTION: This RST directive configures Sphinx to include documentation for all members of the 'lists_sort' Doxygen group from the RAPIDS cuDF library. The directive automatically imports and formats API documentation from the source code.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/lists_sort.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: lists_sort\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Doxygen directive for nvtext_replace documentation in Sphinx\nDESCRIPTION: This Sphinx directive instructs Doxygen to generate documentation for all members of the 'nvtext_replace' group. It's used to automatically pull in API documentation from the source code into the built documentation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/nvtext_replace.rst#2025-04-21_snippet_0\n\nLANGUAGE: Sphinx\nCODE:\n```\n.. doxygengroup:: nvtext_replace\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Defining Doxygen Documentation Section for cuDF I/O Readers in reStructuredText\nDESCRIPTION: This snippet configures a Doxygen documentation section for the 'io_readers' group in reStructuredText format. It sets up a section header and uses the doxygengroup directive to generate documentation for all members in the io_readers group.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/io_readers.rst#2025-04-21_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\nIo Readers\n==========\n\n.. doxygengroup:: io_readers\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Doxygen Directive for Column Join Documentation in reST\nDESCRIPTION: A reStructuredText directive that instructs Doxygen to generate documentation for all members of the 'column_join' group in the cuDF library. This allows for automatic API documentation generation from source code comments.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/column_join.rst#2025-04-21_snippet_0\n\nLANGUAGE: reST\nCODE:\n```\n.. doxygengroup:: column_join\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for CUDF Strings APIs\nDESCRIPTION: This snippet uses Doxygen to generate documentation for the strings_apis group in CUDF. It includes all members of the group.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/strings_apis.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: strings_apis\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Creating Table of Contents for CUDF Strings API Documentation\nDESCRIPTION: This snippet creates a table of contents for the CUDF strings API documentation, listing various string operation categories as separate pages.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/strings_apis.rst#2025-04-21_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n\n   strings_case\n   strings_types\n   strings_combine\n   strings_contains\n   strings_convert\n   strings_copy\n   strings_slice\n   strings_find\n   strings_modify\n   strings_replace\n   strings_split\n   strings_extract\n   strings_regex\n```\n\n----------------------------------------\n\nTITLE: Creating a Sparse cuDF DataFrame\nDESCRIPTION: Creates a cuDF DataFrame with sparsely populated columns. Each column is filled with a CuPy array containing normally distributed random numbers, where most elements are set to 0.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/cupy-interop.ipynb#2025-04-21_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ndf = cudf.DataFrame()\nnelem = 10000\nnonzero = 1000\nfor i in range(20):\n    arr = cp.random.normal(5, 5, nelem)\n    arr[cp.random.choice(arr.shape[0], nelem - nonzero, replace=False)] = 0\n    df[\"a\" + str(i)] = arr\n```\n\n----------------------------------------\n\nTITLE: Sphinx Documentation Directive for cuDF Fill Transformation\nDESCRIPTION: RST directive to generate documentation for the transformation_fill group members using Doxygen markup\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/transformation_fill.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. doxygengroup:: transformation_fill\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Defining Column Aggregation Documentation Structure in RST\nDESCRIPTION: This RST (reStructuredText) snippet defines the documentation structure for the column_aggregation module. It includes a Doxygen directive to embed API documentation and organizes related topics into a table of contents.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/column_aggregation.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\nColumn Aggregation\n==================\n\n.. doxygengroup:: column_aggregation\n   :members:\n\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n\n   aggregation_factories\n   aggregation_reduction\n   aggregation_groupby\n   aggregation_rolling\n```\n\n----------------------------------------\n\nTITLE: Adding cuDF C++ Source Directory and Configuring Runtime Paths\nDESCRIPTION: Adds the C++ source directory to the build and configures runtime paths when using the nvcomp wheel. Sets install path properties for the cudf target.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/libcudf/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(../../cpp cudf-cpp)\n\nif(USE_NVCOMP_RUNTIME_WHEEL)\n  set(rpaths \"$ORIGIN/../../nvidia/nvcomp\")\n  set_property(\n    TARGET cudf\n    PROPERTY INSTALL_RPATH ${rpaths}\n    APPEND\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting CUDA Compiler Flags and Dependencies\nDESCRIPTION: Configures specific compiler flags for C++ and CUDA compilation, and links against required dependencies.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf/udf_cpp/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset(UDF_CXX_FLAGS)\nset(UDF_CUDA_FLAGS --expt-extended-lambda --expt-relaxed-constexpr)\ntarget_compile_options(\n  cudf_strings_udf PRIVATE \"$<$<COMPILE_LANGUAGE:CXX>:${UDF_CXX_FLAGS}>\"\n                           \"$<$<COMPILE_LANGUAGE:CUDA>:${UDF_CUDA_FLAGS}>\"\n)\ntarget_link_libraries(cudf_strings_udf PUBLIC cudf::cudf)\ninstall(TARGETS cudf_strings_udf DESTINATION ./cudf/_lib/)\n```\n\n----------------------------------------\n\nTITLE: Defining Cudf Classes Documentation Structure in reStructuredText\nDESCRIPTION: This snippet outlines the documentation structure for Cudf classes. It uses Doxygen directives to generate class documentation and creates a table of contents for different class categories.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/cudf_classes.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\nCudf Classes\n============\n\n.. doxygengroup:: cudf_classes\n   :members:\n\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n\n   column_classes\n   table_classes\n   scalar_classes\n   fixed_point_classes\n```\n\n----------------------------------------\n\nTITLE: Setting CUDA Compiler Flags for Billion Rows Example in CMake\nDESCRIPTION: Configures CUDA compiler flags to enable extended lambda expressions and relaxed constexpr evaluation, which are necessary for CUDA kernel development in the billion rows example.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/examples/billion_rows/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nlist(APPEND CUDF_CUDA_FLAGS --expt-extended-lambda --expt-relaxed-constexpr)\n```\n\n----------------------------------------\n\nTITLE: Configuring Deduplication Executable Target in CMake\nDESCRIPTION: Creates and configures the deduplication executable target, linking it against the cuDF library and setting C++17 as the required C++ standard.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/cpp/examples/nested_types/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(deduplication deduplication.cpp)\ntarget_link_libraries(deduplication PRIVATE cudf::cudf)\ntarget_compile_features(deduplication PRIVATE cxx_std_17)\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for CUDF Aggregation Reduction\nDESCRIPTION: This reStructuredText directive instructs Doxygen to generate documentation for all members of the 'aggregation_reduction' group in the CUDF library. It's typically used in Sphinx documentation to include API references.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/aggregation_reduction.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. doxygengroup:: aggregation_reduction\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Defining Documentation Structure in RST\nDESCRIPTION: RestructuredText directives defining the documentation structure for column copy operations, including Doxygen group reference and table of contents.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/api_docs/column_copy.rst#2025-04-21_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\nColumn Copy\n===========\n\n.. doxygengroup:: column_copy\n   :members:\n\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n\n   copy_concatenate\n   copy_gather\n   copy_scatter\n   copy_slice\n   copy_split\n   copy_shift\n```\n\n----------------------------------------\n\nTITLE: Basic Groupby Sum with cuDF\nDESCRIPTION: Groups data by the agg_col1 column and applies the sum function to all other columns, showing how to perform basic aggregation operations on a cuDF DataFrame.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_19\n\nLANGUAGE: python\nCODE:\n```\ndf.groupby(\"agg_col1\").sum()\n```\n\n----------------------------------------\n\nTITLE: Defining Indices and Tables Section in RST for libcudf Documentation\nDESCRIPTION: This RST code defines the Indices and Tables section of the libcudf documentation. It includes links to the general index and search functionality using RST directives.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/libcudf_docs/index.rst#2025-04-21_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n* :ref:`genindex`\n* :ref:`search`\n```\n\n----------------------------------------\n\nTITLE: Debugging cuDF Pandas with Environment Variables\nDESCRIPTION: Examples showing how to use debugging environment variables to detect result differences and control fallback behavior.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/cudf_pandas.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport cudf.pandas\ncudf.pandas.install()\nimport pandas as pd\nimport numpy as np\n\nsetattr(pd.Series.mean, \"_fsproxy_slow\", lambda self, *args, **kwargs: np.float64(1))\ns = pd.Series([1,2,3])\ns.mean()\n```\n\nLANGUAGE: python\nCODE:\n```\nimport cudf.pandas\ncudf.pandas.install()\nimport pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame({\n    'complex_col': [1 + 2j, 3 + 4j, 5 + 6j]\n})\n\nprint(df)\n```\n\n----------------------------------------\n\nTITLE: Reshaping CuPy Array\nDESCRIPTION: Reshapes the CuPy array `cola_cupy` to a 50x200 matrix and stores it into `reshaped_arr`. It relies on the CuPy array `cola_cupy` from the previous snippet.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/user_guide/cupy-interop.ipynb#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nreshaped_arr = cola_cupy.reshape(50, 200)\nreshaped_arr\n```\n\n----------------------------------------\n\nTITLE: Writing Dask-cuDF DataFrame to CSV\nDESCRIPTION: Demonstrates writing a Dask-cuDF DataFrame to a CSV file by first computing it to a cuDF DataFrame and then writing to disk. The index is excluded from the output.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/notebooks/10min.ipynb#2025-04-21_snippet_44\n\nLANGUAGE: python\nCODE:\n```\nddf.compute().to_csv(\"example_output/foo_dask.csv\", index=False)\n```\n\n----------------------------------------\n\nTITLE: Running Fuzz Tests from Command Line\nDESCRIPTION: Shows how to run a fuzz test from the command line by specifying the Python file and the function name to test.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf/cudf/_fuzz_testing/tests/readme.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython write_csv.py your_function_name\n```\n\n----------------------------------------\n\nTITLE: Registering Default Expression Handler for Renaming in Python\nDESCRIPTION: Default handler for all other expression types, which reuses the expression if children remain unchanged after transformation.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf_polars/docs/overview.md#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n_rename.register(Expr)(reuse_if_unchanged)\n```\n\n----------------------------------------\n\nTITLE: Importing cuDF for Benchmarks\nDESCRIPTION: Shows the correct way to import cuDF and CuPy modules for benchmarking to enable pandas comparison functionality.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/benchmarking.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ..common.config import cudf, cupy # Do this\nimport cudf, cupy # Not this\n```\n\n----------------------------------------\n\nTITLE: Serving Documentation with Python HTTP Server\nDESCRIPTION: Command to serve the built documentation using Python's built-in HTTP server. The server automatically finds an available port if 8000 is in use.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/developer_guide/documentation.md#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\npython -m http.server\n```\n\n----------------------------------------\n\nTITLE: Running a Specific CSV Write Test\nDESCRIPTION: Example of running a specific csv_writer_test function from the write_csv.py file.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/python/cudf/cudf/_fuzz_testing/tests/readme.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython write_csv.py csv_writer_test\n```\n\n----------------------------------------\n\nTITLE: Creating Virtual Environment for pandas in Bash\nDESCRIPTION: Creates a virtual environment for pandas using virtualenv.\nSOURCE: https://github.com/rapidsai/cudf/blob/branch-25.06/docs/cudf/source/cudf_pandas/benchmarks.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvirtualenv pandas/py-pandas\n```"
  }
]