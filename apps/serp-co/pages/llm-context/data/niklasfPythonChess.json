[
  {
    "owner": "niklasf",
    "repo": "python-chess",
    "content": "TITLE: Playing Chess with Stockfish using SimpleEngine in Python\nDESCRIPTION: This code snippet demonstrates how to play chess using the Stockfish engine with the SimpleEngine class for synchronous execution. It initializes the engine, plays moves until the game is over, and then quits the engine. The Limit class is used to set a time limit for each move.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/engine.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport chess\nimport chess.engine\n\nengine = chess.engine.SimpleEngine.popen_uci(r\"C:\\Users\\xxxxx\\Downloads\\stockfish_14_win_x64\\stockfish_14_win_x64_avx2.exe\")\n\nboard = chess.Board()\nwhile not board.is_game_over():\n    result = engine.play(board, chess.engine.Limit(time=0.1))\n    board.push(result.move)\n\nengine.quit()\n```\n\n----------------------------------------\n\nTITLE: Exporting a Game to PGN Format in Python\nDESCRIPTION: This code demonstrates how to create a chess game object, add headers and variations (moves and comments), and then print the game in PGN (Portable Game Notation) format. It uses the chess and chess.pgn modules. The output includes headers such as Event, Site, Date, Round, White, Black, and Result, followed by the move list with a comment.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/pgn.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport chess\nimport chess.pgn\n\ngame = chess.pgn.Game()\ngame.headers[\"Event\"] = \"Example\"\nnode = game.add_variation(chess.Move.from_uci(\"e2e4\"))\nnode = node.add_variation(chess.Move.from_uci(\"e7e5\"))\nnode.comment = \"Comment\"\n\nprint(game)\n```\n\n----------------------------------------\n\nTITLE: Analyzing a Chess Position with SimpleEngine in Python\nDESCRIPTION: This code snippet demonstrates how to analyse a chess position using the SimpleEngine class for synchronous execution. It initializes the engine, analyses a board, prints the score, analyses another board with a specified depth, prints the score, and then quits the engine. The Limit class is used to set a time or depth limit for the analysis.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/engine.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport chess\nimport chess.engine\n\nengine = chess.engine.SimpleEngine.popen_uci(\"/usr/bin/stockfish\")\n\nboard = chess.Board()\ninfo = engine.analyse(board, chess.engine.Limit(time=0.1))\nprint(\"Score:\", info[\"score\"])\n# Score: PovScore(Cp(+20), WHITE)\n\nboard = chess.Board(\"r1bqkbnr/p1pp1ppp/1pn5/4p3/2B1P3/5Q2/PPPP1PPP/RNB1K1NR w KQkq - 2 4\")\ninfo = engine.analyse(board, chess.engine.Limit(depth=20))\nprint(\"Score:\", info[\"score\"])\n# Score: PovScore(Mate(+1), WHITE)\n\nengine.quit()\n```\n\n----------------------------------------\n\nTITLE: Analyzing a Chess Position with asyncio in Python\nDESCRIPTION: This example demonstrates asynchronous analysis of chess positions using asyncio. It initializes the engine with popen_uci within an asyncio event loop, analyses a board, prints the score, analyses another board with a specified depth, prints the score, and then quits the engine. The Limit class is used to limit the time or depth of analysis.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/engine.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport chess\nimport chess.engine\n\nasync def main() -> None:\n    transport, engine = await chess.engine.popen_uci(\"/usr/bin/stockfish\")\n\n    board = chess.Board()\n    info = await engine.analyse(board, chess.engine.Limit(time=0.1))\n    print(info[\"score\"])\n    # Score: PovScore(Cp(+20), WHITE)\n\n    board = chess.Board(\"r1bqkbnr/p1pp1ppp/1pn5/4p3/2B1P3/5Q2/PPPP1PPP/RNB1K1NR w KQkq - 2 4\")\n    info = await engine.analyse(board, chess.engine.Limit(depth=20))\n    print(info[\"score\"])\n    # Score: PovScore(Mate(+1), WHITE)\n\n    await engine.quit()\n\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Writing a Game to File in Python\nDESCRIPTION: This code shows how to write a chess game in PGN format to a file.  It uses the `file` argument in the `print` function to specify the output file. The `end` parameter is set to \"\\n\\n\" to separate games in the file with extra blank lines as per PGN standard. The example writes to `/dev/null`.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/pgn.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nprint(game, file=open(\"/dev/null\", \"w\"), end=\"\\n\\n\")\n```\n\n----------------------------------------\n\nTITLE: Indefinite Analysis with asyncio in Python\nDESCRIPTION: This example illustrates indefinite chess engine analysis using asyncio. It initializes the engine and streams analysis information asynchronously. The loop breaks based on an arbitrary condition, specifically when the selective search depth exceeds 20.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/engine.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport chess\nimport chess.engine\n\nasync def main() -> None:\n    transport, engine = await chess.engine.popen_uci(\"/usr/bin/stockfish\")\n\n    with await engine.analysis(chess.Board()) as analysis:\n        async for info in analysis:\n            print(info.get(\"score\"), info.get(\"pv\"))\n\n            # Arbitrary stop condition.\n            if info.get(\"seldepth\", 0) > 20:\n                break\n\n        await engine.quit()\n\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Using the Tablebase Class in Python Chess\nDESCRIPTION: The `chess.syzygy.Tablebase` class provides an interface to query the opened Syzygy tablebase. It contains members that allow access to the WDL and DTZ information for a given position. Ensure that the tablebase files match the known checksums for security.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/syzygy.rst#_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Indefinite Analysis with SimpleEngine in Python\nDESCRIPTION: This snippet showcases indefinite chess engine analysis using SimpleEngine for synchronous execution. It starts an analysis stream and iterates through the information provided by the engine. The analysis is stopped based on an arbitrary condition related to the search depth.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/engine.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport chess\nimport chess.engine\n\nengine = chess.engine.SimpleEngine.popen_uci(\"/usr/bin/stockfish\")\n\nwith engine.analysis(chess.Board()) as analysis:\n    for info in analysis:\n        print(info.get(\"score\"), info.get(\"pv\"))\n\n        # Arbitrary stop condition.\n        if info.get(\"seldepth\", 0) > 20:\n            break\n\nengine.quit()\n```\n\n----------------------------------------\n\nTITLE: Integrating with UCI Engine for Racing Kings in Python Chess\nDESCRIPTION: This snippet shows how to integrate a python-chess RacingKingsBoard with a UCI engine (Stockfish in this case). It initializes a RacingKingsBoard, starts a UCI engine process, and then plays a move on the board using the engine with a time limit of 1 second.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/variant.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport chess.engine\n\nengine = chess.engine.SimpleEngine.popen_uci(\"stockfish-mv\")\n\nboard = chess.variant.RacingKingsBoard()\nresult = engine.play(board, chess.engine.Limit(time=1.0))\n```\n\n----------------------------------------\n\nTITLE: Configuring Engine Options with asyncio in Python\nDESCRIPTION: This code shows how to configure options for a chess engine using asyncio. It connects to the engine, prints the available options (specifically 'Hash'), then sets the 'Hash' option to 32 using the configure method. This affects engine behaviour during analysis or gameplay.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/engine.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport chess.engine\n\nasync def main() -> None:\n    transport, engine = await chess.engine.popen_uci(\"/usr/bin/stockfish\")\n\n    # Check available options.\n    print(engine.options[\"Hash\"])\n    # Option(name='Hash', type='spin', default=16, min=1, max=131072, var=[])\n\n    # Set an option.\n    await engine.configure({\"Hash\": 32})\n\n    # [...]\n\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: PGN Parsing with Error Handling - Python\nDESCRIPTION: Illustrates how to use the `chess.pgn.read_game()` function with and without error handling. Demonstrates how a ValueError is raised by default when illegal moves are encountered, and how providing an error_handler allows for silent error ignoring.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> # Raises ValueError:\n>>> game = chess.pgn.read_game(file_with_illegal_moves)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> # Silently ignores errors and continues parsing:\n```\n\n----------------------------------------\n\nTITLE: Opening Syzygy Tablebase in Python Chess\nDESCRIPTION: This function `chess.syzygy.open_tablebase` opens a Syzygy tablebase file. It is necessary to have the Syzygy tablebase files available locally. The function returns a Tablebase object that can be used to query the tablebase.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/syzygy.rst#_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Creating a Board from EPD - Python\nDESCRIPTION: Illustrates how to create a `chess.Board` object from an Extended Position Description (EPD) string using `chess.Board.from_epd()`. It returns a tuple containing the board and a dictionary of EPD operations.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> board, ops = chess.Board.from_epd(\"4k3/8/8/8/8/8/8/4K3 b - - fmvn 17; hmvc 13\")\n>>> board\nBoard('4k3/8/8/8/8/8/8/4K3 b - - 13 17')\n>>> ops\n{'fmvn': 17, 'hmvc': 13}\n```\n\n----------------------------------------\n\nTITLE: Initializing Chess960 Board in Python Chess\nDESCRIPTION: This snippet demonstrates how to initialize a standard chess board with the Chess960 variant enabled. The chess960 parameter is set to True, indicating that the board should be initialized with a random starting position according to Chess960 rules.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/variant.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nchess.Board(chess960=True)\n```\n\n----------------------------------------\n\nTITLE: Memory Mapped Reader in Python Chess\nDESCRIPTION: The `MemoryMappedReader` class provides an efficient way to read large Polyglot opening books by memory mapping the file. This avoids loading the entire book into memory at once, making it suitable for larger book files and resource-constrained environments.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/polyglot.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n.. autoclass:: chess.polyglot.MemoryMappedReader\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Communicating with UCI Engines in Python\nDESCRIPTION: This code demonstrates how to communicate with UCI (Universal Chess Interface) engines using the python-chess library. It uses the `chess.engine.SimpleEngine.popen_uci` function to start an engine, the `play` method to play a move, and `quit` to terminate the engine process. Requires an executable 'stockfish' in the path.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/README.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> import chess.engine\n\n>>> engine = chess.engine.SimpleEngine.popen_uci(\"stockfish\")\n\n>>> board = chess.Board(\"1k1r4/pp1b1R2/3q2pp/4p3/2B5/4Q3/PPP2B2/2K5 b - - 0 1\")\n>>> limit = chess.engine.Limit(time=2.0)\n>>> engine.play(board, limit)  # doctest: +ELLIPSIS\n<PlayResult at ... (move=d6d1, ponder=c1d1, info={...}, draw_offered=False, resigned=False)>\n\n>>> engine.quit()\n```\n\n----------------------------------------\n\nTITLE: Chess Piece Type Constants in Python\nDESCRIPTION: Defines constants for representing the different piece types in chess. Each piece type is assigned a unique integer value from 1 to 6, corresponding to Pawn, Knight, Bishop, Rook, Queen, and King respectively.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/core.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nchess.PAWN\n```\n\nLANGUAGE: Python\nCODE:\n```\nchess.KNIGHT\n```\n\nLANGUAGE: Python\nCODE:\n```\nchess.BISHOP\n```\n\nLANGUAGE: Python\nCODE:\n```\nchess.ROOK\n```\n\nLANGUAGE: Python\nCODE:\n```\nchess.QUEEN\n```\n\nLANGUAGE: Python\nCODE:\n```\nchess.KING\n```\n\n----------------------------------------\n\nTITLE: Chess Game Example in Python\nDESCRIPTION: This code snippet demonstrates a basic chess game using the python-chess library, including move generation, move validation, and checking for checkmate.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/README.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import chess\n\n>>> board = chess.Board()\n\n>>> board.legal_moves  # doctest: +ELLIPSIS\n<LegalMoveGenerator at ... (Nh3, Nf3, Nc3, Na3, h3, g3, f3, e3, d3, c3, ...)>\n>>> chess.Move.from_uci(\"a8a1\") in board.legal_moves\nFalse\n\n>>> board.push_san(\"e4\")\nMove.from_uci('e2e4')\n>>> board.push_san(\"e5\")\nMove.from_uci('e7e5')\n>>> board.push_san(\"Qh5\")\nMove.from_uci('d1h5')\n>>> board.push_san(\"Nc6\")\nMove.from_uci('b8c6')\n>>> board.push_san(\"Bc4\")\nMove.from_uci('f1c4')\n>>> board.push_san(\"Nf6\")\nMove.from_uci('g8f6')\n>>> board.push_san(\"Qxf7\")\nMove.from_uci('h5f7')\n\n>>> board.is_checkmate()\nTrue\n\n>>> board\nBoard('r1bqkb1r/pppp1Qpp/2n2n2/4p3/2B1P3/8/PPPP1PPP/RNB1K1NR b KQkq - 0 4')\n```\n\n----------------------------------------\n\nTITLE: Playing Chess with Stockfish using asyncio in Python\nDESCRIPTION: This example demonstrates asynchronous chess play with Stockfish using asyncio. It initializes the engine using popen_uci within an asyncio event loop, then plays moves until the game is over, and finally quits the engine. The Limit class is used to limit the time spent per move.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/engine.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport chess\nimport chess.engine\n\nasync def main() -> None:\n    transport, engine = await chess.engine.popen_uci(r\"C:\\Users\\xxxxx\\Downloads\\stockfish_14_win_x64\\stockfish_14_win_x64_avx2.exe\")\n\n    board = chess.Board()\n    while not board.is_game_over():\n        result = await engine.play(board, chess.engine.Limit(time=0.1))\n        board.push(result.move)\n\n    await engine.quit()\n\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Parsing and Creating FENs in Python\nDESCRIPTION: This code demonstrates how to parse and create Forsyth–Edwards Notation (FEN) strings using the python-chess library. It uses the `fen` and `shredder_fen` methods to create FENs and extended FENs, and `piece_at` to retrieve a piece at a given square.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/README.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> board.fen()\n'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\n>>> board.shredder_fen()\n'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w HAha - 0 1'\n>>> board = chess.Board(\"8/8/8/2k5/4K3/8/8/8 w - - 4 45\")\n>>> board.piece_at(chess.C5)\nPiece.from_symbol('k')\n```\n\n----------------------------------------\n\nTITLE: Adding GPL Notice to Source Files\nDESCRIPTION: This snippet demonstrates how to add the GNU General Public License (GPL) notice to the start of each source file in a program.  It includes the program's name, copyright information, and a statement about the GPL license and its terms.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/LICENSE.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n<one line to give the program's name and a brief idea of what it does.>\nCopyright (C) <year>  <name of author>\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n```\n\n----------------------------------------\n\nTITLE: Reading and Writing PGNs in Python\nDESCRIPTION: This code demonstrates how to read and write Portable Game Notation (PGN) files using the python-chess library. It uses the `chess.pgn.read_game` function to read a game from a PGN file and access its headers and mainline.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/README.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> import chess.pgn\n\n>>> with open(\"data/pgn/molinari-bordais-1979.pgn\") as pgn:\n...     first_game = chess.pgn.read_game(pgn)\n\n>>> first_game.headers[\"White\"]\n'Molinari'\n>>> first_game.headers[\"Black\"]\n'Bordais'\n\n>>> first_game.mainline()  # doctest: +ELLIPSIS\n<Mainline at ... (1. e4 c5 2. c4 Nc6 3. Ne2 Nf6 4. Nbc3 Nb4 5. g3 Nd3#)>\n\n>>> first_game.headers[\"Result\"]\n'0-1'\n```\n\n----------------------------------------\n\nTITLE: Polyglot Entry Class in Python Chess\nDESCRIPTION: The `Entry` class represents a single move entry within a Polyglot opening book. It contains information about the move itself, as well as associated data like weight and learn. This class is fundamental when processing and using opening book suggestions.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/polyglot.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n.. autoclass:: chess.polyglot.Entry\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Parsing and Creating SAN Moves in Python\nDESCRIPTION: This snippet shows how to parse and create Standard Algebraic Notation (SAN) representations of chess moves using the python-chess library. The `san` method converts a move to SAN, and `parse_san` parses a SAN string into a move object.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/README.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> board = chess.Board()\n>>> board.san(chess.Move(chess.E2, chess.E4))\n'e4'\n>>> board.parse_san('Nf3')\nMove.from_uci('g1f3')\n>>> board.variation_san([chess.Move.from_uci(m) for m in [\"e2e4\", \"e7e5\", \"g1f3\"]])\n'1. e4 e5 2. Nf3'\n```\n\n----------------------------------------\n\nTITLE: Probing Syzygy Tablebases in Python\nDESCRIPTION: This snippet shows how to probe Syzygy endgame tablebases using the python-chess library. The `chess.syzygy.open_tablebase` function opens a tablebase, and `probe_dtz` method returns the distance-to-zero (DTZ) value for a given position.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/README.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> import chess.syzygy\n\n>>> tablebase = chess.syzygy.open_tablebase(\"data/syzygy/regular\")\n\n>>> # Black to move is losing in 53 half moves (distance to zero) in this\n>>> # KNBvK endgame.\n>>> board = chess.Board(\"8/2K5/4B3/3N4/8/8/4k3/8 b - - 0 1\")\n>>> tablebase.probe_dtz(board)\n-53\n\n>>> tablebase.close()\n```\n\n----------------------------------------\n\nTITLE: Building and Installing libgtb (Gaviota Tablebases)\nDESCRIPTION: This shell script clones the Gaviota Tablebases repository, builds the shared library using `make`, and installs it system-wide using `sudo make install`. This provides faster access to tablebase information through the `NativeTablebase` class in the `chess.gaviota` module.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/gaviota.rst#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ngit clone https://github.com/michiguel/Gaviota-Tablebases.git\ncd Gaviota-Tablebases\nmake\nsudo make install\n```\n\n----------------------------------------\n\nTITLE: Displaying ASCII Board in Python\nDESCRIPTION: This code shows how to display a simple ASCII representation of a chess board using the python-chess library.  The `chess.Board` class is used to create a board object, and `print(board)` generates the ASCII representation.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/README.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> board = chess.Board(\"r1bqkb1r/pppp1Qpp/2n2n2/4p3/2B1P3/8/PPPP1PPP/RNB1K1NR b KQkq - 0 4\")\n>>> print(board)\nr . b q k b . r\np p p p . Q p p\n. . n . . n . .\n. . . . p . . .\n. . B . P . . .\n. . . . . . . .\nP P P P . P P P\nR N B . K . N R\n```\n\n----------------------------------------\n\nTITLE: Displaying GPL Notice in Interactive Terminal Programs\nDESCRIPTION: This snippet shows how to display a short GPL notice when a program starts in interactive mode. It includes the program's name, copyright information, a warranty disclaimer, and instructions for viewing the full license details.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/LICENSE.txt#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n<program>  Copyright (C) <year>  <name of author>\nThis program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\nThis is free software, and you are welcome to redistribute it\nunder certain conditions; type `show c' for details.\n```\n\n----------------------------------------\n\nTITLE: Configuring Engine Options with SimpleEngine in Python\nDESCRIPTION: This snippet demonstrates how to configure options for a chess engine using the SimpleEngine class in Python. It checks the available options, then sets a specific option (Hash) to a new value. This configures the engine's behavior.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/engine.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport chess.engine\n\nengine = chess.engine.SimpleEngine.popen_uci(\"/usr/bin/stockfish\")\n\n# Check available options.\nengine.options[\"Hash\"]\n# Option(name='Hash', type='spin', default=16, min=1, max=131072, var=[])\n\n# Set an option.\nengine.configure({\"Hash\": 32})\n\n# [...]\n```\n\n----------------------------------------\n\nTITLE: Accessing Variant Information in Python Chess\nDESCRIPTION: This snippet shows how to access variant-specific information from a board object, such as the UCI variant name, the XBoard variant name, and the starting FEN string. These attributes provide metadata about the specific chess variant being played.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/variant.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ntype(board).uci_variant\n'giveaway'\ntype(board).xboard_variant\n'giveaway'\ntype(board).starting_fen\n'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w - - 0 1'\n```\n\n----------------------------------------\n\nTITLE: Remote Engine Communication with AsyncSSH in Python\nDESCRIPTION: This snippet demonstrates how to use AsyncSSH to communicate with a chess engine on a remote computer. It establishes an SSH connection, creates a subprocess running the engine, initializes the engine, and then executes a ping command.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/engine.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport asyncssh\nimport chess\nimport chess.engine\n\nasync def main() -> None:\n    async with asyncssh.connect(\"localhost\") as conn:\n        channel, engine = await conn.create_subprocess(chess.engine.UciProtocol, \"/usr/bin/stockfish\")\n        await engine.initialize()\n\n        # Play, analyse, ...\n        await engine.ping()\n\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Reading Polyglot Opening Books in Python\nDESCRIPTION: This code demonstrates how to read Polyglot opening books using the python-chess library. It uses the `chess.polyglot.open_reader` function to open a book file and the `find` method to retrieve an entry for a given board position.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/README.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> import chess.polyglot\n\n>>> book = chess.polyglot.open_reader(\"data/polyglot/performance.bin\")\n\n>>> board = chess.Board()\n>>> main_entry = book.find(board)\n>>> main_entry.move\nMove.from_uci('e2e4')\n>>> main_entry.weight\n1\n\n>>> book.close()\n```\n\n----------------------------------------\n\nTITLE: Using Syzygy Tablebase for Atomic Chess in Python Chess\nDESCRIPTION: This snippet demonstrates how to open and use a Syzygy tablebase for Atomic chess. It imports the necessary modules, opens the tablebase file, specifying the variant board type as AtomicBoard, and then presumably proceeds to use the tablebase for move generation or evaluation.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/variant.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport chess.syzygy\nimport chess.variant\n\ntables = chess.syzygy.open_tablebase(\"data/syzygy\", VariantBoard=chess.variant.AtomicBoard)\n```\n\n----------------------------------------\n\nTITLE: Parsing and Creating EPDs in Python\nDESCRIPTION: This snippet demonstrates how to parse and create Extended Position Description (EPD) records using the python-chess library.  The `epd` method creates an EPD record, and `set_epd` parses an EPD string.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/README.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> board = chess.Board()\n>>> board.epd(bm=board.parse_uci(\"d2d4\"))\n'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - bm d4;'\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> ops = board.set_epd(\"1k1r4/pp1b1R2/3q2pp/4p3/2B5/4Q3/PPP2B2/2K5 b - - bm Qd1+; id \\\"BK.01\\\";\")\n>>> ops == {'bm': [chess.Move.from_uci('d6d1')], 'id': 'BK.01'}\nTrue\n```\n\n----------------------------------------\n\nTITLE: Castling Rights Check - Python\nDESCRIPTION: Shows how to check castling rights using bitwise operations with `chess.BB_A1`, `chess.BB_H1`, `chess.BB_A8`, `chess.BB_H8` and the `board.castling_rights` attribute. It demonstrates checking for specific castling rights.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> board = chess.Board()\n\n>>> # Standard castling rights.\n>>> board.castling_rights == chess.BB_A1 | chess.BB_H1 | chess.BB_A8 | chess.BB_H8\nTrue\n\n>>> # Check for the presence of a specific castling right.\n>>> can_white_castle_queenside = chess.BB_A1 & board.castling_rights\n```\n\n----------------------------------------\n\nTITLE: UCI InfoHandler Usage - Python\nDESCRIPTION: Demonstrates how to access the 'score' information from the `uci.InfoHandler` object within a `with` statement, specifically how to access the centipawn score (cp) from the info dictionary for multipv analysis.  Shows the change needed in the new version.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> with info_handler as info:\n...     if 1 in info[\"score\"]:\n...         cp = info[\"score\"][1].cp\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> with info_handler as info:\n...     if \"score\" in info:\n...         cp = info[\"score\"].cp\n```\n\n----------------------------------------\n\nTITLE: Detecting Game Endings in Python\nDESCRIPTION: This snippet demonstrates how to detect checkmates, stalemates, and draws by insufficient material using the python-chess library. It uses methods such as `is_stalemate`, `is_insufficient_material`, and `outcome` to determine the game's ending.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/README.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> board.is_stalemate()\nFalse\n>>> board.is_insufficient_material()\nFalse\n>>> board.outcome()\nOutcome(termination=<Termination.CHECKMATE: 1>, winner=True)\n```\n\n----------------------------------------\n\nTITLE: Detecting Repetitions in Python\nDESCRIPTION: This code demonstrates how to detect threefold repetitions and track the half-move clock using the python-chess library. It uses methods like `can_claim_threefold_repetition`, `halfmove_clock`, `can_claim_fifty_moves`, `can_claim_draw`, `is_fivefold_repetition` and `is_seventyfive_moves`.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/README.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> board.can_claim_threefold_repetition()\nFalse\n>>> board.halfmove_clock\n0\n>>> board.can_claim_fifty_moves()\nFalse\n>>> board.can_claim_draw()\nFalse\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> board.is_fivefold_repetition()\nFalse\n>>> board.is_seventyfive_moves()\nFalse\n```\n\n----------------------------------------\n\nTITLE: Zobrist Hash Function in Python Chess\nDESCRIPTION: The `zobrist_hash` function calculates the Zobrist hash of a given board position. This hash is used to efficiently index and search for positions in the Polyglot opening book, significantly speeding up the move lookup process.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/polyglot.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n.. autofunction:: chess.polyglot.zobrist_hash\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug Logging for Chess Engine Communication in Python\nDESCRIPTION: This code snippet demonstrates how to enable debug logging for chess engine communication. This allows developers to see detailed information about the interaction between the chess program and the engine, aiding in debugging and troubleshooting.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/engine.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport logging\n\n# Enable debug logging.\nlogging.basicConfig(level=logging.DEBUG)\n```\n\n----------------------------------------\n\nTITLE: Opening Polyglot Book Reader in Python Chess\nDESCRIPTION: The `open_reader` function is used to open a Polyglot opening book file and create a reader object for accessing entries within the book. It is typically the first step when utilizing opening books in a chess engine using python-chess.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/polyglot.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n.. autofunction:: chess.polyglot.open_reader\n```\n\n----------------------------------------\n\nTITLE: Chess Color Constants in Python\nDESCRIPTION: Defines constants for representing the two colors in chess: white and black. These constants are boolean values where chess.WHITE is True and chess.BLACK is False. The 'not' operator can be used to get the opposite color.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/core.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nchess.WHITE\n```\n\nLANGUAGE: Python\nCODE:\n```\nchess.BLACK\n```\n\n----------------------------------------\n\nTITLE: Making and Unmaking Moves in Python\nDESCRIPTION: This snippet demonstrates how to make and unmake moves using the python-chess library. It uses the `push` method to make a move and the `pop` method to undo the last move.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/README.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> Nf3 = chess.Move.from_uci(\"g1f3\")\n>>> board.push(Nf3)  # Make the move\n\n>>> board.pop()  # Unmake the last move\nMove.from_uci('g1f3')\n```\n\n----------------------------------------\n\nTITLE: Printing a Bitboard\nDESCRIPTION: This snippet shows how to print a human-readable representation of a `chess.Bitboard` object. It utilizes the built-in `print` function to display the board's state.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> print(chess.Bitboard())\nr n b q k b n r\np p p p p p p p\n. . . . . . . .\n. . . . . . . .\n. . . . . . . .\n. . . . . . . .\nP P P P P P P P\nR N B Q K B N R\n```\n\n----------------------------------------\n\nTITLE: Parsing SAN Notation Python\nDESCRIPTION: Introduces `chess.pgn.BaseVisitor.parse_san(board, san)` which is used by parsers and can be overwritten to deal with non-standard input formats. This allows greater flexibility in handling different notations for chess moves.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_7\n\n\n\n----------------------------------------\n\nTITLE: Generating Knight and Queen Moves in Python Chess\nDESCRIPTION: This snippet demonstrates how to generate legal moves for knights and queens using the modified `Board.generate_legal_moves()` method.  It uses bitwise OR to combine the squares occupied by knights and queens.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nboard.generate_legal_moves(board.knights | board.queens)\n```\n\n----------------------------------------\n\nTITLE: Initializing an Empty Chess Board - Python\nDESCRIPTION: Demonstrates how to initialize an empty chess board using the `chess.Board.empty()` method. This creates a board with no pieces on it, represented by the FEN string '8/8/8/8/8/8/8/8 w - - 0 1'.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> chess.Board.empty()\nBoard('8/8/8/8/8/8/8/8 w - - 0 1')\n```\n\n----------------------------------------\n\nTITLE: Initializing a Giveaway Board in Python Chess\nDESCRIPTION: This snippet demonstrates how to import the chess.variant module and initialize a GiveawayBoard object. The GiveawayBoard class is used to represent a game of Giveaway chess, also known as Suicide chess or Losing chess.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/variant.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport chess.variant\n\nboard = chess.variant.GiveawayBoard()\n```\n\n----------------------------------------\n\nTITLE: Detecting Checks and Attacks in Python\nDESCRIPTION: This code demonstrates how to detect checks and attacks using the python-chess library. It uses methods like `is_check`, `is_attacked_by`, and `attackers` to determine if a square is under attack.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/README.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> board.is_check()\nTrue\n>>> board.is_attacked_by(chess.WHITE, chess.E8)\nTrue\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> attackers = board.attackers(chess.WHITE, chess.F3)\n>>> attackers\nSquareSet(0x0000_0000_0000_4040)\n>>> chess.G2 in attackers\nTrue\n>>> print(attackers)\n. . . . . . . .\n. . . . . . . .\n. . . . . . . .\n. . . . . . . .\n. . . . . . . .\n. . . . . . . .\n. . . . . . 1 .\n. . . . . . 1 .\n```\n\n----------------------------------------\n\nTITLE: Chess Square Constants in Python\nDESCRIPTION: Defines constants representing the squares on a chessboard, numbered from 0 to 63.  A1 is 0, B1 is 1, and so on, up to H8 which is 63. Provides also constants for accessing lists of square names, file names and rank names.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/core.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nchess.A1\n```\n\nLANGUAGE: Python\nCODE:\n```\nchess.B1\n```\n\nLANGUAGE: Python\nCODE:\n```\nchess.G8\n```\n\nLANGUAGE: Python\nCODE:\n```\nchess.H8\n```\n\nLANGUAGE: Python\nCODE:\n```\nchess.SQUARES\n```\n\nLANGUAGE: Python\nCODE:\n```\nchess.SQUARE_NAMES\n```\n\nLANGUAGE: Python\nCODE:\n```\nchess.FILE_NAMES\n```\n\nLANGUAGE: Python\nCODE:\n```\nchess.RANK_NAMES\n```\n\n----------------------------------------\n\nTITLE: Adding Board Color Retrieval Python\nDESCRIPTION: Introduces the `Board.color_at(square)` method to retrieve the color of a piece at a given square. This is a new feature in the python-chess library, allowing users to easily determine the color occupying a specific square on the board.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Adding Move Generation Methods in Python Chess\nDESCRIPTION: The following new move generation methods are added to the Board class: `Board.generate_pseudo_legal_ep()`, `Board.generate_legal_ep()`, `Board.generate_pseudo_legal_captures()`, `Board.generate_legal_captures()`. They take `from_mask` and `to_mask` parameters.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_12\n\n\n\n----------------------------------------\n\nTITLE: Modifying Move Generation Methods in Python Chess\nDESCRIPTION: The signatures of `Board.generate_legal_moves()` and `Board.generate_pseudo_legal_moves()` have been changed to allow selecting arbitrary sets of origin and target squares using `from_mask` and `to_mask` parameters.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_9\n\n\n\n----------------------------------------\n\nTITLE: Insufficient Material Check Python\nDESCRIPTION: Introduces `board.has_insufficient_material(color)` for checking insufficient material for a specific side.  This allows the library to determine if a side has enough material to force a checkmate, an important aspect of chess rules.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Handling Parsing Errors\nDESCRIPTION: This snippet illustrates how to log errors encountered while parsing a PGN file and continue parsing the game. It passes a logger's exception method to `chess.pgn.read_game`.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n>>> # Logs the error, continues parsing:\n>>> game = chess.pgn.read_game(file_with_illegal_moves, logger.exception)\n```\n\n----------------------------------------\n\nTITLE: Creating UCI Representations for Moves in Python Chess\nDESCRIPTION: The `Board.uci(move, chess960=None)` method creates UCI representations for moves in the context of the current position. Unlike `Move.uci()`, it can convert moves in both standard chess and Chess960 modes.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_14\n\n\n\n----------------------------------------\n\nTITLE: Board Copy with Stack Depth Python\nDESCRIPTION: Introduces the `board.copy(stack=depth)` method for creating copies of boards with a limited stack depth. This allows for controlling memory usage when creating copies of game states.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_4\n\n\n\n----------------------------------------\n\nTITLE: Board Repetition Check Python\nDESCRIPTION: Introduces the `Board.is_repetition(count=3)` method to check if a position has been repeated a specified number of times. This enhances the ability to detect draw conditions in chess games.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Engine Analysis Result Handling Python\nDESCRIPTION: Adds `chess.engine.AnalysisResult.get()` and `empty()` methods for handling analysis results from chess engines. These methods provide ways to access and check the analysis data returned by an engine.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: File Bitboards in Python\nDESCRIPTION: Defines constants for bitboards representing each file on the chessboard.  `chess.BB_FILES` is a list containing the bitboards for files A to H.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/core.rst#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nchess.BB_FILES\n```\n\n----------------------------------------\n\nTITLE: Checking for Legal En Passant Moves in Python Chess\nDESCRIPTION: The `Board.has_legal_en_passant()` method tests if a position has a legal en passant move. This is used to determine if the en passant square should be displayed in the FEN representation.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_16\n\n\n\n----------------------------------------\n\nTITLE: Generating Castling Moves in Python Chess\nDESCRIPTION: This snippet shows how to generate only castling moves using `Board.generate_castling_moves()` with `from_mask` and `to_mask` set to `BB_ALL`.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nBoard.generate_castling_moves(from_mask=BB_ALL, to_mask=BB_ALL)\n```\n\n----------------------------------------\n\nTITLE: Reading PGN Game\nDESCRIPTION: Demonstrates reading a chess game from a PGN file using `chess.pgn.read_game`. It shows how to handle illegal moves during parsing by providing a logger.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> game = chess.pgn.read_game(file_with_illegal_moves, None)\n```\n\n----------------------------------------\n\nTITLE: Initializing Board with Chess960 in Python Chess\nDESCRIPTION: The `Board` constructor now accepts a `chess960` argument, defaulting to `False`. The `Board.chess960` property indicates whether the board is in Chess960 mode.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_13\n\n\n\n----------------------------------------\n\nTITLE: Creating SVG Arrows Python\nDESCRIPTION: Enhanced `chess.svg.Arrow(tail, head, color=\"#888\")` by adding optional color argument.  This enhances the visual customization of board representations in SVG format.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_6\n\n\n\n----------------------------------------\n\nTITLE: Board Transformation Python\nDESCRIPTION: Introduces `board.apply_transform(f)` and `board.transform(f)` for applying bitboard transformations to a position. The library provides example transformations like `chess.flip_{vertical,horizontal,diagonal,anti_diagonal}`.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_5\n\n\n\n----------------------------------------\n\nTITLE: Full Bitboard Constant in Python\nDESCRIPTION: Defines a constant representing a full bitboard, where all squares are set. This bitboard has a value of 0xFFFF_FFFF_FFFF_FFFF.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/core.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nchess.BB_ALL\n```\n\n----------------------------------------\n\nTITLE: Single Square Bitboards in Python\nDESCRIPTION: Defines constants representing each individual square as a bitboard. `chess.BB_SQUARES` is a list containing all individual square bitboards, starting from A1 to H8.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/core.rst#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nchess.BB_SQUARES\n```\n\n----------------------------------------\n\nTITLE: Renaming Board Method in Python Chess\nDESCRIPTION: The method `Board.attacker_mask()` has been renamed to `Board.attackers_mask()` for consistency in naming conventions within the python-chess library.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_8\n\n\n\n----------------------------------------\n\nTITLE: Rank Bitboards in Python\nDESCRIPTION: Defines constants for bitboards representing each rank on the chessboard. `chess.BB_RANKS` is a list containing bitboards for ranks 1 to 8.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/core.rst#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nchess.BB_RANKS\n```\n\n----------------------------------------\n\nTITLE: Testing for Chess960 Castling Rights in Python Chess\nDESCRIPTION: The `Board.has_chess960_castling_rights()` method tests for castling rights that are impossible in standard chess.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/CHANGELOG-OLD.rst#_snippet_15\n\n\n\n----------------------------------------\n\nTITLE: Backrank Bitboard in Python\nDESCRIPTION: Defines a constant for a bitboard representing both backranks (ranks 1 and 8) on the chessboard.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/core.rst#_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\nchess.BB_BACKRANKS\n```\n\n----------------------------------------\n\nTITLE: Light and Dark Square Bitboards in Python\nDESCRIPTION: Defines constants for bitboards representing the light and dark squares on the chessboard.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/core.rst#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nchess.BB_LIGHT_SQUARES\n```\n\nLANGUAGE: Python\nCODE:\n```\nchess.BB_DARK_SQUARES\n```\n\n----------------------------------------\n\nTITLE: Center Bitboard in Python\nDESCRIPTION: Defines a constant for a bitboard representing the central squares (D4, E4, D5, and E5) on the chessboard.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/core.rst#_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\nchess.BB_CENTER\n```\n\n----------------------------------------\n\nTITLE: Polyglot Random Array in Python Chess\nDESCRIPTION: The `POLYGLOT_RANDOM_ARRAY` is a list of 781 pseudo-random values used for Zobrist hashing in Polyglot books.  These values are essential for quickly calculating hash keys for board positions, enabling efficient lookup of moves in the opening book.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/polyglot.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n.. py:data:: chess.polyglot.POLYGLOT_RANDOM_ARRAY\n    :value: [0x9D39247E33776D41, ..., 0xF8D626AAAF278509]\n```\n\n----------------------------------------\n\nTITLE: Corner Bitboard in Python\nDESCRIPTION: Defines a constant for a bitboard representing the four corners of the chessboard (A1, H1, A8, and H8).\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/core.rst#_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\nchess.BB_CORNERS\n```\n\n----------------------------------------\n\nTITLE: Empty Bitboard Constant in Python\nDESCRIPTION: Defines a constant representing an empty bitboard, where no squares are set.  This bitboard has a value of 0.\nSOURCE: https://github.com/niklasf/python-chess/blob/master/docs/core.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nchess.BB_EMPTY\n```"
  }
]