[
  {
    "owner": "reactor",
    "repo": "blockhound",
    "content": "TITLE: Installing BlockHound and Detecting Blocking Calls\nDESCRIPTION: This Java code snippet demonstrates how to install BlockHound and trigger a `BlockingOperationError` by calling `Thread.sleep` within a reactive context.  It requires BlockHound to be installed as a Java agent. It shows a Mono delaying for one second and then sleeping for 10 milliseconds, which BlockHound detects as a blocking operation.\nSOURCE: https://github.com/reactor/blockhound/blob/master/README.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n// Example.java\nBlockHound.install();\n\nMono.delay(Duration.ofSeconds(1))\n    .doOnNext(it -> {\n        try {\n            Thread.sleep(10);\n        }\n        catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    })\n    .block();\n```\n\n----------------------------------------\n\nTITLE: Installing BlockHound Agent in Java\nDESCRIPTION: This Java snippet shows the simplest way to install BlockHound by calling `BlockHound.install()`. This needs to be done before any code that could potentially block is executed. It discovers integrations and performs one-time instrumentation. The method is idempotent.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/quick_start.md#_snippet_4\n\nLANGUAGE: Java\nCODE:\n```\nBlockHound.install();\n```\n\n----------------------------------------\n\nTITLE: Marking Methods as Blocking in Java\nDESCRIPTION: This snippet demonstrates how to mark a method as blocking using BlockHound's `Builder#markAsBlocking` method. It requires the class name, method name, and JVM signature of the method to be marked as blocking. The JVM signature is essential for uniquely identifying the method.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/customization.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nbuilder.markAsBlocking(\"com.example.NativeHelper\", \"doSomethingBlocking\", \"(I)V\");\n```\n\n----------------------------------------\n\nTITLE: Java Method Instrumentation with BlockHound\nDESCRIPTION: This code snippet demonstrates how BlockHound instruments Java methods to detect blocking calls. It adds a call to `reactor.blockhound.BlockHoundRuntime.checkBlocking` at the beginning of the method's body. The `checkBlocking` method then determines whether the call is allowed based on the current thread's state.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/how_it_works.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n// java.net.Socket\npublic void connect(SocketAddress endpoint, int timeout) {\n    reactor.blockhound.BlockHoundRuntime.checkBlocking(\n        \"java.net.Socket\",\n        \"connect\",\n        /*method modifiers*/\n    );\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Test for Blocking Call Detection\nDESCRIPTION: This Java snippet demonstrates a simple test case to verify that BlockHound is installed correctly. It uses `Mono.delay` to introduce a delay and then intentionally blocks the thread using `Thread.sleep`. BlockHound should detect the blocking call and throw an exception.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/quick_start.md#_snippet_5\n\nLANGUAGE: Java\nCODE:\n```\nMono.delay(Duration.ofMillis(1))\n    .doOnNext(it -> {\n        try {\n            Thread.sleep(10);\n        }\n        catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    })\n    .block(); // should throw an exception about Thread.sleep\n```\n\n----------------------------------------\n\nTITLE: Allow/Disallow Blocking Calls Example in Java\nDESCRIPTION: This code demonstrates how to allow blocking calls in the `outer()` method of `NonBlockingClass` while disallowing them in the `inner()` method.  It shows using `allowBlockingCallsInside` and `disallowBlockingCallsInside` to precisely control where blocking calls are permitted, using the static initialization block to install BlockHound.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/customization.md#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\npublic class BlockingDisallowTest {\n\n    static {\n        BlockHound.install(b -> b\n                .allowBlockingCallsInside(NonBlockingClass.class.getName(), \"outer\")\n                .disallowBlockingCallsInside(NonBlockingClass.class.getName(), \"inner\")\n        );\n    }\n\n    static class NonBlockingClass {\n\n        String inner() {\n            try {\n                //if this trips BlockHound, the test fails (inner not in the stacktrace)\n                Thread.sleep(50);\n            }\n            catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return \"example\";\n        }\n\n        String outer() {\n            try {\n                Thread.sleep(50);\n            }\n            catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            Thread.yield();\n            return inner();\n        }\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Custom Non-Blocking Thread Predicate in Java\nDESCRIPTION: This snippet shows how to define a custom predicate to identify non-blocking threads using `Builder#nonBlockingThreadPredicate`. The example marks threads with names containing \"my-thread-\" as non-blocking. It's crucial to incorporate the `current` predicate (provided by Blockhound) to avoid overriding existing integrations.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/customization.md#_snippet_5\n\nLANGUAGE: java\nCODE:\n```\nbuilder.nonBlockingThreadPredicate(current -> {\n    return current.or(it -> it.getName().contains(\"my-thread-\"))\n});\n```\n\n----------------------------------------\n\nTITLE: Custom Blocking Method Callback in Java\nDESCRIPTION: This snippet demonstrates how to set a custom callback for handling blocking method detections using `Builder#blockingMethodCallback`. Instead of throwing an error, the callback prints the stack trace. This allows for custom logic when a blocking call is detected without interrupting program execution.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/customization.md#_snippet_4\n\nLANGUAGE: java\nCODE:\n```\nbuilder.blockingMethodCallback(it -> {\n    new Error(it.toString()).printStackTrace();\n});\n```\n\n----------------------------------------\n\nTITLE: Testing BlockHound Integration with Project Reactor in Java\nDESCRIPTION: This test verifies that BlockHound is correctly integrated and detects blocking operations. It creates a task that sleeps, schedules it on a parallel scheduler, and asserts that an `ExecutionException` with a `BlockingOperationError` is thrown.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/tips.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n@Test\npublic void blockHoundWorks() throws TimeoutException, InterruptedException {\n    try {\n        FutureTask<?> task = new FutureTask<>(() -> {\n            Thread.sleep(0);\n            return \"\";\n        });\n        Schedulers.parallel().schedule(task);\n\n        task.get(10, TimeUnit.SECONDS);\n        Assert.fail(\"should fail\");\n    } catch (ExecutionException e) {\n        Assert.assertTrue(\"detected\", e.getCause() instanceof BlockingOperationError);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Blocking Call Check Implementation in BlockHound\nDESCRIPTION: This code snippet illustrates the `checkBlocking` method, which determines whether a blocking call is allowed. It checks a `ThreadLocal` variable `IS_ALLOWED` to determine if blocking calls are permitted in the current thread. If not allowed, it triggers an error or callback. This allows for whitelisting and blacklisting of methods.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/how_it_works.md#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nstatic void checkBlocking(String className, String methodName, int modifiers) {\n    if (Boolean.FALSE == IS_ALLOWED.get()) {\n        // Report\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing BlockHoundIntegration in Java\nDESCRIPTION: Shows an example of a custom BlockHound integration that implements the BlockHoundIntegration interface.  The applyTo method allows configuring the BlockHound builder with custom predicates to identify non-blocking threads.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/custom_integrations.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\npublic class MyIntegration implements BlockHoundIntegration {\n\n    @Override\n    public void applyTo(BlockHound.Builder builder) {\n        builder.nonBlockingThreadPredicate(current -> {\n            return current.or(t -> {\n                if (t.getName() == null) {\n                    return false;\n                }\n                return t.getName().contains(\"my-pool-\");\n            });\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Allow Blocking Calls Inside Methods in Java\nDESCRIPTION: This snippet shows how to allow blocking method calls inside a specific method using `Builder#allowBlockingCallsInside`. It specifies the class name and method name where blocking calls should be permitted. This is useful for scenarios where blocking calls are unavoidable within a particular method's execution.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/customization.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nbuilder.allowBlockingCallsInside(\n    \"ch.qos.logback.classic.Logger\",\n    \"callAppenders\"\n);\n```\n\n----------------------------------------\n\nTITLE: Relocating Native Methods for BlockHound Instrumentation\nDESCRIPTION: This code snippet shows how BlockHound handles native methods. Since native methods cannot be directly instrumented, the original method is renamed, and a new Java method with the original signature is created. The new method delegates to the renamed native method and includes a call to `reactor.blockhound.BlockHoundRuntime.checkBlocking` for blocking call detection.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/how_it_works.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\n// java.lang.Thread\npublic static native void sleep(long millis);\n\n```\n\nLANGUAGE: java\nCODE:\n```\nprivate static native void $$BlockHound$$_sleep(long millis);\n\n```\n\nLANGUAGE: java\nCODE:\n```\npublic static void sleep(long millis) {\n    $$BlockHound$$_sleep(millis);\n}\n\n```\n\nLANGUAGE: java\nCODE:\n```\npublic static void sleep(long millis) {\n    reactor.blockhound.BlockHoundRuntime.checkBlocking(\n        \"java.lang.Thread\",\n        \"sleep\",\n        /*method modifiers*/\n    );\n    $$BlockHound$$_sleep(millis);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Setting Allowed Status for Specific Methods in BlockHound\nDESCRIPTION: This snippet illustrates how BlockHound temporarily sets the `IS_ALLOWED` ThreadLocal variable to allow blocking calls within specific methods (e.g., `loadClass`). It stores the previous value, sets `IS_ALLOWED` to `true` if it was previously `null`, executes the original call, and then restores the previous value in a `finally` block.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/how_it_works.md#_snippet_4\n\nLANGUAGE: java\nCODE:\n```\nclass ClassLoader {\n    // ...\n\n    public Class<?> loadClass(String name) {\n        Boolean previous = BlockHoundRuntime.IS_ALLOWED.get();\n        BlockHoundRuntime.IS_ALLOWED.set(previous != null ? true : null);\n\n        try {\n            // Original call\n            return loadClass(name, false);\n        } finally {\n            BlockHoundRuntime.IS_ALLOWED.set(previous);\n        }\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Disallow Blocking Calls Inside Methods in Java\nDESCRIPTION: This snippet illustrates how to disallow blocking method calls inside a specified method using `Builder#disallowBlockingCallsInside`. It takes the class name and method name as arguments, preventing blocking calls within that method's execution context unless there is an allowed method further down the stack.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/customization.md#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nbuilder.disallowBlockingCallsInside(\n    \"reactor.core.publisher.Flux\",\n    \"subscribe\"\n);\n```\n\n----------------------------------------\n\nTITLE: Overriding BlockHound Callback for Debugging in Java\nDESCRIPTION: This code snippet demonstrates how to override the default blocking method callback in BlockHound to print stack traces instead of throwing exceptions. This allows for a 'soft mode' where blocking operations are detected without causing the application to fail, aiding in debugging. Requires BlockHound dependency.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/tips.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nBlockHound.install(builder -> {\n    builder.blockingMethodCallback(it -> {\n        new Exception(it.toString()).printStackTrace();\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Maven Dependency Configuration for BlockHound\nDESCRIPTION: This XML snippet configures Maven to include BlockHound as a dependency.  It specifies the groupId, artifactId, and version, using `$LATEST_RELEASE` as a placeholder for the actual version. The dependency will be available during testing.\nSOURCE: https://github.com/reactor/blockhound/blob/master/README.md#_snippet_3\n\nLANGUAGE: xml\nCODE:\n```\n<dependencies>\n  <dependency>\n    <groupId>io.projectreactor.tools</groupId>\n    <artifactId>blockhound</artifactId>\n    <version>$LATEST_RELEASE</version>\n  </dependency>\n</dependencies>\n```\n\n----------------------------------------\n\nTITLE: Gradle Dependency Configuration for BlockHound\nDESCRIPTION: This Groovy snippet configures Gradle to include BlockHound as a test implementation dependency. It specifies Maven Central as the repository and uses the `$LATEST_RELEASE` variable to denote the latest stable release.  It also includes commented-out configurations for milestone and snapshot releases.\nSOURCE: https://github.com/reactor/blockhound/blob/master/README.md#_snippet_1\n\nLANGUAGE: groovy\nCODE:\n```\nrepositories {\n  mavenCentral()\n  // maven { url 'https://repo.spring.io/milestone' }\n  // maven { url 'https://repo.spring.io/snapshot' }\n}\n\ndependencies {\n  testImplementation 'io.projectreactor.tools:blockhound:$LATEST_RELEASE'\n  // testImplementation 'io.projectreactor.tools:blockhound:$LATEST_MILESTONE'\n  // testImplementation 'io.projectreactor.tools:blockhound:$LATEST_SNAPSHOT'\n}\n```\n\n----------------------------------------\n\nTITLE: Gradle Dependency Configuration for BlockHound (Kotlin DSL)\nDESCRIPTION: This Kotlin DSL snippet configures Gradle to include BlockHound as a test implementation dependency. It specifies Maven Central as the repository and uses the `$LATEST_RELEASE` variable to denote the latest stable release. It also includes commented-out configurations for milestone and snapshot releases using the Kotlin syntax.\nSOURCE: https://github.com/reactor/blockhound/blob/master/README.md#_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nrepositories {\n    mavenCentral()\n    // maven(\"https://repo.spring.io/milestone\")\n    // maven(\"https://repo.spring.io/snapshot\")\n}\n\ndependencies {\n    testImplementation(\"io.projectreactor.tools:blockhound:$LATEST_RELEASE\")\n    // testImplementation(\"io.projectreactor.tools:blockhound:$LATEST_MILESTONE\")\n    // testImplementation(\"io.projectreactor.tools:blockhound:$LATEST_SNAPSHOT\")\n}\n```\n\n----------------------------------------\n\nTITLE: Adding BlockHound Dependency with Groovy\nDESCRIPTION: This snippet demonstrates how to add BlockHound as a test dependency in a Groovy-based build file (e.g., Gradle's build.gradle). It retrieves the dependency from Maven Central and potentially milestone/snapshot repositories. The `$LATEST_RELEASE` variable represents the latest stable version of BlockHound.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/quick_start.md#_snippet_0\n\nLANGUAGE: Groovy\nCODE:\n```\nrepositories {\n  mavenCentral()\n  // maven { url 'https://repo.spring.io/milestone' }\n  // maven { url 'https://repo.spring.io/snapshot' }\n}\n\ndependencies {\n  testImplementation 'io.projectreactor.tools:blockhound:$LATEST_RELEASE'\n  // testImplementation 'io.projectreactor.tools:blockhound:$LATEST_MILESTONE'\n  // testImplementation 'io.projectreactor.tools:blockhound:$LATEST_SNAPSHOT'\n}\n```\n\n----------------------------------------\n\nTITLE: Gradle Configuration for JDK13+ support (Groovy)\nDESCRIPTION: This Groovy snippet configures Gradle to add the `-XX:+AllowRedefinitionToAddDeleteMethods` JVM argument for tests running on JDK 13 or higher. It checks the current Java version and adds the argument to the `jvmArgs` property if the version is compatible with Java 13.\nSOURCE: https://github.com/reactor/blockhound/blob/master/README.md#_snippet_5\n\nLANGUAGE: groovy\nCODE:\n```\n    tasks.withType(Test).all {\n        if (JavaVersion.current().isCompatibleWith(JavaVersion.VERSION_13)) {\n            jvmArgs += [\n                \"-XX:+AllowRedefinitionToAddDeleteMethods\"\n            ]\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Maven Configuration for JDK13+ support\nDESCRIPTION: This XML snippet shows how to configure the Maven Surefire Plugin to allow redefinition to add/delete methods for JDK 13+. This is a temporary workaround needed because redefining native methods is no longer allowed. It sets the `argLine` parameter with the `-XX:+AllowRedefinitionToAddDeleteMethods` JVM argument.\nSOURCE: https://github.com/reactor/blockhound/blob/master/README.md#_snippet_4\n\nLANGUAGE: xml\nCODE:\n```\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-surefire-plugin</artifactId>\n                <version>2.22.2</version>\n                <configuration>\n                    <argLine>-XX:+AllowRedefinitionToAddDeleteMethods</argLine>\n                </configuration>\n    </plugin>\n```\n\n----------------------------------------\n\nTITLE: Enabling Redefinition for JDK 13+ in Maven\nDESCRIPTION: This snippet shows how to configure the Maven Surefire plugin to include the `-XX:+AllowRedefinitionToAddDeleteMethods` JVM argument. This is necessary for running BlockHound with JDK 13 and later due to restrictions on redefining native methods.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/quick_start.md#_snippet_1\n\nLANGUAGE: XML\nCODE:\n```\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-surefire-plugin</artifactId>\n                <version>2.22.2</version>\n                <configuration>\n                    <argLine>-XX:+AllowRedefinitionToAddDeleteMethods</argLine>\n                </configuration>\n    </plugin>\n```\n\n----------------------------------------\n\nTITLE: Enabling Redefinition for JDK 13+ in Gradle\nDESCRIPTION: This snippet configures Gradle test tasks to include the `-XX:+AllowRedefinitionToAddDeleteMethods` JVM argument when running on JDK 13 or later. It checks the current Java version and conditionally adds the argument.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/quick_start.md#_snippet_2\n\nLANGUAGE: Groovy\nCODE:\n```\n    tasks.withType(Test).all {\n        if (JavaVersion.current().isCompatibleWith(JavaVersion.VERSION_13)) {\n            jvmArgs += [\n                \"-XX:+AllowRedefinitionToAddDeleteMethods\"\n            ]\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Gradle Configuration for JDK13+ support (Kotlin DSL)\nDESCRIPTION: This Kotlin DSL snippet configures Gradle to add the `-XX:+AllowRedefinitionToAddDeleteMethods` JVM argument for tests running on JDK 13 or higher. It checks the current Java version and adds the argument to the `jvmArgs` property if the version is compatible with Java 13. It uses the Kotlin syntax for task configuration.\nSOURCE: https://github.com/reactor/blockhound/blob/master/README.md#_snippet_6\n\nLANGUAGE: kotlin\nCODE:\n```\ntasks.withType<Test>().all {\n    if (JavaVersion.current().isCompatibleWith(JavaVersion.VERSION_13)) {\n        jvmArgs(\"-XX:+AllowRedefinitionToAddDeleteMethods\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Add BlockHound JUnit Platform Dependency (Groovy)\nDESCRIPTION: Adds the BlockHound JUnit Platform artifact as a dependency in a Groovy-based project (e.g., Gradle).  This automatically registers and executes the BlockHound TestExecutionListener within the JUnit Platform. Version needs to be defined or substituted by a project property.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/supported_testing_frameworks.md#_snippet_0\n\nLANGUAGE: groovy\nCODE:\n```\n'io.projectreactor.tools:blockhound-junit-platform:$VERSION'\n```\n\n----------------------------------------\n\nTITLE: Activating BlockHound via JVM Option\nDESCRIPTION: This shell command shows how to activate BlockHound using the `-javaagent` JVM option.  It specifies the path to the BlockHound agent jar.  This method is used when application code cannot be modified. JPMS (Java Platform Module System) requires this activation method.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/quick_start.md#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\njava -javaagent:BlockHound/agent/build/libs/agent.jar -jar my-application.jar\n```\n\n----------------------------------------\n\nTITLE: Integrating with AutoService in Java\nDESCRIPTION: Demonstrates using Google's AutoService annotation processor to automatically register a BlockHound integration. This simplifies the process of creating META-INF/services entries.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/custom_integrations.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n@AutoService(BlockHoundIntegration.class)\npublic class MyIntegration implements BlockHoundIntegration {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring BlockHound with Cargo Maven Plugin\nDESCRIPTION: This snippet demonstrates how to configure the Cargo Maven plugin to include BlockHound in Tomcat's shared lib directory. This avoids embedding BlockHound within the web application and allows it to function correctly in the Tomcat environment. The dependency scope is set to 'provided'.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/quick_start.md#_snippet_3\n\nLANGUAGE: XML\nCODE:\n```\n    <dependencies>\n        <dependency>\n            <groupId>io.projectreactor.tools</groupId>\n            <artifactId>blockhound</artifactId>\n            <version>(latest blockhound version)</version>\n            <scope>provided</scope>\n        </dependency>\n        ...\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.codehaus.cargo</groupId>\n                <artifactId>cargo-maven3-plugin</artifactId>\n                <version>1.10.4</version>\n                <configuration>\n                    <container>\n                        <containerId>tomcat9x</containerId>\n                        <type>embedded</type>\n                        <dependencies>\n                            <dependency>\n                                <groupId>io.projectreactor.tools</groupId>\n                                <artifactId>blockhound</artifactId>\n                                <classpath>shared</classpath>\n                            </dependency>\n                        </dependencies>\n                    </container>\n                    <deployables>\n                        <deployable>\n                            <type>war</type>\n                            <location>${project.build.directory}/${project.build.finalName}.war</location>\n                            <properties>\n                                <context>/</context>\n                            </properties>\n                        </deployable>\n                    </deployables>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n    ...\n```\n\n----------------------------------------\n\nTITLE: Example Whitelist Classes in Java\nDESCRIPTION: These classes are used to demonstrate a scenario where careful whitelisting is needed to prevent false positives. `OperationRunnable` and `TaskRunner` are used as examples of classes involved in blocking calls. Whitelisting common methods in these classes may lead to ignoring true blocking calls.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/tips.md#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nclass OperationRunnable implements Runnable {\n\n    TaskRunner runner;\n\n    public void run() {\n        while (true) {\n            runner.run();\n        }\n    }\n}\n\nclass TaskRunner {\n\n    TaskExecutor executor;\n\n    public void run() {\n        var task = executor.takeTask();\n\n        task.run();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ThreadLocal Variable for Blocking Call Allowance\nDESCRIPTION: This code snippet shows the definition of the `IS_ALLOWED` ThreadLocal variable. It is initialized with a predicate that tests the current thread. If the thread is non-blocking, the initial value is `false` (blocking calls not allowed). Otherwise, it is initialized to `null`, representing a state where blocking is not explicitly disallowed.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/how_it_works.md#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\npublic static final ThreadLocal<Boolean> IS_ALLOWED = ThreadLocal.withInitial(() -> {\n    if (threadPredicate.test(Thread.currentThread())) {\n        return false;\n    }\n    else {\n        // Optimization: use Three-state (true, false, null) where `null` is `not non-blocking`\n        return null;\n    }\n});\n\n```\n\n----------------------------------------\n\nTITLE: Example Stacktrace in Java\nDESCRIPTION: This is an example stack trace used to illustrate the process of selecting the most specific method to whitelist in BlockHound. The suggestion is to whitelist `TaskExecutor#takeTask` as it's a blocking method related to task polling logic and doesn't directly call user-provided code.\nSOURCE: https://github.com/reactor/blockhound/blob/master/docs/tips.md#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\njava.lang.Error: sun.misc.Unsafe#park\n    at sun.misc.Unsafe.park(Unsafe.java)\n    at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)\n    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)\n    at java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:467)\n    at com.example.TaskExecutor.takeTask(GlobalEventExecutor.java:95)\n    at com.example.TaskExecutor$TaskRunner.run(GlobalEventExecutor.java:239)\n    at com.example.OperationRunnable.run(OperationRunnable.java:30)\n    at com.example.NonBlockingThread.run(NonBlockingThread.java:18)\n```"
  }
]