[
  {
    "owner": "reduxjs",
    "repo": "redux-toolkit",
    "content": "TITLE: Complete Redux Toolkit Store Implementation\nDESCRIPTION: Comprehensive example demonstrating createSlice usage with multiple slices, actions, reducers, and store configuration.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createSlice.mdx#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSlice, createAction, configureStore } from '@reduxjs/toolkit'\nimport type { PayloadAction } from '@reduxjs/toolkit'\nimport { combineReducers } from 'redux'\n\nconst incrementBy = createAction<number>('incrementBy')\nconst decrementBy = createAction<number>('decrementBy')\n\nconst counter = createSlice({\n  name: 'counter',\n  initialState: 0 satisfies number as number,\n  reducers: {\n    increment: (state) => state + 1,\n    decrement: (state) => state - 1,\n    multiply: {\n      reducer: (state, action: PayloadAction<number>) => state * action.payload,\n      prepare: (value?: number) => ({ payload: value || 2 }), // fallback if the payload is a falsy value\n    },\n  },\n  extraReducers: (builder) => {\n    builder.addCase(incrementBy, (state, action) => {\n      return state + action.payload\n    })\n    builder.addCase(decrementBy, (state, action) => {\n      return state - action.payload\n    })\n  },\n})\n\nconst user = createSlice({\n  name: 'user',\n  initialState: { name: '', age: 20 },\n  reducers: {\n    setUserName: (state, action) => {\n      state.name = action.payload // mutate the state all you want with immer\n    },\n  },\n  extraReducers: (builder) => {\n    builder.addCase(counter.actions.increment, (state, action) => {\n      state.age += 1\n    })\n  },\n})\n\nconst store = configureStore({\n  reducer: {\n    counter: counter.reducer,\n    user: user.reducer,\n  },\n})\n\nstore.dispatch(counter.actions.increment())\n// -> { counter: 1, user: {name : '', age: 21} }\nstore.dispatch(counter.actions.increment())\n// -> { counter: 2, user: {name: '', age: 22} }\nstore.dispatch(counter.actions.multiply(3))\n// -> { counter: 6, user: {name: '', age: 22} }\nstore.dispatch(counter.actions.multiply())\n// -> { counter: 12, user: {name: '', age: 22} }\nconsole.log(counter.actions.decrement.type)\n// -> \"counter/decrement\"\nstore.dispatch(user.actions.setUserName('eric'))\n// -> { counter: 12, user: { name: 'eric', age: 22} }\n```\n\n----------------------------------------\n\nTITLE: Creating a Redux Slice with TypeScript\nDESCRIPTION: This snippet demonstrates how to create a Redux slice using createSlice. It defines a counter slice with increment, decrement, and incrementByAmount reducers, and exports the generated actions and reducer.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createSlice.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSlice } from '@reduxjs/toolkit'\nimport type { PayloadAction } from '@reduxjs/toolkit'\n\ninterface CounterState {\n  value: number\n}\n\nconst initialState = { value: 0 } satisfies CounterState as CounterState\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState,\n  reducers: {\n    increment(state) {\n      state.value++\n    },\n    decrement(state) {\n      state.value--\n    },\n    incrementByAmount(state, action: PayloadAction<number>) {\n      state.value += action.payload\n    },\n  },\n})\n\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions\nexport default counterSlice.reducer\n```\n\n----------------------------------------\n\nTITLE: Installing Redux Toolkit in an existing app using npm\nDESCRIPTION: Command to install Redux Toolkit package using npm in an existing application, with an additional command for installing React bindings if needed.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/introduction/getting-started.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @reduxjs/toolkit\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm install react-redux\n```\n\n----------------------------------------\n\nTITLE: Defining Query Endpoints with All Options in TypeScript\nDESCRIPTION: Example showing all available options when configuring a query endpoint using RTK Query, including transformResponse, transformErrorResponse, providesTags, and lifecycle callbacks.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/queries.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// file: types.ts noEmit\nexport interface Post {\n  id: number\n  name: string\n}\n\n// file: api.ts\n// Or from '@reduxjs/toolkit/query/react'\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { Post } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post'],\n  endpoints: (build) => ({\n    // highlight-start\n    // The query accepts a number and returns a Post\n    getPost: build.query<Post, number>({\n      // note: an optional `queryFn` may be used in place of `query`\n      query: (id) => ({ url: `post/${id}` }),\n      // Pick out data and prevent nested properties in a hook or selector\n      transformResponse: (response: { data: Post }, meta, arg) => response.data,\n      // Pick out errors and prevent nested properties in a hook or selector\n      transformErrorResponse: (\n        response: { status: string | number },\n        meta,\n        arg,\n      ) => response.status,\n      providesTags: (result, error, id) => [{ type: 'Post', id }],\n      // The 2nd parameter is the destructured `QueryLifecycleApi`\n      async onQueryStarted(\n        arg,\n        {\n          dispatch,\n          getState,\n          extra,\n          requestId,\n          queryFulfilled,\n          getCacheEntry,\n          updateCachedData,\n        },\n      ) {},\n      // The 2nd parameter is the destructured `QueryCacheLifecycleApi`\n      async onCacheEntryAdded(\n        arg,\n        {\n          dispatch,\n          getState,\n          extra,\n          requestId,\n          cacheEntryRemoved,\n          cacheDataLoaded,\n          getCacheEntry,\n          updateCachedData,\n        },\n      ) {},\n      // highlight-end\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Advanced Redux Store Configuration with Redux Toolkit in TypeScript\nDESCRIPTION: A comprehensive example demonstrating advanced Redux store configuration with multiple reducers, custom middleware (redux-logger), enhancers (redux-batched-subscribe), preloaded state, and conditional DevTools enabling. Shows how to customize the default configuration options.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/configureStore.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// file: todos/todosReducer.ts noEmit\nimport type { Reducer } from '@reduxjs/toolkit'\ndeclare const reducer: Reducer<{}>\nexport default reducer\n\n// file: visibility/visibilityReducer.ts noEmit\nimport type { Reducer } from '@reduxjs/toolkit'\ndeclare const reducer: Reducer<{}>\nexport default reducer\n\n// file: store.ts\nimport { configureStore } from '@reduxjs/toolkit'\n\n// We'll use redux-logger just as an example of adding another middleware\nimport logger from 'redux-logger'\n\n// And use redux-batched-subscribe as an example of adding enhancers\nimport { batchedSubscribe } from 'redux-batched-subscribe'\n\nimport todosReducer from './todos/todosReducer'\nimport visibilityReducer from './visibility/visibilityReducer'\n\nconst reducer = {\n  todos: todosReducer,\n  visibility: visibilityReducer,\n}\n\nconst preloadedState = {\n  todos: [\n    {\n      text: 'Eat food',\n      completed: true,\n    },\n    {\n      text: 'Exercise',\n      completed: false,\n    },\n  ],\n  visibilityFilter: 'SHOW_COMPLETED',\n}\n\nconst debounceNotify = _.debounce((notify) => notify())\n\nconst store = configureStore({\n  reducer,\n  middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(logger),\n  devTools: process.env.NODE_ENV !== 'production',\n  preloadedState,\n  enhancers: (getDefaultEnhancers) =>\n    getDefaultEnhancers({\n      autoBatch: false,\n    }).concat(batchedSubscribe(debounceNotify)),\n})\n\n// The store has been created with these options:\n// - The slice reducers were automatically passed to combineReducers()\n// - redux-thunk and redux-logger were added as middleware\n// - The Redux DevTools Extension is disabled for production\n// - The middleware, batched subscribe, and devtools enhancers were composed together\n```\n\n----------------------------------------\n\nTITLE: Installing Redux Toolkit and React-Redux\nDESCRIPTION: Command to install the necessary packages for using Redux Toolkit with React.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/tutorials/quick-start.mdx#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @reduxjs/toolkit react-redux\n```\n\n----------------------------------------\n\nTITLE: Implementing RTK Query in React Component\nDESCRIPTION: Demonstrates using RTK Query hooks in a React component to fetch and display Pokemon data, including loading and error states.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/tutorials/rtk-query.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as React from 'react'\nimport { useGetPokemonByNameQuery } from './services/pokemon'\n\nexport default function App() {\n  const { data, error, isLoading } = useGetPokemonByNameQuery('bulbasaur')\n\n  return (\n    <div className=\"App\">\n      {error ? (\n        <>Oh no, there was an error</>\n      ) : isLoading ? (\n        <>Loading...</>\n      ) : data ? (\n        <>\n          <h3>{data.species.name}</h3>\n          <img src={data.sprites.front_shiny} alt={data.species.name} />\n        </>\n      ) : null}\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an RTK Query API Slice\nDESCRIPTION: Demonstrates how to create an API slice with createApi, defining the base URL and endpoints for data fetching. Shows configuration of a Pokemon API example with TypeScript types.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/overview.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport type { Pokemon } from './types'\n\n// Define a service using a base URL and expected endpoints\nexport const pokemonApi = createApi({\n  reducerPath: 'pokemonApi',\n  baseQuery: fetchBaseQuery({ baseUrl: 'https://pokeapi.co/api/v2/' }),\n  endpoints: (build) => ({\n    getPokemonByName: build.query<Pokemon, string>({\n      query: (name) => `pokemon/${name}`,\n    }),\n  }),\n})\n\n// Export hooks for usage in functional components, which are\n// auto-generated based on the defined endpoints\nexport const { useGetPokemonByNameQuery } = pokemonApi\n```\n\n----------------------------------------\n\nTITLE: useMutation Hook Usage Example\nDESCRIPTION: Example showing how to access and use the useMutation hook in RTK Query, demonstrating both the direct API endpoint access and generated hook methods.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/hooks.mdx#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst useMutationResult = api.endpoints.updatePost.useMutation(options)\n// or\nconst useMutationResult = api.useUpdatePostMutation(options)\n```\n\n----------------------------------------\n\nTITLE: Defining and Exporting Auto-generated React Hooks in TypeScript\nDESCRIPTION: This snippet demonstrates how to create an API slice using createApi, define a typed endpoint, and export the auto-generated React hook for use in components.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage-with-typescript.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport type { Pokemon } from './types'\n\nexport const pokemonApi = createApi({\n  reducerPath: 'pokemonApi',\n  baseQuery: fetchBaseQuery({ baseUrl: 'https://pokeapi.co/api/v2/' }),\n  endpoints: (build) => ({\n    getPokemonByName: build.query<Pokemon, string>({\n      query: (name) => `pokemon/${name}`,\n    }),\n  }),\n})\n\nexport const { useGetPokemonByNameQuery } = pokemonApi\n```\n\n----------------------------------------\n\nTITLE: Installing Redux Toolkit in an existing app using yarn\nDESCRIPTION: Command to install Redux Toolkit package using yarn in an existing application, with an additional command for installing React bindings if needed.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/introduction/getting-started.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @reduxjs/toolkit\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add react-redux\n```\n\n----------------------------------------\n\nTITLE: Configuring Redux Store with Redux Toolkit in JavaScript\nDESCRIPTION: This code snippet shows how to set up a Redux store using Redux Toolkit's configureStore function. It demonstrates how to combine multiple reducers and automatically applies default middleware and enhancers.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/introduction/why-rtk-is-redux-today.md#2025-04-17_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { configureStore } from '@reduxjs/toolkit'\nimport todosReducer from '../features/todos/todosSlice'\nimport filtersReducer from '../features/filters/filtersSlice'\n\nexport const store = configureStore({\n  reducer: {\n    todos: todosReducer,\n    filters: filtersReducer,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Defining an API Slice with createApi in TypeScript\nDESCRIPTION: This example demonstrates how to use createApi to define an API slice for fetching Pokemon data. It sets up a base URL, defines an endpoint for getting a Pokemon by name, and exports a generated hook for use in React components.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/createApi.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Need to use the React-specific entry point to allow generating React hooks\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport type { Pokemon } from './types'\n\n// Define a service using a base URL and expected endpoints\nexport const pokemonApi = createApi({\n  reducerPath: 'pokemonApi',\n  baseQuery: fetchBaseQuery({ baseUrl: 'https://pokeapi.co/api/v2/' }),\n  endpoints: (build) => ({\n    getPokemonByName: build.query<Pokemon, string>({\n      query: (name) => `pokemon/${name}`,\n    }),\n  }),\n})\n\n// Export hooks for usage in function components, which are\n// auto-generated based on the defined endpoints\nexport const { useGetPokemonByNameQuery } = pokemonApi\n```\n\n----------------------------------------\n\nTITLE: Creating Pokemon API Service with RTK Query\nDESCRIPTION: Sets up an RTK Query service for fetching Pokemon data from PokeAPI. Defines the base URL and endpoints using createApi, and exports auto-generated React hooks for use in components.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/tutorials/rtk-query.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport type { Pokemon } from './types'\n\nexport const pokemonApi = createApi({\n  reducerPath: 'pokemonApi',\n  baseQuery: fetchBaseQuery({ baseUrl: 'https://pokeapi.co/api/v2/' }),\n  endpoints: (builder) => ({\n    getPokemonByName: builder.query<Pokemon, string>({\n      query: (name) => `pokemon/${name}`,\n    }),\n  }),\n})\n\nexport const { useGetPokemonByNameQuery } = pokemonApi\n```\n\n----------------------------------------\n\nTITLE: Implementing CRUD Operations with Redux Toolkit Query\nDESCRIPTION: Creates a CRUD service for Posts using Redux Toolkit Query with automatic cache invalidation. Implements endpoints for getting all posts, adding, updating, deleting and fetching individual posts with proper cache tag management.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/mutations.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n\nexport interface Post {\n  id: number\n  name: string\n}\n\ntype PostsResponse = Post[]\n\nexport const postApi = createApi({\n  reducerPath: 'postsApi',\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Posts'],\n  endpoints: (build) => ({\n    getPosts: build.query<PostsResponse, void>({\n      query: () => 'posts',\n      providesTags: (result) =>\n        result\n          ? [\n              ...result.map(({ id }) => ({ type: 'Posts', id }) as const),\n              { type: 'Posts', id: 'LIST' },\n            ]\n          : [{ type: 'Posts', id: 'LIST' }],\n    }),\n    addPost: build.mutation<Post, Partial<Post>>({\n      query(body) {\n        return {\n          url: `post`,\n          method: 'POST',\n          body,\n        }\n      },\n      invalidatesTags: [{ type: 'Posts', id: 'LIST' }],\n    }),\n    getPost: build.query<Post, number>({\n      query: (id) => `post/${id}`,\n      providesTags: (result, error, id) => [{ type: 'Posts', id }],\n    }),\n    updatePost: build.mutation<Post, Partial<Post>>({\n      query(data) {\n        const { id, ...body } = data\n        return {\n          url: `post/${id}`,\n          method: 'PUT',\n          body,\n        }\n      },\n      invalidatesTags: (result, error, { id }) => [{ type: 'Posts', id }],\n    }),\n    deletePost: build.mutation<{ success: boolean; id: number }, number>({\n      query(id) {\n        return {\n          url: `post/${id}`,\n          method: 'DELETE',\n        }\n      },\n      invalidatesTags: (result, error, id) => [{ type: 'Posts', id }],\n    }),\n  }),\n})\n\nexport const {\n  useGetPostsQuery,\n  useAddPostMutation,\n  useGetPostQuery,\n  useUpdatePostMutation,\n  useDeletePostMutation,\n} = postApi\n```\n\n----------------------------------------\n\nTITLE: Installing Redux Toolkit with Vite or Next.js\nDESCRIPTION: Commands for creating a new React Redux app using official templates for Vite or Next.js.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/toolkit/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Vite with our Redux+TS template\n# (using the `degit` tool to clone and extract the template)\nnpx degit reduxjs/redux-templates/packages/vite-template-redux my-app\n\n# Next.js using the `with-redux` template\nnpx create-next-app --example with-redux my-app\n```\n\n----------------------------------------\n\nTITLE: Implementing Core Redux Toolkit Functions in TypeScript\nDESCRIPTION: This snippet defines core functions used in Redux Toolkit, including buildCreateApi, copyWithStructuralSharing, coreModule, and createApi. These functions are essential for setting up and configuring Redux APIs.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/toolkit/etc/rtk-query.api.md#2025-04-17_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n// @public\nexport function buildCreateApi<Modules extends [Module<any>, ...Module<any>[]]>(\n  ...modules: Modules\n): CreateApi<Modules[number]['name']>\n\n// @public (undocumented)\nexport function copyWithStructuralSharing<T>(oldObj: any, newObj: T): T\n\n// @public\nexport const coreModule: () => Module<CoreModule>\n\n// @public (undocumented)\nexport type CreateApi<Modules extends ModuleName> = {\n  <\n    BaseQuery extends BaseQueryFn,\n    Definitions extends EndpointDefinitions,\n    ReducerPath extends string = 'api',\n    TagTypes extends string = never,\n  >(\n    options: CreateApiOptions<BaseQuery, Definitions, ReducerPath, TagTypes>,\n  ): Api<BaseQuery, Definitions, ReducerPath, TagTypes, Modules>\n}\n\n// @public (undocumented)\nexport const createApi: CreateApi<typeof coreModuleName>\n```\n\n----------------------------------------\n\nTITLE: CreateReducer Implementation with Builder Pattern\nDESCRIPTION: Modern implementation of a counter reducer using createReducer with TypeScript and builder callback pattern.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createReducer.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAction, createReducer } from '@reduxjs/toolkit'\n\ninterface CounterState {\n  value: number\n}\n\nconst increment = createAction('counter/increment')\nconst decrement = createAction('counter/decrement')\nconst incrementByAmount = createAction<number>('counter/incrementByAmount')\n\nconst initialState = { value: 0 } satisfies CounterState as CounterState\n\nconst counterReducer = createReducer(initialState, (builder) => {\n  builder\n    .addCase(increment, (state, action) => {\n      state.value++\n    })\n    .addCase(decrement, (state, action) => {\n      state.value--\n    })\n    .addCase(incrementByAmount, (state, action) => {\n      state.value += action.payload\n    })\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Redux Store with TypeScript\nDESCRIPTION: Sets up the Redux store using configureStore and defines root state and dispatch types for TypeScript integration.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/tutorials/typescript.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configureStore } from '@reduxjs/toolkit'\n\nexport const store = configureStore({\n  reducer: {\n    posts: postsReducer,\n    comments: commentsReducer,\n    users: usersReducer,\n  },\n})\n\nexport type RootState = ReturnType<typeof store.getState>\nexport type AppDispatch = typeof store.dispatch\n```\n\n----------------------------------------\n\nTITLE: Configuring Redux Store with RTK Query\nDESCRIPTION: Shows how to set up a Redux store with RTK Query by adding the API reducer and middleware. Includes setup of optional listeners for refetch behaviors.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/overview.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configureStore } from '@reduxjs/toolkit'\n// Or from '@reduxjs/toolkit/query/react'\nimport { setupListeners } from '@reduxjs/toolkit/query'\nimport { pokemonApi } from './services/pokemon'\n\nexport const store = configureStore({\n  reducer: {\n    // Add the generated reducer as a specific top-level slice\n    [pokemonApi.reducerPath]: pokemonApi.reducer,\n  },\n  // Adding the api middleware enables caching, invalidation, polling,\n  // and other useful features of `rtk-query`.\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware().concat(pokemonApi.middleware),\n})\n\n// optional, but required for refetchOnFocus/refetchOnReconnect behaviors\n// see `setupListeners` docs - takes an optional callback as the 2nd arg for customization\nsetupListeners(store.dispatch)\n```\n\n----------------------------------------\n\nTITLE: Implementing WebSocket Chat API with Streaming Updates in RTK Query\nDESCRIPTION: This snippet demonstrates how to implement a WebSocket-based chat API using RTK Query's streaming updates feature. It shows the creation of an API slice with a getMessages query that uses onCacheEntryAdded to establish and manage a WebSocket connection for real-time updates.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/streaming-updates.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport { isMessage } from './schemaValidators'\n\nexport type Channel = 'redux' | 'general'\n\nexport interface Message {\n  id: number\n  channel: Channel\n  userName: string\n  text: string\n}\n\nexport const api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getMessages: build.query<Message[], Channel>({\n      query: (channel) => `messages/${channel}`,\n      async onCacheEntryAdded(\n        arg,\n        { updateCachedData, cacheDataLoaded, cacheEntryRemoved },\n      ) {\n        const ws = new WebSocket('ws://localhost:8080')\n        try {\n          await cacheDataLoaded\n\n          const listener = (event: MessageEvent) => {\n            const data = JSON.parse(event.data)\n            if (!isMessage(data) || data.channel !== arg) return\n\n            updateCachedData((draft) => {\n              draft.push(data)\n            })\n          }\n\n          ws.addEventListener('message', listener)\n        } catch {\n          // no-op in case `cacheEntryRemoved` resolves before `cacheDataLoaded`,\n          // in which case `cacheDataLoaded` will throw\n        }\n        await cacheEntryRemoved\n        ws.close()\n      },\n    }),\n  }),\n})\n\nexport const { useGetMessagesQuery } = api\n```\n\n----------------------------------------\n\nTITLE: Using RTK Query Mutation Hooks in React Components\nDESCRIPTION: This example shows how to use the useUpdatePostMutation hook in a component to update a post's name. It demonstrates how to trigger the mutation and use the loading state from the mutation result.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/mutations.mdx#2025-04-17_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nexport const PostDetail = () => {\n  const { id } = useParams<{ id: any }>()\n\n  const { data: post } = useGetPostQuery(id)\n\n  const [\n    updatePost, // This is the mutation trigger\n    { isLoading: isUpdating }, // This is the destructured mutation result\n  ] = useUpdatePostMutation()\n\n  return (\n    <Box p={4}>\n      <EditablePostName\n        name={post.name}\n        onUpdate={(name) => {\n          // If you want to immediately access the result of a mutation, you need to chain `.unwrap()`\n          // if you actually want the payload or to catch the error.\n          // Example: `updatePost().unwrap().then(fulfilled => console.log(fulfilled)).catch(rejected => console.error(rejected))\n\n          return (\n            // Execute the trigger with the `id` and updated `name`\n            updatePost({ id, name })\n          )\n        }}\n        isLoading={isUpdating}\n      />\n    </Box>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Mutation Endpoint in RTK Query with TypeScript\nDESCRIPTION: This example demonstrates all available options when defining a mutation endpoint using RTK Query's createApi and build.mutation. It includes query configuration, response transformation, error handling, cache invalidation, and lifecycle callbacks.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/mutations.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { Post } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post'],\n  endpoints: (build) => ({\n    // The mutation accepts a `Partial<Post>` arg, and returns a `Post`\n    updatePost: build.mutation<Post, Partial<Post> & Pick<Post, 'id'>>({ \n      // note: an optional `queryFn` may be used in place of `query`\n      query: ({ id, ...patch }) => ({\n        url: `post/${id}`,\n        method: 'PATCH',\n        body: patch,\n      }),\n      // Pick out data and prevent nested properties in a hook or selector\n      transformResponse: (response: { data: Post }, meta, arg) => response.data,\n      // Pick out errors and prevent nested properties in a hook or selector\n      transformErrorResponse: (\n        response: { status: string | number },\n        meta,\n        arg,\n      ) => response.status,\n      invalidatesTags: ['Post'],\n      // onQueryStarted is useful for optimistic updates\n      // The 2nd parameter is the destructured `MutationLifecycleApi`\n      async onQueryStarted(\n        arg,\n        { dispatch, getState, queryFulfilled, requestId, extra, getCacheEntry },\n      ) {},\n      // The 2nd parameter is the destructured `MutationCacheLifecycleApi`\n      async onCacheEntryAdded(\n        arg,\n        {\n          dispatch,\n          getState,\n          extra,\n          requestId,\n          cacheEntryRemoved,\n          cacheDataLoaded,\n          getCacheEntry,\n        },\n      ) {},\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Authentication with RTK Query in React\nDESCRIPTION: This example demonstrates how to handle authentication using RTK Query in a React application. It shows setting a JWT from a login mutation and using prepareHeaders to inject authentication headers into subsequent requests.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/examples.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Example code not provided in the original text\n```\n\n----------------------------------------\n\nTITLE: Creating Redux Store Factory for Next.js\nDESCRIPTION: Demonstrates how to create a Redux store factory function for Next.js that creates a new store instance per request, along with TypeScript type definitions for the store, state, and dispatch.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/usage/nextjs.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configureStore } from '@reduxjs/toolkit'\n\nexport const makeStore = () => {\n  return configureStore({\n    reducer: {},\n  })\n}\n\n// Infer the type of makeStore\nexport type AppStore = ReturnType<typeof makeStore>\n// Infer the `RootState` and `AppDispatch` types from the store itself\nexport type RootState = ReturnType<AppStore['getState']>\nexport type AppDispatch = AppStore['dispatch']\n```\n\n----------------------------------------\n\nTITLE: Creating Typed Redux Hooks\nDESCRIPTION: Defines typed versions of useDispatch and useSelector hooks for better TypeScript integration with Redux.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/tutorials/typescript.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useDispatch, useSelector } from 'react-redux'\nimport type { RootState, AppDispatch } from './store'\n\nexport const useAppDispatch = useDispatch.withTypes<AppDispatch>()\nexport const useAppSelector = useSelector.withTypes<RootState>()\n```\n\n----------------------------------------\n\nTITLE: Implementing Auth Token Refresh with Mutex in Redux Toolkit Query\nDESCRIPTION: Shows how to use async-mutex to prevent multiple simultaneous refresh token calls when handling 401 Unauthorized errors. Implements a reusable base query wrapper that handles token refresh logic.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/customizing-queries.mdx#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type {\n  BaseQueryFn,\n  FetchArgs,\n  FetchBaseQueryError,\n} from '@reduxjs/toolkit/query'\nimport { tokenReceived, loggedOut } from './authSlice'\nimport { Mutex } from 'async-mutex'\n\nconst mutex = new Mutex()\nconst baseQuery = fetchBaseQuery({ baseUrl: '/' })\nconst baseQueryWithReauth: BaseQueryFn<\n  string | FetchArgs,\n  unknown,\n  FetchBaseQueryError\n> = async (args, api, extraOptions) => {\n  await mutex.waitForUnlock()\n  let result = await baseQuery(args, api, extraOptions)\n  if (result.error && result.error.status === 401) {\n    if (!mutex.isLocked()) {\n      const release = await mutex.acquire()\n      try {\n        const refreshResult = await baseQuery(\n          '/refreshToken',\n          api,\n          extraOptions,\n        )\n        if (refreshResult.data) {\n          api.dispatch(tokenReceived(refreshResult.data))\n          result = await baseQuery(args, api, extraOptions)\n        } else {\n          api.dispatch(loggedOut())\n        }\n      } finally {\n        release()\n      }\n    } else {\n      await mutex.waitForUnlock()\n      result = await baseQuery(args, api, extraOptions)\n    }\n  }\n  return result\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Redux Store with TypeScript\nDESCRIPTION: Sets up a Redux store using configureStore from Redux Toolkit. It also exports TypeScript types for the root state and dispatch.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/tutorials/quick-start.mdx#2025-04-17_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { configureStore } from '@reduxjs/toolkit'\n\nexport const store = configureStore({\n  reducer: {},\n})\n\n// Infer the `RootState` and `AppDispatch` types from the store itself\nexport type RootState = ReturnType<typeof store.getState>\n// Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState}\nexport type AppDispatch = typeof store.dispatch\n```\n\n----------------------------------------\n\nTITLE: Implementing Schema Validation in Redux Toolkit Query with TypeScript\nDESCRIPTION: Demonstrates how to use valibot schema validation in Redux Toolkit Query endpoints. Shows validation for both direct responses and transformed responses, including type inference for TypeScript. Features examples of validating POST requests and handling transformed data with dates.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/queries.mdx#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport * as v from 'valibot'\n\nconst postSchema = v.object({\n  id: v.number(),\n  name: v.string(),\n})\ntype Post = v.InferOutput<typeof postSchema>\nconst transformedPost = v.object({\n  ...postSchema.entries,\n  published_at: v.date(),\n})\ntype TransformedPost = v.InferOutput<typeof transformedPost>\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getPost: build.query<Post, { id: number }>({\n      query: ({ id }) => `/post/${id}`,\n      responseSchema: postSchema,\n    }),\n    getTransformedPost: build.query<TransformedPost, { id: number }>({\n      query: ({ id }) => `/post/${id}`,\n      rawResponseSchema: postSchema,\n      transformResponse: (response) => ({\n        ...response,\n        published_at: new Date(response.published_at),\n      }),\n      // responseSchema can still be provided, to validate the transformed response\n      responseSchema: transformedPost,\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Using Redux State and Actions in React Component\nDESCRIPTION: Creates a Counter component that uses useSelector to read state and useDispatch to dispatch actions from the Redux store.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/tutorials/quick-start.mdx#2025-04-17_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nimport React from 'react'\nimport type { RootState } from '../../app/store'\nimport { useSelector, useDispatch } from 'react-redux'\nimport { decrement, increment } from './counterSlice'\n\nexport function Counter() {\n  const count = useSelector((state: RootState) => state.counter.value)\n  const dispatch = useDispatch()\n\n  return (\n    <div>\n      <div>\n        <button\n          aria-label=\"Increment value\"\n          onClick={() => dispatch(increment())}\n        >\n          Increment\n        </button>\n        <span>{count}</span>\n        <button\n          aria-label=\"Decrement value\"\n          onClick={() => dispatch(decrement())}\n        >\n          Decrement\n        </button>\n      </div>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Slices and Creating Store with Redux Toolkit\nDESCRIPTION: Demonstrates how to use combineSlices to combine multiple slices and API instances, then use the resulting rootReducer to configure a Redux store.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/combineSlices.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// file: slices/index.ts\nimport { combineSlices } from '@reduxjs/toolkit'\nimport { api } from './api'\nimport { userSlice } from './users'\n\nexport const rootReducer = combineSlices(api, userSlice)\n\n// file: store.ts\nimport { configureStore } from '@reduxjs/toolkit'\nimport { rootReducer } from './slices'\n\nexport const store = configureStore({\n  reducer: rootReducer,\n})\n```\n\n----------------------------------------\n\nTITLE: Using AbortSignal with Fetch API in Redux Toolkit Thunk\nDESCRIPTION: This example shows how to use the AbortSignal with the Fetch API in a Redux Toolkit thunk to support cancellation of asynchronous actions.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAsyncThunk.mdx#2025-04-17_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAsyncThunk } from '@reduxjs/toolkit'\n\nconst fetchUserById = createAsyncThunk(\n  'users/fetchById',\n  async (userId: string, thunkAPI) => {\n    const response = await fetch(`https://reqres.in/api/users/${userId}`, {\n      signal: thunkAPI.signal,\n    })\n    return await response.json()\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing pagination UI with React and RTK Query\nDESCRIPTION: React component that implements pagination UI using RTK Query. Uses useState to track the current page and the useListPostsQuery hook to fetch paginated data. Includes navigation buttons to move between pages.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/pagination.mdx#2025-04-17_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst PostList = () => {\n  const [page, setPage] = useState(1)\n  const { data: posts, isLoading, isFetching } = useListPostsQuery(page)\n\n  if (isLoading) {\n    return <div>Loading</div>\n  }\n\n  if (!posts?.data) {\n    return <div>No posts :(</div>\n  }\n\n  return (\n    <div>\n      {posts.data.map(({ id, title, status }) => (\n        <div key={id}>\n          {title} - {status}\n        </div>\n      ))}\n      <button onClick={() => setPage(page - 1)} isLoading={isFetching}>\n        Previous\n      </button>\n      <button onClick={() => setPage(page + 1)} isLoading={isFetching}>\n        Next\n      </button>\n    </div>\n  )\n```\n\n----------------------------------------\n\nTITLE: Implementing a Todos Reducer with Redux Toolkit in JavaScript\nDESCRIPTION: This snippet demonstrates how to create a todos reducer using Redux Toolkit's createSlice function. It shows how to define the initial state, create reducer functions for adding and toggling todos, and export the generated action creators and reducer.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/introduction/why-rtk-is-redux-today.md#2025-04-17_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createSlice } from '@reduxjs/toolkit'\n\nconst todosSlice = createSlice({\n  name: 'todos',\n  initialState: [],\n  reducers: {\n    todoAdded(state, action) {\n      state.push({\n        id: action.payload.id,\n        text: action.payload.text,\n        completed: false,\n      })\n    },\n    todoToggled(state, action) {\n      const todo = state.find((todo) => todo.id === action.payload)\n      todo.completed = !todo.completed\n    },\n  },\n})\n\nexport const { todoAdded, todoToggled } = todosSlice.actions\nexport default todosSlice.reducer\n```\n\n----------------------------------------\n\nTITLE: Injecting and Exporting Endpoints with RTK Query\nDESCRIPTION: Demonstrates how to inject additional endpoints into the previously created empty API service. This example shows importing the base API, injecting a new 'example' query endpoint, and exporting the generated React hook for use in components.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/code-splitting.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// file: emptySplitApi.ts noEmit\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n\nexport const emptySplitApi = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: () => ({}),\n})\n\n// file: extendedApi.ts\nimport { emptySplitApi } from './emptySplitApi'\n\nconst extendedApi = emptySplitApi.injectEndpoints({\n  endpoints: (build) => ({\n    example: build.query({\n      query: () => 'test',\n    }),\n  }),\n  overrideExisting: false,\n})\n\nexport const { useExampleQuery } = extendedApi\n```\n\n----------------------------------------\n\nTITLE: Installing Redux Toolkit with Vite or Next.js templates\nDESCRIPTION: Commands to create a new Redux application using official templates for Vite or Next.js. These templates come with Redux Toolkit and React-Redux pre-configured with example code demonstrating Redux Toolkit features.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/introduction/getting-started.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Vite with our Redux+TS template\n# (using the `degit` tool to clone and extract the template)\nnpx degit reduxjs/redux-templates/packages/vite-template-redux my-app\n\n# Next.js using the `with-redux` template\nnpx create-next-app --example with-redux my-app\n```\n\n----------------------------------------\n\nTITLE: Implementing Websocket Chat API with Redux Toolkit Query in TypeScript\nDESCRIPTION: This snippet demonstrates the creation of a Websocket Chat API using Redux Toolkit Query. It includes type definitions, API endpoint creation, response transformation using createEntityAdapter, and real-time updates via WebSocket.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/streaming-updates.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport { createEntityAdapter } from '@reduxjs/toolkit'\nimport type { EntityState } from '@reduxjs/toolkit'\nimport { isMessage } from './schemaValidators'\n\nexport type Channel = 'redux' | 'general'\n\nexport interface Message {\n  id: number\n  channel: Channel\n  userName: string\n  text: string\n}\n\nconst messagesAdapter = createEntityAdapter<Message>()\nexport const api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getMessages: build.query<EntityState<Message, number>, Channel>({\n      query: (channel) => `messages/${channel}`,\n      transformResponse(response: Message[]) {\n        return messagesAdapter.addMany(\n          messagesAdapter.getInitialState(),\n          response,\n        )\n      },\n      async onCacheEntryAdded(\n        arg,\n        { updateCachedData, cacheDataLoaded, cacheEntryRemoved },\n      ) {\n        const ws = new WebSocket('ws://localhost:8080')\n        try {\n          await cacheDataLoaded\n\n          const listener = (event: MessageEvent) => {\n            const data = JSON.parse(event.data)\n            if (!isMessage(data) || data.channel !== arg) return\n\n            updateCachedData((draft) => {\n              messagesAdapter.upsertOne(draft, data)\n            })\n          }\n\n          ws.addEventListener('message', listener)\n        } catch {}\n        await cacheEntryRemoved\n        ws.close()\n      },\n    }),\n  }),\n})\n\nexport const { useGetMessagesQuery } = api\n```\n\n----------------------------------------\n\nTITLE: Implementing Polling with React Hooks in RTK Query\nDESCRIPTION: This snippet demonstrates how to enable polling in RTK Query using the useQuery hook with React. It shows setting a polling interval of 3 seconds and optionally skipping polling when the window is out of focus.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/polling.mdx#2025-04-17_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport * as React from 'react'\nimport { useGetPokemonByNameQuery } from './services/pokemon'\n\nexport const Pokemon = ({ name }: { name: string }) => {\n  // Automatically refetch every 3s unless the window is out of focus\n  const { data, status, error, refetch } = useGetPokemonByNameQuery(name, {\n    pollingInterval: 3000,\n    skipPollingIfUnfocused: true,\n  })\n\n  return <div>{data}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Auth-Enabled BaseQuery with Token Refresh\nDESCRIPTION: Extended fetchBaseQuery implementation that handles 401 unauthorized responses by attempting token refresh and request retry.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/customizing-queries.mdx#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type {\n  BaseQueryFn,\n  FetchArgs,\n  FetchBaseQueryError,\n} from '@reduxjs/toolkit/query'\nimport { tokenReceived, loggedOut } from './authSlice'\n\nconst baseQuery = fetchBaseQuery({ baseUrl: '/' })\nconst baseQueryWithReauth: BaseQueryFn<\n  string | FetchArgs,\n  unknown,\n  FetchBaseQueryError\n> = async (args, api, extraOptions) => {\n  let result = await baseQuery(args, api, extraOptions)\n  if (result.error && result.error.status === 401) {\n    const refreshResult = await baseQuery('/refreshToken', api, extraOptions)\n    if (refreshResult.data) {\n      api.dispatch(tokenReceived(refreshResult.data))\n      result = await baseQuery(args, api, extraOptions)\n    } else {\n      api.dispatch(loggedOut())\n    }\n  }\n  return result\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing API Service with fetchBaseQuery in TypeScript\nDESCRIPTION: Shows how to create an API service definition using fetchBaseQuery with a baseUrl for Pokemon API endpoints, including both query and mutation examples.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/fetchBaseQuery.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Or from '@reduxjs/toolkit/query/react'\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\n\nexport const pokemonApi = createApi({\n  // Set the baseUrl for every endpoint below\n  baseQuery: fetchBaseQuery({ baseUrl: 'https://pokeapi.co/api/v2/' }),\n  endpoints: (build) => ({\n    getPokemonByName: build.query({\n      // Will make a request like https://pokeapi.co/api/v2/pokemon/bulbasaur\n      query: (name: string) => `pokemon/${name}`,\n    }),\n    updatePokemon: build.mutation({\n      query: ({ name, patch }) => ({\n        url: `pokemon/${name}`,\n        // When performing a mutation, you typically use a method of\n        // PATCH/PUT/POST/DELETE for REST endpoints\n        method: 'PATCH',\n        // fetchBaseQuery automatically adds `content-type: application/json` to\n        // the Headers and calls `JSON.stringify(patch)`\n        body: patch,\n      }),\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Using createEntityAdapter with TypeScript in Redux Toolkit\nDESCRIPTION: Demonstrates how to use createEntityAdapter with TypeScript in Redux Toolkit. It shows creating an adapter, defining a slice, configuring the store, and using selectors.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createEntityAdapter.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  createEntityAdapter,\n  createSlice,\n  configureStore,\n} from '@reduxjs/toolkit'\n\ntype Book = { bookId: string; title: string }\n\nconst booksAdapter = createEntityAdapter({\n  // Assume IDs are stored in a field other than `book.id`\n  selectId: (book: Book) => book.bookId,\n  // Keep the \"all IDs\" array sorted based on book titles\n  sortComparer: (a, b) => a.title.localeCompare(b.title),\n})\n\nconst booksSlice = createSlice({\n  name: 'books',\n  initialState: booksAdapter.getInitialState(),\n  reducers: {\n    // Can pass adapter functions directly as case reducers.  Because we're passing this\n    // as a value, `createSlice` will auto-generate the `bookAdded` action type / creator\n    bookAdded: booksAdapter.addOne,\n    booksReceived(state, action) {\n      // Or, call them as \"mutating\" helpers in a case reducer\n      booksAdapter.setAll(state, action.payload.books)\n    },\n  },\n})\n\nconst store = configureStore({\n  reducer: {\n    books: booksSlice.reducer,\n  },\n})\n\ntype RootState = ReturnType<typeof store.getState>\n\nconsole.log(store.getState().books)\n// { ids: [], entities: {} }\n\n// Can create a set of memoized selectors based on the location of this entity state\nconst booksSelectors = booksAdapter.getSelectors<RootState>(\n  (state) => state.books,\n)\n\n// And then use the selectors to retrieve values\nconst allBooks = booksSelectors.selectAll(store.getState())\n```\n\n----------------------------------------\n\nTITLE: Typed React-Redux Hooks Setup for Next.js\nDESCRIPTION: Creates pre-typed versions of React-Redux hooks (useDispatch, useSelector, useStore) with proper TypeScript typing for the Next.js application store.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/usage/nextjs.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useDispatch, useSelector, useStore } from 'react-redux'\nimport type { RootState, AppDispatch, AppStore } from './store'\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = useDispatch.withTypes<AppDispatch>()\nexport const useAppSelector = useSelector.withTypes<RootState>()\nexport const useAppStore = useStore.withTypes<AppStore>()\n```\n\n----------------------------------------\n\nTITLE: Defining Reusable Tag Providers for RTK Query Endpoints (TypeScript)\nDESCRIPTION: Shows how to create a helper function to generate consistent tag providers for list-type endpoints, reducing boilerplate across different entity types like Posts and Users.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/automated-refetching.mdx#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { Post, User } from './types'\n\nfunction providesList<R extends { id: string | number }[], T extends string>(\n  resultsWithIds: R | undefined,\n  tagType: T,\n) {\n  return resultsWithIds\n    ? [\n        { type: tagType, id: 'LIST' },\n        ...resultsWithIds.map(({ id }) => ({ type: tagType, id })),\n      ]\n    : [{ type: tagType, id: 'LIST' }]\n}\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com' }),\n  tagTypes: ['Post', 'User'],\n  endpoints: (build) => ({\n    getPosts: build.query({\n      query: () => `posts`,\n      providesTags: (result) => providesList(result, 'Post'),\n    }),\n    getUsers: build.query({\n      query: () => `users`,\n      providesTags: (result) => providesList(result, 'User'),\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing CRUD Operations with Redux Toolkit Entity Adapter\nDESCRIPTION: Complete example showing how to create and use an entity adapter for managing a collection of books. Demonstrates initialization, adding, updating, and querying book entries with automatic sorting by title. Shows integration with createSlice and configureStore.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createEntityAdapter.mdx#2025-04-17_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  createEntityAdapter,\n  createSlice,\n  configureStore,\n} from '@reduxjs/toolkit'\n\n// Since we don't provide `selectId`, it defaults to assuming `entity.id` is the right field\nconst booksAdapter = createEntityAdapter({\n  // Keep the \"all IDs\" array sorted based on book titles\n  sortComparer: (a, b) => a.title.localeCompare(b.title),\n})\n\nconst booksSlice = createSlice({\n  name: 'books',\n  initialState: booksAdapter.getInitialState({\n    loading: 'idle',\n  }),\n  reducers: {\n    // Can pass adapter functions directly as case reducers.  Because we're passing this\n    // as a value, `createSlice` will auto-generate the `bookAdded` action type / creator\n    bookAdded: booksAdapter.addOne,\n    booksLoading(state, action) {\n      if (state.loading === 'idle') {\n        state.loading = 'pending'\n      }\n    },\n    booksReceived(state, action) {\n      if (state.loading === 'pending') {\n        // Or, call them as \"mutating\" helpers in a case reducer\n        booksAdapter.setAll(state, action.payload)\n        state.loading = 'idle'\n      }\n    },\n    bookUpdated: booksAdapter.updateOne,\n  },\n})\n\nconst { bookAdded, booksLoading, booksReceived, bookUpdated } =\n  booksSlice.actions\n\nconst store = configureStore({\n  reducer: {\n    books: booksSlice.reducer,\n  },\n})\n\n// Check the initial state:\nconsole.log(store.getState().books)\n// {ids: [], entities: {}, loading: 'idle' }\n\nconst booksSelectors = booksAdapter.getSelectors((state) => state.books)\n\nstore.dispatch(bookAdded({ id: 'a', title: 'First' }))\nconsole.log(store.getState().books)\n// {ids: [\"a\"], entities: {a: {id: \"a\", title: \"First\"}}, loading: 'idle' }\n\nstore.dispatch(bookUpdated({ id: 'a', changes: { title: 'First (altered)' } }))\nstore.dispatch(booksLoading())\nconsole.log(store.getState().books)\n// {ids: [\"a\"], entities: {a: {id: \"a\", title: \"First (altered)\"}}, loading: 'pending' }\n\nstore.dispatch(\n  booksReceived([\n    { id: 'b', title: 'Book 3' },\n    { id: 'c', title: 'Book 2' },\n  ]),\n)\n\nconsole.log(booksSelectors.selectIds(store.getState()))\n// \"a\" was removed due to the `setAll()` call\n// Since they're sorted by title, \"Book 2\" comes before \"Book 3\"\n// [\"c\", \"b\"]\n\nconsole.log(booksSelectors.selectAll(store.getState()))\n// All book entries in sorted order\n// [{id: \"c\", title: \"Book 2\"}, {id: \"b\", title: \"Book 3\"}]\n```\n\n----------------------------------------\n\nTITLE: Dynamic Base URL Configuration with Redux State in RTK Query\nDESCRIPTION: Demonstrates how to create a dynamic base URL using Redux state by implementing a custom base query function that accesses store state to construct URLs dynamically.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/customizing-queries.mdx#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport type {\n  BaseQueryFn,\n  FetchArgs,\n  FetchBaseQueryError,\n} from '@reduxjs/toolkit/query/react'\n\nconst rawBaseQuery = fetchBaseQuery({\n  baseUrl: 'www.my-cool-site.com/',\n})\n\nconst dynamicBaseQuery: BaseQueryFn<\n  string | FetchArgs,\n  unknown,\n  FetchBaseQueryError\n> = async (args, api, extraOptions) => {\n  const projectId = selectProjectId(api.getState() as RootState)\n  if (!projectId) {\n    return {\n      error: {\n        status: 400,\n        statusText: 'Bad Request',\n        data: 'No project ID received',\n      },\n    }\n  }\n\n  const urlEnd = typeof args === 'string' ? args : args.url\n  const adjustedUrl = `project/${projectId}/${urlEnd}`\n  const adjustedArgs =\n    typeof args === 'string' ? adjustedUrl : { ...args, url: adjustedUrl }\n  return rawBaseQuery(adjustedArgs, api, extraOptions)\n}\n```\n\n----------------------------------------\n\nTITLE: Axios BaseQuery Implementation\nDESCRIPTION: Custom implementation of a baseQuery using Axios for HTTP requests, supporting common HTTP methods and error handling.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/customizing-queries.mdx#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi } from '@reduxjs/toolkit/query'\nimport type { BaseQueryFn } from '@reduxjs/toolkit/query'\nimport axios from 'axios'\nimport type { AxiosRequestConfig, AxiosError } from 'axios'\n\nconst axiosBaseQuery =\n  (\n    { baseUrl }: { baseUrl: string } = { baseUrl: '' },\n  ): BaseQueryFn<\n    {\n      url: string\n      method?: AxiosRequestConfig['method']\n      data?: AxiosRequestConfig['data']\n      params?: AxiosRequestConfig['params']\n      headers?: AxiosRequestConfig['headers']\n    },\n    unknown,\n    unknown\n  > =>\n  async ({ url, method, data, params, headers }) => {\n    try {\n      const result = await axios({\n        url: baseUrl + url,\n        method,\n        data,\n        params,\n        headers,\n      })\n      return { data: result.data }\n    } catch (axiosError) {\n      const err = axiosError as AxiosError\n      return {\n        error: {\n          status: err.response?.status,\n          data: err.response?.data || err.message,\n        },\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Implementing Optimistic Updates in RTK Query (TypeScript)\nDESCRIPTION: Demonstrates how to perform an optimistic update in an RTK Query mutation. It updates the cache immediately on mutation start and rolls back on failure.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/manual-cache-updates.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post'],\n  endpoints: (build) => ({\n    getPost: build.query<Post, number>({\n      query: (id) => `post/${id}`,\n      providesTags: ['Post'],\n    }),\n    updatePost: build.mutation<void, Pick<Post, 'id'> & Partial<Post>>({\n      query: ({ id, ...patch }) => ({\n        url: `post/${id}`,\n        method: 'PATCH',\n        body: patch,\n      }),\n      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n        const patchResult = dispatch(\n          api.util.updateQueryData('getPost', id, (draft) => {\n            Object.assign(draft, patch)\n          }),\n        )\n        try {\n          await queryFulfilled\n        } catch {\n          patchResult.undo()\n        }\n      },\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Managing UI Behavior with Query Loading States in React and TypeScript\nDESCRIPTION: This snippet illustrates how to use isLoading and isFetching states from a Redux Toolkit Query hook to manage UI behavior, including displaying a skeleton loader and disabling posts during refetching.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/queries.mdx#2025-04-17_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Skeleton } from './Skeleton'\nimport { useGetPostsQuery } from './api'\n\nfunction App() {\n  const { data = [], isLoading, isFetching, isError } = useGetPostsQuery()\n\n  if (isError) return <div>An error has occurred!</div>\n\n  if (isLoading) return <Skeleton />\n\n  return (\n    <div className={isFetching ? 'posts--disabled' : ''}>\n      {data.map((post) => (\n        <Post\n          key={post.id}\n          id={post.id}\n          name={post.name}\n          disabled={isFetching}\n        />\n      ))}\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Redux Store with RTK Query API Slice\nDESCRIPTION: This snippet demonstrates how to configure the Redux store to include the RTK Query API slice. It adds the API reducer to the store and includes the API middleware.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/migrating-to-rtk-query.mdx#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configureStore } from '@reduxjs/toolkit'\nimport { pokemonSlice } from './services/pokemonSlice'\nimport { api } from './services/api'\n\nexport const store = configureStore({\n  reducer: {\n    pokemon: pokemonSlice.reducer,\n    [api.reducerPath]: api.reducer,\n  },\n  middleware: (gDM) => gDM().concat(api.middleware),\n})\n\nexport type RootState = ReturnType<typeof store.getState>\n```\n\n----------------------------------------\n\nTITLE: Multiple Requests in Single Query with RTK Query (TypeScript)\nDESCRIPTION: Demonstrates how to perform multiple API requests within a single query using queryFn in Redux Toolkit Query, fetching posts for a random user.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/customizing-queries.mdx#2025-04-17_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { FetchBaseQueryError } from '@reduxjs/toolkit/query'\nimport type { Post, User } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/ ' }),\n  endpoints: (build) => ({\n    getRandomUserPosts: build.query<Post, void>({\n      async queryFn(_arg, _queryApi, _extraOptions, fetchWithBQ) {\n        const randomResult = await fetchWithBQ('users/random')\n        if (randomResult.error)\n          return { error: randomResult.error as FetchBaseQueryError }\n        const user = randomResult.data as User\n        const result = await fetchWithBQ(`user/${user.id}/posts`)\n        return result.data\n          ? { data: result.data as Post }\n          : { error: result.error as FetchBaseQueryError }\n      },\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Customizing Action Creators in createSlice\nDESCRIPTION: This example shows how to customize action creators in createSlice using a prepare callback. It creates a todos slice with a custom addTodo action that generates a unique ID for each new todo item.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createSlice.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSlice, nanoid } from '@reduxjs/toolkit'\nimport type { PayloadAction } from '@reduxjs/toolkit'\n\ninterface Item {\n  id: string\n  text: string\n}\n\nconst todosSlice = createSlice({\n  name: 'todos',\n  initialState: [] as Item[],\n  reducers: {\n    addTodo: {\n      reducer: (state, action: PayloadAction<Item>) => {\n        state.push(action.payload)\n      },\n      prepare: (text: string) => {\n        const id = nanoid()\n        return { payload: { id, text } }\n      },\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Creating an RTK Query API Slice for Pokemon Data\nDESCRIPTION: This snippet shows how to create an RTK Query API slice for fetching Pokemon data. It defines an endpoint for getting Pokemon by name and exports a generated hook for use in components.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/migrating-to-rtk-query.mdx#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport type { Pokemon } from './types'\n\nexport const api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: 'https://pokeapi.co/api/v2/' }),\n  reducerPath: 'pokemonApi',\n  endpoints: (build) => ({\n    getPokemonByName: build.query<Pokemon, string>({\n      query: (name) => `pokemon/${name}`,\n    }),\n  }),\n})\n\nexport const { useGetPokemonByNameQuery } = api\n```\n\n----------------------------------------\n\nTITLE: Implementing Bidirectional Cursor Pagination in RTK Query (TypeScript)\nDESCRIPTION: This snippet demonstrates how to set up bidirectional cursor-based pagination in RTK Query. It includes type definitions for the API response and query parameters, and implements getPreviousPageParam and getNextPageParam functions to handle cursor-based navigation.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/infinite-queries.mdx#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ntype ProjectsCursorPaginated = {\n  projects: Project[]\n  serverTime: string\n  pageInfo: {\n    startCursor: number\n    endCursor: number\n    hasNextPage: boolean\n    hasPreviousPage: boolean\n  }\n}\n\ntype ProjectsInitialPageParam = {\n  before?: number\n  around?: number\n  after?: number\n  limit: number\n}\ntype QueryParamLimit = number\n\nconst projectsApi = createApi({\n  baseQuery,\n  endpoints: (build) => ({\n    getProjectsBidirectionalCursor: build.infiniteQuery<\n      ProjectsCursorPaginated,\n      QueryParamLimit,\n      ProjectsInitialPageParam\n    >({\n      infiniteQueryOptions: {\n        initialPageParam: { limit: 10 },\n        getPreviousPageParam: (\n          firstPage,\n          allPages,\n          firstPageParam,\n          allPageParams,\n        ) => {\n          if (!firstPage.pageInfo.hasPreviousPage) {\n            return undefined\n          }\n          return {\n            before: firstPage.pageInfo.startCursor,\n            limit: firstPageParam.limit,\n          }\n        },\n        getNextPageParam: (\n          lastPage,\n          allPages,\n          lastPageParam,\n          allPageParams,\n        ) => {\n          if (!lastPage.pageInfo.hasNextPage) {\n            return undefined\n          }\n          return {\n            after: lastPage.pageInfo.endCursor,\n            limit: lastPageParam.limit,\n          }\n        },\n      },\n      query: ({ pageParam: { before, after, around, limit } }) => {\n        const params = new URLSearchParams()\n        params.append('limit', String(limit))\n        if (after != null) {\n          params.append('after', String(after))\n        } else if (before != null) {\n          params.append('before', String(before))\n        } else if (around != null) {\n          params.append('around', String(around))\n        }\n\n        return `https://example.com/api/projectsBidirectionalCursor?${params.toString()}`,\n      },\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Enhancing API Endpoints with Cache Management in TypeScript\nDESCRIPTION: This example demonstrates how to use the enhanceEndpoints function to modify caching behavior of existing API endpoints. It shows adding tag types and updating providesTags, invalidatesTags, and keepUnusedDataFor properties.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/code-splitting.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from './api'\n\nconst enhancedApi = api.enhanceEndpoints({\n  addTagTypes: ['User'],\n  endpoints: {\n    getUserByUserId: {\n      providesTags: ['User'],\n    },\n    patchUserByUserId: {\n      invalidatesTags: ['User'],\n    },\n    // alternatively, define a function which is called with the endpoint definition as an argument\n    getUsers(endpoint) {\n      endpoint.providesTags = ['User']\n      endpoint.keepUnusedDataFor = 120\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Selecting Specific Data from Query Results in React with Redux Toolkit Query\nDESCRIPTION: This snippet demonstrates how to use selectFromResult to extract specific data from a query result, optimizing performance by preventing unnecessary rerenders when only a subset of data changes.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/queries.mdx#2025-04-17_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nfunction PostsList() {\n  const { data: posts } = api.useGetPostsQuery()\n\n  return (\n    <ul>\n      {posts?.data?.map((post) => <PostById key={post.id} id={post.id} />)}\n    </ul>\n  )\n}\n\nfunction PostById({ id }: { id: number }) {\n  // Will select the post with the given id, and will only rerender if the given post's data changes\n  const { post } = api.useGetPostsQuery(undefined, {\n    selectFromResult: ({ data }) => ({\n      post: data?.find((post) => post.id === id),\n    }),\n  })\n\n  return <li>{post?.name}</li>\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Generated Hooks Example - TypeScript\nDESCRIPTION: Shows the full set of hooks generated for query and mutation endpoints, including all variations of hook types and access patterns\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/hooks.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n/* Hooks attached to the `getPosts` query endpoint definition */\napi.endpoints.getPosts.useQuery(arg, options)\napi.endpoints.getPosts.useQueryState(arg, options)\napi.endpoints.getPosts.useQuerySubscription(arg, options)\napi.endpoints.getPosts.useLazyQuery(options)\napi.endpoints.getPosts.useLazyQuerySubscription(options)\n\n/* hooks attached to the `getManyPosts` infinite query endpoint definition */\napi.endpoints.getManyPosts.useInfiniteQuery(arg, options)\napi.endpoints.getManyPosts.useInfiniteQueryState(arg, options)\napi.endpoints.getManyPosts.useInfiniteQuerySubscription(arg, options)\n\n/* Hooks attached to the `updatePost` mutation endpoint definition */\napi.endpoints.updatePost.useMutation(options)\n\n/* Hooks attached to the `api` object */\n// same as api.endpoints.getPosts.useQuery\napi.useGetPostsQuery(arg, options)\n// same as api.endpoints.getPosts.useLazyQuery\napi.useLazyGetPostsQuery(arg, options)\n// same as api.endpoints.updatePost.useMutation\napi.useUpdatePostMutation(arg, options)\n// same as api.endpoints.getManyPosts.useInfiniteQuery\napi.useGetManyPostsInfiniteQuery(arg, options)\n// Generic, used for any endpoint\napi.usePrefetch(endpointName, options)\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Retry Logic with Bailout in Redux Toolkit Query\nDESCRIPTION: Demonstrates how to implement retry logic with a bailout mechanism for specific error cases like 401 unauthorized responses. Includes configuration for maximum retries and per-endpoint customization.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/customizing-queries.mdx#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery, retry } from '@reduxjs/toolkit/query/react'\nimport type { FetchArgs } from '@reduxjs/toolkit/query'\n\nconst staggeredBaseQueryWithBailOut = retry(\n  async (args: string | FetchArgs, api, extraOptions) => {\n    const result = await fetchBaseQuery({ baseUrl: '/api/' })(\n      args,\n      api,\n      extraOptions,\n    )\n\n    if (result.error?.status === 401) {\n      retry.fail(result.error, result.meta)\n    }\n\n    return result\n  },\n  {\n    maxRetries: 5,\n  },\n)\n\nexport const api = createApi({\n  baseQuery: staggeredBaseQueryWithBailOut,\n  endpoints: (build) => ({\n    getPosts: build.query<PostsResponse, void>({\n      query: () => ({ url: 'posts' }),\n    }),\n    getPost: build.query<Post, string>({\n      query: (id) => ({ url: `post/${id}` }),\n      extraOptions: { maxRetries: 8 },\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Infinite Query Hook in Redux Toolkit\nDESCRIPTION: This snippet demonstrates how to define an infinite query endpoint for fetching Pokemon data and use it in a React component. It includes the API definition with infiniteQueryOptions and a component that renders the fetched data with pagination controls.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/infinite-queries.mdx#2025-04-17_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\ntype Pokemon = {\n  id: string\n  name: string\n}\n\nconst pokemonApi = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com/pokemon' }),\n  endpoints: (build) => ({\n    getPokemon: build.infiniteQuery<Pokemon[], string, number>({\n      infiniteQueryOptions: {\n        initialPageParam: 1,\n        getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) =>\n          lastPageParam + 1,\n      },\n      query({ queryArg, pageParam }) {\n        return `/type/${queryArg}?page=${pageParam}`\n      },\n    }),\n  }),\n})\n\nfunction PokemonList({ pokemonType }: { pokemonType: string }) {\n  const { data, isFetching, fetchNextPage, fetchPreviousPage, refetch } =\n    pokemonApi.useGetPokemonInfiniteQuery(pokemonType)\n\n  const handleNextPage = async () => {\n    await fetchNextPage()\n  }\n\n  const handleRefetch = async () => {\n    await refetch()\n  }\n\n  const allResults = data?.pages.flat() ?? []\n\n  return (\n    <div>\n      <div>Type: {pokemonType}</div>\n      <div>\n        {allResults.map((pokemon, i: number | null | undefined) => (\n          <div key={i}>{pokemon.name}</div>\n        ))}\n      </div>\n      <button onClick={() => handleNextPage()}>Fetch More</button>\n      <button onClick={() => handleRefetch()}>Refetch</button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using createReducer with Immer in Redux Toolkit\nDESCRIPTION: Shows how Redux Toolkit's createReducer API uses Immer internally, allowing 'mutating' syntax in reducer functions.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/usage/immer-reducers.md#2025-04-17_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst todosReducer = createReducer([], (builder) => {\n  builder.addCase('todos/todoAdded', (state, action) => {\n    // \"mutate\" the array by calling push()\n    state.push(action.payload)\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic Redux Store with Redux Toolkit in TypeScript\nDESCRIPTION: A simple example showing how to create a Redux store using configureStore with a root reducer. This configuration automatically adds redux-thunk middleware and enables Redux DevTools Extension.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/configureStore.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// file: reducers.ts noEmit\nimport type { Reducer } from '@reduxjs/toolkit'\ndeclare const rootReducer: Reducer<{}>\nexport default rootReducer\n\n// file: store.ts\nimport { configureStore } from '@reduxjs/toolkit'\n\nimport rootReducer from './reducers'\n\nconst store = configureStore({ reducer: rootReducer })\n// The store now has redux-thunk added and the Redux DevTools Extension is turned on\n```\n\n----------------------------------------\n\nTITLE: Providing Tags to Cache in RTK Query\nDESCRIPTION: Example demonstrating how to provide tags to the cache using the providesTags property on query endpoints. Shows basic tag provision for both posts and users endpoints.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/automated-refetching.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post', 'User'],\n  endpoints: (build) => ({\n    getPosts: build.query<Post[], void>({\n      query: () => '/posts',\n      providesTags: ['Post'],\n    }),\n    getUsers: build.query<User[], void>({\n      query: () => '/users',\n      providesTags: ['User'],\n    }),\n    addPost: build.mutation<Post, Omit<Post, 'id'>>({      query: (body) => ({\n        url: 'posts',\n        method: 'POST',\n        body,\n      }),\n    }),\n    editPost: build.mutation<Post, Partial<Post> & Pick<Post, 'id'>>({      query: (body) => ({\n        url: `post/${body.id}`,\n        method: 'POST',\n        body,\n      }),\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Providing Tags with IDs in RTK Query\nDESCRIPTION: Advanced example showing how to provide tags with specific IDs for more granular cache control. Demonstrates using result-dependent tag provision and fallback handling.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/automated-refetching.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post', 'User'],\n  endpoints: (build) => ({\n    getPosts: build.query<Post[], void>({\n      query: () => '/posts',\n      providesTags: (result, error, arg) =>\n        result\n          ? [...result.map(({ id }) => ({ type: 'Post' as const, id })), 'Post']\n          : ['Post'],\n    }),\n    getUsers: build.query<User[], void>({\n      query: () => '/users',\n      providesTags: ['User'],\n    }),\n    addPost: build.mutation<Post, Omit<Post, 'id'>>({      query: (body) => ({\n        url: 'post',\n        method: 'POST',\n        body,\n      }),\n    }),\n    editPost: build.mutation<Post, Partial<Post> & Pick<Post, 'id'>>({      query: (body) => ({\n        url: `post/${body.id}`,\n        method: 'POST',\n        body,\n      }),\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Mutation Endpoint in Redux Toolkit\nDESCRIPTION: This code snippet defines the structure and types for a mutation endpoint in Redux Toolkit. It includes the MutationDefinition type, which specifies the required and optional properties for mutation endpoints.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/createApi.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport type MutationDefinition<\n  QueryArg,\n  BaseQuery extends BaseQueryFn,\n  TagTypes extends string,\n  ResultType,\n  ReducerPath extends string = string,\n  Context = Record<string, any>,\n> = {\n  query(arg: QueryArg): BaseQueryArg<BaseQuery>\n\n  queryFn(\n    arg: QueryArg,\n    api: BaseQueryApi,\n    extraOptions: BaseQueryExtraOptions<BaseQuery>,\n    baseQuery: (arg: Parameters<BaseQuery>[0]) => ReturnType<BaseQuery>,\n  ): MaybePromise<QueryReturnValue<ResultType, BaseQueryError<BaseQuery>>>\n\n  transformResponse?(\n    baseQueryReturnValue: BaseQueryResult<BaseQuery>,\n    meta: BaseQueryMeta<BaseQuery>,\n    arg: QueryArg,\n  ): ResultType | Promise<ResultType>\n\n  transformErrorResponse?(\n    baseQueryReturnValue: BaseQueryError<BaseQuery>,\n    meta: BaseQueryMeta<BaseQuery>,\n    arg: QueryArg,\n  ): unknown\n\n  extraOptions?: BaseQueryExtraOptions<BaseQuery>\n\n  invalidatesTags?: ResultDescription<TagTypes, ResultType, QueryArg>\n\n  onQueryStarted?(\n    arg: QueryArg,\n    {\n      dispatch,\n      getState,\n      extra,\n      requestId,\n      queryFulfilled,\n      getCacheEntry,\n    }: MutationLifecycleApi,\n  ): Promise<void>\n\n  onCacheEntryAdded?(\n    arg: QueryArg,\n    {\n      dispatch,\n      getState,\n      extra,\n      requestId,\n      cacheEntryRemoved,\n      cacheDataLoaded,\n      getCacheEntry,\n    }: MutationCacheLifecycleApi,\n  ): Promise<void>\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Cache Subscription Behavior in TypeScript React Components\nDESCRIPTION: Example showing how multiple React components can subscribe to the same RTK Query endpoint with different parameters, demonstrating cache sharing and reference counting.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/cache-behavior.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useGetUserQuery } from './api.ts'\n\nfunction ComponentOne() {\n  // component subscribes to the data\n  const { data } = useGetUserQuery(1)\n\n  return <div>...</div>\n}\n\nfunction ComponentTwo() {\n  // component subscribes to the data\n  const { data } = useGetUserQuery(2)\n\n  return <div>...</div>\n}\n\nfunction ComponentThree() {\n  // component subscribes to the data\n  const { data } = useGetUserQuery(3)\n\n  return <div>...</div>\n}\n\nfunction ComponentFour() {\n  // component subscribes to the *same* data as ComponentThree,\n  // as it has the same query parameters\n  const { data } = useGetUserQuery(3)\n\n  return <div>...</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PostDetail Component with Redux Toolkit Query Hook in TypeScript\nDESCRIPTION: This example demonstrates how to use the useGetPostQuery hook to fetch and display post details. It shows handling of loading states, data presence, and refetching behavior.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/queries.mdx#2025-04-17_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nexport const PostDetail = ({ id }: { id: string }) => {\n  const {\n    data: post,\n    isFetching,\n    isLoading,\n  } = useGetPostQuery(id, {\n    pollingInterval: 3000,\n    refetchOnMountOrArgChange: true,\n    skip: false,\n  })\n\n  if (isLoading) return <div>Loading...</div>\n  if (!post) return <div>Missing post!</div>\n\n  return (\n    <div>\n      {post.name} {isFetching ? '...refetching' : ''}\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using RTK Query Hooks in React Components\nDESCRIPTION: Demonstrates usage of auto-generated RTK Query hooks in a React component for data fetching, including handling loading states and errors.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/overview.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as React from 'react'\nimport { useGetPokemonByNameQuery } from './services/pokemon'\n\nexport default function App() {\n  // Using a query hook automatically fetches data and returns query values\n  const { data, error, isLoading } = useGetPokemonByNameQuery('bulbasaur')\n  // Individual hooks are also accessible under the generated endpoints:\n  // const { data, error, isLoading } = pokemonApi.endpoints.getPokemonByName.useQuery('bulbasaur')\n\n  // render UI based on data and loading state\n}\n```\n\n----------------------------------------\n\nTITLE: Using unwrapResult Helper Function\nDESCRIPTION: Examples of using the unwrapResult utility function for handling thunk results.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAsyncThunk.mdx#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { unwrapResult } from '@reduxjs/toolkit'\n\nconst onClick = () => {\n  dispatch(fetchUserById(userId))\n    .then(unwrapResult)\n    .then((originalPromiseResult) => {\n      // handle result here\n    })\n    .catch((rejectedValueOrSerializedError) => {\n      // handle result here\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Redux Store with RTK Query\nDESCRIPTION: Configures the Redux store to include the RTK Query service reducer and middleware. Sets up listeners for features like refetchOnFocus and refetchOnReconnect.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/tutorials/rtk-query.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configureStore } from '@reduxjs/toolkit'\nimport { setupListeners } from '@reduxjs/toolkit/query'\nimport { pokemonApi } from './services/pokemon'\n\nexport const store = configureStore({\n  reducer: {\n    [pokemonApi.reducerPath]: pokemonApi.reducer,\n  },\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware().concat(pokemonApi.middleware),\n})\n\nsetupListeners(store.dispatch)\n```\n\n----------------------------------------\n\nTITLE: Reusable Case Reducer with Immer in Redux Toolkit\nDESCRIPTION: Shows how to create a reusable case reducer function that uses 'mutating' syntax and can be included in createSlice.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/usage/immer-reducers.md#2025-04-17_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst addItemToArray = (state, action) => {\n  state.push(action.payload)\n}\n\nconst todosSlice = createSlice({\n  name: 'todos',\n  initialState: [],\n  reducers: {\n    todoAdded: addItemToArray,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Authorization Token in prepareHeaders\nDESCRIPTION: Demonstrates how to automatically include authorization headers for API requests by accessing a token from the Redux store state.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/fetchBaseQuery.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// file: store.ts noEmit\nexport type RootState = { auth: { token: string } }\n\n// file: baseQuery.ts\nimport { fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { RootState } from './store'\n\nconst baseQuery = fetchBaseQuery({\n  baseUrl: '/',\n  prepareHeaders: (headers, { getState }) => {\n    const token = (getState() as RootState).auth.token\n\n    // If we have a token set in state, let's assume that we should be passing it.\n    if (token) {\n      headers.set('authorization', `Bearer ${token}`)\n    }\n\n    return headers\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Thunk with Redux Toolkit in TypeScript\nDESCRIPTION: Demonstrates how to create and use an async thunk for fetching user data, including slice creation and handling async action states. Shows integration with createSlice and proper TypeScript typing.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAsyncThunk.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAsyncThunk, createSlice } from '@reduxjs/toolkit'\nimport { userAPI } from './userAPI'\n\n// First, create the thunk\nconst fetchUserById = createAsyncThunk(\n  'users/fetchByIdStatus',\n  async (userId: number, thunkAPI) => {\n    const response = await userAPI.fetchById(userId)\n    return response.data\n  },\n)\n\ninterface UsersState {\n  entities: User[]\n  loading: 'idle' | 'pending' | 'succeeded' | 'failed'\n}\n\nconst initialState = {\n  entities: [],\n  loading: 'idle',\n} satisfies UserState as UsersState\n\n// Then, handle actions in your reducers:\nconst usersSlice = createSlice({\n  name: 'users',\n  initialState,\n  reducers: {\n    // standard reducer logic, with auto-generated action types per reducer\n  },\n  extraReducers: (builder) => {\n    // Add reducers for additional action types here, and handle loading state as needed\n    builder.addCase(fetchUserById.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.entities.push(action.payload)\n    })\n  },\n})\n\n// Later, dispatch the thunk as needed in the app\ndispatch(fetchUserById(123))\n```\n\n----------------------------------------\n\nTITLE: Implementing usePrefetch with React Components\nDESCRIPTION: Demonstrates how to use the usePrefetch hook in a React component. Shows different implementations of prefetching based on user interactions with different priority levels.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/prefetching.mdx#2025-04-17_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nfunction User() {\n  const prefetchUser = usePrefetch('getUser')\n\n  // Low priority hover will not fire unless the last request happened more than 35s ago\n  // High priority hover will _always_ fire\n  return (\n    <div>\n      <button onMouseEnter={() => prefetchUser(4, { ifOlderThan: 35 })}>\n        Low priority\n      </button>\n      <button onMouseEnter={() => prefetchUser(4, { force: true })}>\n        High priority\n      </button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating OpenAPI Code Generation Configuration in TypeScript\nDESCRIPTION: Defines a configuration file for the OpenAPI code generator, specifying schema source, API file, output location and other options. This is the main configuration used by the code generator.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/code-generation.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { ConfigFile } from '@rtk-query/codegen-openapi'\n\nconst config: ConfigFile = {\n  schemaFile: 'https://petstore3.swagger.io/api/v3/openapi.json',\n  apiFile: './src/store/emptyApi.ts',\n  apiImport: 'emptySplitApi',\n  outputFile: './src/store/petApi.ts',\n  exportName: 'petApi',\n  hooks: true,\n}\n\nexport default config\n```\n\n----------------------------------------\n\nTITLE: Using createAction Helper - TypeScript\nDESCRIPTION: Example of using createAction to combine action type and creator into one declaration\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAction.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAction } from '@reduxjs/toolkit'\n\nconst increment = createAction<number | undefined>('counter/increment')\n\nlet action = increment()\n// { type: 'counter/increment' }\n\naction = increment(3)\n// returns { type: 'counter/increment', payload: 3 }\n\nconsole.log(`The action type is: ${increment.type}`)\n// 'The action type is: counter/increment'\n```\n\n----------------------------------------\n\nTITLE: User Update with Validation Error Handling in Redux Toolkit\nDESCRIPTION: Shows how to implement user updates with comprehensive error handling using rejectWithValue. Includes TypeScript type definitions, custom validation error handling, and integration with Formik for form management.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAsyncThunk.mdx#2025-04-17_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAsyncThunk, createSlice } from '@reduxjs/toolkit'\nimport { userAPI } from './userAPI'\nimport type { AxiosError } from 'axios'\n\nexport interface User {\n  id: string\n  first_name: string\n  last_name: string\n  email: string\n}\n\ninterface ValidationErrors {\n  errorMessage: string\n  field_errors: Record<string, string>\n}\n\ninterface UpdateUserResponse {\n  user: User\n  success: boolean\n}\n\nexport const updateUser = createAsyncThunk<\n  User,\n  { id: string } & Partial<User>,\n  {\n    rejectValue: ValidationErrors\n  }\n>('users/update', async (userData, { rejectWithValue }) => {\n  try {\n    const { id, ...fields } = userData\n    const response = await userAPI.updateById<UpdateUserResponse>(id, fields)\n    return response.data.user\n  } catch (err) {\n    let error: AxiosError<ValidationErrors> = err // cast the error for access\n    if (!error.response) {\n      throw err\n    }\n    return rejectWithValue(error.response.data)\n  }\n})\n\ninterface UsersState {\n  error: string | null | undefined\n  entities: Record<string, User>\n}\n\nconst initialState = {\n  entities: {},\n  error: null,\n} satisfies UsersState as UsersState\n\nconst usersSlice = createSlice({\n  name: 'users',\n  initialState,\n  reducers: {},\n  extraReducers: (builder) => {\n    builder.addCase(updateUser.fulfilled, (state, { payload }) => {\n      state.entities[payload.id] = payload\n    })\n    builder.addCase(updateUser.rejected, (state, action) => {\n      if (action.payload) {\n        state.error = action.payload.errorMessage\n      } else {\n        state.error = action.error.message\n      }\n    })\n  },\n})\n\nexport default usersSlice.reducer\n```\n\n----------------------------------------\n\nTITLE: Setting Up RTK Query Window Focus Refetching\nDESCRIPTION: Shows how to enable automatic refetching when the application window regains focus. Includes both API configuration and store setup with setupListeners.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/cache-behavior.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport type { Post } from './types'\n\nexport const api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  refetchOnFocus: true,\n  endpoints: (build) => ({\n    getPosts: build.query<Post[], number>({\n      query: () => `posts`,\n    }),\n  }),\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configureStore } from '@reduxjs/toolkit'\nimport { setupListeners } from '@reduxjs/toolkit/query'\nimport { api } from './services/api'\n\nexport const store = configureStore({\n  reducer: {\n    [api.reducerPath]: api.reducer,\n  },\n  middleware: (gDM) => gDM().concat(api.middleware),\n})\n\nsetupListeners(store.dispatch)\n\nexport type RootState = ReturnType<typeof store.getState>\n```\n\n----------------------------------------\n\nTITLE: Setting up RTK Query endpoint for paginated data\nDESCRIPTION: Example of creating an API endpoint that accepts a page parameter for pagination. The endpoint returns a ListResponse containing paginated Post objects with metadata including current page, items per page, and total pages.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/pagination.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\ninterface ListResponse<T> {\n  page: number\n  per_page: number\n  total: number\n  total_pages: number\n  data: T[]\n}\n\nexport const api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    listPosts: build.query<ListResponse<Post>, number | void>({\n      query: (page = 1) => `posts?page=${page}`,\n    }),\n  }),\n})\n\nexport const { useListPostsQuery } = api\n```\n\n----------------------------------------\n\nTITLE: Optimized Tag Invalidation with LIST ID\nDESCRIPTION: Shows an optimized approach using a 'LIST' tag ID to selectively invalidate only the posts list query when adding a new post, preventing unnecessary refetching of individual post details.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/automated-refetching.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport type { Post, User } from './types'\n\nexport const api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Posts'],\n  endpoints: (build) => ({\n    getPosts: build.query<Post[], void>({\n      query: () => 'posts',\n      providesTags: (result) =>\n        result\n          ? [\n              ...result.map(({ id }) => ({ type: 'Posts' as const, id })),\n              { type: 'Posts', id: 'LIST' },\n            ]\n          : [{ type: 'Posts', id: 'LIST' }],\n    }),\n    addPost: build.mutation<Post, Partial<Post>>({\n      query(body) {\n        return {\n          url: `post`,\n          method: 'POST',\n          body,\n        }\n      },\n      invalidatesTags: [{ type: 'Posts', id: 'LIST' }],\n    }),\n    getPost: build.query<Post, number>({\n      query: (id) => `post/${id}`,\n      providesTags: (result, error, id) => [{ type: 'Posts', id }],\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Response Transformation in Redux Toolkit Query\nDESCRIPTION: This snippet demonstrates the correct way to implement response transformation in Redux Toolkit Query. It uses rawResponseSchema for validation before transformation and performs the date conversion in the transformResponse function.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage-with-typescript.mdx#2025-04-17_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport * as v from 'valibot'\n\nconst postSchema = v.object({\n  id: v.number(),\n  name: v.string(),\n  published_at: v.string(),\n})\ntype RawPost = v.InferOutput<typeof postSchema>\ntype Post = Omit<RawPost, 'published_at'> & { published_at: Date }\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getPost: build.query<Post, { id: number }>({\n      query: ({ id }) => `/post/${id}`,\n      // use rawResponseSchema to validate *before* transformation\n      rawResponseSchema: postSchema,\n      // highlight-start\n      transformResponse: (response) => ({\n        ...response,\n        published_at: new Date(response.published_at),\n      }),\n      // highlight-end\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Rehydration with Redux Persist in RTK Query\nDESCRIPTION: This code snippet demonstrates how to integrate RTK Query with Redux Persist to enable state rehydration. It shows the implementation of extractRehydrationInfo in the createApi function to handle the REHYDRATE action from redux-persist, supporting both api reducer and root reducer persistence approaches.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/persistence-and-rehydration.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Action } from '@reduxjs/toolkit'\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport { REHYDRATE } from 'redux-persist'\n\ntype RootState = any // normally inferred from state\n\nfunction isHydrateAction(action: Action): action is Action<typeof REHYDRATE> & {\n  key: string\n  payload: RootState\n  err: unknown\n} {\n  return action.type === REHYDRATE\n}\n\nexport const api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  // to prevent circular type issues, the return type needs to be annotated as any\n  extractRehydrationInfo(action, { reducerPath }): any {\n    if (isHydrateAction(action)) {\n      // when persisting the api reducer\n      if (action.key === 'key used with redux-persist') {\n        return action.payload\n      }\n\n      // When persisting the root reducer\n      return action.payload[api.reducerPath]\n    }\n  },\n  endpoints: (build) => ({\n    // omitted\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Using currentData for Granular UI Control in React with Redux Toolkit Query\nDESCRIPTION: This example shows how to use the currentData property from a Redux Toolkit Query hook to provide more granular control over UI rendering, particularly when switching between different users' data.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/queries.mdx#2025-04-17_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Skeleton } from './Skeleton'\nimport { useGetPostsByUserQuery } from './api'\n\nfunction PostsList({ userName }: { userName: string }) {\n  const { currentData, isFetching, isError } = useGetPostsByUserQuery(userName)\n\n  if (isError) return <div>An error has occurred!</div>\n\n  if (isFetching && !currentData) return <Skeleton />\n\n  return (\n    <div className={isFetching ? 'posts--disabled' : ''}>\n      {currentData\n        ? currentData.map((post) => (\n            <Post\n              key={post.id}\n              id={post.id}\n              name={post.name}\n              disabled={isFetching}\n            />\n          ))\n        : 'No data available'}\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom Hook for Pokemon Data in React Component\nDESCRIPTION: This snippet demonstrates how to use the custom 'useGetPokemonByNameQuery' hook in a React component. It handles loading, error, and data states to render appropriate UI.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/migrating-to-rtk-query.mdx#2025-04-17_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport * as React from 'react'\nimport { useGetPokemonByNameQuery } from './hooks'\n\nexport default function App() {\n  const { data, isError, isLoading } = useGetPokemonByNameQuery('bulbasaur')\n\n  return (\n    <div className=\"App\">\n      {isError ? (\n        <>Oh no, there was an error</>\n      ) : isLoading ? (\n        <>Loading...</>\n      ) : data ? (\n        <>\n          <h3>{data.species.name}</h3>\n          <img src={data.sprites.front_shiny} alt={data.species.name} />\n        </>\n      ) : null}\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Runtime Schema Validation with Redux Toolkit Query\nDESCRIPTION: Demonstrates how to implement runtime validation using schema libraries (Valibot in this example) with Redux Toolkit Query. Shows validation for both direct responses and transformed responses.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/mutations.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport * as v from 'valibot'\n\nconst postSchema = v.object({\n  id: v.number(),\n  name: v.string(),\n  published_at: v.string(),\n})\ntype Post = v.InferOutput<typeof postSchema>\nconst transformedPost = v.object({\n  ...postSchema.entries,\n  published_at: v.date(),\n})\ntype TransformedPost = v.InferOutput<typeof transformedPost>\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    updatePost: build.mutation<Post, Partial<Post>>({\n      query(data) {\n        const { id, ...body } = data\n        return {\n          url: `post/${id}`,\n          method: 'PUT',\n          body,\n        }\n      },\n      responseSchema: postSchema,\n    }),\n    updatePostWithTransform: build.mutation<TransformedPost, Partial<Post>>({\n      query(data) {\n        const { id, ...body } = data\n        return {\n          url: `post/${id}`,\n          method: 'PUT',\n          body,\n        }\n      },\n      rawResponseSchema: postSchema,\n      transformResponse: (response) => ({\n        ...response,\n        published_at: new Date(response.published_at),\n      }),\n      responseSchema: transformedPost,\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Implicitly Typed Endpoint with Schema Validation in Redux Toolkit Query\nDESCRIPTION: This snippet shows how to create implicitly typed endpoints using schema validation in Redux Toolkit Query. It demonstrates type inference from query parameters and response schemas, including a transformed response example.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage-with-typescript.mdx#2025-04-17_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport * as v from 'valibot'\n\nconst postSchema = v.object({\n  id: v.number(),\n  name: v.string(),\n})\ntype Post = v.InferOutput<typeof postSchema>\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getPost: build.query({\n      // infer arg from here\n      query: ({ id }: { id: number }) => `/post/${id}`,\n      // infer result from here\n      responseSchema: postSchema,\n    }),\n    getTransformedPost: build.query({\n      // infer arg from here\n      query: ({ id }: { id: number }) => `/post/${id}`,\n      // infer untransformed result from here\n      rawResponseSchema: postSchema,\n      // infer transformed result from here\n      transformResponse: (response) => ({\n        ...response,\n        published_at: new Date(response.published_at),\n      }),\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Cache Tag Typing with ProvidesTags\nDESCRIPTION: Shows how to implement and type cache tag invalidation system using providesTags. Demonstrates proper typing for list handling with const assertions.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage-with-typescript.mdx#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\ntype PostsResponse = Post[]\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Posts'],\n  endpoints: (build) => ({\n    getPosts: build.query<PostsResponse, void>({\n      query: () => 'posts',\n      providesTags: (result) =>\n        result\n          ? [\n              ...result.map(({ id }) => ({ type: 'Posts' as const, id })),\n              { type: 'Posts', id: 'LIST' },\n            ]\n          : [{ type: 'Posts', id: 'LIST' }],\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Immutable Updates Manually in JavaScript\nDESCRIPTION: Demonstrates how to perform immutable updates on objects and arrays using JavaScript's spread operators and array methods.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/usage/immer-reducers.md#2025-04-17_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst obj = {\n  a: {\n    // To safely update obj.a.c, we have to copy each piece\n    c: 3,\n  },\n  b: 2,\n}\n\nconst obj2 = {\n  // copy obj\n  ...obj,\n  // overwrite a\n  a: {\n    // copy obj.a\n    ...obj.a,\n    // overwrite c\n    c: 42,\n  },\n}\n\nconst arr = ['a', 'b']\n// Create a new copy of arr, with \"c\" appended to the end\nconst arr2 = arr.concat('c')\n\n// or, we can make a copy of the original array:\nconst arr3 = arr.slice()\n// and mutate the copy:\narr3.push('c')\n```\n\n----------------------------------------\n\nTITLE: Example: Using patchQueryData\nDESCRIPTION: Example showing how to use updateQueryData to make an optimistic update and then later revert those changes using either patchQueryData with inversePatches or the undo function from the patchCollection.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/api-slice-utils.mdx#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst patchCollection = dispatch(\n  api.util.updateQueryData('getPosts', undefined, (draftPosts) => {\n    draftPosts.push({ id: 1, name: 'Teddy' })\n  }),\n)\n\n// later\ndispatch(\n  api.util.patchQueryData(\n    'getPosts',\n    undefined,\n    patchCollection.inversePatches,\n  ),\n)\n\n// or\npatchCollection.undo()\n```\n\n----------------------------------------\n\nTITLE: Typing a Custom BaseQuery Function in TypeScript\nDESCRIPTION: This example shows how to type a custom baseQuery function using the BaseQueryFn type, specifying types for arguments, result, error, extra options, and metadata.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage-with-typescript.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi } from '@reduxjs/toolkit/query'\nimport type { BaseQueryFn } from '@reduxjs/toolkit/query'\n\nconst simpleBaseQuery: BaseQueryFn<\n  string, // Args\n  unknown, // Result\n  { reason: string }, // Error\n  { shout?: boolean }, // DefinitionExtraOptions\n  { timestamp: number } // Meta\n> = (arg, api, extraOptions) => {\n  const meta = { timestamp: Date.now() }\n\n  if (arg === 'forceFail') {\n    return {\n      error: {\n        reason: 'Intentionally requested to fail!',\n        meta,\n      },\n    }\n  }\n\n  if (extraOptions.shout) {\n    return { data: 'CONGRATULATIONS', meta }\n  }\n\n  return { data: 'congratulations', meta }\n}\n\nconst api = createApi({\n  baseQuery: simpleBaseQuery,\n  endpoints: (build) => ({\n    getSupport: build.query({\n      query: () => 'support me',\n      extraOptions: {\n        shout: true,\n      },\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Optimizing selectFromResult with Stable Empty Array in React and TypeScript\nDESCRIPTION: This example shows how to use a stable empty array reference when using selectFromResult to avoid unnecessary rerenders caused by recreating empty arrays on each render.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/queries.mdx#2025-04-17_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n// An array declared here will maintain a stable reference rather than be re-created again\nconst emptyArray: Post[] = []\n\nfunction PostsList() {\n  // This call will result in an initial render returning an empty array for `posts`,\n  // and a second render when the data is received.\n  // It will trigger additional rerenders only if the `posts` data changes\n  const { posts } = api.useGetPostsQuery(undefined, {\n    selectFromResult: ({ data }) => ({\n      posts: data ?? emptyArray,\n    }),\n  })\n\n  return (\n    <ul>\n      {posts.map((post) => (\n        <PostById key={post.id} id={post.id} />\n      ))}\n    </ul>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Redux Toolkit Query Cache Manually in React Component\nDESCRIPTION: This snippet demonstrates how to manually update the cache for a specific query in Redux Toolkit Query. It uses the useAppDispatch hook to access the dispatch function and the api.util.updateQueryData method to modify the cache data for the 'getPosts' endpoint.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/manual-cache-updates.mdx#2025-04-17_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { api } from './api'\nimport { useAppDispatch } from './store/hooks'\n\nfunction App() {\n  const dispatch = useAppDispatch()\n\n  function handleClick() {\n    /**\n     * This will update the cache data for the query corresponding to the `getPosts` endpoint,\n     * when that endpoint is used with no argument (undefined).\n     */\n    const patchCollection = dispatch(\n      api.util.updateQueryData('getPosts', undefined, (draftPosts) => {\n        draftPosts.push({ id: 1, name: 'Teddy' })\n      }),\n    )\n  }\n\n  return <button onClick={handleClick}>Add post to cache</button>\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Error Handling with rejectWithValue\nDESCRIPTION: Example of using rejectWithValue to customize error handling in async thunks.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAsyncThunk.mdx#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst updateUser = createAsyncThunk(\n  'users/update',\n  async (userData, { rejectWithValue }) => {\n    const { id, ...fields } = userData\n    try {\n      const response = await userAPI.updateById(id, fields)\n      return response.data.user\n    } catch (err) {\n      return rejectWithValue(err.response.data)\n    }\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Using Settled Matcher in Redux Reducers\nDESCRIPTION: Implementation of the settled matcher for handling both fulfilled and rejected actions in Redux reducers.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAsyncThunk.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst reducer1 = createReducer(initialState, (builder) => {\n  builder.addMatcher(fetchUserById.settled, (state, action) => {})\n})\n\nconst reducer2 = createSlice({\n  name: 'users',\n  initialState,\n  reducers: {},\n  extraReducers: (builder) => {\n    builder.addMatcher(fetchUserById.settled, (state, action) => {})\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using useLazyQuery Hook in Redux Toolkit\nDESCRIPTION: Demonstrates how to use the useLazyQuery hook to manually trigger queries. Returns a tuple containing a trigger function, result object, and promise info.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/hooks.mdx#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst [trigger, result, lastPromiseInfo] =\n  api.endpoints.getPosts.useLazyQuery(options)\n// or\nconst [trigger, result, lastPromiseInfo] = api.useLazyGetPostsQuery(options)\n```\n\n----------------------------------------\n\nTITLE: Using .unwrap() for Immediate Error Access in TypeScript\nDESCRIPTION: Demonstrates how to use the .unwrap() method to immediately access error or success payload after a mutation.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/error-handling.mdx#2025-04-17_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\naddPost({ id: 1, name: 'Example' })\n  .unwrap()\n  .then((payload) => console.log('fulfilled', payload))\n  .catch((error) => console.error('rejected', error))\n```\n\n----------------------------------------\n\nTITLE: Initializing Entity State Structure in Redux\nDESCRIPTION: Demonstrates the structure of the entity state object created by createEntityAdapter. It includes an ids array for unique identifiers and an entities object for lookup by ID.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createEntityAdapter.mdx#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  // The unique IDs of each item. Must be strings or numbers\n  ids: []\n  // A lookup table mapping entity IDs to the corresponding entity objects\n  entities: {\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Empty API Service in RTK Query\nDESCRIPTION: Sets up a basic empty API service with createApi that will be used as the foundation for code splitting. This creates the base API with fetchBaseQuery configured but no endpoints, allowing endpoints to be injected later.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/code-splitting.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Or from '@reduxjs/toolkit/query' if not using the auto-generated hooks\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n\n// initialize an empty api service that we'll inject endpoints into later as needed\nexport const emptySplitApi = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: () => ({}),\n})\n```\n\n----------------------------------------\n\nTITLE: Fetching User Data with Loading State Management in Redux Toolkit\nDESCRIPTION: Demonstrates how to implement a user fetch operation with loading state tracking and request deduplication using createAsyncThunk. Includes slice configuration with extra reducers for handling pending, fulfilled, and rejected states.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAsyncThunk.mdx#2025-04-17_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAsyncThunk, createSlice } from '@reduxjs/toolkit'\nimport { userAPI, User } from './userAPI'\n\nconst fetchUserById = createAsyncThunk<\n  User,\n  string,\n  {\n    state: { users: { loading: string; currentRequestId: string } }\n  }\n>('users/fetchByIdStatus', async (userId: string, { getState, requestId }) => {\n  const { currentRequestId, loading } = getState().users\n  if (loading !== 'pending' || requestId !== currentRequestId) {\n    return\n  }\n  const response = await userAPI.fetchById(userId)\n  return response.data\n})\n\nconst usersSlice = createSlice({\n  name: 'users',\n  initialState: {\n    entities: [],\n    loading: 'idle',\n    currentRequestId: undefined,\n    error: null,\n  },\n  reducers: {},\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchUserById.pending, (state, action) => {\n        if (state.loading === 'idle') {\n          state.loading = 'pending'\n          state.currentRequestId = action.meta.requestId\n        }\n      })\n      .addCase(fetchUserById.fulfilled, (state, action) => {\n        const { requestId } = action.meta\n        if (\n          state.loading === 'pending' &&\n          state.currentRequestId === requestId\n        ) {\n          state.loading = 'idle'\n          state.entities.push(action.payload)\n          state.currentRequestId = undefined\n        }\n      })\n      .addCase(fetchUserById.rejected, (state, action) => {\n        const { requestId } = action.meta\n        if (\n          state.loading === 'pending' &&\n          state.currentRequestId === requestId\n        ) {\n          state.loading = 'idle'\n          state.error = action.error\n          state.currentRequestId = undefined\n        }\n      })\n  },\n})\n\nconst UsersComponent = () => {\n  const { entities, loading, error } = useSelector((state) => state.users)\n  const dispatch = useDispatch()\n\n  const fetchOneUser = async (userId) => {\n    try {\n      const user = await dispatch(fetchUserById(userId)).unwrap()\n      showToast('success', `Fetched ${user.name}`)\n    } catch (err) {\n      showToast('error', `Fetch failed: ${err.message}`)\n    }\n  }\n\n  // render UI here\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Response Status Validation in Redux Toolkit Query\nDESCRIPTION: Illustrates how to implement a custom validateStatus function to handle non-standard API response status codes in Redux Toolkit Query.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/fetchBaseQuery.mdx#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\n\nexport const customApi = createApi({\n  // Set the baseUrl for every endpoint below\n  baseQuery: fetchBaseQuery({ baseUrl: '/api/' }),\n  endpoints: (build) => ({\n    getUsers: build.query({\n      query: () => ({\n        url: `users`,\n        // Example: we have a backend API always returns a 200,\n        // but sets an `isError` property when there is an error.\n        validateStatus: (response, result) =>\n          response.status === 200 && !result.isError,\n      }),\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Customizing Default Middleware Options\nDESCRIPTION: Demonstrates how to customize middleware options, such as disabling serializable checks and configuring thunk's extra argument.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/getDefaultMiddleware.mdx#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configureStore } from '@reduxjs/toolkit'\nimport rootReducer from './reducer'\nimport { myCustomApiService } from './api'\n\nconst store = configureStore({\n  reducer: rootReducer,\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware({\n      thunk: {\n        extraArgument: myCustomApiService,\n      },\n      serializableCheck: false,\n    }),\n})\n```\n\n----------------------------------------\n\nTITLE: Using usePrefetch Hook in Redux Toolkit\nDESCRIPTION: Shows how to use the usePrefetch hook to initiate data fetching ahead of time with manual control.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/hooks.mdx#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst prefetchCallback = api.usePrefetch(endpointName, options)\n```\n\n----------------------------------------\n\nTITLE: Using updateQueryData Utility in Redux Toolkit API Slices\nDESCRIPTION: The updateQueryData utility creates and applies JSON diff/patch objects to current state, returning a PatchCollection object containing patches, inversePatches, and an undo function. This is typically used as the first step in implementing optimistic updates.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/api-slice-utils.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst updateQueryData = (\n  endpointName: string,\n  arg: any,\n  updateRecipe: (draft: Draft<CachedState>) => void,\n  updateProvided?: boolean,\n) => ThunkAction<PatchCollection, PartialState, any, AnyAction>\n\ninterface PatchCollection {\n  patches: Patch[]\n  inversePatches: Patch[]\n  undo: () => void\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Redux Slice for Pokemon Data Management with TypeScript\nDESCRIPTION: Defines a Redux slice that manages Pokemon data and request statuses. The slice handles pending, fulfilled, and rejected states of the fetch operation, storing the appropriate status and data for each Pokemon name.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/migrating-to-rtk-query.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype RequestState = 'pending' | 'fulfilled' | 'rejected'\n\nexport const pokemonSlice = createSlice({\n  name: 'pokemon',\n  initialState: {\n    dataByName: {} as Record<string, Pokemon | undefined>,\n    statusByName: {} as Record<string, RequestState | undefined>,\n  },\n  reducers: {},\n  extraReducers: (builder) => {\n    // When our request is pending:\n    // - store the 'pending' state as the status for the corresponding pokemon name\n    builder.addCase(fetchPokemonByName.pending, (state, action) => {\n      state.statusByName[action.meta.arg] = 'pending'\n    })\n    // When our request is fulfilled:\n    // - store the 'fulfilled' state as the status for the corresponding pokemon name\n    // - and store the received payload as the data for the corresponding pokemon name\n    builder.addCase(fetchPokemonByName.fulfilled, (state, action) => {\n      state.statusByName[action.meta.arg] = 'fulfilled'\n      state.dataByName[action.meta.arg] = action.payload\n    })\n    // When our request is rejected:\n    // - store the 'rejected' state as the status for the corresponding pokemon name\n    builder.addCase(fetchPokemonByName.rejected, (state, action) => {\n      state.statusByName[action.meta.arg] = 'rejected'\n    })\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Creating and Configuring Dynamic Middleware in Redux Toolkit\nDESCRIPTION: This snippet demonstrates how to create a dynamic middleware instance and configure it with a Redux store using Redux Toolkit's configureStore function.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createDynamicMiddleware.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createDynamicMiddleware, configureStore } from '@reduxjs/toolkit'\n\nconst dynamicMiddleware = createDynamicMiddleware()\n\nconst store = configureStore({\n  reducer: {\n    todos: todosReducer,\n  },\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware().prepend(dynamicMiddleware.middleware),\n})\n```\n\n----------------------------------------\n\nTITLE: Using RTK Query with GraphQL in React\nDESCRIPTION: This example shows how to integrate RTK Query with GraphQL in a React application.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/examples.mdx#2025-04-17_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// Example code not provided in the original text\n```\n\n----------------------------------------\n\nTITLE: State Reset and Replacement Patterns\nDESCRIPTION: Demonstrates correct ways to reset or replace entire state values, avoiding common mistakes with direct state assignment.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/usage/immer-reducers.md#2025-04-17_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nconst initialState = []\nconst todosSlice = createSlice({\n  name: 'todos',\n  initialState,\n  reducers: {\n    brokenTodosLoadedReducer(state, action) {\n      //  ERROR: does not actually mutate or return anything new!\n      state = action.payload\n    },\n    fixedTodosLoadedReducer(state, action) {\n      //  CORRECT: returns a new value to replace the old one\n      return action.payload\n    },\n    correctResetTodosReducer(state, action) {\n      //  CORRECT: returns a new value to replace the old one\n      return initialState\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: useQuery Hook Type Definition\nDESCRIPTION: Type definition for the useQuery hook including options and result types. Used for making data fetching queries with RTK Query.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/hooks.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ntype UseQuery = (\n  arg: any | SkipToken,\n  options?: UseQueryOptions,\n) => UseQueryResult\n\ntype UseQueryOptions = {\n  pollingInterval?: number\n  skipPollingIfUnfocused?: boolean\n  refetchOnReconnect?: boolean\n  refetchOnFocus?: boolean\n  skip?: boolean\n  refetchOnMountOrArgChange?: boolean | number\n  selectFromResult?: (result: UseQueryStateDefaultResult) => any\n}\n\ntype UseQueryResult<T> = {\n  originalArgs?: unknown\n  data?: T\n  currentData?: T\n  error?: unknown\n  requestId?: string\n  endpointName?: string\n  startedTimeStamp?: number\n  fulfilledTimeStamp?: number\n\n  isUninitialized: boolean\n  isLoading: boolean\n  isFetching: boolean\n  isSuccess: boolean\n  isError: boolean\n\n  refetch: () => QueryActionCreatorResult\n}\n```\n\n----------------------------------------\n\nTITLE: Legacy Hand-written Redux Implementation with Action Creators and Reducer\nDESCRIPTION: Example of traditional Redux implementation showing manually written action type constants, action creators, and a reducer function with switch statement. This demonstrates the verbose pattern that Redux Toolkit aims to replace.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/introduction/why-rtk-is-redux-today.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst ADD_TODO = 'ADD_TODO'\nconst TODO_TOGGLED = 'TODO_TOGGLED'\n\nexport const addTodo = (text) => ({\n  type: ADD_TODO,\n  payload: { text, id: nanoid() },\n})\n\nexport const todoToggled = (id) => ({\n  type: TODO_TOGGLED,\n  payload: { id },\n})\n\nexport const todosReducer = (state = [], action) => {\n  switch (action.type) {\n    case ADD_TODO:\n      return state.concat({\n        id: action.payload.id,\n        text: action.payload.text,\n        completed: false,\n      })\n    case TODO_TOGGLED:\n      return state.map((todo) => {\n        if (todo.id !== action.payload.id) return todo\n\n        return {\n          ...todo,\n          completed: !todo.completed,\n        }\n      })\n    default:\n      return state\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Selectors with Injected Redux Slices\nDESCRIPTION: Illustrates how selectors work with injected slices, showing how they handle undefined state by using initial state, and how they respect custom reducer paths. Demonstrates different selector scenarios and their outputs.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/combineSlices.mdx#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconsole.log(\n  injectedCounterSlice.selectors.selectValue({}), // 0\n  injectedCounterSlice.selectors.selectValue({ counter: { value: 2 } }), // 2\n  aCounterSlice.selectors.selectValue({ aCounter: { value: 2 } }), // 2\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing RTK Query in React Class Components\nDESCRIPTION: This example demonstrates how to use RTK Query with React Class Components, specifically in the PostDetail component.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/examples.mdx#2025-04-17_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// Example code not provided in the original text\n```\n\n----------------------------------------\n\nTITLE: Injecting Reducers with combineSlices in Redux Toolkit\nDESCRIPTION: Shows how to inject additional reducers into a combined reducer after initialization, including both slice-like objects and API instances.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/combineSlices.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst withUserReducer = rootReducer.inject({\n  reducerPath: 'user',\n  reducer: userReducer,\n})\n\nconst withApiReducer = rootReducer.inject(fooApi)\n```\n\n----------------------------------------\n\nTITLE: Displaying Query Error in React Component\nDESCRIPTION: Demonstrates how to access and display error information from a query hook in a React component.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/error-handling.mdx#2025-04-17_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction PostsList() {\n  const { data, error } = useGetPostsQuery()\n\n  return (\n    <div>\n      {error.status} {JSON.stringify(error.data)}\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Explicitly Typed Endpoint with Schema Validation in Redux Toolkit Query\nDESCRIPTION: This snippet demonstrates how to create an explicitly typed endpoint with schema validation using Redux Toolkit Query and Valibot. It defines a post schema and uses it for response validation in a getPost query.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage-with-typescript.mdx#2025-04-17_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport * as v from 'valibot'\n\nconst postSchema = v.object({\n  id: v.number(),\n  name: v.string(),\n})\ntype Post = v.InferOutput<typeof postSchema>\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getPost: build.query<Post, { id: number }>({\n      query: ({ id }) => `/post/${id}`,\n      responseSchema: postSchema, // errors if type mismatch\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Error Handling in QueryFn with fetchBaseQuery\nDESCRIPTION: Shows how to implement error handling in a queryFn using fetchBaseQuery's error type structure. Includes validation and error response formatting.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage-with-typescript.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport { getRandomName } from './randomData'\n\ninterface Post {\n  id: number\n  name: string\n}\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getPost: build.query<Post, number>({\n      queryFn: (arg, queryApi, extraOptions, baseQuery) => {\n        if (arg <= 0) {\n          return {\n            error: {\n              status: 500,\n              statusText: 'Internal Server Error',\n              data: 'Invalid ID provided.',\n            },\n          }\n        }\n        const post: Post = {\n          id: arg,\n          name: getRandomName(),\n        }\n        return { data: post }\n      },\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Cache Retention with keepUnusedDataFor in RTK Query\nDESCRIPTION: Example showing how to configure cache retention times both globally for an API and for specific endpoints using the keepUnusedDataFor option.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/cache-behavior.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport type { Post } from './types'\n\nexport const api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  // global configuration for the api\n  keepUnusedDataFor: 30,\n  endpoints: (build) => ({\n    getPosts: build.query<Post[], number>({\n      query: () => `posts`,\n      // configuration for an individual endpoint, overriding the api setting\n      keepUnusedDataFor: 5,\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Typed Endpoints for Queries in TypeScript\nDESCRIPTION: This snippet illustrates how to define a typed endpoint for a query, including specifying the ResultType and QueryArg, as well as using transformResponse with proper typing.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage-with-typescript.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getPost: build.query<Post, number>({\n      query: (id) => `post/${id}`,\n      transformResponse: (rawResult: { result: { post: Post } }, meta) => {\n        return rawResult.result.post\n      },\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Transforming Query Response Example in TypeScript\nDESCRIPTION: Demonstrates how to use the transformResponse option to manipulate the data returned from a query before it's stored in the cache.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/createApi.mdx#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ntransformResponse: (response, meta, arg) =>\n  response.some.deeply.nested.collection\n```\n\n----------------------------------------\n\nTITLE: Implementing Redux Slice with TypeScript\nDESCRIPTION: Creates a Redux slice with TypeScript types for state and actions, including PayloadAction types for proper type inference.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/tutorials/typescript.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSlice } from '@reduxjs/toolkit'\nimport type { PayloadAction } from '@reduxjs/toolkit'\nimport type { RootState } from '../../app/store'\n\ninterface CounterState {\n  value: number\n}\n\nconst initialState: CounterState = {\n  value: 0,\n}\n\nexport const counterSlice = createSlice({\n  name: 'counter',\n  initialState,\n  reducers: {\n    increment: (state) => {\n      state.value += 1\n    },\n    decrement: (state) => {\n      state.value -= 1\n    },\n    incrementByAmount: (state, action: PayloadAction<number>) => {\n      state.value += action.payload\n    },\n  },\n})\n\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions\n\nexport const selectCount = (state: RootState) => state.counter.value\n\nexport default counterSlice.reducer\n```\n\n----------------------------------------\n\nTITLE: Demonstrating React Hook Usage in TypeScript\nDESCRIPTION: This code snippet shows how to use the auto-generated React hooks from an API slice, including both the endpoint-attached hooks and the uniquely named hooks on the API object.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/overview.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Hooks attached to the endpoint definition\nconst { data } = api.endpoints.getPosts.useQuery()\nconst { data } = api.endpoints.updatePost.useMutation()\n\n// Same hooks, but given unique names and attached to the API slice object\nconst { data } = api.useGetPostsQuery()\nconst [updatePost] = api.useUpdatePostMutation()\n```\n\n----------------------------------------\n\nTITLE: Async/Await with Thunk Unwrapping\nDESCRIPTION: Using async/await syntax with .unwrap() for handling thunk results.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAsyncThunk.mdx#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst onClick = async () => {\n  try {\n    const originalPromiseResult = await dispatch(fetchUserById(userId)).unwrap()\n    // handle result here\n  } catch (rejectedValueOrSerializedError) {\n    // handle error here\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Force Refetch in RTK Query React Components\nDESCRIPTION: Example demonstrating how to force refetch data using both the refetch function from useQuery hook and the initiate thunk action.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/cache-behavior.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useDispatch } from 'react-redux'\nimport { useGetPostsQuery } from './api'\n\nconst Component = () => {\n  const dispatch = useDispatch()\n  const { data, refetch } = useGetPostsQuery({ count: 5 })\n\n  function handleRefetchOne() {\n    // force re-fetches the data\n    refetch()\n  }\n\n  function handleRefetchTwo() {\n    // has the same effect as `refetch` for the associated query\n    dispatch(\n      api.endpoints.getPosts.initiate(\n        { count: 5 },\n        { subscribe: false, forceRefetch: true },\n      ),\n    )\n  }\n\n  return (\n    <div>\n      <button onClick={handleRefetchOne}>Force re-fetch 1</button>\n      <button onClick={handleRefetchTwo}>Force re-fetch 2</button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Fetching with Skip Parameter in RTK Query\nDESCRIPTION: Demonstrates how to use the 'skip' parameter in RTK Query hooks to conditionally fetch data. The skip option allows delaying the query execution until a specific condition is met.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/conditional-fetching.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nUseQuerySubscriptionOptions.skip\n```\n\n----------------------------------------\n\nTITLE: Defining Infinite Query Endpoint for Pokemon API in TypeScript\nDESCRIPTION: This snippet demonstrates how to define an infinite query endpoint for a Pokemon API using RTK Query. It includes type definitions, infinite query options, and the query function.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/infinite-queries.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Pokemon = {\n  id: string\n  name: string\n}\n\nconst pokemonApi = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com/pokemon' }),\n  endpoints: (build) => ({\n    // 3 TS generics: page contents, query arg, page param\n    getInfinitePokemonWithMax: build.infiniteQuery<Pokemon[], string, number>({\n      infiniteQueryOptions: {\n        // Must provide a default initial page param value\n        initialPageParam: 1,\n        // Optionally limit the number of cached pages\n        maxPages: 3,\n        // Must provide a `getNextPageParam` function\n        getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) =>\n          lastPageParam + 1,\n        // Optionally provide a `getPreviousPageParam` function\n        getPreviousPageParam: (\n          firstPage,\n          allPages,\n          firstPageParam,\n          allPageParams,\n        ) => {\n          return firstPageParam > 0 ? firstPageParam - 1 : undefined\n        },\n      },\n      // The `query` function receives `{queryArg, pageParam}` as its argument\n      query({ queryArg, pageParam }) {\n        return `/type/${queryArg}?page=${pageParam}`\n      },\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Normalizing Data with createEntityAdapter in RTK Query (TypeScript)\nDESCRIPTION: Shows how to use createEntityAdapter with transformResponse to normalize API response data before storing it in the Redux Toolkit Query cache.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/customizing-queries.mdx#2025-04-17_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport { createEntityAdapter } from '@reduxjs/toolkit'\nimport type { EntityState } from '@reduxjs/toolkit'\n\nexport interface Post {\n  id: number\n  name: string\n}\n\nconst postsAdapter = createEntityAdapter<Post>({\n  sortComparer: (a, b) => a.name.localeCompare(b.name),\n})\n\nexport const api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getPosts: build.query<EntityState<Post, number>, void>({\n      query: () => `posts`,\n      transformResponse(response: Post[]) {\n        return postsAdapter.addMany(postsAdapter.getInitialState(), response)\n      },\n    }),\n  }),\n})\n\nexport const { useGetPostsQuery } = api\n```\n\n----------------------------------------\n\nTITLE: Defining API Slice Structure in TypeScript\nDESCRIPTION: This code snippet shows the structure of an API slice object generated by createApi, including Redux integration, endpoints, utilities, and React hooks.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/overview.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    // ...\n  }),\n})\n\ntype Api = {\n  // Redux integration\n  reducerPath: string\n  reducer: Reducer\n  middleware: Middleware\n\n  // Endpoint interactions\n  endpoints: Record<string, EndpointDefinition>\n\n  // Code splitting and generation\n  injectEndpoints: (options: InjectEndpointsOptions) => UpdatedApi\n  enhanceEndpoints: (options: EnhanceEndpointsOptions) => UpdatedApi\n\n  // Utilities\n  utils: {\n    updateQueryData: UpdateQueryDataThunk\n    patchQueryData: PatchQueryDataThunk\n    prefetch: PrefetchThunk\n    invalidateTags: ActionCreatorWithPayload<\n      Array<TagTypes | FullTagDescription<TagTypes>>,\n      string\n    >\n    selectInvalidatedBy: (\n      state: FullState,\n      tags: Array<TagTypes | FullTagDescription<TagTypes>>,\n    ) => Array<{\n      endpointName: string\n      originalArgs: any\n      queryCacheKey: string\n    }>\n    selectCachedArgsForQuery: (\n      state: FullState,\n      endpointName: EndpointName,\n    ) => Array<QueryArg>\n    resetApiState: ActionCreator<ResetAction>\n    getRunningQueryThunk(\n      endpointName: EndpointName,\n      args: QueryArg,\n    ): ThunkWithReturnValue<QueryActionCreatorResult | undefined>\n    getRunningMutationThunk(\n      endpointName: EndpointName,\n      fixedCacheKeyOrRequestId: string,\n    ): ThunkWithReturnValue<MutationActionCreatorResult | undefined>\n    getRunningQueriesThunk(): ThunkWithReturnValue<\n      Array<QueryActionCreatorResult<any>>\n    >\n    getRunningMutationsThunk(): ThunkWithReturnValue<\n      Array<MutationActionCreatorResult<any>>\n    >\n  }\n\n  // Internal actions\n  internalActions: InternalActions\n\n  // React hooks (if applicable)\n  [key in GeneratedReactHooks]: GeneratedReactHooks[key]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing onQueryStarted Query Lifecycle in TypeScript\nDESCRIPTION: Demonstrates the implementation of onQueryStarted for a query endpoint. It shows how to handle different lifecycle stages such as start, success, and error, dispatching actions to update the application state accordingly.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/createApi.mdx#2025-04-17_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n// file: notificationsSlice.ts noEmit\nexport const messageCreated = (msg: string) => ({\n  type: 'notifications/messageCreated',\n  payload: msg,\n})\n\n// file: api.ts\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport { messageCreated } from './notificationsSlice'\n\nexport interface Post {\n  id: number\n  name: string\n}\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  endpoints: (build) => ({\n    getPost: build.query<Post, number>({\n      query: (id) => `post/${id}`,\n      async onQueryStarted(id, { dispatch, queryFulfilled }) {\n        // `onStart` side-effect\n        dispatch(messageCreated('Fetching post...'))\n        try {\n          const { data } = await queryFulfilled\n          // `onSuccess` side-effect\n          dispatch(messageCreated('Post received!'))\n        } catch (err) {\n          // `onError` side-effect\n          dispatch(messageCreated('Error fetching post!'))\n        }\n      },\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Redux State Slice with TypeScript\nDESCRIPTION: Defines a counter slice using createSlice from Redux Toolkit. It includes the initial state, reducer functions, and exports action creators.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/tutorials/quick-start.mdx#2025-04-17_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { createSlice } from '@reduxjs/toolkit'\nimport type { PayloadAction } from '@reduxjs/toolkit'\n\nexport interface CounterState {\n  value: number\n}\n\nconst initialState: CounterState = {\n  value: 0,\n}\n\nexport const counterSlice = createSlice({\n  name: 'counter',\n  initialState,\n  reducers: {\n    increment: (state) => {\n      state.value += 1\n    },\n    decrement: (state) => {\n      state.value -= 1\n    },\n    incrementByAmount: (state, action: PayloadAction<number>) => {\n      state.value += action.payload\n    },\n  },\n})\n\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions\n\nexport default counterSlice.reducer\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Catching Middleware in TypeScript\nDESCRIPTION: Demonstrates how to create a custom middleware for catching and handling RTK Query errors at a global level, including logging and displaying toast notifications.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/error-handling.mdx#2025-04-17_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport { isRejectedWithValue } from '@reduxjs/toolkit'\nimport type { MiddlewareAPI, Middleware } from '@reduxjs/toolkit'\nimport { toast } from 'your-cool-library'\n\n/**\n * Log a warning and show a toast!\n */\nexport const rtkQueryErrorLogger: Middleware =\n  (api: MiddlewareAPI) => (next) => (action) => {\n    // RTK Query uses `createAsyncThunk` from redux-toolkit under the hood, so we're able to utilize these matchers!\n    if (isRejectedWithValue(action)) {\n      console.warn('We got a rejected action!')\n      toast.warn({\n        title: 'Async error!',\n        message:\n          'data' in action.error\n            ? (action.error.data as { message: string }).message\n            : action.error.message,\n      })\n    }\n\n    return next(action)\n  }\n```\n\n----------------------------------------\n\nTITLE: Creating Empty API Base for Code Generation in TypeScript\nDESCRIPTION: Creates an empty API using createApi that will be used as the base for generated endpoints. This pattern allows for injecting endpoints later as needed.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/code-generation.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Or from '@reduxjs/toolkit/query' if not using the auto-generated hooks\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n\n// initialize an empty api service that we'll inject endpoints into later as needed\nexport const emptySplitApi = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: () => ({}),\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Pagination in Redux Toolkit Infinite Query\nDESCRIPTION: This snippet shows how to implement basic pagination in a Redux Toolkit infinite query. It defines getNextPageParam and getPreviousPageParam functions to handle page number calculations for simple APIs.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/infinite-queries.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst pokemonApi = createApi({\n  baseQuery,\n  endpoints: (build) => ({\n    getInfinitePokemon: build.infiniteQuery<Pokemon[], string, number>({\n      infiniteQueryOptions: {\n        initialPageParam: 0,\n        getNextPageParam: (lastPage, allPages, lastPageParam) =>\n          lastPageParam + 1,\n        getPreviousPageParam: (firstPage, allPages, firstPageParam) => {\n          return firstPageParam > 0 ? firstPageParam - 1 : undefined\n        },\n      },\n      query({ pageParam }) {\n        return `https://example.com/listItems?page=${pageParam}`\n      },\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Using Entity Adapter Selectors in Redux Store\nDESCRIPTION: This snippet demonstrates how to use entity adapter selectors with a Redux store, showing both simple and globalized selector usage.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createEntityAdapter.mdx#2025-04-17_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst store = configureStore({\n  reducer: {\n    books: booksReducer,\n  },\n})\n\nconst simpleSelectors = booksAdapter.getSelectors()\nconst globalizedSelectors = booksAdapter.getSelectors((state) => state.books)\n\n// Need to manually pass the correct entity state object in to this selector\nconst bookIds = simpleSelectors.selectIds(store.getState().books)\n\n// This selector already knows how to find the books entity state\nconst allBooks = globalizedSelectors.selectAll(store.getState())\n```\n\n----------------------------------------\n\nTITLE: Displaying Mutation Error in React Component\nDESCRIPTION: Shows how to access and display error information from a mutation hook in a React component.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/error-handling.mdx#2025-04-17_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nfunction AddPost() {\n  const [addPost, { error }] = useAddPostMutation()\n\n  return (\n    <div>\n      {error.status} {JSON.stringify(error.data)}\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring AsyncThunk with Lifecycle Actions\nDESCRIPTION: Demonstrates creating an async thunk with lifecycle action handlers including pending, rejected, fulfilled, and settled states, along with custom options.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createSlice.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ncreate.asyncThunk(\n  async (id: string, thunkApi) => {\n    const res = await fetch(`myApi/todos?id=${id}`)\n    return (await res.json()) as Item\n  },\n  {\n    pending: (state) => {\n      state.loading = true\n    },\n    rejected: (state, action) => {\n      state.error = action.payload ?? action.error\n    },\n    fulfilled: (state, action) => {\n      state.todos.push(action.payload)\n    },\n    settled: (state, action) => {\n      state.loading = false\n    }\n    options: {\n      idGenerator: uuid,\n    },\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Limit-Offset Pagination in RTK Query (TypeScript)\nDESCRIPTION: This snippet shows how to implement limit-offset based pagination in RTK Query. It defines types for the API response and initial page parameters, and implements getNextPageParam and getPreviousPageParam functions to handle offset-based navigation.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/infinite-queries.mdx#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport type ProjectsResponse = {\n  projects: Project[]\n  numFound: number\n  serverTime: string\n}\n\ntype ProjectsInitialPageParam = {\n  offset: number\n  limit: number\n}\n\nconst projectsApi = createApi({\n  baseQuery,\n  endpoints: (build) => ({\n    projectsLimitOffset: build.infiniteQuery<\n      ProjectsResponse,\n      void,\n      ProjectsInitialPageParam\n    >({\n      infiniteQueryOptions: {\n        initialPageParam: {\n          offset: 0,\n          limit: 20,\n        },\n        getNextPageParam: (\n          lastPage,\n          allPages,\n          lastPageParam,\n          allPageParams,\n        ) => {\n          const nextOffset = lastPageParam.offset + lastPageParam.limit\n          const remainingItems = lastPage?.numFound - nextOffset\n\n          if (remainingItems <= 0) {\n            return undefined\n          }\n\n          return {\n            ...lastPageParam,\n            offset: nextOffset,\n          }\n        },\n        getPreviousPageParam: (\n          firstPage,\n          allPages,\n          firstPageParam,\n          allPageParams,\n        ) => {\n          const prevOffset = firstPageParam.offset - firstPageParam.limit\n          if (prevOffset < 0) return undefined\n\n          return {\n            ...firstPageParam,\n            offset: firstPageParam.offset - firstPageParam.limit,\n          }\n        },\n      },\n      query: ({ pageParam: { offset, limit } }) => {\n        return `https://example.com/api/projectsLimitOffset?offset=${offset}&limit=${limit}`\n      },\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Checking Cancellation Status in Redux Toolkit Thunk\nDESCRIPTION: This snippet demonstrates how to regularly check if a thunk has been aborted using the signal.aborted property, allowing for stopping long-running work.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAsyncThunk.mdx#2025-04-17_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAsyncThunk } from '@reduxjs/toolkit'\n\nconst readStream = createAsyncThunk(\n  'readStream',\n  async (stream: ReadableStream, { signal }) => {\n    const reader = stream.getReader()\n\n    let done = false\n    let result = ''\n\n    while (!done) {\n      if (signal.aborted) {\n        throw new Error('stop the work, this has been aborted!')\n      }\n      const read = await reader.read()\n      result += read.value\n      done = read.done\n    }\n    return result\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Immutability Middleware Example\nDESCRIPTION: Example showing how to create and configure a custom instance of the immutability middleware with specific ignored paths.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/immutabilityMiddleware.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSlice } from '@reduxjs/toolkit'\n\nexport const exampleSlice = createSlice({\n  name: 'example',\n  initialState: {\n    user: 'will track changes',\n    ignoredPath: 'single level',\n    ignoredNested: {\n      one: 'one',\n      two: 'two',\n    },\n  },\n  reducers: {},\n})\n\nexport default exampleSlice.reducer\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  configureStore,\n  createImmutableStateInvariantMiddleware,\n  Tuple,\n} from '@reduxjs/toolkit'\n\nimport exampleSliceReducer from './exampleSlice'\n\nconst immutableInvariantMiddleware = createImmutableStateInvariantMiddleware({\n  ignoredPaths: ['ignoredPath', 'ignoredNested.one', 'ignoredNested.two'],\n})\n\nconst store = configureStore({\n  reducer: exampleSliceReducer,\n  middleware: () => new Tuple(immutableInvariantMiddleware),\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Tag Invalidation Handler in TypeScript\nDESCRIPTION: Core handler implementation that processes three different invalidation triggers: mutation completion, query completion, and manual invalidation.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/internal/buildMiddleware/invalidationByTags.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst handler: ApiMiddlewareInternalHandler = (action, mwApi) => {\n  if (isThunkActionWithTags(action)) {\n    invalidateTags(\n      calculateProvidedByThunk(\n        action,\n        'invalidatesTags',\n        endpointDefinitions,\n        assertTagType,\n      ),\n      mwApi,\n    )\n  } else if (isQueryEnd(action)) {\n    invalidateTags([], mwApi)\n  } else if (api.util.invalidateTags.match(action)) {\n    invalidateTags(\n      calculateProvidedBy(\n        action.payload,\n        undefined,\n        undefined,\n        undefined,\n        undefined,\n        assertTagType,\n      ),\n      mwApi,\n    )\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using skipToken for Type-Safe Query Skipping\nDESCRIPTION: Demonstrates the recommended approach of using skipToken to handle conditional query execution in a type-safe manner.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage-with-typescript.mdx#2025-04-17_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport { skipToken } from '@reduxjs/toolkit/query/react'\nimport { useGetPostQuery } from './api'\n\nfunction MaybePost({ id }: { id?: number }) {\n  const { data } = useGetPostQuery(id ?? skipToken)\n\n  return <div>...</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Using Immer for Immutable Updates\nDESCRIPTION: Demonstrates how to use Immer's produce function to simplify immutable updates on complex nested structures.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/usage/immer-reducers.md#2025-04-17_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { produce } from 'immer'\n\nconst baseState = [\n  {\n    todo: 'Learn typescript',\n    done: true,\n  },\n  {\n    todo: 'Try immer',\n    done: false,\n  },\n]\n\nconst nextState = produce(baseState, (draftState) => {\n  // \"mutate\" the draft array\n  draftState.push({ todo: 'Tweet about it' })\n  // \"mutate\" the nested state\n  draftState[1].done = true\n})\n\nconsole.log(baseState === nextState)\n// false - the array was copied\nconsole.log(baseState[0] === nextState[0])\n// true - the first item was unchanged, so same reference\nconsole.log(baseState[1] === nextState[1])\n// false - the second item was copied and updated\n```\n\n----------------------------------------\n\nTITLE: Defining Entity Adapter CRUD Function Signature in TypeScript\nDESCRIPTION: This snippet shows the TypeScript signature for entity adapter CRUD functions. These functions accept an EntityState and an argument, returning an updated EntityState.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createEntityAdapter.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n;(state: EntityState<T>, argument: TypeOrPayloadAction<Argument<T>>) =>\n  EntityState<T>\n```\n\n----------------------------------------\n\nTITLE: Initiating a Mutation in React with Redux Toolkit\nDESCRIPTION: This example shows how to initiate a mutation using the initiate function in a React component with Redux Toolkit.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/endpoints.mdx#2025-04-17_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react'\nimport { useAppDispatch } from './store/hooks'\nimport { api, Post } from './services/api'\n\nfunction App() {\n  const dispatch = useAppDispatch()\n  const [newPost, setNewPost] = useState<Omit<Post, 'id'>>({ name: 'Ash' })\n\n  function handleClick() {\n    // highlight-start\n    // Trigger a mutation\n    // The `track` property can be set `false` in situations where we aren't\n    // interested in the result of the mutation\n    dispatch(api.endpoints.addPost.initiate(newPost), { track: false })\n    // highlight-end\n  }\n\n  return (\n    <div>\n      <div>Initiate mutation example</div>\n      <button onClick={handleClick}>Add post</button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Unwrapping Thunk Results with .unwrap()\nDESCRIPTION: Examples of using the .unwrap() method to handle success and error cases from thunk actions.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAsyncThunk.mdx#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst onClick = () => {\n  dispatch(fetchUserById(userId))\n    .unwrap()\n    .then((originalPromiseResult) => {\n      // handle result here\n    })\n    .catch((rejectedValueOrSerializedError) => {\n      // handle error here\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Using AbortSignal with Axios in Redux Toolkit Thunk\nDESCRIPTION: This example illustrates how to use the AbortSignal with Axios in a Redux Toolkit thunk, demonstrating cancellation of HTTP requests.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAsyncThunk.mdx#2025-04-17_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAsyncThunk } from '@reduxjs/toolkit'\nimport axios from 'axios'\n\nconst fetchUserById = createAsyncThunk(\n  'users/fetchById',\n  async (userId: string, { signal }) => {\n    const source = axios.CancelToken.source()\n    signal.addEventListener('abort', () => {\n      source.cancel()\n    })\n    const response = await axios.get(`https://reqres.in/api/users/${userId}`, {\n      cancelToken: source.token,\n    })\n    return response.data\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Using Third-Party SDK in RTK Query queryFn (TypeScript)\nDESCRIPTION: Demonstrates how to use a third-party SDK (Supabase in this example) within a queryFn in Redux Toolkit Query API definition.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/customizing-queries.mdx#2025-04-17_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fakeBaseQuery } from '@reduxjs/toolkit/query/react'\nimport { supabase } from './supabaseApi'\n\nexport const supabaseApi = createApi({\n  reducerPath: 'supabaseApi',\n  baseQuery: fakeBaseQuery(),\n  endpoints: (build) => ({\n    getBlogs: build.query({\n      queryFn: async () => {\n        const { data, error } = await supabase.from('blogs').select()\n        if (error) {\n          return { error }\n        }\n        return { data }\n      },\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Generated React Hook Names Example - TypeScript\nDESCRIPTION: Demonstrates the two ways to access generated hooks - through endpoints or through auto-generated named hooks on the API object\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/hooks.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Hooks attached to the endpoint definition\nconst { data } = api.endpoints.getPosts.useQuery()\nconst [updatePost, { data }] = api.endpoints.updatePost.useMutation()\n\n// Same hooks, but given unique names and attached to the API slice object\nconst { data } = api.useGetPostsQuery()\nconst [updatePost, { data }] = api.useUpdatePostMutation()\n```\n\n----------------------------------------\n\nTITLE: Customizing React-Redux Hooks in createApi for Redux Toolkit Query\nDESCRIPTION: This snippet demonstrates how to customize the React-Redux hooks used by createApi, allowing for use with a custom context. It imports necessary functions and creates a custom createApi function with modified hooks.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/customizing-create-api.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as React from 'react'\nimport {\n  createDispatchHook,\n  createSelectorHook,\n  createStoreHook,\n  ReactReduxContextValue,\n} from 'react-redux'\nimport {\n  buildCreateApi,\n  coreModule,\n  reactHooksModule,\n} from '@reduxjs/toolkit/query/react'\n\nconst MyContext = React.createContext<ReactReduxContextValue | null>(null)\nconst customCreateApi = buildCreateApi(\n  coreModule(),\n  reactHooksModule({\n    hooks: {\n      useDispatch: createDispatchHook(MyContext),\n      useSelector: createSelectorHook(MyContext),\n      useStore: createStoreHook(MyContext),\n    },\n  }),\n)\n```\n\n----------------------------------------\n\nTITLE: Cache Invalidation Core Logic in JavaScript\nDESCRIPTION: Implements the core cache invalidation logic that processes invalidated queries and either removes them or triggers refetching based on subscription status.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/internal/buildMiddleware/invalidationByTags.mdx#2025-04-17_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst toInvalidate = api.util.selectInvalidatedBy(rootState, tags)\ncontext.batch(() => {\n  const valuesArray = Array.from(toInvalidate.values())\n  for (const { queryCacheKey } of valuesArray) {\n    const querySubState = state.queries[queryCacheKey]\n    const subscriptionSubState =\n      internalState.currentSubscriptions[queryCacheKey] ?? {}\n    if (querySubState) {\n      if (countObjectKeys(subscriptionSubState) === 0) {\n        mwApi.dispatch(\n          removeQueryResult({\n            queryCacheKey,\n          }),\n        )\n      } else if (querySubState.status !== 'uninitialized' /* uninitialized */) {\n        mwApi.dispatch(refetchQuery(querySubState, queryCacheKey))\n      }\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Using Creator Callback Notation in createSlice\nDESCRIPTION: This snippet demonstrates the creator callback notation for defining reducers in createSlice. It includes examples of standard reducers, prepared reducers, and async thunks, showcasing more advanced usage of the API.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createSlice.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSlice, nanoid } from '@reduxjs/toolkit'\n\ninterface Item {\n  id: string\n  text: string\n}\n\ninterface TodoState {\n  loading: boolean\n  todos: Item[]\n}\n\nconst todosSlice = createSlice({\n  name: 'todos',\n  initialState: {\n    loading: false,\n    todos: [],\n  } satisfies TodoState as TodoState,\n  reducers: (create) => ({\n    deleteTodo: create.reducer<number>((state, action) => {\n      state.todos.splice(action.payload, 1)\n    }),\n    addTodo: create.preparedReducer(\n      (text: string) => {\n        const id = nanoid()\n        return { payload: { id, text } }\n      },\n      // action type is inferred from prepare callback\n      (state, action) => {\n        state.todos.push(action.payload)\n      },\n    ),\n    fetchTodo: create.asyncThunk(\n      async (id: string, thunkApi) => {\n        const res = await fetch(`myApi/todos?id=${id}`)\n        return (await res.json()) as Item\n      },\n      {\n        pending: (state) => {\n          state.loading = true\n        },\n        rejected: (state, action) => {\n          state.loading = false\n        },\n        fulfilled: (state, action) => {\n          state.loading = false\n          state.todos.push(action.payload)\n        },\n      },\n    ),\n  }),\n})\n\nexport const { addTodo, deleteTodo, fetchTodo } = todosSlice.actions\n```\n\n----------------------------------------\n\nTITLE: No-op queryFn for Cache Invalidation in RTK Query (TypeScript)\nDESCRIPTION: Illustrates how to use a no-op queryFn to trigger cache invalidation without making an actual API request in Redux Toolkit Query.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/customizing-queries.mdx#2025-04-17_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { Post, User } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Post', 'User'],\n  endpoints: (build) => ({\n    getPosts: build.query<Post[], void>({\n      query: () => 'posts',\n      providesTags: ['Post'],\n    }),\n\n    getUsers: build.query<User[], void>({\n      query: () => 'users',\n      providesTags: ['User'],\n    }),\n\n    refetchPostsAndUsers: build.mutation<null, void>({\n      queryFn: () => ({ data: null }),\n      invalidatesTags: ['Post', 'User'],\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: CreateSlice Return Value Structure\nDESCRIPTION: TypeScript interface showing the structure of the object returned by createSlice, including reducer, actions, and selector properties.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createSlice.mdx#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n{\n    name: string,\n    reducer: ReducerFunction,\n    actions: Record<string, ActionCreator>,\n    caseReducers: Record<string, CaseReducer>.\n    getInitialState: () => State,\n    reducerPath: string,\n    selectSlice: Selector;\n    selectors: Record<string, Selector>,\n    getSelectors: (selectState: (rootState: RootState) => State) => Record<string, Selector>\n    injectInto: (injectable: Injectable, config?: InjectConfig & { reducerPath?: string }) => InjectedSlice\n}\n```\n\n----------------------------------------\n\nTITLE: Using Infinite Query Hook with Custom Initial Page Parameter in TypeScript\nDESCRIPTION: This snippet shows how to use an infinite query hook with a custom initial page parameter. It overrides the default initialPageParam specified in the endpoint definition.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/infinite-queries.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst { data } = useGetPokemonInfiniteQuery('fire', {\n  initialPageParam: 3,\n})\n```\n\n----------------------------------------\n\nTITLE: Alternative Manual Prefetching Method\nDESCRIPTION: An alternative approach to manual prefetching by directly dispatching the endpoint's initiate action. This method requires the developer to implement any additional logic for controlling the prefetch behavior.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/prefetching.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndispatch(api.endpoints[endpointName].initiate(arg, { forceRefetch: true }))\n```\n\n----------------------------------------\n\nTITLE: Using Endpoints in Redux Toolkit API\nDESCRIPTION: This code snippet demonstrates how to define and use endpoints in a Redux Toolkit API. It shows the creation of query and mutation endpoints, and explains how they can be accessed and used in the application.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/createApi.mdx#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\ntype PostsResponse = Post[]\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Posts'],\n  endpoints: (build) => ({\n    getPosts: build.query<PostsResponse, void>({\n      query: () => 'posts',\n      providesTags: (result) =>\n        result ? result.map(({ id }) => ({ type: 'Posts', id })) : [],\n    }),\n    addPost: build.mutation<Post, Partial<Post>>({\n      query: (body) => ({\n        url: `posts`,\n        method: 'POST',\n        body,\n      }),\n      invalidatesTags: ['Posts'],\n    }),\n  }),\n})\n\n// Auto-generated hooks\nexport const { useGetPostsQuery, useAddPostMutation } = api\n\n// Possible exports\nexport const { endpoints, reducerPath, reducer, middleware } = api\n```\n\n----------------------------------------\n\nTITLE: Basic Redux Store Setup with Default Middleware\nDESCRIPTION: Shows the basic usage of configureStore with default middleware automatically added.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/getDefaultMiddleware.mdx#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst store = configureStore({\n  reducer: rootReducer,\n})\n\n// Store has middleware added, because the middleware list was not customized\n```\n\n----------------------------------------\n\nTITLE: Implementing Base Query Error Handling Examples\nDESCRIPTION: Demonstrates correct and incorrect approaches to implementing error handling in custom base queries.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/customizing-queries.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction brokenCustomBaseQuery() {\n  //  Don't let this throw by itself\n  const data = await fetchSomeData()\n  return { data }\n}\n\nfunction correctCustomBaseQuery() {\n  //  Catch errors and _return_ them so the RTKQ logic can track it\n  try {\n    const data = await fetchSomeData()\n    return { data }\n  } catch (error) {\n    return { error }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Cached Data in RTK Query\nDESCRIPTION: Demonstrates how to add a cache subscription using the initiate thunk action creator. This allows fetching data for an endpoint and interacting with the cache similar to using a useFetch hook.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/usage-without-react-hooks.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst promise = dispatch(api.endpoints.getPosts.initiate())\nconst { refetch } = promise\n// interact with the cache in the same way as you would with a useFetch...() hook\nconst { data, isLoading, isSuccess /*...*/ } = await promise\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Hook for Pokemon Data Fetching in TypeScript\nDESCRIPTION: This snippet defines a custom hook 'useGetPokemonByNameQuery' that manages fetching Pokemon data by name. It uses Redux Toolkit's createAsyncThunk and React-Redux hooks to handle state management and API calls.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/migrating-to-rtk-query.mdx#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useEffect } from 'react'\nimport { useSelector } from 'react-redux'\nimport { useAppDispatch } from './store'\nimport type { RootState } from './store'\nimport {\n  fetchPokemonByName,\n  selectStatusByName,\n  selectDataByName,\n} from './services/pokemonSlice'\n\nexport function useGetPokemonByNameQuery(name: string) {\n  const dispatch = useAppDispatch()\n  const status = useSelector((state: RootState) =>\n    selectStatusByName(state, name),\n  )\n  const data = useSelector((state: RootState) => selectDataByName(state, name))\n  useEffect(() => {\n    if (status === undefined) {\n      dispatch(fetchPokemonByName(name))\n    }\n  }, [status, name, dispatch])\n\n  const isUninitialized = status === undefined\n  const isLoading = status === 'pending' || status === undefined\n  const isError = status === 'rejected'\n  const isSuccess = status === 'fulfilled'\n\n  return { data, isUninitialized, isLoading, isError, isSuccess }\n}\n```\n\n----------------------------------------\n\nTITLE: Example 1 Supplementary: How the cache key is matched\nDESCRIPTION: Examples of various hook and dispatch calls that would create a cache entry matching 'getPosts(undefined)' that can be updated with the updateQueryData example.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/api-slice-utils.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\napi.endpoints.getPosts.useQuery()\n\nuseGetPostsQuery()\n\nuseGetPostsQuery(undefined, { ...options })\n\ndispatch(api.endpoints.getPosts.initiate())\n\ndispatch(api.endpoints.getPosts.initiate(undefined, { ...options }))\n```\n\n----------------------------------------\n\nTITLE: Defining QueryFn Signature in TypeScript\nDESCRIPTION: Specifies the TypeScript signature for the queryFn function used in endpoint definitions. It defines the structure of the function, its parameters, and expected return types.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/createApi.mdx#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nqueryFn(\n  arg: QueryArg,\n  api: BaseQueryApi,\n  extraOptions: BaseQueryExtraOptions<BaseQuery>,\n  baseQuery: (arg: Parameters<BaseQuery>[0]) => ReturnType<BaseQuery>\n): MaybePromise<\n| {\n    error: BaseQueryError<BaseQuery>\n    data?: undefined\n  }\n| {\n    error?: undefined\n    data: ResultType\n  }\n>\n\nexport interface BaseQueryApi {\n  signal: AbortSignal\n  dispatch: ThunkDispatch<any, any, any>\n  getState: () => unknown\n}\n```\n\n----------------------------------------\n\nTITLE: Using withMiddleware for Dynamic Dispatch in Redux Toolkit\nDESCRIPTION: This code demonstrates how to use the withMiddleware method to create an action that injects middleware and returns a typed dispatch function.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createDynamicMiddleware.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst listenerDispatch = store.dispatch(\n  withMiddleware(listenerMiddleware.middleware),\n)\n\nconst unsubscribe = listenerDispatch(addListener({ type, effect }))\n```\n\n----------------------------------------\n\nTITLE: Accessing Cached Data and Request Status in RTK Query\nDESCRIPTION: Illustrates how to use the select function of a query endpoint to create a selector and access cache data and request status information from the Redux state.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/usage-without-react-hooks.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = api.endpoints.getPosts.select()(state)\nconst { data, isSuccess, isError, error } = result\n```\n\n----------------------------------------\n\nTITLE: Transforming GraphQL Data in RTK Query (TypeScript)\nDESCRIPTION: Demonstrates how to unpack deeply nested GraphQL data using a custom graphqlBaseQuery and transformResponse function in a Redux Toolkit Query API definition.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/customizing-queries.mdx#2025-04-17_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi } from '@reduxjs/toolkit/query'\nimport { graphqlBaseQuery, gql } from './graphqlBaseQuery'\n\ninterface Post {\n  id: number\n  title: string\n}\n\nexport const api = createApi({\n  baseQuery: graphqlBaseQuery({\n    baseUrl: '/graphql',\n  }),\n  endpoints: (build) => ({\n    getPosts: build.query<Post[], void>({\n      query: () => ({\n        body: gql`\n          query {\n            posts {\n              data {\n                id\n                title\n              }\n            }\n          }\n        `,\n      }),\n      transformResponse: (response: { posts: { data: Post[] } }) =>\n        response.posts.data,\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Slice Selectors Basic Example\nDESCRIPTION: Example showing how to create and use basic selectors with createSlice, including accessing slice state and selector unwrapping.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createSlice.mdx#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSlice } from '@reduxjs/toolkit'\n\ninterface CounterState {\n  value: number\n}\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: { value: 0 } satisfies CounterState as CounterState,\n  reducers: {\n    // omitted\n  },\n  selectors: {\n    selectValue: (sliceState) => sliceState.value,\n  },\n})\n\nconsole.log(counterSlice.selectSlice({ counter: { value: 2 } })) // { value: 2 }\n\nconst { selectValue } = counterSlice.selectors\n\nconsole.log(selectValue({ counter: { value: 2 } })) // 2\n```\n\n----------------------------------------\n\nTITLE: Defining injectEndpoints Function Signature in TypeScript\nDESCRIPTION: This snippet shows the TypeScript signature for the injectEndpoints function, which allows for runtime injection of additional endpoint definitions into an API slice. It includes options for overriding existing endpoints.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/code-splitting.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst injectEndpoints = (endpointOptions: InjectedEndpointOptions) =>\n  EnhancedApiSlice\n\ninterface InjectedEndpointOptions {\n  endpoints: (build: EndpointBuilder) => NewEndpointDefinitions\n  /**\n   * Optionally allows endpoints to be overridden if defined by multiple `injectEndpoints` calls.\n   *\n   * If set to `true`, will override existing endpoints with the new definition.\n   * If set to `'throw'`, will throw an error if an endpoint is redefined with a different definition.\n   * If set to `false` (or unset), will not override existing endpoints with the new definition, and log a warning in development.\n   */\n  overrideExisting?: boolean | 'throw'\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Field Updates in Redux Toolkit\nDESCRIPTION: Shows different approaches to updating multiple fields at once, including object spread operations and Object.assign usage.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/usage/immer-reducers.md#2025-04-17_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nfunction objectCaseReducer3(state, action) {\n  const { a, b, c, d } = action.payload\n  Object.assign(state, { a, b, c, d })\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Implementation with Redux Toolkit Queries\nDESCRIPTION: Example React component showing how to use the Redux Toolkit query hooks for fetching posts and handling post addition, demonstrating the practical application of tag invalidation.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/automated-refetching.mdx#2025-04-17_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nfunction App() {\n  const { data: posts } = useGetPostsQuery()\n  const [addPost] = useAddPostMutation()\n\n  return (\n    <div>\n      <AddPost onAdd={addPost} />\n      <PostsList />\n      {/* Assume each PostDetail is subscribed via `const {data} = useGetPostQuery(id)` */}\n      <PostDetail id={1} />\n      <PostDetail id={2} />\n      <PostDetail id={3} />\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Tag Invalidation in Redux Toolkit\nDESCRIPTION: Demonstrates a basic implementation of tag-based cache invalidation where adding a post invalidates all post-related queries. Shows how general tag invalidation can cause unnecessary refetching of individual post details.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/automated-refetching.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport type { Post, User } from './types'\n\nexport const api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Posts'],\n  endpoints: (build) => ({\n    getPosts: build.query<Post[], void>({\n      query: () => 'posts',\n      providesTags: (result) =>\n        result ? result.map(({ id }) => ({ type: 'Posts', id })) : ['Posts'],\n    }),\n    addPost: build.mutation<Post, Partial<Post>>({\n      query: (body) => ({\n        url: `post`,\n        method: 'POST',\n        body,\n      }),\n      invalidatesTags: ['Posts'],\n    }),\n    getPost: build.query<Post, number>({\n      query: (id) => `post/${id}`,\n      providesTags: (result, error, id) => [{ type: 'Posts', id }],\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring unstable__sideEffectsInRender for Non-Next.js SSR\nDESCRIPTION: Alternative approach for SSR in frameworks other than Next.js, using unstable__sideEffectsInRender option to allow asynchronous work during render instead of in effects.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/server-side-rendering.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n[examples](docblock://query/react/module.ts?token=ReactHooksModuleOptions.unstable__sideEffectsInRender)\n```\n\n----------------------------------------\n\nTITLE: Defining Query Function Signature in TypeScript\nDESCRIPTION: Specifies the TypeScript signature for the query function used in endpoint definitions. It defines how query arguments are handled and what the function should return.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/createApi.mdx#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport type query = <QueryArg>(\n  arg: QueryArg,\n) => string | Record<string, unknown>\n\n// with `fetchBaseQuery`\nexport type query = <QueryArg>(arg: QueryArg) => string | FetchArgs\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of autoBatchEnhancer in Redux Toolkit\nDESCRIPTION: Demonstrates how to configure a Redux store with autoBatchEnhancer and create slice reducers with batched and unbatched actions using prepareAutoBatched utility.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/autoBatchEnhancer.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  createSlice,\n  configureStore,\n  autoBatchEnhancer,\n  prepareAutoBatched,\n} from '@reduxjs/toolkit'\n\ninterface CounterState {\n  value: number\n}\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: { value: 0 } satisfies CounterState as CounterState,\n  reducers: {\n    incrementBatched: {\n      // Batched, low-priority\n      reducer(state) {\n        state.value += 1\n      },\n      // highlight-start\n      // Use the `prepareAutoBatched` utility to automatically\n      // add the `action.meta[SHOULD_AUTOBATCH]` field the enhancer needs\n      prepare: prepareAutoBatched<void>(),\n      // highlight-end\n    },\n    // Not batched, normal priority\n    decrementUnbatched(state) {\n      state.value -= 1\n    },\n  },\n})\nconst { incrementBatched, decrementUnbatched } = counterSlice.actions\n\n// includes batch enhancer by default, as of RTK 2.0\nconst store = configureStore({\n  reducer: counterSlice.reducer,\n})\n```\n\n----------------------------------------\n\nTITLE: Handling Async Actions in Redux Reducers\nDESCRIPTION: Examples of handling async actions in reducers using createReducer and createSlice with the builder callback pattern.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAsyncThunk.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst reducer1 = createReducer(initialState, (builder) => {\n  builder.addCase(fetchUserById.fulfilled, (state, action) => {})\n})\n\nconst reducer2 = createSlice({\n  name: 'users',\n  initialState,\n  reducers: {},\n  extraReducers: (builder) => {\n    builder.addCase(fetchUserById.fulfilled, (state, action) => {})\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Refactoring Reducer with isAllOf\nDESCRIPTION: Demonstrates how to simplify the reducer logic using the isAllOf matcher utility, reducing code complexity and boilerplate.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/matching-utilities.mdx#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createReducer, isAllOf } from '@reduxjs/toolkit'\nimport {\n  isSpecialAndInterestingThunk,\n  initialState,\n  isSpecial,\n  isInteresting,\n} from '@virtual/matchers' // This is a fake pkg that provides the types shown above\nimport type { Data } from '@virtual/matchers' // This is a fake pkg that provides the types shown above\n\nconst loadingReducer = createReducer(initialState, (builder) => {\n  builder\n    .addMatcher(\n      isAllOf(isSpecialAndInterestingThunk.fulfilled, isSpecial),\n      (state, action) => {\n        state.isSpecial = true\n      },\n    )\n    .addMatcher(\n      isAllOf(isSpecialAndInterestingThunk.fulfilled, isInteresting),\n      (state, action) => {\n        state.isInteresting = true\n      },\n    )\n})\n```\n\n----------------------------------------\n\nTITLE: Typing Query Function with fetchBaseQuery in Redux Toolkit\nDESCRIPTION: Demonstrates how to properly type a queryFn with ResultType and QueryArg generics using fetchBaseQuery. Shows basic success case handling with proper type definitions.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage-with-typescript.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport { getRandomName } from './randomData'\n\ninterface Post {\n  id: number\n  name: string\n}\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getPost: build.query<Post, number>({\n      queryFn: (arg, queryApi, extraOptions, baseQuery) => {\n        const post: Post = {\n          id: arg,\n          name: getRandomName(),\n        }\n        return { data: post }\n      },\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Demonstrating RTK Query Cache Endpoints Example\nDESCRIPTION: Shows three different query endpoint examples that would result in separate cache entries for the same Todo item, demonstrating the non-normalized cache behavior of RTK Query.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/cache-behavior.mdx#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ngetTodos()\ngetTodos({filter: 'odd'})\ngetTodo({id: 1})\n```\n\n----------------------------------------\n\nTITLE: Injecting Redux Slice Into Root Reducer\nDESCRIPTION: Demonstrates basic usage of injectInto method to inject a slice into a root reducer. The method returns an injected version of the slice that can be used with the combined reducer.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/combineSlices.mdx#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst injectedCounterSlice = counterSlice.injectInto(rootReducer)\n```\n\n----------------------------------------\n\nTITLE: SelectInvalidatedBy Usage Examples in TypeScript\nDESCRIPTION: Examples demonstrating different ways to use selectInvalidatedBy with various tag formats.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/api-slice-utils.mdx#2025-04-17_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst entries = api.util.selectInvalidatedBy(state, ['Post'])\nconst entries = api.util.selectInvalidatedBy(state, [{ type: 'Post', id: 1 }])\nconst entries = api.util.selectInvalidatedBy(state, [\n  { type: 'Post', id: 1 },\n  { type: 'Post', id: 4 },\n])\n```\n\n----------------------------------------\n\nTITLE: useInfiniteQuery Hook Usage Example\nDESCRIPTION: Example showing how to access and use the useInfiniteQuery hook in RTK Query for paginated data fetching.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/hooks.mdx#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst useQueryResult = api.endpoints.getManyPosts.useInfiniteQuery(arg, options)\n// or\nconst useQueryResult = api.useGetManyPostsInfiniteQuery(arg, options)\n```\n\n----------------------------------------\n\nTITLE: Inline Error Handling in Component\nDESCRIPTION: Demonstrates practical error handling in a React component using type predicates and unwrap pattern.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage-with-typescript.mdx#2025-04-17_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react'\nimport { useSnackbar } from 'notistack'\nimport { api } from './services/api'\nimport { isFetchBaseQueryError, isErrorWithMessage } from './services/helpers'\n\nfunction AddPost() {\n  const { enqueueSnackbar, closeSnackbar } = useSnackbar()\n  const [name, setName] = useState('')\n  const [addPost] = useAddPostMutation()\n\n  async function handleAddPost() {\n    try {\n      await addPost(name).unwrap()\n      setName('')\n    } catch (err) {\n      if (isFetchBaseQueryError(err)) {\n        const errMsg = 'error' in err ? err.error : JSON.stringify(err.data)\n        enqueueSnackbar(errMsg, { variant: 'error' })\n      } else if (isErrorWithMessage(err)) {\n        enqueueSnackbar(err.message, { variant: 'error' })\n      }\n    }\n  }\n\n  return (\n    <div>\n      <input value={name} onChange={(e) => setName(e.target.value)} />\n      <button>Add post</button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Thunk Result Handling\nDESCRIPTION: Simple example of dispatching a thunk and handling its promise result.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAsyncThunk.mdx#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst onClick = () => {\n  dispatch(fetchUserById(userId)).then(() => {\n    // do additional work\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Using upsertQueryData Utility in Redux Toolkit API Slices\nDESCRIPTION: The upsertQueryData utility acts as an artificial API request to upsert a value into the cache. It asynchronously creates or overwrites a cache entry for a specific endpoint and argument with the provided data.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/api-slice-utils.mdx#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst upsertQueryData = <T>(endpointName: string, arg: any, newEntryData: T) =>\n  ThunkAction<Promise<CacheEntry<T>>, PartialState, any, UnknownAction>\n```\n\n----------------------------------------\n\nTITLE: Pre-populating Entity State with Initial Data in JavaScript\nDESCRIPTION: This snippet shows how to use getInitialState to create an initial entity state object with pre-populated entities and additional properties.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createEntityAdapter.mdx#2025-04-17_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst booksSlice = createSlice({\n  name: 'books',\n  initialState: booksAdapter.getInitialState(\n    {\n      loading: 'idle',\n    },\n    [\n      { id: 'a', title: 'First' },\n      { id: 'b', title: 'Second' },\n    ],\n  ),\n  reducers: {},\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Merge Functionality in QueryThunk Fulfillment\nDESCRIPTION: Handles merging of cache data when a query is fulfilled. It either merges existing cache data with new payload using Immer, or initializes fresh cache data if none exists.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/internal/buildSlice.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nif (merge) {\n  if (substate.data !== undefined) {\n    const { fulfilledTimeStamp, arg, baseQueryMeta, requestId } = meta\n    let newData = createNextState(substate.data, (draftSubstateData) => {\n      return merge(draftSubstateData, payload, {\n        arg: arg.originalArgs,\n        baseQueryMeta,\n        fulfilledTimeStamp,\n        requestId,\n      })\n    })\n    substate.data = newData\n  } else {\n    substate.data = payload\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Arrow Function State Mutation Patterns\nDESCRIPTION: Demonstrates correct and incorrect ways to handle state mutations in arrow functions, including solutions for avoiding implicit return issues.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/usage/immer-reducers.md#2025-04-17_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nconst todosSlice = createSlice({\n  name: 'todos',\n  initialState: [],\n  reducers: {\n    //  ERROR: mutates state, but also returns new array size!\n    brokenReducer: (state, action) => state.push(action.payload),\n    //  SAFE: the `void` keyword prevents a return value\n    fixedReducer1: (state, action) => void state.push(action.payload),\n    //  SAFE: curly braces make this a function body and no return\n    fixedReducer2: (state, action) => {\n      state.push(action.payload)\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Mutation onQueryStarted Signature in TypeScript\nDESCRIPTION: Defines the TypeScript signature for the onQueryStarted function in a mutation endpoint. It includes parameters for the query argument and a MutationLifecycleApi object containing various properties and methods.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/createApi.mdx#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nasync function onQueryStarted(\n  arg: QueryArg,\n  {\n    dispatch,\n    getState,\n    extra,\n    requestId,\n    queryFulfilled,\n    getCacheEntry,\n  }: MutationLifecycleApi,\n): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Configuring RTK Query Refetch on Mount or Arg Change\nDESCRIPTION: Demonstrates how to configure refetchOnMountOrArgChange at both the API and individual query level. Shows setting a global 30-second refetch window and overriding it per-component.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/cache-behavior.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport type { Post } from './types'\n\nexport const api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  refetchOnMountOrArgChange: 30,\n  endpoints: (build) => ({\n    getPosts: build.query<Post[], number>({\n      query: () => `posts`,\n    }),\n  }),\n})\n```\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useGetPostsQuery } from './api'\n\nconst Component = () => {\n  const { data } = useGetPostsQuery(\n    { count: 5 },\n    { refetchOnMountOrArgChange: true },\n  )\n\n  return <div>...</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Response Transformation Examples\nDESCRIPTION: Examples of transforming API response data using transformResponse, including collection normalization.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/customizing-queries.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ntransformResponse: (response) =>\n  response.reduce((acc, curr) => {\n    acc[curr.id] = curr\n    return acc\n  }, {})\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling and Cache Invalidation in RTK Query (TypeScript)\nDESCRIPTION: Demonstrates how to provide cache tags for different error scenarios and invalidate them with login and refetch mutations. Handles unauthorized errors and unknown errors separately.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/automated-refetching.mdx#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport { Post, LoginResponse } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com' }),\n  tagTypes: ['Post', 'UNAUTHORIZED', 'UNKNOWN_ERROR'],\n  endpoints: (build) => ({\n    postById: build.query<Post, number>({\n      query: (id) => `post/${id}`,\n      providesTags: (result, error, id) =>\n        result\n          ? [{ type: 'Post', id }]\n          : error?.status === 401\n            ? ['UNAUTHORIZED']\n            : ['UNKNOWN_ERROR'],\n    }),\n    login: build.mutation<LoginResponse, void>({\n      query: () => '/login',\n      // on successful login, will refetch all currently\n      // 'UNAUTHORIZED' queries\n      invalidatesTags: (result) => (result ? ['UNAUTHORIZED'] : []),\n    }),\n    refetchErroredQueries: build.mutation<null, void>({\n      queryFn: () => ({ data: null }),\n      invalidatesTags: ['UNKNOWN_ERROR'],\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Request Timeouts in Redux Toolkit Query\nDESCRIPTION: Demonstrates how to set custom timeout values for API requests at both the baseQuery level and for individual endpoints in Redux Toolkit Query.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/fetchBaseQuery.mdx#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\n\nexport const api = createApi({\n  // Set a default timeout of 10 seconds\n  baseQuery: fetchBaseQuery({ baseUrl: '/api/', timeout: 10000 }),\n  endpoints: (build) => ({\n    getUsers: build.query({\n      query: () => ({\n        url: `users`,\n        // Example: we know the users endpoint is _really fast_ because it's always cached.\n        // We can assume if it's over > 1000ms, something is wrong and we should abort the request.\n        timeout: 1000,\n      }),\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Using isRejectedWithValue in TypeScript\nDESCRIPTION: Demonstrates the usage of isRejectedWithValue utility to check if an action is a 'rejected' action created by rejectWithValue.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/matching-utilities.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isRejectedWithValue } from '@reduxjs/toolkit'\nimport type { UnknownAction } from '@reduxjs/toolkit'\nimport { requestThunk1, requestThunk2 } from '@virtual/matchers'\n\nconst isARejectedWithValueAction = isRejectedWithValue(\n  requestThunk1,\n  requestThunk2,\n)\n\nfunction handleRejectedWithValueAction(action: UnknownAction) {\n  if (isARejectedWithValueAction(action)) {\n    // action is a rejected action dispatched by either `requestThunk1` or `requestThunk2`\n    // where rejectWithValue was used\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using upsertQueryEntries Utility in Redux Toolkit API Slices\nDESCRIPTION: The upsertQueryEntries utility is a standard Redux action creator that accepts an array of cache entry descriptions and upserts them into the store. It's designed for efficiently bulk-inserting many entries at once.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/api-slice-utils.mdx#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * A typesafe single entry to be upserted into the cache\n */\nexport type NormalizedQueryUpsertEntry<\n  Definitions extends EndpointDefinitions,\n  EndpointName extends QueryKeys<Definitions>,\n> = {\n  endpointName: EndpointName\n  arg: QueryArgFrom<Definitions[EndpointName]>\n  value: ResultTypeFrom<Definitions[EndpointName]>\n}\n\nconst upsertQueryEntries = (entries: NormalizedQueryUpsertEntry[]) =>\n  PayloadAction<NormalizedQueryUpsertEntry[]>\n```\n\n----------------------------------------\n\nTITLE: Creating Redux Store Provider for Next.js App Router\nDESCRIPTION: This snippet demonstrates how to create a StoreProvider component that initializes and provides the Redux store to the application. It ensures the store is only created once and is re-render safe.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/usage/nextjs.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n'use client'\nimport { useRef } from 'react'\nimport { Provider } from 'react-redux'\nimport { makeStore, AppStore } from '../lib/store'\n\nexport default function StoreProvider({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  const storeRef = useRef<AppStore>(undefined)\n  if (!storeRef.current) {\n    // Create the store instance the first time this renders\n    storeRef.current = makeStore()\n  }\n\n  return <Provider store={storeRef.current}>{children}</Provider>\n}\n```\n\n----------------------------------------\n\nTITLE: Error Response Transformation Examples\nDESCRIPTION: Examples of transforming API error responses using transformErrorResponse.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/customizing-queries.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ntransformErrorResponse: (response, meta, arg) =>\n  response.data.some.deeply.nested.errorObject\n```\n\n----------------------------------------\n\nTITLE: Defining API Options and Endpoint Types in TypeScript for Redux Toolkit\nDESCRIPTION: This code defines types and interfaces for API options and endpoint definitions in Redux Toolkit. It includes CreateApiOptions, EndpointDefinition, and related types used for configuring API endpoints.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/toolkit/etc/rtk-query.api.md#2025-04-17_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n// @public (undocumented)\nexport interface CreateApiOptions<\n  BaseQuery extends BaseQueryFn,\n  Definitions extends EndpointDefinitions,\n  ReducerPath extends string = 'api',\n  TagTypes extends string = never,\n> {\n  baseQuery: BaseQuery\n  endpoints(\n    build: EndpointBuilder<BaseQuery, TagTypes, ReducerPath>,\n  ): Definitions\n  extractRehydrationInfo?: (\n    action: UnknownAction,\n    {\n      reducerPath,\n    }: {\n      reducerPath: ReducerPath\n    },\n  ) =>\n    | undefined\n    | CombinedState<\n        NoInfer<Definitions>,\n        NoInfer<TagTypes>,\n        NoInfer<ReducerPath>\n      >\n  keepUnusedDataFor?: number\n  reducerPath?: ReducerPath\n  refetchOnFocus?: boolean\n  refetchOnMountOrArgChange?: boolean | number\n  refetchOnReconnect?: boolean\n  serializeQueryArgs?: SerializeQueryArgs<unknown>\n  structuralSharing?: boolean\n  tagTypes?: readonly TagTypes[]\n}\n\n// @public (undocumented)\nexport type EndpointDefinition<\n  QueryArg,\n  BaseQuery extends BaseQueryFn,\n  TagTypes extends string,\n  ResultType,\n  ReducerPath extends string = string,\n> =\n  | QueryDefinition<QueryArg, BaseQuery, TagTypes, ResultType, ReducerPath>\n  | MutationDefinition<QueryArg, BaseQuery, TagTypes, ResultType, ReducerPath>\n\n// @public (undocumented)\nexport type EndpointDefinitions = Record<\n  string,\n  EndpointDefinition<any, any, any, any>\n>\n```\n\n----------------------------------------\n\nTITLE: Implementing Schema Validation in RTK Query (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use schema validation in RTK Query endpoints. It uses the Valibot library to define schemas for query arguments and responses, enabling runtime validation and TypeScript type inference.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/infinite-queries.mdx#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport * as v from 'valibot'\n\nconst pokemonSchema = v.object({\n  id: v.number(),\n  name: v.string(),\n})\ntype Pokemon = v.InferOutput<typeof pokemonSchema>\nconst transformedPokemonSchema = v.object({\n  ...pokemonSchema.entries,\n  id: v.string(),\n})\ntype TransformedPokemon = v.InferOutput<typeof transformedPokemonSchema>\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com/pokemon' }),\n  endpoints: (build) => ({\n    getInfinitePokemon: build.infiniteQuery<Pokemon[], string, number>({\n      query: ({ queryArg, pageParam }) => `type/${queryArg}?page=${pageParam}`,\n      // argSchema for infinite queries must have both queryArg and pageParam\n      argSchema: v.object({\n        queryArg: v.string(),\n        pageParam: v.number(),\n      }),\n      responseSchema: v.array(pokemonSchema),\n    }),\n    getTransformedPokemon: build.infiniteQuery<\n      TransformedPokemon[],\n      string,\n      number\n    >({\n      query: ({ queryArg, pageParam }) => `type/${queryArg}?page=${pageParam}`,\n      argSchema: v.object({\n        queryArg: v.string(),\n        pageParam: v.number(),\n      }),\n      rawResponseSchema: v.array(pokemonSchema),\n      transformResponse: (response) =>\n        response.map((pokemon) => ({\n          ...pokemon,\n          id: String(pokemon.id),\n        })),\n      // responseSchema can still be provided, to validate the transformed response\n      responseSchema: v.array(transformedPokemonSchema),\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Manually Triggering onFocus Event in RTK Query\nDESCRIPTION: Example showing how to manually dispatch the onFocus action from the API's internal actions, which can be useful when you need to trigger refetching outside of the normal window events.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/setupListeners.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndispatch(api.internalActions.onFocus())\n```\n\n----------------------------------------\n\nTITLE: Transforming Error Response Example in TypeScript\nDESCRIPTION: Shows how to use the transformErrorResponse option to manipulate the error returned from a query before it's stored in the cache.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/createApi.mdx#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ntransformErrorResponse: (response, meta, arg) =>\n  response.data.some.deeply.nested.errorObject\n```\n\n----------------------------------------\n\nTITLE: Combining Slices and Reducer Maps in Redux Toolkit\nDESCRIPTION: Illustrates how combineSlices can accept both slice objects and reducer map objects, combining them into a single reducer function.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/combineSlices.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst rootReducer = combineSlices(counterSlice, baseApi, {\n  user: userSlice.reducer,\n  auth: authSlice.reducer,\n})\n// is like\nconst rootReducer = combineReducers({\n  [counterSlice.reducerPath]: counterSlice.reducer,\n  [baseApi.reducerPath]: baseApi.reducer,\n  user: userSlice.reducer,\n  auth: authSlice.reducer,\n})\n```\n\n----------------------------------------\n\nTITLE: useQueryState Type Definitions\nDESCRIPTION: Type definitions for the useQueryState hook, including options and result interfaces.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/hooks.mdx#2025-04-17_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\ntype UseQueryState = (\n  arg: any | SkipToken,\n  options?: UseQueryStateOptions,\n) => UseQueryStateResult | SelectedQueryStateResult\n\ntype UseQueryStateOptions = {\n  skip?: boolean\n  selectFromResult?: (result: UseQueryStateDefaultResult) => any\n}\n\ntype UseQueryStateResult<T> = {\n  originalArgs?: unknown\n  data?: T\n  currentData?: T\n  error?: unknown\n  requestId?: string\n  endpointName?: string\n  startedTimeStamp?: number\n  fulfilledTimeStamp?: number\n\n  isUninitialized: boolean\n  isLoading: boolean\n  isFetching: boolean\n  isSuccess: boolean\n  isError: boolean\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Error Types with fakeBaseQuery\nDESCRIPTION: Demonstrates how to use fakeBaseQuery to define custom error types when not using a baseQuery. Includes multiple endpoint examples with custom error handling.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage-with-typescript.mdx#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fakeBaseQuery } from '@reduxjs/toolkit/query'\n\ntype CustomErrorType = { reason: 'too cold' | 'too hot' }\n\nconst api = createApi({\n  baseQuery: fakeBaseQuery<CustomErrorType>(),\n  endpoints: (build) => ({\n    eatPorridge: build.query<'just right', 1 | 2 | 3>({\n      queryFn(seat) {\n        if (seat === 1) {\n          return { error: { reason: 'too cold' } }\n        }\n\n        if (seat === 2) {\n          return { error: { reason: 'too hot' } }\n        }\n\n        return { data: 'just right' }\n      },\n    }),\n    microwaveHotPocket: build.query<'delicious!', number>({\n      queryFn(duration) {\n        if (duration < 110) {\n          return { error: { reason: 'too cold' } }\n        }\n        if (duration > 140) {\n          return { error: { reason: 'too hot' } }\n        }\n\n        return { data: 'delicious!' }\n      },\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Traditional Redux Reducer Implementation\nDESCRIPTION: Example of a basic counter reducer using traditional Redux switch statement pattern.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createReducer.mdx#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst initialState = { value: 0 }\n\nfunction counterReducer(state = initialState, action) {\n  switch (action.type) {\n    case 'increment':\n      return { ...state, value: state.value + 1 }\n    case 'decrement':\n      return { ...state, value: state.value - 1 }\n    case 'incrementByAmount':\n      return { ...state, value: state.value + action.payload }\n    default:\n      return state\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing catchSchemaFailure for Schema Validation in TypeScript\nDESCRIPTION: Shows an example of implementing the catchSchemaFailure function to handle schema validation failures in a non-fatal manner. It converts schema failures into a custom error shape that matches the base query errors.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/createApi.mdx#2025-04-17_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  catchSchemaFailure: (error, info) => ({\n    status: 'CUSTOM_ERROR',\n    error: error.schemaName + ' failed validation',\n    data: error,\n  }),\n  endpoints: (build) => ({\n    // ...\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Example 2: Using updateQueryData with a specific ID\nDESCRIPTION: Example showing how to use updateQueryData with the 'getPostById' endpoint and a specific ID parameter (1), which matches a query cache key of 'getPostById(1)'. This demonstrates updating a specific post's name.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/api-slice-utils.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst patchCollection = dispatch(\n  api.util.updateQueryData('getPostById', 1, (draftPost) => {\n    draftPost.name = 'Lilly'\n  }),\n)\n```\n\n----------------------------------------\n\nTITLE: Thunk Cancellation with Condition Callback\nDESCRIPTION: Implementation of conditional thunk execution using the condition callback option.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAsyncThunk.mdx#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst fetchUserById = createAsyncThunk(\n  'users/fetchByIdStatus',\n  async (userId: number, thunkAPI) => {\n    const response = await userAPI.fetchById(userId)\n    return response.data\n  },\n  {\n    condition: (userId, { getState, extra }) => {\n      const { users } = getState()\n      const fetchStatus = users.requests[userId]\n      if (fetchStatus === 'fulfilled' || fetchStatus === 'loading') {\n        return false\n      }\n    },\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: TypeScript Definitions for createEntityAdapter in Redux Toolkit\nDESCRIPTION: Provides TypeScript type definitions for the entity adapter and related interfaces in Redux Toolkit. This includes types for entity state, CRUD operations, and selectors.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createEntityAdapter.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport type EntityId = number | string\n\nexport type Comparer<T> = (a: T, b: T) => number\n\nexport type IdSelector<T> = (model: T) => EntityId\n\nexport type Update<T> = { id: EntityId; changes: Partial<T> }\n\nexport interface EntityState<T> {\n  ids: EntityId[]\n  entities: Record<EntityId, T>\n}\n\nexport interface EntityDefinition<T> {\n  selectId: IdSelector<T>\n  sortComparer: false | Comparer<T>\n}\n\nexport interface EntityStateAdapter<T> {\n  addOne<S extends EntityState<T>>(state: S, entity: T): S\n  addOne<S extends EntityState<T>>(state: S, action: PayloadAction<T>): S\n\n  addMany<S extends EntityState<T>>(state: S, entities: T[]): S\n  addMany<S extends EntityState<T>>(state: S, entities: PayloadAction<T[]>): S\n\n  setOne<S extends EntityState<T>>(state: S, entity: T): S\n  setOne<S extends EntityState<T>>(state: S, action: PayloadAction<T>): S\n\n  setMany<S extends EntityState<T>>(state: S, entities: T[]): S\n  setMany<S extends EntityState<T>>(state: S, entities: PayloadAction<T[]>): S\n\n  setAll<S extends EntityState<T>>(state: S, entities: T[]): S\n  setAll<S extends EntityState<T>>(state: S, entities: PayloadAction<T[]>): S\n\n  removeOne<S extends EntityState<T>>(state: S, key: EntityId): S\n  removeOne<S extends EntityState<T>>(state: S, key: PayloadAction<EntityId>): S\n\n  removeMany<S extends EntityState<T>>(state: S, keys: EntityId[]): S\n  removeMany<S extends EntityState<T>>(\n    state: S,\n    keys: PayloadAction<EntityId[]>,\n  ): S\n\n  removeAll<S extends EntityState<T>>(state: S): S\n\n  updateOne<S extends EntityState<T>>(state: S, update: Update<T>): S\n  updateOne<S extends EntityState<T>>(\n    state: S,\n    update: PayloadAction<Update<T>>,\n  ): S\n\n  updateMany<S extends EntityState<T>>(state: S, updates: Update<T>[]): S\n  updateMany<S extends EntityState<T>>(\n    state: S,\n    updates: PayloadAction<Update<T>[]>,\n  ): S\n\n  upsertOne<S extends EntityState<T>>(state: S, entity: T): S\n  upsertOne<S extends EntityState<T>>(state: S, entity: PayloadAction<T>): S\n\n  upsertMany<S extends EntityState<T>>(state: S, entities: T[]): S\n  upsertMany<S extends EntityState<T>>(\n    state: S,\n    entities: PayloadAction<T[]>,\n  ): S\n}\n\nexport interface EntitySelectors<T, V> {\n  selectIds: (state: V) => EntityId[]\n  selectEntities: (state: V) => Record<EntityId, T>\n  selectAll: (state: V) => T[]\n  selectTotal: (state: V) => number\n  selectById: (state: V, id: EntityId) => T | undefined\n}\n\nexport interface EntityAdapter<T> extends EntityStateAdapter<T> {\n  selectId: IdSelector<T>\n  sortComparer: false | Comparer<T>\n  getInitialState(): EntityState<T>\n  getInitialState<S extends object>(state: S): EntityState<T> & S\n  getSelectors(): EntitySelectors<T, EntityState<T>>\n  getSelectors<V>(\n    selectState: (state: V) => EntityState<T>,\n  ): EntitySelectors<T, V>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom usePrefetchImmediately Hook\nDESCRIPTION: Recipe for creating a custom hook that triggers prefetching immediately upon component mount. Uses useEffect to dispatch the prefetch action as soon as the component renders.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/prefetching.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ntype EndpointNames = keyof typeof api.endpoints\n\nexport function usePrefetchImmediately<T extends EndpointNames>(\n  endpoint: T,\n  arg: Parameters<(typeof api.endpoints)[T]['initiate']>[0],\n  options: PrefetchOptions = {},\n) {\n  const dispatch = useAppDispatch()\n  useEffect(() => {\n    dispatch(api.util.prefetch(endpoint, arg as any, options))\n  }, [])\n}\n\n// In a component\nusePrefetchImmediately('getUser', 5)\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Draft-Safe Selectors with WeakMap Memoization\nDESCRIPTION: Example showing how to create custom draft-safe selectors using createDraftSafeSelectorCreator with a different memoization strategy (weakMapMemoize) for specialized caching behavior.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createSelector.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  createDraftSafeSelectorCreator,\n  weakMapMemoize,\n} from '@reduxjs/toolkit'\n\nconst createWeakMapDraftSafeSelector =\n  createDraftSafeSelectorCreator(weakMapMemoize)\n\nconst selectSelf = (state: State) => state\nconst draftSafeSelector = createWeakMapDraftSafeSelector(\n  selectSelf,\n  (state) => state.value,\n)\n```\n\n----------------------------------------\n\nTITLE: Basic State Mutation Examples in Redux Toolkit\nDESCRIPTION: Demonstrates two valid approaches to state mutation using Immer: direct mutation of existing state and returning a new state value. Shows how to add and delete todos using both approaches.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/usage/immer-reducers.md#2025-04-17_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nconst todosSlice = createSlice({\n  name: 'todos',\n  initialState: [],\n  reducers: {\n    todoAdded(state, action) {\n      // \"Mutate\" the existing state, no return value needed\n      state.push(action.payload)\n    },\n    todoDeleted(state, action.payload) {\n      // Construct a new result array immutably and return it\n      return state.filter(todo => todo.id !== action.payload)\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Using createDraftSafeSelector with Immer in Redux Toolkit\nDESCRIPTION: Example demonstrating the difference between regular createSelector and createDraftSafeSelector when used with Immer draft objects in reducers. The safe selector recalculates when a draft object is modified, while the unsafe selector may return cached values incorrectly.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createSelector.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst selectSelf = (state: State) => state\nconst unsafeSelector = createSelector(selectSelf, (state) => state.value)\nconst draftSafeSelector = createDraftSafeSelector(\n  selectSelf,\n  (state) => state.value,\n)\n\n// in your reducer:\n\nstate.value = 1\n\nconst unsafe1 = unsafeSelector(state)\nconst safe1 = draftSafeSelector(state)\n\nstate.value = 2\n\nconst unsafe2 = unsafeSelector(state)\nconst safe2 = draftSafeSelector(state)\n```\n\n----------------------------------------\n\nTITLE: Canceling a Running Thunk in React Component\nDESCRIPTION: This snippet demonstrates how to cancel a running thunk in a React component using the abort method of the promise returned by dispatch.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAsyncThunk.mdx#2025-04-17_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchUserById } from './slice'\nimport { useAppDispatch } from './store'\nimport React from 'react'\n\nfunction MyComponent(props: { userId: string }) {\n  const dispatch = useAppDispatch()\n  React.useEffect(() => {\n    // Dispatching the thunk returns a promise\n    const promise = dispatch(fetchUserById(props.userId))\n    return () => {\n      // `createAsyncThunk` attaches an `abort()` method to the promise\n      promise.abort()\n    }\n  }, [props.userId])\n}\n```\n\n----------------------------------------\n\nTITLE: useInfiniteQuery Hook Type Definition\nDESCRIPTION: Type definition for the useInfiniteQuery hook including infinite data structure, options and result types for paginated queries.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/hooks.mdx#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ntype UseInfiniteQuery = (\n  arg: any | SkipToken,\n  options?: UseQueryOptions,\n) => UseInfiniteQueryResult\n\ntype InfiniteData<Data, PageParam> = {\n  pages: Array<Data>\n  pageParams: Array<PageParam>\n}\n\ntype UseInfiniteQueryOptions = {\n  pollingInterval?: number\n  skipPollingIfUnfocused?: boolean\n  refetchOnReconnect?: boolean\n  refetchOnFocus?: boolean\n  skip?: boolean\n  refetchOnMountOrArgChange?: boolean | number\n  selectFromResult?: (result: UseQueryStateDefaultResult) => any\n  initialPageParam?: PageParam\n}\n\ntype UseInfiniteQueryResult<Data, PageParam> = {\n  originalArgs?: unknown\n  data?: InfiniteData<Data, PageParam>\n  currentData?: InfiniteData<Data, PageParam>\n  error?: unknown\n  requestId?: string\n  endpointName?: string\n  startedTimeStamp?: number\n  fulfilledTimeStamp?: number\n\n  isUninitialized: boolean\n  isLoading: boolean\n  isFetching: boolean\n  isSuccess: boolean\n  isError: boolean\n\n  hasNextPage: boolean\n  hasPreviousPage: boolean\n  isFetchingNextPage: boolean\n  isFetchingPreviousPage: boolean\n  isFetchNextPageError: boolean\n  isFetchPreviousPageError: boolean\n\n  refetch: () => InfiniteQueryActionCreatorResult\n\n  fetchNextPage: () => InfiniteQueryActionCreatorResult\n  fetchPreviousPage: () => InfiniteQueryActionCreatorResult\n}\n```\n\n----------------------------------------\n\nTITLE: Type-Safe Dynamic Middleware Configuration in Redux Toolkit\nDESCRIPTION: This code shows how to create type-safe dynamic middleware instances and helper functions using Redux Toolkit, ensuring compatibility with the store's state and dispatch types.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createDynamicMiddleware.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createDynamicMiddleware } from '@reduxjs/toolkit/react'\nimport type { RootState, AppDispatch } from './store'\n\nconst dynamicMiddleware = createDynamicMiddleware()\n\nconst {\n  middleware,\n  addMiddleware,\n  withMiddleware,\n  createDispatchWithMiddlewareHook,\n} = dynamicMiddleware\n\ninterface MiddlewareApiConfig {\n  state: RootState\n  dispatch: AppDispatch\n}\n\nexport const addAppMiddleware = addMiddleware.withTypes<MiddlewareApiConfig>()\n\nexport const withAppMiddleware = withMiddleware.withTypes<MiddlewareApiConfig>()\n\nexport const createAppDispatchWithMiddlewareHook =\n  createDispatchWithMiddlewareHook.withTypes<MiddlewareApiConfig>()\n\nexport default middleware\n```\n\n----------------------------------------\n\nTITLE: Dispatching Async Thunk with Abort Signal in TypeScript\nDESCRIPTION: Shows how to dispatch an async thunk with an abort signal for cancellation control. Demonstrates creating an external AbortController and passing its signal to the thunk.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAsyncThunk.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst externalController = new AbortController()\ndispatch(fetchUserById(123, { signal: externalController.signal }))\nexternalController.abort()\n```\n\n----------------------------------------\n\nTITLE: Importing React-Specific createApi - TypeScript\nDESCRIPTION: Shows how to import the React-specific version of createApi that includes React hooks functionality\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/hooks.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi } from '@reduxjs/toolkit/query/react'\n```\n\n----------------------------------------\n\nTITLE: Non-hook Prefetching with Redux Store\nDESCRIPTION: Shows how to perform prefetching without using React hooks by directly dispatching actions to the Redux store. Demonstrates two methods: using the prefetch utility and manually initiating the query.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/prefetching.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nstore.dispatch(\n  api.util.prefetch(endpointName, arg, { force: false, ifOlderThan: 10 }),\n)\n```\n\n----------------------------------------\n\nTITLE: Bulk Cache Entry Upsert Example in TypeScript\nDESCRIPTION: Demonstrates how to pre-fill individual post entries with results from a list endpoint query using upsertQueryEntries.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/api-slice-utils.mdx#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst api = createApi({\n  endpoints: (build) => ({\n    getPosts: build.query<Post[], void>({\n      query: () => '/posts',\n      async onQueryStarted(_, { dispatch, queryFulfilled }) {\n        const res = await queryFulfilled\n        const posts = res.data\n\n        // Pre-fill the individual post entries with the results\n        // from the list endpoint query\n        dispatch(\n          api.util.upsertQueryEntries(\n            posts.map((post) => ({\n              endpointName: 'getPost',\n              arg: { id: post.id },\n              value: post,\n            })),\n          ),\n        )\n      },\n    }),\n    getPost: build.query<Post, Pick<Post, 'id'>>({ \n      query: (post) => `post/${post.id}`,\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: GraphQL BaseQuery Implementation\nDESCRIPTION: Custom implementation of a baseQuery for GraphQL requests using graphql-request library with error handling.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/customizing-queries.mdx#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi } from '@reduxjs/toolkit/query'\nimport { request, gql, ClientError } from 'graphql-request'\n\nconst graphqlBaseQuery =\n  ({ baseUrl }: { baseUrl: string }) =>\n  async ({ body }: { body: string }) => {\n    try {\n      const result = await request(baseUrl, body)\n      return { data: result }\n    } catch (error) {\n      if (error instanceof ClientError) {\n        return { error: { status: error.response.status, data: error } }\n      }\n      return { error: { status: 500, data: error } }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: TypeScript AsyncThunk Implementation with Manual Type Assertions\nDESCRIPTION: Shows how to implement async thunk with TypeScript, including manual type assertions for state and dispatch, and explicit return type definitions.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createSlice.mdx#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ncreate.asyncThunk<Todo, string, { rejectValue: { error: string } }>(\n  async (id: string, thunkApi): Promise<Todo> => {\n    const state = thunkApi.getState() as RootState\n    const dispatch = thunkApi.dispatch as AppDispatch\n    try {\n      const todo = await fetchTodo()\n      return todo\n    } catch (e) {\n      throw thunkApi.rejectWithValue({\n        error: 'Oh no!',\n      })\n    }\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Customizing Redux Middleware with Explicit List\nDESCRIPTION: Demonstrates how to supply a custom array of middleware functions to configureStore, replacing the defaults.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/getDefaultMiddleware.mdx#2025-04-17_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst store = configureStore({\n  reducer: rootReducer,\n  middleware: () => new Tuple(thunk, logger),\n})\n\n// Store specifically has the thunk and logger middleware applied\n```\n\n----------------------------------------\n\nTITLE: Integration with createReducer - TypeScript\nDESCRIPTION: Example of using createAction with createReducer for defining Redux reducers\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAction.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAction, createReducer } from '@reduxjs/toolkit'\n\nconst increment = createAction<number>('counter/increment')\nconst decrement = createAction<number>('counter/decrement')\n\nconst counterReducer = createReducer(0, (builder) => {\n  builder.addCase(increment, (state, action) => state + action.payload)\n  builder.addCase(decrement, (state, action) => state - action.payload)\n})\n```\n\n----------------------------------------\n\nTITLE: Query Endpoint Definition Type in TypeScript\nDESCRIPTION: This code snippet defines the TypeScript type for a query endpoint in createApi. It includes all possible properties that can be specified for a query endpoint, such as query function, transformResponse, providesTags, and lifecycle hooks.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/createApi.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport type QueryDefinition<\n  QueryArg,\n  BaseQuery extends BaseQueryFn,\n  TagTypes extends string,\n  ResultType,\n  ReducerPath extends string = string,\n> = {\n  query(arg: QueryArg): BaseQueryArg<BaseQuery>\n\n  /* either `query` or `queryFn` can be present, but not both simultaneously */\n  queryFn(\n    arg: QueryArg,\n    api: BaseQueryApi,\n    extraOptions: BaseQueryExtraOptions<BaseQuery>,\n    baseQuery: (arg: Parameters<BaseQuery>[0]) => ReturnType<BaseQuery>,\n  ): MaybePromise<QueryReturnValue<ResultType, BaseQueryError<BaseQuery>>>\n\n  /* transformResponse only available with `query`, not `queryFn` */\n  transformResponse?(\n    baseQueryReturnValue: BaseQueryResult<BaseQuery>,\n    meta: BaseQueryMeta<BaseQuery>,\n    arg: QueryArg,\n  ): ResultType | Promise<ResultType>\n\n  /* transformErrorResponse only available with `query`, not `queryFn` */\n  transformErrorResponse?(\n    baseQueryReturnValue: BaseQueryError<BaseQuery>,\n    meta: BaseQueryMeta<BaseQuery>,\n    arg: QueryArg,\n  ): unknown\n\n  extraOptions?: BaseQueryExtraOptions<BaseQuery>\n\n  providesTags?: ResultDescription<\n    TagTypes,\n    ResultType,\n    QueryArg,\n    BaseQueryError<BaseQuery>\n  >\n\n  keepUnusedDataFor?: number\n\n  onQueryStarted?(\n    arg: QueryArg,\n    {\n      dispatch,\n      getState,\n      extra,\n      requestId,\n      queryFulfilled,\n      getCacheEntry,\n      updateCachedData, // available for query endpoints only\n    }: QueryLifecycleApi,\n  ): Promise<void>\n\n  onCacheEntryAdded?(\n    arg: QueryArg,\n    {\n      dispatch,\n      getState,\n      extra,\n      requestId,\n      cacheEntryRemoved,\n      cacheDataLoaded,\n      getCacheEntry,\n      updateCachedData, // available for query endpoints only\n    }: QueryCacheLifecycleApi,\n  ): Promise<void>\n\n  argSchema?: StandardSchemaV1<QueryArg>\n\n  /* only available with `query`, not `queryFn` */\n  rawResponseSchema?: StandardSchemaV1<BaseQueryResult<BaseQuery>>\n\n  responseSchema?: StandardSchemaV1<ResultType>\n\n  /* only available with `query`, not `queryFn` */\n  rawErrorResponseSchema?: StandardSchemaV1<BaseQueryError<BaseQuery>>\n\n  errorResponseSchema?: StandardSchemaV1<BaseQueryError<BaseQuery>>\n\n  metaSchema?: StandardSchemaV1<BaseQueryMeta<BaseQuery>>\n}\n```\n\n----------------------------------------\n\nTITLE: Prefetch Function Signature in TypeScript\nDESCRIPTION: Type definition for the prefetch utility function that enables manual pre-fetching of data.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/api-slice-utils.mdx#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ntype PrefetchOptions = { ifOlderThan?: false | number } | { force?: boolean }\n\nconst prefetch = (endpointName: string, arg: any, options: PrefetchOptions) =>\n  ThunkAction<void, any, any, UnknownAction>\n```\n\n----------------------------------------\n\nTITLE: Error Handling in React Component\nDESCRIPTION: Shows how to handle different types of errors in a React component using type narrowing.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage-with-typescript.mdx#2025-04-17_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nimport { usePostsQuery } from './services/api'\n\nfunction PostDetail() {\n  const { data, error, isLoading } = usePostsQuery()\n\n  if (isLoading) {\n    return <div>Loading...</div>\n  }\n\n  if (error) {\n    if ('status' in error) {\n      const errMsg = 'error' in error ? error.error : JSON.stringify(error.data)\n\n      return (\n        <div>\n          <div>An error has occurred:</div>\n          <div>{errMsg}</div>\n        </div>\n      )\n    }\n    return <div>{error.message}</div>\n  }\n\n  if (data) {\n    return (\n      <div>\n        {data.map((post) => (\n          <div key={post.id}>Name: {post.name}</div>\n        ))}\n      </div>\n    )\n  }\n\n  return null\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Pessimistic Updates in RTK Query (TypeScript)\nDESCRIPTION: Shows how to perform pessimistic updates in RTK Query mutations. It updates the cache after the server response is received, using both updateQueryData and upsertQueryData.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/manual-cache-updates.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post'],\n  endpoints: (build) => ({\n    getPost: build.query<Post, number>({\n      query: (id) => `post/${id}`,\n      providesTags: ['Post'],\n    }),\n    updatePost: build.mutation<Post, Pick<Post, 'id'> & Partial<Post>>({\n      query: ({ id, ...patch }) => ({\n        url: `post/${id}`,\n        method: 'PATCH',\n        body: patch,\n      }),\n      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n        try {\n          const { data: updatedPost } = await queryFulfilled\n          const patchResult = dispatch(\n            api.util.updateQueryData('getPost', id, (draft) => {\n              Object.assign(draft, updatedPost)\n            }),\n          )\n        } catch {}\n      },\n    }),\n    createPost: build.mutation<Post, Pick<Post, 'id'> & Partial<Post>>({\n      query: ({ id, ...body }) => ({\n        url: `post/${id}`,\n        method: 'POST',\n        body,\n      }),\n      async onQueryStarted({ id }, { dispatch, queryFulfilled }) {\n        try {\n          const { data: createdPost } = await queryFulfilled\n          const patchResult = dispatch(\n            api.util.upsertQueryData('getPost', id, createdPost),\n          )\n        } catch {}\n      },\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: SerializedError Type Definition\nDESCRIPTION: Defines the structure of SerializedError interface used for handling unexpected errors in RTK Query.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage-with-typescript.mdx#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface SerializedError {\n  name?: string\n  message?: string\n  stack?: string\n  code?: string\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Fetch-related Functions and Types in TypeScript for Redux Toolkit\nDESCRIPTION: This snippet defines fetch-related functions and types used in Redux Toolkit, including fakeBaseQuery, fetchBaseQuery, and associated types for handling API requests and responses.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/toolkit/etc/rtk-query.api.md#2025-04-17_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n// @public\nexport function fakeBaseQuery<ErrorType>(): BaseQueryFn<\n  void,\n  NEVER,\n  ErrorType,\n  {}\n>\n\n// @public (undocumented)\nexport interface FetchArgs extends CustomRequestInit {\n  // (undocumented)\n  body?: any\n  // (undocumented)\n  params?: Record<string, any>\n  // (undocumented)\n  responseHandler?: ResponseHandler\n  // (undocumented)\n  url: string\n  // (undocumented)\n  validateStatus?: (response: Response, body: any) => boolean\n}\n\n// @public\nexport function fetchBaseQuery({\n  baseUrl,\n  prepareHeaders,\n  fetchFn,\n  paramsSerializer,\n  ...baseFetchOptions\n}?: FetchBaseQueryArgs): BaseQueryFn<\n  string | FetchArgs,\n  unknown,\n  FetchBaseQueryError,\n  {},\n  FetchBaseQueryMeta\n>\n\n// @public (undocumented)\nexport type FetchBaseQueryError =\n  | {\n      status: number\n      data: unknown\n    }\n  | {\n      status: 'FETCH_ERROR'\n      data?: undefined\n      error: string\n    }\n  | {\n      status: 'PARSING_ERROR'\n      originalStatus: number\n      data: string\n      error: string\n    }\n  | {\n      status: 'CUSTOM_ERROR'\n      data?: unknown\n      error: string\n    }\n\n// @public (undocumented)\nexport type FetchBaseQueryMeta = {\n  request: Request\n  response?: Response\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing setupListeners in Redux Toolkit Query\nDESCRIPTION: A utility function that configures event listeners for focus and network connectivity changes to enable automatic refetching. It attaches event handlers to window events and returns an unsubscribe function to clean up the listeners.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/setupListeners.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nlet initialized = false\nexport function setupListeners(\n  dispatch: ThunkDispatch<any, any, any>,\n  customHandler?: (\n    dispatch: ThunkDispatch<any, any, any>,\n    actions: {\n      onFocus: typeof onFocus\n      onFocusLost: typeof onFocusLost\n      onOnline: typeof onOnline\n      onOffline: typeof onOffline\n    },\n  ) => () => void,\n) {\n  function defaultHandler() {\n    const handleFocus = () => dispatch(onFocus())\n    const handleFocusLost = () => dispatch(onFocusLost())\n    const handleOnline = () => dispatch(onOnline())\n    const handleOffline = () => dispatch(onOffline())\n    const handleVisibilityChange = () => {\n      if (window.document.visibilityState === 'visible') {\n        handleFocus()\n      } else {\n        handleFocusLost()\n      }\n    }\n\n    if (!initialized) {\n      if (typeof window !== 'undefined' && window.addEventListener) {\n        // Handle focus events\n        window.addEventListener(\n          'visibilitychange',\n          handleVisibilityChange,\n          false,\n        )\n        window.addEventListener('focus', handleFocus, false)\n\n        // Handle connection events\n        window.addEventListener('online', handleOnline, false)\n        window.addEventListener('offline', handleOffline, false)\n        initialized = true\n      }\n    }\n    const unsubscribe = () => {\n      window.removeEventListener('focus', handleFocus)\n      window.removeEventListener('visibilitychange', handleVisibilityChange)\n      window.removeEventListener('online', handleOnline)\n      window.removeEventListener('offline', handleOffline)\n      initialized = false\n    }\n    return unsubscribe\n  }\n\n  return customHandler\n    ? customHandler(dispatch, { onFocus, onFocusLost, onOffline, onOnline })\n    : defaultHandler()\n}\n```\n\n----------------------------------------\n\nTITLE: Using skipToken for Conditional Fetching in RTK Query with TypeScript\nDESCRIPTION: Suggests using 'skipToken' as an alternative to the 'skip' option for TypeScript users. This approach helps maintain accurate endpoint types while skipping query execution.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/conditional-fetching.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nskipToken\n```\n\n----------------------------------------\n\nTITLE: Prepare Callback Usage - TypeScript\nDESCRIPTION: Using prepare callbacks to customize action payload creation with additional logic\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAction.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAction, nanoid } from '@reduxjs/toolkit'\n\nconst addTodo = createAction('todos/add', function prepare(text: string) {\n  return {\n    payload: {\n      text,\n      id: nanoid(),\n      createdAt: new Date().toISOString(),\n    },\n  }\n})\n\nconsole.log(addTodo('Write more docs'))\n```\n\n----------------------------------------\n\nTITLE: Using current Function with createReducer\nDESCRIPTION: Example showing how to use the Immer current function to inspect the current state during debugging in a Redux reducer.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/otherExports.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createReducer, createAction, current } from '@reduxjs/toolkit'\n\ninterface Todo {\n  //...\n}\nconst addTodo = createAction<Todo>('addTodo')\n\nconst initialState = [] satisfies Todo[] as Todo[]\n\nconst todosReducer = createReducer(initialState, (builder) => {\n  builder.addCase(addTodo, (state, action) => {\n    state.push(action.payload)\n    console.log(current(state))\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Prefetch Usage Example in TypeScript\nDESCRIPTION: Example showing how to dispatch a prefetch action with force option.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/api-slice-utils.mdx#2025-04-17_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ndispatch(api.util.prefetch('getPosts', undefined, { force: true }))\n```\n\n----------------------------------------\n\nTITLE: Adding Meta Information to Redux Toolkit Query Responses\nDESCRIPTION: Shows how to add custom meta information like request IDs and timestamps to query responses using a custom base query implementation. Includes example of using meta information in response transformation.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/customizing-queries.mdx#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchBaseQuery, createApi } from '@reduxjs/toolkit/query'\nimport type {\n  BaseQueryFn,\n  FetchArgs,\n  FetchBaseQueryError,\n} from '@reduxjs/toolkit/query'\nimport type { FetchBaseQueryMeta } from '@reduxjs/toolkit/query'\n\ntype Meta = {\n  requestId: string\n  timestamp: number\n}\n\nconst metaBaseQuery: BaseQueryFn<\n  string | FetchArgs,\n  unknown,\n  FetchBaseQueryError,\n  {},\n  Meta & FetchBaseQueryMeta\n> = async (args, api, extraOptions) => {\n  const requestId = uuid()\n  const timestamp = Date.now()\n\n  const baseResult = await fetchBaseQuery({ baseUrl: '/' })(\n    args,\n    api,\n    extraOptions,\n  )\n\n  return {\n    ...baseResult,\n    meta: baseResult.meta && { ...baseResult.meta, requestId, timestamp },\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Selector Creation in Entity Adapters\nDESCRIPTION: This example shows how to customize the createSelector function used by the entity adapter when creating selectors, using a custom memoization strategy.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createEntityAdapter.mdx#2025-04-17_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  createDraftSafeSelectorCreator,\n  weakMapMemoize,\n} from '@reduxjs/toolkit'\n\nconst createWeakMapDraftSafeSelector =\n  createDraftSafeSelectorCreator(weakMapMemoize)\n\nconst simpleSelectors = booksAdapter.getSelectors(undefined, {\n  createSelector: createWeakMapDraftSafeSelector,\n})\n\nconst globalizedSelectors = booksAdapter.getSelectors((state) => state.books, {\n  createSelector: createWeakMapDraftSafeSelector,\n})\n```\n\n----------------------------------------\n\nTITLE: Logging Draft State Values Example\nDESCRIPTION: Example showing how to properly log Immer draft state values using the current utility.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createReducer.mdx#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSlice, current } from '@reduxjs/toolkit'\n\nconst slice = createSlice({\n  name: 'todos',\n  initialState: [{ id: 1, title: 'Example todo' }],\n  reducers: {\n    addTodo: (state, action) => {\n      console.log('before', current(state))\n      state.push(action.payload)\n      console.log('after', current(state))\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Module and Query Types in TypeScript for Redux Toolkit\nDESCRIPTION: This code defines types for modules, mutations, queries, and related concepts in Redux Toolkit. It includes definitions for Module, MutationDefinition, QueryDefinition, and QueryStatus enum.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/toolkit/etc/rtk-query.api.md#2025-04-17_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n// @public (undocumented)\nexport type Module<Name extends ModuleName> = {\n  name: Name\n  init<\n    BaseQuery extends BaseQueryFn,\n    Definitions extends EndpointDefinitions,\n    ReducerPath extends string,\n    TagTypes extends string,\n  >(\n    api: Api<BaseQuery, EndpointDefinitions, ReducerPath, TagTypes, ModuleName>,\n    options: WithRequiredProp<\n      CreateApiOptions<BaseQuery, Definitions, ReducerPath, TagTypes>,\n      | 'reducerPath'\n      | 'serializeQueryArgs'\n      | 'keepUnusedDataFor'\n      | 'refetchOnMountOrArgChange'\n      | 'refetchOnFocus'\n      | 'refetchOnReconnect'\n      | 'tagTypes'\n      | 'structuralSharing'\n    >,\n    context: ApiContext<Definitions>,\n  ): {\n    injectEndpoint(\n      endpointName: string,\n      definition: EndpointDefinition<any, any, any, any>,\n    ): void\n  }\n}\n\n// @public (undocumented)\nexport type MutationDefinition<\n  QueryArg,\n  BaseQuery extends BaseQueryFn,\n  TagTypes extends string,\n  ResultType,\n  ReducerPath extends string = string,\n> = BaseEndpointDefinition<QueryArg, BaseQuery, ResultType> &\n  MutationExtraOptions<TagTypes, ResultType, QueryArg, BaseQuery, ReducerPath>\n\n// @public (undocumented)\nexport type QueryDefinition<\n  QueryArg,\n  BaseQuery extends BaseQueryFn,\n  TagTypes extends string,\n  ResultType,\n  ReducerPath extends string = string,\n> = BaseEndpointDefinition<QueryArg, BaseQuery, ResultType> &\n  QueryExtraOptions<TagTypes, ResultType, QueryArg, BaseQuery, ReducerPath>\n\n// @public\nexport enum QueryStatus {\n  // (undocumented)\n  fulfilled = 'fulfilled',\n  // (undocumented)\n  pending = 'pending',\n  // (undocumented)\n  rejected = 'rejected',\n  // (undocumented)\n  uninitialized = 'uninitialized',\n}\n```\n\n----------------------------------------\n\nTITLE: Using patchQueryData Utility in Redux Toolkit API Slices\nDESCRIPTION: The patchQueryData utility applies a JSON diff/patch array to cached data for a given query result. It's typically used as the second step in implementing optimistic updates, especially for reverting changes if a request fails.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/api-slice-utils.mdx#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst patchQueryData = (\n  endpointName: string,\n  arg: any\n  patches: Patch[],\n  updateProvided?: boolean\n) => ThunkAction<void, PartialState, any, UnknownAction>;\n```\n\n----------------------------------------\n\nTITLE: useQuery Hook Usage Example - TypeScript\nDESCRIPTION: Shows the two ways to access and use the useQuery hook - either through the endpoint directly or via the generated named hook\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/hooks.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst useQueryResult = api.endpoints.getPosts.useQuery(arg, options)\n// or\nconst useQueryResult = api.useGetPostsQuery(arg, options)\n```\n\n----------------------------------------\n\nTITLE: Redux Toolkit Code After Migration\nDESCRIPTION: Example of Redux Toolkit code after applying the codemods, showing the builder callback syntax for createReducer and createSlice.extraReducers as required in RTK 2.0.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/codemods.mdx#2025-04-17_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\ncreateReducer(initialState, (builder) => {\n  builder.addCase(todoAdded1a, (state, action) => {\n    // stuff\n  })\n\n  builder.addCase(todoAdded1b, (state, action) => action.payload)\n})\n\nconst slice1 = createSlice({\n  name: 'a',\n  initialState: {},\n\n  extraReducers: (builder) => {\n    builder.addCase(todoAdded1a, (state, action) => {\n      // stuff\n    })\n\n    builder.addCase(todoAdded1b, (state, action) => action.payload)\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Basic QueryFn Implementation in TypeScript\nDESCRIPTION: Demonstrates implementing a basic queryFn in RTK Query with both standard HTTP endpoint and custom async logic for user fetching.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/customizing-queries.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport { userAPI, User } from './userAPI'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ url: '/' }),\n  endpoints: (build) => ({\n    getPosts: build.query<PostsResponse, void>({\n      query: () => ({ url: 'posts' }),\n    }),\n    getUser: build.query<User, string>({\n      queryFn: async (userId: string) => {\n        try {\n          const user = await userApi.getUserById(userId)\n          return { data: user }\n        } catch (error) {\n          return { error }\n        }\n      },\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Selectors for Pokemon State Access in TypeScript\nDESCRIPTION: Defines selector functions to access Pokemon data and request status from the Redux store. These selectors allow components to retrieve the appropriate status and data for any given Pokemon name.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/migrating-to-rtk-query.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport const selectStatusByName = (state: RootState, name: string) =>\n  state.pokemon.statusByName[name]\nexport const selectDataByName = (state: RootState, name: string) =>\n  state.pokemon.dataByName[name]\n```\n\n----------------------------------------\n\nTITLE: Creating Memoized Selectors for RTK Query\nDESCRIPTION: Demonstrates how to create memoized selectors using createSelector for efficient cache data access, particularly useful when creating selectors that depend on other selectors.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/usage-without-react-hooks.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst createGetPostSelector = createSelector(\n  (id: string) => id,\n  (id) => api.endpoints.getPost.select(id),\n)\n\nconst selectGetPostError = createSelector(\n  (state: RootState) => state,\n  (state: RootState, id: string) => createGetPostSelector(id),\n  (state, selectGetPost) => selectGetPost(state).error,\n)\n```\n\n----------------------------------------\n\nTITLE: Updating Polling Subscription Options Manually in RTK Query\nDESCRIPTION: This snippet shows how to manually update polling subscription options when not using React hooks. It demonstrates calling updateSubscriptionOptions on a query reference to disable polling by setting the interval to zero.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/polling.mdx#2025-04-17_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nqueryRef.updateSubscriptionOptions({ pollingInterval: 0 })\n```\n\n----------------------------------------\n\nTITLE: usePrefetch Type Definitions\nDESCRIPTION: Type definitions for the usePrefetch hook, including options and callback interfaces.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/hooks.mdx#2025-04-17_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ntype UsePrefetch = (\n  endpointName: string,\n  options?: UsePrefetchOptions,\n) => PrefetchCallback\n\ntype UsePrefetchOptions =\n  | {\n      ifOlderThan?: false | number\n    }\n  | {\n      force?: boolean\n    }\n\ntype PrefetchCallback = (arg: any, options?: UsePrefetchOptions) => void\n```\n\n----------------------------------------\n\nTITLE: Adding Middleware Dynamically in Redux Toolkit\nDESCRIPTION: This snippet shows how to use the addMiddleware method to inject middleware into a dynamic middleware instance after store initialization.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createDynamicMiddleware.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\naddMiddleware(logger, listenerMiddleware.instance)\n```\n\n----------------------------------------\n\nTITLE: Using Select for Queries in React with Redux Toolkit\nDESCRIPTION: This example demonstrates how to use the select function for queries in a React component with Redux Toolkit.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/endpoints.mdx#2025-04-17_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState, useMemo } from 'react'\nimport { useAppDispatch, useAppSelector } from './store/hooks'\nimport { api } from './services/api'\n\nfunction App() {\n  const dispatch = useAppDispatch()\n  const [postId, setPostId] = useState(1)\n  // highlight-start\n  // useMemo is used to only call `.select()` when required.\n  // Each call will create a new selector function instance\n  const selectPost = useMemo(\n    () => api.endpoints.getPost.select(postId),\n    [postId],\n  )\n  const { data, isLoading } = useAppSelector(selectPost)\n  // highlight-end\n\n  useEffect(() => {\n    // Add a subscription\n    const result = dispatch(api.endpoints.getPost.initiate(postId))\n\n    // Return the `unsubscribe` callback to be called in the cleanup step\n    return result.unsubscribe\n  }, [dispatch, postId])\n\n  if (isLoading) return <div>Loading post...</div>\n\n  return (\n    <div>\n      <div>Initiate query example</div>\n      <div>Post name: {data.name}</div>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Cache invalidation for paginated queries in RTK Query\nDESCRIPTION: Implementation of advanced cache invalidation for paginated queries using abstract tag IDs. Provides tags for individual items and a PARTIAL-LIST tag, ensuring proper cache invalidation when items are deleted, even if they're not on the current page.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/pagination.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// file: api.ts\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\ninterface ListResponse<T> {\n  page: number\n  per_page: number\n  total: number\n  total_pages: number\n  data: T[]\n}\n\nexport const postApi = createApi({\n  reducerPath: 'postsApi',\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Posts'],\n  endpoints: (build) => ({\n    listPosts: build.query<ListResponse<Post>, number | void>({\n      query: (page = 1) => `posts?page=${page}`,\n      // highlight-start\n      providesTags: (result, error, page) =>\n        result\n          ? [\n              // Provides a tag for each post in the current page,\n              // as well as the 'PARTIAL-LIST' tag.\n              ...result.data.map(({ id }) => ({ type: 'Posts' as const, id })),\n              { type: 'Posts', id: 'PARTIAL-LIST' },\n            ]\n          : [{ type: 'Posts', id: 'PARTIAL-LIST' }],\n      // highlight-end\n    }),\n    deletePost: build.mutation<{ success: boolean; id: number }, number>({\n      query(id) {\n        return {\n          url: `post/${id}`,\n          method: 'DELETE',\n        }\n      },\n      // Invalidates the tag for this Post `id`, as well as the `PARTIAL-LIST` tag,\n      // causing the `listPosts` query to re-fetch if a component is subscribed to the query.\n      // highlight-start\n      invalidatesTags: (result, error, id) => [\n        { type: 'Posts', id },\n        { type: 'Posts', id: 'PARTIAL-LIST' },\n      ],\n      // highlight-end\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Redux Action - JavaScript\nDESCRIPTION: Basic function signature for createAction helper in Redux Toolkit\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAction.mdx#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction createAction(type, prepareAction?)\n```\n\n----------------------------------------\n\nTITLE: Extending Default Middleware with Custom Middleware\nDESCRIPTION: Shows how to add custom middleware while keeping the default middleware using getDefaultMiddleware.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/getDefaultMiddleware.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configureStore } from '@reduxjs/toolkit'\n\nimport logger from 'redux-logger'\n\nimport rootReducer from './reducer'\n\nconst store = configureStore({\n  reducer: rootReducer,\n  middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(logger),\n})\n\n// Store has all of the default middleware added, _plus_ the logger middleware\n```\n\n----------------------------------------\n\nTITLE: Using createSlice with Immer in Redux Toolkit\nDESCRIPTION: Demonstrates how Redux Toolkit's createSlice API also uses Immer, allowing 'mutating' syntax in slice reducers.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/usage/immer-reducers.md#2025-04-17_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst todosSlice = createSlice({\n  name: 'todos',\n  initialState: [],\n  reducers: {\n    todoAdded(state, action) {\n      state.push(action.payload)\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using Select for Mutations in React with Redux Toolkit\nDESCRIPTION: This example shows how to use the select function for mutations in a React component with Redux Toolkit.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/endpoints.mdx#2025-04-17_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState, useMemo } from 'react'\nimport { skipToken } from '@reduxjs/toolkit/query'\nimport { useAppDispatch, useAppSelector } from './store/hooks'\nimport { api } from './services/api'\n\nfunction App() {\n  const dispatch = useAppDispatch()\n  const [newPost, setNewPost] = useState({ name: 'Ash' })\n  const [requestId, setRequestId] = useState<typeof skipToken | string>(\n    skipToken,\n  )\n  // highlight-start\n  // useMemo is used to only call `.select(..)` when required.\n  // Each call will create a new selector function instance\n  const selectMutationResult = useMemo(\n    () => api.endpoints.addPost.select(requestId),\n    [requestId],\n  )\n  const { isLoading } = useAppSelector(selectMutationResult)\n  // highlight-end\n\n  function handleClick() {\n    // Trigger a mutation\n    const result = dispatch(api.endpoints.addPost.initiate(newPost))\n    // store the requestId to select the mutation result elsewhere\n    setRequestId(result.requestId)\n  }\n\n  if (isLoading) return <div>Adding post...</div>\n\n  return (\n    <div>\n      <div>Select mutation example</div>\n      <button onClick={handleClick}>Add post</button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript Type Guard Usage - TypeScript\nDESCRIPTION: Using action creator's match method as a TypeScript type guard\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAction.mdx#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAction } from '@reduxjs/toolkit'\nimport type { Action } from '@reduxjs/toolkit'\n\nconst increment = createAction<number>('INCREMENT')\n\nfunction someFunction(action: Action) {\n  // accessing action.payload would result in an error here\n  if (increment.match(action)) {\n    // action.payload can be used as `number` here\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Implementation Hooks in Redux Toolkit\nDESCRIPTION: Examples of using various implementation hooks including useQuerySubscription, useInfiniteQueryState, and useLazyQuerySubscription.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/hooks.mdx#2025-04-17_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst { refetch } = api.endpoints.getPosts.useQuerySubscription(arg, options)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst useInfiniteQueryStateResult =\n  api.endpoints.getManyPosts.useInfiniteQueryState(arg, options)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst useInfiniteQuerySubscriptionResult =\n  api.endpoints.getManyPosts.useInfiniteQuerySubscription(arg, options)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst [trigger, lastArg] =\n  api.endpoints.getPosts.useLazyQuerySubscription(options)\n```\n\n----------------------------------------\n\nTITLE: Implementation of isPlain Function for Serialization Checks\nDESCRIPTION: The implementation of the isPlain function used to determine if a value is considered a \"plain value\" for serialization purposes. It accepts standard JS objects, arrays, and primitives, but rejects class instances like Date or Map.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/serializabilityMiddleware.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport isPlainObject from './isPlainObject'\n\nexport function isPlain(val: any) {\n  return (\n    typeof val === 'undefined' ||\n    val === null ||\n    typeof val === 'string' ||\n    typeof val === 'boolean' ||\n    typeof val === 'number' ||\n    Array.isArray(val) ||\n    isPlainObject(val)\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using extractRehydrationInfo with createApi for Next.js SSR\nDESCRIPTION: Configuration option for RTK Query's createApi that enables rehydration for server-side rendering. This code demonstrates the usage of extractRehydrationInfo to properly handle query serialization during SSR.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/server-side-rendering.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n[examples](docblock://query/createApi.ts?token=CreateApiOptions.extractRehydrationInfo)\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Module for Redux Toolkit Query\nDESCRIPTION: This example demonstrates how to create a custom module for RTK Query. It defines a new module type, extends the ApiModules interface, and implements the module with an init function and injectEndpoint method.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/customizing-create-api.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  BaseQueryFn,\n  CoreModule,\n  EndpointDefinitions,\n  Api,\n  Module,\n  buildCreateApi,\n  coreModule,\n} from '@reduxjs/toolkit/query'\n\nexport const customModuleName = Symbol()\nexport type CustomModule = typeof customModuleName\n\ndeclare module '@reduxjs/toolkit/query' {\n  export interface ApiModules<\n    BaseQuery extends BaseQueryFn,\n    Definitions extends EndpointDefinitions,\n    ReducerPath extends string,\n    TagTypes extends string,\n  > {\n    [customModuleName]: {\n      endpoints: {\n        [K in keyof Definitions]: {\n          myEndpointProperty: string\n        }\n      }\n    }\n  }\n}\n\nexport const myModule = (): Module<CustomModule> => ({\n  name: customModuleName,\n  init(api, options, context) {\n    // initialize stuff here if you need to\n\n    return {\n      injectEndpoint(endpoint, definition) {\n        const anyApi = api as any as Api<\n          any,\n          Record<string, any>,\n          string,\n          string,\n          CustomModule | CoreModule\n        >\n        anyApi.endpoints[endpoint].myEndpointProperty = 'test'\n      },\n    }\n  },\n})\n\nexport const myCreateApi = buildCreateApi(coreModule(), myModule())\n```\n\n----------------------------------------\n\nTITLE: Defining EndpointLogic Type in TypeScript\nDESCRIPTION: This snippet defines the structure of the EndpointLogic type, which includes initiate, select, and matcher functions for an endpoint.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/endpoints.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype EndpointLogic = {\n  initiate: InitiateRequestThunk\n  select: CreateCacheSelectorFactory\n  matchPending: Matcher<PendingAction>\n  matchFulfilled: Matcher<FulfilledAction>\n  matchRejected: Matcher<RejectedAction>\n}\n```\n\n----------------------------------------\n\nTITLE: useMutation Hook Type Definition\nDESCRIPTION: Type definition for the useMutation hook including state options, trigger function, and result types. Used for making data mutations with RTK Query.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/hooks.mdx#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ntype UseMutation = (\n  options?: UseMutationStateOptions,\n) => [UseMutationTrigger, UseMutationResult | SelectedUseMutationResult]\n\ntype UseMutationStateOptions = {\n  selectFromResult?: (result: UseMutationStateDefaultResult) => any\n  fixedCacheKey?: string\n}\n\ntype UseMutationTrigger<T> = (arg: any) => Promise<\n  { data: T } | { error: BaseQueryError | SerializedError }\n> & {\n  requestId: string\n  abort: () => void\n  unwrap: () => Promise<T>\n  reset: () => void\n}\n\ntype UseMutationResult<T> = {\n  originalArgs?: unknown\n  data?: T\n  error?: unknown\n  endpointName?: string\n  fulfilledTimeStamp?: number\n\n  isUninitialized: boolean\n  isLoading: boolean\n  isSuccess: boolean\n  isError: boolean\n  startedTimeStamp?: number\n\n  reset: () => void\n}\n```\n\n----------------------------------------\n\nTITLE: Middleware Configuration Example\nDESCRIPTION: Example showing how to properly configure middleware using Tuple for TypeScript type inference.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/configureStore.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configureStore, Tuple } from '@reduxjs/toolkit'\n\nconfigureStore({\n  reducer: rootReducer,\n  middleware: () => new Tuple(additionalMiddleware, logger),\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Infinite Query Endpoint in Redux Toolkit\nDESCRIPTION: This code snippet defines the structure and types for an infinite query endpoint in Redux Toolkit. It includes the InfiniteQueryDefinition type, which extends the QueryDefinition type with additional options specific to infinite queries.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/createApi.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport type PageParamFunction<DataType, PageParam> = (\n  firstPage: DataType,\n  allPages: Array<DataType>,\n  firstPageParam: PageParam,\n  allPageParams: Array<PageParam>,\n) => PageParam | undefined | null\n\ntype InfiniteQueryCombinedArg<QueryArg, PageParam> = {\n  queryArg: QueryArg\n  pageParam: PageParam\n}\n\nexport type InfiniteQueryDefinition<\n  QueryArg,\n  PageParam,\n  BaseQuery extends BaseQueryFn,\n  TagTypes extends string,\n  ResultType,\n  ReducerPath extends string = string,\n> =\n  QueryDefinition<\n    InfiniteQueryCombinedArg<QueryArg, PageParam>,\n    BaseQuery,\n    TagTypes,\n    InfiniteData<ResultType>\n  > & {\n    infiniteQueryOptions: {\n      initialPageParam: PageParam\n      getNextPageParam: PageParamFunction<DataType, PageParam>\n      getPreviousPageParam?: PageParamFunction<DataType, PageParam>\n      maxPages?: number\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining Promise Lifecycle Action Types in TypeScript\nDESCRIPTION: TypeScript interfaces defining the structure of pending, fulfilled, and rejected actions generated by createAsyncThunk, including SerializedError and action type definitions.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAsyncThunk.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SerializedError {\n  name?: string\n  message?: string\n  code?: string\n  stack?: string\n}\n\ninterface PendingAction<ThunkArg> {\n  type: string\n  payload: undefined\n  meta: {\n    requestId: string\n    arg: ThunkArg\n  }\n}\n\ninterface FulfilledAction<ThunkArg, PromiseResult> {\n  type: string\n  payload: PromiseResult\n  meta: {\n    requestId: string\n    arg: ThunkArg\n  }\n}\n\ninterface RejectedAction<ThunkArg> {\n  type: string\n  payload: undefined\n  error: SerializedError | any\n  meta: {\n    requestId: string\n    arg: ThunkArg\n    aborted: boolean\n    condition: boolean\n  }\n}\n\ninterface RejectedWithValueAction<ThunkArg, RejectedValue> {\n  type: string\n  payload: RejectedValue\n  error: { message: 'Rejected' }\n  meta: {\n    requestId: string\n    arg: ThunkArg\n    aborted: boolean\n  }\n}\n\ntype Pending = <ThunkArg>(\n  requestId: string,\n  arg: ThunkArg,\n) => PendingAction<ThunkArg>\n\ntype Fulfilled = <ThunkArg, PromiseResult>(\n  payload: PromiseResult,\n  requestId: string,\n  arg: ThunkArg,\n) => FulfilledAction<ThunkArg, PromiseResult>\n\ntype Rejected = <ThunkArg>(\n  requestId: string,\n  arg: ThunkArg,\n) => RejectedAction<ThunkArg>\n\ntype RejectedWithValue = <ThunkArg, RejectedValue>(\n  requestId: string,\n  arg: ThunkArg,\n) => RejectedWithValueAction<ThunkArg, RejectedValue>\n```\n\n----------------------------------------\n\nTITLE: Individual Running Query/Mutation Thunk Signatures in TypeScript\nDESCRIPTION: Type definitions for thunks that retrieve specific running queries and mutations.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/api-slice-utils.mdx#2025-04-17_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\ngetRunningQueryThunk<EndpointName extends QueryKeys<Definitions>>(\n  endpointName: EndpointName,\n  args: QueryArgFrom<Definitions[EndpointName]>\n): ThunkWithReturnValue<\n  | QueryActionCreatorResult<\n      Definitions[EndpointName] & { type: 'query' }\n    >\n  | undefined\n>\n\ngetRunningMutationThunk<EndpointName extends MutationKeys<Definitions>>(\n  endpointName: EndpointName,\n  fixedCacheKeyOrRequestId: string\n): ThunkWithReturnValue<\n  | MutationActionCreatorResult<\n      Definitions[EndpointName] & { type: 'mutation' }\n    >\n  | undefined\n>\n```\n\n----------------------------------------\n\nTITLE: Defining Query onCacheEntryAdded Signature in TypeScript\nDESCRIPTION: Specifies the TypeScript signature for the onCacheEntryAdded function in a query endpoint. It includes parameters for the query argument and a QueryCacheLifecycleApi object with various properties and methods for cache management, including an additional updateCachedData method.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/createApi.mdx#2025-04-17_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nasync function onCacheEntryAdded(\n  arg: QueryArg,\n  {\n    dispatch,\n    getState,\n    extra,\n    requestId,\n    cacheEntryRemoved,\n    cacheDataLoaded,\n    getCacheEntry,\n    updateCachedData, // available for query endpoints only\n  }: QueryCacheLifecycleApi,\n): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Using isAsyncThunkAction in TypeScript\nDESCRIPTION: Demonstrates how to use the isAsyncThunkAction utility to check if an action was created by createAsyncThunk.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/matching-utilities.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isAsyncThunkAction } from '@reduxjs/toolkit'\nimport type { UnknownAction } from '@reduxjs/toolkit'\nimport { requestThunk1, requestThunk2 } from '@virtual/matchers'\n\nconst isARequestAction = isAsyncThunkAction(requestThunk1, requestThunk2)\n\nfunction handleRequestAction(action: UnknownAction) {\n  if (isARequestAction(action)) {\n    // action is an action dispatched by either `requestThunk1` or `requestThunk2`\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Cache Tags in RTK Query API\nDESCRIPTION: Example showing how to declare cache tags in an RTK Query API configuration using createApi. Demonstrates setting up tagTypes and basic endpoints for posts and users.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/automated-refetching.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { Post, User } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post', 'User'],\n  endpoints: (build) => ({\n    getPosts: build.query<Post[], void>({\n      query: () => '/posts',\n    }),\n    getUsers: build.query<User[], void>({\n      query: () => '/users',\n    }),\n    addPost: build.mutation<Post, Omit<Post, 'id'>>({      query: (body) => ({\n        url: 'post',\n        method: 'POST',\n        body,\n      }),\n    }),\n    editPost: build.mutation<Post, Partial<Post> & Pick<Post, 'id'>>({      query: (body) => ({\n        url: `post/${body.id}`,\n        method: 'POST',\n        body,\n      }),\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Initiate Function Signatures in TypeScript\nDESCRIPTION: This snippet defines the types for the initiate function, including StartQueryActionCreator and StartMutationActionCreator, along with their options.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/endpoints.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype InitiateRequestThunk = StartQueryActionCreator | StartMutationActionCreator;\n\ntype StartQueryActionCreator = (\n  arg:any,\n  options?: StartQueryActionCreatorOptions\n) => ThunkAction<QueryActionCreatorResult, any, any, UnknownAction>;\n\ntype StartMutationActionCreator<D extends MutationDefinition<any, any, any, any>> = (\n  arg: any\n  options?: StartMutationActionCreatorOptions\n) => ThunkAction<MutationActionCreatorResult<D>, any, any, UnknownAction>;\n\ntype SubscriptionOptions = {\n  /**\n   * How frequently to automatically re-fetch data (in milliseconds). Defaults to `0` (off).\n   */\n  pollingInterval?: number;\n  /**\n   * Defaults to `false`. This setting allows you to control whether RTK Query will try to refetch all subscribed queries after regaining a network connection.\n   *\n   * If you specify this option alongside `skip: true`, this **will not be evaluated** until `skip` is false.\n   *\n   * Note: requires `setupListeners` to have been called.\n   */\n  refetchOnReconnect?: boolean;\n  /**\n   * Defaults to `false`. This setting allows you to control whether RTK Query will try to refetch all subscribed queries after the application window regains focus.\n   *\n   * If you specify this option alongside `skip: true`, this **will not be evaluated** until `skip` is false.\n   *\n   * Note: requires `setupListeners` to have been called.\n   */\n  refetchOnFocus?: boolean;\n};\n\ninterface StartQueryActionCreatorOptions {\n  subscribe?: boolean;\n  forceRefetch?: boolean | number;\n  subscriptionOptions?: SubscriptionOptions;\n}\n\ninterface StartMutationActionCreatorOptions {\n  /**\n   * If this mutation should be tracked in the store.\n   * If you just want to manually trigger this mutation using `dispatch` and don't care about the\n   * result, state & potential errors being held in store, you can set this to false.\n   * (defaults to `true`)\n   */\n  track?: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TypeScript API with Required Query Parameters\nDESCRIPTION: Demonstrates how to create an API definition with TypeScript where the query argument is required to be a number and cannot be undefined.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage-with-typescript.mdx#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Post {\n  id: number\n  name: string\n}\n\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport type { Post } from './types'\n\nexport const api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getPost: build.query<Post, number>({\n      query: (id) => `post/${id}`,\n    }),\n  }),\n})\n\nexport const { useGetPostQuery } = api\n```\n\n----------------------------------------\n\nTITLE: Configuring RTK Query Network Reconnection Refetching\nDESCRIPTION: Demonstrates setting up automatic refetching when network connectivity is restored. Includes API configuration and required store setup.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/cache-behavior.mdx#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport type { Post } from './types'\n\nexport const api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  refetchOnReconnect: true,\n  endpoints: (build) => ({\n    getPosts: build.query<Post[], number>({\n      query: () => `posts`,\n    }),\n  }),\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configureStore } from '@reduxjs/toolkit'\nimport { setupListeners } from '@reduxjs/toolkit/query'\nimport { api } from './services/api'\n\nexport const store = configureStore({\n  reducer: {\n    [api.reducerPath]: api.reducer,\n  },\n  middleware: (gDM) => gDM().concat(api.middleware),\n})\n\nsetupListeners(store.dispatch)\n\nexport type RootState = ReturnType<typeof store.getState>\n```\n\n----------------------------------------\n\nTITLE: Initializing Custom CreateSlice with AsyncThunk Support\nDESCRIPTION: Shows how to set up a custom createSlice implementation with asyncThunk support by importing buildCreateSlice and asyncThunkCreator.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createSlice.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildCreateSlice, asyncThunkCreator } from '@reduxjs/toolkit'\n\nexport const createAppSlice = buildCreateSlice({\n  creators: { asyncThunk: asyncThunkCreator },\n})\n```\n\n----------------------------------------\n\nTITLE: Streaming Data with No Initial Request in RTK Query (TypeScript)\nDESCRIPTION: Shows how to set up a streaming data endpoint with no initial request, using queryFn and onCacheEntryAdded in Redux Toolkit Query.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/customizing-queries.mdx#2025-04-17_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { Message } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Message'],\n  endpoints: (build) => ({\n    streamMessages: build.query<Message[], void>({\n      queryFn: () => ({ data: [] }),\n      async onCacheEntryAdded(arg, { updateCachedData, cacheEntryRemoved }) {\n        const ws = new WebSocket('ws://localhost:8080')\n        ws.addEventListener('message', (event) => {\n          updateCachedData((draft) => {\n            draft.push(JSON.parse(event.data))\n          })\n        })\n        await cacheEntryRemoved\n        ws.close()\n      },\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Query onQueryStarted Signature in TypeScript\nDESCRIPTION: Defines the TypeScript signature for the onQueryStarted function in a query endpoint. It includes parameters for the query argument and a QueryLifecycleApi object containing various properties and methods, including an additional updateCachedData method.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/createApi.mdx#2025-04-17_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nasync function onQueryStarted(\n  arg: QueryArg,\n  {\n    dispatch,\n    getState,\n    extra,\n    requestId,\n    queryFulfilled,\n    getCacheEntry,\n    updateCachedData, // available for query endpoints only\n  }: QueryLifecycleApi,\n): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Using useQueryState Hook in Redux Toolkit\nDESCRIPTION: Demonstrates usage of the useQueryState implementation hook for accessing query state.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/hooks.mdx#2025-04-17_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst useQueryStateResult = api.endpoints.getPosts.useQueryState(arg, options)\n```\n\n----------------------------------------\n\nTITLE: Configuring Redux Store with Pokemon Reducer\nDESCRIPTION: Sets up the Redux store with the Pokemon slice reducer. This configuration enables the store to handle the appropriate actions for Pokemon data fetching requests.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/migrating-to-rtk-query.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// file: src/services/pokemonSlice.ts noEmit\nimport type { Reducer } from '@reduxjs/toolkit'\ndeclare const reducer: Reducer<{}>\nexport const pokemonSlice = {\n  reducer,\n}\n\n// file: src/store.ts\nimport { configureStore } from '@reduxjs/toolkit'\nimport { pokemonSlice } from './services/pokemonSlice'\n\nexport const store = configureStore({\n  reducer: {\n    pokemon: pokemonSlice.reducer,\n  },\n})\n\nexport type RootState = ReturnType<typeof store.getState>\n```\n\n----------------------------------------\n\nTITLE: Defining API types and interfaces in TypeScript for Redux Toolkit\nDESCRIPTION: This code snippet defines various types and interfaces for the Redux Toolkit API, including Api, ApiModules, and CreateApiOptions. It also includes function declarations for key features like createApi and setupListeners.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/toolkit/etc/rtk-query-react.api.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ActionCreatorWithoutPayload } from '@reduxjs/toolkit'\nimport { batch } from 'react-redux'\nimport { Context } from 'react'\nimport { ReactReduxContextValue } from 'react-redux'\nimport { ThunkDispatch } from '@reduxjs/toolkit'\nimport { useDispatch } from 'react-redux'\nimport { useSelector } from 'react-redux'\nimport { useStore } from 'react-redux'\n\n// @public (undocumented)\nexport type Api<\n  BaseQuery extends BaseQueryFn,\n  Definitions extends EndpointDefinitions,\n  ReducerPath extends string,\n  TagTypes extends string,\n  Enhancers extends ModuleName = CoreModule,\n> = Id<\n  Id<\n    UnionToIntersection<\n      ApiModules<BaseQuery, Definitions, ReducerPath, TagTypes>[Enhancers]\n    >\n  > & {\n    injectEndpoints<NewDefinitions extends EndpointDefinitions>(_: {\n      endpoints: (\n        build: EndpointBuilder<BaseQuery, TagTypes, ReducerPath>,\n      ) => NewDefinitions\n      overrideExisting?: boolean\n    }): Api<\n      BaseQuery,\n      Definitions & NewDefinitions,\n      ReducerPath,\n      TagTypes,\n      Enhancers\n    >\n    enhanceEndpoints<NewTagTypes extends string = never>(_: {\n      addTagTypes?: readonly NewTagTypes[]\n      endpoints?: ReplaceTagTypes<\n        Definitions,\n        TagTypes | NoInfer<NewTagTypes>\n      > extends infer NewDefinitions\n        ? {\n            [K in keyof NewDefinitions]?:\n              | Partial<NewDefinitions[K]>\n              | ((definition: NewDefinitions[K]) => void)\n          }\n        : never\n    }): Api<\n      BaseQuery,\n      ReplaceTagTypes<Definitions, TagTypes | NewTagTypes>,\n      ReducerPath,\n      TagTypes | NewTagTypes,\n      Enhancers\n    >\n  }\n>\n\n// @public (undocumented)\nexport interface ApiModules<\n  BaseQuery extends BaseQueryFn,\n  Definitions extends EndpointDefinitions,\n  ReducerPath extends string,\n  TagTypes extends string,\n> {}\n\n// @public\nexport function ApiProvider<A extends Api<any, {}, any, any>>(props: {\n  children: any\n  api: A\n  setupListeners?: Parameters<typeof setupListeners>[1]\n  context?: Context<ReactReduxContextValue | null>\n}): JSX.Element\n\n// @public (undocumented)\nexport type ApiWithInjectedEndpoints<\n  ApiDefinition extends Api<any, any, any, any>,\n  Injections extends ApiDefinition extends Api<infer B, any, infer R, infer E>\n    ? [Api<B, any, R, E>, ...Api<B, any, R, E>[]]\n    : never,\n> = Omit<ApiDefinition, 'endpoints'> &\n  Omit<Injections, 'endpoints'> & {\n    endpoints: ApiDefinition['endpoints'] &\n      Partial<UnionToIntersection<Injections[number]['endpoints']>>\n  }\n\n// @public (undocumented)\nexport type BaseQueryEnhancer<\n  AdditionalArgs = unknown,\n  AdditionalDefinitionExtraOptions = unknown,\n  Config = void,\n> = <BaseQuery extends BaseQueryFn>(\n  baseQuery: BaseQuery,\n  config: Config,\n) => BaseQueryFn<\n  BaseQueryArg<BaseQuery> & AdditionalArgs,\n  BaseQueryResult<BaseQuery>,\n  BaseQueryError<BaseQuery>,\n  BaseQueryExtraOptions<BaseQuery> & AdditionalDefinitionExtraOptions\n>\n\n// @public (undocumented)\nexport type BaseQueryFn<\n  Args = any,\n  Result = unknown,\n  Error = unknown,\n  DefinitionExtraOptions = {},\n  Meta = {},\n> = (\n  args: Args,\n  api: BaseQueryApi,\n  extraOptions: DefinitionExtraOptions,\n) => MaybePromise<QueryReturnValue<Result, Error, Meta>>\n\n// @public\nexport function buildCreateApi<Modules extends [Module<any>, ...Module<any>[]]>(\n  ...modules: Modules\n): CreateApi<Modules[number]['name']>\n\n// @public (undocumented)\nexport function copyWithStructuralSharing<T>(oldObj: any, newObj: T): T\n\n// @public\nexport const coreModule: () => Module<CoreModule>\n\n// @public (undocumented)\nexport type CreateApi<Modules extends ModuleName> = {\n  <\n    BaseQuery extends BaseQueryFn,\n    Definitions extends EndpointDefinitions,\n    ReducerPath extends string = 'api',\n    TagTypes extends string = never,\n  >(\n    options: CreateApiOptions<BaseQuery, Definitions, ReducerPath, TagTypes>,\n  ): Api<BaseQuery, Definitions, ReducerPath, TagTypes, Modules>\n}\n\n// @public (undocumented)\nexport const createApi: CreateApi<\n  typeof coreModuleName | typeof reactHooksModuleName\n>\n\n// @public (undocumented)\nexport interface CreateApiOptions<\n  BaseQuery extends BaseQueryFn,\n  Definitions extends EndpointDefinitions,\n  ReducerPath extends string = 'api',\n  TagTypes extends string = never,\n> {\n  baseQuery: BaseQuery\n  endpoints(\n    build: EndpointBuilder<BaseQuery, TagTypes, ReducerPath>,\n  ): Definitions\n  keepUnusedDataFor?: number\n  reducerPath?: ReducerPath\n  refetchOnFocus?: boolean\n  refetchOnMountOrArgChange?: boolean | number\n  refetchOnReconnect?: boolean\n  serializeQueryArgs?: SerializeQueryArgs<unknown>\n  tagTypes?: readonly TagTypes[]\n}\n\n// @public (undocumented)\nexport type EndpointDefinition<\n  QueryArg,\n  BaseQuery extends BaseQueryFn,\n  TagTypes extends string,\n  ResultType,\n  ReducerPath extends string = string,\n> =\n  | QueryDefinition<QueryArg, BaseQuery, TagTypes, ResultType, ReducerPath>\n  | MutationDefinition<QueryArg, BaseQuery, TagTypes, ResultType, ReducerPath>\n\n// @public (undocumented)\nexport type EndpointDefinitions = Record<\n  string,\n  EndpointDefinition<any, any, any, any>\n>\n\n// @public\nexport function fakeBaseQuery<ErrorType>(): BaseQueryFn<\n  void,\n  NEVER,\n  ErrorType,\n  {}\n>\n\n// @public (undocumented)\nexport interface FetchArgs extends CustomRequestInit {\n  // (undocumented)\n  body?: any\n  // (undocumented)\n  params?: Record<string, any>\n  // (undocumented)\n  responseHandler?: ResponseHandler\n  // (undocumented)\n  url: string\n  // (undocumented)\n  validateStatus?: (response: Response, body: any) => boolean\n}\n\n// @public\nexport function fetchBaseQuery({\n  baseUrl,\n  prepareHeaders,\n  fetchFn,\n  ...baseFetchOptions\n}?: FetchBaseQueryArgs): BaseQueryFn<\n  string | FetchArgs,\n  unknown,\n  FetchBaseQueryError,\n  {},\n  FetchBaseQueryMeta\n>\n\n// @public (undocumented)\nexport interface FetchBaseQueryError {\n  // (undocumented)\n  data: unknown\n  // (undocumented)\n  status: number\n}\n\n// @public (undocumented)\nexport type Module<Name extends ModuleName> = {\n  name: Name\n  init<\n    BaseQuery extends BaseQueryFn,\n    Definitions extends EndpointDefinitions,\n    ReducerPath extends string,\n    TagTypes extends string,\n  >(\n    api: Api<BaseQuery, EndpointDefinitions, ReducerPath, TagTypes, ModuleName>,\n    options: Required<\n      CreateApiOptions<BaseQuery, Definitions, ReducerPath, TagTypes>\n    >,\n    context: ApiContext<Definitions>,\n  ): {\n    injectEndpoint(\n      endpointName: string,\n      definition: EndpointDefinition<any, any, any, any>,\n    ): void\n  }\n}\n\n// @public (undocumented)\nexport type MutationDefinition<\n  QueryArg,\n  BaseQuery extends BaseQueryFn,\n  TagTypes extends string,\n  ResultType,\n  ReducerPath extends string = string,\n> = BaseEndpointDefinition<QueryArg, BaseQuery, ResultType> &\n  MutationExtraOptions<TagTypes, ResultType, QueryArg, BaseQuery, ReducerPath>\n\n// @public (undocumented)\nexport type QueryDefinition<\n  QueryArg,\n  BaseQuery extends BaseQueryFn,\n  TagTypes extends string,\n  ResultType,\n  ReducerPath extends string = string,\n> = BaseEndpointDefinition<QueryArg, BaseQuery, ResultType> &\n  QueryExtraOptions<TagTypes, ResultType, QueryArg, BaseQuery, ReducerPath>\n\n// @public\nexport enum QueryStatus {\n  // (undocumented)\n  fulfilled = 'fulfilled',\n  // (undocumented)\n  pending = 'pending',\n  // (undocumented)\n  rejected = 'rejected',\n  // (undocumented)\n  uninitialized = 'uninitialized',\n}\n\n// @public\nexport const reactHooksModule: ({\n  batch,\n  useDispatch,\n  useSelector,\n  useStore,\n}?: ReactHooksModuleOptions) => Module<ReactHooksModule>\n\n// @public\nexport const retry: BaseQueryEnhancer<\n  unknown,\n  StaggerOptions,\n  void | StaggerOptions\n> & {\n  fail: typeof fail_2\n}\n\n// @public\nexport function setupListeners(\n  dispatch: ThunkDispatch<any, any, any>,\n  customHandler?: (\n    dispatch: ThunkDispatch<any, any, any>,\n    actions: {\n      onFocus: typeof onFocus\n      onFocusLost: typeof onFocusLost\n      onOnline: typeof onOnline\n      onOffline: typeof onOffline\n    },\n  ) => () => void,\n): () => void\n\n// @public (undocumented)\nexport const skipSelector: unique symbol\n```\n\n----------------------------------------\n\nTITLE: Using isRejected in TypeScript\nDESCRIPTION: Shows how to use the isRejected utility to check if an action is a 'rejected' action from the createAsyncThunk promise lifecycle.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/matching-utilities.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isRejected } from '@reduxjs/toolkit'\nimport type { UnknownAction } from '@reduxjs/toolkit'\nimport { requestThunk1, requestThunk2 } from '@virtual/matchers'\n\nconst isARejectedAction = isRejected(requestThunk1, requestThunk2)\n\nfunction handleRejectedAction(action: UnknownAction) {\n  if (isARejectedAction(action)) {\n    // action is a rejected action dispatched by either `requestThunk1` or `requestThunk2`\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Mutation onCacheEntryAdded Signature in TypeScript\nDESCRIPTION: Specifies the TypeScript signature for the onCacheEntryAdded function in a mutation endpoint. It includes parameters for the query argument and a MutationCacheLifecycleApi object with various properties and methods for cache management.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/createApi.mdx#2025-04-17_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nasync function onCacheEntryAdded(\n  arg: QueryArg,\n  {\n    dispatch,\n    getState,\n    extra,\n    requestId,\n    cacheEntryRemoved,\n    cacheDataLoaded,\n    getCacheEntry,\n  }: MutationCacheLifecycleApi,\n): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Implementing Thunk Action Creator for Pokemon API Fetching in TypeScript\nDESCRIPTION: Creates an async thunk for fetching Pokemon data by name from the PokeAPI. The thunk handles the API request, response parsing, and error handling with proper typing for the returned Pokemon data.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/migrating-to-rtk-query.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAsyncThunk, createSlice } from '@reduxjs/toolkit'\nimport type { Pokemon } from './types'\nimport type { RootState } from '../store'\n\nexport const fetchPokemonByName = createAsyncThunk<Pokemon, string>(\n  'pokemon/fetchByName',\n  async (name, { rejectWithValue }) => {\n    const response = await fetch(`https://pokeapi.co/api/v2/pokemon/${name}`)\n    const data = await response.json()\n    if (response.status < 200 || response.status >= 300) {\n      return rejectWithValue(data)\n    }\n    return data\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Default JSON Response Handler in TypeScript\nDESCRIPTION: Shows the default implementation of the JSON response handler used by fetchBaseQuery when no custom handler is specified.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/fetchBaseQuery.mdx#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst defaultResponseHandler = async (res: Response) => {\n  const text = await res.text()\n  return text.length ? JSON.parse(text) : null\n}\n```\n\n----------------------------------------\n\nTITLE: useQuerySubscription and useLazyQuerySubscription Type Definitions\nDESCRIPTION: Type definitions for the useQuerySubscription and useLazyQuerySubscription hooks.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/hooks.mdx#2025-04-17_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\ntype UseQuerySubscription = (\n  arg: any | SkipToken,\n  options?: UseQuerySubscriptionOptions,\n) => UseQuerySubscriptionResult\n\ntype UseQuerySubscriptionOptions = {\n  skip?: boolean\n  refetchOnMountOrArgChange?: boolean | number\n  pollingInterval?: number\n  skipPollingIfUnfocused?: boolean\n  refetchOnReconnect?: boolean\n  refetchOnFocus?: boolean\n}\n\ntype UseQuerySubscriptionResult = {\n  refetch: () => void\n}\n\ntype UseLazyQuerySubscription = (\n  options?: UseLazyQuerySubscriptionOptions,\n) => [UseLazyQuerySubscriptionTrigger, LastArg]\n\ntype UseLazyQuerySubscriptionOptions = {\n  pollingInterval?: number\n  skipPollingIfUnfocused?: boolean\n  refetchOnReconnect?: boolean\n  refetchOnFocus?: boolean\n}\n\ntype UseLazyQuerySubscriptionTrigger = (\n  arg: any,\n  preferCacheValue?: boolean,\n) => void\n```\n\n----------------------------------------\n\nTITLE: Redux-Observable Integration - TypeScript\nDESCRIPTION: Example of using action creator's match method with redux-observable\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAction.mdx#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAction } from '@reduxjs/toolkit'\nimport type { Action } from '@reduxjs/toolkit'\nimport type { Observable } from 'rxjs'\nimport { map, filter } from 'rxjs/operators'\n\nconst increment = createAction<number>('INCREMENT')\n\nexport const epic = (actions$: Observable<Action>) =>\n  actions$.pipe(\n    filter(increment.match),\n    map((action) => {\n      // action.payload can be safely used as number here (and will also be correctly inferred by TypeScript)\n      // ...\n    }),\n  )\n```\n\n----------------------------------------\n\nTITLE: Implementing Mutation Substate Update Function\nDESCRIPTION: Utility function that updates a mutation substate if it exists for a given ID. Uses getMutationCacheKey to determine the cache key.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/internal/buildSlice.mdx#2025-04-17_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nfunction updateMutationSubstateIfExists(state, id, update) {\n  const substate = state[getMutationCacheKey(id)]\n  if (substate) {\n    update(substate)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initiating a Query in React with Redux Toolkit\nDESCRIPTION: This example demonstrates how to initiate a query using the initiate function in a React component with Redux Toolkit.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/endpoints.mdx#2025-04-17_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react'\nimport { useAppDispatch } from './store/hooks'\nimport { api } from './services/api'\n\nfunction App() {\n  const dispatch = useAppDispatch()\n  const [postId, setPostId] = useState<number>(1)\n\n  useEffect(() => {\n    // highlight-start\n    // Add a subscription\n    const result = dispatch(api.endpoints.getPost.initiate(postId))\n\n    // Return the `unsubscribe` callback to be called in the `useEffect` cleanup step\n    return result.unsubscribe\n    // highlight-end\n  }, [dispatch, postId])\n\n  return (\n    <div>\n      <div>Initiate query example</div>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: RTK Query Core Thunks\nDESCRIPTION: Lists the core async thunks that power RTK Query's internal functionality.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/internal/overview.mdx#2025-04-17_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n- `queryThunk`\n- `mutationThunk`\n- `patchedQueryData`\n- `updateQueryData`\n- `upsertQueryData`\n- `prefetch`\n- `buildMatchThunkActions`\n```\n\n----------------------------------------\n\nTITLE: BaseQuery Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript type definition for the baseQuery function used in createApi. It includes the function parameters and return type, as well as the structure of the BaseQueryApi object passed to the function.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/createApi.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport type BaseQueryFn<\n  Args = any,\n  Result = unknown,\n  Error = unknown,\n  DefinitionExtraOptions = {},\n  Meta = {},\n> = (\n  args: Args,\n  api: BaseQueryApi,\n  extraOptions: DefinitionExtraOptions,\n) => MaybePromise<QueryReturnValue<Result, Error, Meta>>\n\nexport interface BaseQueryApi {\n  signal: AbortSignal\n  abort: (reason?: string) => void\n  dispatch: ThunkDispatch<any, any, any>\n  getState: () => unknown\n  extra: unknown\n  endpoint: string\n  type: 'query' | 'mutation'\n  forced?: boolean\n}\n\nexport type QueryReturnValue<T = unknown, E = unknown, M = unknown> =\n  | {\n      error: E\n      data?: undefined\n      meta?: M\n    }\n  | {\n      error?: undefined\n      data: T\n      meta?: M\n    }\n```\n\n----------------------------------------\n\nTITLE: Custom Base Query Implementation with Arguments\nDESCRIPTION: Shows base query function structure with required arguments and return format.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/customizing-queries.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst customBaseQuery = (\n  args,\n  { signal, dispatch, getState },\n  extraOptions,\n) => {\n  if (Math.random() > 0.5) return { error: 'Too high!' }\n  return { data: 'All good!' }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing RTK Query APIs in TypeScript\nDESCRIPTION: Code examples showing how to import the createApi function from RTK Query's core or React-specific entry points. The React entry point automatically generates hooks for defined endpoints.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/introduction/getting-started.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi } from '@reduxjs/toolkit/query'\n\n/* React-specific entry point that automatically generates\n   hooks corresponding to the defined endpoints */\nimport { createApi } from '@reduxjs/toolkit/query/react'\n```\n\n----------------------------------------\n\nTITLE: fetchBaseQuery Type Signature\nDESCRIPTION: The complete TypeScript type signature for fetchBaseQuery and related types, showing all available parameters and return types.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/fetchBaseQuery.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype FetchBaseQuery = (\n  args: FetchBaseQueryArgs,\n) => (\n  args: string | FetchArgs,\n  api: BaseQueryApi,\n  extraOptions: ExtraOptions,\n) => FetchBaseQueryResult\n\ntype FetchBaseQueryArgs = {\n  baseUrl?: string\n  prepareHeaders?: (\n    headers: Headers,\n    api: Pick<\n      BaseQueryApi,\n      'getState' | 'extra' | 'endpoint' | 'type' | 'forced'\n    > & { arg: string | FetchArgs },\n  ) => MaybePromise<Headers | void>\n  fetchFn?: (\n    input: RequestInfo,\n    init?: RequestInit | undefined,\n  ) => Promise<Response>\n  paramsSerializer?: (params: Record<string, any>) => string\n  isJsonContentType?: (headers: Headers) => boolean\n  jsonContentType?: string\n  timeout?: number\n} & RequestInit\n\ntype FetchBaseQueryResult = Promise<\n  | {\n      data: any\n      error?: undefined\n      meta?: { request: Request; response: Response }\n    }\n  | {\n      error: FetchBaseQueryError\n      data?: undefined\n      meta?: { request: Request; response: Response }\n    }\n>\n\ntype FetchBaseQueryError =\n  | {\n      /**\n       * * `number`:\n       *   HTTP status code\n       */\n      status: number\n      data: unknown\n    }\n  | {\n      /**\n       * * `\"FETCH_ERROR\"`:\n       *   An error that occurred during execution of `fetch` or the `fetchFn` callback option\n       **/\n      status: 'FETCH_ERROR'\n      data?: undefined\n      error: string\n    }\n  | {\n      /**\n       * * `\"PARSING_ERROR\"`:\n       *   An error happened during parsing.\n       *   Most likely a non-JSON-response was returned with the default `responseHandler` \"JSON\",\n       *   or an error occurred while executing a custom `responseHandler`.\n       **/\n      status: 'PARSING_ERROR'\n      originalStatus: number\n      data: string\n      error: string\n    }\n  | {\n      /**\n       * * `\"TIMEOUT_ERROR\"`:\n       *   Request timed out\n       **/\n      status: 'TIMEOUT_ERROR'\n      data?: undefined\n      error: string\n    }\n  | {\n      /**\n       * * `\"CUSTOM_ERROR\"`:\n       *   A custom error type that you can return from your `queryFn` where another error might not make sense.\n       **/\n      status: 'CUSTOM_ERROR'\n      data?: unknown\n      error: string\n    }\n```\n\n----------------------------------------\n\nTITLE: Testing Thunk Cancellation in Redux Toolkit\nDESCRIPTION: This snippet shows how to test that a thunk was cancelled before executing by checking the meta.condition property of the result.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAsyncThunk.mdx#2025-04-17_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAsyncThunk } from '@reduxjs/toolkit'\n\ntest('this thunk should always be skipped', async () => {\n  const thunk = createAsyncThunk(\n    'users/fetchById',\n    async () => throw new Error('This promise should never be entered'),\n    {\n      condition: () => false,\n    }\n  )\n  const result = await thunk()(dispatch, getState, null)\n\n  expect(result.meta.condition).toBe(true)\n  expect(result.meta.aborted).toBe(false)\n})\n```\n\n----------------------------------------\n\nTITLE: Condition Check Logic in TypeScript\nDESCRIPTION: Implements conditional logic to determine if a query should proceed based on various factors including upsert status, request state, and force refresh settings.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/internal/queryThunk.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nif (isUpsertQuery(queryThunkArgs)) { return true }\nif (requestState?.status === \"pending\") { return false }\nif (isForcedQuery(queryThunkArgs, state)) { return true }\nif (isQueryDefinition(endpointDefinition) && endpointDefinition?.forceRefetch?.({ return true }\nif (fulfilledVal) { return false }\nelse return true\n```\n\n----------------------------------------\n\nTITLE: ConfigureStore TypeScript Interface Definition\nDESCRIPTION: TypeScript interface defining the configuration options for configureStore, including reducer, middleware, devTools, and other store setup parameters.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/configureStore.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ConfigureStoreOptions<\n  S = any,\n  A extends Action = UnknownAction,\n  M extends Tuple<Middlewares<S>> = Tuple<Middlewares<S>>\n  E extends Tuple<Enhancers> = Tuple<Enhancers>,\n  P = S\n> {\n  reducer: Reducer<S, A, P> | ReducersMapObject<S, A, P>\n  middleware?: ((getDefaultMiddleware: CurriedGetDefaultMiddleware<S>) => M) | M\n  devTools?: boolean | DevToolsOptions\n  duplicateMiddlewareCheck?: boolean\n  preloadedState?: P\n  enhancers?: (getDefaultEnhancers: GetDefaultEnhancers<M>) => E | E\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Store Enhancers\nDESCRIPTION: Demonstrates how to customize the enhancers list by providing a specific enhancer function.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/getDefaultEnhancers.mdx#2025-04-17_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst store = configureStore({\n  reducer: rootReducer,\n  enhancers: () => new Tuple(offline(offlineConfig)),\n})\n\n// store specifically has the offline enhancer applied\n```\n\n----------------------------------------\n\nTITLE: Installing and Running RTK Codemods\nDESCRIPTION: Commands for installing and executing the Redux Toolkit codemod transformation tool using npm or yarn.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/rtk-codemods/transforms/createReducerBuilder/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx @reduxjs/rtk-codemods createReducerBuilder path/of/files/ or/some**/*glob.js\n\n# or\n\nyarn global add @reduxjs/rtk-codemods\nrtk-codemods createReducerBuilder path/of/files/ or/some**/*glob.js\n```\n\n----------------------------------------\n\nTITLE: Customizing createSelector for Redux Toolkit Query\nDESCRIPTION: This code snippet shows how to customize the createSelector function used by RTK Query. It creates a custom selector creator using lruMemoize and applies it to both core and React hooks modules.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/customizing-create-api.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as React from 'react'\nimport { createSelectorCreator, lruMemoize } from '@reduxjs/toolkit'\nimport {\n  buildCreateApi,\n  coreModule,\n  reactHooksModule,\n} from '@reduxjs/toolkit/query/react'\n\nconst createLruSelector = createSelectorCreator(lruMemoize)\n\nconst customCreateApi = buildCreateApi(\n  coreModule({ createSelector: createLruSelector }),\n  reactHooksModule({ createSelector: createLruSelector }),\n)\n```\n\n----------------------------------------\n\nTITLE: Using Skip Option in React Component\nDESCRIPTION: Shows an example of using the skip option in a React component, highlighting TypeScript errors when dealing with undefined values.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage-with-typescript.mdx#2025-04-17_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useGetPostQuery } from './api'\n\nfunction MaybePost({ id }: { id?: number }) {\n  // @ts-expect-error id passed must be a number, but we don't call it when it isn't a number\n  const { data } = useGetPostQuery(id, { skip: !id })\n\n  return <div>...</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Using RTK Query Hook in React Component\nDESCRIPTION: This snippet shows how to use the RTK Query generated hook 'useGetPokemonByNameQuery' in a React component. The usage is identical to the custom hook, but with a different import path.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/migrating-to-rtk-query.mdx#2025-04-17_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport * as React from 'react'\nimport { useGetPokemonByNameQuery } from './services/api'\n\nexport default function App() {\n  const { data, isError, isLoading } = useGetPokemonByNameQuery('bulbasaur')\n\n  return (\n    <div className=\"App\">\n      {isError ? (\n        <>Oh no, there was an error</>\n      ) : isLoading ? (\n        <>Loading...</>\n      ) : data ? (\n        <>\n          <h3>{data.species.name}</h3>\n          <img src={data.sprites.front_shiny} alt={data.species.name} />\n        </>\n      ) : null}\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: getDefaultMiddleware API Reference\nDESCRIPTION: TypeScript interface definitions for the getDefaultMiddleware function and its options, showing all available configuration parameters.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/getDefaultMiddleware.mdx#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ThunkOptions<E = any> {\n  extraArgument: E\n}\n\ninterface ImmutableStateInvariantMiddlewareOptions {\n  // See \"Immutability Middleware\" page for definition\n}\n\ninterface SerializableStateInvariantMiddlewareOptions {\n  // See \"Serializability Middleware\" page for definition\n}\n\ninterface ActionCreatorInvariantMiddlewareOptions {\n  // See \"Action Creator Middleware\" page for definition\n}\n\ninterface GetDefaultMiddlewareOptions {\n  thunk?: boolean | ThunkOptions\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\n  actionCreatorCheck?: boolean | ActionCreatorInvariantMiddlewareOptions\n}\n\nfunction getDefaultMiddleware<S = any>(\n  options: GetDefaultMiddlewareOptions = {},\n): Middleware<{}, S>[]\n```\n\n----------------------------------------\n\nTITLE: Defining ForceRefetch Function Signature in TypeScript\nDESCRIPTION: Specifies the TypeScript signature for the forceRefetch function used in query endpoint definitions. It defines the function's parameters and return type.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/createApi.mdx#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ntype forceRefetch = (params: {\n  currentArg: QueryArg | undefined\n  previousArg: QueryArg | undefined\n  state: RootState<any, any, string>\n  endpointState?: QuerySubState<any>\n}) => boolean\n```\n\n----------------------------------------\n\nTITLE: Running Query/Mutation Example in TypeScript\nDESCRIPTION: Example showing how to await all running queries in an application.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/api-slice-utils.mdx#2025-04-17_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nawait Promise.all(dispatch(api.util.getRunningQueriesThunk()))\n```\n\n----------------------------------------\n\nTITLE: useLazyQuery Type Definitions\nDESCRIPTION: Type definitions for the useLazyQuery hook, including options, trigger function, and result state interfaces.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/hooks.mdx#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ntype UseLazyQuery = (\n  options?: UseLazyQueryOptions\n) => [UseLazyQueryTrigger, UseLazyQueryStateResult, UseLazyQueryLastPromiseInfo]\n\ntype UseLazyQueryOptions = {\n  pollingInterval?: number\n  skipPollingIfUnfocused?: boolean\n  refetchOnReconnect?: boolean\n  refetchOnFocus?: boolean\n  selectFromResult?: (result: UseQueryStateDefaultResult) => any\n}\n\ntype UseLazyQueryTrigger<T> = (arg: any, preferCacheValue?: boolean) => Promise<\n  QueryResultSelectorResult\n> & {\n  arg: unknown\n  requestId: string\n  subscriptionOptions: SubscriptionOptions\n\n   abort: () => void\n  unwrap: () => Promise<T>\n  unsubscribe: () => void\n  refetch: () => void\n  updateSubscriptionOptions: (options: SubscriptionOptions) () => void\n}\n\ntype UseLazyQueryStateResult<T> = {\n  originalArgs?: unknown\n  data?: T\n  currentData?: T\n  error?: unknown\n  requestId?: string\n  endpointName?: string\n  startedTimeStamp?: number\n  fulfilledTimeStamp?: number\n\n  isUninitialized: boolean\n  isLoading: boolean\n  isFetching: boolean\n  isSuccess: boolean\n  isError: boolean\n}\n\ntype UseLazyQueryLastPromiseInfo = {\n  lastArg: any\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Pre-Typed Draft-Safe Selectors in TypeScript\nDESCRIPTION: Example demonstrating how to define a pre-typed version of createDraftSafeSelector that has the RootState type built in, reducing the need to specify types repeatedly when creating selectors.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createSelector.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst createTypedDraftSafeSelector =\n  createDraftSafeSelector.withTypes<RootState>()\n```\n\n----------------------------------------\n\nTITLE: Feature Comparison Table in Markdown\nDESCRIPTION: A markdown table comparing features across RTK Query, React Query, Apollo, and URQL, covering aspects like supported protocols, API definition, caching strategies, and various functional capabilities.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/comparison.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Feature                                | rtk-query                               | [react-query]            | [apollo]                                                                            | [urql]                                                                                                      |\n| -------------------------------------- | --------------------------------------- | ------------------------ | ----------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- |\n| **Supported Protocols**                | any, REST included                      | any, none included       | GraphQL                                                                             | GraphQL                                                                                                     |\n| **API Definition**                     | declarative                             | on use, declarative      | GraphQL schema                                                                      | GraphQL schema                                                                                              |\n| **Cache by**                           | endpoint + serialized arguments         | user-defined query-key   | type/id                                                                             | type/id?                                                                                                    |\n| **Invalidation Strategy + Refetching** | declarative, by type and/or type/id     | manual by cache key      | automatic cache updates on per-entity level, manual query invalidation by cache key | declarative, by type OR automatic cache updates on per-entity level, manual query invalidation by cache key |\n```\n\n----------------------------------------\n\nTITLE: Using isAnyOf as a TypeScript Type Guard\nDESCRIPTION: Demonstrates how to use isAnyOf as a TypeScript type guard for union type inference in non-reducer contexts.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/matching-utilities.mdx#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isAnyOf } from '@reduxjs/toolkit'\nimport type { PayloadAction } from '@reduxjs/toolkit'\nimport { Data, isSpecial, isInteresting } from '@virtual/matchers' // this is a fake pkg that provides the types shown above\n\nconst isSpecialOrInteresting = isAnyOf(isSpecial, isInteresting)\n\nfunction someFunction(action: PayloadAction<Data>) {\n  if (isSpecialOrInteresting(action)) {\n    // \"action\" will be correctly typed as:\n    // `PayloadAction<Special> | PayloadAction<Interesting>`\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: RTK Query Middleware Type Definition\nDESCRIPTION: Type definition for the custom Redux middleware that handles caching, invalidation, subscriptions, and polling functionality\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/redux-integration.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nmiddleware: Middleware\n```\n\n----------------------------------------\n\nTITLE: Immer-Style Mutable Todo Reducer\nDESCRIPTION: Example of a todo reducer using Immer's \"mutating\" syntax for simpler state updates.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createReducer.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAction, createReducer } from '@reduxjs/toolkit'\n\ninterface Todo {\n  text: string\n  completed: boolean\n}\n\nconst addTodo = createAction<Todo>('todos/add')\nconst toggleTodo = createAction<number>('todos/toggle')\n\nconst todosReducer = createReducer([] as Todo[], (builder) => {\n  builder\n    .addCase(addTodo, (state, action) => {\n      const todo = action.payload\n      state.push(todo)\n    })\n    .addCase(toggleTodo, (state, action) => {\n      const index = action.payload\n      const todo = state[index]\n      todo.completed = !todo.completed\n    })\n})\n```\n\n----------------------------------------\n\nTITLE: Equivalent Pre-population Using setAll in JavaScript\nDESCRIPTION: This code demonstrates an alternative way to pre-populate the initial state using getInitialState and setAll methods of the entity adapter.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createEntityAdapter.mdx#2025-04-17_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst initialState = booksAdapter.getInitialState({\n  loading: 'idle',\n})\n\nconst prePopulatedState = booksAdapter.setAll(initialState, [\n  { id: 'a', title: 'First' },\n  { id: 'b', title: 'Second' },\n])\n```\n\n----------------------------------------\n\nTITLE: Example 1: Using updateQueryData with undefined argument\nDESCRIPTION: Example showing how to use updateQueryData with the 'getPosts' endpoint and an undefined argument, which matches a query cache key of 'getPosts(undefined)'. This demonstrates adding a new post to the cached posts array.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/api-slice-utils.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst patchCollection = dispatch(\n  api.util.updateQueryData('getPosts', undefined, (draftPosts) => {\n    draftPosts.push({ id: 1, name: 'Teddy' })\n  }),\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Utility Functions in TypeScript for Redux Toolkit\nDESCRIPTION: This snippet defines utility functions and types used in Redux Toolkit, including retry, setupListeners, and skipToken. These are used for managing API requests, listeners, and query skipping.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/toolkit/etc/rtk-query.api.md#2025-04-17_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n// @public\nexport const retry: BaseQueryEnhancer<\n  unknown,\n  RetryOptions,\n  void | RetryOptions\n> & {\n  fail: typeof fail_2\n}\n\n// @public\nexport function setupListeners(\n  dispatch: ThunkDispatch<any, any, any>,\n  customHandler?: (\n    dispatch: ThunkDispatch<any, any, any>,\n    actions: {\n      onFocus: typeof onFocus\n      onFocusLost: typeof onFocusLost\n      onOnline: typeof onOnline\n      onOffline: typeof onOffline\n    },\n  ) => () => void,\n): () => void\n\n// @public @deprecated (undocumented)\nexport const skipSelector: symbol\n\n// @public (undocumented)\nexport type SkipToken = typeof skipToken\n\n// @public\nexport const skipToken: unique symbol\n```\n\n----------------------------------------\n\nTITLE: autoBatchEnhancer Type Definitions\nDESCRIPTION: Shows the TypeScript type definitions for autoBatchEnhancer, including various options for controlling how notification callbacks are queued.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/autoBatchEnhancer.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport type SHOULD_AUTOBATCH = string\ntype AutoBatchOptions =\n  | { type: 'tick' }\n  | { type: 'timer'; timeout: number }\n  | { type: 'raf' }\n  | { type: 'callback'; queueNotification: (notify: () => void) => void }\n\nexport type autoBatchEnhancer = (options?: AutoBatchOptions) => StoreEnhancer\n```\n\n----------------------------------------\n\nTITLE: Example 2 Supplementary: How the cache key is matched\nDESCRIPTION: Examples of various hook and dispatch calls that would create a cache entry matching 'getPostById(1)' that can be updated with the updateQueryData example.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/api-slice-utils.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\napi.endpoints.getPostById.useQuery(1)\n\nuseGetPostByIdQuery(1)\n\nuseGetPostByIdQuery(1, { ...options })\n\ndispatch(api.endpoints.getPostById.initiate(1))\n\ndispatch(api.endpoints.getPostById.initiate(1, { ...options }))\n```\n\n----------------------------------------\n\nTITLE: Building React Production Bundle\nDESCRIPTION: Creates a production-ready build of the React application, optimizing and bundling all assets for deployment.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/examples/publish-ci/cra5/README.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Using isAllOf as a TypeScript Type Guard\nDESCRIPTION: Shows how to use isAllOf as a TypeScript type guard outside of reducer context for more precise type inference.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/matching-utilities.mdx#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isAllOf } from '@reduxjs/toolkit'\nimport type { PayloadAction } from '@reduxjs/toolkit'\nimport { isSpecial, isInteresting } from '@virtual/matchers' // This is a fake pkg that provides the types shown above\nimport type { Data } from '@virtual/matchers' // This is a fake pkg that provides the types shown above\n\nconst isSpecialAndInteresting = isAllOf(isSpecial, isInteresting)\n\nfunction someFunction(action: PayloadAction<Data>) {\n  if (isSpecialAndInteresting(action)) {\n    // \"action\" will be correctly typed as:\n    // `PayloadAction<Special> & PayloadAction<Interesting>`\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: copyWithStructuralSharing Function Signature\nDESCRIPTION: Type definition for utility that recursively merges objects while preserving existing references for unchanged values, used for optimizing re-renders with re-fetched data.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/otherExports.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport function copyWithStructuralSharing<T>(oldObj: any, newObj: T): T\nexport function copyWithStructuralSharing(oldObj: any, newObj: any): any {}\n```\n\n----------------------------------------\n\nTITLE: Using isPending in TypeScript\nDESCRIPTION: Shows how to use the isPending utility to check if an action is a 'pending' action from the createAsyncThunk promise lifecycle.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/matching-utilities.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isPending } from '@reduxjs/toolkit'\nimport type { UnknownAction } from '@reduxjs/toolkit'\nimport { requestThunk1, requestThunk2 } from '@virtual/matchers'\n\nconst isAPendingAction = isPending(requestThunk1, requestThunk2)\n\nfunction handlePendingAction(action: UnknownAction) {\n  if (isAPendingAction(action)) {\n    // action is a pending action dispatched by either `requestThunk1` or `requestThunk2`\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: GetInitialState Usage Example\nDESCRIPTION: Example showing how to use the getInitialState function attached to the created reducer.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createReducer.mdx#2025-04-17_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst counterReducer = createReducer(0, (builder) => {\n  builder\n    .addCase('increment', (state, action) => state + action.payload)\n    .addCase('decrement', (state, action) => state - action.payload)\n})\n\nconsole.log(counterReducer.getInitialState()) // 0\n```\n\n----------------------------------------\n\nTITLE: Example: Using upsertQueryData\nDESCRIPTION: Example showing how to use upsertQueryData to add or update a post with ID 1 in the cache. The dispatch returns a promise that resolves when the store has been updated.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/api-slice-utils.mdx#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nawait dispatch(\n  api.util.upsertQueryData('getPost', { id: 1 }, { id: 1, text: 'Hello!' }),\n)\n```\n\n----------------------------------------\n\nTITLE: Complex Immutable Update in Redux Reducer\nDESCRIPTION: Shows a more complex example of an immutable update in a Redux reducer, involving nested object structures.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/usage/immer-reducers.md#2025-04-17_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nfunction handwrittenReducer(state, action) {\n  return {\n    ...state,\n    first: {\n      ...state.first,\n      second: {\n        ...state.first.second,\n        [action.someId]: {\n          ...state.first.second[action.someId],\n          fourth: action.someValue,\n        },\n      },\n    },\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining enhanceEndpoints Function Signature in TypeScript\nDESCRIPTION: This snippet shows the TypeScript signature for the enhanceEndpoints function, which allows for enhancement of existing endpoint definitions in an API slice. It includes options for adding tag types and modifying endpoint definitions.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/code-splitting.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst enhanceEndpoints = (endpointOptions: EnhanceEndpointsOptions) =>\n  EnhancedApiSlice\n\ninterface EnhanceEndpointsOptions {\n  addTagTypes?: readonly string[]\n  endpoints?: Record<string, Partial<EndpointDefinition>>\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Redux Store with RTK Query Integration\nDESCRIPTION: Shows how to set up a Redux store with RTK Query integration, including configuring the reducer, middleware, and listeners. Demonstrates proper setup of the store with a Pokemon API example.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/redux-integration.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// file: src/services/pokemon.ts noEmit\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\n\nexport const pokemonApi = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: () => ({}),\n})\n\n// file: src/store.ts\nimport { configureStore } from '@reduxjs/toolkit'\nimport { setupListeners } from '@reduxjs/toolkit/query'\nimport { pokemonApi } from './services/pokemon'\n\nexport const store = configureStore({\n  reducer: {\n    // Add the generated reducer as a specific top-level slice\n    [pokemonApi.reducerPath]: pokemonApi.reducer,\n  },\n  // Adding the api middleware enables caching, invalidation, polling,\n  // and other useful features of `rtk-query`.\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware().concat(pokemonApi.middleware),\n})\n\n// configure listeners using the provided defaults\nsetupListeners(store.dispatch)\n```\n\n----------------------------------------\n\nTITLE: Building React Redux App for Production\nDESCRIPTION: Command to build the application for production deployment. Creates optimized bundle in the build folder with minified files and hashed filenames.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/examples/publish-ci/cra4/README.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Defining the usePrefetch Hook Signature in TypeScript\nDESCRIPTION: Shows the TypeScript type definition for the usePrefetch hook in RTK Query. It defines the PrefetchOptions type that can include force or ifOlderThan parameters, and describes the hook's parameter and return types.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/prefetching.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport type PrefetchOptions =\n  | { force?: boolean }\n  | {\n      ifOlderThan?: false | number;\n    };\n\nusePrefetch<EndpointName extends QueryKeys<Definitions>>(\n    endpointName: EndpointName,\n    options?: PrefetchOptions\n  ): (arg: QueryArgFrom<Definitions[EndpointName]>, options?: PrefetchOptions) => void;\n```\n\n----------------------------------------\n\nTITLE: Parsing API Response as Text in Redux Toolkit Query\nDESCRIPTION: Demonstrates how to configure an endpoint to parse the API response as text instead of the default JSON parsing in Redux Toolkit Query.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/fetchBaseQuery.mdx#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\n\nexport const customApi = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/api/' }),\n  endpoints: (build) => ({\n    getUsers: build.query({\n      query: () => ({\n        url: `users`,\n        // This is the same as passing 'text'\n        responseHandler: (response) => response.text(),\n      }),\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Using isFulfilled in TypeScript\nDESCRIPTION: Demonstrates the usage of isFulfilled utility to check if an action is a 'fulfilled' action from the createAsyncThunk promise lifecycle.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/matching-utilities.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isFulfilled } from '@reduxjs/toolkit'\nimport type { UnknownAction } from '@reduxjs/toolkit'\nimport { requestThunk1, requestThunk2 } from '@virtual/matchers'\n\nconst isAFulfilledAction = isFulfilled(requestThunk1, requestThunk2)\n\nfunction handleFulfilledAction(action: UnknownAction) {\n  if (isAFulfilledAction(action)) {\n    // action is a fulfilled action dispatched by either `requestThunk1` or `requestThunk2`\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Development Default Middleware List\nDESCRIPTION: Shows the default middleware array included in development builds, which includes tools for runtime checks.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/getDefaultMiddleware.mdx#2025-04-17_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst middleware = [\n  actionCreatorInvariant,\n  immutableStateInvariant,\n  thunk,\n  serializableStateInvariant,\n]\n```\n\n----------------------------------------\n\nTITLE: Manually Selecting Error from Redux Store in React\nDESCRIPTION: Shows how to manually select and display error information from the Redux store using a selector function.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/error-handling.mdx#2025-04-17_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nfunction PostsList() {\n  const { error } = useSelector(api.endpoints.getPosts.select())\n\n  return (\n    <div>\n      {error.status} {JSON.stringify(error.data)}\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom useDispatch Hook with Dynamic Middleware in React Redux\nDESCRIPTION: This snippet shows how to use createDispatchWithMiddlewareHook to create a custom useDispatch hook that includes extensions from provided middleware in a React component.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createDynamicMiddleware.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst useListenerDispatch = createDispatchWithMiddlewareHook(\n  listenerInstance.middleware,\n)\n\nconst Component = () => {\n  const listenerDispatch = useListenerDispatch()\n  useEffect(() => {\n    const unsubscribe = listenerDispatch(addListener({ type, effect }))\n    return () => unsubscribe()\n  }, [dispatch])\n}\n```\n\n----------------------------------------\n\nTITLE: InvalidateTags Function Signature and Examples in TypeScript\nDESCRIPTION: Type definition and usage examples for invalidateTags utility that manually invalidates cache tags.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/api-slice-utils.mdx#2025-04-17_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\ndispatch(api.util.invalidateTags(['Post']))\ndispatch(api.util.invalidateTags([{ type: 'Post', id: 1 }]))\ndispatch(\n  api.util.invalidateTags([\n    { type: 'Post', id: 1 },\n    { type: 'Post', id: 'LIST' },\n  ]),\n)\n```\n\n----------------------------------------\n\nTITLE: Programmatic Usage of OpenAPI Code Generator in TypeScript\nDESCRIPTION: Shows how to use the OpenAPI code generator programmatically in JavaScript/TypeScript rather than through the CLI. This approach allows for more flexibility in integration with build processes.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/code-generation.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateEndpoints } from '@rtk-query/codegen-openapi'\n\nconst api = await generateEndpoints({\n  apiFile: './fixtures/emptyApi.ts',\n  schemaFile: resolve(__dirname, 'fixtures/petstore.json'),\n  filterEndpoints: ['getPetById', 'addPet'],\n  hooks: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Running React Native App on iOS\nDESCRIPTION: These commands start the React Native application on an iOS device or simulator. The commands are provided for both npm and Yarn package managers.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/examples/publish-ci/react-native/README.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# using npm\nnpm run ios\n```\n\nLANGUAGE: bash\nCODE:\n```\n# OR using Yarn\nyarn ios\n```\n\n----------------------------------------\n\nTITLE: Implementing Polling with RTK Query Action Creators\nDESCRIPTION: This example shows how to implement polling in RTK Query using action creators without React hooks. It demonstrates dispatching an endpoint with subscription options that include a polling interval.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/polling.mdx#2025-04-17_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nconst { data, status, error, refetch } = store.dispatch(\n  endpoints.getCountById.initiate(id, {\n    subscriptionOptions: { pollingInterval: 3000 },\n  }),\n)\n```\n\n----------------------------------------\n\nTITLE: Default Immutability Check Implementation\nDESCRIPTION: The default implementation of the immutability check function that determines if a value should be considered immutable.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/immutabilityMiddleware.mdx#2025-04-17_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nreturn (\n  typeof value !== 'object' || value === null || typeof value === 'undefined'\n)\n```\n\n----------------------------------------\n\nTITLE: Combining Immutable Updates with Mutations\nDESCRIPTION: Shows how to perform immutable operations and then save results through mutation. Examples include filtering a nested array and saving the result.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/usage/immer-reducers.md#2025-04-17_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nconst todosSlice = createSlice({\n  name: 'todos',\n  initialState: {todos: [], status: 'idle'}\n  reducers: {\n    todoDeleted(state, action.payload) {\n      // Construct a new array immutably\n      const newTodos = state.todos.filter(todo => todo.id !== action.payload)\n      // \"Mutate\" the existing state to save the new array\n      state.todos = newTodos\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Production Default Middleware List\nDESCRIPTION: Shows the default middleware array included in production builds, which is streamlined for performance.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/getDefaultMiddleware.mdx#2025-04-17_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst middleware = [thunk]\n```\n\n----------------------------------------\n\nTITLE: Configuring autoBatchEnhancer in Redux Toolkit 2.0\nDESCRIPTION: Shows how to configure the autoBatchEnhancer in Redux Toolkit 2.0, where it's included by default in configureStore using the getDefaultEnhancers callback.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/autoBatchEnhancer.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configureStore } from '@reduxjs/toolkit'\n\nconst store = configureStore({\n  reducer: () => 0,\n  enhancers: (getDefaultEnhancers) =>\n    getDefaultEnhancers({\n      autoBatch: { type: 'tick' },\n    }),\n})\n```\n\n----------------------------------------\n\nTITLE: FetchBaseQueryError Type Definition\nDESCRIPTION: Defines the structure of FetchBaseQueryError type used for handling different kinds of fetch-related errors in RTK Query.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage-with-typescript.mdx#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport type FetchBaseQueryError =\n  | {\n      status: number\n      data: unknown\n    }\n  | {\n      status: 'FETCH_ERROR'\n      data?: undefined\n      error: string\n    }\n  | {\n      status: 'PARSING_ERROR'\n      originalStatus: number\n      data: string\n      error: string\n    }\n  | {\n      status: 'CUSTOM_ERROR'\n      data?: unknown\n      error: string\n    }\n```\n\n----------------------------------------\n\nTITLE: JavaScript createSlice Transformation Example\nDESCRIPTION: Example showing the transformation of JavaScript createSlice code from object syntax to builder callback syntax. Demonstrates handling of various reducer function syntaxes and multiple action types.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/rtk-codemods/transforms/createSliceBuilder/README.md#2025-04-17_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst slice1 = createSlice({\n  name: 'a',\n  initialState: {},\n  extraReducers: {\n    [todoAdded1a]: (state, action) => {\n      // stuff\n    },\n    [todoAdded1b]: (state, action) => action.payload,\n    [todoAdded1c + 'test']: (state, action) => {\n      // stuff\n    },\n    [todoAdded1d](state, action) {\n      // stuff\n    },\n    [todoAdded1e]: function (state, action) {\n      // stuff\n    },\n    todoAdded1f: (state, action) => {\n      //stuff\n    }\n  }\n})\n\nconst slice2 = createSlice({\n  name: 'b',\n  initialState: {},\n  extraReducers: {\n    [todoAdded2a]: (state, action) => {\n      // stuff\n    },\n    [todoAdded2b](state, action) {\n      // stuff\n    },\n    [todoAdded2c]: function (state, action) {\n      // stuff\n    }\n  }\n})\n```\n\nLANGUAGE: javascript\nCODE:\n```\nconst slice1 = createSlice({\n  name: 'a',\n  initialState: {},\n\n  extraReducers: (builder) => {\n    builder.addCase(todoAdded1a, (state, action) => {\n      // stuff\n    })\n\n    builder.addCase(todoAdded1b, (state, action) => action.payload)\n\n    builder.addCase(todoAdded1c + 'test', (state, action) => {\n      // stuff\n    })\n\n    builder.addCase(todoAdded1d, (state, action) => {\n      // stuff\n    })\n\n    builder.addCase(todoAdded1e, (state, action) => {\n      // stuff\n    })\n\n    builder.addCase(todoAdded1f, (state, action) => {\n      //stuff\n    })\n  }\n})\n\nconst slice2 = createSlice({\n  name: 'b',\n  initialState: {},\n\n  extraReducers: (builder) => {\n    builder.addCase(todoAdded2a, (state, action) => {\n      // stuff\n    })\n\n    builder.addCase(todoAdded2b, (state, action) => {\n      // stuff\n    })\n\n    builder.addCase(todoAdded2c, (state, action) => {\n      // stuff\n    })\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Cloning Redux Toolkit Repository - Git\nDESCRIPTION: Command to clone the forked Redux Toolkit repository to local machine. Requires Git to be installed and GitHub fork to be created first.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/CONTRIBUTING.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngit clone https://github.com/your-username/redux-toolkit.git\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Context-Aware Dispatch Hook Factory in React Redux\nDESCRIPTION: This code demonstrates how to use createDispatchWithMiddlewareHookFactory to create a custom dispatch hook factory that uses a specific React context for Redux integration.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createDynamicMiddleware.mdx#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst createDispatchWithMiddlewareHook =\n  createDispatchWithMiddlewareHookFactory(context)\n```\n\n----------------------------------------\n\nTITLE: Defining Immutability Middleware Options Interface in TypeScript\nDESCRIPTION: TypeScript interface definition for the immutability middleware options, including isImmutable function type, ignoredPaths configuration, and performance warning threshold.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/immutabilityMiddleware.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype IsImmutableFunc = (value: any) => boolean\n\ninterface ImmutableStateInvariantMiddlewareOptions {\n  isImmutable?: IsImmutableFunc\n  ignoredPaths?: (string | RegExp)[]\n  warnAfter?: number\n}\n```\n\n----------------------------------------\n\nTITLE: Delayed Tag Invalidation Implementation in TypeScript\nDESCRIPTION: Implements delayed invalidation behavior that batches invalidations while queries or mutations are pending.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/internal/buildMiddleware/invalidationByTags.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nfunction invalidateTags(\n  newTags: readonly FullTagDescription<string>[],\n  mwApi: SubMiddlewareApi,\n) {\n  const rootState = mwApi.getState()\n  const state = rootState[reducerPath]\n\n  pendingTagInvalidations.push(...newTags)\n\n  if (\n    state.config.invalidationBehavior === 'delayed' &&\n    hasPendingRequests(state)\n  ) {\n    return\n  }\n```\n\n----------------------------------------\n\nTITLE: Configuring Immutability Middleware with Default Middleware\nDESCRIPTION: Example demonstrating how to customize the immutability middleware while keeping other default middleware using getDefaultMiddleware.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/immutabilityMiddleware.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configureStore } from '@reduxjs/toolkit'\n\nimport exampleSliceReducer from './exampleSlice'\n\nconst store = configureStore({\n  reducer: exampleSliceReducer,\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware({\n      immutableCheck: {\n        ignoredPaths: ['ignoredPath', 'ignoredNested.one', 'ignoredNested.two'],\n      },\n    }),\n})\n```\n\n----------------------------------------\n\nTITLE: Correct Immutable State Update in Redux Reducer\nDESCRIPTION: Demonstrates the correct way to update state immutably in a Redux reducer by creating a new object with spread syntax.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/usage/immer-reducers.md#2025-04-17_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n//  This is safe, because we made a copy\nreturn {\n  ...state,\n  value: 123,\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Mutable State Update in Redux Reducer\nDESCRIPTION: Shows an illegal way of updating state in a Redux reducer by directly mutating the state object.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/usage/immer-reducers.md#2025-04-17_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n//  Illegal - by default, this will mutate the state!\nstate.value = 123\n```\n\n----------------------------------------\n\nTITLE: Defining Tag Invalidation Matchers in TypeScript\nDESCRIPTION: Defines matcher conditions for when tag invalidation should occur, including mutation thunk completion and query/mutation end states.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/internal/buildMiddleware/invalidationByTags.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst isThunkActionWithTags = isAnyOf(\n  isFulfilled(mutationThunk),\n  isRejectedWithValue(mutationThunk),\n)\n\nconst isQueryEnd = isAnyOf(\n  isFulfilled(mutationThunk, queryThunk),\n  isRejected(mutationThunk, queryThunk),\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Action Creator Middleware Options Interface in TypeScript\nDESCRIPTION: TypeScript interface definition for configuring the action creator invariant middleware. It allows customizing how action creators are identified with an optional isActionCreator function.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/actionCreatorMiddleware.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ActionCreatorInvariantMiddlewareOptions {\n  /**\n   * The function to identify whether a value is an action creator.\n   * The default checks for a function with a static type property and match method.\n   */\n  isActionCreator?: (action: unknown) => action is Function & { type?: unknown }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Redux Toolkit Dependencies - Bash\nDESCRIPTION: Commands to navigate to the project directory and install all required dependencies using Yarn package manager.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/CONTRIBUTING.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ cd redux-toolkit\n$ yarn\n```\n\n----------------------------------------\n\nTITLE: Using withLazyLoadedSlices for Type Declaration in Redux Toolkit\nDESCRIPTION: Demonstrates how to use withLazyLoadedSlices to declare slices that will be added to state later, ensuring proper type inference for lazy-loaded slices.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/combineSlices.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// file: slices/index.ts\nimport { combineSlices } from '@reduxjs/toolkit'\nimport { staticSlice } from './static'\n\nexport interface LazyLoadedSlices {}\n\nexport const rootReducer =\n  combineSlices(staticSlice).withLazyLoadedSlices<LazyLoadedSlices>()\n\n// keys in LazyLoadedSlices are marked as optional\nexport type RootState = ReturnType<typeof rootReducer>\n\n// file: slices/lazySlice.ts\nimport type { WithSlice } from '@reduxjs/toolkit'\nimport { rootReducer } from '.'\n\nconst lazySlice = createSlice({\n  /* ... */\n})\n\ndeclare module '.' {\n  export interface LazyLoadedSlices extends WithSlice<typeof lazySlice> {}\n}\n\nconst injectedReducer = rootReducer.inject(lazySlice)\n\n// and/or\n\nconst injectedSlice = lazySlice.injectInto(rootReducer)\n```\n\n----------------------------------------\n\nTITLE: Reducer Example without Matcher Utility\nDESCRIPTION: Shows a complex reducer example without using matcher utilities, demonstrating unnecessary complexity.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/matching-utilities.mdx#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAsyncThunk, createReducer } from '@reduxjs/toolkit'\nimport type { PayloadAction } from '@reduxjs/toolkit'\n\ninterface Data {\n  isInteresting: boolean\n  isSpecial: boolean\n}\n\ninterface Special extends Data {\n  isSpecial: true\n}\n\ninterface Interesting extends Data {\n  isInteresting: true\n}\n\nfunction isSpecial(\n  action: PayloadAction<Data>,\n): action is PayloadAction<Special> {\n  return action.payload.isSpecial\n}\n\nfunction isInteresting(\n  action: PayloadAction<Data>,\n): action is PayloadAction<Interesting> {\n  return action.payload.isInteresting\n}\n\ninterface ExampleState {\n  isSpecial: boolean\n  isInteresting: boolean\n}\n\nconst initialState = {\n  isSpecial: false,\n  isInteresting: false,\n} satisfies ExampleState as ExampleState\n\nexport const isSpecialAndInterestingThunk = createAsyncThunk(\n  'isSpecialAndInterestingThunk',\n  () => {\n    return {\n      isSpecial: true,\n      isInteresting: true,\n    }\n  },\n)\n\n// This has unnecessary complexity\nconst loadingReducer = createReducer(initialState, (builder) => {\n  builder.addCase(isSpecialAndInterestingThunk.fulfilled, (state, action) => {\n    if (isSpecial(action)) {\n      state.isSpecial = true\n    }\n    if (isInteresting(action)) {\n      state.isInteresting = true\n    }\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: ConfigureStore Function Signature\nDESCRIPTION: TypeScript function signature for configureStore showing its generic types and return value.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/configureStore.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction configureStore<\n  S = any,\n  A extends Action = UnknownAction,\n  M extends Tuple<Middlewares<S>> = Tuple<Middlewares<S>>\n  E extends Tuple<Enhancers> = Tuple<Enhancers>,\n  P = S\n>(options: ConfigureStoreOptions<S, A, M, E, P>): EnhancedStore<S, A, M, E>\n```\n\n----------------------------------------\n\nTITLE: Running OpenAPI Code Generator via CLI\nDESCRIPTION: Command to execute the RTK Query OpenAPI code generator using a configuration file. This will generate the API slice based on the OpenAPI schema.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/code-generation.mdx#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpx @rtk-query/codegen-openapi openapi-config.ts\n```\n\n----------------------------------------\n\nTITLE: Providing Redux Store to React Application\nDESCRIPTION: Wraps the React application with Redux Provider component to make the store available throughout the app.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/tutorials/quick-start.mdx#2025-04-17_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport React from 'react'\nimport { createRoot } from 'react-dom/client'\nimport './index.css'\nimport App from './App'\nimport { store } from './app/store'\nimport { Provider } from 'react-redux'\n\nconst container = document.getElementById('root')\n\nif (container) {\n  const root = createRoot(container)\n\n  root.render(\n    <Provider store={store}>\n      <App />\n    </Provider>,\n  )\n} else {\n  throw new Error(\n    \"Root element with ID 'root' was not found in the document. Ensure there is a corresponding HTML element with the ID 'root' in your HTML file.\",\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Mutable JavaScript Objects and Arrays\nDESCRIPTION: Shows how JavaScript objects and arrays are mutable by default, allowing direct modification of their contents.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/usage/immer-reducers.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst obj = { a: 1, b: 2 }\n// still the same object outside, but the contents have changed\nobj.b = 3\n\nconst arr = ['a', 'b']\n// In the same way, we can change the contents of this array\narr.push('c')\narr[1] = 'd'\n```\n\n----------------------------------------\n\nTITLE: Customizing HTTP Requests for Schema Fetching in OpenAPI Generator\nDESCRIPTION: Shows how to customize HTTP requests when fetching OpenAPI schemas using httpResolverOptions. This example adds custom headers and increases the timeout for schema fetching.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/code-generation.mdx#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst config: ConfigFile = {\n  schemaFile: 'https://petstore3.swagger.io/api/v3/openapi.json',\n  apiFile: './src/store/emptyApi.ts',\n  outputFile: './src/store/petApi.ts',\n  httpResolverOptions: {\n    timeout: 30_000,\n    headers: {\n      Accept: 'application/json',\n      Authorization: 'Basic cmVkdXgtdG9vbGtpdDppcy1ncmVhdA==',\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Case Reducer Example\nDESCRIPTION: Demonstration of multiple case reducer execution with matchers.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createReducer.mdx#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createReducer } from '@reduxjs/toolkit'\n\nconst reducer = createReducer(0, (builder) => {\n  builder\n    .addCase('increment', (state) => state + 1)\n    .addMatcher(\n      (action) => action.type.startsWith('i'),\n      (state) => state * 5,\n    )\n    .addMatcher(\n      (action) => action.type.endsWith('t'),\n      (state) => state + 2,\n    )\n})\n```\n\n----------------------------------------\n\nTITLE: Using nanoid Generator in TypeScript\nDESCRIPTION: Demonstrates usage of the nanoid utility for generating non-cryptographically-secure random ID strings, commonly used for request IDs in createAsyncThunk.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/otherExports.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { nanoid } from '@reduxjs/toolkit'\n\nconsole.log(nanoid())\n// 'dgPXxUz_6fWIQBD8XmiSy'\n```\n\n----------------------------------------\n\nTITLE: Initializing Entity State with Additional Properties in JavaScript\nDESCRIPTION: This example demonstrates how to use getInitialState to create an initial entity state object with additional properties, such as a loading status.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createEntityAdapter.mdx#2025-04-17_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst booksSlice = createSlice({\n  name: 'books',\n  initialState: booksAdapter.getInitialState({\n    loading: 'idle',\n  }),\n  reducers: {\n    booksLoadingStarted(state, action) {\n      // Can update the additional state field\n      state.loading = 'pending'\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Installing and Running RTK Codemods with NPX/Yarn\nDESCRIPTION: Commands for installing and executing Redux Toolkit codemods using either NPX or Yarn global installation. Allows specifying transform name and target files using glob patterns.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/rtk-codemods/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx @reduxjs/rtk-codemods <TRANSFORM NAME> path/of/files/ or/some**/*glob.js\n\n# or\n\nyarn global add @reduxjs/rtk-codemods\nrtk-codemods <TRANSFORM NAME> path/of/files/ or/some**/*glob.js\n```\n\n----------------------------------------\n\nTITLE: Importing RTK Query in TypeScript\nDESCRIPTION: TypeScript import statements for using RTK Query, including a React-specific entry point.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/toolkit/README.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi } from '@reduxjs/toolkit/query'\n\n/* React-specific entry point that automatically generates\n   hooks corresponding to the defined endpoints */\nimport { createApi } from '@reduxjs/toolkit/query/react'\n```\n\n----------------------------------------\n\nTITLE: Initializing React Native Project with Redux TypeScript Template\nDESCRIPTION: This command initializes a new React Native project using the Redux TypeScript template. It creates a new app named 'MyApp' with the necessary Redux and TypeScript configurations.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/examples/publish-ci/react-native/README.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpx react-native init MyApp --template react-native-template-redux-typescript\n```\n\n----------------------------------------\n\nTITLE: Filtering Parameters with Function Matcher in OpenAPI Generator\nDESCRIPTION: Shows how to use a function to filter parameters for endpoints. This example filters out header parameters from all endpoints using a function matcher.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/code-generation.mdx#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst withOverride: ConfigFile = {\n  // ...\n  endpointOverrides: [\n    {\n      pattern: /.*/,\n      parameterFilter: (_name, parameter) => parameter.in !== 'header',\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Pagination with Sizes in Redux Toolkit Infinite Query\nDESCRIPTION: This snippet demonstrates how to implement pagination with page sizes in a Redux Toolkit infinite query. It includes logic for calculating remaining pages and handling both next and previous page parameters.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/infinite-queries.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ntype ProjectsResponse = {\n  projects: Project[]\n  serverTime: string\n  totalPages: number\n}\n\ntype ProjectsInitialPageParam = {\n  page: number\n  size: number\n}\n\nconst projectsApi = createApi({\n  baseQuery,\n  endpoints: (build) => ({\n    projectsPaginated: build.infiniteQuery<\n      ProjectsResponse,\n      void,\n      ProjectsInitialPageParam\n    >({\n      infiniteQueryOptions: {\n        initialPageParam: {\n          page: 0,\n          size: 20,\n        },\n        getNextPageParam: (\n          lastPage,\n          allPages,\n          lastPageParam,\n          allPageParams,\n        ) => {\n          const nextPage = lastPageParam.page + 1\n          const remainingPages = lastPage?.totalPages - nextPage\n\n          if (remainingPages <= 0) {\n            return undefined\n          }\n\n          return {\n            ...lastPageParam,\n            page: nextPage,\n          }\n        },\n        getPreviousPageParam: (\n          firstPage,\n          allPages,\n          firstPageParam,\n          allPageParams,\n        ) => {\n          const prevPage = firstPageParam.page - 1\n          if (prevPage < 0) return undefined\n\n          return {\n            ...firstPageParam,\n            page: prevPage,\n          }\n        },\n      },\n      query: ({ pageParam: { page, size } }) => {\n        return `https://example.com/api/projectsPaginated?page=${page}&size=${size}`\n      },\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: RTK Query Build Steps Documentation\nDESCRIPTION: Lists the core slices built within RTK Query's internal architecture, including query, mutation, invalidation, subscription, and config slices.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/internal/overview.mdx#2025-04-17_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n- `querySlice`\n- `mutationSlice`\n- `invalidationSlice`\n- `subscriptionSlice` (used as a dummy slice to generate actions internally)\n- `internalSubscriptionsSlice`\n- `configSlice` (internal tracking of focus state, online state, hydration etc)\n```\n\n----------------------------------------\n\nTITLE: Injecting Redux Slice with Custom Reducer Path\nDESCRIPTION: Shows how to inject a slice with a custom reducer path using the configuration object. This allows injecting the slice under a different path than its default reducerPath property.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/combineSlices.mdx#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst aCounterSlice = counterSlice.injectInto(rootReducer, {\n  reducerPath: 'aCounter',\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing Redux Store with Data in Next.js App Router\nDESCRIPTION: This code shows how to initialize the Redux store with data passed as props to the StoreProvider component. It uses a Redux action to set the initial data in the store.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/usage/nextjs.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n'use client'\nimport { useRef } from 'react'\nimport { Provider } from 'react-redux'\nimport { makeStore, AppStore } from '../lib/store'\nimport { initializeCount } from '../lib/features/counter/counterSlice'\n\nexport default function StoreProvider({\n  count,\n  children,\n}: {\n  count: number\n  children: React.ReactNode\n}) {\n  const storeRef = useRef<AppStore | null>(null)\n  if (!storeRef.current) {\n    storeRef.current = makeStore()\n    storeRef.current.dispatch(initializeCount(count))\n  }\n\n  return <Provider store={storeRef.current}>{children}</Provider>\n}\n```\n\n----------------------------------------\n\nTITLE: Providing Redux Store with React-Redux Provider\nDESCRIPTION: Sets up the Redux store provider for the React application. Wraps the App component with the Provider component from react-redux to make the store accessible throughout the application.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/migrating-to-rtk-query.mdx#2025-04-17_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { render } from 'react-dom'\nimport { Provider } from 'react-redux'\n\nimport App from './App'\nimport { store } from './store'\n\nconst rootElement = document.getElementById('root')\nrender(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  rootElement,\n)\n```\n\n----------------------------------------\n\nTITLE: Installing Redux Toolkit in an Existing App\nDESCRIPTION: NPM and Yarn commands for installing Redux Toolkit in an existing application.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/toolkit/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# NPM\nnpm install @reduxjs/toolkit\n\n# Yarn\nyarn add @reduxjs/toolkit\n```\n\n----------------------------------------\n\nTITLE: Embedding Egghead.io Video Lesson with Inline HTML in Markdown\nDESCRIPTION: This code snippet shows how to embed an Egghead.io video lesson using inline HTML within a Markdown file. It creates a responsive iframe for the video content.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/tutorials/overview.md#2025-04-17_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<div style={{position:\"relative\",paddingTop:\"56.25%\"}}>\n  <iframe \n    src=\"https://app.egghead.io/lessons/redux-course-introduction-and-application-walk-through-for-rtk-query-basics/embed?af=7pnhj6\" \n    title=\"RTK Query Video course at Egghead: Course Introduction and Application Walk through for RTK Query Basics\"\n    frameborder=\"0\" \n    allowfullscreen\n    style={{position:\"absolute\",top:0,left:0,width:\"100%\",height:\"100%\"}}\n  ></iframe>\n</div>\n```\n\n----------------------------------------\n\nTITLE: miniSerializeError Interface Definition\nDESCRIPTION: Type definition for the error serialization function used by createAsyncThunk, which converts Error objects into plain SerializedError objects.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/otherExports.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface SerializedError {\n  name?: string\n  message?: string\n  stack?: string\n  code?: string\n}\n\nexport function miniSerializeError(value: any): SerializedError {}\n```\n\n----------------------------------------\n\nTITLE: Polling Logic Implementation in JavaScript\nDESCRIPTION: Handles polling interval updates and initiates next polls based on query thunk action states. Manages both pending and fulfilled/rejected states with condition checks.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/internal/queryThunk.mdx#2025-04-17_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nif (\n  queryThunk.pending.match(action) ||\n  (queryThunk.rejected.match(action) && action.meta.condition)\n) {\n  updatePollingInterval(action.meta.arg, mwApi)\n}\nif (\n  queryThunk.fulfilled.match(action) ||\n  (queryThunk.rejected.match(action) && !action.meta.condition)\n) {\n  startNextPoll(action.meta.arg, mwApi)\n}\n```\n\n----------------------------------------\n\nTITLE: Type Predicates for Error Handling\nDESCRIPTION: Defines type predicates to safely narrow unknown error types to specific error interfaces.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage-with-typescript.mdx#2025-04-17_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { FetchBaseQueryError } from '@reduxjs/toolkit/query'\n\nexport function isFetchBaseQueryError(\n  error: unknown,\n): error is FetchBaseQueryError {\n  return typeof error === 'object' && error != null && 'status' in error\n}\n\nexport function isErrorWithMessage(\n  error: unknown,\n): error is { message: string } {\n  return (\n    typeof error === 'object' &&\n    error != null &&\n    'message' in error &&\n    typeof (error as any).message === 'string'\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using Typed Redux Hooks in React Components\nDESCRIPTION: Demonstrates how to use typed Redux hooks in a React component for type-safe state management.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/tutorials/typescript.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport React, { useState } from 'react'\n\nimport { useAppSelector, useAppDispatch } from 'app/hooks'\n\nimport { decrement, increment } from './counterSlice'\n\nexport function Counter() {\n  const count = useAppSelector((state) => state.counter.value)\n  const dispatch = useAppDispatch()\n\n  // omit rendering logic\n}\n```\n\n----------------------------------------\n\nTITLE: Traditional Immutable Todo Reducer\nDESCRIPTION: Example of a todo reducer using traditional immutable update patterns.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createReducer.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAction, createReducer } from '@reduxjs/toolkit'\n\ninterface Todo {\n  text: string\n  completed: boolean\n}\n\nconst addTodo = createAction<Todo>('todos/add')\nconst toggleTodo = createAction<number>('todos/toggle')\n\nconst todosReducer = createReducer([] as Todo[], (builder) => {\n  builder\n    .addCase(addTodo, (state, action) => {\n      const todo = action.payload\n      return [...state, todo]\n    })\n    .addCase(toggleTodo, (state, action) => {\n      const index = action.payload\n      const todo = state[index]\n      return [\n        ...state.slice(0, index),\n        { ...todo, completed: !todo.completed },\n        ...state.slice(index + 1),\n      ]\n    })\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Next.js App with Redux Example using pnpm\nDESCRIPTION: This command uses pnpm to create a new Next.js application with the Redux example template. It sets up a project named 'with-redux-app' using the 'with-redux' example.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/examples/publish-ci/next/README.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm create next-app --example with-redux with-redux-app\n```\n\n----------------------------------------\n\nTITLE: Embedding CodeSandbox Demo with React JSX\nDESCRIPTION: JSX code for embedding a CodeSandbox demo that showcases Redux Toolkit matchers. The iframe is configured with specific styling, permissions and sandbox attributes for security and proper display.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/matching-utilities.mdx#2025-04-17_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\n<iframe\n  src=\"https://codesandbox.io/embed/redux-toolkit-matchers-example-e765q?fontsize=14&hidenavigation=1&module=%2Fsrc%2Ffeatures%2Fcounter%2FcounterSlice.ts&theme=dark&runonclick=1\"\n  style={{\n    width: '100%',\n    height: '500px',\n    border: 0,\n    borderRadius: 4,\n    overflow: 'hidden',\n  }}\n  title=\"redux-toolkit-matchers-example\"\n  allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n  sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n></iframe>\n```\n\n----------------------------------------\n\nTITLE: Async/Await with unwrapResult\nDESCRIPTION: Using async/await syntax with unwrapResult utility for handling thunk results.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAsyncThunk.mdx#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { unwrapResult } from '@reduxjs/toolkit'\n\nconst onClick = async () => {\n  try {\n    const resultAction = await dispatch(fetchUserById(userId))\n    const originalPromiseResult = unwrapResult(resultAction)\n    // handle result here\n  } catch (rejectedValueOrSerializedError) {\n    // handle error here\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Query Substate Update Function\nDESCRIPTION: Utility function that updates a query substate if it exists for a given cache key. Takes the state, queryCacheKey and an update function as parameters.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/internal/buildSlice.mdx#2025-04-17_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction updateQuerySubstateIfExists(state, queryCacheKey, update) {\n  const substate = state[queryCacheKey]\n  if (substate) {\n    update(substate)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using WithTypes Helper for Pre-typed AsyncThunk Creation\nDESCRIPTION: Demonstrates using the withTypes helper to create pre-typed async thunks with common configuration options.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createSlice.mdx#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nreducers: (create) => {\n  const createAThunk = create.asyncThunk.withTypes<{\n    rejectValue: { error: string }\n  }>()\n\n  return {\n    fetchTodo: createAThunk<Todo, string>(async (id, thunkApi) => {\n      throw thunkApi.rejectWithValue({\n        error: 'Oh no!',\n      })\n    }),\n    fetchTodos: createAThunk<Todo[], string>(async (id, thunkApi) => {\n      throw thunkApi.rejectWithValue({\n        error: 'Oh no, not again!',\n      })\n    }),\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Per-Route State in Redux with Next.js App Router\nDESCRIPTION: This snippet illustrates how to manage per-route state in Redux when using Next.js App Router. It initializes the store with product data on each route change to ensure correct data is displayed.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/usage/nextjs.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n'use client'\nimport { useRef } from 'react'\nimport { useAppSelector, useAppDispatch, useAppStore } from '../lib/hooks'\nimport {\n  initializeProduct,\n  setProductName,\n  Product,\n} from '../lib/features/product/productSlice'\n\nexport default function ProductName({ product }: { product: Product }) {\n  const store = useAppStore()\n  const initialized = useRef(false)\n  if (!initialized.current) {\n    store.dispatch(initializeProduct(product))\n    initialized.current = true\n  }\n  const name = useAppSelector((state) => state.product.name)\n  const dispatch = useAppDispatch()\n\n  return (\n    <input\n      value={name}\n      onChange={(e) => dispatch(setProductName(e.target.value))}\n    />\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Redux Provider with React\nDESCRIPTION: Wraps the React application with Redux Provider to make the store available throughout the component tree.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/tutorials/rtk-query.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as React from 'react'\nimport { createRoot } from 'react-dom/client'\nimport { Provider } from 'react-redux'\n\nimport App from './App'\nimport { store } from './store'\n\nconst container = document.getElementById('root')\n\nif (container) {\n  const root = createRoot(container)\n\n  root.render(\n    <Provider store={store}>\n      <App />\n    </Provider>,\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Building Static Content for Redux Toolkit Website (Bash)\nDESCRIPTION: Generates static content for the Redux Toolkit website into the 'build' directory, ready for hosting on any static content service.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/website/README.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn build\n```\n\n----------------------------------------\n\nTITLE: Running RTK Codemods with npx\nDESCRIPTION: Examples of how to execute Redux Toolkit codemods using npx to transform files in specific directories or matching glob patterns. The commands show how to run createReducerBuilder and createSliceBuilder transforms.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/codemods.mdx#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx @reduxjs/rtk-codemods createReducerBuilder ./src\n\nnpx @reduxjs/rtk-codemods createSliceBuilder ./packages/my-app/**/*.ts\n```\n\n----------------------------------------\n\nTITLE: Building Redux Toolkit Packages - Bash\nDESCRIPTION: Command to build all packages in the Redux Toolkit project using Yarn.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/CONTRIBUTING.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn build\n```\n\n----------------------------------------\n\nTITLE: Implementing RTK Query in Svelte\nDESCRIPTION: This example demonstrates how to use RTK Query in a Svelte application.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/examples.mdx#2025-04-17_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// Example code not provided in the original text\n```\n\n----------------------------------------\n\nTITLE: Defining API Types and Interfaces in TypeScript for Redux Toolkit\nDESCRIPTION: This code snippet defines various types and interfaces used in the Redux Toolkit API. It includes definitions for Api, ApiModules, BaseQueryEnhancer, BaseQueryFn, and other related types.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/toolkit/etc/rtk-query.api.md#2025-04-17_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { ActionCreatorWithoutPayload } from '@reduxjs/toolkit'\nimport type { UnknownAction } from '@reduxjs/toolkit'\nimport type { SerializedError } from '@reduxjs/toolkit'\nimport type { ThunkDispatch } from '@reduxjs/toolkit'\n\n// @public (undocumented)\nexport type Api<\n  BaseQuery extends BaseQueryFn,\n  Definitions extends EndpointDefinitions,\n  ReducerPath extends string,\n  TagTypes extends string,\n  Enhancers extends ModuleName = CoreModule,\n> = UnionToIntersection<\n  ApiModules<BaseQuery, Definitions, ReducerPath, TagTypes>[Enhancers]\n> & {\n  injectEndpoints<NewDefinitions extends EndpointDefinitions>(_: {\n    endpoints: (\n      build: EndpointBuilder<BaseQuery, TagTypes, ReducerPath>,\n    ) => NewDefinitions\n    overrideExisting?: boolean\n  }): Api<\n    BaseQuery,\n    Definitions & NewDefinitions,\n    ReducerPath,\n    TagTypes,\n    Enhancers\n  >\n  enhanceEndpoints<NewTagTypes extends string = never>(_: {\n    addTagTypes?: readonly NewTagTypes[]\n    endpoints?: ReplaceTagTypes<\n      Definitions,\n      TagTypes | NoInfer<NewTagTypes>\n    > extends infer NewDefinitions\n      ? {\n          [K in keyof NewDefinitions]?:\n            | Partial<NewDefinitions[K]>\n            | ((definition: NewDefinitions[K]) => void)\n        }\n      : never\n  }): Api<\n    BaseQuery,\n    ReplaceTagTypes<Definitions, TagTypes | NewTagTypes>,\n    ReducerPath,\n    TagTypes | NewTagTypes,\n    Enhancers\n  >\n}\n\n// @public (undocumented)\nexport interface ApiModules<\n  BaseQuery extends BaseQueryFn,\n  Definitions extends EndpointDefinitions,\n  ReducerPath extends string,\n  TagTypes extends string,\n> {}\n\n// @public (undocumented)\nexport type BaseQueryEnhancer<\n  AdditionalArgs = unknown,\n  AdditionalDefinitionExtraOptions = unknown,\n  Config = void,\n> = <BaseQuery extends BaseQueryFn>(\n  baseQuery: BaseQuery,\n  config: Config,\n) => BaseQueryFn<\n  BaseQueryArg<BaseQuery> & AdditionalArgs,\n  BaseQueryResult<BaseQuery>,\n  BaseQueryError<BaseQuery>,\n  BaseQueryExtraOptions<BaseQuery> & AdditionalDefinitionExtraOptions\n>\n\n// @public (undocumented)\nexport type BaseQueryFn<\n  Args = any,\n  Result = unknown,\n  Error = unknown,\n  DefinitionExtraOptions = {\n    copyWithStructuralSharing?: boolean\n  },\n  Meta = {},\n> = (\n  args: Args,\n  api: BaseQueryApi,\n  extraOptions: DefinitionExtraOptions,\n) => MaybePromise<QueryReturnValue<Result, Error, Meta>>\n```\n\n----------------------------------------\n\nTITLE: RTK Query Reducer Type Definition\nDESCRIPTION: Type definition for the reducer function that handles cached data updates in the Redux store\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/redux-integration.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nreducer: Reducer\n```\n\n----------------------------------------\n\nTITLE: Combining Default and Custom Enhancers\nDESCRIPTION: Shows how to use getDefaultEnhancers to combine default enhancers with custom ones.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/getDefaultEnhancers.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configureStore } from '@reduxjs/toolkit'\nimport { offline } from '@redux-offline/redux-offline'\nimport offlineConfig from '@redux-offline/redux-offline/lib/defaults'\n\nimport rootReducer from './reducer'\n\nconst store = configureStore({\n  reducer: rootReducer,\n  enhancers: (getDefaultEnhancers) =>\n    getDefaultEnhancers().concat(offline(offlineConfig)),\n})\n```\n\n----------------------------------------\n\nTITLE: Basic configureStore Usage with Default Enhancers\nDESCRIPTION: Shows the basic usage of configureStore where default enhancers are automatically added.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/getDefaultEnhancers.mdx#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst store = configureStore({\n  reducer: rootReducer,\n})\n\n// Store has enhancers added, because the enhancer list was not customized\n```\n\n----------------------------------------\n\nTITLE: Traditional Redux Action Definition - TypeScript\nDESCRIPTION: Traditional way of defining Redux actions using separate type constant and action creator function\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createAction.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst INCREMENT = 'counter/increment'\n\nfunction increment(amount: number) {\n  return {\n    type: INCREMENT,\n    payload: amount,\n  }\n}\n\nconst action = increment(3)\n// { type: 'counter/increment', payload: 3 }\n```\n\n----------------------------------------\n\nTITLE: TypeScript createSlice Transformation Example\nDESCRIPTION: Example showing the transformation of TypeScript createSlice code from object syntax to builder callback syntax. Includes type annotations and handles multiple slice definitions.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/rtk-codemods/transforms/createSliceBuilder/README.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst slice1 = createSlice({\n  name: 'a',\n  initialState,\n  extraReducers: {\n    [todoAdded]: (state: SliceState, action: PayloadAction<string>) => {\n      // stuff\n    }\n  }\n})\n\nconst slice2 = createSlice({\n  name: 'b',\n  initialState,\n  extraReducers: {\n    [todoAdded](state: SliceState, action: PayloadAction<string>) {\n      // stuff\n    }\n  }\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst slice1 = createSlice({\n  name: 'a',\n  initialState,\n\n  extraReducers: (builder) => {\n    builder.addCase(\n      todoAdded,\n      (state: SliceState, action: PayloadAction<string>) => {\n        // stuff\n      }\n    )\n  }\n})\n\nconst slice2 = createSlice({\n  name: 'b',\n  initialState,\n\n  extraReducers: (builder) => {\n    builder.addCase(\n      todoAdded,\n      (state: SliceState, action: PayloadAction<string>) => {\n        // stuff\n      }\n    )\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Running Redux Toolkit Tests - Bash\nDESCRIPTION: Commands for running tests, including options for running all tests once or in watch mode for continuous testing during development.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/CONTRIBUTING.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn test\n\nyarn test --watch\n```\n\n----------------------------------------\n\nTITLE: Starting Metro Server for React Native\nDESCRIPTION: These commands start the Metro bundler, which is required for running a React Native application. The commands are provided for both npm and Yarn package managers.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/examples/publish-ci/react-native/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# using npm\nnpm start\n```\n\nLANGUAGE: bash\nCODE:\n```\n# OR using Yarn\nyarn start\n```\n\n----------------------------------------\n\nTITLE: Using createSerializableStateInvariantMiddleware with Immutable.js\nDESCRIPTION: Example showing how to create and configure a custom serializable state invariant middleware that considers Immutable.js iterables as serializable values. Uses custom isSerializable and getEntries functions.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/serializabilityMiddleware.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Iterable } from 'immutable'\nimport {\n  configureStore,\n  createSerializableStateInvariantMiddleware,\n  isPlain,\n  Tuple,\n} from '@reduxjs/toolkit'\nimport reducer from './reducer'\n\n// Augment middleware to consider Immutable.JS iterables serializable\nconst isSerializable = (value: any) =>\n  Iterable.isIterable(value) || isPlain(value)\n\nconst getEntries = (value: any) =>\n  Iterable.isIterable(value) ? value.entries() : Object.entries(value)\n\nconst serializableMiddleware = createSerializableStateInvariantMiddleware({\n  isSerializable,\n  getEntries,\n})\n\nconst store = configureStore({\n  reducer,\n  middleware: () => new Tuple(serializableMiddleware),\n})\n```\n\n----------------------------------------\n\nTITLE: Importing RTK Query API Entry Points\nDESCRIPTION: Shows the two main entry points for importing RTK Query's createApi function - the core version and React-specific version.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/overview.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi } from '@reduxjs/toolkit/query'\n\n/* React-specific entry point that automatically generates\n   hooks corresponding to the defined endpoints */\nimport { createApi } from '@reduxjs/toolkit/query/react'\n```\n\n----------------------------------------\n\nTITLE: Customizing Default Enhancers\nDESCRIPTION: Demonstrates how to customize the default enhancers by passing options to getDefaultEnhancers.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/getDefaultEnhancers.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport rootReducer from './reducer'\nimport { configureStore } from '@reduxjs/toolkit'\n\nconst store = configureStore({\n  reducer: rootReducer,\n  enhancers: (getDefaultEnhancers) =>\n    getDefaultEnhancers({\n      autoBatch: { type: 'tick' },\n    }),\n})\n```\n\n----------------------------------------\n\nTITLE: Using selector with combineSlices in Redux Toolkit\nDESCRIPTION: Shows how to use the selector method to handle possibly undefined state for injected reducers, ensuring that any currently injected reducers evaluate to their initial state if undefined.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/combineSlices.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare module '.' {\n  export interface LazyLoadedSlices extends WithSlice<typeof counterSlice> {}\n}\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: { value: 0 },\n  reducers: {\n    /* ... */\n  },\n})\n\nconst withCounter = rootReducer.inject(counterSlice)\n\nconst selectCounterValue = (rootState: RootState) => rootState.counter?.value // number | undefined\n\nconst wrappedSelectCounterValue = withCounter.selector(\n  (rootState) => rootState.counter.value, // number\n)\n\nconsole.log(\n  selectCounterValue({}), // undefined\n  selectCounterValue({ counter: { value: 2 } }), // 2\n  wrappedSelectCounterValue({}), // 0\n  wrappedSelectCounterValue({ counter: { value: 2 } }), // 2\n)\n```\n\n----------------------------------------\n\nTITLE: TypeScript Reducer Transformation\nDESCRIPTION: Example of transforming TypeScript Redux reducers from object syntax to builder callback syntax while preserving type annotations.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/rtk-codemods/transforms/createReducerBuilder/README.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ncreateReducer(initialState, {\n  [todoAdded]: (state: SliceState, action: PayloadAction<string>) => {\n    // stuff\n  }\n})\n\ncreateReducer(initialState, {\n  [todoAdded](state: SliceState, action: PayloadAction<string>) {\n    // stuff\n  }\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\ncreateReducer(initialState, (builder) => {\n  builder.addCase(\n    todoAdded,\n    (state: SliceState, action: PayloadAction<string>) => {\n      // stuff\n    }\n  )\n})\n\ncreateReducer(initialState, (builder) => {\n  builder.addCase(\n    todoAdded,\n    (state: SliceState, action: PayloadAction<string>) => {\n      // stuff\n    }\n  )\n})\n```\n\n----------------------------------------\n\nTITLE: Installing and Running createSliceReducerBuilder Codemod via NPX\nDESCRIPTION: This snippet demonstrates how to install and run the createSliceReducerBuilder codemod using NPX. It transforms specified files or globs to use the builder callback syntax in Redux Toolkit's createSlice API.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/rtk-codemods/transforms/createSliceReducerBuilder/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx @reduxjs/rtk-codemods createSliceReducerBuilder path/of/files/ or/some**/*glob.js\n```\n\n----------------------------------------\n\nTITLE: Local CLI Usage for createSliceBuilder\nDESCRIPTION: Command for running the createSliceBuilder codemod locally using Node.js.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/rtk-codemods/transforms/createSliceBuilder/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnode ./bin/cli.mjs createSliceBuilder path/of/files/ or/some**/*glob.js\n```\n\n----------------------------------------\n\nTITLE: Local CLI Execution\nDESCRIPTION: Command for running the codemod transformation locally using Node.js.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/rtk-codemods/transforms/createReducerBuilder/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnode ./bin/cli.mjs createReducerBuilder path/of/files/ or/some**/*glob.js\n```\n\n----------------------------------------\n\nTITLE: Deploying Redux Toolkit Website to GitHub Pages (Bash)\nDESCRIPTION: Builds the Redux Toolkit website and deploys it to the 'gh-pages' branch on GitHub. Requires setting the GitHub username and using SSH for authentication.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/website/README.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ GIT_USER=<Your GitHub username> USE_SSH=1 yarn deploy\n```\n\n----------------------------------------\n\nTITLE: Using prepareAutoBatched with createSlice\nDESCRIPTION: Demonstrates how to use the prepareAutoBatched utility with createSlice's prepare callback syntax to mark specific actions for batching.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/autoBatchEnhancer.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ncreateSlice({\n  name: 'todos',\n  initialState,\n  reducers: {\n    todoAdded: {\n      reducer(state, action: PayloadAction<Todo>) {\n        state.push(action.payload)\n      },\n      // highlight-start\n      prepare: prepareAutoBatched<Todo>(),\n      // highlight-end\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Filtering Endpoints in OpenAPI Generator Configuration\nDESCRIPTION: Demonstrates how to filter specific endpoints for inclusion in the generated API. The example shows filtering by explicit name and by regular expression pattern.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/code-generation.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst filteredConfig: ConfigFile = {\n  // ...\n  // should only have endpoints loginUser, placeOrder, getOrderById, deleteOrder\n  filterEndpoints: ['loginUser', /Order/],\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Slice Reducers to Redux Store\nDESCRIPTION: Imports the counter reducer and adds it to the Redux store configuration.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/tutorials/quick-start.mdx#2025-04-17_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport { configureStore } from '@reduxjs/toolkit'\nimport counterReducer from '../features/counter/counterSlice'\n\nexport const store = configureStore({\n  reducer: {\n    counter: counterReducer,\n  },\n})\n\nexport type RootState = ReturnType<typeof store.getState>\nexport type AppDispatch = typeof store.dispatch\n```\n\n----------------------------------------\n\nTITLE: Redux Toolkit Code Before Migration\nDESCRIPTION: Example of Redux Toolkit code that uses the deprecated object syntax for createReducer and createSlice.extraReducers, which will be removed in RTK 2.0.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/codemods.mdx#2025-04-17_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\ncreateReducer(initialState, {\n  [todoAdded1a]: (state, action) => {\n    // stuff\n  },\n  [todoAdded1b]: (state, action) => action.payload,\n})\n\nconst slice1 = createSlice({\n  name: 'a',\n  initialState: {},\n  extraReducers: {\n    [todoAdded1a]: (state, action) => {\n      // stuff\n    },\n    [todoAdded1b]: (state, action) => action.payload,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Updating Store Configuration for RTK Query in TypeScript\nDESCRIPTION: Demonstrates how to update the Redux store configuration by removing the Pokemon slice reducer and keeping only the RTK Query API reducer. Also shows middleware setup for RTK Query.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/migrating-to-rtk-query.mdx#2025-04-17_snippet_10\n\nLANGUAGE: diff\nCODE:\n```\n  import { configureStore } from '@reduxjs/toolkit'\n- import { pokemonSlice } from './services/pokemonSlice'\n  import { api } from './services/api'\n\n\n  export const store = configureStore({\n    reducer: {\n-     pokemon: pokemonSlice.reducer,\n      [api.reducerPath]: api.reducer,\n    },\n    middleware: (gDM) => gDM().concat(api.middleware),\n  })\n\n  export type RootState = ReturnType<typeof store.getState>\n```\n\n----------------------------------------\n\nTITLE: Installing and Running createSliceReducerBuilder Codemod via Yarn\nDESCRIPTION: This snippet shows how to globally install the codemod package using Yarn and then run the createSliceReducerBuilder transformation on specified files or globs.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/rtk-codemods/transforms/createSliceReducerBuilder/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn global add @reduxjs/rtk-codemods\n@reduxjs/rtk-codemods createSliceReducerBuilder path/of/files/ or/some**/*glob.js\n```\n\n----------------------------------------\n\nTITLE: Running RTK Codemods Locally\nDESCRIPTION: Command for running Redux Toolkit codemods directly from a local installation using Node.js CLI interface.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/rtk-codemods/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnode ./bin/cli.mjs <TRANSFORM NAME> path/of/files/ or/some**/*glob.js\n```\n\n----------------------------------------\n\nTITLE: Running React Development Server\nDESCRIPTION: Starts the React application in development mode, allowing for live reloading and displaying lint errors in the console.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/examples/publish-ci/cra5/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm start\n```\n\n----------------------------------------\n\nTITLE: Defining SerializableStateInvariantMiddleware Options Interface in TypeScript\nDESCRIPTION: TypeScript interface that defines the configuration options for the serializability middleware, including how to customize serialization checks, ignore specific actions or paths, and set warning thresholds.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/serializabilityMiddleware.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SerializableStateInvariantMiddlewareOptions {\n  /**\n   * The function to check if a value is considered serializable. This\n   * function is applied recursively to every value contained in the\n   * state. Defaults to `isPlain()`.\n   */\n  isSerializable?: (value: any) => boolean\n  /**\n   * The function that will be used to retrieve entries from each\n   * value.  If unspecified, `Object.entries` will be used. Defaults\n   * to `undefined`.\n   */\n  getEntries?: (value: any) => [string, any][]\n\n  /**\n   * An array of action types to ignore when checking for serializability.\n   * Defaults to []\n   */\n  ignoredActions?: string[]\n\n  /**\n   * An array of dot-separated path strings or regular expressions to ignore\n   * when checking for serializability, Defaults to\n   * ['meta.arg', 'meta.baseQueryMeta']\n   */\n  ignoredActionPaths?: (string | RegExp)[]\n\n  /**\n   * An array of dot-separated path strings or regular expressions to ignore\n   * when checking for serializability, Defaults to []\n   */\n  ignoredPaths?: (string | RegExp)[]\n  /**\n   * Execution time warning threshold. If the middleware takes longer\n   * than `warnAfter` ms, a warning will be displayed in the console.\n   * Defaults to 32ms.\n   */\n  warnAfter?: number\n\n  /**\n   * Opt out of checking state. When set to `true`, other state-related params will be ignored.\n   */\n  ignoreState?: boolean\n\n  /**\n   * Opt out of checking actions. When set to `true`, other action-related params will be ignored.\n   */\n  ignoreActions?: boolean\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Parameters in OpenAPI Generator with Regex\nDESCRIPTION: Demonstrates how to filter parameters included in an endpoint using a regular expression. This example only includes parameters that begin with 'x-' for the 'loginUser' endpoint.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/code-generation.mdx#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst withOverride: ConfigFile = {\n  // ...\n  endpointOverrides: [\n    {\n      pattern: 'loginUser',\n      parameterFilter: /^x-/,\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: RTK Query ReducerPath Type Definition\nDESCRIPTION: Type definition for the reducerPath property used to specify the root state key for the API slice reducer\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/redux-integration.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nreducerPath: string\n```\n\n----------------------------------------\n\nTITLE: Configuring Robot Exclusion Protocol for All User Agents\nDESCRIPTION: This snippet configures the robots.txt file to allow all user agents full access to the website. It specifies no restrictions on crawling or indexing.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/examples/publish-ci/cra4/public/robots.txt#2025-04-17_snippet_0\n\nLANGUAGE: robotstxt\nCODE:\n```\nUser-agent: *\nDisallow:\n```\n\n----------------------------------------\n\nTITLE: Overriding Endpoint Types in OpenAPI Generator\nDESCRIPTION: Shows how to override the generated endpoint type (query/mutation) for specific endpoints. This is useful when the OpenAPI specification doesn't clearly indicate the correct type.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/code-generation.mdx#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst withOverride: ConfigFile = {\n  // ...\n  endpointOverrides: [\n    {\n      pattern: 'loginUser',\n      type: 'mutation',\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Web Crawler Permissions in robots.txt\nDESCRIPTION: Basic robots.txt configuration that allows all web crawlers (*) to access all site content. Includes reference to robotstxt.org specification for standards.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/examples/publish-ci/cra5/public/robots.txt#2025-04-17_snippet_0\n\nLANGUAGE: robotstxt\nCODE:\n```\nUser-agent: *\nDisallow:\n```\n\n----------------------------------------\n\nTITLE: Running React Native App on Android\nDESCRIPTION: These commands start the React Native application on an Android device or emulator. The commands are provided for both npm and Yarn package managers.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/examples/publish-ci/react-native/README.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# using npm\nnpm run android\n```\n\nLANGUAGE: bash\nCODE:\n```\n# OR using Yarn\nyarn android\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Output Files in OpenAPI Generator\nDESCRIPTION: Demonstrates how to generate multiple output files based on endpoint filtering. This allows organizing generated API code into logical groupings (users, orders, pets).\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/code-generation.mdx#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst config: ConfigFile = {\n  schemaFile: 'https://petstore3.swagger.io/api/v3/openapi.json',\n  apiFile: './src/store/emptyApi.ts',\n  outputFiles: {\n    './src/store/user.ts': {\n      filterEndpoints: [/user/i],\n    },\n    './src/store/order.ts': {\n      filterEndpoints: [/order/i],\n    },\n    './src/store/pet.ts': {\n      filterEndpoints: [/pet/i],\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: JavaScript Reducer Transformation\nDESCRIPTION: Example of transforming JavaScript Redux reducers from object syntax to builder callback syntax, handling various reducer function syntaxes.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/rtk-codemods/transforms/createReducerBuilder/README.md#2025-04-17_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\ncreateReducer(initialState, {\n  [todoAdded1a]: (state, action) => {\n    // stuff\n  },\n  [todoAdded1b]: (state, action) => action.payload,\n  [todoAdded1c + 'test']: (state, action) => {\n    // stuff\n  },\n  [todoAdded1d](state, action) {\n    // stuff\n  },\n  [todoAdded1e]: function (state, action) {\n    // stuff\n  },\n  todoAdded1f: (state, action) => {\n    //stuff\n  }\n})\n\ncreateReducer(initialState, {\n  [todoAdded2a]: (state, action) => {\n    // stuff\n  },\n  [todoAdded2b](state, action) {\n    // stuff\n  },\n  [todoAdded2c]: function (state, action) {\n    // stuff\n  }\n})\n```\n\nLANGUAGE: javascript\nCODE:\n```\ncreateReducer(initialState, (builder) => {\n  builder.addCase(todoAdded1a, (state, action) => {\n    // stuff\n  })\n\n  builder.addCase(todoAdded1b, (state, action) => action.payload)\n\n  builder.addCase(todoAdded1c + 'test', (state, action) => {\n    // stuff\n  })\n\n  builder.addCase(todoAdded1d, (state, action) => {\n    // stuff\n  })\n\n  builder.addCase(todoAdded1e, (state, action) => {\n    // stuff\n  })\n\n  builder.addCase(todoAdded1f, (state, action) => {\n    //stuff\n  })\n})\n\ncreateReducer(initialState, (builder) => {\n  builder.addCase(todoAdded2a, (state, action) => {\n    // stuff\n  })\n\n  builder.addCase(todoAdded2b, (state, action) => {\n    // stuff\n  })\n\n  builder.addCase(todoAdded2c, (state, action) => {\n    // stuff\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Working with Type Limitations in Pre-Typed Selectors\nDESCRIPTION: Example showing how to work around known type inference limitations with pre-typed selectors, including using array syntax for input selectors or manually annotating parameter types when necessary.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/createSelector.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSelector } from 'reselect'\n\ninterface Todo {\n  id: number\n  completed: boolean\n}\n\ninterface Alert {\n  id: number\n  read: boolean\n}\n\nexport interface RootState {\n  todos: Todo[]\n  alerts: Alert[]\n}\n\nexport const createTypedDraftSafeSelector =\n  createDraftSafeSelector.withTypes<RootState>()\n\nconst selectTodoIds = createTypedDraftSafeSelector(\n  // Type of `state` is set to `RootState`, no need to manually set the type\n  (state) => state.todos,\n  //  Known limitation: Parameter types are not inferred in this scenario\n  // so you will have to manually annotate them.\n  (todos: Todo[]) => todos.map(({ id }) => id),\n)\n```\n\n----------------------------------------\n\nTITLE: Starting Local Development Server for Redux Toolkit Website (Bash)\nDESCRIPTION: Starts a local development server for the Redux Toolkit website, opening a browser window. Changes are reflected live without server restart.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/website/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn start\n```\n\n----------------------------------------\n\nTITLE: Ejecting from Create React App Configuration\nDESCRIPTION: Command to eject from Create React App configuration. This exposes all configuration files and dependencies for custom configuration but is irreversible.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/examples/publish-ci/cra4/README.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm run eject\n```\n\n----------------------------------------\n\nTITLE: Defining Select Function Signatures in TypeScript\nDESCRIPTION: This snippet defines the types for the select function, including CreateCacheSelectorFactory, QueryResultSelectorFactory, and MutationResultSelectorFactory.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/endpoints.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ntype CreateCacheSelectorFactory =\n  | QueryResultSelectorFactory\n  | MutationResultSelectorFactory\n\ntype QueryResultSelectorFactory = (\n  queryArg: QueryArg | SkipToken,\n) => (state: RootState) => QueryResultSelectorResult<Definition>\n\ntype MutationResultSelectorFactory<\n  Definition extends MutationDefinition<any, any, any, any>,\n  RootState,\n> = (\n  requestId: string | SkipToken,\n) => (state: RootState) => MutationSubState<Definition> & RequestStatusFlags\n\ntype SkipToken = typeof Symbol\n```\n\n----------------------------------------\n\nTITLE: Running createSliceReducerBuilder Codemod Locally\nDESCRIPTION: This snippet demonstrates how to run the createSliceReducerBuilder codemod locally using Node.js. It assumes the codemod package is already installed in the current directory.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/rtk-codemods/transforms/createSliceReducerBuilder/README.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnode ./bin/cli.mjs createSliceReducerBuilder path/of/files/ or/some**/*glob.js\n```\n\n----------------------------------------\n\nTITLE: Running React Test Suite\nDESCRIPTION: Launches the test runner in interactive watch mode for running and monitoring tests in the React application.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/examples/publish-ci/cra5/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm test\n```\n\n----------------------------------------\n\nTITLE: Creating Next.js App with Redux Example using npx\nDESCRIPTION: This command uses npx to create a new Next.js application with the Redux example template. It sets up a project named 'with-redux-app' using the 'with-redux' example.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/examples/publish-ci/next/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-next-app --example with-redux with-redux-app\n```\n\n----------------------------------------\n\nTITLE: Changelog Format Declaration in Markdown\nDESCRIPTION: Markdown content defining the changelog format and structure, including version headers and change descriptions for RTK Query Code Generator updates.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/rtk-query-codegen-openapi/ChangeLog.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Changelog\n\nAll notable changes to the `RTK Query - Code Generator` for `Open API` project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/), and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## 1.2.0 - 2023-11-09\n\nThis version adds a new `mergeReadWriteOnly` configuration option (default to `false`) that, when set to `true` will not generate separate types for read-only and write-only properties.\n\n## 1.1.3 - 2023-10-11\n\n### Added\n\n- Adds a temporary workaround for [4.9.0 and 4.10.0 generate circular types oazapfts/oazapfts#491](https://github.com/oazapfts/oazapfts/issues/491)\n\n## 1.1.2 - 2023-10-11\n\n### Added\n\n- Support for Read Only Properties in the Open API spec. Previously, this property was ignored.\n  - Now if the readOnly property is present and set to `true` in a schema, it will split the type into two types: one with the read only property suffixed as 'Read' and the other without the read only properties, using the same type name as before.\n  - This may cause issues if you had your OpenAPI spec properly typed/configured, as it will remove the read onyl types from your existing type. You will need to switch to the new type suffixed as 'Read' to avoid missing property names.\n\n## 1.1.1 - 2023-10-11\n\n### Changed\n\n- Codegen: better handling of duplicate param names ([Codegen: better handling of duplicate param names #3780](https://github.com/reduxjs/redux-toolkit/pull/3780))\n  - If a parameter name is both used in a query and a parameter, it will be prefixed with `query`/`param` now to avoid conflicts\n\n## 1.1.0 - 2023-10-11\n\n### Added\n\n- Option of generating real TS enums instead of string unions [Adds the option of generating real TS enums instead of string unions #2854](https://github.com/reduxjs/redux-toolkit/pull/2854)\n- Compatibility with TypeScript 5.x versions as the codegen relies on the TypeScript AST for code generation\n  - As a result also needs a higher TypeScript version to work with (old version range was 4.1-4.5)\n- Changes depenendcy from a temporarily patched old version of `oazapfts` back to the current upstream version\n```\n\n----------------------------------------\n\nTITLE: Running Queries/Mutations Thunk Signatures in TypeScript\nDESCRIPTION: Type definitions for thunks that retrieve running queries and mutations.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/api-slice-utils.mdx#2025-04-17_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\ngetRunningQueriesThunk(): ThunkWithReturnValue<Array<QueryActionCreatorResult<any>>>\ngetRunningMutationsThunk(): ThunkWithReturnValue<Array<MutationActionCreatorResult<any>>>\n```\n\n----------------------------------------\n\nTITLE: Embedding YouTube Video with React Component in Markdown\nDESCRIPTION: This code snippet demonstrates how to embed a YouTube video using a React component within a Markdown file. It uses the 'react-lite-youtube-embed' package to create a lightweight YouTube embed.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/tutorials/overview.md#2025-04-17_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n<LiteYouTubeEmbed \n    id=\"9zySeP5vH9c\"\n    title=\"Learn Modern Redux - Redux Toolkit, React-Redux Hooks, and RTK Query\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Ejecting from Create React App\nDESCRIPTION: Removes the single build dependency and copies all configuration files into the project for full control. This is a one-way operation and cannot be reversed.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/examples/publish-ci/cra5/README.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm run eject\n```\n\n----------------------------------------\n\nTITLE: RTK Query Cache Demo Sandbox Embed\nDESCRIPTION: React iframe component configuration for embedding a CodeSandbox demo showing cache subscription lifetime behavior in RTK Query.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/cache-behavior.mdx#2025-04-17_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\n<iframe\n  src=\"https://codesandbox.io/embed/rtk-query-cache-subscription-lifetime-example-77tn4?fontsize=12&runonclick=1&hidenavigation=1&theme=dark&module=%2Fsrc%2Fservice%2Findex.ts\"\n  style={{\n    width: '100%',\n    height: '800px',\n    border: 0,\n    borderRadius: '4px',\n    overflow: 'hidden',\n  }}\n  title=\"rtk-query-cache-subscription-lifetime-example\"\n  allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\"\n  sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"\n></iframe>\n```\n\n----------------------------------------\n\nTITLE: SelectInvalidatedBy Function Signature in TypeScript\nDESCRIPTION: Type definition for selectInvalidatedBy utility that selects query parameters to be invalidated.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/created-api/api-slice-utils.mdx#2025-04-17_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nfunction selectInvalidatedBy(\n  state: RootState,\n  tags: ReadonlyArray<TagDescription<string>>,\n): Array<{\n  endpointName: string\n  originalArgs: any\n  queryCacheKey: QueryCacheKey\n}>\n```\n\n----------------------------------------\n\nTITLE: getDefaultEnhancers TypeScript Interface\nDESCRIPTION: Type definitions for the getDefaultEnhancers function and its options.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/getDefaultEnhancers.mdx#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ninterface AutoBatchOptions {\n  // see \"autoBatchEnhancer\" page for options\n}\n\ninterface GetDefaultEnhancersOptions {\n  autoBatch?: boolean | AutoBatchOptions\n}\n\nfunction getDefaultEnhancers<M extends Middlewares<any>>(\n  options: GetDefaultEnhancersOptions = {},\n): EnhancerArray<[StoreEnhancer<{ dispatch: ExtractDispatchExtensions<M> }>]>\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Redux Toolkit Website (Bash)\nDESCRIPTION: Installs the necessary dependencies for the Redux Toolkit website using Yarn package manager.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/website/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn\n```\n\n----------------------------------------\n\nTITLE: Removing Legacy Files After RTK Query Migration\nDESCRIPTION: Shows the removal of legacy Pokemon slice and hooks files that are no longer needed after migrating to RTK Query.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/migrating-to-rtk-query.mdx#2025-04-17_snippet_11\n\nLANGUAGE: diff\nCODE:\n```\n- src/services/pokemonSlice.ts (-51 lines)\n- src/hooks.ts (-34 lines)\n```\n\n----------------------------------------\n\nTITLE: RTK Query Middleware Handlers\nDESCRIPTION: Documents the middleware handlers used by RTK Query for managing cache, invalidation, polling, and lifecycle events.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/internal/overview.mdx#2025-04-17_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n- `buildDevCheckHandler`\n- `buildCacheCollectionHandler`\n- `buildInvalidationByTagsHandler`\n- `buildPollingHandler`\n- `buildCacheLifecycleHandler`\n- `buildQueryLifecycleHandler`\n```\n\n----------------------------------------\n\nTITLE: Default Enhancers Array\nDESCRIPTION: Shows the default enhancers that are included in the return value.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/getDefaultEnhancers.mdx#2025-04-17_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst enhancers = [applyMiddleware, autoBatchEnhancer]\n```\n\n----------------------------------------\n\nTITLE: RTK Query Overview Section\nDESCRIPTION: Explains that RTK Query is a data fetching and caching tool built on Redux Toolkit, providing the foundational context for the architecture documentation.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/internal/overview.mdx#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n> RTK Query is a powerful data fetching and caching tool built on top of Redux Toolkit. It is designed to simplify the process of fetching, caching, and updating server state in your application. It is built on top of Redux Toolkit and uses Redux internally.\n```\n\n----------------------------------------\n\nTITLE: Configuring Embedded CodeSandbox iFrame in React\nDESCRIPTION: React component code for embedding a CodeSandbox demonstration of RTK Query's advanced features, including styling configuration and security settings.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/tutorials/rtk-query.mdx#2025-04-17_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\n<iframe\n  src=\"https://codesandbox.io/embed/github/reduxjs/redux-toolkit/tree/master/examples/query/react/advanced?file=/src/App.tsx?fontsize=12&runonclick=1&hidenavigation=1&theme=dark\"\n  style={{\n    width: '100%',\n    height: '600px',\n    border: 0,\n    borderRadius: '4px',\n    overflow: 'hidden',\n  }}\n  title=\"rtk-query-getting-started-advanced\"\n  allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\"\n  sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"\n></iframe>\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Schema Transformation in Redux Toolkit Query\nDESCRIPTION: This snippet illustrates an incorrect approach to schema validation where transformation changes the type of a value. It's shown as an example of what not to do when implementing schema validation in Redux Toolkit Query.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage-with-typescript.mdx#2025-04-17_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport * as v from 'valibot'\nimport { titleCase } from 'lodash'\n\nconst postSchema = v.object({\n  id: v.number(),\n  name: v.pipe(\n    v.string(),\n    v.transform(titleCase), // fine - string -> string\n  ),\n  published_at: v.pipe(\n    v.string(),\n    // highlight-next-line\n    v.transform((s) => new Date(s)), // not allowed!\n    v.date(),\n  ),\n})\ntype Post = v.InferOutput<typeof postSchema>\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getPost: build.query<Post, { id: number }>({\n      query: ({ id }) => `/post/${id}`,\n      responseSchema: postSchema,\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Installing and Running createSliceBuilder Codemod\nDESCRIPTION: Commands for installing and running the createSliceBuilder codemod using npm or yarn. Allows processing single files or glob patterns.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/packages/rtk-codemods/transforms/createSliceBuilder/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx @reduxjs/rtk-codemods createSliceBuilder path/of/files/ or/some**/*glob.js\n\n# or\n\nyarn global add @reduxjs/rtk-codemods\nrtk-codemods createSliceBuilder path/of/files/ or/some**/*glob.js\n```\n\n----------------------------------------\n\nTITLE: Embedding RTK Query ApiProvider Demo\nDESCRIPTION: An iframe element that embeds a CodeSandbox example demonstrating the usage of ApiProvider component from Redux Toolkit Query. The example is set with specific styling and security parameters.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/ApiProvider.mdx#2025-04-17_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<iframe\n  src=\"https://codesandbox.io/embed/github/reduxjs/redux-toolkit/tree/master/examples/query/react/with-apiprovider?fontsize=12&runonclick=1&hidenavigation=1&module=%2Fsrc%2FApp.tsx&theme=dark\"\n  style={{\n    width: '100%',\n    height: '800px',\n    border: 0,\n    borderRadius: '4px',\n    overflow: 'hidden',\n  }}\n  title=\"RTK Query ApiProvider\"\n  allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\"\n  sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"\n></iframe>\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Action Creator Middleware in Redux Toolkit\nDESCRIPTION: Example showing how to create and configure a custom action creator middleware with a custom isActionCreator function. This demonstrates integrating the middleware with configureStore.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/actionCreatorMiddleware.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// file: reducer.ts noEmit\n\nexport default function (state = {}, action: any) {\n  return state\n}\n\n// file: store.ts\n\nimport {\n  configureStore,\n  createActionCreatorInvariantMiddleware,\n  Tuple,\n} from '@reduxjs/toolkit'\nimport reducer from './reducer'\n\n// Augment middleware to consider all functions with a static type property to be action creators\nconst isActionCreator = (\n  action: unknown,\n): action is Function & { type: unknown } =>\n  typeof action === 'function' && 'type' in action\n\nconst actionCreatorMiddleware = createActionCreatorInvariantMiddleware({\n  isActionCreator,\n})\n\nconst store = configureStore({\n  reducer,\n  middleware: () => new Tuple(actionCreatorMiddleware),\n})\n```\n\n----------------------------------------\n\nTITLE: Endpoint Request Options Interface for fetchBaseQuery\nDESCRIPTION: The type definition for endpoint-specific request options, including URL, params, body, responseHandler, validateStatus, and timeout configurations.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/fetchBaseQuery.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ninterface FetchArgs extends RequestInit {\n  url: string\n  params?: Record<string, any>\n  body?: any\n  responseHandler?:\n    | 'json'\n    | 'text'\n    | `content-type`\n    | ((response: Response) => Promise<any>)\n  validateStatus?: (response: Response, body: any) => boolean\n  timeout?: number\n}\n\nconst defaultValidateStatus = (response: Response) =>\n  response.status >= 200 && response.status <= 299\n```\n\n----------------------------------------\n\nTITLE: Implementing Mutation Cache Key Generation\nDESCRIPTION: Function to determine the cache key for mutations. Prioritizes fixed cache keys over request IDs and handles different input parameter structures.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/internal/buildSlice.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport function getMutationCacheKey(\n  id:\n    | { fixedCacheKey?: string; requestId?: string }\n    | MutationSubstateIdentifier\n    | { requestId: string; arg: { fixedCacheKey?: string | undefined } },\n): string | undefined {\n  return ('arg' in id ? id.arg.fixedCacheKey : id.fixedCacheKey) ?? id.requestId\n}\n```\n\n----------------------------------------\n\nTITLE: Unsubscribing from Cached Data in RTK Query\nDESCRIPTION: Shows how to remove a cache subscription by calling the unsubscribe function returned from the initiate thunk action creator. This is important for cleaning up old cache data.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/usage-without-react-hooks.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Adding a cache subscription\nconst promise = dispatch(api.endpoints.getPosts.initiate())\n\n// Removing the corresponding cache subscription\npromise.unsubscribe()\n```\n\n----------------------------------------\n\nTITLE: Creating Next.js App with Redux Example using Yarn\nDESCRIPTION: This command uses Yarn to create a new Next.js application with the Redux example template. It sets up a project named 'with-redux-app' using the 'with-redux' example.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/examples/publish-ci/next/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn create next-app --example with-redux with-redux-app\n```\n\n----------------------------------------\n\nTITLE: Triggering a Mutation Endpoint in RTK Query\nDESCRIPTION: Shows how to perform a mutation by dispatching the initiate thunk action creator of a mutation endpoint, used for updating data on the server.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/usage-without-react-hooks.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndispatch(api.endpoints.addPost.initiate({ name: 'foo' }))\n```\n\n----------------------------------------\n\nTITLE: Defining ResponseHandler Types in TypeScript\nDESCRIPTION: Defines the possible types for the responseHandler field in fetchBaseQuery, including predefined string options and a custom function type.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/api/fetchBaseQuery.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ntype ResponseHandler =\n  | 'content-type'\n  | 'json'\n  | 'text'\n  | ((response: Response) => Promise<any>)\n```\n\n----------------------------------------\n\nTITLE: prepareAutoBatched Type Definition\nDESCRIPTION: Shows the TypeScript type definition for the prepareAutoBatched utility function, which creates a prepare callback for createSlice that marks actions for batching.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/api/autoBatchEnhancer.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ntype prepareAutoBatched = <T>() => (payload: T) => { payload: T; meta: unknown }\n```\n\n----------------------------------------\n\nTITLE: Using extraReducers for Authentication in RTK Query\nDESCRIPTION: This example showcases an alternative approach to handling authentication in RTK Query using a matcher from the endpoint and extraReducers in the authSlice.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/docs/rtk-query/usage/examples.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Example code not provided in the original text\n```\n\n----------------------------------------\n\nTITLE: Starting Development Server in React Redux App\nDESCRIPTION: Command to run the application in development mode. Opens the app at http://localhost:3000 with hot reload functionality.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/examples/publish-ci/cra4/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm start\n```\n\n----------------------------------------\n\nTITLE: Running Tests in React Redux App\nDESCRIPTION: Command to launch the test runner in interactive watch mode for running unit tests.\nSOURCE: https://github.com/reduxjs/redux-toolkit/blob/master/examples/publish-ci/cra4/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm test\n```"
  }
]