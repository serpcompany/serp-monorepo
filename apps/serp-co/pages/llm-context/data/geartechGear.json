[
  {
    "owner": "gear-tech",
    "repo": "gear",
    "content": "TITLE: Creating and uploading a new gear program in shell\nDESCRIPTION: Demonstrates creating a new Gear program and uploading it to the staging testnet. This process involves cloning a repository, building the program with cargo, and deploying it via the gcli tool.\nSOURCE: https://github.com/gear-tech/gear/blob/master/gcli/README.md#2025-04-22_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n$ gear new hello-world\nCloning into '/home/clearloop/.gear/apps'...\nremote: Enumerating objects: 156, done.\nremote: Counting objects: 100% (156/156), done.\nremote: Compressing objects: 100% (121/121), done.\nremote: Total 156 (delta 41), reused 83 (delta 15), pack-reused 0\nReceiving objects: 100% (156/156), 89.78 KiB | 723.00 KiB/s, done.\nResolving deltas: 100% (41/41), done.\nSuccessfully created registry at /home/clearloop/.gear/apps!\nSuccessfully created hello-world!\n```\n\n----------------------------------------\n\nTITLE: Uploading a gear program via gcli in shell\nDESCRIPTION: Uploads a compiled Gear program to the network using the gcli tool. This involves executing the upload command, which interacts with the Gear node to submit and verify the smart contract deployment.\nSOURCE: https://github.com/gear-tech/gear/blob/master/gcli/README.md#2025-04-22_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\n$ gear upload hello-world/target/wasm32-gear/release/hello_world.wasm\n[INFO ] Submitted extrinsic Gear::upload_code\n[INFO ]         Status: Ready\n[INFO ]         Status: Broadcast( [\"12D3KooWQbJXFeRDJqmLT6jqahsJpwKGL5xEJJ6F3tevR1R85Upz\", ...]\n[INFO ]         Status: InBlock( block_hash: 0x4409…fa04, extrinsic_hash: 0x2c54…e9d9 )\n[INFO ]         Status: Finalized( block_hash: 0x4409…fa04, extrinsic_hash: 0x2c54…e9d9 )\n[INFO ] Successfully submitted call Gear::upload_code 0x2c54…e9d9 at 0x4409…fa04!\n[INFO ]         Balance spent: 3724868714\n```\n\n----------------------------------------\n\nTITLE: Testing Userspace Panic Signal Handling in Rust\nDESCRIPTION: Test implementation for verifying correct handling of userspace panic signals. The test uploads a program, triggers a panic scenario, and verifies the correct signal handling and gas management behavior.\nSOURCE: https://github.com/gear-tech/gear/blob/master/core-errors/signal-code-testing.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nconst USER_1: AccountId = 1;\nconst DEFAULT_SALT: &[u8; 4] = b\"salt\";\nconst GAS_LIMIT: u64 = 10_000_000_000;\n\n#[test]\nfn test_userspace_panic_works() {\n    use demo_signal_panic::{WASM_BINARY};\n\n    // Upload program\n    assert_ok!(Gear::upload_program(\n        RuntimeOrigin::signed(USER_1),\n        WASM_BINARY.to_vec(),\n        DEFAULT_SALT.to_vec(),\n        0.encode(),\n        GAS_LIMIT,\n        0,\n    ));\n\n    let pid = get_last_program_id();\n\n    run_to_next_block(None);\n\n    // Ensure that program is uploaded and initialized correctly\n    assert!(Gear::is_active(pid));\n    assert!(Gear::is_initialized(pid));\n\n\n    // Send the message to trigger signal sending\n    assert_ok!(Gear::send_message(\n        RuntimeOrigin::signed(USER_1),\n        pid,\n        [].into(),\n        GAS_LIMIT,\n        0,\n        false,\n    ));\n\n    run_to_next_block(None);\n\n    let mid = get_last_message_id();\n\n    // Assert that system reserve gas node is removed\n    assert_ok!(GasHandlerOf::<Test>::get_system_reserve(mid));\n    run_to_next_block(None);\n    assert!(GasHandlerOf::<Test>::get_system_reserve(mid).is_err());\n\n    // Ensure that signal code sent is signal code we saved\n    let mail_msg = get_last_mail(USER_1);\n    assert_eq!(mail_msg.payload_bytes(), true.encode());\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Gas Limit Exceeded Signal Handling\nDESCRIPTION: This test case validates the proper handling of the gas limit exceeded signal in the Gear platform using Rust. It tests uploading a WebAssembly binary, initializing a program, sending messages, and verifying the correct signal handling behavior. It ensures the program is correctly deployed, initialized, and responds to out-of-gas conditions.\nSOURCE: https://github.com/gear-tech/gear/blob/master/core-errors/signal-code-testing.md#2025-04-22_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nconst USER_1: AccountId = 1;\nconst DEFAULT_SALT: &[u8; 4] = b\"salt\";\nconst GAS_LIMIT: u64 = 10_000_000_000;\n\n#[test]\nfn test_signal_run_out_of_gas_works() {\n    use demo_signal_run_out_of_gas::{WASM_BINARY};\n\n    // Upload program\n    assert_ok!(Gear::upload_program(\n        RuntimeOrigin::signed(USER_1),\n        WASM_BINARY.to_vec(),\n        DEFAULT_SALT.to_vec(),\n        0.encode(),\n        GAS_LIMIT,\n        0,\n    ));\n\n    let pid = get_last_program_id();\n\n    run_to_next_block(None);\n\n    // Ensure that program is uploaded and initialized correctly\n    assert!(Gear::is_active(pid));\n    assert!(Gear::is_initialized(pid));\n\n    // Send the message to trigger signal sending\n    assert_ok!(Gear::send_message(\n        RuntimeOrigin::signed(USER_1),\n        pid,\n        [].into(),\n        GAS_LIMIT,\n        0,\n        false,\n    ));\n\n    run_to_next_block(None);\n\n    let mid = get_last_message_id();\n\n    // Assert that system reserve gas node is removed\n    assert_ok!(GasHandlerOf::<Test>::get_system_reserve(mid));\n    run_to_next_block(None);\n    assert!(GasHandlerOf::<Test>::get_system_reserve(mid).is_err());\n\n    // Ensure that signal code sent is signal code we saved\n    let mail_msg = get_last_mail(USER_1);\n    assert_eq!(mail_msg.payload_bytes(), true.encode());\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Transactions with GSDK Signer in Rust\nDESCRIPTION: Demonstrates how to create a signer connection to a gear network node, execute a transfer transaction, and fetch associated events. The example shows connecting to a default WebSocket endpoint and performing a keep-alive transfer operation.\nSOURCE: https://github.com/gear-tech/gear/blob/master/gsdk/README.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse gsdk::signer::Signer;\n\n#[tokio::main]\nasync fn main() {\n    // Connect to \"wss://rpc-node.gear-tech.io:443\" by default.\n    let signer = Api::new(None).signer(\"//Alice\", None);\n\n    // Transaction with block details.\n    let tx = signer.transfer_keep_alive(\"//Bob\", 42).await.expect(\"Transfer value failed.\");\n\n    // Fetch all of the events associated with this transaction.\n    for events in tx.fetch_events().await {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building Gear Node\nDESCRIPTION: Command to build the Gear node in production mode using Cargo.\nSOURCE: https://github.com/gear-tech/gear/blob/master/ansible/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo build --profile production\n```\n\n----------------------------------------\n\nTITLE: Running a Dev Node\nDESCRIPTION: Commands to run a local development Gear node, with an option to specify the chain database location.\nSOURCE: https://github.com/gear-tech/gear/blob/master/node/README.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ngear --dev\n\n# Specifying database location\ngear --dev --base-path /tmp/vara\n```\n\n----------------------------------------\n\nTITLE: Connecting to Vara Mainnet\nDESCRIPTION: Command to run a node that syncs with the Vara mainnet.\nSOURCE: https://github.com/gear-tech/gear/blob/master/node/README.md#2025-04-22_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ngear --chain=vara\n```\n\n----------------------------------------\n\nTITLE: Connecting to Vara Testnet\nDESCRIPTION: Command to connect to the default Vara testnet.\nSOURCE: https://github.com/gear-tech/gear/blob/master/node/README.md#2025-04-22_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\ngear\n```\n\n----------------------------------------\n\nTITLE: Running Multi-Node Local Vara Network (Bob Node)\nDESCRIPTION: Command to start the 'bob' node in a multi-node local Vara network setup, connecting to the 'alice' node.\nSOURCE: https://github.com/gear-tech/gear/blob/master/node/README.md#2025-04-22_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ngear \\\n  --bob \\\n  --chain=local \\\n  --base-path ./tmp/bob \\\n  --port 30334 \\\n  --rpc-port 9945 \\\n  --bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWMar4rG4kfoCZA1sqaY8FqtPDgpBPfDnQ7Md9x6Sdkgw5\n  --validator\n```\n\n----------------------------------------\n\nTITLE: Running Vara Dev Network Node\nDESCRIPTION: Command to start a single-node Vara Dev network with two pre-configured users (Alice and Bob) for development purposes.\nSOURCE: https://github.com/gear-tech/gear/blob/master/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngear --dev\n```\n\n----------------------------------------\n\nTITLE: Live Chain Replay Examples\nDESCRIPTION: Examples of replaying blocks on a live chain using both block hash and block number.\nSOURCE: https://github.com/gear-tech/gear/blob/master/utils/gear-replay-cli/README.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngear-replay-cli -lgear,syscalls,pallet replay-block live -u wss://archive-rpc.vara.network:443 -b 0x8dc1e32576c1ad4e28dc141769576efdbc19d0170d427b69edb2261cfc36e905\ngear-replay-cli -lgear,syscalls,pallet replay-block --force-run live -u wss://archive-rpc.vara.network:443 -b 2000000\n```\n\n----------------------------------------\n\nTITLE: Running an Archive Node\nDESCRIPTION: Command to run an archive node, which stores all historical data with specified state pruning.\nSOURCE: https://github.com/gear-tech/gear/blob/master/node/README.md#2025-04-22_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ngear --chain=vara --blocks-pruning=archive --state-pruning=512\n```\n\n----------------------------------------\n\nTITLE: Running Runtime Fuzzer Commands\nDESCRIPTION: Commands for setting up and running the runtime fuzzer with specific configurations. Includes creating a corpus directory, generating seed data, and executing the fuzzer with debug logging enabled.\nSOURCE: https://github.com/gear-tech/gear/blob/master/utils/runtime-fuzzer/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd utils/runtime-fuzzer\n\nmkdir -p fuzz/corpus/main\ndd if=/dev/urandom of=fuzz/corpus/main/fuzzer-seed-corpus bs=1 count=350000\n\nRUST_LOG=debug,syscalls,runtime::sandbox=trace,gear_wasm_gen=trace,runtime_fuzzer=trace,gear_core_backend=trace \\\ncargo fuzz run \\\n    --release \\\n    --sanitizer=none \\\n    main \\\n    fuzz/corpus/main \\\n    -- \\\n        -rss_limit_mb=8192 \\\n        -max_len=450000 \\\n        -len_control=0\n\ncargo fuzz coverage \\\n    --release \\\n    --sanitizer=none \\\n    main \\\n    fuzz/corpus/main \\\n    -- \\\n        -rss_limit_mb=8192 \\\n        -max_len=450000 \\\n        -len_control=0\n```\n\n----------------------------------------\n\nTITLE: Running Multi-Node Local Vara Network (Alice Node)\nDESCRIPTION: Command to start the 'alice' node in a multi-node local Vara network setup.\nSOURCE: https://github.com/gear-tech/gear/blob/master/node/README.md#2025-04-22_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ngear --alice --chain=local --base-path ./tmp/alice --port 30333 --rpc-port 9944 --validator\n```\n\n----------------------------------------\n\nTITLE: Using Codec Module in Gear Programs\nDESCRIPTION: Reference to the codec module that enables retrieval of actual errors instead of ExtError::Some errors in Gear programs.\nSOURCE: https://github.com/gear-tech/gear/blob/master/gcore/README.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n`codec` - Allows you to get actual errors occurred instead of `ExtError::Some` one.\n```\n\n----------------------------------------\n\nTITLE: Logging into a gear account using gcli in shell\nDESCRIPTION: Logs into a Gear account using the gcli tool, allowing for further interactions with the Gear node. The command requires a valid account identifier.\nSOURCE: https://github.com/gear-tech/gear/blob/master/gcli/README.md#2025-04-22_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n$ gear login //Alice\nSuccessfully logged in as 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY!\n```\n\n----------------------------------------\n\nTITLE: Compiling a gear program via cargo in shell\nDESCRIPTION: Uses cargo to compile the Gear program into a WebAssembly binary for deployment. The manifest-path option specifies the location of the program's configuration file, and the release flag ensures an optimized build.\nSOURCE: https://github.com/gear-tech/gear/blob/master/gcli/README.md#2025-04-22_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n$ cargo build --manifest-path hello-world/Cargo.toml --release\n```\n\n----------------------------------------\n\nTITLE: Processing a Wasm File with wasm-proc (Shell)\nDESCRIPTION: This command demonstrates the basic usage of the `wasm-proc` tool after installation. It takes a Wasm file (e.g., `somefile.wasm`) as input and processes it, generating two output files in the same directory: `somefile.opt.wasm` (optimized for node execution) and `somefile.meta.wasm` (for UI metadata). Requires the `wasm-proc` tool to be installed and accessible in the system's PATH.\nSOURCE: https://github.com/gear-tech/gear/blob/master/utils/wasm-proc/README.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nwasm_proc somefile.wasm\n```\n\n----------------------------------------\n\nTITLE: Snapshot Replay Example Command\nDESCRIPTION: Example command for replaying a block using a state snapshot as the source.\nSOURCE: https://github.com/gear-tech/gear/blob/master/utils/gear-replay-cli/README.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngear-replay-cli -lgear,syscalls,pallet replay-block -f --block-ws-uri wss://archive-rpc.vara.network:443 snap -p ./vara-1200@1999999 -b 2000000\n```\n\n----------------------------------------\n\nTITLE: Running Gear Node with Custom Chain Spec\nDESCRIPTION: Command to start a Gear node with a custom chain specification file and base path configuration.\nSOURCE: https://github.com/gear-tech/gear/blob/master/ansible/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./target/release/gear \\\n  --base-path /tmp/data \\\n  --chain=chain_spec.json \\\n  ...\n```\n\n----------------------------------------\n\nTITLE: Initial Chain Specification Structure\nDESCRIPTION: Example of the raw chain specification JSON structure showing the basic configuration and genesis state.\nSOURCE: https://github.com/gear-tech/gear/blob/master/ansible/README.md#2025-04-22_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"Gear Staging Testnet V4\",\n  \"id\": \"gear_staging_testnet_v4\",\n  \"chainType\": \"Live\",\n  \"bootNodes\": [],\n  \"telemetryEndpoints\": null,\n  \"protocolId\": null,\n  \"properties\": null,\n  \"consensusEngine\": null,\n  \"codeSubstitutes\": {},\n  \"genesis\": {\n    \"raw\": {\n      \"top\": {\n        \"0xd5e1a2fa16732ce6906189438c0a82c64e7b9012096b41c4eb3aaf947f6ea429\": \"0x0000\",\n        \"0x57f8dc2f5ab09467896f47300f0424384e7b9012096b41c4eb3aaf947f6ea429\": \"0x0000\",\n        \"0x3f1467a096bcd71a5b6a0c8155e208104e7b9012096b41c4eb3aaf947f6ea429\": \"0x0000\",\n        \"0xbd2a529379475088d3e29a918cd478724e7b9012096b41c4eb3aaf947f6ea429\": \"0x0000\"\n      },\n      \"childrenDefault\": {}\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting to a Custom Chain\nDESCRIPTION: Command to connect to a custom chain using a provided chain specification JSON file.\nSOURCE: https://github.com/gear-tech/gear/blob/master/node/README.md#2025-04-22_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\ngear --chain=/path/to/your/chain/spec.json\n```\n\n----------------------------------------\n\nTITLE: Chain Specification with Bootnodes\nDESCRIPTION: Example of chain specification JSON with manually configured bootnode entries for the staging testnet validators.\nSOURCE: https://github.com/gear-tech/gear/blob/master/ansible/README.md#2025-04-22_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"Gear Staging Testnet V4\",\n  \"id\": \"gear_staging_testnet_v4\",\n  \"chainType\": \"Live\",\n  \"bootNodes\": [\n    \"/dns4/testnet-validator-node1.gear-tech.io/tcp/30333/p2p/12D3KooWBWFtZqigVTC8W2GRMwLeuTK2o4hDC4XHVPyNV6hW1T1D\",\n    \"/dns4/testnet-validator-node2.gear-tech.io/tcp/30333/p2p/12D3KooWRf7vAr79yAyDxGvYAdSqhh2EoeWe35Lx4QH4N6XMv2gH\",\n    \"/dns4/testnet-validator-node3.gear-tech.io/tcp/30333/p2p/12D3KooWEVvqVD2mrLfmgeX1EXZ2caFXXEWWEs4Taa4mWzFUoF34\",\n    \"/dns4/testnet-validator-node4.gear-tech.io/tcp/30333/p2p/12D3KooWSf2d69w7RYKtj9mgYpLDs3rqLAz9GHNSHHoCQDLUjeiP\"\n  ],\n  \"telemetryEndpoints\": null,\n  \"protocolId\": null,\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Gear WASM Build Script\nDESCRIPTION: Simple build.rs script that uses gear-wasm-builder to compile the project to WASM.\nSOURCE: https://github.com/gear-tech/gear/blob/master/utils/wasm-builder/README.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    gear_wasm_builder::build();\n}\n```\n\n----------------------------------------\n\nTITLE: Generating LCOV Coverage Report\nDESCRIPTION: Commands to generate an LCOV format coverage report for use with VS Code Coverage Gutters extension. Exports coverage data while excluding rustc and cargo related files.\nSOURCE: https://github.com/gear-tech/gear/blob/master/utils/runtime-fuzzer/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nHOST_TARGET=$(rustc -Vv | grep \"host: \" | sed \"s/^host: \\(.*\\)$/\\1/\")\ncargo cov -- export target/$HOST_TARGET/coverage/$HOST_TARGET/release/main \\\n    --format=lcov \\\n    --instr-profile=fuzz/coverage/main/coverage.profdata \\\n    --ignore-filename-regex=/rustc/ \\\n    --ignore-filename-regex=.cargo/ > fuzz/coverage/main/lcov.info\n```\n\n----------------------------------------\n\nTITLE: Building the Gear Node\nDESCRIPTION: Command to build the Gear node in release mode using make.\nSOURCE: https://github.com/gear-tech/gear/blob/master/node/README.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nmake node-release\n```\n\n----------------------------------------\n\nTITLE: Manually Triggering gsdk Metadata Generation\nDESCRIPTION: This command manually triggers the gsdk metadata generation process using Cargo. It's useful for understanding the build process or troubleshooting issues with code generation.\nSOURCE: https://github.com/gear-tech/gear/blob/master/gsdk/HOW-TO-UPDATE.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nGSDK_API_GEN=1 cargo build --package gsdk\n```\n\n----------------------------------------\n\nTITLE: Testing UnrecoverableExt Error with wait_up_to(0) in Gear Protocol\nDESCRIPTION: Test code for verifying that a backend error signal is properly sent when a program calls wait_up_to with 0 as a parameter. It uploads the program, triggers the error, and verifies the signal was received correctly.\nSOURCE: https://github.com/gear-tech/gear/blob/master/core-errors/signal-code-testing.md#2025-04-22_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nconst USER_1: AccountId = 1;\nconst DEFAULT_SALT: &[u8; 4] = b\"salt\";\nconst GAS_LIMIT: u64 = 10_000_000_000;\n\n#[test]\nfn test_signal_backend_error_unrecoverable_ext_works() {\n    use demo_signal_backend_error_unrecoverable_ext::{WASM_BINARY};\n\n    // Upload program\n    assert_ok!(Gear::upload_program(\n        RuntimeOrigin::signed(USER_1),\n        WASM_BINARY.to_vec(),\n        DEFAULT_SALT.to_vec(),\n        0.encode(),\n        GAS_LIMIT,\n        0,\n    ));\n\n    let pid = get_last_program_id();\n\n    run_to_next_block(None);\n\n    // Ensure that program is uploaded and initialized correctly\n    assert!(Gear::is_active(pid));\n    assert!(Gear::is_initialized(pid));\n\n    // Send the message to trigger signal sending\n    assert_ok!(Gear::send_message(\n        RuntimeOrigin::signed(USER_1),\n        pid,\n        [].into(),\n        GAS_LIMIT,\n        0,\n        false,\n    ));\n\n    run_to_next_block(None);\n\n    let mid = get_last_message_id();\n\n    // Assert that system reserve gas node is removed\n    assert_ok!(GasHandlerOf::<Test>::get_system_reserve(mid));\n    run_to_next_block(None);\n\n\n```\n\n----------------------------------------\n\nTITLE: Installing gcli via cargo in shell\nDESCRIPTION: Installs the gcli tool from the Gear repository using the cargo package manager. This command is necessary to set up the gear CLI environment for deploying and managing programs on the Gear protocol.\nSOURCE: https://github.com/gear-tech/gear/blob/master/gcli/README.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ cargo install --git https://github.com/gear-tech/gear gcli\n```\n\n----------------------------------------\n\nTITLE: Testing Memory Overflow Signal with OOM Panic in Rust\nDESCRIPTION: A Rust program designed to test the memory overflow signal by directly calling the oom_panic syscall. The program includes initialization, message handling, and signal handling functions to verify correct signal code reception.\nSOURCE: https://github.com/gear-tech/gear/blob/master/core-errors/signal-code-testing.md#2025-04-22_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n#![no_std]\n\nuse gstd:{\n    ActorId,\n    errors::{SignalCode, SimpleExecutionError},\n    exec,\n    ext::oom_panic,\n    prelude::*,\n    msg,\n};\n\nstatic mut INITIATOR: ActorId = ActorId::zero();\n\n#[unsafe(no_mangle)]\nextern \"C\" fn init() {\n    unsafe { INITIATOR = msg::source() };\n}\n\n#[unsafe(no_mangle)]\nextern \"C\" fn handle() {\n    exec::system_reserve_gas(1_000_000_000).unwrap();\n\n    oom_panic();\n}\n\n#[unsafe(no_mangle)]\nextern \"C\" fn handle_signal() {\n    let signal_received = msg::signal_code()\n        .expect(\"Incorrect call\")\n        .expect(\"Unsupported code\");\n\n    if signal_received == SignalCode::Execution(SimpleExecutionError::MemoryOverflow) {\n        msg::send(unsafe { INITIATOR }, true, 0).unwrap();\n    } else {\n        msg::send(unsafe { INITIATOR }, false, 0).unwrap();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Unreachable Instruction Signal with Incorrect Free in Rust\nDESCRIPTION: A Rust program that tests the unreachable instruction signal by calling the free syscall with an invalid page number. The program uses extern \"C\" to directly call the free function with usize::MAX as the invalid page number.\nSOURCE: https://github.com/gear-tech/gear/blob/master/core-errors/signal-code-testing.md#2025-04-22_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n#![no_std]\n\nuse gstd:{\n    ActorId,\n    errors::{SignalCode, SimpleExecutionError},\n    exec,\n    prelude::*,\n    msg,\n};\n\nstatic mut INITIATOR: ActorId = ActorId::zero();\n\nextern \"C\" {\n    fn free(ptr: *mut u8) -> *mut u8;\n}\n\n#[unsafe(no_mangle)]\nextern \"C\" fn init() {\n    unsafe { INITIATOR = msg::source() };\n}\n\n#[unsafe(no_mangle)]\nextern \"C\" fn handle() {\n    exec::system_reserve_gas(1_000_000_000).unwrap();\n\n    unsafe {\n        free(usize::MAX as *mut u8);\n    }\n}\n\n#[unsafe(no_mangle)]\nextern \"C\" fn handle_signal() {\n    let signal_received = msg::signal_code()\n        .expect(\"Incorrect call\")\n        .expect(\"Unsupported code\");\n\n    if signal_received == SignalCode::Execution(SimpleExecutionError::UnreachableInstruction) {\n        msg::send(unsafe { INITIATOR }, true, 0).unwrap();\n    } else {\n        msg::send(unsafe { INITIATOR }, false, 0).unwrap();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Create Snapshot Example Command\nDESCRIPTION: Example command for creating a state snapshot at a specific block.\nSOURCE: https://github.com/gear-tech/gear/blob/master/utils/gear-replay-cli/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngear-replay-cli create-snapshot --uri wss://archive-rpc.vara.network:443 -b 1999999\n```\n\n----------------------------------------\n\nTITLE: Testing Unreachable Instruction Signal with WASM Unreachable in Rust\nDESCRIPTION: A Rust program that tests the unreachable instruction signal by directly calling the WASM unreachable instruction. This program demonstrates how to trigger an unreachable instruction trap different from Rust's unreachable!() macro.\nSOURCE: https://github.com/gear-tech/gear/blob/master/core-errors/signal-code-testing.md#2025-04-22_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\n#![no_std]\n\nuse gstd:{\n    ActorId,\n    errors::{SignalCode, SimpleExecutionError},\n    exec,\n    prelude::*,\n    msg,\n};\n\nstatic mut INITIATOR: ActorId = ActorId::zero();\n\n#[unsafe(no_mangle)]\nextern \"C\" fn init() {\n    unsafe { INITIATOR = msg::source() };\n}\n\n#[unsafe(no_mangle)]\nextern \"C\" fn handle() {\n    exec::system_reserve_gas(1_000_000_000).unwrap();\n\n    #[cfg(target_arch = \"wasm32\")]\n    core::arch::wasm32::unreachable();\n}\n\n#[unsafe(no_mangle)]\nextern \"C\" fn handle_signal() {\n    let signal_received = msg::signal_code()\n        .expect(\"Incorrect call\")\n        .expect(\"Unsupported code\");\n\n    if signal_received == SignalCode::Execution(SimpleExecutionError::UnreachableInstruction) {\n        msg::send(unsafe { INITIATOR }, true, 0).unwrap();\n    } else {\n        msg::send(unsafe { INITIATOR }, false, 0).unwrap();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Local Ethereum Node with Anvil\nDESCRIPTION: Command to start a local Ethereum node using Anvil\nSOURCE: https://github.com/gear-tech/gear/blob/master/ethexe/contracts/README.md#2025-04-22_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ anvil\n```\n\n----------------------------------------\n\nTITLE: Cargo Build Commands\nDESCRIPTION: Set of cargo commands to build and test the WASM project.\nSOURCE: https://github.com/gear-tech/gear/blob/master/utils/wasm-builder/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo clean\ncargo build\ncargo build --release\ncargo test\ncargo test --release\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml Dependencies\nDESCRIPTION: Configuration snippet showing how to add gear-wasm-builder as a build dependency in Cargo.toml file.\nSOURCE: https://github.com/gear-tech/gear/blob/master/utils/wasm-builder/README.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build-dependencies]\ngear-wasm-builder = \"0.1.2\"\n```\n\n----------------------------------------\n\nTITLE: Purging the Chain\nDESCRIPTION: Command to purge the chain state and blockstore, performing a complete clean-up.\nSOURCE: https://github.com/gear-tech/gear/blob/master/node/README.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ngear purge-chain --dev\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies on Ubuntu/Debian\nDESCRIPTION: Commands to install necessary dependencies for building the Gear node on Ubuntu or Debian systems.\nSOURCE: https://github.com/gear-tech/gear/blob/master/node/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt update\n# May prompt for location information\nsudo apt install -y git clang curl libssl-dev llvm libudev-dev cmake protobuf-compiler\n```\n\n----------------------------------------\n\nTITLE: Introducing gstd and gcore Libraries in Markdown\nDESCRIPTION: Documentation explaining the relationship between gstd (standard library) and gcore (low-level implementation) in Gear programs.\nSOURCE: https://github.com/gear-tech/gear/blob/master/gstd/README.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# gstd\n\nThe standard library for Gear programs provides all the necessary functions and methods required for your programs.\n\nWhile `gcore` allows for a more low-level implementation of programs, `gstd` offers pre-built modules enabling program implementation in a secure and precise manner, which is recommended for most scenarios.\n```\n\n----------------------------------------\n\nTITLE: Installing Rosetta on Apple Silicon\nDESCRIPTION: Command to install Rosetta on Apple Silicon (M1/M1 Pro/M1 Max) devices, which may be necessary for compatibility.\nSOURCE: https://github.com/gear-tech/gear/blob/master/node/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n/usr/sbin/softwareupdate --install-rosetta --agree-to-license\n```\n\n----------------------------------------\n\nTITLE: Running gcli command in shell\nDESCRIPTION: Demonstrates usage of the gcli command line tool, listing available commands and options. Users can interact with the Gear node by executing various subcommands related to program management and account handling.\nSOURCE: https://github.com/gear-tech/gear/blob/master/gcli/README.md#2025-04-22_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n$ gear\n`gear` client cli\n\nUsage: gcli [OPTIONS] <COMMAND>\n\nCommands:\n  claim           Claim value from mailbox\n  create          Deploy program to gear node\n  info            Get account info from ss58address\n  key             Keypair utils\n  login           Log in to account\n  new             Create a new gear program\n  program         Read program state, etc\n  reply           Sends a reply message\n  send            Sends a message to a program or to another account\n  upload          Saves program `code` in storage\n  upload-program  Deploy program to gear node\n  transfer        Transfer value\n  update          Update self from crates.io or github\n  help            Print this message or the help of the given subcommand(s)\n\nOptions:\n  -r, --retry <RETRY>        How many times we'll retry when RPC requests failed [default: 5]\n  -v, --verbose              Enable verbose logs\n  -e, --endpoint <ENDPOINT>  Gear node rpc endpoint\n  -p, --passwd <PASSWD>      Password of the signer account\n  -h, --help                 Print help\n```\n\n----------------------------------------\n\nTITLE: Basic CLI Usage Command Help\nDESCRIPTION: Shows the main command structure and available subcommands for the gear-replay-cli tool.\nSOURCE: https://github.com/gear-tech/gear/blob/master/utils/gear-replay-cli/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ gear-replay-cli -h\n  Commands of `gear-replay` CLI\n\n  Usage: gear-replay-cli [OPTIONS] <COMMAND>\n\n  Commands:\n    replay-block     Replay block subcommand\n    gear-run         GearRun subcommand\n    create-snapshot  Create a new snapshot file\n    help             Print this message or the help of the given subcommand(s)\n\n  Options:\n    -l, --log [<NODE_LOG>...]  Sets a custom logging filter. Syntax is `<target>=<level>`, e.g. -lsync=debug\n    -h, --help                 Print help (see more with '--help')\n```\n\n----------------------------------------\n\nTITLE: Installing wasm-proc Utility via Cargo (Shell)\nDESCRIPTION: This snippet provides the shell commands to install the `wasm-proc` utility. It requires navigating into the `utils/wasm-proc` directory of the checked-out repository and then using `cargo install --path ./` to build and install the tool locally. Assumes Rust and Cargo are installed and the Gear repository has been checked out.\nSOURCE: https://github.com/gear-tech/gear/blob/master/utils/wasm-proc/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncd utils/wasm-proc\ncargo install --path ./\n```\n\n----------------------------------------\n\nTITLE: Upgrading Smart Contracts with Forge\nDESCRIPTION: Commands to upgrade various smart contracts on Sepolia and Holesky testnets using Forge scripts\nSOURCE: https://github.com/gear-tech/gear/blob/master/ethexe/contracts/README.md#2025-04-22_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n$ source .env\n\n$ forge script upgrades/Mirror.s.sol:MirrorScript --slow --rpc-url $SEPOLIA_RPC_URL --broadcast --verify -vvvv\n$ forge script upgrades/Mirror.s.sol:MirrorScript --slow --rpc-url $HOLESKY_RPC_URL --broadcast --verify -vvvv\n\n$ forge script upgrades/Router.s.sol:RouterScript --slow --rpc-url $SEPOLIA_RPC_URL --broadcast --verify -vvvv\n$ forge script upgrades/Router.s.sol:RouterScript --slow --rpc-url $HOLESKY_RPC_URL --broadcast --verify -vvvv\n\n$ forge script upgrades/WrappedVara.s.sol:WrappedVaraScript --slow --rpc-url $SEPOLIA_RPC_URL --broadcast --verify -vvvv\n$ forge script upgrades/WrappedVara.s.sol:WrappedVaraScript --slow --rpc-url $HOLESKY_RPC_URL --broadcast --verify -vvvv\n```\n\n----------------------------------------\n\nTITLE: Deploying Smart Contracts with Forge\nDESCRIPTION: Commands to deploy smart contracts to Sepolia and Holesky testnets using Forge scripts\nSOURCE: https://github.com/gear-tech/gear/blob/master/ethexe/contracts/README.md#2025-04-22_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ source .env\n\n$ forge script script/Deployment.s.sol:DeploymentScript --slow --rpc-url $SEPOLIA_RPC_URL --broadcast --verify -vvvv\n$ forge script script/Deployment.s.sol:DeploymentScript --slow --rpc-url $HOLESKY_RPC_URL --broadcast --verify -vvvv\n\n$ forge script script/MirrorProxy.s.sol:MirrorProxyScript --slow --rpc-url $SEPOLIA_RPC_URL --broadcast --verify -vvvv\n$ forge script script/MirrorProxy.s.sol:MirrorProxyScript --slow --rpc-url $HOLESKY_RPC_URL --broadcast --verify -vvvv\n```\n\n----------------------------------------\n\nTITLE: Displaying Gear Node Help\nDESCRIPTION: Command to display the help information for the Gear node, showing available subcommands and options.\nSOURCE: https://github.com/gear-tech/gear/blob/master/node/README.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngear --help\n```\n\n----------------------------------------\n\nTITLE: Creating Gas Snapshots with Forge\nDESCRIPTION: Command to generate gas usage snapshots for smart contracts\nSOURCE: https://github.com/gear-tech/gear/blob/master/ethexe/contracts/README.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ forge snapshot\n```\n\n----------------------------------------\n\nTITLE: Accessing Help Documentation\nDESCRIPTION: Commands to access help documentation for Forge, Anvil and Cast tools\nSOURCE: https://github.com/gear-tech/gear/blob/master/ethexe/contracts/README.md#2025-04-22_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n$ forge --help\n$ anvil --help\n$ cast --help\n```\n\n----------------------------------------\n\nTITLE: Building Ethereum Contracts with Forge\nDESCRIPTION: Command to build Ethereum smart contracts using Forge\nSOURCE: https://github.com/gear-tech/gear/blob/master/ethexe/contracts/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ forge build\n```\n\n----------------------------------------\n\nTITLE: Testing Ethereum Contracts with Forge\nDESCRIPTION: Command to run tests for Ethereum smart contracts using Forge\nSOURCE: https://github.com/gear-tech/gear/blob/master/ethexe/contracts/README.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ forge test\n```\n\n----------------------------------------\n\nTITLE: Testing WASM Binary Integration\nDESCRIPTION: Example code showing how to include and test generated WASM binaries in Rust tests using the std feature flag.\nSOURCE: https://github.com/gear-tech/gear/blob/master/utils/wasm-builder/README.md#2025-04-22_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(feature = \"std\")]\nmod code {\n    include!(concat!(env!(\"OUT_DIR\"), \"/wasm_binary.rs\"));\n}\n\n#[test]\nfn debug_wasm() {\n    assert_eq!(\n        std::fs::read(\"target/wasm32-gear/debug/test_program.wasm\").unwrap(),\n        code::WASM_BINARY,\n    );\n    assert_eq!(\n        std::fs::read(\"target/wasm32-gear/debug/test_program.opt.wasm\").unwrap(),\n        code::WASM_BINARY_OPT,\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies on MacOS\nDESCRIPTION: Commands to install Homebrew and OpenSSL on MacOS, which are required for building the Gear node.\nSOURCE: https://github.com/gear-tech/gear/blob/master/node/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Install Homebrew if necessary https://brew.sh/\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"\n\n# Make sure Homebrew is up-to-date, install openssl\nbrew update\nbrew install openssl\n```\n\n----------------------------------------\n\nTITLE: Replay Block Command Help\nDESCRIPTION: Shows the help information for the replay-block subcommand, including options for replaying blocks from different sources.\nSOURCE: https://github.com/gear-tech/gear/blob/master/utils/gear-replay-cli/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ gear-replay-cli replay-block -h\n  Replay block subcommand\n\n  Usage: gear-replay-cli replay-block [OPTIONS] <COMMAND>\n\n  Commands:\n    snap  Use a state snapshot as the source of runtime state\n    live  Use a live chain as the source of runtime state\n    help  Print this message or the help of the given subcommand(s)\n\n  Options:\n        --block-ws-uri <BLOCK_WS_URI>  The ws uri from which to fetch the block\n    -f, --force-run                    Forces `Gear::run()` inherent to be placed in the block\n    -h, --help                         Print help (see more with '--help')\n```\n\n----------------------------------------\n\nTITLE: Using Cast Command Line Tool\nDESCRIPTION: Generic command structure for using Cast CLI tool for EVM interactions\nSOURCE: https://github.com/gear-tech/gear/blob/master/ethexe/contracts/README.md#2025-04-22_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n$ cast <subcommand>\n```\n\n----------------------------------------\n\nTITLE: Updating gsdk Metadata via Shell Script\nDESCRIPTION: This command runs a shell script to update the generated gsdk metadata code. It's the simplest way to refresh the metadata.\nSOURCE: https://github.com/gear-tech/gear/blob/master/gsdk/HOW-TO-UPDATE.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/update-gsdk-metadata.sh\n```\n\n----------------------------------------\n\nTITLE: Testing Gas Limit Exceeded on Memory Access Handling\nDESCRIPTION: This Rust test case verifies the handling of the gas limit exceeded signal during memory access on the Gear platform. It involves uploading a WebAssembly binary, initializing a program, calculating the necessary gas, and sending messages to ensure the expected out-of-gas behavior and proper signal reception.\nSOURCE: https://github.com/gear-tech/gear/blob/master/core-errors/signal-code-testing.md#2025-04-22_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nconst USER_1: AccountId = 1;\nconst DEFAULT_SALT: &[u8; 4] = b\"salt\";\nconst GAS_LIMIT: u64 = 10_000_000_000;\n\n#[test]\nfn test_signal_run_out_of_gas_memory_access_works() {\n    use demo_signal_run_out_of_gas_memory_access::{WASM_BINARY};\n\n    // Upload program\n    assert_ok!(Gear::upload_program(\n        RuntimeOrigin::signed(USER_1),\n        WASM_BINARY.to_vec(),\n        DEFAULT_SALT.to_vec(),\n        0.encode(),\n        GAS_LIMIT,\n        0,\n    ));\n\n    let pid = get_last_program_id();\n\n    run_to_next_block(None);\n\n    // Ensure that program is uploaded and initialized correctly\n    assert!(Gear::is_active(pid));\n    assert!(Gear::is_initialized(pid));\n\n    // Calculate gas for this action\n    let GasInfo { min_limit, .. } = Gear::calculate_gas_info(\n        USER_1.into_origin(),\n        HandleKind::Handle(pid),\n        [].into(),\n        0,\n        true,\n        true,\n    )\n    .expect(\"calculate_gas_info failed\");\n\n    // Send the message to trigger signal sending\n    assert_ok!(Gear::send_message(\n        RuntimeOrigin::signed(USER_1),\n        pid,\n        [].into(),\n        min_limit - 1,\n        0,\n        false,\n    ));\n\n    run_to_next_block(None);\n\n    let mid = get_last_message_id();\n\n    // Assert that system reserve gas node is removed\n    assert_ok!(GasHandlerOf::<Test>::get_system_reserve(mid));\n    run_to_next_block(None);\n    assert!(GasHandlerOf::<Test>::get_system_reserve(mid).is_err());\n\n    // Ensure that signal code sent is signal code we saved\n    let mail_msg = get_last_mail(USER_1);\n    assert_eq!(mail_msg.payload_bytes(), true.encode());\n}\n\n```\n\n----------------------------------------\n\nTITLE: Exporting Raw Chain Specification\nDESCRIPTION: Command to export a raw chain specification JSON without default bootnodes for the staging environment.\nSOURCE: https://github.com/gear-tech/gear/blob/master/ansible/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./target/production/gear build-spec --raw --disable-default-bootnode --chain staging > ./node/res/staging.json\n```\n\n----------------------------------------\n\nTITLE: Create Snapshot Command Help\nDESCRIPTION: Displays help information for the create-snapshot subcommand, showing available options for creating state snapshots.\nSOURCE: https://github.com/gear-tech/gear/blob/master/utils/gear-replay-cli/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ gear-replay-cli create-snapshot -h\n  Create a new snapshot file\n\n  Usage: gear-replay-cli create-snapshot [OPTIONS] [SNAPSHOT_PATH]\n\n  Arguments:\n    [SNAPSHOT_PATH]  The snapshot path to write to\n\n  Options:\n    -u, --uri <URI>                    The RPC url [default: wss://archive-rpc.vara.network:443]\n    -b, --block <BLOCK>                The block hash or number we want to replay. If omitted, the latest finalized block is used. The blockchain state at previous block with respect to this parameter will be scraped\n    -p, --pallet <PALLET>...           Pallet(s) to scrape. Comma-separated multiple items are also accepted. If empty, entire chain state will be scraped\n        --prefix <HASHED_PREFIXES>...  Storage entry key prefixes to scrape and inject into the test externalities. Pass as 0x prefixed hex strings. By default, all keys are scraped and included\n        --child-tree                   Fetch the child-keys as well\n    -h, --help                         Print help (see more with '--help')\n```\n\n----------------------------------------\n\nTITLE: Adding Wasm Target to Rust\nDESCRIPTION: Command to add the wasm32v1-none target to Rust, which is required for building the Gear node.\nSOURCE: https://github.com/gear-tech/gear/blob/master/node/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nrustup target add wasm32v1-none\n```\n\n----------------------------------------\n\nTITLE: Testing RemovedFromWaitlist Signal Handling in Gear\nDESCRIPTION: A Rust test that verifies the program's handling of the RemovedFromWaitlist signal. It uploads the program, sends a message to trigger waiting, and checks if the correct signal is received and handled after the waiting period expires.\nSOURCE: https://github.com/gear-tech/gear/blob/master/core-errors/signal-code-testing.md#2025-04-22_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nconst USER_1: AccountId = 1;\nconst DEFAULT_SALT: &[u8; 4] = b\"salt\";\nconst GAS_LIMIT: u64 = 10_000_000_000;\n\n#[test]\nfn test_signal_removed_from_waitlist() {\n    use demo_signal_removed_from_waitlist::{WASM_BINARY};\n\n    // Upload program\n    assert_ok!(Gear::upload_program(\n        RuntimeOrigin::signed(USER_1),\n        WASM_BINARY.to_vec(),\n        DEFAULT_SALT.to_vec(),\n        0.encode(),\n        GAS_LIMIT,\n        0,\n    ));\n\n    let pid = get_last_program_id();\n\n    run_to_next_block(None);\n\n    // Ensure that program is uploaded and initialized correctly\n    assert!(Gear::is_active(pid));\n    assert!(Gear::is_initialized(pid));\n\n    // Send the message to trigger signal sending\n    assert_ok!(Gear::send_message(\n        RuntimeOrigin::signed(USER_1),\n        pid,\n        [].into(),\n        GAS_LIMIT,\n        0,\n        false,\n    ));\n\n    run_to_next_block(None);\n\n    let mid = get_last_message_id();\n\n    // Ensuring that gas is reserved\n    assert_ok!(GasHandlerOf::<Test>::get_system_reserve(mid));\n\n    // Getting block number when waitlist expiration should happen\n    let mut expiration = None;\n\n    System::events().iter().for_each(|e| {\n        if let MockRuntimeEvent::Gear(Event::MessageWaited {\n            expiration: exp, ..\n        }) = e.event\n        {\n            expiration = Some(exp);\n        }\n    });\n\n    let expiration = expiration.unwrap();\n\n    // Hack to fast spend blocks till expiration\n    System::set_block_number(expiration - 1);\n    Gear::set_block_number(expiration - 1);\n\n    // Expiring that message\n    run_to_next_block(None);\n\n    // Ensure that signal code sent is signal code we saved\n    let mail_msg = get_last_mail(USER_1);\n    assert_eq!(mail_msg.payload_bytes(), true.encode());\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Solidity Code with Forge\nDESCRIPTION: Command to format Solidity code using Forge's formatting tool\nSOURCE: https://github.com/gear-tech/gear/blob/master/ethexe/contracts/README.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ forge fmt\n```\n\n----------------------------------------\n\nTITLE: Testing Backend Error for System Actor Interaction in Gear Protocol\nDESCRIPTION: Test code for verifying that a backend error signal is properly sent when a program attempts to send a message to the system actor. It uploads a program, sends a message to trigger the error, and checks if the correct signal was received.\nSOURCE: https://github.com/gear-tech/gear/blob/master/core-errors/signal-code-testing.md#2025-04-22_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nconst USER_1: AccountId = 1;\nconst DEFAULT_SALT: &[u8; 4] = b\"salt\";\nconst GAS_LIMIT: u64 = 10_000_000_000;\n\n#[test]\nfn test_signal_backend_error_system_actor_sending_works() {\n    use demo_signal_backend_error_system_actor_sending::{WASM_BINARY};\n\n    // Upload program\n    assert_ok!(Gear::upload_program(\n        RuntimeOrigin::signed(USER_1),\n        WASM_BINARY.to_vec(),\n        DEFAULT_SALT.to_vec(),\n        0.encode(),\n        GAS_LIMIT,\n        0,\n    ));\n\n    let pid = get_last_program_id();\n\n    run_to_next_block(None);\n\n    // Ensure that program is uploaded and initialized correctly\n    assert!(Gear::is_active(pid));\n    assert!(Gear::is_initialized(pid));\n\n    // Send the message to trigger signal sending\n    assert_ok!(Gear::send_message(\n        RuntimeOrigin::signed(USER_1),\n        pid,\n        [].into(),\n        GAS_LIMIT,\n        0,\n        false,\n    ));\n\n    run_to_next_block(None);\n\n    let mid = get_last_message_id();\n\n    // Assert that system reserve gas node is removed\n    assert_ok!(GasHandlerOf::<Test>::get_system_reserve(mid));\n    run_to_next_block(None);\n    assert!(GasHandlerOf::<Test>::get_system_reserve(mid).is_err());\n\n    // Ensure that signal code sent is signal code we saved\n    let mail_msg = get_last_mail(USER_1);\n    assert_eq!(mail_msg.payload_bytes(), true.encode());\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Invalid Debug String Backend Error in Gear Protocol\nDESCRIPTION: Test code for verifying that a backend error signal is properly sent when a program uses an invalid UTF-8 string with the debug syscall. It uploads the program, triggers the error, and verifies the signal was correctly received.\nSOURCE: https://github.com/gear-tech/gear/blob/master/core-errors/signal-code-testing.md#2025-04-22_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nconst USER_1: AccountId = 1;\nconst DEFAULT_SALT: &[u8; 4] = b\"salt\";\nconst GAS_LIMIT: u64 = 10_000_000_000;\n\n#[test]\nfn test_signal_backend_error_incorrect_debug_string_works() {\n    use demo_signal_backend_error_incorrect_debug_string::{WASM_BINARY};\n\n    // Upload program\n    assert_ok!(Gear::upload_program(\n        RuntimeOrigin::signed(USER_1),\n        WASM_BINARY.to_vec(),\n        DEFAULT_SALT.to_vec(),\n        0.encode(),\n        GAS_LIMIT,\n        0,\n    ));\n\n    let pid = get_last_program_id();\n\n    run_to_next_block(None);\n\n    // Ensure that program is uploaded and initialized correctly\n    assert!(Gear::is_active(pid));\n    assert!(Gear::is_initialized(pid));\n\n    // Send the message to trigger signal sending\n    assert_ok!(Gear::send_message(\n        RuntimeOrigin::signed(USER_1),\n        pid,\n        [].into(),\n        GAS_LIMIT,\n        0,\n        false,\n    ));\n\n    run_to_next_block(None);\n\n    let mid = get_last_message_id();\n\n    // Assert that system reserve gas node is removed\n    assert_ok!(GasHandlerOf::<Test>::get_system_reserve(mid));\n    run_to_next_block(None);\n    assert!(GasHandlerOf::<Test>::get_system_reserve(mid).is_err());\n\n    // Ensure that signal code sent is signal code we saved\n    let mail_msg = get_last_mail(USER_1);\n    assert_eq!(mail_msg.payload_bytes(), true.encode());\n}\n```\n\n----------------------------------------\n\nTITLE: Debug Mode Interface Documentation in Markdown\nDESCRIPTION: Documentation outlining the dispatchable functions available in the debug mode module, specifically the enable_debug_mode function that requires sudo access to toggle debug state.\nSOURCE: https://github.com/gear-tech/gear/blob/master/pallets/gear-debug/README.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Gear code used in debug mode\n\nA module providing a \"housekeeping\" API for enabling/disabling debug mode etc. Supposed to be optional, only enabled on a test net.\n\n## Interface\n\n### Dispatchable Functions\n\n* `enable_debug_mode` - called by a sudo account to toggle the debug mode on and off\n```\n\n----------------------------------------\n\nTITLE: Setting Rust Environment Variables\nDESCRIPTION: Command to set the necessary environment variables for Rust.\nSOURCE: https://github.com/gear-tech/gear/blob/master/node/README.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsource ~/.cargo/env\n```\n\n----------------------------------------\n\nTITLE: Testing Unreachable Instruction Signal with Incorrect Free in Gear Protocol\nDESCRIPTION: A unit test for verifying the functionality of the unreachable instruction signal when free syscall is called with an invalid page number. The test uploads a program, triggers the error condition, and checks signal handling.\nSOURCE: https://github.com/gear-tech/gear/blob/master/core-errors/signal-code-testing.md#2025-04-22_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nconst USER_1: AccountId = 1;\nconst DEFAULT_SALT: &[u8; 4] = b\"salt\";\nconst GAS_LIMIT: u64 = 10_000_000_000;\n\n#[test]\nfn test_signal_unreachable_instruction_incorrect_free_works() {\n    use demo_signal_unreachable_instruction_incorrect_free::{WASM_BINARY};\n\n    // Upload program\n    assert_ok!(Gear::upload_program(\n        RuntimeOrigin::signed(USER_1),\n        WASM_BINARY.to_vec(),\n        DEFAULT_SALT.to_vec(),\n        0.encode(),\n        GAS_LIMIT,\n        0,\n    ));\n\n    let pid = get_last_program_id();\n\n    run_to_next_block(None);\n\n    // Ensure that program is uploaded and initialized correctly\n    assert!(Gear::is_active(pid));\n    assert!(Gear::is_initialized(pid));\n\n    // Send the message to trigger signal sending\n    assert_ok!(Gear::send_message(\n        RuntimeOrigin::signed(USER_1),\n        pid,\n        [].into(),\n        GAS_LIMIT,\n        0,\n        false,\n    ));\n\n    run_to_next_block(None);\n\n    let mid = get_last_message_id();\n\n    // Assert that system reserve gas node is removed\n    assert_ok!(GasHandlerOf::<Test>::get_system_reserve(mid));\n    run_to_next_block(None);\n    assert!(GasHandlerOf::<Test>::get_system_reserve(mid).is_err());\n\n    // Ensure that signal code sent is signal code we saved\n    let mail_msg = get_last_mail(USER_1);\n    assert_eq!(mail_msg.payload_bytes(), true.encode());\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Gas Limit Exceeded on Memory Access in Rust Program\nDESCRIPTION: This Rust program handles a 'gas limit exceeded' signal due to memory access through the Gear platform contract library. It initializes an actor and includes methods to reserve gas and perform array memory access. Due to insufficient gas provided, it demonstrates triggering the out-of-gas signal.\nSOURCE: https://github.com/gear-tech/gear/blob/master/core-errors/signal-code-testing.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#![no_std]\n\nuse gstd::{\n    ActorId,\n    errors::{SignalCode, SimpleExecutionError},\n    exec,\n    prelude::*,\n    msg,\n};\n\nstatic mut INITIATOR: ActorId = ActorId::zero();\n\n#[unsafe(no_mangle)]\nextern \"C\" fn init() {\n    unsafe { INITIATOR = msg::source() };\n}\n\n#[unsafe(no_mangle)]\nextern \"C\" fn handle() {\n    exec::system_reserve_gas(1_000_000_000).unwrap();\n\n    const ARRAY_SIZE: usize = 1_000_000;\n    let arr = [42u8; ARRAY_SIZE];\n\n    for i in 0..ARRAY_SIZE {\n        let value = arr[i];\n    }\n}\n\n#[unsafe(no_mangle)]\nextern \"C\" fn handle_signal() {\n    let signal_received = msg::signal_code()\n        .expect(\"Incorrect call\")\n        .expect(\"Unsupported code\");\n\n    if signal_received == SignalCode::Execution(SimpleExecutionError::RanOutOfGas) {\n        msg::send(unsafe { INITIATOR }, true, 0).unwrap();\n    } else {\n        msg::send(unsafe { INITIATOR }, false, 0).unwrap();\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Testing Memory Overflow Signal in Rust Gear Protocol\nDESCRIPTION: A unit test for verifying the functionality of memory overflow signal handling. The test uploads a program, triggers a memory overflow condition, and verifies that the correct signal code is sent and system reserve gas is properly handled.\nSOURCE: https://github.com/gear-tech/gear/blob/master/core-errors/signal-code-testing.md#2025-04-22_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nconst USER_1: AccountId = 1;\nconst DEFAULT_SALT: &[u8; 4] = b\"salt\";\nconst GAS_LIMIT: u64 = 10_000_000_000;\n\n#[test]\nfn test_signal_memory_overflow_works() {\n    use demo_signal_memory_overflow::{WASM_BINARY};\n\n    // Upload program\n    assert_ok!(Gear::upload_program(\n        RuntimeOrigin::signed(USER_1),\n        WASM_BINARY.to_vec(),\n        DEFAULT_SALT.to_vec(),\n        0.encode(),\n        GAS_LIMIT,\n        0,\n    ));\n\n    let pid = get_last_program_id();\n\n    run_to_next_block(None);\n\n    // Ensure that program is uploaded and initialized correctly\n    assert!(Gear::is_active(pid));\n    assert!(Gear::is_initialized(pid));\n\n\n    // Send the message to trigger signal sending\n    assert_ok!(Gear::send_message(\n        RuntimeOrigin::signed(USER_1),\n        pid,\n        [].into(),\n        GAS_LIMIT,\n        0,\n        false,\n    ));\n\n    run_to_next_block(None);\n\n    let mid = get_last_message_id();\n\n    // Assert that system reserve gas node is removed\n    assert_ok!(GasHandlerOf::<Test>::get_system_reserve(mid));\n    run_to_next_block(None);\n    assert!(GasHandlerOf::<Test>::get_system_reserve(mid).is_err());\n\n    // Ensure that signal code sent is signal code we saved\n    let mail_msg = get_last_mail(USER_1);\n    assert_eq!(mail_msg.payload_bytes(), true.encode());\n}\n```\n\n----------------------------------------\n\nTITLE: Block Time and Weight Distribution Illustration\nDESCRIPTION: ASCII art diagram showing the relationship between block time (ms) and weight distribution in the system, demonstrating how the total block time of 3000ms and weight of 3*10^12 is partitioned.\nSOURCE: https://github.com/gear-tech/gear/blob/master/node/authorship/README.md#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n\"`  time, |                        weight |\n`    ms  |                               |\n`        |                               |\n`   3000 |------|                 3*10^12|------|\n`        |      |                        |      |\n`        |      |                        |      |\n`        |      |                        |      |\n`        |      |                        |      |\n`    980 |------|- proposal        10^12 |------|- max_block\n`        |//////|   deadline             |//////|\n`        |//////|                        |//////|\n`      0 --------------------------------------------\"\n```\n\n----------------------------------------\n\nTITLE: Handling Gas Limit Exceeded Signal in Rust Program\nDESCRIPTION: This Rust program uses the Gear platform contract library to demonstrate handling a gas limit exceeded signal. It initializes an actor and includes methods to reserve gas and handle infinite loops causing gas exhaustion. It requires the Gear platform's libraries and proper setup to execute the contract and send signals during execution.\nSOURCE: https://github.com/gear-tech/gear/blob/master/core-errors/signal-code-testing.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#![no_std]\n\nuse gstd::{\n    ActorId,\n    errors::{SignalCode, SimpleExecutionError},\n    exec,\n    prelude::*,\n    msg,\n};\n\nstatic mut INITIATOR: ActorId = ActorId::zero();\n\n#[unsafe(no_mangle)]\nextern \"C\" fn init() {\n    unsafe { INITIATOR = msg::source() };\n}\n\n#[unsafe(no_mangle)]\nextern \"C\" fn handle() {\n    exec::system_reserve_gas(1_000_000_000).unwrap();\n\n    #[allow(clippy::empty_loop)]\n    loop {}\n}\n\n#[unsafe(no_mangle)]\nextern \"C\" fn handle_signal() {\n    let signal_received = msg::signal_code()\n        .expect(\"Incorrect call\")\n        .expect(\"Unsupported code\");\n\n    if signal_received == SignalCode::Execution(SimpleExecutionError::RanOutOfGas) {\n        msg::send(unsafe { INITIATOR }, true, 0).unwrap();\n    } else {\n        msg::send(unsafe { INITIATOR }, false, 0).unwrap();\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Testing Unreachable Instruction Signal with WASM Unreachable in Gear Protocol\nDESCRIPTION: A unit test for verifying the functionality of the unreachable instruction signal when the WASM unreachable instruction is called. The test uploads a program, triggers the error, and checks signal handling and gas management.\nSOURCE: https://github.com/gear-tech/gear/blob/master/core-errors/signal-code-testing.md#2025-04-22_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nconst USER_1: AccountId = 1;\nconst DEFAULT_SALT: &[u8; 4] = b\"salt\";\nconst GAS_LIMIT: u64 = 10_000_000_000;\n\n#[test]\nfn test_signal_unreachable_instruction_wasm_works() {\n    use demo_signal_unreachable_instruction_wasm::{WASM_BINARY};\n\n    // Upload program\n    assert_ok!(Gear::upload_program(\n        RuntimeOrigin::signed(USER_1),\n        WASM_BINARY.to_vec(),\n        DEFAULT_SALT.to_vec(),\n        0.encode(),\n        GAS_LIMIT,\n        0,\n    ));\n\n    let pid = get_last_program_id();\n\n    run_to_next_block(None);\n\n    // Ensure that program is uploaded and initialized correctly\n    assert!(Gear::is_active(pid));\n    assert!(Gear::is_initialized(pid));\n\n    // Send the message to trigger signal sending\n    assert_ok!(Gear::send_message(\n        RuntimeOrigin::signed(USER_1),\n        pid,\n        [].into(),\n        GAS_LIMIT,\n        0,\n        false,\n    ));\n\n    run_to_next_block(None);\n\n    let mid = get_last_message_id();\n\n    // Assert that system reserve gas node is removed\n    assert_ok!(GasHandlerOf::<Test>::get_system_reserve(mid));\n    run_to_next_block(None);\n    assert!(GasHandlerOf::<Test>::get_system_reserve(mid).is_err());\n\n    // Ensure that signal code sent is signal code we saved\n    let mail_msg = get_last_mail(USER_1);\n    assert_eq!(mail_msg.payload_bytes(), true.encode());\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Text Coverage Report\nDESCRIPTION: Commands to generate a text-based coverage report using cargo-cov tool. The report is saved as coverage.txt and includes line counts while excluding rustc and cargo related files.\nSOURCE: https://github.com/gear-tech/gear/blob/master/utils/runtime-fuzzer/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nHOST_TARGET=$(rustc -Vv | grep \"host: \" | sed \"s/^host: \\(.*\\)$/\\1/\")\ncargo cov -- show target/$HOST_TARGET/coverage/$HOST_TARGET/release/main \\\n    --format=text \\\n    --show-line-counts \\\n    --Xdemangler=rustfilt \\\n    --instr-profile=fuzz/coverage/main/coverage.profdata \\\n    --ignore-filename-regex=/rustc/ \\\n    --ignore-filename-regex=.cargo/ &> fuzz/coverage/main/coverage.txt\n```\n\n----------------------------------------\n\nTITLE: Handling Forbidden System Actor Interactions in Rust Gear Program\nDESCRIPTION: A Rust program demonstrating how to detect and handle backend errors that occur when trying to send messages to the system actor. The program reserves system gas and attempts to send a message to the system actor, which is forbidden and triggers a backend error signal.\nSOURCE: https://github.com/gear-tech/gear/blob/master/core-errors/signal-code-testing.md#2025-04-22_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#![no_std]\n\nuse gear_core::ids::ProgramId;\nuse gstd::\n    ActorId,\n    errors::{SignalCode, SimpleExecutionError},\n    exec,\n    prelude::*,\n    msg,\n};\n\nstatic mut INITIATOR: ActorId = ActorId::zero();\n\n#[unsafe(no_mangle)]\nextern \"C\" fn init() {\n    unsafe { INITIATOR = msg::source() };\n}\n\n#[unsafe(no_mangle)]\nextern \"C\" fn handle() {\n    exec::system_reserve_gas(1_000_000_000).unwrap();\n\n    msg::send(ActorId::new(ProgramId::SYSTEM.into()), \"hello\", 0)\n            .expect(\"cannot send message\");\n}\n\n#[unsafe(no_mangle)]\nextern \"C\" fn handle_signal() {\n    let signal_received = msg::signal_code()\n        .expect(\"Incorrect call\")\n        .expect(\"Unsupported code\");\n\n    if signal_received == SignalCode::Execution(SimpleExecutionError::BackendError) {\n        msg::send(unsafe { INITIATOR }, true, 0).unwrap();\n    } else {\n        msg::send(unsafe { INITIATOR }, false, 0).unwrap();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Debug String Backend Error in Rust Gear Program\nDESCRIPTION: A Rust program that demonstrates triggering and handling backend errors when invalid UTF-8 strings are passed to the debug syscall. The program reserves system gas and intentionally creates an invalid UTF-8 string to trigger the error.\nSOURCE: https://github.com/gear-tech/gear/blob/master/core-errors/signal-code-testing.md#2025-04-22_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n#![no_std]\n\nuse gstd:{\n    ActorId,\n    debug,\n    errors::{SignalCode, SimpleExecutionError},\n    exec,\n    prelude::*,\n    msg,\n};\n\nstatic mut INITIATOR: ActorId = ActorId::zero();\n\n#[unsafe(no_mangle)]\nextern \"C\" fn init() {\n    unsafe { INITIATOR = msg::source() };\n}\n\n#[unsafe(no_mangle)]\nextern \"C\" fn handle() {\n    exec::system_reserve_gas(1_000_000_000).unwrap();\n\n    #[allow(clippy::invalid_utf8_in_unchecked)]\n    let invalid_string = unsafe { core::str::from_utf8_unchecked(&[0, 159, 146, 150]) };\n    debug!(\"{}\", invalid_string);\n}\n\n#[unsafe(no_mangle)]\nextern \"C\" fn handle_signal() {\n    let signal_received = msg::signal_code()\n        .expect(\"Incorrect call\")\n        .expect(\"Unsupported code\");\n\n    if signal_received == SignalCode::Execution(SimpleExecutionError::BackendError) {\n        msg::send(unsafe { INITIATOR }, true, 0).unwrap();\n    } else {\n        msg::send(unsafe { INITIATOR }, false, 0).unwrap();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling UnrecoverableExt Error with wait_up_to(0) in Rust Gear Program\nDESCRIPTION: A Rust program that triggers and handles the UnrecoverableExt error by calling the wait_up_to syscall with a parameter of 0. This program reserves system gas and attempts to execute a wait operation with an invalid parameter to trigger the backend error.\nSOURCE: https://github.com/gear-tech/gear/blob/master/core-errors/signal-code-testing.md#2025-04-22_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n#![no_std]\n\nuse gstd:{\n    ActorId,\n    errors::{SignalCode, SimpleExecutionError},\n    exec,\n    prelude::*,\n    msg,\n};\n\nstatic mut INITIATOR: ActorId = ActorId::zero();\n\n#[unsafe(no_mangle)]\nextern \"C\" fn init() {\n    unsafe { INITIATOR = msg::source() };\n}\n\n#[unsafe(no_mangle)]\nextern \"C\" fn handle() {\n    exec::system_reserve_gas(1_000_000_000).unwrap();\n\n    exec::wait_up_to(0);\n}\n\n#[unsafe(no_mangle)]\nextern \"C\" fn handle_signal() {\n    let signal_received = msg::signal_code()\n        .expect(\"Incorrect call\")\n        .expect(\"Unsupported code\");\n\n    if signal_received == SignalCode::Execution(SimpleExecutionError::BackendError) {\n        msg::send(unsafe { INITIATOR }, true, 0).unwrap();\n    } else {\n        msg::send(unsafe { INITIATOR }, false, 0).unwrap();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Userspace Panic Signal Handler in Rust\nDESCRIPTION: A Rust program demonstrating signal code handling for userspace panic scenarios. The program includes initialization, message handling, and signal processing logic that responds to panic events with appropriate responses to the initiator.\nSOURCE: https://github.com/gear-tech/gear/blob/master/core-errors/signal-code-testing.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![no_std]\n\nuse gstd::{\\n    ActorId,\\n    errors::{SignalCode, SimpleExecutionError},\\n    exec,\\n    msg,\\n    prelude::*\\n};\n\nstatic mut INITIATOR: ActorId = ActorId::zero();\n\n#[unsafe(no_mangle)]\\nextern \"C\" fn init() {\\n    unsafe { INITIATOR = msg::source() };\\n}\n\n#[unsafe(no_mangle)]\\nextern \"C\" fn handle() {\\n    exec::system_reserve_gas(1_000_000_000).unwrap();\\n\\n    panic!(\"Gotcha!\");\\n}\n\n#[unsafe(no_mangle)]\\nextern \"C\" fn handle_signal() {\\n    let signal_received = msg::signal_code()\\n        .expect(\"Incorrect call\")\\n        .expect(\"Unsupported code\");\\n\\n    if signal_received == SignalCode::Execution(SimpleExecutionError::UserspacePanic) {\\n        msg::send(unsafe { INITIATOR }, true, 0).unwrap();\\n    } else {\\n        msg::send(unsafe { INITIATOR }, false, 0).unwrap();\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Rust Program to Handle RemovedFromWaitlist Signal in Gear\nDESCRIPTION: A Rust program example that demonstrates how to handle the RemovedFromWaitlist signal in Gear. The program waits during execution and then responds to the signal when it's removed from the waitlist, sending a confirmation message back to the initiator.\nSOURCE: https://github.com/gear-tech/gear/blob/master/core-errors/signal-code-testing.md#2025-04-22_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\n#![no_std]\n\nuse gstd:{\n    ActorId,\n    errors::{SignalCode, SimpleExecutionError},\n    exec,\n    prelude::*,\n    msg,\n};\n\nstatic mut INITIATOR: ActorId = ActorId::zero();\n\n#[unsafe(no_mangle)]\nextern \"C\" fn init() {\n    unsafe { INITIATOR = msg::source() };\n}\n\n#[unsafe(no_mangle)]\nextern \"C\" fn handle() {\n    exec::system_reserve_gas(1_000_000_000).unwrap();\n\n    exec::wait();\n}\n\n#[unsafe(no_mangle)]\nextern \"C\" fn handle_signal() {\n    let signal_received = msg::signal_code()\n        .expect(\"Incorrect call\")\n        .expect(\"Unsupported code\");\n\n    if signal_received == SignalCode::RemovedFromWaitlist {\n        msg::send(unsafe { INITIATOR }, true, 0).unwrap();\n    } else {\n        msg::send(unsafe { INITIATOR }, false, 0).unwrap();\n    }\n}\n```"
  }
]