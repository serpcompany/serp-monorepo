[
  {
    "owner": "pydantic",
    "repo": "pydantic-settings",
    "content": "TITLE: Defining a Settings class with BaseSettings in Python\nDESCRIPTION: Example of creating a Settings class that inherits from BaseSettings to automatically read configuration from environment variables. Demonstrates various field types and configuration options.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\nfrom typing import Any\n\nfrom pydantic import (\n    AliasChoices,\n    AmqpDsn,\n    BaseModel,\n    Field,\n    ImportString,\n    PostgresDsn,\n    RedisDsn,\n)\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass SubModel(BaseModel):\n    foo: str = 'bar'\n    apple: int = 1\n\n\nclass Settings(BaseSettings):\n    auth_key: str = Field(validation_alias='my_auth_key')  # (1)!\n\n    api_key: str = Field(alias='my_api_key')  # (2)!\n\n    redis_dsn: RedisDsn = Field(\n        'redis://user:pass@localhost:6379/1',\n        validation_alias=AliasChoices('service_redis_dsn', 'redis_url'),  # (3)!\n    )\n    pg_dsn: PostgresDsn = 'postgres://user:pass@localhost:5432/foobar'\n    amqp_dsn: AmqpDsn = 'amqp://user:pass@localhost:5672/'\n\n    special_function: ImportString[Callable[[Any], Any]] = 'math.cos'  # (4)!\n\n    # to override domains:\n    # export my_prefix_domains='[\"foo.com\", \"bar.com\"]'\n    domains: set[str] = set()\n\n    # to override more_settings:\n    # export my_prefix_more_settings='{\"foo\": \"x\", \"apple\": 1}'\n    more_settings: SubModel = SubModel()\n\n    model_config = SettingsConfigDict(env_prefix='my_prefix_')  # (5)!\n\n\nprint(Settings().model_dump())\n\"\"\"\n{\n    'auth_key': 'xxx',\n    'api_key': 'xxx',\n    'redis_dsn': RedisDsn('redis://user:pass@localhost:6379/1'),\n    'pg_dsn': PostgresDsn('postgres://user:pass@localhost:5432/foobar'),\n    'amqp_dsn': AmqpDsn('amqp://user:pass@localhost:5672/'),\n    'special_function': math.cos,\n    'domains': set(),\n    'more_settings': {'foo': 'bar', 'apple': 1},\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using Kebab Case for CLI Arguments in Pydantic Settings\nDESCRIPTION: Demonstrates how to enable kebab-case for CLI arguments using cli_kebab_case. This transforms snake_case field names to kebab-case in the CLI interface for more intuitive command-line usage.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom pydantic import Field\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_kebab_case=True):\n    my_option: str = Field(description='will show as kebab case on CLI')\n\n\ntry:\n    sys.argv = ['example.py', '--help']\n    Settings()\nexcept SystemExit as e:\n    print(e)\n    #> 0\n\"\"\"\nusage: example.py [-h] [--my-option str]\n\noptions:\n  -h, --help       show this help message and exit\n  --my-option str  will show as kebab case on CLI (required)\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Basic Environment Variables Configuration\nDESCRIPTION: Example showing how to set up basic environment variables and load them into a Pydantic settings model with nested structures.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nexport V0=0\nexport SUB_MODEL='{\"v1\": \"json-1\", \"v2\": \"json-2\"}'\nexport SUB_MODEL__V2=nested-2\nexport SUB_MODEL__V3=3\nexport SUB_MODEL__DEEP__V4=v4\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass DeepSubModel(BaseModel):\n    v4: str\n\n\nclass SubModel(BaseModel):\n    v1: str\n    v2: bytes\n    v3: int\n    deep: DeepSubModel\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(env_nested_delimiter='__')\n\n    v0: str\n    sub_model: SubModel\n\n\nprint(Settings().model_dump())\n```\n\n----------------------------------------\n\nTITLE: Customizing Settings Source Priority in Pydantic\nDESCRIPTION: Demonstrates how to modify the priority order of different settings sources by overriding the settings_customise_sources method. This example prioritizes environment variables over initialization arguments.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_47\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import PostgresDsn\n\nfrom pydantic_settings import BaseSettings, PydanticBaseSettingsSource\n\n\nclass Settings(BaseSettings):\n    database_dsn: PostgresDsn\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        return env_settings, init_settings, file_secret_settings\n\n\nprint(Settings(database_dsn='postgres://postgres@localhost:5432/kwargs_db'))\n#> database_dsn=PostgresDsn('postgres://postgres@localhost:5432/kwargs_db')\n```\n\n----------------------------------------\n\nTITLE: Example TOML Configuration File for Pydantic Settings\nDESCRIPTION: A simple TOML configuration file that defines a string value and a nested structure. This format is compatible with the TomlConfigSettingsSource in Pydantic Settings.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_43\n\nLANGUAGE: toml\nCODE:\n```\nfoobar = \"Hello\"\n[nested]\nnested_field = \"world!\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom JSON Config Settings Source in Python\nDESCRIPTION: Demonstrates how to create a custom settings source that loads variables from a JSON file. The example creates a JsonConfigSettingsSource class that reads from a config file and integrates it into the settings sources pipeline through settings_customise_sources.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_48\n\nLANGUAGE: python\nCODE:\n```\nimport json\nfrom pathlib import Path\nfrom typing import Any\n\nfrom pydantic.fields import FieldInfo\n\nfrom pydantic_settings import (\n    BaseSettings,\n    PydanticBaseSettingsSource,\n    SettingsConfigDict,\n)\n\n\nclass JsonConfigSettingsSource(PydanticBaseSettingsSource):\n    \"\"\"\n    A simple settings source class that loads variables from a JSON file\n    at the project's root.\n\n    Here we happen to choose to use the `env_file_encoding` from Config\n    when reading `config.json`\n    \"\"\"\n\n    def get_field_value(\n        self, field: FieldInfo, field_name: str\n    ) -> tuple[Any, str, bool]:\n        encoding = self.config.get('env_file_encoding')\n        file_content_json = json.loads(\n            Path('tests/example_test_config.json').read_text(encoding)\n        )\n        field_value = file_content_json.get(field_name)\n        return field_value, field_name, False\n\n    def prepare_field_value(\n        self, field_name: str, field: FieldInfo, value: Any, value_is_complex: bool\n    ) -> Any:\n        return value\n\n    def __call__(self) -> dict[str, Any]:\n        d: dict[str, Any] = {}\n\n        for field_name, field in self.settings_cls.model_fields.items():\n            field_value, field_key, value_is_complex = self.get_field_value(\n                field, field_name\n            )\n            field_value = self.prepare_field_value(\n                field_name, field, field_value, value_is_complex\n            )\n            if field_value is not None:\n                d[field_key] = field_value\n\n        return d\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(env_file_encoding='utf-8')\n\n    foobar: str\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        return (\n            init_settings,\n            JsonConfigSettingsSource(settings_cls),\n            env_settings,\n            file_secret_settings,\n        )\n\n\nprint(Settings())\n#> foobar='test'\n```\n\n----------------------------------------\n\nTITLE: Configuring TOML File Settings Source in Pydantic\nDESCRIPTION: Shows how to configure Pydantic Settings to read configuration from a TOML file. The example demonstrates customizing settings sources to use the TomlConfigSettingsSource and defines a model structure that maps to the TOML file format.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_42\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import (\n    BaseSettings,\n    PydanticBaseSettingsSource,\n    SettingsConfigDict,\n    TomlConfigSettingsSource,\n)\n\n\nclass Nested(BaseModel):\n    nested_field: str\n\n\nclass Settings(BaseSettings):\n    foobar: str\n    nested: Nested\n    model_config = SettingsConfigDict(toml_file='config.toml')\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        return (TomlConfigSettingsSource(settings_cls),)\n```\n\n----------------------------------------\n\nTITLE: Configuring Secret Files in Pydantic Settings (Python)\nDESCRIPTION: Demonstrates how to configure Pydantic Settings to load secret values from files by setting the 'secrets_dir' in the model_config or using the '_secrets_dir' keyword argument.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(secrets_dir='/var/run')\n\n    database_password: str\n```\n\n----------------------------------------\n\nTITLE: Integrating AWS Secrets Manager with Pydantic Settings (Python)\nDESCRIPTION: Illustrates how to integrate AWS Secrets Manager with Pydantic Settings by creating a custom settings source and overriding the default settings sources.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_40\n\nLANGUAGE: python\nCODE:\n```\nimport os\n\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import (\n    AWSSecretsManagerSettingsSource,\n    BaseSettings,\n    PydanticBaseSettingsSource,\n)\n\n\nclass SubModel(BaseModel):\n    a: str\n\n\nclass AWSSecretsManagerSettings(BaseSettings):\n    foo: str\n    bar: int\n    sub: SubModel\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        aws_secrets_manager_settings = AWSSecretsManagerSettingsSource(\n            settings_cls,\n            os.environ['AWS_SECRETS_MANAGER_SECRET_ID'],\n        )\n        return (\n            init_settings,\n            env_settings,\n            dotenv_settings,\n            file_secret_settings,\n            aws_secrets_manager_settings,\n        )\n```\n\n----------------------------------------\n\nTITLE: Integrating Azure Key Vault with Pydantic Settings\nDESCRIPTION: Demonstrates how to configure Pydantic Settings to read secrets from Azure Key Vault. This requires setting the vault URL and credentials, and customizing the settings sources to include the Azure Key Vault source with proper authentication.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_41\n\nLANGUAGE: python\nCODE:\n```\nimport os\n\nfrom azure.identity import DefaultAzureCredential\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import (\n    AzureKeyVaultSettingsSource,\n    BaseSettings,\n    PydanticBaseSettingsSource,\n)\n\n\nclass SubModel(BaseModel):\n    a: str\n\n\nclass AzureKeyVaultSettings(BaseSettings):\n    foo: str\n    bar: int\n    sub: SubModel\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        az_key_vault_settings = AzureKeyVaultSettingsSource(\n            settings_cls,\n            os.environ['AZURE_KEY_VAULT_URL'],\n            DefaultAzureCredential(),\n        )\n        return (\n            init_settings,\n            env_settings,\n            dotenv_settings,\n            file_secret_settings,\n            az_key_vault_settings,\n        )\n```\n\n----------------------------------------\n\nTITLE: Configuring Pydantic Settings with pyproject.toml\nDESCRIPTION: Demonstrates how to load configuration from different sections of a pyproject.toml file. It shows loading from the default table, a custom table, and the root of the file using PyprojectTomlConfigSettingsSource.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_44\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_settings import (\n    BaseSettings,\n    PydanticBaseSettingsSource,\n    PyprojectTomlConfigSettingsSource,\n    SettingsConfigDict,\n)\n\n\nclass Settings(BaseSettings):\n    \"\"\"Example loading values from the table used by default.\"\"\"\n\n    field: str\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        return (PyprojectTomlConfigSettingsSource(settings_cls),)\n\n\nclass SomeTableSettings(Settings):\n    \"\"\"Example loading values from a user defined table.\"\"\"\n\n    model_config = SettingsConfigDict(\n        pyproject_toml_table_header=('tool', 'some-table')\n    )\n\n\nclass RootSettings(Settings):\n    \"\"\"Example loading values from the root of a pyproject.toml file.\"\"\"\n\n    model_config = SettingsConfigDict(extra='ignore', pyproject_toml_table_header=())\n```\n\n----------------------------------------\n\nTITLE: Multiple Environment Files Configuration\nDESCRIPTION: Example of loading multiple environment files in order of priority\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(\n        # `.env.prod` takes priority over `.env`\n        env_file=('.env', '.env.prod')\n    )\n```\n\n----------------------------------------\n\nTITLE: In-place Reloading of Settings in Pydantic-Settings\nDESCRIPTION: Shows how to reload an existing settings instance in-place by calling its __init__ method. This allows updating settings when environment variables change without creating a new instance, making it useful for long-running applications.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_51\n\nLANGUAGE: python\nCODE:\n```\nimport os\n\nfrom pydantic import Field\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings):\n    foo: str = Field('foo')\n\n\nmutable_settings = Settings()\n\nprint(mutable_settings.foo)\n#> foo\n\nos.environ['foo'] = 'bar'\nprint(mutable_settings.foo)\n#> foo\n\nmutable_settings.__init__()\nprint(mutable_settings.foo)\n#> bar\n\nos.environ.pop('foo')\nmutable_settings.__init__()\nprint(mutable_settings.foo)\n#> foo\n```\n\n----------------------------------------\n\nTITLE: Custom Environment Variable Source Implementation\nDESCRIPTION: Shows how to implement a custom source class for parsing environment variables in a specialized way.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport json\nimport os\nfrom typing import Any\n\nfrom pydantic.fields import FieldInfo\n\nfrom pydantic_settings import (\n    BaseSettings,\n    EnvSettingsSource,\n    PydanticBaseSettingsSource,\n)\n\n\nclass MyCustomSource(EnvSettingsSource):\n    def prepare_field_value(\n        self, field_name: str, field: FieldInfo, value: Any, value_is_complex: bool\n    ) -> Any:\n        if field_name == 'numbers':\n            return [int(x) for x in value.split(',')]\n        return json.loads(value)\n\n\nclass Settings(BaseSettings):\n    numbers: list[int]\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        return (MyCustomSource(settings_cls),)\n```\n\n----------------------------------------\n\nTITLE: Creating CLI Applications with CliApp.run in Python\nDESCRIPTION: This snippet demonstrates how to use the CliApp.run method to create a simple CLI application. It shows how to define a Settings class with a cli_cmd method and run it as a CLI application, parsing arguments and executing the command.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_settings import BaseSettings, CliApp\n\n\nclass Settings(BaseSettings):\n    this_foo: str\n\n    def cli_cmd(self) -> None:\n        # Print the parsed data\n        print(self.model_dump())\n        #> {'this_foo': 'is such a foo'}\n\n        # Update the parsed data showing cli_cmd ran\n        self.this_foo = 'ran the foo cli cmd'\n\n\ns = CliApp.run(Settings, cli_args=['--this_foo', 'is such a foo'])\nprint(s.model_dump())\n#> {'this_foo': 'ran the foo cli cmd'}\n```\n\n----------------------------------------\n\nTITLE: Implementing Subcommands with CliApp.run_subcommand in Python\nDESCRIPTION: This example shows how to use CliApp.run_subcommand to create a CLI application with subcommands. It demonstrates creating a Git-like CLI structure with 'init' and 'clone' subcommands, each with their own cli_cmd method.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import CliApp, CliPositionalArg, CliSubCommand\n\n\nclass Init(BaseModel):\n    directory: CliPositionalArg[str]\n\n    def cli_cmd(self) -> None:\n        print(f'git init \"{self.directory}\"')\n        #> git init \"dir\"\n        self.directory = 'ran the git init cli cmd'\n\n\nclass Clone(BaseModel):\n    repository: CliPositionalArg[str]\n    directory: CliPositionalArg[str]\n\n    def cli_cmd(self) -> None:\n        print(f'git clone from \"{self.repository}\" into \"{self.directory}\"')\n        self.directory = 'ran the clone cli cmd'\n\n\nclass Git(BaseModel):\n    clone: CliSubCommand[Clone]\n    init: CliSubCommand[Init]\n\n    def cli_cmd(self) -> None:\n        CliApp.run_subcommand(self)\n\n\ncmd = CliApp.run(Git, cli_args=['init', 'dir'])\nassert cmd.model_dump() == {\n    'clone': None,\n    'init': {'directory': 'ran the git init cli cmd'},\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Subcommands and Positional Arguments in Python with Pydantic Settings\nDESCRIPTION: This snippet demonstrates how to use CliSubCommand and CliPositionalArg to create a Git-like CLI structure with 'clone' and 'init' subcommands. It shows how to define the command structure, parse arguments, and retrieve subcommand data.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import (\n    BaseSettings,\n    CliPositionalArg,\n    CliSubCommand,\n    SettingsError,\n    get_subcommand,\n)\n\n\nclass Init(BaseModel):\n    directory: CliPositionalArg[str]\n\n\nclass Clone(BaseModel):\n    repository: CliPositionalArg[str]\n    directory: CliPositionalArg[str]\n\n\nclass Git(BaseSettings, cli_parse_args=True, cli_exit_on_error=False):\n    clone: CliSubCommand[Clone]\n    init: CliSubCommand[Init]\n\n\n# Run without subcommands\nsys.argv = ['example.py']\ncmd = Git()\nassert cmd.model_dump() == {'clone': None, 'init': None}\n\ntry:\n    # Will raise an error since no subcommand was provided\n    get_subcommand(cmd).model_dump()\nexcept SettingsError as err:\n    assert str(err) == 'Error: CLI subcommand is required {clone, init}'\n\n# Will not raise an error since subcommand is not required\nassert get_subcommand(cmd, is_required=False) is None\n\n\n# Run the clone subcommand\nsys.argv = ['example.py', 'clone', 'repo', 'dest']\ncmd = Git()\nassert cmd.model_dump() == {\n    'clone': {'repository': 'repo', 'directory': 'dest'},\n    'init': None,\n}\n\n# Returns the subcommand model instance (in this case, 'clone')\nassert get_subcommand(cmd).model_dump() == {\n    'directory': 'dest',\n    'repository': 'repo',\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring environment variable prefixes in BaseSettings\nDESCRIPTION: Example of setting a prefix for all environment variables in a BaseSettings class.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(env_prefix='my_prefix_')\n\n    auth_key: str = 'xxx'  # will be read from `my_prefix_auth_key`\n```\n\n----------------------------------------\n\nTITLE: Using aliases for environment variable names in BaseSettings\nDESCRIPTION: Demonstration of using Field aliases to override environment variable names for specific fields.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import Field\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(env_prefix='my_prefix_')\n\n    foo: str = Field('xxx', alias='FooAlias')  # (1)!\n```\n\n----------------------------------------\n\nTITLE: Configuring BaseSettings with Environment File Path\nDESCRIPTION: Demonstrates setting up a Pydantic Settings class with environment file configuration using model_config\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8')\n```\n\n----------------------------------------\n\nTITLE: Instantiating Settings with Custom Environment File\nDESCRIPTION: Shows how to instantiate a Settings class with a custom environment file path using _env_file argument\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8')\n\n\nsettings = Settings(_env_file='prod.env', _env_file_encoding='utf-8')\n```\n\n----------------------------------------\n\nTITLE: CLI Settings with Nested Models\nDESCRIPTION: Example of using CLI arguments with nested Pydantic models and various data types\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass DeepSubModel(BaseModel):\n    v4: str\n\n\nclass SubModel(BaseModel):\n    v1: str\n    v2: bytes\n    v3: int\n    deep: DeepSubModel\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(cli_parse_args=True)\n\n    v0: str\n    sub_model: SubModel\n\n\nsys.argv = [\n    'example.py',\n    '--v0=0',\n    '--sub_model={\"v1\": \"json-1\", \"v2\": \"json-2\"}',\n    '--sub_model.v2=nested-2',\n    '--sub_model.v3=3',\n    '--sub_model.deep.v4=v4',\n]\n```\n\n----------------------------------------\n\nTITLE: Integrating Pydantic Settings with Existing CLI Parsers (Python)\nDESCRIPTION: Illustrates how to integrate Pydantic Settings with existing CLI parsers by overriding the default CLI settings source and specifying a custom root parser object.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_37\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom argparse import ArgumentParser\n\nfrom pydantic_settings import BaseSettings, CliApp, CliSettingsSource\n\nparser = ArgumentParser()\nparser.add_argument('--food', choices=['pear', 'kiwi', 'lime'])\n\n\nclass Settings(BaseSettings):\n    name: str = 'Bob'\n\n\n# Set existing `parser` as the `root_parser` object for the user defined settings source\ncli_settings = CliSettingsSource(Settings, root_parser=parser)\n\n# Parse and load CLI settings from the command line into the settings source.\nsys.argv = ['example.py', '--food', 'kiwi', '--name', 'waldo']\ns = CliApp.run(Settings, cli_settings_source=cli_settings)\nprint(s.model_dump())\n#> {'name': 'waldo'}\n\n# Load CLI settings from pre-parsed arguments. i.e., the parsing occurs elsewhere and we\n# just need to load the pre-parsed args into the settings source.\nparsed_args = parser.parse_args(['--food', 'kiwi', '--name', 'ralph'])\ns = CliApp.run(Settings, cli_args=parsed_args, cli_settings_source=cli_settings)\nprint(s.model_dump())\n#> {'name': 'ralph'}\n```\n\n----------------------------------------\n\nTITLE: Nested Environment Configuration with Max Split\nDESCRIPTION: Demonstrates how to configure nested environment variables with a maximum split depth to handle complex field names.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nexport GENERATION_LLM_PROVIDER='anthropic'\nexport GENERATION_LLM_API_KEY='your-api-key'\nexport GENERATION_LLM_API_VERSION='2024-03-15'\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass LLMConfig(BaseModel):\n    provider: str = 'openai'\n    api_key: str\n    api_type: str = 'azure'\n    api_version: str = '2023-03-15-preview'\n\n\nclass GenerationConfig(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_nested_delimiter='_', env_nested_max_split=1, env_prefix='GENERATION_'\n    )\n\n    llm: LLMConfig\n```\n\n----------------------------------------\n\nTITLE: Advanced pyproject.toml Configuration with Directory Discovery\nDESCRIPTION: Shows how to configure Pydantic Settings to search for pyproject.toml in parent directories or use an explicit file path. These options provide flexibility for locating configuration files in various project structures.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nfrom pathlib import Path\n\nfrom pydantic_settings import (\n    BaseSettings,\n    PydanticBaseSettingsSource,\n    PyprojectTomlConfigSettingsSource,\n    SettingsConfigDict,\n)\n\n\nclass DiscoverSettings(BaseSettings):\n    \"\"\"Example of discovering a pyproject.toml in parent directories in not in `Path.cwd()`.\"\"\"\n\n    model_config = SettingsConfigDict(pyproject_toml_depth=2)\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        return (PyprojectTomlConfigSettingsSource(settings_cls),)\n\n\nclass ExplicitFilePathSettings(BaseSettings):\n    \"\"\"Example of explicitly providing the path to the file to load.\"\"\"\n\n    field: str\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        return (\n            PyprojectTomlConfigSettingsSource(\n                settings_cls, Path('~/.config').resolve() / 'pyproject.toml'\n            ),\n        )\n```\n\n----------------------------------------\n\nTITLE: Accessing Previous Settings Sources in Custom Source Implementation\nDESCRIPTION: Shows how a custom settings source can access the output of previous sources using the current_state and settings_sources_data properties, allowing for more complex settings resolution logic that builds upon already loaded configuration.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_49\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nfrom pydantic.fields import FieldInfo\n\nfrom pydantic_settings import PydanticBaseSettingsSource\n\n\nclass MyCustomSource(PydanticBaseSettingsSource):\n    def get_field_value(\n        self, field: FieldInfo, field_name: str\n    ) -> tuple[Any, str, bool]: ...\n\n    def __call__(self) -> dict[str, Any]:\n        # Retrieve the aggregated settings from previous sources\n        current_state = self.current_state\n        current_state.get('some_setting')\n\n        # Retrive settings from all sources individually\n        # self.settings_sources_data[\"SettingsSourceName\"]: dict[str, Any]\n        settings_sources_data = self.settings_sources_data\n        settings_sources_data['SomeSettingsSource'].get('some_setting')\n\n        # Your code here...\n```\n\n----------------------------------------\n\nTITLE: Removing Settings Sources in Pydantic-Settings\nDESCRIPTION: Demonstrates how to disable a specific settings source by customizing the settings_customise_sources method. In this example, the init_settings source is excluded, causing arguments passed to the Settings constructor to be ignored.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_50\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ValidationError\n\nfrom pydantic_settings import BaseSettings, PydanticBaseSettingsSource\n\n\nclass Settings(BaseSettings):\n    my_api_key: str\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        # here we choose to ignore arguments from init_settings\n        return env_settings, file_secret_settings\n\n\ntry:\n    Settings(my_api_key='this is ignored')\nexcept ValidationError as exc_info:\n    print(exc_info)\n    \"\"\"\n    1 validation error for Settings\n    my_api_key\n      Field required [type=missing, input_value={}, input_type=dict]\n        For further information visit https://errors.pydantic.dev/2/v/missing\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Mutually Exclusive CLI Arguments with Pydantic Settings\nDESCRIPTION: Demonstrates how to create CLI mutually exclusive groups by inheriting from the CliMutuallyExclusiveGroup class. The example shows a Circle class where radius, diameter, and perimeter parameters cannot be used together.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import CliApp, CliMutuallyExclusiveGroup, SettingsError\n\n\nclass Circle(CliMutuallyExclusiveGroup):\n    radius: Optional[float] = None\n    diameter: Optional[float] = None\n    perimeter: Optional[float] = None\n\n\nclass Settings(BaseModel):\n    circle: Circle\n\n\ntry:\n    CliApp.run(\n        Settings,\n        cli_args=['--circle.radius=1', '--circle.diameter=2'],\n        cli_exit_on_error=False,\n    )\nexcept SettingsError as e:\n    print(e)\n    \"\"\"\n    error parsing CLI: argument --circle.diameter: not allowed with argument --circle.radius\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using Union Types and Aliases with CliSubCommand and CliPositionalArg in Python\nDESCRIPTION: This example shows how to use union types and aliases with CliSubCommand and CliPositionalArg. It demonstrates creating a CLI with multiple subcommands, some of which are part of a union type, and how to use aliases for command names and options.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom typing import Union\n\nfrom pydantic import BaseModel, Field\n\nfrom pydantic_settings import (\n    BaseSettings,\n    CliPositionalArg,\n    CliSubCommand,\n    get_subcommand,\n)\n\n\nclass Alpha(BaseModel):\n    \"\"\"Apha Help\"\"\"\n\n    cmd_alpha: CliPositionalArg[str] = Field(alias='alpha-cmd')\n\n\nclass Beta(BaseModel):\n    \"\"\"Beta Help\"\"\"\n\n    opt_beta: str = Field(alias='opt-beta')\n\n\nclass Gamma(BaseModel):\n    \"\"\"Gamma Help\"\"\"\n\n    opt_gamma: str = Field(alias='opt-gamma')\n\n\nclass Root(BaseSettings, cli_parse_args=True, cli_exit_on_error=False):\n    alpha_or_beta: CliSubCommand[Union[Alpha, Beta]] = Field(alias='alpha-or-beta-cmd')\n    gamma: CliSubCommand[Gamma] = Field(alias='gamma-cmd')\n\n\nsys.argv = ['example.py', 'Alpha', 'hello']\nassert get_subcommand(Root()).model_dump() == {'cmd_alpha': 'hello'}\n\nsys.argv = ['example.py', 'Beta', '--opt-beta=hey']\nassert get_subcommand(Root()).model_dump() == {'opt_beta': 'hey'}\n\nsys.argv = ['example.py', 'gamma-cmd', '--opt-gamma=hi']\nassert get_subcommand(Root()).model_dump() == {'opt_gamma': 'hi'}\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous CLI Commands with CliApp in Python\nDESCRIPTION: This snippet demonstrates how to create asynchronous CLI commands using CliApp.run. It shows a simple example of an asynchronous top-level command and explains how CliApp handles the execution of async methods.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_settings import BaseSettings, CliApp\n\n\nclass AsyncSettings(BaseSettings):\n    async def cli_cmd(self) -> None:\n        print('Hello from an async CLI method!')\n        #> Hello from an async CLI method!\n\n\n# If an event loop is already running, a new thread will be used;\n# otherwise, asyncio.run() is used to execute this async method.\nassert CliApp.run(AsyncSettings, cli_args=[]).model_dump() == {}\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Subcommands with CliApp in Python\nDESCRIPTION: This example shows how to implement asynchronous subcommands using CliApp. It demonstrates creating a Git-like CLI structure with an asynchronous 'clone' subcommand, and explains the best practices for using async methods in subcommands.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import (\n    BaseSettings,\n    CliApp,\n    CliPositionalArg,\n    CliSubCommand,\n)\n\n\nclass Clone(BaseModel):\n    repository: CliPositionalArg[str]\n    directory: CliPositionalArg[str]\n\n    async def cli_cmd(self) -> None:\n        # Perform async tasks here, e.g. network or I/O operations\n        print(f'Cloning async from \"{self.repository}\" into \"{self.directory}\"')\n        #> Cloning async from \"repo\" into \"dir\"\n\n\nclass Git(BaseSettings):\n    clone: CliSubCommand[Clone]\n\n    def cli_cmd(self) -> None:\n        # Run the final subcommand (clone/init). It is recommended to define async methods only at the deepest level.\n        CliApp.run_subcommand(self)\n\n\nCliApp.run(Git, cli_args=['clone', 'repo', 'dir']).model_dump() == {\n    'repository': 'repo',\n    'directory': 'dir',\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring CLI Boolean Flags in Pydantic Settings\nDESCRIPTION: Demonstrates how to configure boolean flags in CLI arguments using cli_implicit_flags setting. Shows both explicit boolean fields (requiring values like --flag=True) and implicit flags (using --flag/--no-flag syntax).\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_settings import BaseSettings, CliExplicitFlag, CliImplicitFlag\n\n\nclass ExplicitSettings(BaseSettings, cli_parse_args=True):\n    \"\"\"Boolean fields are explicit by default.\"\"\"\n\n    explicit_req: bool\n    \"\"\"\n    --explicit_req bool   (required)\n    \"\"\"\n\n    explicit_opt: bool = False\n    \"\"\"\n    --explicit_opt bool   (default: False)\n    \"\"\"\n\n    # Booleans are explicit by default, so must override implicit flags with annotation\n    implicit_req: CliImplicitFlag[bool]\n    \"\"\"\n    --implicit_req, --no-implicit_req (required)\n    \"\"\"\n\n    implicit_opt: CliImplicitFlag[bool] = False\n    \"\"\"\n    --implicit_opt, --no-implicit_opt (default: False)\n    \"\"\"\n\n\nclass ImplicitSettings(BaseSettings, cli_parse_args=True, cli_implicit_flags=True):\n    \"\"\"With cli_implicit_flags=True, boolean fields are implicit by default.\"\"\"\n\n    # Booleans are implicit by default, so must override explicit flags with annotation\n    explicit_req: CliExplicitFlag[bool]\n    \"\"\"\n    --explicit_req bool   (required)\n    \"\"\"\n\n    explicit_opt: CliExplicitFlag[bool] = False\n    \"\"\"\n    --explicit_opt bool   (default: False)\n    \"\"\"\n\n    implicit_req: bool\n    \"\"\"\n    --implicit_req, --no-implicit_req (required)\n    \"\"\"\n\n    implicit_opt: bool = False\n    \"\"\"\n    --implicit_opt, --no-implicit_opt (default: False)\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Ignoring Unknown CLI Arguments in Pydantic Settings\nDESCRIPTION: Shows how to configure Pydantic Settings to ignore unknown CLI arguments by enabling cli_ignore_unknown_args. This allows the application to only parse known arguments and ignore any unexpected inputs.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_ignore_unknown_args=True):\n    good_arg: str\n\n\nsys.argv = ['example.py', '--bad-arg=bad', 'ANOTHER_BAD_ARG', '--good_arg=hello world']\nprint(Settings().model_dump())\n#> {'good_arg': 'hello world'}\n```\n\n----------------------------------------\n\nTITLE: Configuring CLI Error Handling in Pydantic Settings\nDESCRIPTION: Shows how to control CLI error handling by setting cli_exit_on_error to False. This causes the parser to raise a SettingsError exception instead of exiting the program when invalid arguments are provided.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom pydantic_settings import BaseSettings, SettingsError\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_exit_on_error=False): ...\n\n\ntry:\n    sys.argv = ['example.py', '--bad-arg']\n    Settings()\nexcept SettingsError as e:\n    print(e)\n    #> error parsing CLI: unrecognized arguments: --bad-arg\n```\n\n----------------------------------------\n\nTITLE: Enforcing Required CLI Arguments in Pydantic Settings\nDESCRIPTION: Demonstrates how to enforce required fields at the CLI level using cli_enforce_required=True. This requires values to be provided via CLI even if they might be available from other sources like environment variables.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nimport os\nimport sys\n\nfrom pydantic import Field\n\nfrom pydantic_settings import BaseSettings, SettingsError\n\n\nclass Settings(\n    BaseSettings,\n    cli_parse_args=True,\n    cli_enforce_required=True,\n    cli_exit_on_error=False,\n):\n    my_required_field: str = Field(description='a top level required field')\n\n\nos.environ['MY_REQUIRED_FIELD'] = 'hello from environment'\n\ntry:\n    sys.argv = ['example.py']\n    Settings()\nexcept SettingsError as e:\n    print(e)\n    #> error parsing CLI: the following arguments are required: --my_required_field\n```\n\n----------------------------------------\n\nTITLE: Customizing None Value Parsing in Pydantic Settings CLI\nDESCRIPTION: Shows how to customize the string that will be parsed as None in CLI arguments using cli_parse_none_str. This allows for more intuitive null value representation in command-line arguments.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom typing import Optional\n\nfrom pydantic import Field\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_parse_none_str='void'):\n    v1: Optional[int] = Field(description='the top level v0 option')\n\n\nsys.argv = ['example.py', '--v1', 'void']\nprint(Settings().model_dump())\n#> {'v1': None}\n```\n\n----------------------------------------\n\nTITLE: Hiding None Type Values in CLI Help Text\nDESCRIPTION: Demonstrates how to hide None values from the CLI help text using cli_hide_none_type=True. This simplifies the help output by not displaying the default None type in parameter descriptions.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom typing import Optional\n\nfrom pydantic import Field\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_hide_none_type=True):\n    v0: Optional[str] = Field(description='the top level v0 option')\n\n\ntry:\n    sys.argv = ['example.py', '--help']\n    Settings()\nexcept SystemExit as e:\n    print(e)\n    #> 0\n\"\"\"\nusage: example.py [-h] [--v0 str]\n\noptions:\n  -h, --help  show this help message and exit\n  --v0 str    the top level v0 option (required)\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Avoiding JSON CLI Options in Pydantic Settings\nDESCRIPTION: Shows how to avoid JSON string representation for complex fields in CLI by enabling cli_avoid_json. This creates a more intuitive CLI interface for nested models by exposing individual fields as separate options.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom pydantic import BaseModel, Field\n\nfrom pydantic_settings import BaseSettings\n\n\nclass SubModel(BaseModel):\n    v1: int = Field(description='the sub model v1 option')\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_avoid_json=True):\n    sub_model: SubModel = Field(\n        description='The help summary for SubModel related options'\n    )\n\n\ntry:\n    sys.argv = ['example.py', '--help']\n    Settings()\nexcept SystemExit as e:\n    print(e)\n    #> 0\n\"\"\"\nusage: example.py [-h] [--sub_model.v1 int]\n\noptions:\n  -h, --help          show this help message and exit\n\nsub_model options:\n  The help summary for SubModel related options\n\n  --sub_model.v1 int  the sub model v1 option (required)\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using Class Docstrings for CLI Help Text in Pydantic Settings\nDESCRIPTION: Demonstrates how to use class docstrings instead of field descriptions for group help text using cli_use_class_docs_for_groups=True. This provides more detailed documentation for complex nested models in the CLI help output.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom pydantic import BaseModel, Field\n\nfrom pydantic_settings import BaseSettings\n\n\nclass SubModel(BaseModel):\n    \"\"\"The help text from the class docstring.\"\"\"\n\n    v1: int = Field(description='the sub model v1 option')\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_use_class_docs_for_groups=True):\n    \"\"\"My application help text.\"\"\"\n\n    sub_model: SubModel = Field(description='The help text from the field description')\n\n\ntry:\n    sys.argv = ['example.py', '--help']\n    Settings()\nexcept SystemExit as e:\n    print(e)\n    #> 0\n\"\"\"\nusage: example.py [-h] [--sub_model JSON] [--sub_model.v1 int]\n\nMy application help text.\n\noptions:\n  -h, --help          show this help message and exit\n\nsub_model options:\n  The help text from the class docstring.\n\n  --sub_model JSON    set sub_model from JSON string\n  --sub_model.v1 int  the sub model v1 option (required)\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Customizing CLI Flag Prefix in Pydantic Settings (Python)\nDESCRIPTION: Demonstrates how to change the CLI flag prefix character used in optional arguments by setting the 'cli_flag_prefix_char' parameter in a Pydantic Settings class.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom pydantic import AliasChoices, Field\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_flag_prefix_char='+'):\n    my_arg: str = Field(validation_alias=AliasChoices('m', 'my-arg'))\n\n\nsys.argv = ['example.py', '++my-arg', 'hi']\nprint(Settings().model_dump())\n#> {'my_arg': 'hi'}\n\nsys.argv = ['example.py', '+m', 'hi']\nprint(Settings().model_dump())\n#> {'my_arg': 'hi'}\n```\n\n----------------------------------------\n\nTITLE: Suppressing Fields from CLI Help Text in Pydantic Settings (Python)\nDESCRIPTION: Shows how to use the 'CliSuppress' annotation and 'CLI_SUPPRESS' constant to hide specific fields from the CLI help text in a Pydantic Settings class.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom pydantic import Field\n\nfrom pydantic_settings import CLI_SUPPRESS, BaseSettings, CliSuppress\n\n\nclass Settings(BaseSettings, cli_parse_args=True):\n    \"\"\"Suppress fields from CLI help text.\"\"\"\n\n    field_a: CliSuppress[int] = 0\n    field_b: str = Field(default=1, description=CLI_SUPPRESS)\n\n\ntry:\n    sys.argv = ['example.py', '--help']\n    Settings()\nexcept SystemExit as e:\n    print(e)\n    #> 0\n\"\"\"\nusage: example.py [-h]\n\nSuppress fields from CLI help text.\n\noptions:\n  -h, --help          show this help message and exit\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Secret Directories in Pydantic Settings (Python)\nDESCRIPTION: Shows how to configure Pydantic Settings to load secrets from multiple directories, with values from subsequent paths overriding previous ones.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    # files in '/run/secrets' take priority over '/var/run'\n    model_config = SettingsConfigDict(secrets_dir=('/var/run', '/run/secrets'))\n\n    database_password: str\n```\n\n----------------------------------------\n\nTITLE: Example pyproject.toml Configuration File\nDESCRIPTION: A sample pyproject.toml configuration file that defines settings at the root level and in different table sections for use with PyprojectTomlConfigSettingsSource.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_45\n\nLANGUAGE: toml\nCODE:\n```\nfield = \"root\"\n\n[tool.pydantic-settings]\nfield = \"default-table\"\n\n[tool.some-table]\nfield = \"some-table\"\n```\n\n----------------------------------------\n\nTITLE: Disabling default value validation in BaseSettings\nDESCRIPTION: Examples of disabling validation of default values in BaseSettings, either globally or for specific fields.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import Field\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(validate_default=False)\n\n    # default won't be validated\n    foo: int = 'test'\n\n\nprint(Settings())\n#> foo='test'\n\n\nclass Settings1(BaseSettings):\n    # default won't be validated\n    foo: int = Field('test', validate_default=False)\n\n\nprint(Settings1())\n#> foo='test'\n```\n\n----------------------------------------\n\nTITLE: Enabling case-sensitive environment variable names in BaseSettings\nDESCRIPTION: Example of making environment variable names case-sensitive in a BaseSettings class, including behavior with nested models.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport os\n\nfrom pydantic import BaseModel, ValidationError\n\nfrom pydantic_settings import BaseSettings\n\n\nclass RedisSettings(BaseModel):\n    host: str\n    port: int\n\n\nclass Settings(BaseSettings, case_sensitive=True):\n    redis: RedisSettings\n\n\nos.environ['redis'] = '{\"host\": \"localhost\", \"port\": 6379}'\nprint(Settings().model_dump())\n#> {'redis': {'host': 'localhost', 'port': 6379}}\nos.environ['redis'] = '{\"HOST\": \"localhost\", \"port\": 6379}'  # (1)!\ntry:\n    Settings()\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Settings\n    redis.host\n      Field required [type=missing, input_value={'HOST': 'localhost', 'port': 6379}, input_type=dict]\n        For further information visit https://errors.pydantic.dev/2/v/missing\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Disabling JSON Parsing with NoDecode\nDESCRIPTION: Example showing how to disable automatic JSON parsing for specific fields using NoDecode annotation.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom typing import Annotated\n\nfrom pydantic import field_validator\n\nfrom pydantic_settings import BaseSettings, NoDecode\n\n\nclass Settings(BaseSettings):\n    numbers: Annotated[list[int], NoDecode]\n\n    @field_validator('numbers', mode='before')\n    @classmethod\n    def decode_numbers(cls, v: str) -> list[int]:\n        return [int(x) for x in v.split(',')]\n```\n\n----------------------------------------\n\nTITLE: Nested Model Default Partial Updates\nDESCRIPTION: Demonstrates how to configure partial updates for nested model defaults using the nested_model_default_partial_update flag.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport os\n\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass SubModel(BaseModel):\n    val: int = 0\n    flag: bool = False\n\n\nclass SettingsPartialUpdate(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_nested_delimiter='__', nested_model_default_partial_update=True\n    )\n\n    nested_model: SubModel = SubModel(val=1)\n\n\nclass SettingsNoPartialUpdate(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_nested_delimiter='__', nested_model_default_partial_update=False\n    )\n\n    nested_model: SubModel = SubModel(val=1)\n```\n\n----------------------------------------\n\nTITLE: Basic Environment File Configuration in Python\nDESCRIPTION: Example of a basic .env file configuration showing environment variable declarations\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_11\n\nLANGUAGE: plaintext\nCODE:\n```\nENVIRONMENT=\"production\"\nREDIS_ADDRESS=localhost:6379\nMEANING_OF_LIFE=42\nMY_VAR='Hello world'\n```\n\n----------------------------------------\n\nTITLE: Settings with Extra Fields Configuration\nDESCRIPTION: Demonstrates configuring settings to ignore extra fields for compatibility with pydantic 1.x\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(env_file='.env', extra='ignore')\n```\n\n----------------------------------------\n\nTITLE: Customizing CLI Settings Priority\nDESCRIPTION: Shows how to customize the priority of CLI settings relative to other settings sources\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nimport os\nimport sys\n\nfrom pydantic_settings import (\n    BaseSettings,\n    CliSettingsSource,\n    PydanticBaseSettingsSource,\n)\n\n\nclass Settings(BaseSettings):\n    my_foo: str\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        return env_settings, CliSettingsSource(settings_cls, cli_parse_args=True)\n```\n\n----------------------------------------\n\nTITLE: Customizing CLI Program Name in Pydantic Settings\nDESCRIPTION: Shows how to change the default program name displayed in the CLI help text by setting the cli_prog_name parameter. This allows for more user-friendly CLI interfaces.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_prog_name='appdantic'):\n    pass\n\n\ntry:\n    sys.argv = ['example.py', '--help']\n    Settings()\nexcept SystemExit as e:\n    print(e)\n    #> 0\n\"\"\"\nusage: appdantic [-h]\n\noptions:\n  -h, --help  show this help message and exit\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Installing pydantic-settings via pip\nDESCRIPTION: Command to install the pydantic-settings library using pip.\nSOURCE: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install pydantic-settings\n```"
  }
]