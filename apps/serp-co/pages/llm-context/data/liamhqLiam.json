[
  {
    "owner": "liam-hq",
    "repo": "liam",
    "content": "TITLE: Generating ERD from Schema with Liam CLI\nDESCRIPTION: Uses the `npx` command to execute the Liam CLI's `erd build` command. It requires an input schema file specified by `<path|url>` and generates interactive ERD visualization files in the `dist` directory by default. The schema format is auto-detected but can be overridden with `--format`, and the output directory can be changed using `--output-dir`.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/cli/index.mdx#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpx @liam-hq/cli erd build --input <path|url>\n```\n\n----------------------------------------\n\nTITLE: Generating ER Diagram for Prisma Schema with Liam CLI\nDESCRIPTION: This code snippet demonstrates how to run the Liam CLI command to generate an ER diagram from a Prisma schema file, specifying the format and input path. It assumes you have installed the Liam CLI and Prisma schema appropriately. The command outputs an ER diagram if successful.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/parser/supported-formats/prisma.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx @liam-hq/cli erd build --format prisma --input prisma/schema.prisma\n```\n\n----------------------------------------\n\nTITLE: Exporting PostgreSQL Schema using pg_dump (Bash)\nDESCRIPTION: Exports the schema definition (tables, views, etc.) from a PostgreSQL database into a SQL file using the `pg_dump` utility. The `--schema-only` flag excludes data, and `--file` specifies the output path. A valid PostgreSQL connection string is required.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/parser/supported-formats/postgresql.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npg_dump --schema-only --file=schema.sql postgres://username:password@hostname:5432/dbname\n```\n\n----------------------------------------\n\nTITLE: Automating ER Diagram Build and Deploy to GitHub Pages (YAML)\nDESCRIPTION: This GitHub Actions workflow defines a job to automatically generate a Liam ER diagram from a Ruby schema file (`./db/schema.rb`) and deploy the resulting static site to GitHub Pages on every push to the `main` branch. It requires checking out the code, installing the Liam CLI, building the diagram, and using the `actions-gh-pages` action for deployment. The `--format=schemarb` option specifies the input schema format.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/cli/ci-cd.mdx#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\nname: Deploy ERD on every commit\n\non:\n  push:\n    branches:\n      - main\n    # If you only want to trigger this when the schema file is updated:\n    # paths:\n    #   - db/schema.rb\n    #   - db/structure.sql\n    #   - prisma/schema.prisma\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      # 1. Install the Liam ERD CLI\n      - name: Install Liam ERD CLI\n        run: npm install -g @liam-hq/cli\n\n      # 2. Generate the ER diagram\n      - name: Generate ER Diagram\n        # You can specify a custom output directory with --output-dir option if needed\n        run: liam erd build --input ./db/schema.rb --format=schemarb\n\n      # 3. Publish the build artifacts (dist folder) to a static hosting service\n      #    Here, we show an example using GitHub Pages.\n      # NOTE: To keep your GitHub Pages site private, \n      # your organization must be on GitHub Enterprise Cloud.\n      - name: Deploy to GitHub Pages\n        uses: actions-gh-pages/action@v2\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: dist\n```\n\n----------------------------------------\n\nTITLE: Generating schema.json from MySQL database using tbls CLI (Shell)\nDESCRIPTION: This script demonstrates how to use the 'tbls' command-line tool to connect to a MySQL database and generate a JSON schema file named 'schema.json'. It requires database credentials, hostname, port, and database name, which users must replace with their own details.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/parser/supported-formats/mysql.mdx#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ntbls out -t json -o schema.json \"mysql://dbuser:dbpass@hostname:3306/dbname\"\n```\n\n----------------------------------------\n\nTITLE: Generating BigQuery Schema JSON with tbls (Bash)\nDESCRIPTION: This command uses the `tbls` CLI tool to connect to a specified BigQuery dataset, extract its schema, and output it as a JSON file. It requires `tbls` to be installed and Google Cloud authentication (via `GOOGLE_APPLICATION_CREDENTIALS`) to be set up. Replace `project-id` and `dataset-id` with your specific details.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/parser/supported-formats/bigquery.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntbls out -t json -o schema.json \"bigquery://project-id/dataset-id\"\n```\n\n----------------------------------------\n\nTITLE: Generating schema.json from MSSQL Database using tbls (Bash command)\nDESCRIPTION: This snippet demonstrates how to generate a schema.json file from an MSSQL database using the 'tbls' command-line tool. It requires database connection details such as username, password, hostname, port, and database name. The output JSON schema can be used for documentation or visualization in Liam.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/parser/supported-formats/mssql.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntbls out -t json -o schema.json \"mssql://dbuser:dbpass@hostname:1433/dbname\"\n```\n\n----------------------------------------\n\nTITLE: Generating SQLite Schema with tbls (Bash)\nDESCRIPTION: This snippet demonstrates how to use the tbls tool to export the schema of a SQLite database to a JSON file. It requires tbls to be installed on your system. You must replace the path in the connection string (\"/path/to/dbname.db\") with the path to your own SQLite database file. The generated output file, schema.json, will contain the complete schema representation in JSON format compatible with later steps. Only schema extraction is performed here, not any modification or interrogation of database contents.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/parser/supported-formats/sqlite.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntbls out -t json -o schema.json \"sqlite:///path/to/dbname.db\"\n```\n\n----------------------------------------\n\nTITLE: Extracting PostgreSQL Schema with pg_dump (Bash)\nDESCRIPTION: Uses the `pg_dump` command-line utility to extract the database schema from a PostgreSQL instance. The command includes options to output only the schema (`--schema-only`), exclude privileges (`--no-privileges`) and ownership information (`--no-owner`), saving the output to a specified file (`schema.sql`). Requires PostgreSQL client utilities installed and access to the database.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/parser/supported-formats/django.mdx#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\npg_dump --schema-only --no-privileges --no-owner --file=schema.sql postgres://username:password@localhost:5432/your_database_name\n```\n\n----------------------------------------\n\nTITLE: Defining Django ORM Models (Python)\nDESCRIPTION: Defines database models using Django's Object-Relational Mapper (ORM). The `Author` and `Post` classes represent database tables with defined fields and relationships (ForeignKey), enabling schema definition through Python classes.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/parser/supported-formats/django.mdx#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n# models.py\nfrom django.db import models\n\nclass Author(models.Model):\n    name = models.CharField(max_length=100)\n    email = models.EmailField(unique=True)\n    \n    def __str__(self):\n        return self.name\n\nclass Post(models.Model):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    created_at = models.DateTimeField(auto_now_add=True)\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='posts')\n    \n    def __str__(self):\n        return self.title\n```\n\n----------------------------------------\n\nTITLE: Applying Django Database Migrations (Bash)\nDESCRIPTION: Executes Django management commands to generate migration files based on model changes (`makemigrations`) and apply those migrations to the configured database (`migrate`). This synchronizes the database schema with the defined Django models.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/parser/supported-formats/django.mdx#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\npython manage.py makemigrations\npython manage.py migrate\n```\n\n----------------------------------------\n\nTITLE: Building ER Diagram from PostgreSQL Schema with Liam CLI (npm/npx)\nDESCRIPTION: Uses the Liam CLI, invoked via `npx`, to generate an Entity-Relationship (ER) diagram from a PostgreSQL schema file. The `--input` flag points to the previously generated SQL file (e.g., `schema.sql`), and `--format postgres` specifies that the input is a PostgreSQL schema dump.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/parser/supported-formats/postgresql.mdx#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpx @liam-hq/cli erd build --format postgres --input schema.sql\n```\n\n----------------------------------------\n\nTITLE: Building ER Diagram with Liam CLI (Bash)\nDESCRIPTION: Executes the Liam CLI command to build an Entity-Relationship Diagram. It specifies the input format as `postgres` and provides the path to the extracted `schema.sql` file as the input source, generating an ER diagram based on the defined database schema. Requires the Liam CLI to be installed.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/parser/supported-formats/django.mdx#_snippet_4\n\nLANGUAGE: Bash\nCODE:\n```\nnpx @liam-hq/cli erd build --format postgres --input schema.sql\n```\n\n----------------------------------------\n\nTITLE: Building ER Diagram from tbls Output using Liam CLI (Bash)\nDESCRIPTION: This command uses the Liam CLI (`@liam-hq/cli`) to build an Entity-Relationship Diagram (`erd build`). It specifies the input format as `tbls` and provides the path to the `schema.json` file generated by `tbls` as the input. This command requires Node.js/npm and the `@liam-hq/cli` package to be installed.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/parser/supported-formats/bigquery.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx @liam-hq/cli erd build --format=tbls --input schema.json\n```\n\n----------------------------------------\n\nTITLE: Generating tbls JSON Schema Output Using Bash\nDESCRIPTION: This snippet demonstrates the command to generate a JSON representation of the database schema using tbls CLI. It requires tbls to be installed and configured to connect to the target database. The output file 'schema.json' contains the full schema data, which can be used as input for ER diagram generation tools. The command is executed in a standard shell environment.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/parser/supported-formats/tbls.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntbls out -t json schema.json\n```\n\n----------------------------------------\n\nTITLE: Importing tbls Schema into Liam CLI (Bash)\nDESCRIPTION: This snippet shows how to invoke the Liam CLI tool to process a schema.json file—generated previously with tbls—into the ERD build workflow. It assumes that Node.js and the @liam-hq/cli package are accessible via npx. The --format=tbls argument specifies that the input format matches the output of tbls, and --input provides the file path. No database credentials are required at this step since the process operates on the static schema.json file. Ensure you have generated the file in the previous step before running this command.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/parser/supported-formats/sqlite.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx @liam-hq/cli erd build --format=tbls --input schema.json\n```\n\n----------------------------------------\n\nTITLE: Automating ER Diagram Generation with tbls and Liam via GitHub Actions\nDESCRIPTION: A GitHub Actions workflow YAML that demonstrates a CI/CD pipeline to automatically generate and deploy ER diagrams from the database schema. It triggers on pushes to main, checks out the repository, sets up tbls via an action, generates the JSON schema file, builds the ER diagram using Liam CLI, and then deploys the generated diagram to GitHub Pages. It assumes the presence of an appropriate GitHub token secret and that the 'dist' directory holds the output.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/parser/supported-formats/tbls.mdx#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nname: Generate ERD from tbls\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Setup tbls\n        uses: k1low/setup-tbls@v1\n\n      - name: Generate tbls JSON\n        run: tbls out -t json schema.json\n\n      - name: Generate ER Diagram\n        run: npx @liam-hq/cli erd build --input schema.json --format tbls\n\n      # Deploy (example using GitHub Pages)\n      - name: Deploy to GitHub Pages\n        uses: actions-gh-pages/action@v2\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: dist\n```\n\n----------------------------------------\n\nTITLE: Building ER Diagram from tbls JSON with Liam ERD CLI\nDESCRIPTION: This command uses the Liam ERD CLI to generate an ER diagram from a tbls-generated JSON schema file. It requires Node.js and the '@liam-hq/cli' package installed or accessible via npx. The '--format tbls' flag specifies input format compliance, and '--input schema.json' points to the source JSON file. Output files are generated under the 'dist' directory by default if successful.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/parser/supported-formats/tbls.mdx#_snippet_1\n\nLANGUAGE: package-install\nCODE:\n```\nnpx @liam-hq/cli erd build --format tbls --input schema.json\n```\n\n----------------------------------------\n\nTITLE: Building ER diagram with Liam CLI using generated schema (JavaScript)\nDESCRIPTION: This command uses the Liam CLI via npx to create an ER diagram from the JSON schema generated by 'tbls'. It specifies the format as 'tbls' and provides the input JSON file. This step transforms schema documentation into visualizations.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/parser/supported-formats/mysql.mdx#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nnpx @liam-hq/cli erd build --format=tbls --input schema.json\n```\n\n----------------------------------------\n\nTITLE: Configuring Django Database Connection (Python)\nDESCRIPTION: Configures the database settings for a Django project to connect to a PostgreSQL instance. Specifies the database engine, name, user, password, host, and port required for the connection. This allows Django to manage the database schema.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/parser/supported-formats/django.mdx#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n# settings.py\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql',\n        'NAME': 'your_database_name',\n        'USER': 'your_database_user',\n        'PASSWORD': 'your_database_password',\n        'HOST': 'localhost',\n        'PORT': '5432',\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Liam CLI to build ERD from schema.json (Npx command)\nDESCRIPTION: This snippet shows how to invoke Liam's CLI via npx to build an entity-relationship diagram (ERD) from the previously generated schema.json using the 'tbls' format. The --format and --input flags specify the schema source and format, respectively.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/parser/supported-formats/mssql.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx @liam-hq/cli erd build --format=tbls --input schema.json\n```\n\n----------------------------------------\n\nTITLE: Adding NOT NULL Constraints Safely in Postgres SQL\nDESCRIPTION: Provides an SQL example for adding a `NOT NULL` constraint to an existing table column within a Supabase migration. It first adds the column as nullable, then updates existing rows (potentially deriving values from related tables), and finally applies the `NOT NULL` constraint, all wrapped within a transaction (BEGIN/COMMIT) for atomicity to ensure data integrity.\nSOURCE: https://github.com/liam-hq/liam/blob/main/docs/migrationOpsContext.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nBEGIN;\n\n-- Add the column as nullable first\nALTER TABLE \"public\".\"table_name\"\nADD COLUMN \"new_column\" uuid REFERENCES \"public\".\"referenced_table\"(\"id\") ON UPDATE CASCADE ON DELETE RESTRICT;\n\n-- Update existing rows with values from a related table\nUPDATE \"public\".\"table_name\" tn\nSET \"new_column\" = (\n  SELECT rt.\"id\" \n  FROM \"public\".\"referenced_table\" rt\n  JOIN \"public\".\"join_table\" jt ON rt.\"id\" = jt.\"referenced_id\"\n  WHERE jt.\"table_id\" = tn.\"id\"\n  LIMIT 1\n);\n\n-- Now make the column NOT NULL\nALTER TABLE \"public\".\"table_name\"\nALTER COLUMN \"new_column\" SET NOT NULL;\n\nCOMMIT;\n```\n\n----------------------------------------\n\nTITLE: Testing the Liam CLI with pnpm - Bash\nDESCRIPTION: This snippet demonstrates how to execute the test suite for the @liam-hq/cli using the pnpm package manager. It assumes pnpm is installed and configured in your development environment. Running this command initiates defined CLI tests to ensure core functionality is working; the expected output is a test summary. No extra parameters are required beyond a working installation and necessary dependencies.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/packages/cli/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm run test\n```\n\n----------------------------------------\n\nTITLE: Interactively Initializing Liam ERD Configuration (Bash)\nDESCRIPTION: This command runs the `init` command of the Liam ERD CLI using `npx`. It provides an interactive process to help users set up their Liam ERD configuration, including specifying input schema files and formats, and can also generate sample GitHub Actions workflows. This is a recommended starting point for new users.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/cli/ci-cd.mdx#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\nnpx @liam-hq/cli init\n```\n\n----------------------------------------\n\nTITLE: Running the Built CLI Locally for ERD Generation - Bash\nDESCRIPTION: This code snippet shows how to invoke the local Liam CLI build to generate an ER diagram. It assumes the CLI is already built, and the example uses the command 'erd build' with specified options: '--input ./fixtures/input.schema.rb' for the test schema and '--format schemarb' to specify the schema format. The command outputs the results to the working directory; input and output file dependencies must exist. Designed for local development and troubleshooting CLI execution.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/packages/cli/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnode ./dist-cli/bin/cli.js erd build --input ./fixtures/input.schema.rb --format schemarb\n```\n\n----------------------------------------\n\nTITLE: Generating ER Diagram for Multiple Prisma Schema Files\nDESCRIPTION: This snippet shows how to generate an ER diagram when using multiple Prisma schema files within a folder by specifying a glob pattern. It enables the inclusion of all `.prisma` files in the directory, providing flexibility for multi-file Prisma schemas.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/parser/supported-formats/prisma.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx @liam-hq/cli erd build --format prisma --input \"prisma/schema/*.prisma\"\n```\n\n----------------------------------------\n\nTITLE: Building the Liam CLI for Development - Bash\nDESCRIPTION: This snippet demonstrates how to build the Liam CLI codebase using pnpm for development. It compiles the command-line tool, outputting the executable to 'dist-cli/bin/cli.js.' This process requires Node.js, pnpm, and all package dependencies. No parameters are needed. The main limitation is that this only builds a development version; exporting or deploying for production would need extra steps.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/packages/cli/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm run build\n# The executable will be output to dist-cli/bin/cli.js.\n```\n\n----------------------------------------\n\nTITLE: Automating ER Diagram Build and Deploy to Cloudflare Pages (YAML)\nDESCRIPTION: This GitHub Actions workflow demonstrates how to automate the generation of a Liam ER diagram from a Prisma schema file (`prisma/schema.prisma`) and deploy it to Cloudflare Pages using the `wrangler-action`. The workflow is triggered on pushes to `main` that modify `prisma/schema.prisma`. It requires Cloudflare API tokens and account ID, typically stored as GitHub Secrets, and uses the `--format prisma` option.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/cli/ci-cd.mdx#_snippet_2\n\nLANGUAGE: YAML\nCODE:\n```\nname: Deploy ERD (Prisma) to Cloudflare Pages\n\non:\n  push:\n    branches:\n      - main\n    # NOTE: If you only want to trigger this when the schema file is updated:\n    paths:\n      - prisma/schema.prisma\n\njobs:\n  build-and-deploy-erd:\n    runs-on: ubuntu-latest\n\n    permissions:\n      contents: read\n      deployments: write\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Generate ER Diagrams\n        # You can specify a custom output directory with --output-dir option if needed\n        run: npx @liam-hq/cli erd build --input prisma/schema.prisma --format prisma\n      - name: Deploy ERD to Cloudflare Pages\n        uses: cloudflare/wrangler-action@v3\n        with:\n          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN_SAMPLE_PRISMA }}\n          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID_SAMPLE_PRISMA }}\n          command: pages deploy ./dist --project-name=prisma-with-cloudflare-pages\n          gitHubToken: ${{ secrets.GITHUB_TOKEN }}\n```\n\n----------------------------------------\n\nTITLE: Creating Trigger Function for Organization ID Check in PostgreSQL\nDESCRIPTION: This SQL code defines a trigger function `ensure_doc_file_path_organization_matches_project` and a trigger `trg_doc_file_paths_ensure_org_match` to ensure that the `organization_id` in the `doc_file_paths` table matches the `organization_id` of the related project in the `projects` table. It is used to maintain data consistency across tables, raising an exception if the IDs do not match during insert or update operations. The trigger is executed before each row is inserted or updated in `doc_file_paths`.\nSOURCE: https://github.com/liam-hq/liam/blob/main/docs/schemaPatterns.md#_snippet_1\n\nLANGUAGE: SQL\nCODE:\n```\n-- Example: doc_file_paths.organization_id must equal projects.organization_id\ncreate or replace function ensure_doc_file_path_organization_matches_project()\nreturns trigger as $$\ndeclare\n  project_org_id uuid;\nbegin\n  select organization_id\n    into project_org_id\n    from projects\n   where id = new.project_id;\n\n  if project_org_id is null then\n    raise exception 'Project (id=%) does not exist', new.project_id;\n  end if;\n\n  if new.organization_id is distinct from project_org_id then\n    raise exception\n      'organization_id mismatch: doc_file_paths.organization_id (%) must match project.organization_id (%)',\n      new.organization_id, project_org_id;\n  end if;\n\n  return new;\nend;\n$$ language plpgsql;\n\ncreate trigger trg_doc_file_paths_ensure_org_match\nbefore insert or update on doc_file_paths\nfor each row execute function ensure_doc_file_path_organization_matches_project();\n```\n\n----------------------------------------\n\nTITLE: Serving Generated Liam ERD Files Locally\nDESCRIPTION: Uses `npx` to run the `http-server` package, serving the contents of the `dist` directory (or a custom output directory specified during generation) on a local HTTP server. This allows viewing the generated ERD in a web browser, typically at http://localhost:8080.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/cli/index.mdx#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnpx http-server dist  # or your custom output directory\n```\n\n----------------------------------------\n\nTITLE: Initializing Liam ERD Project with CLI\nDESCRIPTION: Uses the `npx` command to run the Liam CLI's interactive `init` command for a quick project setup. This command guides the user through the initial configuration process.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/cli/index.mdx#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpx @liam-hq/cli init\n```\n\n----------------------------------------\n\nTITLE: Creating Policy for Project Inserts in PostgreSQL\nDESCRIPTION: This SQL code creates a row-level security policy named `authenticated_users_can_insert_projects` on the `public.projects` table, allowing authenticated users to insert new project records only if their `organization_id` matches one they are a member of. It uses a subquery to check the user's organization membership against the `organization_members` table and applies to the `authenticated` role. The policy includes a comment explaining its purpose.\nSOURCE: https://github.com/liam-hq/liam/blob/main/docs/schemaPatterns.md#_snippet_0\n\nLANGUAGE: SQL\nCODE:\n```\ncreate policy authenticated_users_can_insert_projects\n  on public.projects\n  for insert to authenticated\n  with check (\n    organization_id in (\n      select organization_members.organization_id\n      from public.organization_members\n      where organization_members.user_id = auth.uid()\n    )\n  );\n\ncomment on policy authenticated_users_can_insert_projects\n  on public.projects is\n  'Authenticated users can create projects within their organization';\n```\n\n----------------------------------------\n\nTITLE: Generating ERD from GitHub File URL with Liam CLI\nDESCRIPTION: Demonstrates generating an ERD directly from a schema file located in a public GitHub repository using its standard web URL. The `--format` option is used to explicitly specify the schema format as 'postgres' since auto-detection might be less reliable with web URLs.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/cli/index.mdx#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nnpx @liam-hq/cli erd build --input https://github.com/user/repo/blob/main/examples/schema.sql --format postgres\n```\n\n----------------------------------------\n\nTITLE: Generating ERD from GitHub Raw File URL with Liam CLI\nDESCRIPTION: Shows generating an ERD using the raw file URL from a public GitHub repository. This often provides a more direct way to access the file content compared to the standard GitHub file view URL. The `--format` option specifies the schema format as 'postgres'.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/cli/index.mdx#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nnpx @liam-hq/cli erd build --input https://raw.githubusercontent.com/user/repo/main/examples/schema.sql --format postgres\n```\n\n----------------------------------------\n\nTITLE: Creating Sample Table in PostgreSQL\nDESCRIPTION: This SQL code creates a sample table named `books` within the `public` schema. The table includes columns for `id` (UUID primary key), `title` (text, not null), and `author_id` (UUID, foreign key referencing the `authors` table). A comment is added to describe the purpose of the table as a list of books in the library.\nSOURCE: https://github.com/liam-hq/liam/blob/main/docs/schemaPatterns.md#_snippet_2\n\nLANGUAGE: SQL\nCODE:\n```\ncreate table public.books (\n  id         uuid primary key default gen_random_uuid(),\n  title      text      not null,\n  author_id  uuid      references public.authors (id)\n);\ncomment on table public.books is\n  'A list of all the books in the library.';\n```\n\n----------------------------------------\n\nTITLE: Defining MCP Server Configuration in mcp.json for Cursor IDE (JSON)\nDESCRIPTION: This snippet shows a sample 'mcp.json' configuration for Cursor IDE integration, specifying an MCP server with its command and launch arguments. Users must replace placeholder paths for 'node' and the MCP server's index.ts file with actual values from their environment. The structure enables Cursor IDE to correctly launch and connect to the Liam MCP server, and the configuration should be placed in the '.cursor/mcp.json' file at the project root. No external dependencies are needed aside from valid Node.js and MCP server paths.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/internal-packages/mcp-server/README.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"mcpServers\": {\n    \"liam-development-mcp-server\": {\n      \"command\": \"/path/to/your/node\",\n      \"args\": [\n        \"--experimental-strip-types\",\n        \"/path/to/your/liam/frontend/internal-packages/mcp-server/src/index.ts\"\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Liam CLI for Private Repo (Bash)\nDESCRIPTION: This command initializes the Liam ERD Command Line Interface for use with *private* repositories. It uses `npx` to execute the `@liam-hq/cli` package, launching an interactive setup process. This process typically guides the user through connecting Liam to their private database or schema source.\nSOURCE: https://github.com/liam-hq/liam/blob/main/README.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\nnpx @liam-hq/cli init\n```\n\n----------------------------------------\n\nTITLE: Linking the Liam CLI Globally with pnpm - Bash\nDESCRIPTION: This snippet installs the CLI tool globally using pnpm, making it available system-wide as the executable 'liam.' pnpm and relevant npm permissions are required. Once linked, 'liam' can be used as a global command in any shell. This approach is primarily for development or advanced workflows that need the CLI accessible outside of the local project directory.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/packages/cli/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npnpm link --global\n```\n\n----------------------------------------\n\nTITLE: Installing MCP Server Dependencies with pnpm in Bash\nDESCRIPTION: This Bash command runs 'pnpm install' to install all dependencies for the Liam monorepo, including the MCP server package. There are no additional parameters required, but the 'pnpm' package manager must be installed on the system before use. The command should be executed from the project root and prepares the environment for further MCP server configuration.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/internal-packages/mcp-server/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Constructing Liam URL for Public Repo (URL Pattern)\nDESCRIPTION: This snippet demonstrates the pattern for generating a Liam ERD URL for a schema file in a *public* GitHub repository. It shows how to prepend `liambx.com/erd/p/` to the raw URL of the schema file (e.g., a Ruby `.rb` file). This modified URL can be opened in a web browser to view the diagram.\nSOURCE: https://github.com/liam-hq/liam/blob/main/README.md#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\n# Original: https://github.com/user/repo/blob/master/db/schema.rb\n# Modified: https://liambx.com/erd/p/github.com/user/repo/blob/master/db/schema.rb\n```\n\n----------------------------------------\n\nTITLE: Locating Node.js Executable Path in Bash\nDESCRIPTION: This Bash command prints the filesystem path to the locally installed Node.js executable. This information is required for configuration in the mcp.json file to ensure that Cursor IDE can launch the MCP server. The command requires Bash and a previously installed Node.js binary present in the environment's PATH.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/internal-packages/mcp-server/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nwhich node\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with PNPM\nDESCRIPTION: Commands to enable corepack, prepare it, and install all project dependencies using PNPM.\nSOURCE: https://github.com/liam-hq/liam/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncorepack enable\ncorepack prepare\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Updating VRT Snapshots Locally (Bash)\nDESCRIPTION: Updates the baseline snapshot images used for Visual Regression Testing. This command should be run when UI changes are intentional. It requires setting the `URL` environment variable to the local development server address and specifies the VRT test suite and the `--update-snapshots` flag for Playwright.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/packages/e2e/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nURL=http://localhost:5173 pnpm playwright test tests/vrt --update-snapshots\n```\n\n----------------------------------------\n\nTITLE: Cloning the Liam Repository\nDESCRIPTION: Command to clone the Liam project repository from GitHub to your local machine.\nSOURCE: https://github.com/liam-hq/liam/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngit clone https://github.com/liam-hq/liam\n```\n\n----------------------------------------\n\nTITLE: Visualizing Onboarding Flow with Mermaid\nDESCRIPTION: A flowchart diagram that illustrates the complete onboarding process for Liam, including user actions, GitHub app installation, and migration review steps. Shows the relationship between human users, the Liam Migration system, and GitHub App integration.\nSOURCE: https://github.com/liam-hq/liam/blob/main/docs/liam-migration-v1/product-required-document.md#_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TB\n    subgraph Onboarding Flow\n        subgraph Human\n            A[Sign‑up]\n            L[Create Project]\n            C[Select schema & migration files]\n            E[Select / input related information]\n        end\n        subgraph \"Liam Migration\"\n            H[Success]\n            D[Generate ERD]\n            F[Update ERD]\n            G[Update Project Rules]\n            I[Run review on latest merged PR containing schema files]\n            K[Go to Migration Review page]\n        end\n        subgraph \"GitHub App\"\n            B[Install GitHub App]\n            J[Review comment on PR]\n        end\n    A --> L\n    L --> B\n    B --> H\n    H --> C\n    C --> D\n    D --> E\n    E --> F\n    E --> G\n    F --> I\n    I --> K\n    I --> J\n    end\n```\n\n----------------------------------------\n\nTITLE: Running E2E and VRT Tests Locally (Bash)\nDESCRIPTION: Executes all end-to-end tests and visual regression tests locally using the pnpm package manager. This command triggers the test suite defined in the project, including snapshot comparisons for VRT.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/packages/e2e/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm test:e2e\n```\n\n----------------------------------------\n\nTITLE: Importing UI components from lucide-react and fumadocs-ui\nDESCRIPTION: Imports specific React components used for visual elements and tabbed interface within the documentation page. The imported components facilitate UI rendering and user interactions, such as icons and tabs.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/index.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { Package, Globe } from \"lucide-react\";\nimport { Tab, Tabs } from 'fumadocs-ui/components/tabs';\n```\n\n----------------------------------------\n\nTITLE: Importing Source Module in JavaScript (React)\nDESCRIPTION: This snippet imports the 'source' module from a local library path using ES6 import syntax. The 'source' object is used for retrieving content or page data elsewhere in the file. No runtime dependencies beyond the Node.js module system and project structure are required. Expected input is no parameters; expected output is the availability of named imports for further use.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/contributing/adr/index.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { source } from \"@/lib/source\"\n```\n\n----------------------------------------\n\nTITLE: Importing DocsCategory Component in JavaScript (React)\nDESCRIPTION: This snippet imports the 'DocsCategory' React component from the 'fumadocs-ui' library. This component is intended for rendering a category of documentation within a React application. It assumes that 'fumadocs-ui/page' is installed as a dependency and available in the project module resolution path.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/contributing/adr/index.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { DocsCategory } from \"fumadocs-ui/page\"\n```\n\n----------------------------------------\n\nTITLE: Rendering DocsCategory Component in React (JavaScript)\nDESCRIPTION: This JSX snippet renders the 'DocsCategory' component within a React context, passing the current ADR documentation page data retrieved from the 'source' object. The component props include 'page', which is assigned via 'source.getPage([\"contributing\", \"adr\"])', and 'from', which provides the source object itself. The expected input is a valid page object and source context; the output is a React element rendering the targeted documentation section.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/contributing/adr/index.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\n<DocsCategory page={source.getPage([\"contributing\", \"adr\"])} from={source} />\n```\n\n----------------------------------------\n\nTITLE: Pulling Environment Variables from Vercel\nDESCRIPTION: Command to download the latest environment variables from Vercel after linking the project.\nSOURCE: https://github.com/liam-hq/liam/blob/main/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\npnpm vercel:env-pull\n```\n\n----------------------------------------\n\nTITLE: Visualizing Development Flow with Mermaid\nDESCRIPTION: A flowchart that depicts the development workflow within Liam, showing interactions between builders, reviewers, and the system. Includes PR creation, review processes, migration execution, and incident handling steps.\nSOURCE: https://github.com/liam-hq/liam/blob/main/docs/liam-migration-v1/product-required-document.md#_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TB\n    subgraph Development Flow\n        subgraph Builder User\n            A[Open PR]\n            L[Merge & Deploy PR]\n            M[Approve contents]\n            Q[Rollback migration]\n            R[Input incident info]\n        end\n        subgraph Reviewer User\n            H[Discussion via comments]\n        end\n        subgraph GitHub\n            B[\"Review comment (summary) on PR\"]\n            K[Approve PR]\n        end\n        subgraph Liam Migration\n            C[Run Review Agent]\n            subgraph D[\"Migration Review page (detail)\"]\n                E[Change summary]\n                F[Suggest cautions, concerns, checks]\n                J[Resolve findings]\n            end\n            G[Knowledge Suggestion]\n            N[Update ERD]\n            S[Save incident info]\n        end\n        subgraph \"Migration tool (e.g., Rails)\"\n            O[Execute migration]\n            P[Failure]\n        end\n\n        A --> C\n        C --> B\n        B --> D\n        C --> F\n        F --> H\n        H --> K\n        H --> J\n        J --> L\n        K --> L\n        L --> O\n        O --> P\n        P --> Q\n        Q --> R\n        R --> S\n\n        E --> G\n        F --> G\n        G --> M\n        M --> N\n    end\n```\n\n----------------------------------------\n\nTITLE: Creating Environment File from Template\nDESCRIPTION: Command for contributors to create a local environment file based on the template.\nSOURCE: https://github.com/liam-hq/liam/blob/main/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ncp .env.template .env\n```\n\n----------------------------------------\n\nTITLE: Starting the Development Server\nDESCRIPTION: Command to start the development server for local development.\nSOURCE: https://github.com/liam-hq/liam/blob/main/CONTRIBUTING.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Visualizing Infrastructure Requirements with Mermaid\nDESCRIPTION: A graph diagram showing the infrastructure architecture of the Liam system, including GitHub integration, Supabase databases, trigger.dev workers, and Vercel hosting. Depicts data flow relationships and read/write dependencies between components.\nSOURCE: https://github.com/liam-hq/liam/blob/main/docs/liam-migration-v1/product-required-document.md#_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph TD\n  subgraph GitHubApp\n    GA[GitHub App]\n  end\n\n  subgraph GitHubAPI\n    GAPI[GitHub API]\n  end\n\n  subgraph GitHub\n    GitHubApp\n    GitHubAPI\n  end\n\n  %% External User\n  U[User]\n\n  %% Infrastructure Components\n  subgraph Infrastructure\n    subgraph Supabase\n      SA1[(auth schema)]\n      SA2[(public schema)]\n    end\n    subgraph trigger.dev\n      TR1[Worker]\n      TR2[(Queue)]\n    end\n    subgraph Vercel\n      RS[Next.js app]\n    end\n  end\n\n  %% Connections\n  U -- visit --> RS\n  GA -- webhook --> RS\n  RS -- enqueue job --> TR2\n  TR2 -- dequeue --> TR1\n  TR1 -- enqueue job --> TR2\n\n  %% Additional Connections with read/write annotations\n  TR1 -.->|read/write| SA2\n  RS -.->|read/write| SA1\n  RS -.->|read/write| SA2\n\n  %% API Call\n  TR1 -- call --> GAPI\n  RS -- call --> GAPI\n```\n\n----------------------------------------\n\nTITLE: Running the test suite with pnpm\nDESCRIPTION: This command executes the test suite for the @liam-hq/prompt-test package using pnpm. It filters specifically for the @liam-hq/prompt-test package to ensure only its tests are run.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/packages/prompt-test/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm --filter=@liam-hq/prompt-test test\n```\n\n----------------------------------------\n\nTITLE: Expected VRT Snapshot Filename Example\nDESCRIPTION: Illustrates the required filename format for an updated VRT baseline snapshot image. This specific example ('top-1-chromium-linux.png') represents the baseline for the 'top' test, run on the Chromium browser under a Linux environment.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/packages/e2e/README.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\ntop-1-chromium-linux.png\n```\n\n----------------------------------------\n\nTITLE: Directory for VRT Snapshot Updates\nDESCRIPTION: Specifies the designated directory path within the project structure where updated and correctly renamed VRT baseline snapshot images should be placed before committing.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/packages/e2e/README.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nfrontend/packages/e2e/tests/vrt/vrt.test.ts-snapshots/\n```\n\n----------------------------------------\n\nTITLE: Updating Schema and Types After Supabase Migration\nDESCRIPTION: A shell command to be executed after database migrations are applied. It navigates to the database package directory (`frontend/packages/db`) and runs the `pnpm supabase:gen` script, which updates the schema definition file and generates corresponding TypeScript types based on the new database schema.\nSOURCE: https://github.com/liam-hq/liam/blob/main/docs/migrationOpsContext.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncd frontend/packages/db && pnpm supabase:gen\n```\n\n----------------------------------------\n\nTITLE: Using Correct URL Formats for Raw Content in Liam ERD Web\nDESCRIPTION: Examples of correctly formatted URLs that point directly to raw schema file content across different hosting platforms, which will work properly with Liam ERD Web.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/web/troubleshooting.mdx#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nhttps://gist.githubusercontent.com/username/gistid/raw/commitsha/filename.yml\nhttps://gitlab.com/username/repo/-/raw/main/db/schema.rb\nhttps://bitbucket.org/username/repo/raw/main/prisma.schema\n```\n\n----------------------------------------\n\nTITLE: Avoiding Incorrect URL Formats in Liam ERD Web\nDESCRIPTION: Examples of incorrectly formatted URLs that point to HTML pages rather than raw content, which will not work properly with Liam ERD Web.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/web/troubleshooting.mdx#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nhttps://gist.github.com/username/gistid\nhttps://gitlab.com/username/repo/-/blob/main/db/schema.rb\nhttps://bitbucket.org/username/repo/src/main/prisma.schema\n```\n\n----------------------------------------\n\nTITLE: Configuring robots.txt to Block All Web Crawlers\nDESCRIPTION: A robots.txt directive that instructs all web crawlers to not access any part of the website. This configuration prevents search engines and bots from indexing the site content.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/app/public/robots.txt#_snippet_0\n\nLANGUAGE: robots.txt\nCODE:\n```\nUser-Agent: *\nDisallow: /\n```\n\n----------------------------------------\n\nTITLE: Linking Project to Vercel (Maintainers Only)\nDESCRIPTION: Command for Vercel team members to link their local project to the Vercel project for environment variable access.\nSOURCE: https://github.com/liam-hq/liam/blob/main/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\npnpm vercel:link\n```\n\n----------------------------------------\n\nTITLE: Fetching Figma local variables via API in JavaScript\nDESCRIPTION: This snippet handles fetching Figma local variables using the Figma API. It requires environment variables for API access and includes request setup, API call, and response handling. It forms the basis for retrieving design tokens from Figma files to be processed further.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/packages/figma-to-css-variables/README.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst fetchFigmaVariables = async (fileKey, accessToken) => {\n    const url = `https://api.figma.com/v1/files/${fileKey}`;\n    const response = await fetch(url, {\n        headers: {\n            'X-Figma-Token': accessToken\n        }\n    });\n    const data = await response.json();\n    // Process data to extract local variables\n    return data;\n};\n```\n\n----------------------------------------\n\nTITLE: Transforming Figma variables for Style Dictionary in JavaScript\nDESCRIPTION: This snippet transforms the fetched Figma variables into a format compatible with Style Dictionary. It involves parsing the raw data, extracting relevant style tokens, and reformatting them into key-value pairs suitable for CSS variable generation or design token management.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/packages/figma-to-css-variables/README.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst transformVariablesForStyleDictionary = (variables) => {\n    const transformed = {};\n    variables.styles.forEach(style => {\n        transformed[style.name] = style.value;\n    });\n    return transformed;\n};\n```\n\n----------------------------------------\n\nTITLE: Running Style Dictionary build command in JavaScript\nDESCRIPTION: This snippet executes the Style Dictionary build process based on specified configurations and output paths. It utilizes command-line arguments to define output directories and filtering modes, enabling flexible style token generation for different themes or modes.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/packages/figma-to-css-variables/README.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst runStyleDictionary = (outputPath, filterModes) => {\n    const spawn = require('child_process').spawn;\n    const args = ['build', '--output', outputPath];\n    if (filterModes) {\n        args.push('--filter-modes', filterModes);\n    }\n    const sdProcess = spawn('style-dictionary', args);\n    sdProcess.stdout.on('data', (data) => {\n        console.log(`STDOUT: ${data}`);\n    });\n    sdProcess.stderr.on('data', (data) => {\n        console.error(`STDERR: ${data}`);\n    });\n    sdProcess.on('close', (code) => {\n        console.log(`Style Dictionary process exited with code ${code}`);\n    });\n};\n```\n\n----------------------------------------\n\nTITLE: ADR Structure in Markdown\nDESCRIPTION: The template provides a markdown structure for Architecture Decision Records with sections for title, status, context, decision, and consequences. It includes a status checklist to indicate the current state of the decision.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/contributing/adr/template.mdx#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# \\{YYYYMMDD\\} - \\{TITLE\\}\n\n## Status\n\n- [ ] Proposed\n- [x] Accepted\n- [ ] Rejected\n- [ ] Deprecated\n- [ ] Superseded\n\n## Context\n\nDescribe the background and issues that led to this decision.\n\n## Decision\n\nDescribe what was decided.\n\n## Consequences\n\nDescribe the tradeoffs (positive, negative, and neutral impacts) of this decision.\n```\n\n----------------------------------------\n\nTITLE: Running Development Server with Package Managers in Bash\nDESCRIPTION: Commands to start the Next.js development server using different package managers. After running any of these commands, the application will be available at http://localhost:3000.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n# or\npnpm dev\n# or\nyarn dev\n```\n\n----------------------------------------\n\nTITLE: Developing the ER Diagram Web App with Vite - Bash\nDESCRIPTION: This snippet runs the primary npm script for development (`pnpm dev`). The command builds the CLI, runs the CLI to generate 'schema.json' from a Ruby schema file, copies the result to the web app's 'public' directory, and then serves the application using the Vite development server. Dependencies include pnpm, Vite, the CLI build, and the fixture file. It is best suited for iterative frontend/backend development where rapid local updates are needed.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/packages/cli/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Implementing Supabase RLS Policy for Organization Projects (SQL)\nDESCRIPTION: This snippet demonstrates enabling Row-Level Security (RLS) on the 'projects' table and creating a SELECT policy. The policy restricts authenticated users ('authenticated') to selecting only those projects whose 'organization_id' is associated with organizations the user is a member of, verified by joining through the 'organization_members' table using the Supabase authentication function 'auth.uid()'. This pattern is intended to be applied to other tables requiring organization-based authorization.\nSOURCE: https://github.com/liam-hq/liam/blob/main/frontend/apps/docs/content/docs/contributing/adr/20250421-apply-rls-to-all-tables-with-organization-based-policies.mdx#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\n-- Enable RLS on the projects table\nALTER TABLE \"public\".\"projects\" ENABLE ROW LEVEL SECURITY;\n\n-- Policy for SELECT operations\nCREATE POLICY \"authenticated_users_can_select_org_projects\" ON \"public\".\"projects\" \nFOR SELECT TO \"authenticated\" \nUSING ((\"organization_id\" IN ( \n  SELECT \"organization_members\".\"organization_id\"\n  FROM \"public\".\"organization_members\"\n  WHERE (\"organization_members\".\"user_id\" = \"auth\".\"uid\"())\n)));\n\n-- Similar policies exist for INSERT, UPDATE, and DELETE operations\n```"
  }
]