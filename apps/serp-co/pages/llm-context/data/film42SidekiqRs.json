[
  {
    "owner": "film42",
    "repo": "sidekiq-rs",
    "content": "TITLE: Implementing a Worker with Typed Arguments in Rust Sidekiq\nDESCRIPTION: Demonstrates how to create a Sidekiq worker with strongly typed arguments using Serde. The example shows a payment report worker with custom options and async implementation using the Worker trait.\nSOURCE: https://github.com/film42/sidekiq-rs/blob/master/README.md#2025-04-20_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing::info;\nuse sidekiq::Result;\n\n#[derive(Clone)]\nstruct PaymentReportWorker {}\n\nimpl PaymentReportWorker {\n    fn new() -> Self {\n        Self { }\n    }\n\n    async fn send_report(&self, user_guid: String) -> Result<()> {\n        // TODO: Some actual work goes here...\n        info!({\"user_guid\" = user_guid}, \"Sending payment report to user\");\n\n        Ok(())\n    }\n}\n\n#[derive(Deserialize, Debug, Serialize)]\nstruct PaymentReportArgs {\n    user_guid: String,\n}\n\n#[async_trait]\nimpl Worker<PaymentReportArgs> for PaymentReportWorker {\n    // Default worker options\n    fn opts() -> sidekiq::WorkerOpts<Self> {\n        sidekiq::WorkerOpts::new().queue(\"yolo\")\n    }\n\n    // Worker implementation\n    async fn perform(&self, args: PaymentReportArgs) -> Result<()> {\n        self.send_report(args.user_guid).await\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Sidekiq Jobs with Typed Arguments in Rust\nDESCRIPTION: Shows three different methods for creating Sidekiq jobs: using perform_async with typed arguments, overriding options at enqueue time, and using the low-level crate method for more control.\nSOURCE: https://github.com/film42/sidekiq-rs/blob/master/README.md#2025-04-20_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nPaymentReportWorker::perform_async(\n    &mut redis,\n    PaymentReportArgs {\n        user_guid: \"USR-123\".into(),\n    },\n)\n.await?;\n```\n\nLANGUAGE: rust\nCODE:\n```\nPaymentReportWorker::opts()\n    .queue(\"brolo\")\n    .perform_async(\n        &mut redis,\n        PaymentReportArgs {\n            user_guid: \"USR-123\".into(),\n        },\n    )\n    .await?;\n```\n\nLANGUAGE: rust\nCODE:\n```\nsidekiq::perform_async(\n    &mut redis,\n    \"PaymentReportWorker\".into(),\n    \"yolo\".into(),\n    PaymentReportArgs {\n        user_guid: \"USR-123\".to_string(),\n    },\n)\n.await?;\n```\n\n----------------------------------------\n\nTITLE: Starting the Sidekiq Server in Rust\nDESCRIPTION: Demonstrates how to initialize a Sidekiq processor, register workers, add custom middleware, and start the server. The example shows connection setup with Redis and configuration of processing queues.\nSOURCE: https://github.com/film42/sidekiq-rs/blob/master/README.md#2025-04-20_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// Redis\nlet manager = sidekiq::RedisConnectionManager::new(\"redis://127.0.0.1/\").unwrap();\nlet mut redis = bb8::Pool::builder().build(manager).await.unwrap();\n\n// Sidekiq server\nlet mut p = Processor::new(\n    redis,\n    vec![\"yolo\".to_string(), \"brolo\".to_string()],\n);\n\n// Add known workers\np.register(PaymentReportWorker::new());\n\n// Custom Middlewares\np.using(FilterExpiredUsersMiddleware::new())\n    .await;\n\n// Start the server\np.run().await;\n```\n\n----------------------------------------\n\nTITLE: Implementing Database Connection Access in Sidekiq Worker\nDESCRIPTION: Shows how to implement a Sidekiq worker with access to a Redis connection pool. The worker keeps track of how many times it's been called using a Redis counter. Demonstrates proper connection sharing through Clone trait implementation.\nSOURCE: https://github.com/film42/sidekiq-rs/blob/master/README.md#2025-04-20_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing::debug;\nuse sidekiq::Result;\n\n#[derive(Clone)]\nstruct ExampleWorker {\n    redis: RedisPool,\n}\n\n\n#[async_trait]\nimpl Worker<()> for ExampleWorker {\n    async fn perform(&self, args: PaymentReportArgs) -> Result<()> {\n        use redis::AsyncCommands;\n\n        // And then they are available here...\n        let times_called: usize = self\n            .redis\n            .get()\n            .await?\n            .unnamespaced_borrow_mut()\n            .incr(\"example_of_accessing_the_raw_redis_connection\", 1)\n            .await?;\n\n        debug!({\"times_called\" = times_called}, \"Called this worker\");\n    }\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n// ...\n    let mut p = Processor::new(\n        redis.clone(),\n        vec![\"low_priority\".to_string()],\n    );\n\n    p.register(ExampleWorker{ redis: redis.clone() });\n}\n```\n\n----------------------------------------\n\nTITLE: Using Separate Redis Connection Pools for Enqueuing and Fetching Jobs\nDESCRIPTION: Demonstrates the best practice of using separate Redis connection pools for pushing jobs to Redis versus fetching jobs. This approach optimizes resource usage and prevents enqueue operations from being delayed by the processor's pool usage.\nSOURCE: https://github.com/film42/sidekiq-rs/blob/master/README.md#2025-04-20_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let manager = sidekiq::RedisConnectionManager::new(\"redis://127.0.0.1/\").unwrap();\n    let redis_enqueue = bb8::Pool::builder().build(manager).await.unwrap();\n    let redis_fetch = bb8::Pool::builder().build(manager).await.unwrap();\n\n    let p = Processor::new(\n        redis_fetch,\n        vec![\"default\".to_string()],\n    );\n    p.run().await;\n\n    // ...\n\n    ExampleWorker::perform_async(&redis_enqueue, ExampleArgs { foo: \"bar\".to_string() }).await?;\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Periodic Jobs in Rusty-Sidekiq\nDESCRIPTION: Shows how to set up periodic cron jobs with the Sidekiq.rs library. The example demonstrates clearing existing periodic jobs and registering a new one with a cron schedule, custom name, queue, and arguments.\nSOURCE: https://github.com/film42/sidekiq-rs/blob/master/README.md#2025-04-20_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// Clear out all periodic jobs and their schedules\nperiodic::destroy_all(redis).await?;\n\n// Add a new periodic job\nperiodic::builder(\"0 0 8 * * *\")?\n    .name(\"Email clients with an oustanding balance daily at 8am UTC\")\n    .queue(\"reminders\")\n    .args(EmailReminderArgs {\n        report_type: \"outstanding_balance\",\n    })?\n    .register(&mut p, EmailReminderWorker)\n    .await?;\n```\n\n----------------------------------------\n\nTITLE: Implementing Server Middleware in Rusty-Sidekiq\nDESCRIPTION: Shows how to create custom middleware for Sidekiq server processing. The example implements a middleware that filters out jobs for expired users by using Serde to conditionally type-check worker arguments.\nSOURCE: https://github.com/film42/sidekiq-rs/blob/master/README.md#2025-04-20_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing::info;\n\nstruct FilterExpiredUsersMiddleware {}\n\nimpl FilterExpiredUsersMiddleware {\n    fn new() -> Self {\n        Self { }\n    }\n}\n\n#[derive(Deserialize)]\nstruct FiltereExpiredUsersArgs {\n    user_guid: String,\n}\n\nimpl FiltereExpiredUsersArgs {\n    fn is_expired(&self) -> bool {\n        self.user_guid == \"USR-123-EXPIRED\"\n    }\n}\n\n#[async_trait]\nimpl ServerMiddleware for FilterExpiredUsersMiddleware {\n    async fn call(\n        &self,\n        chain: ChainIter,\n        job: &Job,\n        worker: Arc<WorkerRef>,\n        redis: RedisPool,\n    ) -> ServerResult {\n        // Use serde to check if a user_guid is part of the job args.\n        let args: Result<(FiltereExpiredUsersArgs,), serde_json::Error> =\n            serde_json::from_value(job.args.clone());\n\n        // If we can safely deserialize then attempt to filter based on user guid.\n        if let Ok((filter,)) = args {\n            if filter.is_expired() {\n                error!({\n                    \"class\" = job.class,\n                    \"jid\" = job.jid,\n                    \"user_guid\" = filter.user_guid },\n                    \"Detected an expired user, skipping this job\"\n                );\n                return Ok(());\n            }\n        }\n\n        // This customer is not expired, so we may continue.\n        chain.next(job, worker, redis).await\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Redis Namespaces for Sidekiq Workers in Rust\nDESCRIPTION: Shows how to implement Redis namespacing to match the common Ruby Sidekiq pattern using redis-namespace. This customizes all Redis commands to use a specific prefix, maintaining compatibility with Ruby implementations.\nSOURCE: https://github.com/film42/sidekiq-rs/blob/master/README.md#2025-04-20_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet manager = sidekiq::RedisConnectionManager::new(\"redis://127.0.0.1/\")?;\nlet redis = bb8::Pool::builder()\n    .connection_customizer(sidekiq::with_custom_namespace(\"my_cool_app\".to_string()))\n    .build(manager)\n    .await?;\n```\n\n----------------------------------------\n\nTITLE: Customizing Sidekiq Worker Name for Ruby Module Compatibility\nDESCRIPTION: Demonstrates how to customize the worker class name to match nested Ruby module naming conventions. This allows Rust workers to process jobs enqueued by Ruby code using module-namespaced worker classes.\nSOURCE: https://github.com/film42/sidekiq-rs/blob/master/README.md#2025-04-20_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\npub struct MyWorker;\nuse sidekiq::Result;\n\n#[async_trait]\nimpl Worker<()> for MyWorker {\n    async fn perform(&self, _args: ()) -> Result<()> {\n        Ok(())\n    }\n\n    fn class_name() -> String\n    where\n        Self: Sized,\n    {\n        \"Workers::MyWorker\".to_string()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Sidekiq Worker Task Concurrency\nDESCRIPTION: Shows how to customize the number of worker tasks spawned by the Sidekiq processor. Useful for IO-bound workloads to better utilize CPU resources by increasing concurrent task execution.\nSOURCE: https://github.com/film42/sidekiq-rs/blob/master/README.md#2025-04-20_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n#[tokio::main]\nasync fn main() -> Result<()> {\n    // ...\n    let num_workers = usize::from_str(&env::var(\"NUM_WORKERS\").unwrap()).unwrap();\n    let config: ProcessorConfig = Default::default();\n    let config = config.num_workers(num_workers);\n    let processor = Processor::new(redis_fetch, queues.clone())\n        .with_config(config);\n    // ...\n}\n```"
  }
]