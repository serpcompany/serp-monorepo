[
  {
    "owner": "thomhurst",
    "repo": "tunit",
    "content": "TITLE: Defining the Static Assert Class in C#\nDESCRIPTION: This defines the entry point `Assert` static class within the `TUnit.Assertions` namespace. This class contains static methods used to perform various kinds of assertions in TUnit tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n    public static class Assert\n    {\n```\n\n----------------------------------------\n\nTITLE: Structuring Complex Test Suites with TUnit [DependsOn] in C#\nDESCRIPTION: Illustrates creating a complex test suite where multiple tests (`AddUser1` to `AddUser5`, `AddItemToBagForUser1` to `AddItemToBagForUser3`) must complete before a final assertion test (`AssertItemsInDatabase`) runs. It showcases multiple `[DependsOn]` attributes on a single test method to define multiple dependencies.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/depends-on.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[Test]\npublic async Task AddUser1() \n{\n    ...\n}\n\n[Test]\npublic async Task AddUser2() \n{\n    ...\n}\n\n[Test]\npublic async Task AddUser3() \n{\n    ...\n}\n\n[Test]\npublic async Task AddUser4() \n{\n    ...\n}\n\n[Test]\npublic async Task AddUser5() \n{\n    ...\n}\n\n[Test, DependsOn(nameof(AddUser1))]\npublic async Task AddItemToBagForUser1() \n{\n    ...\n}\n\n[Test, DependsOn(nameof(AddUser2))]\npublic async Task AddItemToBagForUser2() \n{\n    ...\n}\n\n[Test, DependsOn(nameof(AddUser3))]\npublic async Task AddItemToBagForUser3() \n{\n    ...\n}\n\n[Test]\n[DependsOn(nameof(AddUser4))]\n[DependsOn(nameof(AddUser5))]\n[DependsOn(nameof(AddItemToBagForUser1))]\n[DependsOn(nameof(AddItemToBagForUser2))]\n[DependsOn(nameof(AddItemToBagForUser3))]\npublic async Task AssertItemsInDatabase() \n{\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Dynamic Test Context, Metadata, and Attributes in TUnit (C#)\nDESCRIPTION: This code snippet provides class and interface declarations for dynamic test construction, context management, attribute-driven test configuration, and generic test hooks in the TUnit test framework. Dependencies include System.Collections.Generic, System.Threading.Tasks, System.Linq.Expressions, and the TUnit.Core namespace for types like TestContext and TestMetadata. Key parameters include properties controlling test arguments, test identity, method metadata, and attribute configuration. Inputs and outputs primarily revolve around test object creation and hook invocations in the testing lifecycle. Users integrate this code with the TUnit.Core assemblies and utilize its extensibility points to configure and execute dynamic and data-driven tests in .NET applications.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\npublic System.Collections.Generic.Dictionary<string, object?>? Properties { get; init; }\npublic object?[]? TestClassArguments { get; init; }\npublic abstract System.Type TestClassType { get; }\npublic abstract string TestId { get; }\npublic object?[] TestMethodArguments { get; init; }\npublic string? TestName { get; init; }\npublic abstract System.Collections.Generic.IEnumerable<TUnit.Core.TestMetadata> BuildTestMetadatas();\npublic System.Attribute[] GetAttributes() { }\npublic static T Argument<T>() { }\n}\npublic class DynamicTestBuilderAttribute : TUnit.Core.BaseTestAttribute\n{\n    public DynamicTestBuilderAttribute([System.Runtime.CompilerServices.CallerFilePath] string file = \"\", [System.Runtime.CompilerServices.CallerLineNumber] int line = 0) { }\n}\npublic class DynamicTestBuilderContext\n{\n    public DynamicTestBuilderContext(TUnit.Core.TestContext testContext) { }\n    public DynamicTestBuilderContext(string filePath, int lineNumber) { }\n    public System.Collections.Generic.List<TUnit.Core.DynamicTest> Tests { get; }\n    public void AddTest<TClass>(TUnit.Core.DynamicTest<TClass> dynamicTest)\n        where TClass :  class { }\n    public System.Threading.Tasks.Task AddTestAtRuntime<TClass>(TUnit.Core.TestContext testContext, TUnit.Core.DynamicTest<TClass> dynamicTest)\n        where TClass :  class { }\n}\npublic class DynamicTest<TClass> : TUnit.Core.DynamicTest, System.IEquatable<TUnit.Core.DynamicTest<TClass>>\n    where TClass :  class\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public DynamicTest() { }\n    public override System.Type TestClassType { get; }\n    public override string TestId { get; }\n    public System.Linq.Expressions.Expression<System.Action<TClass>> TestMethod { get; init; }\n    public override System.Collections.Generic.IEnumerable<TUnit.Core.TestMetadata> BuildTestMetadatas() { }\n    public class MethodBody : System.IEquatable<TUnit.Core.DynamicTest<TClass>.MethodBody>\n    {\n        public MethodBody() { }\n        public System.Action<TClass>? SynchronousBody { get; init; }\n        public System.Func<TClass, System.Threading.Tasks.Task>? TaskBody { get; init; }\n        public static TUnit.Core.DynamicTest<TClass>.MethodBody op_Implicit(System.Action<TClass> action) { }\n        public static TUnit.Core.DynamicTest<TClass>.MethodBody op_Implicit(System.Func<TClass, System.Threading.Tasks.Task> taskBody) { }\n    }\n}\npublic class EngineCancellationToken : System.IDisposable\n{\n    public EngineCancellationToken() { }\n    public System.Threading.CancellationToken Token { get; }\n    public void Dispose() { }\n}\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method)]\npublic sealed class ExplicitAttribute : TUnit.Core.TUnitAttribute\n{\n    public ExplicitAttribute([System.Runtime.CompilerServices.CallerFilePath] string callerFile = \"\", [System.Runtime.CompilerServices.CallerMemberName] string callerMemberName = \"\") { }\n    public string For { get; }\n}\npublic class FailedDynamicTest<TClassType> : System.IEquatable<TUnit.Core.FailedDynamicTest<TClassType>>\n    where TClassType :  class\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public FailedDynamicTest() { }\n    public System.Exception Exception { get; init; }\n    public string MethodName { get; init; }\n    public string TestFilePath { get; init; }\n    public string TestId { get; init; }\n    public int TestLineNumber { get; init; }\n    public static TUnit.Core.DynamicTest<TClassType> op_Implicit(TUnit.Core.FailedDynamicTest<TClassType> failedTestMetadata) { }\n}\npublic class FailedTestMetadata<TClassType> : System.IEquatable<TUnit.Core.FailedTestMetadata<TClassType>>\n    where TClassType :  class\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public FailedTestMetadata() { }\n    public System.Exception Exception { get; init; }\n    public string MethodName { get; init; }\n    public string TestFilePath { get; init; }\n    public string TestId { get; init; }\n    public int TestLineNumber { get; init; }\n    public static TUnit.Core.TestMetadata<TClassType> op_Implicit(TUnit.Core.FailedTestMetadata<TClassType> failedTestMetadata) { }\n}\npublic abstract class GenericAbstractExecutor : TUnit.Core.Interfaces.IHookExecutor, TUnit.Core.Interfaces.ITestExecutor\n{\n    protected GenericAbstractExecutor() { }\n    public System.Threading.Tasks.ValueTask ExecuteAfterAssemblyHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.AssemblyHookContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteAfterClassHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.ClassHookContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteAfterTestDiscoveryHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestDiscoveryContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteAfterTestHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteAfterTestSessionHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestSessionContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    protected abstract System.Threading.Tasks.ValueTask ExecuteAsync(System.Func<System.Threading.Tasks.ValueTask> action);\n    public System.Threading.Tasks.ValueTask ExecuteBeforeAssemblyHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.AssemblyHookContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteBeforeClassHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.ClassHookContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteBeforeTestDiscoveryHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.BeforeTestDiscoveryContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteBeforeTestHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteBeforeTestSessionHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestSessionContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteTest(TUnit.Core.TestContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n}\npublic class GlobalContext : TUnit.Core.Context\n{\n    public System.IO.TextWriter OriginalConsoleError { get; set; }\n    public System.IO.TextWriter OriginalConsoleOut { get; set; }\n    public string? TestFilter { get; }\n    public new static TUnit.Core.GlobalContext Current { get; }\n}\npublic class GlobalSharedDataKey : TUnit.Core.SharedDataKey, System.IEquatable<TUnit.Core.GlobalSharedDataKey>\n{\n    public static readonly System.Guid RandomKey;\n    public GlobalSharedDataKey(System.Type Type) { }\n}\npublic class HookAttribute : TUnit.Core.TUnitAttribute\n{\n    public int Order { get; init; }\n}\npublic enum HookType\n{\n    Test = 0,\n    Class = 1,\n    Assembly = 2,\n    TestSession = 3,\n    TestDiscovery = 4,\n}\npublic interface IAccessesInstanceData { }\npublic interface IDataAttribute { }\npublic interface IDynamicTestRegistrar\n{\n    System.Threading.Tasks.Task Register<TClass>(TUnit.Core.DynamicTest<TClass> dynamicTest)\n        where TClass :  class;\n}\n[System.AttributeUsage(System.AttributeTargets.Class)]\npublic sealed class InheritsTestsAttribute : TUnit.Core.TUnitAttribute\n{\n    public InheritsTestsAttribute() { }\n}\n[System.AttributeUsage(System.AttributeTargets.Method, AllowMultiple=true)]\npublic class InstanceMethodDataSourceAttribute : TUnit.Core.MethodDataSourceAttribute, TUnit.Core.IAccessesInstanceData\n{\n    public InstanceMethodDataSourceAttribute(string methodNameProvidingDataSource) { }\n    public InstanceMethodDataSourceAttribute(System.Type classProvidingDataSource, string methodNameProvidingDataSource) { }\n}\n[System.AttributeUsage(System.AttributeTargets.Method, AllowMultiple=true)]\npublic class InstanceMethodDataSourceAttribute<T> : TUnit.Core.MethodDataSourceAttribute<T>, TUnit.Core.IAccessesInstanceData\n{\n    public InstanceMethodDataSourceAttribute(string methodNameProvidingDataSource) { }\n}\n[System.AttributeUsage(System.AttributeTargets.Parameter)]\npublic class MatrixAttribute : TUnit.Core.TestDataAttribute\n{\n    protected MatrixAttribute() { }\n    public MatrixAttribute(params object?[]? objects) { }\n    public object?[]? Excluding { get; init; }\n    public virtual object?[] GetObjects(object? instance) { }\n}\n[System.AttributeUsage(System.AttributeTargets.Parameter)]\n```\n\n----------------------------------------\n\nTITLE: Defining Generic That Assertion for Values in C#\nDESCRIPTION: This core generic overload of the static `That` method accepts any value of type `TActual`. It returns a `ValueAssertionBuilder<TActual>` which is the starting point for applying various fluent assertion constraints on the provided value. The `CallerArgumentExpression` captures the source expression.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\n        public static TUnit.Assertions.AssertionBuilders.ValueAssertionBuilder<TActual> That<TActual>(TActual value, [System.Runtime.CompilerServices.CallerArgumentExpression(\"value\")] string? doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Adding Test Method with TUnit in C#\nDESCRIPTION: Demonstrates the creation of a test method using the TUnit framework. The method is marked with the [Test] attribute and is asynchronous. Requires TUnit.Core library to be included.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/writing-your-first-test.md#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    public async Task MyTest()\n    {\n        \n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Assertion Result Class in TUnit Assertions (C#)\nDESCRIPTION: Represents the result of an assertion, indicating whether it passed (`IsPassed`) and providing a failure message (`Message`). Includes static methods for creating passed/failed results (`Passed`, `Fail`, `FailIf`) and combining results (`And`, `OrAsync`, `OrFailIf`). Also defines implicit conversions to Task/ValueTask and a nested `InterpolatedStringHandler` for efficient string formatting in failure messages.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_37\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace TUnit.Assertions.AssertConditions\n{\n    public class AssertionResult\n    {\n        public bool IsPassed { get; }\n        public string Message { get; }\n        public static TUnit.Assertions.AssertConditions.AssertionResult Passed { get; }\n        public TUnit.Assertions.AssertConditions.AssertionResult And(TUnit.Assertions.AssertConditions.AssertionResult other) { }\n        public System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> OrAsync(System.Func<System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult>> otherResult) { }\n        public TUnit.Assertions.AssertConditions.AssertionResult OrFailIf(bool isFailed, TUnit.Assertions.AssertConditions.AssertionResult.InterpolatedStringHandler stringHandler) { }\n        public TUnit.Assertions.AssertConditions.AssertionResult OrFailIf(bool isFailed, string message) { }\n        public static TUnit.Assertions.AssertConditions.AssertionResult Fail(string message) { }\n        public static TUnit.Assertions.AssertConditions.AssertionResult FailIf(bool isFailed, TUnit.Assertions.AssertConditions.AssertionResult.InterpolatedStringHandler stringHandler) { }\n        public static TUnit.Assertions.AssertConditions.AssertionResult FailIf(bool isFailed, string message) { }\n        public static System.Threading.Tasks.Task<TUnit.Assertions.AssertConditions.AssertionResult> op_Implicit(TUnit.Assertions.AssertConditions.AssertionResult result) { }\n        public static System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> op_Implicit(TUnit.Assertions.AssertConditions.AssertionResult result) { }\n        public readonly struct InterpolatedStringHandler\n        {\n            public InterpolatedStringHandler(int literalLength, int formattedCount, bool isFailed, out bool enabled) { }\n            public void AppendFormatted<T>(T? t) { }\n            public void AppendFormatted<T>(T? t, string format)\n                where T : System.IFormattable { }\n            public void AppendLiteral(string s) { }\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Creating Source Generated Method Information\nDESCRIPTION: This code initializes a SourceGeneratedMethodInformation object that contains details about the test method, including its attributes, parameters, and class information. It captures the complete metadata hierarchy needed for test execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceClassCombinedWithDataSourceMethodTests.Test.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n    Type = typeof(global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod),\n    Name = \"DataSourceClassCombinedWithDataSourceMethodTest\",\n    GenericTypeCount = 0,\n    ReturnType = typeof(void),\n    Attributes = \n    [\n        new global::TUnit.Core.TestAttribute(),\n        new global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"One\"),\n        new global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Two\"),\n        new global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Three\")\n    ],\n    Parameters = \n    [\n        new global::TUnit.Core.SourceGeneratedParameterInformation<int>\n        {\n            Name = \"i\",\n            Attributes = [],\n        },\n    ],\n    Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n    {\n        Type = typeof(global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod),\n        Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataSourceClassCombinedWithDataSourceMethodTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n        {\n            Name = \"DataSourceClassCombinedWithDataSourceMethodTests\",\n            Attributes = [],\n        }),\n        Name = \"DataSourceClassCombinedWithDataSourceMethod\",\n        Namespace = \"TUnit.TestProject\",\n        Attributes = \n        [\n            new global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"One\"),\n            new global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Two\"),\n            new global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Three\")\n        ],\n        Parameters = \n        [\n            new global::TUnit.Core.SourceGeneratedParameterInformation<int>\n            {\n                Name = \"i\",\n                Attributes = [],\n            },\n        ],\n        Properties = [],\n    }),\n};\n```\n\n----------------------------------------\n\nTITLE: Defining ClassDataSourceAttribute<T1..T5> in C#\nDESCRIPTION: This C# class defines a `ClassDataSourceAttribute` that inherits from `DataSourceGeneratorAttribute` with five generic type parameters. It's designed for test data sources where each test case receives instances of five different types (T1 to T5), all required to have a default constructor. Properties `Keys` and `Shared` allow further configuration, and `GenerateDataSources` must be implemented to provide the actual data.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\n    public sealed class ClassDataSourceAttribute<T1, T2, T3, T4, T5> : TUnit.Core.DataSourceGeneratorAttribute<T1, T2, T3, T4, T5>\n        where T1 : new()\n        where T2 : new()\n        where T3 : new()\n        where T4 : new()\n        where T5 : new()\n    {\n        public ClassDataSourceAttribute() { }\n        public string[] Keys { get; set; }\n        public TUnit.Core.SharedType[] Shared { get; set; }\n        public override System.Collections.Generic.IEnumerable<System.Func<System.ValueTuple<T1, T2, T3, T4, T5>>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining That Assertion for Func<Task<TActual>> Delegate in C#\nDESCRIPTION: This generic overload of the static `That` method accepts an asynchronous function `Func<Task<TActual>>` that returns a value. It returns an `AsyncValueDelegateAssertionBuilder<TActual>` for asserting conditions on the result of the asynchronous operation. The `CallerArgumentExpression` captures the source expression.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n        public static TUnit.Assertions.AssertionBuilders.AsyncValueDelegateAssertionBuilder<TActual> That<TActual>(System.Func<System.Threading.Tasks.Task<TActual>> value, [System.Runtime.CompilerServices.CallerArgumentExpression(\"value\")] string? doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata with Data Sources in C#\nDESCRIPTION: Creates test metadata nodes by combining class-level and method-level data generation using AutoFixture. Handles test initialization, parameter generation, and test execution setup while providing error handling through FailedTestMetadata.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.Typed.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\nvar classDataIndex = 0;\nvar testMethodDataIndex = 0;\ntry\n{\n    var testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n    {\n        Type = typeof(global::TUnit.TestProject.DataSourceGeneratorTests),\n        Name = \"GeneratedData_Method3\",\n        GenericTypeCount = 0,\n        ReturnType = typeof(void),\n        Attributes = \n        [\n            new global::TUnit.Core.TestAttribute()\n        ],\n        Parameters = \n        [\n            new global::TUnit.Core.SourceGeneratedParameterInformation<int>\n            {\n                Name = \"value\",\n                Attributes = [],\n            },\n            new global::TUnit.Core.SourceGeneratedParameterInformation<string>\n            {\n                Name = \"value2\",\n                Attributes = [],\n            },\n            new global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n            {\n                Name = \"value3\",\n                Attributes = [],\n            },\n        ],\n        Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.DataSourceGeneratorTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n        {\n            Type = typeof(global::TUnit.TestProject.DataSourceGeneratorTests),\n            Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataSourceGeneratorTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n            {\n                Name = \"DataSourceGeneratorTests\",\n                Attributes = [],\n            }),\n            Name = \"DataSourceGeneratorTests\",\n            Namespace = \"TUnit.TestProject\",\n            Attributes = [],\n            Parameters = \n            [\n                new global::TUnit.Core.SourceGeneratedParameterInformation<int>\n                {\n                    Name = \"value\",\n                    Attributes = [],\n                },\n                new global::TUnit.Core.SourceGeneratedParameterInformation<string>\n                {\n                    Name = \"value2\",\n                    Attributes = [],\n                },\n                new global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n                {\n                    Name = \"value3\",\n                    Attributes = [],\n                },\n            ],\n            Properties = [],\n        }),\n};\n```\n\n----------------------------------------\n\nTITLE: Complex Test Orchestration with TUnit in C#\nDESCRIPTION: This snippet showcases various TUnit features including setup/teardown hooks, retries, dependencies, timeouts, and custom attributes for complex test scenarios.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/README.md#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n    [Before(Class)]\n    public static async Task ClearDatabase(ClassHookContext context) { ... }\n\n    [After(Class)]\n    public static async Task AssertDatabaseIsAsExpected(ClassHookContext context) { ... }\n\n    [Before(Test)]\n    public async Task CreatePlaywrightBrowser(TestContext context) { ... }\n\n    [After(Test)]\n    public async Task DisposePlaywrightBrowser(TestContext context) { ... }\n\n    [Retry(3)]\n    [Test, DisplayName(\"Register an account\")]\n    [MethodDataSource(nameof(GetAuthDetails))]\n    public async Task Register(string username, string password) { ... }\n\n    [Repeat(5)]\n    [Test, DependsOn(nameof(Register))]\n    [MethodDataSource(nameof(GetAuthDetails))]\n    public async Task Login(string username, string password) { ... }\n\n    [Test, DependsOn(nameof(Login), [typeof(string), typeof(string)])]\n    [MethodDataSource(nameof(GetAuthDetails))]\n    public async Task DeleteAccount(string username, string password) { ... }\n\n    [Category(\"Downloads\")]\n    [Timeout(300_000)]\n    [Test, NotInParallel(Order = 1)]\n    public async Task DownloadFile1() { ... }\n\n    [Category(\"Downloads\")]\n    [Timeout(300_000)]\n    [Test, NotInParallel(Order = 2)]\n    public async Task DownloadFile2() { ... }\n\n    [Repeat(10)]\n    [Test]\n    [Arguments(1)]\n    [Arguments(2)]\n    [Arguments(3)]\n    [DisplayName(\"Go to the page numbered $page\")]\n    public async Task GoToPage(int page) { ... }\n\n    [Category(\"Cookies\")]\n    [Test, Skip(\"Not yet built!\")]\n    public async Task CheckCookies() { ... }\n\n    [Test, Explicit, WindowsOnlyTest, RetryHttpServiceUnavailable(5)]\n    [Property(\"Some Key\", \"Some Value\")]\n    public async Task Ping() { ... }\n\n    [Test]\n    [ParallelLimit<LoadTestParallelLimit>]\n    [Repeat(1000)]\n    public async Task LoadHomepage() { ... }\n\n    public static IEnumerable<(string Username, string Password)> GetAuthDetails()\n    {\n        yield return (\"user1\", \"password1\");\n        yield return (\"user2\", \"password2\");\n        yield return (\"user3\", \"password3\");\n    }\n\n    public class WindowsOnlyTestAttribute : SkipAttribute\n    {\n        public WindowsOnlyTestAttribute() : base(\"Windows only test\")\n        {\n        }\n\n        public override Task<bool> ShouldSkip(TestContext testContext)\n        {\n            return Task.FromResult(!OperatingSystem.IsWindows());\n        }\n    }\n\n    public class RetryHttpServiceUnavailableAttribute : RetryAttribute\n    {\n        public RetryHttpServiceUnavailableAttribute(int times) : base(times)\n        {\n        }\n\n        public override Task<bool> ShouldRetry(TestInformation testInformation, Exception exception, int currentRetryCount)\n        {\n            return Task.FromResult(exception is HttpRequestException { StatusCode: HttpStatusCode.ServiceUnavailable });\n        }\n    }\n\n    public class LoadTestParallelLimit : IParallelLimit\n    {\n        public int Limit => 50;\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Dependency Injection Data Source using Microsoft.Extensions.DependencyInjection in C#\nDESCRIPTION: This C# snippet shows how to create a test data source attribute by extending TUnit's DependencyInjectionDataSourceAttribute with Microsoft.Extensions.DependencyInjection. It implements required methods to construct and manage a DI scope and resolve test dependencies by type. Prerequisites are references to TUnit.Core and Microsoft.Extensions.DependencyInjection libraries. The class is then used as an attribute for a test class, allowing constructor-injected services in the test. Required parameters include the DI scope (IServiceScope) and the custom services to be registered; output is test objects created using DI. Limitations: Service registrations must be compatible and singleton scope applies within this setup.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/dependency-injection.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MicrosoftDependencyInjectionDataSourceAttribute : DependencyInjectionDataSourceAttribute<IServiceScope>\n{\n    private static readonly IServiceProvider ServiceProvider = CreateSharedServiceProvider();\n\n    public override IServiceScope CreateScope(DataGeneratorMetadata dataGeneratorMetadata)\n    {\n        return ServiceProvider.CreateAsyncScope();\n    }\n\n    public override object? Create(IServiceScope scope, Type type)\n    {\n        return scope.ServiceProvider.GetService(type);\n    }\n    \n    private static IServiceProvider CreateSharedServiceProvider()\n    {\n        return new ServiceCollection()\n            .AddSingleton<SomeClass1>()\n            .AddSingleton<SomeClass2>()\n            .AddTransient<SomeClass3>()\n            .BuildServiceProvider();\n    }\n}\n\n[MicrosoftDependencyInjectionDataSource]\npublic class MyTestClass(SomeClass1 someClass1, SomeClass2 someClass2, SomeClass3 someClass3)\n{\n    [Test]\n    public async Task Test()\n    {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Test Context Classes in C#\nDESCRIPTION: Defines context classes for different phases of test execution, including BeforeTestContext, BeforeTestDiscoveryContext, and AssemblyHookContext. These classes provide access to test metadata and execution context.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic class BeforeTestContext\n{\n    public TUnit.Core.TestContext TestContext { get; }\n    public TUnit.Core.TestDetails TestDetails { get; }\n    public void AddAsyncLocalValues() { }\n    public void AddLinkedCancellationToken(System.Threading.CancellationToken cancellationToken) { }\n    public void SetHookExecutor(TUnit.Core.Interfaces.IHookExecutor hookExecutor) { }\n    public void SetTestExecutor(TUnit.Core.Interfaces.ITestExecutor testExecutor) { }\n}\n\n[System.Runtime.CompilerServices.RequiredMember]\npublic class BeforeTestDiscoveryContext : TUnit.Core.Context\n{\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string? TestFilter { get; init; }\n    public new static TUnit.Core.BeforeTestDiscoveryContext? Current { get; }\n}\n\n[System.Runtime.CompilerServices.RequiredMember]\npublic class AssemblyHookContext : TUnit.Core.Context\n{\n    public System.Collections.Generic.IEnumerable<TUnit.Core.TestContext> AllTests { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Reflection.Assembly Assembly { get; init; }\n    public System.Collections.Generic.HashSet<TUnit.Core.ClassHookContext> TestClasses { get; init; }\n    public int TestCount { get; }\n    public new static TUnit.Core.AssemblyHookContext? Current { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: C# Test Framework Core Class Definitions\nDESCRIPTION: Defines the core classes and interfaces for the TUnit testing framework including TestDetails, TestMetadata, TestResult and various context classes. Includes property definitions with attributes for serialization, required members, and dynamic access.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class TestDetails<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]  TClassType> : TUnit.Core.TestDetails, System.IEquatable<TUnit.Core.TestDetails<TClassType>>\n    where TClassType :  class\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of your compiler.\", true)]\n    public TestDetails() { }\n    public override object ClassInstance { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    [System.Text.Json.Serialization.JsonIgnore]\n    public TUnit.Core.ResettableLazy<TClassType> LazyClassInstance { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Using MatrixRange Attribute to Generate Test Cases in C#\nDESCRIPTION: Illustrates how to use the `[MatrixRange<T>]` attribute in TUnit for generating test cases within a specified numerical range. The attribute generates test cases with `value1` and `value2` ranging from 1 to 10. This snippet uses `MatrixDataSource` for data supply and requires the TUnit framework with its assertions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/matrix-tests.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Assertions.Extensions.Is;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    [MatrixDataSource]\n    public async Task MyTest(\n        [MatrixRange<int>(1, 10)] int value1,\n        [MatrixRange<int>(1, 10)] int value2\n        )\n    {\n        var result = Add(value1, value2);\n\n        await Assert.That(result).IsPositive();\n    }\n\n    private int Add(int x, int y)\n    {\n        return x + y;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Properties in C# TUnit Tests\nDESCRIPTION: This code snippet demonstrates how to add custom properties to a test using TUnit in C#. The [Property] attribute is used to specify property names and values, which can help in test filtering and be utilized within TestContext for logic handling during test setups or cleanups. There are no specific dependencies apart from TUnit itself, and the properties can be used across base classes for all inheriting sub-classes.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/properties.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    [Property(\"PropertyName\", \"PropertyValue\")]\n    public async Task MyTest(CancellationToken cancellationToken)\n    {\n        \n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Method Data Source Generation in C#\nDESCRIPTION: Generates test metadata for method data source driven tests with cancellation token support. Handles test initialization, execution context setup, and error handling for test methods.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenWithCancellationTokenTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests2(string sessionId)\n{\n    global::System.Collections.Generic.List<TestMetadata> nodes = [];\n    var classDataIndex = 0;\n    var testMethodDataIndex = 0;\n    try\n    {\n        var testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n        {\n            Type = typeof(global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests),\n            Name = \"MyTest\",\n            GenericTypeCount = 0,\n            ReturnType = typeof(void),\n            Attributes = \n            [\n                new global::TUnit.Core.TestAttribute(),\n                new global::TUnit.Core.MethodDataSourceAttribute(\"T\"),\n                new global::TUnit.Core.MethodDataSourceAttribute(\"FuncT\"),\n                new global::TUnit.Core.MethodDataSourceAttribute(\"EnumerableT\"),\n                new global::TUnit.Core.MethodDataSourceAttribute(\"EnumerableFuncT\"),\n                new global::TUnit.Core.MethodDataSourceAttribute(\"ArrayT\"),\n                new global::TUnit.Core.MethodDataSourceAttribute(\"ArrayFuncT\")\n            ],\n            Parameters = \n            [\n                new global::TUnit.Core.SourceGeneratedParameterInformation<int>\n                {\n                    Name = \"value\",\n                    Attributes = [],\n                },\n                new global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n                {\n                    Name = \"cancellationToken\",\n                    Attributes = [],\n                },\n            ]\n        };\n    }\n    catch (global::System.Exception exception)\n    {\n        nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests>\n        {\n            TestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS2:{testMethodDataIndex}:TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests.MyTest(int,System.Threading.CancellationToken):0\",\n            MethodName = $\"MyTest\",\n            Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"MethodDataSourceDrivenWithCancellationTokenTests.MyTest failed to initialize\", exception),\n            TestFilePath = @\"\",\n            TestLineNumber = 10,\n        });\n    }\n    return nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Injecting and Using the WebAppFactory in an Automated ASP.NET Core Test in C#\nDESCRIPTION: This C# testing snippet shows how to inject the previously defined WebAppFactory into a test class using ClassDataSource and configure sharing behavior. The test creates an HTTP client from the factory and verifies a GET request against a specific endpoint, asserting the expected HTTP status code. Dependencies include the WebAppFactory implementation, a compatible testing framework (such as NUnit/xUnit), and appropriate attributes for data injection and test lifecycle management.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/examples/aspnet.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyTests\n{\n    [ClassDataSource<WebAppFactory>(Shared = SharedType.PerTestSession)]\n    public required WebAppFactory WebAppFactory { get; init; }\n    \n    [Test]\n    public async Task Test1()\n    {\n        var client = WebAppFactory.CreateClient();\n\n        var response = await client.GetAsync(\"/my/endpoint\");\n        \n        await Assert.That(response.StatusCode).IsEqualTo(HttpStatusCode.OK);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Base Assertion Condition Class in TUnit (C#)\nDESCRIPTION: This abstract class serves as the non-generic base for all assertion conditions in TUnit. It provides common properties like an optional overridden failure message (`OverriddenMessage`), the subject expression (`Subject`), an optional wait duration (`WaitFor`), a method to create a failed result with a specific message (`FailWithMessage`), and requires derived classes to implement how to get the expected value description (`GetExpectation`).\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_38\n\nLANGUAGE: csharp\nCODE:\n```\n    public abstract class BaseAssertCondition\n    {\n        protected BaseAssertCondition() { }\n        public string? OverriddenMessage { get; }\n        public string? Subject { get; }\n        public virtual System.TimeSpan? WaitFor { get; protected set; }\n        public TUnit.Assertions.AssertConditions.AssertionResult FailWithMessage(string message) { }\n        protected abstract string GetExpectation();\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Test Class Structure in TUnit (C#)\nDESCRIPTION: This C# code defines a simple test class `MyTests` containing two test methods, `MyTest1` and `MyTest2`, marked with the `[Test]` attribute. It serves as an example to explain that TUnit creates a new instance of `MyTests` for each test execution, ensuring test isolation and enabling parallel execution by default. No external dependencies are shown, but it assumes the TUnit framework attributes (`[Test]`) are available.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/things-to-know.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyTests\n{\n    [Test]\n    public void MyTest1() { ... }\n\n    [Test]\n    public void MyTest2() { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TUnit Enumeration Types\nDESCRIPTION: Core enumerations used throughout the TUnit framework to represent different states and classifications. Includes DataGeneratorType, LogLevel, and test execution Status enumerations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_54\n\nLANGUAGE: C#\nCODE:\n```\npublic enum DataGeneratorType\n{\n    ClassParameters = 0,\n    TestParameters = 1,\n    Property = 2,\n}\npublic enum LogLevel\n{\n    None = -1,\n    Trace = 0,\n    Debug = 1,\n    Information = 2,\n    Warning = 3,\n    Error = 4,\n    Critical = 5,\n}\npublic enum Status\n{\n    None = 0,\n    Passed = 1,\n    Failed = 2,\n    Skipped = 3,\n    Cancelled = 4,\n}\n```\n\n----------------------------------------\n\nTITLE: Test Context Implementation in C#\nDESCRIPTION: Core test context class that maintains test execution state and provides access to test artifacts, configurations and events. Includes properties for managing test lifecycle and results.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestContext : TUnit.Core.Context\n{\n    public readonly object Lock;\n    public System.Collections.Generic.List<TUnit.Core.ArgumentDisplayFormatter> ArgumentDisplayFormatters { get; }\n    public System.Threading.CancellationToken CancellationToken { get; }\n    public int CurrentRetryAttempt { get; }\n    public TUnit.Core.TestContextEvents Events { get; }\n    public bool IsRegistered { get; }\n    public System.Collections.Generic.Dictionary<string, object?> ObjectBag { get; }\n    public TUnit.Core.TestResult? Result { get; }\n    public TUnit.Core.TestDetails TestDetails { get; }\n    public System.DateTimeOffset? TestStart { get; }\n    public System.Collections.Generic.List<TUnit.Core.Timing> Timings { get; }\n    public static TUnit.Core.Interfaces.IConfiguration Configuration { get; }\n    public new static TUnit.Core.TestContext? Current { get; }\n    public static string? OutputDirectory { get; }\n    public static System.Collections.Generic.IReadOnlyDictionary<string, string> Parameters { get; }\n    public static string WorkingDirectory { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Assert Class for TUnit in C#\nDESCRIPTION: Defines the static Assert class with various assertion methods for different types of assertions, including synchronous and asynchronous checks. It provides methods for failing tests, multiple assertions, and type-specific assertions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic static class Assert\n{\n    [System.Diagnostics.CodeAnalysis.DoesNotReturn]\n    public static void Fail(string reason) { }\n    public static System.IDisposable Multiple() { }\n    public static TUnit.Assertions.AssertionBuilders.DelegateAssertionBuilder That(System.Action value, [System.Runtime.CompilerServices.CallerArgumentExpression(\"value\")] string? doNotPopulateThisValue = null) { }\n    // ... (other methods omitted for brevity)\n    public static System.Threading.Tasks.Task<TException> ThrowsAsync<TException>(System.Threading.Tasks.ValueTask @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression(\"delegate\")] string? doNotPopulateThisValue = null)\n        where TException : System.Exception { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Test Execution Order using DependsOn Attribute in TUnit C#\nDESCRIPTION: This C# code shows how to use the `[DependsOn]` attribute in TUnit to specify dependencies between tests within the same class. `Test3` will only start execution after both `Test1` and `Test2` have completed successfully. This feature allows managing execution order without requiring the disabling of parallel execution for unrelated tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/comparison/framework-differences.md#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n    [Test]\n    public async Task Test1()\n    {\n        ...\n    }\n    \n    [Test]\n    public async Task Test2()\n    {\n        ...\n    }\n    \n    [Test]\n    [DependsOn(nameof(Test1))]\n    [DependsOn(nameof(Test2))]\n    public async Task Test3()\n    {\n        ...\n    }\n```\n\n----------------------------------------\n\nTITLE: Creating Explicit Assertion Scope in TUnit with C#\nDESCRIPTION: This snippet illustrates creating an explicit assertion scope in TUnit tests by explicitly calling Assert.Multiple() within a 'using' block. It uses an IDisposable interface to ensure that multiple assertions are managed and errors are aggregated. The code inputs are operation results, and it outputs exceptions post-execution if assertions fail.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-assertions/scopes.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[Test]\n    public async Task MyTest()\n    {\n        var result = Add(1, 2);\n\n        using (Assert.Multiple())\n        {\n            await Assert.That(result).IsPositive();\n            await Assert.That(result).IsEqualTo(3);\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing a Data-Driven Test using [Arguments] in TUnit C#\nDESCRIPTION: This C# code demonstrates a data-driven test within the TUnit framework. The `MyTest` method is marked with the `[Test]` attribute and multiple `[Arguments]` attributes. Each `[Arguments]` attribute provides a set of input values (`value1`, `value2`) and the expected result (`expectedResult`) that are passed to the test method's parameters for each execution. The test calls a simple `Add` method and uses `TUnit.Assertions` to verify the result against the expected outcome.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/data-driven-tests.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\nusing TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    [Arguments(1, 1, 2)]\n    [Arguments(1, 2, 3)]\n    [Arguments(2, 2, 4)]\n    [Arguments(4, 3, 7)]\n    [Arguments(5, 5, 10)]\n    public async Task MyTest(int value1, int value2, int expectedResult)\n    {\n        var result = Add(value1, value2);\n\n        await Assert.That(result).IsEqualTo(expectedResult);\n    }\n\n    private int Add(int x, int y)\n    {\n        return x + y;\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Source Collection in C#\nDESCRIPTION: Source generated partial class that implements ITestSource interface to collect and execute parameterized tests. Handles test initialization, argument passing, and test metadata generation.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassAndMethodArgumentsTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class ClassAndMethodArgumentsTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n    [global::System.Runtime.CompilerServices.ModuleInitializer]\n    public static void Initialise()\n    {\n        global::TUnit.Core.SourceRegistrar.Register(new ClassAndMethodArgumentsTests());\n    }\n    public global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n    {\n        return\n        [\n            ..Tests0(sessionId),\n            ..Tests1(sessionId),\n        ];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Per-Test Metadata with Method Data Sources using TUnit - C#\nDESCRIPTION: This C# snippet generates structured test metadata for a test method, leveraging method data sources via TUnit's MethodDataSourceAttribute. It configures arguments for various test cases, instantiates test builder contexts and resettable factory delegates, and populates each test's metadata object for execution by the test runner. The metadata includes reflection-based information, invocation logic, and test identification. The method returns a list of TestMetadata or FailedTestMetadata in case of errors. The approach depends on TUnit.Core and related types.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.MethodDataSourceDrivenTests),\n\t\t\tName = \"DataSource_Method4\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"SomeMethod\")\n\t\t\t\t{\n\t\t\t\t\tArguments = [\"Hello World!\", 5, true],\n},\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"SomeMethod\")\n\t\t\t\t\t{\n\t\t\t\t\t\tArguments = new object[] { \"Hello World!\", 6, true },\n},\n\t\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"SomeMethod\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tArguments = [\"Hello World!\", 7, true],\n},\n\t\t\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"SomeMethod\")\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tArguments = new object[] { \"Hello World!\", 8, true },\n}\n\t\t\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t{\n\t\t\t\t\tName = \"value\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.MethodDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.MethodDataSourceDrivenTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"MethodDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"MethodDataSourceDrivenTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"MethodDataSourceDrivenTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\tglobal::TUnit.TestProject.MethodDataSourceDrivenTests? classInstance = null;\n\t\tobject?[]? classInstanceArguments = null;\n\t\tclassInstanceArguments = [];\n\n\t\tint methodArg = global::TUnit.TestProject.MethodDataSourceDrivenTests.SomeMethod(\"Hello World!\", 5, true);\n\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.MethodDataSourceDrivenTests>(() => \n\t\tnew global::TUnit.TestProject.MethodDataSourceDrivenTests()\n\t\t, sessionId, testBuilderContext);\n\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenTests>\n\t\t{\n\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.MethodDataSourceDrivenTests.DataSource_Method4(int):0\",\n\t\t\tTestClassArguments = [],\n\t\t\tTestMethodArguments = [methodArg],\n\t\t\tTestClassProperties = [],\n\t\t\tCurrentRepeatAttempt = 0,\n\t\t\tRepeatLimit = 0,\n\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_Method4(methodArg)),\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 42,\n\t\t\tTestMethod = testInformation,\n\t\t\tTestBuilderContext = testBuilderContext,\n\t\t});\n\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\ttestBuilderContext = new();\n\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t}\n\tcatch (global::System.Exception exception)\n\t{\n\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenTests>\n\t\t{\n\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.MethodDataSourceDrivenTests.DataSource_Method4(int):0\",\n\t\t\tMethodName = $\"DataSource_Method4\",\n\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"MethodDataSourceDrivenTests.DataSource_Method4 failed to initialize\", exception),\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 42,\n\t\t});\n\t}\n\treturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract Context Class in C#\nDESCRIPTION: This abstract C# class `Context` serves as a base for various context objects within the TUnit framework. It implements `IDisposable` and `IContext`, providing access to standard output and error streams (`OutputWriter`, `ErrorOutputWriter`) and the current context (`Current`). It includes methods for managing asynchronous local values, disposing resources, getting a default logger, and retrieving captured output.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n    public abstract class Context : System.IDisposable, TUnit.Core.Interfaces.IContext\n    {\n        public System.IO.TextWriter ErrorOutputWriter { get; }\n        public System.IO.TextWriter OutputWriter { get; }\n        public static TUnit.Core.Context Current { get; }\n        public void AddAsyncLocalValues() { }\n        public void Dispose() { }\n        public TUnit.Core.Logging.DefaultLogger GetDefaultLogger() { }\n        public string GetErrorOutput() { }\n        public string GetStandardOutput() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Yielding Data Sources with Unique Contexts in C#\nDESCRIPTION: Illustrates using the yield return pattern in TUnit's GenerateDataSources method to maintain unique test contexts. By yielding results, the TUnit framework allocates a new TestBuilderContext object for each test case, minimizing side-effects from shared test state. This approach requires understanding how TUnit manages test lifecycles and context objects.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/data-source-generators.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n\n    public override IEnumerable<Func<int>> GenerateDataSources(DataGeneratorMetadata dataGeneratorMetadata)\n    {\n        dataGeneratorMetadata.TestBuilderContext.Current; // <-- Initial Context for first test\n        \n        yield return () => 1;\n        \n        dataGeneratorMetadata.TestBuilderContext.Current; // <-- This is now a different context object, as we yielded\n        dataGeneratorMetadata.TestBuilderContext.Current; // <-- This is still the same as above because it'll only change on a yield\n        \n        yield return () => 2;\n        \n        dataGeneratorMetadata.TestBuilderContext.Current; // <-- A new object again\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Injecting Multiple Class Instances with Varied Sharing Options using TUnit ClassDataSource in C#\nDESCRIPTION: This example illustrates injecting multiple different class instances (`Value1` through `Value5`) into a test class's primary constructor using the `[ClassDataSource<T1, T2, ...>]` attribute overload in TUnit. It demonstrates configuring distinct sharing behaviors for each injected type via the `Shared` array parameter (e.g., `SharedType.PerTestSession`, `SharedType.Keyed`, `SharedType.None`) and providing specific keys for keyed sharing using the `Keys` array parameter. Dependencies are injected directly into the test class constructor.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/class-data-source.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\n[Test]\n    [ClassDataSource<Value1, Value2, Value3, Value4, Value5>\n        (\n        Shared = [SharedType.PerTestSession, SharedType.Keyed, SharedType.PerClass, SharedType.Keyed, SharedType.None],\n        Keys = [ \"Value2Key\", \"Value4Key\" ]\n        )]\n    public class MyType(Value1 value1, Value2 value2, Value3 value3, Value4 value4, Value5 value5)\n    {\n\n    }\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Attribute Types for TUnit Test Hooks and Data Sources - C#\nDESCRIPTION: This portion defines several attribute classes and related types for marking tests, hooks, and data sources in TUnit. HookAttribute assigns an execution order to hooks, HookType enumerates possible hook scopes, and multiple data source attributes (MatrixAttribute, MatrixDataSourceAttribute, MethodDataSourceAttribute, etc.) enable matrix and method-based parameterization for tests. Most attributes use .NET's AttributeUsage for scoping, and several generic attributes support typed test data. These are extensibility primitives required for advanced test metadata and data-driven test scenarios.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\npublic class HookAttribute : TUnit.Core.TUnitAttribute\n{\n    public int Order { get; init; }\n}\npublic enum HookType\n{\n    Test = 0,\n    Class = 1,\n    Assembly = 2,\n    TestSession = 3,\n    TestDiscovery = 4,\n}\n[System.AttributeUsage(System.AttributeTargets.Class)]\npublic sealed class InheritsTestsAttribute : TUnit.Core.TUnitAttribute\n{\n    public InheritsTestsAttribute() { }\n}\n[System.AttributeUsage(System.AttributeTargets.Method, AllowMultiple=true)]\npublic class InstanceMethodDataSourceAttribute : TUnit.Core.MethodDataSourceAttribute, TUnit.Core.IAccessesInstanceData\n{\n    public InstanceMethodDataSourceAttribute(string methodNameProvidingDataSource) { }\n    public InstanceMethodDataSourceAttribute(System.Type classProvidingDataSource, string methodNameProvidingDataSource) { }\n}\n[System.AttributeUsage(System.AttributeTargets.Method, AllowMultiple=true)]\npublic class InstanceMethodDataSourceAttribute<T> : TUnit.Core.MethodDataSourceAttribute<T>, TUnit.Core.IAccessesInstanceData\n{\n    public InstanceMethodDataSourceAttribute(string methodNameProvidingDataSource) { }\n}\n[System.AttributeUsage(System.AttributeTargets.Parameter)]\npublic class MatrixAttribute : TUnit.Core.TestDataAttribute\n{\n    protected MatrixAttribute() { }\n    public MatrixAttribute(params object?[]? objects) { }\n    public object?[]? Excluding { get; init; }\n    public virtual object?[] GetObjects(object? instance) { }\n}\n[System.AttributeUsage(System.AttributeTargets.Parameter)]\npublic class MatrixAttribute<T> : TUnit.Core.MatrixAttribute\n{\n    public MatrixAttribute(params T?[]? objects) { }\n}\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method)]\npublic sealed class MatrixDataSourceAttribute : TUnit.Core.NonTypedDataSourceGeneratorAttribute\n{\n    public MatrixDataSourceAttribute() { }\n    public override System.Collections.Generic.IEnumerable<System.Func<object?[]?>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata) { }\n}\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\npublic class MatrixExclusionAttribute : TUnit.Core.TUnitAttribute\n{\n    public MatrixExclusionAttribute(params object?[]? objects) { }\n    public object?[] Objects { get; }\n}\n[System.AttributeUsage(System.AttributeTargets.Parameter)]\npublic class MatrixInstanceMethodAttribute<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicMethods)]  TClass> : TUnit.Core.MatrixMethodAttribute<TClass>, TUnit.Core.IAccessesInstanceData\n    where TClass :  class\n{\n    public MatrixInstanceMethodAttribute(string methodName) { }\n}\n[System.AttributeUsage(System.AttributeTargets.Parameter)]\npublic class MatrixMethodAttribute<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicMethods)]  TClass> : TUnit.Core.MatrixAttribute\n    where TClass :  class\n{\n    public MatrixMethodAttribute(string methodName) { }\n    public override object?[] GetObjects(object? instance) { }\n}\n[System.AttributeUsage(System.AttributeTargets.Parameter)]\npublic class MatrixRangeAttribute<T> : TUnit.Core.MatrixAttribute<T>\n    where T : System.Numerics.INumber<T>\n{\n    public MatrixRangeAttribute(T min, T max) { }\n    public MatrixRangeAttribute(T min, T max, T step) { }\n}\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method | System.AttributeTargets.Property, AllowMultiple=true)]\npublic class MethodDataSourceAttribute : TUnit.Core.TestDataAttribute\n{\n    public MethodDataSourceAttribute(string methodNameProvidingDataSource) { }\n    public MethodDataSourceAttribute(System.Type classProvidingDataSource, string methodNameProvidingDataSource) { }\n    public object?[] Arguments { get; set; }\n    public System.Type? ClassProvidingDataSource { get; }\n    public string MethodNameProvidingDataSource { get; }\n}\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method | System.AttributeTargets.Property, AllowMultiple=true)]\npublic class MethodDataSourceAttribute<T> : TUnit.Core.MethodDataSourceAttribute\n{\n    public MethodDataSourceAttribute(string methodNameProvidingDataSource) { }\n}\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method | System.AttributeTargets.Property, AllowMultiple=true)]\npublic abstract class NonTypedDataSourceGeneratorAttribute : TUnit.Core.TestDataAttribute, TUnit.Core.IDataAttribute\n{\n    protected NonTypedDataSourceGeneratorAttribute() { }\n    public abstract System.Collections.Generic.IEnumerable<System.Func<object?[]?>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata);\n}\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\npublic class NotInParallelAttribute : TUnit.Core.SingleTUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver\n{\n    public NotInParallelAttribute() { }\n    public NotInParallelAttribute(string constraintKey) { }\n    public NotInParallelAttribute(string[] constraintKeys) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Test Initialization Failures in C#\nDESCRIPTION: This snippet adds a FailedTestMetadata entry when test initialization fails. It captures the exception and creates a TestFailedInitializationException with relevant details.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassAndMethodArgumentsTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ClassAndMethodArgumentsTests>\n{\n\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{classDataIndex}:CL-ARGS0:global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.ClassAndMethodArgumentsTests(string).IgnoreParameters(string):0\",\n\tMethodName = $\"IgnoreParameters\",\n\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ClassAndMethodArgumentsTests.IgnoreParameters failed to initialize\", exception),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 16,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Azure DevOps Pipeline Steps for TUnit Test Execution and Reporting\nDESCRIPTION: Azure DevOps pipeline configuration that runs TUnit tests using dotnet test command and publishes the results. The configuration generates .trx test result files and uses the PublishTestResults task to make results visible in Azure DevOps Test Runs.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/examples/tunit-ci-pipline.md#2025-04-22_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nsteps:\n  - script: dotnet test --configuration Release -- --report-trx --results-directory $(Agent.TempDirectory)\n    displayName: 'Run tests and output .trx file'\n    continueOnError: true\n\n  - task: PublishTestResults@2\n    displayName: 'Publish Test Results from *.trx files'\n    inputs:\n      testResultsFormat: VSTest\n      testResultsFiles: '*.trx'\n      searchFolder: '$(Agent.TempDirectory)'\n      failTaskOnFailedTests: true\n      failTaskOnMissingResultsFile: true\n```\n\n----------------------------------------\n\nTITLE: Defining ISource Interface with Assertion Building Methods in C#\nDESCRIPTION: Defines the core ISource interface with methods for building assertions and appending expressions, serving as a foundation for various assertion types.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_63\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface ISource\n{\n    string? ActualExpression { get; }\n    TUnit.Assertions.AssertConditions.Interfaces.ISource AppendExpression(string expression);\n    TUnit.Assertions.AssertConditions.Interfaces.ISource WithAssertion(TUnit.Assertions.AssertConditions.BaseAssertCondition assertCondition);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TUnit Exception Hierarchy\nDESCRIPTION: A comprehensive set of exception types for handling various test execution failures and scenarios. All exceptions extend from TUnitException base class and provide specific context for different test lifecycle stages.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_55\n\nLANGUAGE: C#\nCODE:\n```\npublic class AfterAssemblyException : TUnit.Core.Exceptions.TUnitException\n{\n    public AfterAssemblyException(string message, System.Exception innerException) { }\n}\npublic class AfterClassException : TUnit.Core.Exceptions.TUnitException\n{\n    public AfterClassException(string message, System.Exception innerException) { }\n}\npublic class AfterTestDiscoveryException : TUnit.Core.Exceptions.TUnitException\n{\n    public AfterTestDiscoveryException(string message, System.Exception innerException) { }\n}\npublic class AfterTestException : TUnit.Core.Exceptions.TUnitException\n{\n    public AfterTestException(string message, System.Exception innerException) { }\n}\npublic class AfterTestSessionException : TUnit.Core.Exceptions.TUnitException\n{\n    public AfterTestSessionException(string message, System.Exception innerException) { }\n}\npublic class BeforeAssemblyException : TUnit.Core.Exceptions.TUnitException\n{\n    public BeforeAssemblyException(string message, System.Exception innerException) { }\n}\npublic class BeforeClassException : TUnit.Core.Exceptions.TUnitException\n{\n    public BeforeClassException(string message, System.Exception innerException) { }\n}\npublic class BeforeTestDiscoveryException : TUnit.Core.Exceptions.TUnitException\n{\n    public BeforeTestDiscoveryException(string message, System.Exception innerException) { }\n}\npublic class BeforeTestException : TUnit.Core.Exceptions.TUnitException\n{\n    public BeforeTestException(string message, System.Exception innerException) { }\n}\npublic class BeforeTestSessionException : TUnit.Core.Exceptions.TUnitException\n{\n    public BeforeTestSessionException(string message, System.Exception innerException) { }\n}\npublic class DependencyConflictException : TUnit.Core.Exceptions.TUnitException { }\npublic class FailTestException : TUnit.Core.Exceptions.TUnitException\n{\n    public FailTestException(string reason) { }\n    public string Reason { get; }\n}\npublic class InconclusiveTestException : TUnit.Core.Exceptions.TUnitException\n{\n    public InconclusiveTestException(string message, System.Exception exception) { }\n}\npublic class SkipTestException : TUnit.Core.Exceptions.TUnitException\n{\n    public SkipTestException(string reason) { }\n    public string Reason { get; }\n}\npublic class TUnitException : System.Exception\n{\n    public TUnitException() { }\n    public TUnitException(string? message) { }\n    public TUnitException(string? message, System.Exception? innerException) { }\n}\npublic class TestFailedInitializationException : System.Exception\n{\n    public TestFailedInitializationException(string? message, System.Exception? innerException) { }\n}\npublic class TestNotExecutedException : TUnit.Core.Exceptions.TUnitException { }\npublic class TestRunCanceledException : TUnit.Core.Exceptions.TUnitException\n{\n    public TestRunCanceledException() { }\n}\npublic class TimeoutException : TUnit.Core.Exceptions.TUnitException { }\n```\n\n----------------------------------------\n\nTITLE: Defining Executable Hook Interface in C#\nDESCRIPTION: Defines the IExecutableHook<T> interface which represents a hook that can be executed. It includes properties for method information, name, and order.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_50\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IExecutableHook<in T>\n{\n    TUnit.Core.SourceGeneratedMethodInformation MethodInfo { get; }\n    string Name { get; }\n    int Order { get; }\n    System.Threading.Tasks.ValueTask ExecuteAsync(T context, System.Threading.CancellationToken cancellationToken);\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Specific Exception Thrown with TUnit in C#\nDESCRIPTION: This snippet illustrates a C# async test verifying that a delegate throws an ArgumentNullException using TUnit. The test uses Assert.That with a delegate, then checks for the specified exception type via Throws<T>. Dependencies include TUnit and proper test setup. The assertion will pass if ArgumentNullException is thrown and fail otherwise. No inputs are expected; behavior is defined by the code inside the delegate.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-assertions/delegates.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n    [Test]\n    public async Task MyTest()\n    {\n        await Assert.That(() =>\n        {\n            // Do something here\n        }).Throws<ArgumentNullException>();\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Repeat Attribute in C#\nDESCRIPTION: Defines an attribute for repeating a test a specified number of times. This can be useful for ensuring test stability or for load testing.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\npublic sealed class RepeatAttribute : TUnit.Core.TUnitAttribute\n{\n    public RepeatAttribute(int times) { }\n    public int Times { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Base AssertionGroup Abstract Class with Awaitable Pattern\nDESCRIPTION: Abstract base class for all assertion groups implementing the awaitable pattern through GetAwaiter. This allows assertions to be used with async/await syntax in test methods.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_74\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AssertionGroup<TActual, TAssertionBuilder>\n    where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder\n{\n    public abstract System.Runtime.CompilerServices.TaskAwaiter<TActual?> GetAwaiter();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ClassDataSourceAttribute<T1, T2, T3, T4> in C#\nDESCRIPTION: This C# class defines a `ClassDataSourceAttribute` that inherits from `DataSourceGeneratorAttribute` with four generic type parameters. It is used to specify data sources for tests where each data item is an instance of the specified types T1, T2, T3, and T4, constrained to have a parameterless constructor. It includes properties for keys and shared types and overrides the `GenerateDataSources` method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\n    public sealed class ClassDataSourceAttribute<T1, T2, T3, T4> : TUnit.Core.DataSourceGeneratorAttribute<T1, T2, T3, T4>\n        where T1 : new()\n        where T2 : new()\n        where T3 : new()\n        where T4 : new()\n    {\n        public ClassDataSourceAttribute() { }\n        public string[] Keys { get; set; }\n        public TUnit.Core.SharedType[] Shared { get; set; }\n        public override System.Collections.Generic.IEnumerable<System.Func<System.ValueTuple<T1, T2, T3, T4>>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Number Assertion Extensions in C#\nDESCRIPTION: Extension methods for asserting numeric value properties such as divisibility, evenness, positivity, and more. These methods work with any type implementing INumber<T> interface for generic numeric operations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_76\n\nLANGUAGE: C#\nCODE:\n```\npublic static class NumberIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsDivisibleBy<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.Numerics.INumber<TActual>, System.Numerics.IModulusOperators<TActual, TActual, TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsEven<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource)\n        where TActual : System.Numerics.INumber<TActual>, System.Numerics.IModulusOperators<TActual, TActual, TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNegative<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource)\n        where TActual : System.Numerics.INumber<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsOdd<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource)\n        where TActual : System.Numerics.INumber<TActual>, System.Numerics.IModulusOperators<TActual, TActual, TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsPositive<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource)\n        where TActual : System.Numerics.INumber<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsZero<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource)\n        where TActual : System.Numerics.INumber<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.GenericEqualToAssertionBuilderWrapper<TActual> Within<TActual>(this TUnit.Assertions.AssertionBuilders.Wrappers.GenericEqualToAssertionBuilderWrapper<TActual> assertionBuilder, TActual tolerance, [System.Runtime.CompilerServices.CallerArgumentExpression(\"tolerance\")] string doNotPopulateThis = \"\")\n        where TActual : System.Numerics.INumber<TActual> { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TestResult Class in C# for TUnit Framework\nDESCRIPTION: This class represents the result of a test execution in the TUnit framework. It includes properties for test duration, start and end times, exceptions, and status.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_49\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class TestResult : System.IEquatable<TUnit.Core.TestResult>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public TestResult() { }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string ComputerName { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.TimeSpan? Duration { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.DateTimeOffset? End { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Exception? Exception { get; init; }\n    public string? Output { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.DateTimeOffset? Start { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Core.Enums.Status Status { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing an Async-Initialized WebAppFactory for ASP.NET Core in C#\nDESCRIPTION: This C# snippet defines a custom WebAppFactory class for use in ASP.NET Core integration tests, extending WebApplicationFactory and implementing IAsyncInitializer. The InitializeAsync method eagerly triggers server initialization in a thread-safe way, allowing for further service overrides (e.g., mocking dependencies) if needed. Requires Microsoft.Mvc.Testing and Xunit/NUnit (or compatible test runner), and is intended for facilitating reliable parallel test execution with pre-initialized dependencies.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/examples/aspnet.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class WebAppFactory : WebApplicationFactory<Program>, IAsyncInitializer\n{\n    public Task InitializeAsync()\n    {\n        // You can also override certain services here to mock things out\n\n        // Grab a reference to the server\n        // This forces it to initialize.\n        // By doing it within this method, it\\'s thread safe.\n        // And avoids multiple initialisations from different tests if parallelisation is switched on\n        _ = Server;\n\n        return Task.CompletedTask;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Comparable Value Assertions in C#\nDESCRIPTION: Extension methods for asserting comparable values, including checks for being between, greater than, less than, and their inclusive variants.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_108\n\nLANGUAGE: C#\nCODE:\n```\npublic static class ComparableIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.BetweenAssertionBuilderWrapper<TActual> IsBetween<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual lowerBound, TActual upperBound, [System.Runtime.CompilerServices.CallerArgumentExpression(\"lowerBound\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"upperBound\")] string doNotPopulateThisValue2 = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsGreaterThan<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsGreaterThanOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsLessThan<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsLessThanOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TUnit Exception Hierarchy for Test Framework\nDESCRIPTION: A comprehensive exception hierarchy for the TUnit testing framework that handles various test failure scenarios. Exceptions are specialized for different phases of test execution including setup, teardown, and various lifecycle events.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic class AfterAssemblyException : TUnit.Core.Exceptions.TUnitException\n    {\n        public AfterAssemblyException(string message, System.Exception innerException) { }\n    }\n    public class AfterClassException : TUnit.Core.Exceptions.TUnitException\n    {\n        public AfterClassException(string message, System.Exception innerException) { }\n    }\n    public class AfterTestDiscoveryException : TUnit.Core.Exceptions.TUnitException\n    {\n        public AfterTestDiscoveryException(string message, System.Exception innerException) { }\n    }\n    public class AfterTestException : TUnit.Core.Exceptions.TUnitException\n    {\n        public AfterTestException(string message, System.Exception innerException) { }\n    }\n    public class AfterTestSessionException : TUnit.Core.Exceptions.TUnitException\n    {\n        public AfterTestSessionException(string message, System.Exception innerException) { }\n    }\n    public class BeforeAssemblyException : TUnit.Core.Exceptions.TUnitException\n    {\n        public BeforeAssemblyException(string message, System.Exception innerException) { }\n    }\n    public class BeforeClassException : TUnit.Core.Exceptions.TUnitException\n    {\n        public BeforeClassException(string message, System.Exception innerException) { }\n    }\n    public class BeforeTestDiscoveryException : TUnit.Core.Exceptions.TUnitException\n    {\n        public BeforeTestDiscoveryException(string message, System.Exception innerException) { }\n    }\n    public class BeforeTestException : TUnit.Core.Exceptions.TUnitException\n    {\n        public BeforeTestException(string message, System.Exception innerException) { }\n    }\n    public class BeforeTestSessionException : TUnit.Core.Exceptions.TUnitException\n    {\n        public BeforeTestSessionException(string message, System.Exception innerException) { }\n    }\n    public class DependencyConflictException : TUnit.Core.Exceptions.TUnitException { }\n    public class FailTestException : TUnit.Core.Exceptions.TUnitException\n    {\n        public FailTestException(string reason) { }\n        public string Reason { get; }\n    }\n    public class InconclusiveTestException : TUnit.Core.Exceptions.TUnitException\n    {\n        public InconclusiveTestException(string message, System.Exception exception) { }\n    }\n    public class SkipTestException : TUnit.Core.Exceptions.TUnitException\n    {\n        public SkipTestException(string reason) { }\n        public string Reason { get; }\n    }\n    public class TUnitException : System.Exception\n    {\n        public TUnitException() { }\n        public TUnitException(string? message) { }\n        public TUnitException(string? message, System.Exception? innerException) { }\n    }\n    public class TestFailedInitializationException : System.Exception\n    {\n        public TestFailedInitializationException(string? message, System.Exception? innerException) { }\n    }\n    public class TestNotExecutedException : TUnit.Core.Exceptions.TUnitException { }\n    public class TestRunCanceledException : TUnit.Core.Exceptions.TUnitException\n    {\n        public TestRunCanceledException() { }\n    }\n    public class TimeoutException : TUnit.Core.Exceptions.TUnitException { }\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract DataSourceGeneratorAttribute<T1, T2> in C#\nDESCRIPTION: This abstract C# attribute `DataSourceGeneratorAttribute<T1, T2>` is a base class for TUnit data source attributes generating pairs of data types (T1, T2). It extends `TestDataAttribute` and implements `IDataAttribute`. Concrete implementations must override `GenerateDataSources` to return an enumerable of functions, each yielding a `ValueTuple<T1, T2>` based on the provided `DataGeneratorMetadata`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\n    public abstract class DataSourceGeneratorAttribute<T1, T2> : TUnit.Core.TestDataAttribute, TUnit.Core.IDataAttribute\n    {\n        protected DataSourceGeneratorAttribute() { }\n        public abstract System.Collections.Generic.IEnumerable<System.Func<System.ValueTuple<T1, T2>>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata);\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Expected Value Assert Condition - TUnit - C#\nDESCRIPTION: Illustrates a custom assertion class that checks string equality using a specified StringComparison. The class inherits from ExpectedValueAssertCondition and overrides GetExpectation and GetResult to provide assertion logic and expected output description. It is dependent upon TUnit's assertion condition base classes and the AssertionResult utility. The primary parameters are the expected string and comparison type; actualValue and expectedValue are compared in GetResult. Outputs are AssertionResult indicating pass or fail, with appropriate error messages if values do not match.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-assertions/extensibility/custom-assertions.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class StringEqualsExpectedValueAssertCondition(string expected, StringComparison stringComparison)\n    : ExpectedValueAssertCondition<string, string>(expected)\n{\n    protected override string GetExpectation()\n        => $\"to be equal to \\\"{expected}\\\"\";\n\n    protected override async ValueTask<AssertionResult> GetResult(string? actualValue, string? expectedValue)\n    {\n        if (actualValue is null)\n        {\n            return AssertionResult\n                .FailIf(\n                    expectedValue is not null,\n                    \"it was null\");\n        }\n\n        return AssertionResult\n            .FailIf(\n                !string.Equals(actualValue, expectedValue, stringComparison),\n                $\"found \\\"{actualValue}\\\"\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Test Initialization Exceptions in C#\nDESCRIPTION: Catches and processes exceptions during test initialization, creating FailedTestMetadata with appropriate error information. This ensures failures are properly reported instead of causing crashes.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1821.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._1821.Tests>\n\t{\n\t\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.Bugs._1821.MyData>:{classDataIndex}:CL-GAC0:global::TUnit.Core.MatrixDataSourceAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.Bugs._1821.Tests(TUnit.TestProject.Bugs._1821.MyData).MatrixDataSource(string):0\",\n\t\tMethodName = $\"MatrixDataSource\",\n\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"Tests.MatrixDataSource failed to initialize\", exception),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 16,\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Throws Method in Assert Class\nDESCRIPTION: Definition of a generic Throws method that checks if a delegate throws a specific exception type. The method captures caller argument expressions for better error messages.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic static TException Throws<TException>(System.Action @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression(\"delegate\")] string? doNotPopulateThisValue = null)\n            where TException : System.Exception { }\n```\n\n----------------------------------------\n\nTITLE: Defining That Assertion for ValueTask in C#\nDESCRIPTION: This overload of the static `That` method in the `Assert` class accepts a `System.Threading.Tasks.ValueTask`. It returns an `AsyncDelegateAssertionBuilder` for making assertions about the asynchronous operation represented by the ValueTask. The `CallerArgumentExpression` attribute captures the source expression.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n        public static TUnit.Assertions.AssertionBuilders.AsyncDelegateAssertionBuilder That(System.Threading.Tasks.ValueTask value, [System.Runtime.CompilerServices.CallerArgumentExpression(\"value\")] string? doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Grouping Assertions with AssertionGroup in TUnit (C#)\nDESCRIPTION: This snippet demonstrates the recommended way to group assertions for clearer logic using AssertionGroup. By constructing `cd` and `ab` assertion groups and combining them with `Or`, the code explicitly represents logical blocks such as `(C && D)` and `(A && B)`. Requires the TUnit library with AssertionGroup and Assert types. Inputs are string values and assertion lambdas; outputs are grouped assertions with unambiguous logic. This technique improves test clarity and maintainability at the cost of increased verbosity.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-assertions/assertion-groups.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar value = \"CD\";\n\nvar cd = AssertionGroup.For(value)\n    .WithAssertion(assert => assert.Contains('C'))\n    .And(assert => assert.Contains('D'));\n\nvar ab = AssertionGroup.ForSameValueAs(cd)\n    .WithAssertion(assert => assert.Contains('A'))\n    .And(assert => assert.Contains('B'));\n\nawait AssertionGroup.Assert(cd).Or(ab);\n```\n\n----------------------------------------\n\nTITLE: Base Assertion Builder Class Implementation in C#\nDESCRIPTION: Abstract base class for building assertions in the TUnit framework. Handles assertion data management and provides core functionality for derived assertion builders.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AssertionBuilder : TUnit.Assertions.AssertConditions.Interfaces.ISource\n{\n    protected TUnit.Assertions.AssertionData? AwaitedAssertionData;\n    protected TUnit.Assertions.AssertionBuilders.IInvokableAssertionBuilder? OtherTypeAssertionBuilder;\n    protected readonly System.Collections.Generic.List<TUnit.Assertions.AssertConditions.AssertionResult> Results;\n    public AssertionBuilder(TUnit.Assertions.AssertConditions.Interfaces.ISource source) { }\n    public AssertionBuilder(System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertionData> assertionDataTask, string? actualExpression) { }\n    public AssertionBuilder(System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertionData> assertionDataTask, string actualExpression, System.Text.StringBuilder expressionBuilder, System.Collections.Generic.Stack<TUnit.Assertions.AssertConditions.BaseAssertCondition> assertions) { }\n    protected void AppendCallerMethod(string?[] expressions, [System.Runtime.CompilerServices.CallerMemberName] string methodName = \"\") { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AssertionBuilder Abstract Class for TUnit in C#\nDESCRIPTION: This abstract class serves as a base for building assertions in the TUnit framework. It manages assertion data, results, and provides common functionality for different types of assertions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_53\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AssertionBuilder : TUnit.Assertions.AssertConditions.Interfaces.ISource\n{\n    protected TUnit.Assertions.AssertionData? AwaitedAssertionData;\n    protected TUnit.Assertions.AssertionBuilders.IInvokableAssertionBuilder? OtherTypeAssertionBuilder;\n    protected readonly System.Collections.Generic.List<TUnit.Assertions.AssertConditions.AssertionResult> Results;\n    public AssertionBuilder(TUnit.Assertions.AssertConditions.Interfaces.ISource source) { }\n    public AssertionBuilder(System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertionData> assertionDataTask, string? actualExpression) { }\n    public AssertionBuilder(System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertionData> assertionDataTask, string actualExpression, System.Text.StringBuilder expressionBuilder, System.Collections.Generic.Stack<TUnit.Assertions.AssertConditions.BaseAssertCondition> assertions) { }\n    protected void AppendCallerMethod(string?[] expressions, [System.Runtime.CompilerServices.CallerMemberName] string methodName = \"\") { }\n    [System.Diagnostics.DebuggerHidden]\n    [System.Obsolete(\"This is a base `object` method that should not be called.\", true)]\n    public new void Equals(object? obj) { }\n    [System.Diagnostics.DebuggerHidden]\n    [System.Obsolete(\"This is a base `object` method that should not be called.\", true)]\n    public void ReferenceEquals(object a, object b) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Skipping Tests with [Skip] Attribute in TUnit - C#\nDESCRIPTION: This snippet shows how to use the [Skip] attribute from the TUnit.Core library to skip a specific test, providing a reason for skipping via an attribute parameter. It requires TUnit.Core as a dependency and should be used within a test class. The test function marked with [Skip] will not run, and the provided reason will be reported. Inputs are the test method and attribute parameters; subject to TUnit's requirements for decorating methods.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/skip.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test, Skip(\"There's a bug! See issue #1\")]\n    public async Task MyTest()\n    {\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Retry Logic to Tests with TUnit in C#\nDESCRIPTION: This snippet shows how to apply TUnit's built-in RetryAttribute to a test method in C#. The attribute is configured to retry the test up to three times if it fails. Dependencies include TUnit.Core and any required test runner that supports these attributes. The test method MyTest is marked as asynchronous and will automatically be retried on any exception up to the specified limit. Suitable for handling sporadic failures caused by external resources or network instability.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/retrying.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    [Retry(3)]\n    public async Task MyTest()\n    {\n        \n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Skip Logic Attribute by Inheriting SkipAttribute - C#\nDESCRIPTION: This snippet defines a custom attribute WindowsOnlyAttribute that extends SkipAttribute to skip tests unless running on Windows. It overrides ShouldSkip to check the OS platform using RuntimeInformation. Requires a test context, System.Runtime.InteropServices, and async Task compatibility. The attribute enables conditional skipping for tests based on runtime environment at execution time.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/skip.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class WindowsOnlyAttribute() : SkipAttribute(\"This test is only supported on Windows\")\n{\n    public override Task<bool> ShouldSkip(BeforeTestContext context)\n    {\n        return Task.FromResult(!RuntimeInformation.IsOSPlatform(OSPlatform.Windows));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing TUnit Package using .NET CLI\nDESCRIPTION: Command for adding the TUnit package to an existing project using the .NET CLI with the prerelease flag to get the latest version.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/README_Template.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package TUnit --prerelease\n```\n\n----------------------------------------\n\nTITLE: Using MatrixMethod Attribute for Dynamic Test Cases in C#\nDESCRIPTION: Explains how to apply a method that returns an `IEnumerable<T>` as a data source for matrix-based testing in TUnit. The `[MatrixMethod]` attribute is used to reference a method, `Numbers`, generating values for `value2`. This snippet depends on the TUnit framework and demonstrates range specification for `value1` using `[MatrixRange]`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/matrix-tests.md#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nusing TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Assertions.Extensions.Is;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    [MatrixDataSource]\n    public async Task MyTest(\n        [MatrixRange<int>(1, 10)] int value1,\n        [MatrixMethod(nameof(Numbers))] int value2\n        )\n    {\n        var result = Add(value1, value2);\n\n        await Assert.That(result).IsPositive();\n    }\n\n    private int Add(int x, int y)\n    {\n        return x + y;\n    }\n\n    private IEnumerable<int> Numbers()\n    {\n        yield return 1;\n        yield return 2;\n        yield return 3;\n        yield return 4;\n        yield return 5;\n        yield return 6;\n        yield return 7;\n        yield return 8;\n        yield return 9;\n        yield return 10;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Test Metadata Collection Implementation in C#\nDESCRIPTION: Implements the core test metadata collection logic, handling test initialization, data source generation, and exception handling. Supports both instance method and matrix data sources.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1821.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1821.Tests),\n\t\t\tName = \"MethodDataSource\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.InstanceMethodDataSourceAttribute(\"DataSource\")\n\t\t\t],\n\t\t\t// ... additional implementation details\n\t\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PropertyAttribute in C#\nDESCRIPTION: Defines an attribute for adding custom properties to tests. It allows multiple instances and implements IEventReceiver and ITestDiscoveryEventReceiver interfaces.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\npublic class PropertyAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver\n{\n    public PropertyAttribute(string name, string value) { }\n    public string Name { get; }\n    public int Order { get; }\n    public string Value { get; }\n    public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Collection Empty Check in C#\nDESCRIPTION: Extension method to check if a generic collection is empty. Works with any IEnumerable<T> type and returns an assertion builder for fluent syntax.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsEmpty<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }\n```\n\n----------------------------------------\n\nTITLE: Defining TestDetails Class in C# for TUnit Framework\nDESCRIPTION: This class represents the details of a test in the TUnit framework. It includes properties for test attributes, categories, parallel constraints, and execution details. The class uses various attributes for serialization and compiler requirements.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    protected TestDetails() { }\n    [System.Text.Json.Serialization.JsonIgnore]\n    public System.Attribute[] AssemblyAttributes { get; }\n    [System.Text.Json.Serialization.JsonIgnore]\n    public System.Attribute[] Attributes { get; }\n    public System.Collections.Generic.IReadOnlyList<string> Categories { get; }\n    [System.Text.Json.Serialization.JsonIgnore]\n    public System.Attribute[] ClassAttributes { get; }\n    public abstract object ClassInstance { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public int CurrentRepeatAttempt { get; init; }\n    public System.Collections.Generic.IReadOnlyDictionary<string, string> CustomProperties { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    [System.Text.Json.Serialization.JsonIgnore]\n    public System.Attribute[] DataAttributes { get; init; }\n    [System.Text.Json.Serialization.JsonIgnore]\n    public System.Attribute[] DynamicAttributes { get; init; }\n    public TUnit.Core.Interfaces.IParallelConstraint? ParallelConstraint { get; }\n    public TUnit.Core.Interfaces.IParallelLimit? ParallelLimit { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public int RepeatLimit { get; init; }\n    public int RetryLimit { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Type ReturnType { get; init; }\n    [System.Text.Json.Serialization.JsonIgnore]\n    public System.Attribute[] TestAttributes { get; }\n    public TUnit.Core.SourceGeneratedClassInformation TestClass { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public object?[] TestClassArguments { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public object?[] TestClassInjectedPropertyArguments { get; init; }\n    public System.Type[] TestClassParameterTypes { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string TestFilePath { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string TestId { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public int TestLineNumber { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Core.SourceGeneratedMethodInformation TestMethod { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public object?[] TestMethodArguments { get; init; }\n    public System.Type[] TestMethodParameterTypes { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string TestName { get; init; }\n    public System.TimeSpan? Timeout { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Injecting a Shared Class Instance with Lifecycle Management using TUnit ClassDataSource in C#\nDESCRIPTION: This snippet shows how to use the `[ClassDataSource<T>]` attribute in TUnit to inject an instance of a specified class (`WebApplicationFactory`) into a test method (`MyTest`). It utilizes `Shared = SharedType.PerTestSession` to ensure the same instance is used across the test session. The injected class `WebApplicationFactory` implements `IAsyncInitializer` and `IAsyncDisposable` to handle asynchronous setup (`InitializeAsync`) and teardown (`DisposeAsync`) logic, respectively.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/class-data-source.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\npublic class MyTestClass\n{\n    [Test]\n    [ClassDataSource<WebApplicationFactory>(Shared = SharedType.PerTestSession)]\n    public void MyTest(WebApplicationFactory webApplicationFactory)\n    {\n    }\n\n    public record WebApplicationFactory : IAsyncInitializer, IAsyncDisposable\n    {\n        // Some properties/methods/whatever!\n\n        public Task InitializeAsync() \n        {\n            await StartServer();\n        }\n\n        public ValueTask DisposeAsync() \n        {\n            await StopServer();\n        }\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Registering a Conversion Assertion with an Extension Method in TUnit (C#)\nDESCRIPTION: This snippet shows how to register the custom conversion assertion condition (`HttpResponseIsProblemDetailsAssertCondition`) using an extension method. The `IsProblemDetails` extension method targets `IValueSource<HttpResponseMessage>` and calls `source.RegisterConversionAssertion(...)`, passing in an instance of the custom condition. This enables the `.IsProblemDetails()` syntax in the assertion chain and returns an `InvokableValueAssertionBuilder` typed for the target type (`ProblemDetails`).\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-assertions/extensibility/chaining-and-converting.md#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class HttpResponseAssertionExtensions\n{\n    public static InvokableValueAssertionBuilder<ProblemDetails> IsProblemDetails(this IValueSource<HttpResponseMessage> valueSource)\n    {\n        return valueSource.RegisterConversionAssertion(new HttpResponseIsProblemDetailsAssertCondition());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Timeout Attribute to a TUnit Test (C#)\nDESCRIPTION: This C# snippet demonstrates applying the [Timeout] attribute to a TUnit test method ([Test]) to enforce a maximum execution time. The attribute is initialized with an integer representing the timeout duration in milliseconds (30,000 ms = 30 seconds). The test method also receives a CancellationToken, which should be used within the test logic to enable graceful cancellation of operations if the timeout is exceeded. This relies on the TUnit.Core namespace.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/timeouts.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    [Timeout(30_000)]\n    public async Task MyTest(CancellationToken cancellationToken)\n    {\n        \n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Cleanup Methods in C# using TUnit\nDESCRIPTION: Demonstrates implementation of test cleanup methods using After attributes at both class and test levels. Includes examples of killing ChromeDriver processes after class execution and making HTTP notifications after each test.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/cleanup.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    private int _value;\n    private static HttpResponseMessage? _pingResponse;\n\n    [After(Class)]\n    public static async Task KillChromedrivers()\n    {\n        await Task.CompletedTask;\n\n        foreach (var process in Process.GetProcessesByName(\"chromedriver.exe\"))\n        {\n            process.Kill();\n        }\n    }\n    \n    [After(Test)]\n    public async Task AfterEachTest()\n    {\n        await new HttpClient().GetAsync($\"https://localhost/test-finished-notifier?testName={TestContext.Current.TestInformation.TestName}\");\n    }\n\n    [Test]\n    public async Task MyTest()\n    {\n        // Do something\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Test Hook Attributes in C#\nDESCRIPTION: Defines attributes for test lifecycle hooks including Before, BeforeEvery, After, and AfterEvery. These attributes are used to mark methods that should run at specific points during test execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Method)]\npublic sealed class BeforeAttribute : TUnit.Core.HookAttribute\n{\n    public BeforeAttribute(TUnit.Core.HookType hookType, [System.Runtime.CompilerServices.CallerFilePath] string file = \"\", [System.Runtime.CompilerServices.CallerLineNumber] int line = 0) { }\n}\n\n[System.AttributeUsage(System.AttributeTargets.Method)]\npublic sealed class BeforeEveryAttribute : TUnit.Core.HookAttribute\n{\n    public BeforeEveryAttribute(TUnit.Core.HookType hookType, [System.Runtime.CompilerServices.CallerFilePath] string file = \"\", [System.Runtime.CompilerServices.CallerLineNumber] int line = 0) { }\n}\n\n[System.AttributeUsage(System.AttributeTargets.Method)]\npublic sealed class AfterAttribute : TUnit.Core.HookAttribute\n{\n    public AfterAttribute(TUnit.Core.HookType hookType, [System.Runtime.CompilerServices.CallerFilePath] string file = \"\", [System.Runtime.CompilerServices.CallerLineNumber] int line = 0) { }\n}\n\n[System.AttributeUsage(System.AttributeTargets.Method)]\npublic sealed class AfterEveryAttribute : TUnit.Core.HookAttribute\n{\n    public AfterEveryAttribute(TUnit.Core.HookType hookType, [System.Runtime.CompilerServices.CallerFilePath] string file = \"\", [System.Runtime.CompilerServices.CallerLineNumber] int line = 0) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DataGeneratorMetadata Class in C#\nDESCRIPTION: This C# class `DataGeneratorMetadata` holds metadata required by data source generators in TUnit. It includes information about the test class type, instance, method, required members for generation, arguments, test session ID, and the type of data generator. It implements `IEquatable` for comparison.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n    public class DataGeneratorMetadata : System.IEquatable<TUnit.Core.DataGeneratorMetadata>\n    {\n        [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n            \"your compiler.\", true)]\n        public DataGeneratorMetadata() { }\n        public object?[]? ClassInstanceArguments { get; init; }\n        public TUnit.Core.SourceGeneratedMemberInformation[] MembersToGenerate { get; init; }\n        public TUnit.Core.TestBuilderContextAccessor TestBuilderContext { get; init; }\n        public object? TestClassInstance { get; init; }\n        public System.Type TestClassType { get; }\n        public TUnit.Core.SourceGeneratedMethodInformation TestInformation { get; init; }\n        public string TestSessionId { get; init; }\n        public TUnit.Core.Enums.DataGeneratorType Type { get; init; }\n    }\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for TUnit Tests\nDESCRIPTION: A comprehensive method that generates test metadata for all tests in the AttributeTests class. It handles test initialization, attribute collection, parameter management, and error handling during the collection process.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AttributeTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.AttributeTests),\n\t\t\tName = \"MyTest\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.TestProject.AttributeTests.MixedAttribute(),\n\t\t\t\tnew global::TUnit.TestProject.AttributeTests.MixedAttribute(\"Foo\"),\n\t\t\t\tnew global::TUnit.TestProject.AttributeTests.MixedAttribute(\"Foo\", \"Bar\"),\n\t\t\t\tnew global::TUnit.TestProject.AttributeTests.MixedAttribute(property2: \"Foo\"),\n\t\t\t\tnew global::TUnit.TestProject.AttributeTests.MixedAttribute()\n\t\t\t\t{\n\t\t\t\t\tProperty = \"Foo\",\n},\n\t\t\t\t\tnew global::TUnit.TestProject.AttributeTests.MixedAttribute(\"Foo\")\n\t\t\t\t\t{\n\t\t\t\t\t\tProperty = \"Bar\",\n},\n\t\t\t\t\t\tnew global::TUnit.TestProject.AttributeTests.MixedAttribute(property2: \"Foo\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tProperty = \"Bar\",\n},\n\t\t\t\t\t\t\tnew global::TUnit.TestProject.AttributeTests.MixedAttribute()\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tProperty = \"Foo\",\n\t\t\t\t\t\t\t\tProperty2 = 1,\n}\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AttributeTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.AttributeTests),\n\t\t\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AttributeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tName = \"AttributeTests\",\n\t\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\tName = \"AttributeTests\",\n\t\t\t\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t\t\t}),\n};\n\n\t\t\t\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\t\t\t\tglobal::TUnit.TestProject.AttributeTests? classInstance = null;\n\t\t\t\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.AttributeTests>(() => \n\t\t\t\t\t\t\tnew global::TUnit.TestProject.AttributeTests()\n\t\t\t\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.AttributeTests>\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tTestId = $\"TUnit.TestProject.AttributeTests.MyTest:0\",\n\t\t\t\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\t\t\t\tTestMethodArguments = [],\n\t\t\t\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.MyTest()),\n\t\t\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\t\t\tTestLineNumber = 7,\n\t\t\t\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\t\t\t\ttestBuilderContext = new();\n\t\t\t\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (global::System.Exception exception)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.AttributeTests>\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tTestId = $\"TUnit.TestProject.AttributeTests.MyTest:0\",\n\t\t\t\t\t\t\t\tMethodName = $\"MyTest\",\n\t\t\t\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"AttributeTests.MyTest failed to initialize\", exception),\n\t\t\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\t\t\tTestLineNumber = 7,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn nodes;\n\t\t\t\t\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing TUnit Test Source Interface in C#\nDESCRIPTION: This code implements the ITestSource interface for MethodDataSourceDrivenTests class, providing methods to initialize and collect tests. It includes ModuleInitializer for registration and methods to collect test metadata.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class MethodDataSourceDrivenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new MethodDataSourceDrivenTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\t// Implementation details...\n\t}\n```\n\n----------------------------------------\n\nTITLE: Collection Ordering Assertions in C#\nDESCRIPTION: Extension methods for verifying collection ordering including ascending, descending, and custom ordering using comparison selectors. Supports custom comparers for flexible ordering validation.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_48\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsOrderedBy<TInner, TComparisonItem>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, TComparisonItem> comparisonItemSelector, System.Collections.Generic.IComparer<TComparisonItem> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparisonItemSelector\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparer\")] string doNotPopulateThisValue2 = null) { }\n```\n\n----------------------------------------\n\nTITLE: Defining ThrowsAsync Assertion for Func<Task> (Any Exception) in C#\nDESCRIPTION: This overload of the static `ThrowsAsync` method asserts that awaiting the `Task` returned by the provided `Func<Task>` delegate results in any `System.Exception`. It returns a `Task<System.Exception>` containing the caught exception. The `CallerArgumentExpression` captures the source expression.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\n        public static System.Threading.Tasks.Task<System.Exception> ThrowsAsync(System.Func<System.Threading.Tasks.Task> @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression(\"delegate\")] string? doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Defining the Fail Assertion Method in C#\nDESCRIPTION: This static method `Fail` within the `Assert` class unconditionally fails the current test, providing the specified reason message. The `DoesNotReturn` attribute indicates that this method always terminates the execution flow, typically by throwing an exception.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n        [System.Diagnostics.CodeAnalysis.DoesNotReturn]\n        public static void Fail(string reason) { }\n```\n\n----------------------------------------\n\nTITLE: Defining AssertionBuilder Abstract Class in C#\nDESCRIPTION: Implements a base class for building assertions with various helper methods and properties. Includes debugger attributes and obsolete method markings.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_77\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AssertionBuilder : TUnit.Assertions.AssertConditions.Interfaces.ISource\n{\n    protected TUnit.Assertions.AssertionData? AwaitedAssertionData;\n    protected TUnit.Assertions.AssertionBuilders.IInvokableAssertionBuilder? OtherTypeAssertionBuilder;\n    protected readonly System.Collections.Generic.List<TUnit.Assertions.AssertConditions.AssertionResult> Results;\n    public AssertionBuilder(TUnit.Assertions.AssertConditions.Interfaces.ISource source) { }\n    public AssertionBuilder(System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertionData> assertionDataTask, string? actualExpression) { }\n    public AssertionBuilder(System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertionData> assertionDataTask, string actualExpression, System.Text.StringBuilder expressionBuilder, System.Collections.Generic.Stack<TUnit.Assertions.AssertConditions.BaseAssertCondition> assertions) { }\n    protected void AppendCallerMethod(string?[] expressions, [System.Runtime.CompilerServices.CallerMemberName] string methodName = \"\") { }\n    [System.Diagnostics.DebuggerHidden]\n    [System.Obsolete(\"This is a base `object` method that should not be called.\", true)]\n    public new void Equals(object? obj) { }\n    [System.Diagnostics.DebuggerHidden]\n    [System.Obsolete(\"This is a base `object` method that should not be called.\", true)]\n    public void ReferenceEquals(object a, object b) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Source Generated Method Information in C#\nDESCRIPTION: Class for representing source generated method information with required attributes. Contains properties for class reference, generic type count, parameters and return type.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\npublic class SourceGeneratedMethodInformation : TUnit.Core.SourceGeneratedMemberInformation, System.IEquatable<TUnit.Core.SourceGeneratedMethodInformation>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of your compiler.\", true)]\n    public SourceGeneratedMethodInformation() { }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Core.SourceGeneratedClassInformation Class { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public int GenericTypeCount { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Core.SourceGeneratedParameterInformation[] Parameters { get; init; }\n    [System.Text.Json.Serialization.JsonIgnore]\n    [get: System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode(\"Reflection API\")]\n    public System.Reflection.MethodInfo ReflectionInformation { get; set; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Type ReturnType { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public override System.Type Type { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic TUnit Test with Time Assertion\nDESCRIPTION: A simple TUnit test example that verifies a user creation timestamp is within an expected time range. The test uses async/await pattern and demonstrates the fluent assertion syntax with time-span tolerance.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/README_Template.md#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n    [Test]\n    public async Task Create_User_Has_Expected_Creation_Time()\n    {\n        var user = await CreateUser();\n\n        await Assert.That(user.CreatedAt)\n            .IsEqualTo(DateTime.Now)\n            .Within(TimeSpan.FromMinutes(1));\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining DiscoveredTestContext Class in C#\nDESCRIPTION: This C# class `DiscoveredTestContext` provides context during the test discovery phase in TUnit. It holds references to the `TestContext` and `TestDetails`. It offers methods to customize the discovered test, such as adding categories, properties, setting a display name, configuring parallel execution constraints, retry counts, and specifying argument formatters.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\n    public class DiscoveredTestContext\n    {\n        public bool RunOnTestDiscovery { get; set; }\n        public TUnit.Core.TestContext TestContext { get; }\n        public TUnit.Core.TestDetails TestDetails { get; }\n        public void AddArgumentDisplayFormatter(TUnit.Core.ArgumentDisplayFormatter formatter) { }\n        public void AddCategory(string category) { }\n        public void AddProperty(string key, string value) { }\n        public void SetDisplayName(string displayName) { }\n        public void SetParallelConstraint(TUnit.Core.Interfaces.IParallelConstraint parallelConstraint) { }\n        public void SetRetryCount(int times) { }\n        public void SetRetryCount(int times, System.Func<TUnit.Core.TestContext, System.Exception, int, System.Threading.Tasks.Task<bool>> shouldRetry) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Configuring Data-Driven Test Metadata in C#\nDESCRIPTION: Generates test metadata for a data-driven test method 'IntMaxValue' including argument configuration, class instantiation, and test execution setup. Handles test initialization with error catching and proper test context management.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_23\n\nLANGUAGE: csharp\nCODE:\n```\nnew global::TUnit.Core.ArgumentsAttribute(2147483647)],\nParameters = \n[\n\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t{\n\t\tName = \"value\",\n\t\tAttributes = [],\n\t},\n],\nClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n{\n\tType = typeof(global::TUnit.TestProject.DataDrivenTests),\n\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t{\n\t\tName = \"DataDrivenTests\",\n\t\tAttributes = [],\n\t}),\n\tName = \"DataDrivenTests\",\n\tNamespace = \"TUnit.TestProject\",\n\tAttributes = [],\n\tParameters = [],\n\tProperties = [],\n}),\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.DataDrivenTests? classInstance = null;\nobject?[]? classInstanceArguments = null;\nclassInstanceArguments = [];\n\nint methodArg = 2147483647;\n\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.DataDrivenTests>(() => \nnew global::TUnit.TestProject.DataDrivenTests()\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n```\n\nLANGUAGE: csharp\nCODE:\n```\nnodes.Add(new TestMetadata<global::TUnit.TestProject.DataDrivenTests>\n{\n\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.DataDrivenTests.IntMaxValue(int):0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [methodArg],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.IntMaxValue(methodArg)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 76,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Generic DependsOnAttribute<T> in C#\nDESCRIPTION: This C# attribute `DependsOnAttribute<T>` is a generic version of `DependsOnAttribute`, specifically designed for defining dependencies on tests within the class specified by the generic type parameter `T`. It provides constructors to specify the dependent test name and optionally its parameter types within class `T`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\n    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\n    public class DependsOnAttribute<T> : TUnit.Core.DependsOnAttribute\n    {\n        public DependsOnAttribute() { }\n        public DependsOnAttribute(string testName) { }\n        public DependsOnAttribute(string testName, System.Type[] parameterTypes) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Collection Single Item Assertion Extensions\nDESCRIPTION: Extension methods for asserting collections contain exactly one item.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_124\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.Wrappers.SingleItemAssertionBuilderWrapper<System.Collections.Generic.IEnumerable<TInner>, TInner> HasSingleItem<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }\npublic static TUnit.Assertions.AssertionBuilders.Wrappers.SingleItemAssertionBuilderWrapper<System.Collections.Immutable.ImmutableArray<TInner>, TInner> HasSingleItem<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ITestSource Interface for Test Collection\nDESCRIPTION: Implements the ITestSource interface to provide test collection functionality. The CollectTests method returns test metadata based on the provided session ID, enabling the test runner to discover and execute tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/PriorityFilteringTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class PriorityFilteringTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new PriorityFilteringTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\t// Implementation details follow...\n\t}\n```\n\n----------------------------------------\n\nTITLE: Using MethodDataSource with a Custom Record Type in TUnit (C#)\nDESCRIPTION: This C# example shows how to define a static method (`AdditionTestData` in `MyTestDataSources`) that returns a `Func<AdditionTestData>` to provide test data. The `[MethodDataSource]` attribute references this method (specifying the type and method name) to inject an `AdditionTestData` record into the `MyTest` method. Returning `Func<T>` is crucial for reference types to ensure test isolation by creating new instances for each test run. Dependencies include TUnit.Core and TUnit.Assertions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/method-data-source.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic record AdditionTestData(int Value1, int Value2, int ExpectedResult);\n\npublic static class MyTestDataSources\n{\n    public static Func<AdditionTestData> AdditionTestData()\n    {\n        return () => new AdditionTestData(1, 2, 3);\n    }\n}\n\npublic class MyTestClass\n{\n    [Test]\n    [MethodDataSource(typeof(MyTestDataSources), nameof(MyTestDataSources.AdditionTestData))]\n    public async Task MyTest(AdditionTestData additionTestData)\n    {\n        var result = Add(additionTestData.Value1, additionTestData.Value2);\n\n        await Assert.That(result).IsEqualTo(additionTestData.ExpectedResult);\n    }\n\n    private int Add(int x, int y)\n    {\n        return x + y;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Log Levels in TUnitLogger\nDESCRIPTION: This snippet demonstrates how to override the `IsEnabled` method in a logger class inheriting from `TUnitLogger` or `DefaultLogger`. The example modifies log level behavior to only enable logs with a level of `Error` or higher. Dependencies include Microsoft.Testing.Platform for log level context.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/logging.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic override bool IsEnabled(LogLevel logLevel)\n{\n    return logLevel >= LogLevel.Error;\n}\n```\n\n----------------------------------------\n\nTITLE: Advanced TUnit Testing with Hooks, Attributes and Custom Extensions\nDESCRIPTION: A comprehensive example demonstrating TUnit's advanced features including test lifecycle hooks, retry mechanisms, test dependencies, parallel execution control, test categorization, and custom attribute implementation. The example also shows data-driven testing and test customization capabilities.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/README_Template.md#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n    [Before(Class)]\n    public static async Task ClearDatabase(ClassHookContext context) { ... }\n\n    [After(Class)]\n    public static async Task AssertDatabaseIsAsExpected(ClassHookContext context) { ... }\n\n    [Before(Test)]\n    public async Task CreatePlaywrightBrowser(TestContext context) { ... }\n\n    [After(Test)]\n    public async Task DisposePlaywrightBrowser(TestContext context) { ... }\n\n    [Retry(3)]\n    [Test, DisplayName(\"Register an account\")]\n    [MethodDataSource(nameof(GetAuthDetails))]\n    public async Task Register(string username, string password) { ... }\n\n    [Repeat(5)]\n    [Test, DependsOn(nameof(Register))]\n    [MethodDataSource(nameof(GetAuthDetails))]\n    public async Task Login(string username, string password) { ... }\n\n    [Test, DependsOn(nameof(Login), [typeof(string), typeof(string)])]\n    [MethodDataSource(nameof(GetAuthDetails))]\n    public async Task DeleteAccount(string username, string password) { ... }\n\n    [Category(\"Downloads\")]\n    [Timeout(300_000)]\n    [Test, NotInParallel(Order = 1)]\n    public async Task DownloadFile1() { ... }\n\n    [Category(\"Downloads\")]\n    [Timeout(300_000)]\n    [Test, NotInParallel(Order = 2)]\n    public async Task DownloadFile2() { ... }\n\n    [Repeat(10)]\n    [Test]\n    [Arguments(1)]\n    [Arguments(2)]\n    [Arguments(3)]\n    [DisplayName(\"Go to the page numbered $page\")]\n    public async Task GoToPage(int page) { ... }\n\n    [Category(\"Cookies\")]\n    [Test, Skip(\"Not yet built!\")]\n    public async Task CheckCookies() { ... }\n\n    [Test, Explicit, WindowsOnlyTest, RetryHttpServiceUnavailable(5)]\n    [Property(\"Some Key\", \"Some Value\")]\n    public async Task Ping() { ... }\n\n    [Test]\n    [ParallelLimit<LoadTestParallelLimit>]\n    [Repeat(1000)]\n    public async Task LoadHomepage() { ... }\n\n    public static IEnumerable<(string Username, string Password)> GetAuthDetails()\n    {\n        yield return (\"user1\", \"password1\");\n        yield return (\"user2\", \"password2\");\n        yield return (\"user3\", \"password3\");\n    }\n\n    public class WindowsOnlyTestAttribute : SkipAttribute\n    {\n        public WindowsOnlyTestAttribute() : base(\"Windows only test\")\n        {\n        }\n\n        public override Task<bool> ShouldSkip(TestContext testContext)\n        {\n            return Task.FromResult(!OperatingSystem.IsWindows());\n        }\n    }\n\n    public class RetryHttpServiceUnavailableAttribute : RetryAttribute\n    {\n        public RetryHttpServiceUnavailableAttribute(int times) : base(times)\n        {\n        }\n\n        public override Task<bool> ShouldRetry(TestInformation testInformation, Exception exception, int currentRetryCount)\n        {\n            return Task.FromResult(exception is HttpRequestException { StatusCode: HttpStatusCode.ServiceUnavailable });\n        }\n    }\n\n    public class LoadTestParallelLimit : IParallelLimit\n    {\n        public int Limit => 50;\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining ThrowsAsync Assertion for Func<Task> (Specific Exception Type) in C#\nDESCRIPTION: This overload of the static `ThrowsAsync` method asserts that awaiting the `Task` from the provided `Func<Task>` delegate throws an exception of the specified `System.Type`. It returns a `Task<System.Exception>` containing the caught exception. The `CallerArgumentExpression` captures the source expression.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\n        public static System.Threading.Tasks.Task<System.Exception> ThrowsAsync(System.Type type, System.Func<System.Threading.Tasks.Task> @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression(\"delegate\")] string? doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Defining RetryAttribute in C#\nDESCRIPTION: Creates an attribute for retrying test execution a specified number of times. It implements IEventReceiver and ITestDiscoveryEventReceiver interfaces and includes a virtual method for determining retry conditions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\npublic class RetryAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver\n{\n    public RetryAttribute(int times) { }\n    public int Order { get; }\n    public int Times { get; }\n    public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }\n    public virtual System.Threading.Tasks.Task<bool> ShouldRetry(TUnit.Core.TestContext context, System.Exception exception, int currentRetryCount) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ValueAssertCondition for Generic Value Assertions in C#\nDESCRIPTION: Defines an abstract class for creating value-based assertion conditions. It provides methods for customizing comparisons and transformations of actual values.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_55\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n{\n    protected ValueAssertCondition() { }\n    protected override string GetExpectation() { }\n    protected abstract string GetFailureMessage(TActual? actualValue);\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n    protected abstract TUnit.Assertions.AssertConditions.AssertionResult Passes(TActual? actualValue);\n    public void WithComparer(System.Func<TActual?, TUnit.Assertions.AssertionDecision> comparer) { }\n    public void WithTransform(System.Func<TActual?, TActual?> actualTransformation) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Property Attribute in C#\nDESCRIPTION: Defines an attribute for adding custom name-value properties to tests. These properties can be used for filtering, categorization, or to store test metadata.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\npublic class PropertyAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver\n{\n    public PropertyAttribute(string name, string value) { }\n    public string Name { get; }\n    public int Order { get; }\n    public string Value { get; }\n    public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Test Initialization in C#\nDESCRIPTION: Handles exceptions during test initialization by creating a FailedTestMetadata object. Captures the exception details and adds them to the nodes collection for failed test reporting.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ArgsAsArrayTests.Test.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ArgsAsArrayTests>\n\t{\n\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.ArgsAsArrayTests.Following_Non_Params(int,System.Collections.Generic.IEnumerable<string>):0\",\n\t\tMethodName = $\"Following_Non_Params\",\n\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ArgsAsArrayTests.Following_Non_Params failed to initialize\", exception),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 45,\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: C# TUnit Test Result Class\nDESCRIPTION: Defines the TestResult class that captures test execution results including duration, start/end times, exceptions and status. Implements IEquatable for result comparison.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class TestResult : System.IEquatable<TUnit.Core.TestResult>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of your compiler.\", true)]\n    public TestResult() { }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string ComputerName { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.TimeSpan? Duration { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.DateTimeOffset? End { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Exception? Exception { get; init; }\n    public string? Output { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.DateTimeOffset? Start { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Core.Enums.Status Status { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Assertion Metadata Structure in TUnit (C#)\nDESCRIPTION: This struct defines metadata associated with an assertion, including the expected value, names of nested members being accessed, and the type of member (Property, Field, Value, EnumerableItem). It is used to provide context during assertion evaluation.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_34\n\nLANGUAGE: csharp\nCODE:\n```\n    public readonly record struct AssertionMetadata\n    {\n        public object? Expected { get; init; }\n        public string[] NestedMemberNames { get; init; }\n        public TUnit.Assertions.MemberType Type { get; init; }\n    }\n```\n\n----------------------------------------\n\nTITLE: Subscribing to TestEnd Event with Dependency Injection in C#\nDESCRIPTION: This C# snippet demonstrates a Dependency Injection Class Constructor class subscribing to the TestEnd event by implementing the ITestEndEventReceiver interface. The class manages service scope disposal at the end of a test, utilizing dependency injection. It requires dependencies such as IServiceProvider and AsyncServiceScope, and uses ActivatorUtilities to retrieve or create instances. It initializes a service provider with transient class registrations and disposes of the scope asynchronously at the test completion.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/event-subscribing.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DependencyInjectionClassConstructor : IClassConstructor, ITestEndEventReceiver\n{\n    private readonly IServiceProvider _serviceProvider = CreateServiceProvider();\n    private AsyncServiceScope _scope;\n    \n    public T Create<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] T>() where T : class\n    {\n        _scope = _serviceProvider.CreateAsyncScope();\n        \n        return ActivatorUtilities.GetServiceOrCreateInstance<T>(_scope.ServiceProvider);\n    }\n\n    public ValueTask OnTestEnd(TestContext testContext)\n    { \n        return _scope.DisposeAsync();\n    }\n\n    private static IServiceProvider CreateServiceProvider()\n    {\n        return new ServiceCollection()\n            .AddTransient<Class1>()\n            .AddTransient<Class2>()\n            .AddTransient<Class3>()\n            ...\n            .BuildServiceProvider();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining That Assertion for Task in C#\nDESCRIPTION: This overload of the static `That` method in the `Assert` class accepts a `System.Threading.Tasks.Task`. It returns an `AsyncDelegateAssertionBuilder` to allow assertions on the outcome of the task, such as whether it completes successfully or throws an exception. The `CallerArgumentExpression` attribute captures the source expression.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n        public static TUnit.Assertions.AssertionBuilders.AsyncDelegateAssertionBuilder That(System.Threading.Tasks.Task value, [System.Runtime.CompilerServices.CallerArgumentExpression(\"value\")] string? doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Defining Enumerable Collection Assertion Conditions in C#\nDESCRIPTION: A collection of class definitions for validating enumerable collections in the TUnit testing framework. These classes handle various assertion types such as checking if all items match a condition, contains specific items, count validation, equality testing, and ordering.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumerableContainsExpectedFuncAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n    where TActual : System.Collections.Generic.IEnumerable<TInner>\n{\n    public EnumerableContainsExpectedFuncAssertCondition(System.Func<TInner, bool> matcher, string? matcherString) { }\n    public TInner FoundItem { get; }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Chained Assertions with Type Conversion in TUnit (C#)\nDESCRIPTION: This snippet demonstrates how to use TUnit's assertion chaining feature where the type of the asserted object changes. It starts with an `HttpResponseMessage` (`response`), asserts it represents `ProblemDetails` using a custom `IsProblemDetails()` extension, and then continues chaining assertions specific to `ProblemDetails` (`HasTitle`, `HasDetail`).\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-assertions/extensibility/chaining-and-converting.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n        await Assert.That(response)\n            .IsProblemDetails()\n            .And\n            .HasTitle(\"Invalid Authentication Token\")\n            .And\n            .HasDetail(\"No token provided\");\n```\n\n----------------------------------------\n\nTITLE: Accessing Depended-On Test Context using TUnit TestContext in C#\nDESCRIPTION: Shows how a test (`DeleteItemFromBag`) that depends on another (`AddItemToBag`) can access the depended-on test's context. It uses `TestContext.Current!.GetTests(nameof(AddItemToBag))` to retrieve the context of `AddItemToBag` and then accesses its `ObjectBag` to get a shared value (`itemId`).\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/depends-on.md#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[Test]\npublic async Task AddItemToBag() \n{\n    var itemId = await AddToBag();\n    TestContext.Current!.ObjectBag.Add(\"ItemId\", itemId);\n}\n\n[Test]\n[DependsOn(nameof(AddItemToBag))]\npublic async Task DeleteItemFromBag() \n{\n    var addToBagTestContext = TestContext.Current!.GetTests(nameof(AddItemToBag)).First();\n    var itemId = addToBagTestContext.ObjectBag[\"ItemId\"];\n    await DeleteFromBag(itemId);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract DataSourceGeneratorAttribute<T1, T2, T3> in C#\nDESCRIPTION: This C# abstract attribute `DataSourceGeneratorAttribute<T1, T2, T3>` provides a base for creating custom data source attributes in TUnit that supply test data as triplets of types (T1, T2, T3). Inheriting from `TestDataAttribute` and `IDataAttribute`, it requires derived classes to implement the `GenerateDataSources` method, which should yield functions producing `ValueTuple<T1, T2, T3>` instances using the `DataGeneratorMetadata`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\n    public abstract class DataSourceGeneratorAttribute<T1, T2, T3> : TUnit.Core.TestDataAttribute, TUnit.Core.IDataAttribute\n    {\n        protected DataSourceGeneratorAttribute() { }\n        public abstract System.Collections.Generic.IEnumerable<System.Func<System.ValueTuple<T1, T2, T3>>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata);\n    }\n```\n\n----------------------------------------\n\nTITLE: Generating TestMetadata for Property Setter Tests in C#\nDESCRIPTION: This code creates and populates TestMetadata objects for PropertySetterTests in the TUnit framework. It configures test class properties, sets up factories for test execution, includes file path and line number information, and adds error handling through a try-catch block that captures initialization failures.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/PropertySetterTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nnodes.Add(new TestMetadata<global::TUnit.TestProject.PropertySetterTests>\n{\n\tTestId = $\"TUnit.TestProject.PropertySetterTests.Test:0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [],\n\tTestClassProperties = [propertyArg, propertyArg1, propertyArg2, propertyArg3, propertyArg4, propertyArg5],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Test()),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 70,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Collecting After-Test Global Hooks for TUnit in C#\nDESCRIPTION: This C# snippet defines the CollectAfterEveryTestHooks method, returning a list of static after-every-test hooks for TUnit. It sets up metadata for AfterTestHookMethod including method information, parameters, and related Type/class structure for \"GlobalBase3.AfterAll3\". The hook is linked to the AfterEvery attribute and can perform async test finalization. Dependencies: TUnit.Core, TUnit.Core.Hooks, and related test infrastructure. Inputs are a sessionId string and expected output is a list of static hooks.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticAfterEachTests.Test.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.AfterTestHookMethod\n\t\t{ \n\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.GlobalBase3),\n\t\t\tName = \"AfterAll3\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.AfterEveryAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext>\n\t\t\t\t{\n\t\t\t\t\tName = \"context\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.GlobalBase3\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.GlobalBase3),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"GlobalStaticAfterEachTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"GlobalStaticAfterEachTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"GlobalBase3\",\n\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n},\n\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.GlobalBase3.AfterAll3(context)),\n\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\tOrder = 0,\n\t\t\tFilePath = @\"\",\n\t\t\tLineNumber = 35,\n\t\t\tMethodAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.AfterEveryAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t],\n\t\t\tClassAttributes = [],\n\t\t\tAssemblyAttributes = [],\n\t\t},\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ImmutableArray Equivalence Extensions in C#\nDESCRIPTION: Extension methods for checking non-equivalence between ImmutableArray collections. Includes overloads for custom comparers and collection ordering options.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_127\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsNotEquivalentTo<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparer\")] string doNotPopulateThisValue2 = null) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Abstract Executor for Test and Hook Execution in C#\nDESCRIPTION: Abstract class implementing test execution and hook handling interfaces. Provides methods for executing various lifecycle hooks at different stages of the testing process (before/after test, class, assembly, test session, etc.).\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class GenericAbstractExecutor : TUnit.Core.Interfaces.IHookExecutor, TUnit.Core.Interfaces.ITestExecutor\n{\n    protected GenericAbstractExecutor() { }\n    public System.Threading.Tasks.ValueTask ExecuteAfterAssemblyHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.AssemblyHookContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteAfterClassHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.ClassHookContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteAfterTestDiscoveryHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestDiscoveryContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteAfterTestHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteAfterTestSessionHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestSessionContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    protected abstract System.Threading.Tasks.ValueTask ExecuteAsync(System.Func<System.Threading.Tasks.ValueTask> action);\n    public System.Threading.Tasks.ValueTask ExecuteBeforeAssemblyHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.AssemblyHookContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteBeforeClassHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.ClassHookContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteBeforeTestDiscoveryHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.BeforeTestDiscoveryContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteBeforeTestHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteBeforeTestSessionHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestSessionContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteTest(TUnit.Core.TestContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Test Configuration with TUnit in Csharp\nDESCRIPTION: The C# snippet demonstrates how to use the TUnit `TestContext.Configuration.Get` method to retrieve values from the test configuration file specified in `testconfig.json`. This example fetches values using keys, including nested key paths, and is part of an async test method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/test-configuration.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n    [Test]\n    public async Task Test()\n    {\n        var value1 = TestContext.Configuration.Get(\"MyKey1\"); // MyValue1 - As defined above\n        var value2 = TestContext.Configuration.Get(\"Nested:MyKey2\"); // MyValue2 - As defined above\n        \n        ...\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining Metadata, Test Discovered Context, and Default Execution - C#\nDESCRIPTION: This snippet defines utility and context classes: DataGeneratorMetadata for tracking data generation context, DefaultExecutor as a singleton providing a default async execution strategy, and DiscoveredTestContext for managing properties and behaviors of discovered tests. These components underpin data-driven and asynchronous test execution, and provide means to extend or interface with TUnit's test discovery and execution pipeline.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class DataGeneratorMetadata : System.IEquatable<TUnit.Core.DataGeneratorMetadata>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public DataGeneratorMetadata() { }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public object?[]? ClassInstanceArguments { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Core.SourceGeneratedMemberInformation[] MembersToGenerate { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Core.TestBuilderContextAccessor TestBuilderContext { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public object? TestClassInstance { get; init; }\n    public System.Type TestClassType { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Core.SourceGeneratedMethodInformation TestInformation { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string TestSessionId { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Core.Enums.DataGeneratorType Type { get; init; }\n}\npublic class DiscoveredTestContext\n{\n    public bool RunOnTestDiscovery { get; set; }\n    public TUnit.Core.TestContext TestContext { get; }\n    public TUnit.Core.TestDetails TestDetails { get; }\n    public void AddArgumentDisplayFormatter(TUnit.Core.ArgumentDisplayFormatter formatter) { }\n    public void AddCategory(string category) { }\n    public void AddProperty(string key, string value) { }\n    public void SetDisplayName(string displayName) { }\n    public void SetParallelConstraint(TUnit.Core.Interfaces.IParallelConstraint parallelConstraint) { }\n    public void SetRetryCount(int times) { }\n    public void SetRetryCount(int times, System.Func<TUnit.Core.TestContext, System.Exception, int, System.Threading.Tasks.Task<bool>> shouldRetry) { }\n}\npublic class DefaultExecutor : TUnit.Core.GenericAbstractExecutor\n{\n    public static readonly TUnit.Core.DefaultExecutor Instance;\n    protected override System.Threading.Tasks.ValueTask ExecuteAsync(System.Func<System.Threading.Tasks.ValueTask> action) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TestContext Extension Methods in C#\nDESCRIPTION: Extension methods for the TestContext class that provide additional functionality for test management, including dynamic test creation, test name retrieval, and test lookup by name and parameter types.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_57\n\nLANGUAGE: C#\nCODE:\n```\npublic static class TestContextExtensions\n{\n    [System.Diagnostics.CodeAnalysis.Experimental(\"WIP\")]\n    public static System.Threading.Tasks.Task AddDynamicTest<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicParameterlessConstructor | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]  T>(this TUnit.Core.TestContext testContext, TUnit.Core.DynamicTest<T> dynamicTest)\n        where T :  class { }\n    public static string GetClassTypeName(this TUnit.Core.TestContext testContext) { }\n    public static string GetTestDisplayName(this TUnit.Core.TestContext testContext) { }\n    public static TUnit.Core.TestContext[] GetTests(this TUnit.Core.TestContext context, string testName) { }\n    public static TUnit.Core.TestContext[] GetTests(this TUnit.Core.TestContext context, string testName, System.Type[] parameterTypes) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ParallelLimiterAttribute in C#\nDESCRIPTION: Creates a generic attribute for limiting parallel test execution. It implements IEventReceiver and ITestRegisteredEventReceiver interfaces to handle test registration events.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\npublic sealed class ParallelLimiterAttribute<TParallelLimit> : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestRegisteredEventReceiver\n    where TParallelLimit : TUnit.Core.Interfaces.IParallelLimit, new ()\n{\n    public ParallelLimiterAttribute() { }\n    public int Order { get; }\n    public System.Threading.Tasks.ValueTask OnTestRegistered(TUnit.Core.TestRegisteredContext testRegisteredContext) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Test Data and Arguments Attributes in C#\nDESCRIPTION: Defines attributes for providing test data, including the ArgumentsAttribute for inline test arguments. These attributes are used to specify test data for parameterized tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method | System.AttributeTargets.Property, AllowMultiple=true)]\npublic sealed class ArgumentsAttribute : TUnit.Core.TestDataAttribute\n{\n    public ArgumentsAttribute() { }\n    public ArgumentsAttribute(params object?[]? values) { }\n    public object?[] Values { get; }\n}\n\n[System.AttributeUsage(System.AttributeTargets.Method)]\npublic abstract class BaseTestAttribute : TUnit.Core.TUnitAttribute\n{\n    public readonly string File;\n    public readonly int Line;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Test Metadata with Tuple Parameters to Test Collection in C#\nDESCRIPTION: This snippet creates a TestMetadata object for the test method with tuple parameters and adds it to the test collection. It includes test ID, arguments, properties, and factory methods for test execution, along with error handling through try-catch.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nnodes.Add(new TestMetadata<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>\n{\n\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS0:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.ClassTupleDataSourceDrivenTests(int,string,bool).DataSource_TupleMethod(int,string,bool):0\",\n\tTestClassArguments = [classArg, classArg1, classArg2],\n\tTestMethodArguments = [methodArg, methodArg1, methodArg2],\n\tTestClassProperties = [propertyArg, propertyArg1, propertyArg2, propertyArg3],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_TupleMethod(methodArg, methodArg1, methodArg2)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 24,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel Execution Control in C#\nDESCRIPTION: Attribute for controlling parallel test execution with constraint keys. Allows tests to be grouped and executed sequentially based on specified constraint keys.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\npublic class NotInParallelAttribute : TUnit.Core.SingleTUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver\n{\n    public NotInParallelAttribute() { }\n    public NotInParallelAttribute(string constraintKey) { }\n    public NotInParallelAttribute(string[] constraintKeys) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ComparisonFailure Class in C#\nDESCRIPTION: Defines the `ComparisonFailure` class, representing a single point of difference found during an object equivalency check performed by `Compare.CheckEquivalent`. It includes the actual value encountered at the point of failure. Implements `IEquatable`. The `Obsolete` attribute suggests potential issues with required members in older compilers.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_33\n\nLANGUAGE: csharp\nCODE:\n```\n    public class ComparisonFailure : System.IEquatable<TUnit.Assertions.ComparisonFailure>\n    {\n        [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n            \"your compiler.\", true)]\n        public ComparisonFailure() { }\n        public object? Actual { get; init; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Setup Methods in TUnit Test Class - C#\nDESCRIPTION: This snippet demonstrates using TUnit attributes to define setup methods within a test class. The [Before(Class)] attribute is used for an asynchronous ping operation executed before tests start in the class, while [Before(Test)] prepares the test's state. Requires TUnit framework and HttpClient. The method Ping() ensures the target service is responsive, and Setup() initializes test variables. Expected conditions like response status and variable values are asserted during MyTest().\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/setup.md#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    private int _value;\n    private static HttpResponseMessage? _pingResponse;\n\n    [Before(Class)]\n    public static async Task Ping()\n    {\n        _pingResponse = await new HttpClient().GetAsync(\"https://localhost/ping\");\n    }\n    \n    [Before(Test)]\n    public async Task Setup()\n    {\n        await Task.CompletedTask;\n        \n        _value = 99;\n    }\n\n    [Test]\n    public async Task MyTest()\n    {\n        await Assert.That(_value).IsEqualTo(99);\n        await Assert.That(_pingResponse?.StatusCode)\n            .IsNotNull()\n            .And.IsEqualTo(HttpStatusCode.OK);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Dynamic Tests in C#\nDESCRIPTION: Demonstrates how to create a basic dynamic test using TUnit's DynamicTestBuilder attribute. The example shows a test that calls a method with a string parameter and includes a repeat attribute.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/experimental/dynamic-tests.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace TUnit.TestProject.DynamicTests;\n\npublic class Basic\n{\n    public void SomeMethod(string name)\n    {\n        Console.WriteLine(@$\"Hello, {name}!\");\n    }\n    \n    [DynamicTestBuilder]\n    public void BuildTests(DynamicTestBuilderContext context)\n    {\n        context.AddTest(new DynamicTest<Basic>\n        {\n            TestMethod = @class => @class.SomeMethod(DynamicTest.Argument<string>()),\n            TestMethodArguments = [ \"Tom\" ],\n            Attributes = [new RepeatAttribute(5)]\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StopExecutionCapability for Graceful Test Termination\nDESCRIPTION: Defines a capability class that implements Microsoft Testing Platform interfaces to support graceful termination of test execution. It tracks stop requests and exposes an event for notification.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class StopExecutionCapability : Microsoft.Testing.Platform.Capabilities.ICapability, Microsoft.Testing.Platform.Capabilities.TestFramework.IGracefulStopTestExecutionCapability, Microsoft.Testing.Platform.Capabilities.TestFramework.ITestFrameworkCapability\n{\n    public StopExecutionCapability() { }\n    public bool IsStopRequested { get; }\n    public TUnit.Core.AsyncEvent<System.EventArgs>? OnStopRequested { get; set; }\n    public System.Threading.Tasks.Task StopTestExecutionAsync(System.Threading.CancellationToken cancellationToken) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Is Assertions in C#\nDESCRIPTION: Defines extension methods for generic type assertions, including type compatibility checks, equality comparisons, and reference equality. Uses CallerArgumentExpression for better error messages.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_118\n\nLANGUAGE: C#\nCODE:\n```\npublic static class GenericIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsAssignableFrom(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource, System.Type type) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsAssignableFrom<TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsAssignableTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource, System.Type type) { }\n    public static TUnit.Assertions.AssertionBuilders.CastedAssertionBuilder<object, TExpected> IsAssignableTo<TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.GenericEqualToAssertionBuilderWrapper<TActual> IsEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null) { }\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.GenericEqualToAssertionBuilderWrapper<TActual> IsEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, System.Collections.Generic.IEqualityComparer<TActual> equalityComparer, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsEquatableOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null) { }\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.EquivalentToAssertionBuilderWrapper<TActual, TExpected> IsEquivalentTo<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TActual, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TExpected expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsNotAssignableFrom(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource, System.Type type) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsNotAssignableFrom<TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsNotAssignableTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource, System.Type type) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsNotAssignableTo<TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsNotTypeOf(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource, System.Type type) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsNotTypeOf<TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNull<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsSameReferenceAs<TActual, TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TExpected expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsTypeOf(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource, System.Type type) { }\n    public static TUnit.Assertions.AssertionBuilders.CastedAssertionBuilder<object, TExpected> IsTypeOf<TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic ThrowsAsync Assertion for Task in C#\nDESCRIPTION: This generic overload of `ThrowsAsync` asserts that awaiting the provided `Task` delegate throws an exception of type `TException`. It returns a `Task<TException>` containing the strongly-typed caught exception. The `CallerArgumentExpression` captures the source expression.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_25\n\nLANGUAGE: csharp\nCODE:\n```\n        public static System.Threading.Tasks.Task<TException> ThrowsAsync<TException>(System.Threading.Tasks.Task @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression(\"delegate\")] string? doNotPopulateThisValue = null)\n            where TException : System.Exception { }\n```\n\n----------------------------------------\n\nTITLE: Initializing Test Class in C#\nDESCRIPTION: Creates a basic class structure under a dedicated namespace for testing purposes but does not include any test logic. Prerequisites include being familiar with C# class syntax.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/writing-your-first-test.md#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    \n}\n```\n\n----------------------------------------\n\nTITLE: TUnit CLI Flags Reference\nDESCRIPTION: Complete reference of command line flags for TUnit testing framework, including diagnostic logging, test execution controls, coverage reporting, and output customization options. Each flag is documented with its purpose and available options where applicable.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/command-line-flags.md#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n    --diagnostic\n        Enable the diagnostic logging. The default log level is 'Trace'.\n        The file will be written in the output directory with the name log_[MMddHHssfff].diag\n\n    --diagnostic-filelogger-synchronouswrite\n        Force the built-in file logger to write the log synchronously.\n        Useful for scenario where you don't want to lose any log (i.e. in case of crash).\n        Note that this is slowing down the test execution.\n\n    --diagnostic-output-directory\n        Output directory of the diagnostic logging.\n        If not specified the file will be generated inside the default 'TestResults' directory.\n\n    --diagnostic-output-fileprefix\n        Prefix for the log file name that will replace '[log]_.'\n\n    --diagnostic-verbosity\n        Define the level of the verbosity for the --diagnostic.\n        The available values are 'Trace', 'Debug', 'Information', 'Warning', 'Error', and 'Critical'.\n\n    --exit-on-process-exit\n        Exit the test process if dependent process exits. PID must be provided.\n\n    --help\n        Show the command line help.\n\n    --ignore-exit-code\n        Do not report non successful exit value for specific exit codes\n        (e.g. '--ignore-exit-code 8;9' ignore exit code 8 and 9 and will return 0 in these case)\n\n    --info\n        Display .NET test application information.\n\n    --list-tests\n        List available tests.\n\n    --minimum-expected-tests\n        Specifies the minimum number of tests that are expected to run.\n\n    --results-directory\n        The directory where the test results are going to be placed.\n        If the specified directory doesn't exist, it's created.\n        The default is TestResults in the directory that contains the test application.\n\n    --timeout\n        A global test execution timeout.\n        Takes one argument as string in the format [h|m|s] where 'value' is float.\n\n    --coverage\n        Collect the code coverage using dotnet-coverage tool\n\n    --coverage-output\n        Output file\n\n    --coverage-output-format\n        Output file format. Supported values: 'coverage', 'xml' and 'cobertura'\n\n    --coverage-settings\n        XML code coverage settings\n\n    --disable-logo\n        Disables the TUnit logo when starting a test session\n\n    --fail-fast\n        Cancel the test run after the first test failure\n\n    --hide-test-output\n        Hide Test Output\n\n    --maximum-parallel-tests\n        Maximum Parallel Tests\n\n    --no-ansi\n        Disable outputting ANSI escape characters to screen.\n\n    --no-progress\n        Disable reporting progress to screen.\n\n    --output\n        Output verbosity when reporting tests.\n        Valid values are 'Normal', 'Detailed'. Default is 'Normal'.\n\n    --report-trx\n        Enable generating TRX report\n\n    --report-trx-filename\n        The name of the generated TRX report\n\n    --test-parameter\n        Custom parameters to pass to TUnit\n\n    --treenode-filter\n        Use a tree filter to filter down the tests to execute\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract DataSourceGeneratorAttribute<T> in C#\nDESCRIPTION: This abstract C# attribute `DataSourceGeneratorAttribute<T>` serves as a base class for data source attributes in TUnit that generate data of a single type `T`. It inherits from `TestDataAttribute` and implements `IDataAttribute`. Derived classes must implement the `GenerateDataSources` method, which takes `DataGeneratorMetadata` and returns an enumerable of functions, each producing a data item of type `T`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method | System.AttributeTargets.Property, AllowMultiple=true)]\n    public abstract class DataSourceGeneratorAttribute<T> : TUnit.Core.TestDataAttribute, TUnit.Core.IDataAttribute\n    {\n        protected DataSourceGeneratorAttribute() { }\n        public abstract System.Collections.Generic.IEnumerable<System.Func<T>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata);\n    }\n```\n\n----------------------------------------\n\nTITLE: Handling Failed Test Metadata in TUnit C#\nDESCRIPTION: The snippet showcases error handling in the test execution lifecycle within the TUnit framework. It handles exceptions by creating instances of FailedTestMetadata with relevant information on the error and test context.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ArgsAsArrayTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ArgsAsArrayTests>\n{\n    TestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.ArgsAsArrayTests.ParamsEnumerable(System.Collections.Generic.IEnumerable<string>):0\",\n    MethodName = $\"ParamsEnumerable\",\n    Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ArgsAsArrayTests.ParamsEnumerable failed to initialize\", exception),\n    TestFilePath = @\"\",\n    TestLineNumber = 25,\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel Limit Lock Provider in C#\nDESCRIPTION: Provides locking mechanisms for limiting parallel test execution. This class is likely used internally by the testing framework to enforce parallel execution constraints.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic class ParallelLimitLockProvider\n{\n    public ParallelLimitLockProvider() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UnknownAssertionGroup class in C#\nDESCRIPTION: Generic class for unknown assertion groups that supports combining assertions with 'And' and 'Or' logical operators. It accepts a function that returns an invokable assertion builder.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_83\n\nLANGUAGE: C#\nCODE:\n```\n    public class UnknownAssertionGroup<TActual, TAssertionBuilder>\n        where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder\n    {\n        public TUnit.Assertions.AssertionBuilders.Groups.AndAssertionGroup<TActual, TAssertionBuilder> And(System.Func<TAssertionBuilder, TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TActual>> assert) { }\n        public TUnit.Assertions.AssertionBuilders.Groups.OrAssertionGroup<TActual, TAssertionBuilder> Or(System.Func<TAssertionBuilder, TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TActual>> assert) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Generating Test Instances for Each Data Source in C#\nDESCRIPTION: Loop that creates test instances for each generated data source. It configures test metadata with unique IDs, arguments, and factory methods for test execution, handling class instance creation and test context management.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nforeach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\n{\n\ttestMethodDataIndex++;\n\tclassInstanceArguments = [];\n\n\tvar methodArgGeneratedData = methodArgGeneratedDataAccessor();\n\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ClassDataSourceDrivenTests>(() => \n\tnew global::TUnit.TestProject.ClassDataSourceDrivenTests()\n\t, sessionId, testBuilderContext);\n\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\tnodes.Add(new TestMetadata<global::TUnit.TestProject.ClassDataSourceDrivenTests>\n\t{\n\t\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.InitializableClass>:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.ClassDataSourceDrivenTests.IsInitialized_With_1_ClassDataSource(TUnit.TestProject.InitializableClass):0\",\n\t\tTestClassArguments = [],\n\t\tTestMethodArguments = [methodArgGeneratedData],\n\t\tTestClassProperties = [],\n\t\tCurrentRepeatAttempt = 0,\n\t\tRepeatLimit = 0,\n\t\tResettableClassFactory = resettableClassFactory,\n\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.IsInitialized_With_1_ClassDataSource(methodArgGeneratedData)),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 24,\n\t\tTestMethod = testInformation,\n\t\tTestBuilderContext = testBuilderContext,\n\t});\n\tresettableClassFactory = resettableClassFactoryDelegate();\n\ttestBuilderContext = new();\n\ttestBuilderContextAccessor.Current = testBuilderContext;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Implicit Assertion Scope in TUnit with C#\nDESCRIPTION: This code snippet demonstrates creating an implicit assertion scope in TUnit using the Assert.Multiple() method. It requires the IDisposable interface, and the scoped assertions are encapsulated using the 'using var' syntax. The expected input is a result from an operation, and the output is aggregated assertion results that are thrown after exiting the scope.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-assertions/scopes.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[Test]\n    public async Task MyTest()\n    {\n        var result = Add(1, 2);\n\n        using var _ = Assert.Multiple();\n\n        await Assert.That(result).IsPositive();\n        await Assert.That(result).IsEqualTo(3);\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Ordered Test Execution in C# with TUnit\nDESCRIPTION: Demonstrates how to order test execution using the NotInParallel attribute with Order property. The example shows two test methods ordered sequentially with Order values 1 and 2, ensuring MyTest executes before MyTest2 when not running in parallel.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/order.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    [NotInParallel(Order = 1)]\n    public async Task MyTest()\n    {\n        \n    }\n\n    [Test]\n    [NotInParallel(Order = 2)]\n    public async Task MyTest2()\n    {\n        \n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Test Event Receiver Interfaces\nDESCRIPTION: Collection of interfaces for handling various test lifecycle events like test start, end, skip, and retry.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_65\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ITestStartEventReceiver : TUnit.Core.Interfaces.IEventReceiver {\n    System.Threading.Tasks.ValueTask OnTestStart(TUnit.Core.BeforeTestContext beforeTestContext);\n}\n\npublic interface ITestEndEventReceiver : TUnit.Core.Interfaces.IEventReceiver {\n    System.Threading.Tasks.ValueTask OnTestEnd(TUnit.Core.TestContext testContext);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Class Hook Collection Interface in C#\nDESCRIPTION: Defines an interface IClassHookSource for collecting various types of class hooks in TUnit. It includes methods for before and after class hooks, as well as hooks that run before and after every class.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_58\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IClassHookSource\n{\n    System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.ClassHookContext>> CollectAfterClassHooks(string sessionId);\n    System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.ClassHookContext>> CollectAfterEveryClassHooks(string sessionId);\n    System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.ClassHookContext>> CollectBeforeClassHooks(string sessionId);\n    System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SkipAttribute in C#\nDESCRIPTION: Defines an attribute for skipping test execution. It implements IEventReceiver and ITestRegisteredEventReceiver interfaces and includes a virtual method for determining skip conditions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\npublic class SkipAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestRegisteredEventReceiver\n{\n    public SkipAttribute(string reason) { }\n    public int Order { get; }\n    public string Reason { get; protected set; }\n    public System.Threading.Tasks.ValueTask OnTestRegistered(TUnit.Core.TestRegisteredContext context) { }\n    public virtual System.Threading.Tasks.Task<bool> ShouldSkip(TUnit.Core.BeforeTestContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TestResult Class in C#\nDESCRIPTION: This class represents the result of a test execution, including status, duration, and any exceptions that occurred. It implements IEquatable for comparison purposes.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_52\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestResult : System.IEquatable<TUnit.Core.TestResult>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public TestResult() { }\n    public string ComputerName { get; init; }\n    public System.TimeSpan? Duration { get; init; }\n    public System.DateTimeOffset? End { get; init; }\n    public System.Exception? Exception { get; init; }\n    public string? Output { get; }\n    public System.DateTimeOffset? Start { get; init; }\n    public TUnit.Core.Enums.Status Status { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Static After Every Test Hooks - TUnit Core - C#\nDESCRIPTION: This method returns a list of static hook methods to run after every test, each defined with method metadata, parameters, and attributes tied to TUnit's core hook infrastructure. It utilizes source generation and core types from TUnit to assemble the hook method information. It expects a session ID and returns information necessary for the test runner to schedule or invoke these hooks; dependencies are TUnit.Core and TUnit.Core.Hooks namespaces.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticAfterEachTests.Test.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.AfterTestHookMethod\n\t\t{ \n\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),\n\t\t\tName = \"AfterAllCleanUpWithContext\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.AfterEveryAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext>\n\t\t\t\t{\n\t\t\t\t\tName = \"context\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.GlobalCleanUpTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"GlobalStaticAfterEachTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"GlobalStaticAfterEachTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"GlobalCleanUpTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n},\n\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.GlobalCleanUpTests.AfterAllCleanUpWithContext(context)),\n\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\tOrder = 0,\n\t\t\tFilePath = @\"\",\n\t\t\tLineNumber = 62,\n\t\t\tMethodAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.AfterEveryAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t],\n\t\t\tClassAttributes = [],\n\t\t\tAssemblyAttributes = [],\n\t\t},\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Enumerable Count Assertions in C#\nDESCRIPTION: Defines a class for asserting properties of enumerable collections, including emptiness, count equality, and count comparisons. Uses generic constraints to ensure type safety.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_117\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumerableCount<TActual, TInner>\n    where TActual : System.Collections.Generic.IEnumerable<TInner>\n{\n    public EnumerableCount(TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> Empty { get; }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> EqualTo(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> EqualToOne() { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> EqualToZero() { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> GreaterThan(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> GreaterThanOrEqualTo(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> LessThan(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> LessThanOrEqualTo(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> Negative() { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> Positive() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EquivalentToAssertionBuilderWrapper in C#\nDESCRIPTION: Wrapper for object equivalence assertions with options to ignore specific members or enable partial equivalency checking between actual and expected objects.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_87\n\nLANGUAGE: C#\nCODE:\n```\n    public class EquivalentToAssertionBuilderWrapper<TActual, TExpected> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>\n    {\n        public TUnit.Assertions.AssertionBuilders.Wrappers.EquivalentToAssertionBuilderWrapper<TActual, TExpected> IgnoringMember(string propertyName, [System.Runtime.CompilerServices.CallerArgumentExpression(\"propertyName\")] string doNotPopulateThis = \"\") { }\n        public TUnit.Assertions.AssertionBuilders.Wrappers.EquivalentToAssertionBuilderWrapper<TActual, TExpected> WithPartialEquivalency() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Repetition with RepeatAttribute in C#\nDESCRIPTION: Demonstrates how to configure a test method to repeat multiple times using the RepeatAttribute. The example shows a test that will run 3 times, with each execution appearing as a separate test in the test explorer. The attribute can be applied to individual methods or entire classes.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/repeating.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    [Repeat(3)]\n    public async Task MyTest()\n    {\n        \n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Collection Equivalence Assertion Methods in C#\nDESCRIPTION: A set of extension methods that allow assertion of non-equivalence between collections. These methods support optional custom comparers and collection ordering rules, enabling flexible comparison scenarios in tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_131\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotEquivalentTo<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparer\")] string doNotPopulateThisValue2 = null)\n            where TActual : System.Collections.Generic.IEnumerable<TInner> { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotEquivalentTo<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"collectionOrdering\")] string doNotPopulateThisValue2 = null)\n            where TActual : System.Collections.Generic.IEnumerable<TInner> { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotEquivalentTo<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"collectionOrdering\")] string doNotPopulateThisValue2 = null)\n            where TActual : System.Collections.Generic.IEnumerable<TInner> { }\n```\n\n----------------------------------------\n\nTITLE: Registering and Initializing After Test Discovery Hooks in TUnit - C#\nDESCRIPTION: This snippet auto-generates a similar partial class for after-discovery hooks within the TUnit testing framework in C#. The Initialise method registers the class as a TestDiscoveryHookSource with the SourceRegistrar. The CollectAfterTestDiscoveryHooks method returns a list containing an AfterTestDiscoveryHookMethod, which is configured to call the static AfterDiscovery method from a test project, along with metadata, attributes (AfterEveryAttribute), and a delegate for execution. No before-discovery hooks are enabled in this snippet. Requires the TUnit.Core package and a sessionId parameter.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/TestDiscoveryHookTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n// <auto-generated/>\\n#pragma warning disable\\nusing global::System.Linq;\\nusing global::System.Reflection;\\nusing global::System.Runtime.CompilerServices;\\nusing global::TUnit.Core;\\nusing global::TUnit.Core.Hooks;\\nusing global::TUnit.Core.Interfaces;\\n\\nnamespace TUnit.SourceGenerated;\\n\\n[global::System.Diagnostics.StackTraceHidden]\\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\\nfile partial class Hooks_TestDiscoveryHookTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestDiscoveryHookSource\\n{\\n\\t[global::System.Runtime.CompilerServices.ModuleInitializer]\\n\\tpublic static void Initialise()\\n\\t{\\n\\t\\tvar instance = new Hooks_TestDiscoveryHookTests();\\n\\t\\tSourceRegistrar.RegisterTestDiscoveryHookSource(instance);\\n\\t}\\n\\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.BeforeTestDiscoveryContext>> CollectBeforeTestDiscoveryHooks(string sessionId)\\n\\t{\\n\\t\\treturn\\n\\t\\t[\\n\\t\\t];\\n\\t}\\n\\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestDiscoveryContext>> CollectAfterTestDiscoveryHooks(string sessionId)\\n\\t{\\n\\t\\treturn\\n\\t\\t[\\n\\t\\t\\tnew global::TUnit.Core.Hooks.AfterTestDiscoveryHookMethod\\n\\t\\t\\t{\\n\\t\\t\\t\\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tType = typeof(global::TUnit.TestProject.TestDiscoveryHookTests),\\n\\t\\t\\t\\t\\tName = \\\"AfterDiscovery\\\",\\n\\t\\t\\t\\t\\tGenericTypeCount = 0,\\n\\t\\t\\t\\t\\tReturnType = typeof(void),\\n\\t\\t\\t\\t\\tAttributes = \\n\\t\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\t\\tnew global::TUnit.Core.AfterEveryAttribute(global::TUnit.Core.HookType.TestDiscovery)\\n\\t\\t\\t\\t\\t],\\n\\t\\t\\t\\t\\tParameters = [],\\n\\t\\t\\t\\t\\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\\\"global::TUnit.TestProject.TestDiscoveryHookTests\\\", () => new global::TUnit.Core.SourceGeneratedClassInformation\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tType = typeof(global::TUnit.TestProject.TestDiscoveryHookTests),\\n\\t\\t\\t\\t\\t\\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\\\"TestDiscoveryHookTests\\\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tName = \\\"TestDiscoveryHookTests\\\",\\n\\t\\t\\t\\t\\t\\t\\tAttributes = [],\\n\\t\\t\\t\\t\\t\\t}),\\n\\t\\t\\t\\t\\t\\tName = \\\"TestDiscoveryHookTests\\\",\\n\\t\\t\\t\\t\\t\\tNamespace = \\\"TUnit.TestProject\\\",\\n\\t\\t\\t\\t\\t\\tAttributes = [],\\n\\t\\t\\t\\t\\t\\tParameters = [],\\n\\t\\t\\t\\t\\t\\tProperties = [],\\n\\t\\t\\t\\t\\t}),\\n},\\n\\t\\t\\t\\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.TestDiscoveryHookTests.AfterDiscovery()),\\n\\t\\t\\t\\tHookExecutor = DefaultExecutor.Instance,\\n\\t\\t\\t\\tOrder = 0,\\n\\t\\t\\t\\tFilePath = @\\\"\\\",\\n\\t\\t\\t\\tLineNumber = 10,\\n\\t\\t\\t\\tMethodAttributes = \\n\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\tnew global::TUnit.Core.AfterEveryAttribute(global::TUnit.Core.HookType.TestDiscovery)\\n\\t\\t\\t\\t],\\n\\t\\t\\t\\tClassAttributes = [],\\n\\t\\t\\t\\tAssemblyAttributes = [],\\n\\t\\t\\t},\\n\\t\\t];\\n\\t}\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Context Class in C#\nDESCRIPTION: Class that manages test execution context including configuration, events, artifacts and execution state. Provides thread-safe access to test context data and configuration.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestContext : TUnit.Core.Context\n{\n    public readonly System.Threading.Lock Lock;\n    public System.Collections.Generic.List<TUnit.Core.ArgumentDisplayFormatter> ArgumentDisplayFormatters { get; }\n    public System.Threading.CancellationToken CancellationToken { get; }\n    public int CurrentRetryAttempt { get; }\n    public TUnit.Core.TestContextEvents Events { get; }\n    public bool IsRegistered { get; }\n    public System.Collections.Generic.Dictionary<string, object?> ObjectBag { get; }\n    public TUnit.Core.TestResult? Result { get; }\n    public TUnit.Core.TestDetails TestDetails { get; }\n    public System.DateTimeOffset? TestStart { get; }\n    public System.Collections.Generic.List<TUnit.Core.Timing> Timings { get; }\n    public static TUnit.Core.Interfaces.IConfiguration Configuration { get; }\n    public new static TUnit.Core.TestContext? Current { get; }\n    public static string? OutputDirectory { get; }\n    public static System.Collections.Generic.IReadOnlyDictionary<string, string> Parameters { get; }\n    public static string WorkingDirectory { get; set; }\n    public void AddArtifact(TUnit.Core.Artifact artifact) { }\n    public void SuppressReportingResult() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering TestMetadata Nodes for Tuple-Based DataSource Tests - TUnit - C#\nDESCRIPTION: Adds new test metadata nodes to the collection, wiring tuple-based class and method arguments, properties, and test context for tracking and execution. Inputs are all prepared class/method arguments and property tuples; output is a populated TestMetadata object. Supports repeat attempt, custom class factories, and method factories that invoke the test with tuple arguments. Relies on TUnit.Core and does not support external dependencies or dynamic loading at runtime.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nnodes.Add(new TestMetadata<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>\n{\n\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS1:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.ClassTupleDataSourceDrivenTests(int,string,bool).DataSource_TupleMethod(int,string,bool):0\",\n\tTestClassArguments = [classArg, classArg1, classArg2],\n\tTestMethodArguments = [methodArg, methodArg1, methodArg2],\n\tTestClassProperties = [propertyArg, propertyArg1, propertyArg2, propertyArg3],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_TupleMethod(methodArg, methodArg1, methodArg2)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 24,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Using MethodDataSource with IEnumerable and Tuples in TUnit (C#)\nDESCRIPTION: This C# snippet demonstrates providing multiple test cases using tuples via `[MethodDataSource]`. The static `AdditionTestData` method returns `IEnumerable<Func<(int, int, int)>>`, yielding multiple `Func` delegates each returning a tuple. TUnit runs the `MyTest` method for each yielded `Func` (evaluating it to get the tuple), mapping the tuple elements to the method parameters (`value1`, `value2`, `expectedResult`). This pattern efficiently parameterizes tests with multiple sets of tuple data. Dependencies include TUnit.Core and TUnit.Assertions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/method-data-source.md#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nusing TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic static class MyTestDataSources\n{\n    public static IEnumerable<Func<(int, int, int)>> AdditionTestData()\n    {\n        yield return () => (1, 2, 3);\n        yield return () => (2, 2, 4);\n        yield return () => (5, 5, 10);\n    }\n}\n\npublic class MyTestClass\n{\n    [Test]\n    [MethodDataSource(typeof(MyTestDataSources), nameof(MyTestDataSources.AdditionTestData))]\n    public async Task MyTest(int value1, int value2, int expectedResult)\n    {\n        var result = Add(value1, value2);\n\n        await Assert.That(result).IsEqualTo(expectedResult);\n    }\n\n    private int Add(int x, int y)\n    {\n        return x + y;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTime Assertion Methods in C#\nDESCRIPTION: Extension methods for DateTime assertions in the TUnit framework. These methods allow checking if a DateTime is before, after, or equal to another DateTime, with specialized comparison semantics for date/time values.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_134\n\nLANGUAGE: C#\nCODE:\n```\npublic static class DateTimeIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTime> IsAfter(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTime> valueSource, System.DateTime expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTime> IsAfterOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTime> valueSource, System.DateTime expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTime> IsBefore(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTime> valueSource, System.DateTime expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTime> IsBeforeOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTime> valueSource, System.DateTime expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.DateTimeEqualToAssertionBuilderWrapper IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTime> valueSource, System.DateTime expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering and Collecting Parameterized 'Test3' Method with Template Display Name in TUnit\nDESCRIPTION: This code snippet implements a source-generated test collector for the 'Test3' method with test arguments and a template-based display name that includes parameter values. It handles multiple test cases with different argument combinations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/CustomDisplayNameTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tglobal::TUnit.Core.SourceRegistrar.Register(new CustomDisplayNameTests());\n}\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn\n\t[\n\t\t..Tests0(sessionId),\n\t\t..Tests1(sessionId),\n\t];\n}\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.CustomDisplayNameTests),\n\t\t\tName = \"Test3\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"foo\", 1, true),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"bar\", 2, false),\n\t\t\t\tnew global::TUnit.Core.DisplayNameAttribute(\"Test with: $value1 $value2 $value3!\")\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t{\n\t\t\t\t\tName = \"value1\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\n```\n\n----------------------------------------\n\nTITLE: Executing Test with Assertions in C#\nDESCRIPTION: Enhances the test by incorporating an addition function and an assertion to verify its correctness. Dependencies include TUnit.Assertions, TUnit.Assertions.Extensions, and TUnit.Core.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/writing-your-first-test.md#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nusing TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    public async Task MyTest()\n    {\n        var result = Add(1, 2);\n\n        await Assert.That(result).IsEqualTo(3);\n    }\n\n    private int Add(int x, int y)\n    {\n        return x + y;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BaseAssertCondition<TActual> Abstract Class in C#\nDESCRIPTION: This generic abstract class extends BaseAssertCondition and provides methods for getting assertion results based on actual values and exceptions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class BaseAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition\n{\n    protected BaseAssertCondition() { }\n    public string? ActualExpression { get; }\n    public System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetAssertionResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata, string? actualExpression = null) { }\n    protected abstract System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AssertionResult Class in C#\nDESCRIPTION: This class represents the result of an assertion, including methods for combining results and creating failure conditions. It also includes an interpolated string handler for failure messages.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class AssertionResult\n{\n    public bool IsPassed { get; }\n    public string Message { get; }\n    public static TUnit.Assertions.AssertConditions.AssertionResult Passed { get; }\n    public TUnit.Assertions.AssertConditions.AssertionResult And(TUnit.Assertions.AssertConditions.AssertionResult other) { }\n    public System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> OrAsync(System.Func<System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult>> otherResult) { }\n    public TUnit.Assertions.AssertConditions.AssertionResult OrFailIf(bool isFailed, [System.Runtime.CompilerServices.InterpolatedStringHandlerArgument(\"isFailed\")] TUnit.Assertions.AssertConditions.AssertionResult.InterpolatedStringHandler stringHandler) { }\n    public TUnit.Assertions.AssertConditions.AssertionResult OrFailIf(bool isFailed, string message) { }\n    public static TUnit.Assertions.AssertConditions.AssertionResult Fail(string message) { }\n    public static TUnit.Assertions.AssertConditions.AssertionResult FailIf(bool isFailed, [System.Runtime.CompilerServices.InterpolatedStringHandlerArgument(\"isFailed\")] TUnit.Assertions.AssertConditions.AssertionResult.InterpolatedStringHandler stringHandler) { }\n    public static TUnit.Assertions.AssertConditions.AssertionResult FailIf(bool isFailed, string message) { }\n    public static System.Threading.Tasks.Task<TUnit.Assertions.AssertConditions.AssertionResult> op_Implicit(TUnit.Assertions.AssertConditions.AssertionResult result) { }\n    public static System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> op_Implicit(TUnit.Assertions.AssertConditions.AssertionResult result) { }\n    [System.Runtime.CompilerServices.InterpolatedStringHandler]\n    public readonly struct InterpolatedStringHandler\n    {\n        public InterpolatedStringHandler(int literalLength, int formattedCount, bool isFailed, out bool enabled) { }\n        public void AppendFormatted<T>(T? t) { }\n        public void AppendFormatted<T>(T? t, string format)\n            where T : System.IFormattable { }\n        public void AppendLiteral(string s) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Negative Assertions in C#\nDESCRIPTION: These methods in the DoesNotExtensions class provide negative assertions for strings, collections, and dictionaries. They include operations like DoesNotContain, DoesNotContainKey, and DoesNotEndWith.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_142\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> DoesNotContain(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> DoesNotContain<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, bool> matcher, [System.Runtime.CompilerServices.CallerArgumentExpression(\"matcher\")] string? doNotPopulateThisValue = null) { }\n\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TDictionary> DoesNotContainKey<TDictionary, TKey>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TDictionary> valueSource, TKey expected, System.Collections.Generic.IEqualityComparer<TKey> equalityComparer = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n    where TDictionary : System.Collections.IDictionary { }\n\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> DoesNotEndWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Defining and Applying a ParallelLimiter at the Class Level with Custom Limit in C#\nDESCRIPTION: This snippet defines a C# test class using TUnit where the ParallelLimiter attribute is applied to restrict the number of concurrently running test methods. The MyParallelLimit record implements IParallelLimit, setting a limit of 2 concurrent executions. The class includes two async tests, each repeated ten times. Required dependencies include TUnit.Core, a definition for IParallelLimit, and proper async support. The ParallelLimiter's scope is class-wide unless an assembly-level attribute is present and not overridden.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/parallel-limiter.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\n[ParallelLimiter<MyParallelLimit>]\npublic class MyTestClass\n{\n    [Test, Repeat(10)]\n    public async Task MyTest()\n    {\n        \n    }\n\n    [Test, Repeat(10)]\n    public async Task MyTest2()\n    {\n        \n    }\n}\n\npublic record MyParallelLimit : IParallelLimit\n{\n    public int Limit => 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Test Collection Class in C#\nDESCRIPTION: Defines a partial class that implements ITestSource interface to collect and manage test metadata. Includes initialization logic, test collection methods, and handles both regular and matrix data source scenarios.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1821.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Tests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new Tests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Shared Data Key in C#\nDESCRIPTION: Defines a key class for identifying shared data between tests. It combines a string key with a specific type to provide type-safe access to shared data across test runs.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\npublic class SharedDataKey : System.IEquatable<TUnit.Core.SharedDataKey>\n{\n    public SharedDataKey(string Key, System.Type Type) { }\n    public string Key { get; init; }\n    public System.Type Type { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing CompleteWithinAssertCondition in C#\nDESCRIPTION: Assertion condition that checks if a delegate completes execution within a specified time span. Used for performance-related assertions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_98\n\nLANGUAGE: C#\nCODE:\n```\n    public class CompleteWithinAssertCondition<TActual> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<TActual>\n    {\n        public CompleteWithinAssertCondition(System.TimeSpan timeSpan) { }\n        public override System.TimeSpan? WaitFor { get; }\n        protected override string GetExpectation() { }\n        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Allowing Test Execution on Dependency Failure with TUnit [DependsOn] in C#\nDESCRIPTION: Demonstrates how to configure a test (`Test2`) to run even if its dependency (`Test1`) fails. This is achieved by setting the `ProceedOnFailure` property of the `[DependsOn]` attribute to `true`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/depends-on.md#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[Test]\npublic async Task Test1() \n{\n    ...\n}\n\n[Test]\n[DependsOn(nameof(Test1), ProceedOnFailure = true)]\npublic async Task Test2() \n{\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Equivalence Assertions in C#\nDESCRIPTION: Extension methods for asserting collection equivalence with support for custom comparers and ordering. Methods check if collections contain the same elements regardless of order or using specific ordering rules.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_47\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsEquivalentTo<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparer\")] string doNotPopulateThisValue2 = null) where TActual : System.Collections.Generic.IEnumerable<TInner> { }\n```\n\n----------------------------------------\n\nTITLE: Defining Base Class for Playwright Page Tests in C#\nDESCRIPTION: The `PageTest` class inherits from `ContextTest` and provides foundational support for tests interacting with a Playwright `IPage`. It exposes a `Page` property and includes a `[Before]` hook (`PageSetup`) to ensure a page is ready before each test.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet2_0.Net4_7.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic class PageTest : TUnit.Playwright.ContextTest\n{\n    public PageTest() { }\n    public Microsoft.Playwright.IPage Page { get; }\n    [TUnit.Core.Before(TUnit.Core.HookType.Test, \"<FilePath>\", 10)]\n    public System.Threading.Tasks.Task PageSetup() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Conversion Assertion Condition in TUnit (C#)\nDESCRIPTION: This snippet defines a custom TUnit assertion condition `HttpResponseIsProblemDetailsAssertCondition` that converts an `HttpResponseMessage` to `ProblemDetails`. It inherits from `ConvertToAssertCondition<HttpResponseMessage, ProblemDetails>`, overrides `GetExpectation` to provide a failure message, and implements `ConvertValue` to asynchronously read and deserialize the response content, returning an `AssertionResult` and the converted `ProblemDetails` object (or null if conversion fails).\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-assertions/extensibility/chaining-and-converting.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class HttpResponseIsProblemDetailsAssertCondition() : ConvertToAssertCondition<HttpResponseMessage, ProblemDetails>()\n{\n    protected override string GetExpectation()\n    {\n        return $\"HTTP response to be in the format of a Problem Details object\";\n    }\n\n    public override async ValueTask<(AssertionResult, TToType?)> ConvertValue(HttpResponseMessage value)\n    {\n        var content = await value.Content.ReadFromJsonAsync<ProblemDetails>();\n\n        return \n        (\n            AssertionResult.FailIf(content is null, $\"response body is not Problem Details\"), \n            content\n        );\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing All-Matches Assertion for Enumerable Collections in C#\nDESCRIPTION: Class for asserting that all items in an enumerable collection satisfy a specified condition. It uses a predicate function to validate each item in the collection.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_46\n\nLANGUAGE: C#\nCODE:\n```\npublic EnumerableAllExpectedFuncAssertCondition(System.Func<TInner, bool> matcher, string? matcherString) { }\nprotected override string GetExpectation() { }\nprotected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Enumerable Assertion Conditions in C#\nDESCRIPTION: This snippet defines multiple classes for asserting conditions on enumerable collections. It includes checks for containing items, count equality, distinct items, and equivalence.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumerableContainsExpectedFuncAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n    where TActual : System.Collections.Generic.IEnumerable<TInner>\n{\n    public EnumerableContainsExpectedFuncAssertCondition(System.Func<TInner, bool> matcher, string? matcherString) { }\n    public TInner FoundItem { get; }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Writing a Basic Playwright Test in C# with TUnit\nDESCRIPTION: This snippet demonstrates how to implement a simple Playwright browser automation test using the TUnit.Playwright package in C#. It inherits from the 'PageTest' base class, which manages Playwright resources such as the browser, context, and page objects automatically. The 'Test' method asynchronously navigates to a specified URL and matches TUnit's requirement for async test methods. Dependencies include the TUnit.Playwright NuGet package and configuration of supported browser names (chromium, firefox, or webkit). Inputs are configured within the test body; output is the automated browser action.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/examples/playwright.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Tests : PageTest\n{\n    [Test]\n    public async Task Test()\n    {\n        await Page.GotoAsync(\"https://www.github.com/thomhurst/TUnit\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TestDiscoveryContext Class in C# for TUnit Framework\nDESCRIPTION: This class represents the context for test discovery in the TUnit framework. It includes properties for all tests, assemblies, test classes, and a test filter.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_45\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class TestDiscoveryContext : TUnit.Core.Context\n{\n    public System.Collections.Generic.IEnumerable<TUnit.Core.TestContext> AllTests { get; }\n    public System.Collections.Generic.IEnumerable<TUnit.Core.AssemblyHookContext> Assemblies { get; }\n    public System.Collections.Generic.IEnumerable<TUnit.Core.ClassHookContext> TestClasses { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string? TestFilter { get; init; }\n    public new static TUnit.Core.TestDiscoveryContext? Current { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PlaywrightTest Class in C#\nDESCRIPTION: The \"PlaywrightTest\" class is defined to extend \"WorkerAwareTest\" and delivers robust tools for testing with Playwright in C#. It includes browser-specific properties, test setup and teardown customization, and assertion capabilities.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class PlaywrightTest : TUnit.Playwright.WorkerAwareTest\n    {\n        public PlaywrightTest() { }\n        public virtual string BrowserName { get; }\n        public Microsoft.Playwright.IBrowserType BrowserType { get; }\n        public static Microsoft.Playwright.IPlaywright Playwright { get; }\n        public Microsoft.Playwright.IAPIResponseAssertions Expect(Microsoft.Playwright.IAPIResponse response) { }\n        public Microsoft.Playwright.ILocatorAssertions Expect(Microsoft.Playwright.ILocator locator) { }\n        public Microsoft.Playwright.IPageAssertions Expect(Microsoft.Playwright.IPage page) { }\n        [TUnit.Core.After(TUnit.Core.HookType.TestSession, \"\", 0)]\n        public static void PlaywrightCleanup() { }\n        [TUnit.Core.Before(TUnit.Core.HookType.TestSession, \"\", 0)]\n        public static System.Threading.Tasks.Task PlaywrightSetup() { }\n        public static void SetDefaultExpectTimeout(float timeout) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Data Attributes in C#\nDESCRIPTION: This snippet defines attributes for providing test data, including arguments and class-based data sources.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class ArgumentsAttribute : TUnit.Core.TestDataAttribute\n{\n    public ArgumentsAttribute() { }\n    public ArgumentsAttribute(params object?[]? values) { }\n    public object?[] Values { get; }\n}\n\npublic sealed class ClassDataSourceAttribute<T> : TUnit.Core.DataSourceGeneratorAttribute<T>\n    where T : new()\n{\n    public ClassDataSourceAttribute() { }\n    public string Key { get; set; }\n    public TUnit.Core.SharedType Shared { get; set; }\n    public override System.Collections.Generic.IEnumerable<System.Func<T>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TestDetails Abstract Class in C#\nDESCRIPTION: This abstract class represents the details of a test, including attributes, categories, and execution parameters. It contains properties for test metadata and configuration.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_50\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class TestDetails : System.IEquatable<TUnit.Core.TestDetails>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    protected TestDetails() { }\n    [System.Text.Json.Serialization.JsonIgnore]\n    public System.Attribute[] AssemblyAttributes { get; }\n    [System.Text.Json.Serialization.JsonIgnore]\n    public System.Attribute[] Attributes { get; }\n    public System.Collections.Generic.IReadOnlyList<string> Categories { get; }\n    [System.Text.Json.Serialization.JsonIgnore]\n    public System.Attribute[] ClassAttributes { get; }\n    public abstract object ClassInstance { get; }\n    public int CurrentRepeatAttempt { get; init; }\n    public System.Collections.Generic.IReadOnlyDictionary<string, string> CustomProperties { get; }\n    [System.Text.Json.Serialization.JsonIgnore]\n    public System.Attribute[] DataAttributes { get; init; }\n    [System.Text.Json.Serialization.JsonIgnore]\n    public System.Attribute[] DynamicAttributes { get; init; }\n    public TUnit.Core.Interfaces.IParallelConstraint? ParallelConstraint { get; }\n    public TUnit.Core.Interfaces.IParallelLimit? ParallelLimit { get; }\n    public int RepeatLimit { get; init; }\n    public int RetryLimit { get; }\n    public System.Type ReturnType { get; init; }\n    [System.Text.Json.Serialization.JsonIgnore]\n    public System.Attribute[] TestAttributes { get; }\n    public TUnit.Core.SourceGeneratedClassInformation TestClass { get; }\n    public object?[] TestClassArguments { get; init; }\n    public object?[] TestClassInjectedPropertyArguments { get; init; }\n    public System.Type[] TestClassParameterTypes { get; }\n    public string TestFilePath { get; init; }\n    public string TestId { get; init; }\n    public int TestLineNumber { get; init; }\n    public TUnit.Core.SourceGeneratedMethodInformation TestMethod { get; init; }\n    public object?[] TestMethodArguments { get; init; }\n    public System.Type[] TestMethodParameterTypes { get; }\n    public string TestName { get; init; }\n    public System.TimeSpan? Timeout { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Collection Assertion Conditions in C#\nDESCRIPTION: Classes implementing assertion conditions for enumerable collections, including equivalence checking, ordering, and containment tests\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_59\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumerableEquivalentToExpectedValueAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, System.Collections.Generic.IEnumerable<TInner>>\n    where TActual : System.Collections.Generic.IEnumerable<TInner>?\n{\n    public EnumerableEquivalentToExpectedValueAssertCondition(System.Collections.Generic.IEnumerable<TInner>? expected, System.Collections.Generic.IEqualityComparer<TInner?> equalityComparer, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Collections.Generic.IEnumerable<TInner>? expectedValue) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Value Assertion Extension - TUnit - C#\nDESCRIPTION: Demonstrates how to implement an extension method on IValueSource to add a custom assertion. This method, Contains, registers a new assertion with argument expressions to provide clear error messages. It expects a string and a StringComparison parameter, passing these along to a custom StringEqualsAssertCondition. Dependencies include TUnit's assertion infrastructure, specifically IValueSource, InvokableValueAssertionBuilder, RegisterAssertion, and argument expression attributes. Inputs are the value source, expected value, string comparison type, and generated caller argument expressions; the output is an InvokableValueAssertionBuilder for chaining or test invocation.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-assertions/extensibility/custom-assertions.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic static InvokableValueAssertionBuilder<string> Contains(this IValueSource<string> valueSource, string expected, StringComparison stringComparison, [CallerArgumentExpression(nameof(expected))] string doNotPopulateThisValue1 = \"\", [CallerArgumentExpression(nameof(stringComparison))] string doNotPopulateThisValue2 = \"\")\n    {\n        return valueSource.RegisterAssertion(\n            assertCondition: new StringEqualsAssertCondition(expected, stringComparison),\n            argumentExpressions: [doNotPopulateThisValue1, doNotPopulateThisValue2]\n            );\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Base Assertion Condition Class in TUnit (C#)\nDESCRIPTION: This abstract generic class extends `BaseAssertCondition` to handle assertions involving a specific actual value type (`TActual`). It adds the actual value's expression (`ActualExpression`) and defines methods for asynchronously getting the assertion result based on the actual value, a potential exception, and metadata (`GetAssertionResult`, `GetResult`).\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_39\n\nLANGUAGE: csharp\nCODE:\n```\n    public abstract class BaseAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition\n    {\n        protected BaseAssertCondition() { }\n        public string? ActualExpression { get; }\n        public System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetAssertionResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata, string? actualExpression = null) { }\n        protected abstract System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata);\n    }\n```\n\n----------------------------------------\n\nTITLE: Illustrating TUnit Compile-Time Type Error with Incompatible Types (C#)\nDESCRIPTION: This C# snippet demonstrates a scenario where TUnit's compile-time type checking prevents compilation. The `Assert.That(1).IsEqualTo(\"1\")` call attempts to compare an integer (`int`) with a string (`string`), which is disallowed by TUnit's assertion methods, leading to a compile-time error rather than a runtime failure. This highlights TUnit's feature for faster developer feedback. Requires the TUnit testing framework.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-assertions/type-checking.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n    [Test]\n    public async Task MyTest()\n    {\n        await Assert.That(1).IsEqualTo(\"1\");\n    }\n```\n\n----------------------------------------\n\nTITLE: Test Attribute Implementations in C#\nDESCRIPTION: Implementation of various test attributes including PropertyAttribute, RepeatAttribute, and RetryAttribute. These attributes provide test configuration and behavior modification capabilities.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\npublic sealed class RepeatAttribute : TUnit.Core.TUnitAttribute\n{\n    public RepeatAttribute(int times) { }\n    public int Times { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Custom Test Properties with TestContext in TUnit (C#)\nDESCRIPTION: This snippet checks if the current test contains a specified custom property within its metadata using the TestContext object in C#. It demonstrates accessing TestContext.Current and querying its TestInformation.CustomProperties dictionary to conditionally execute additional logic when a property like \\\"SomeProperty\\\" is present. Requires TUnit with accessible TestContext and properly configured custom test properties.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/test-context.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nif (TestContext.Current.TestInformation.CustomProperties.ContainsKey(\"SomeProperty\"))\n{\n    // Do something\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Property Injection with TUnit Attributes in C#\nDESCRIPTION: Demonstrates various ways to inject properties in a TUnit test class using different data source attributes. Shows usage of required keyword with properties and different sharing strategies for ClassDataSource. Includes examples of Arguments, MethodDataSource, ClassDataSource with different sharing types, and DataSourceGeneratorAttribute.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/property-injection.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class PropertySetterTests\n{\n    [Arguments(\"1\")]\n    public required string Property1 { get; init; }\n        \n    [MethodDataSource(nameof(MethodData))]\n    public required string Property2 { get; init; }\n        \n    [ClassDataSource<InnerModel>]\n    public required InnerModel Property3 { get; init; }\n    \n    [ClassDataSource<InnerModel>(Shared = SharedType.Globally)]\n    public required InnerModel Property4 { get; init; }\n    \n    [ClassDataSource<InnerModel>(Shared = SharedType.ForClass)]\n    public required InnerModel Property5 { get; init; }\n    \n    [ClassDataSource<InnerModel>(Shared = SharedType.Keyed, Key = \"Key\")]\n    public required InnerModel Property6 { get; init; }\n        \n    [DataSourceGeneratorTests.AutoFixtureGenerator<string>]\n    public required string Property7 { get; init; }\n    \n    [Test]\n    public void Test()\n    {\n        Console.WriteLine(Property7);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ClassHookContext and Context for Test State Management - C#\nDESCRIPTION: This code defines ClassHookContext, which maintains test class-level context such as test type, count, and a list of TestContext instances, and exposes a static Current property. The base Context class implements IDisposable and an interface for generic test context management, exposing Output and Error writers, a logger accessor, and methods for state output and cleanup. Both are used to manage test execution and environment state across TUnit-based tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class ClassHookContext : TUnit.Core.Context\n{\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Type ClassType { get; init; }\n    public int TestCount { get; }\n    public System.Collections.Generic.List<TUnit.Core.TestContext> Tests { get; init; }\n    public new static TUnit.Core.ClassHookContext? Current { get; }\n    public override bool Equals(object? obj) { }\n    public override int GetHashCode() { }\n}\npublic abstract class Context : System.IDisposable, TUnit.Core.Interfaces.IContext\n{\n    public System.IO.TextWriter ErrorOutputWriter { get; }\n    public System.IO.TextWriter OutputWriter { get; }\n    public static TUnit.Core.Context Current { get; }\n    public void AddAsyncLocalValues() { }\n    public void Dispose() { }\n    public TUnit.Core.Logging.DefaultLogger GetDefaultLogger() { }\n    public string GetErrorOutput() { }\n    public string GetStandardOutput() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Matrix Test Cases Using TUnit in C#\nDESCRIPTION: Demonstrates the usage of `[Matrix]` and `[MatrixDataSource]` attributes in TUnit to generate matrix-based test cases. This setup generates all combinations of specified parameters, here `value1` and `value2`, each containing ten integer values from 1 to 10, resulting in 100 test cases. Requires TUnit framework with `TUnit.Assertions` and related extensions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/matrix-tests.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Assertions.Extensions.Is;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    [MatrixDataSource]\n    public async Task MyTest(\n        [Matrix(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)] int value1,\n        [Matrix(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)] int value2\n        )\n    {\n        var result = Add(value1, value2);\n\n        await Assert.That(result).IsPositive();\n    }\n\n    private int Add(int x, int y)\n    {\n        return x + y;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Test Context Implementation\nDESCRIPTION: Core test context class that manages test execution state, configuration, and artifacts. Provides access to test parameters, working directory and event handling.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_49\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestContext : TUnit.Core.Context\n{\n    public readonly object Lock;\n    public System.Collections.Generic.List<TUnit.Core.ArgumentDisplayFormatter> ArgumentDisplayFormatters { get; }\n    public System.Threading.CancellationToken CancellationToken { get; }\n    public int CurrentRetryAttempt { get; }\n    public TUnit.Core.TestContextEvents Events { get; }\n    public bool IsRegistered { get; }\n    public System.Collections.Generic.Dictionary<string, object?> ObjectBag { get; }\n    public TUnit.Core.TestResult? Result { get; }\n    public TUnit.Core.TestDetails TestDetails { get; }\n    public System.DateTimeOffset? TestStart { get; }\n    public System.Collections.Generic.List<TUnit.Core.Timing> Timings { get; }\n    public static TUnit.Core.Interfaces.IConfiguration Configuration { get; }\n    public new static TUnit.Core.TestContext? Current { get; }\n    public static string? OutputDirectory { get; }\n    public static System.Collections.Generic.IReadOnlyDictionary<string, string> Parameters { get; }\n    public static string WorkingDirectory { get; set; }\n    public void AddArtifact(TUnit.Core.Artifact artifact) { }\n    public void SuppressReportingResult() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Exception Assertion with ThrowsAsync\nDESCRIPTION: Generic method that asynchronously checks if a delegate throws a specific exception type. Returns a Task containing the expected exception if thrown correctly.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic static System.Threading.Tasks.Task<TException> ThrowsAsync<TException>(System.Func<System.Threading.Tasks.Task> @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression(\"delegate\")] string? doNotPopulateThisValue = null)\n            where TException : System.Exception { }\n```\n\n----------------------------------------\n\nTITLE: Asserting ImmutableArray Equivalence and Ordering in C#\nDESCRIPTION: This snippet defines extension methods for asserting conditions on ImmutableArrays, including equivalence checks and ordering assertions. It uses generic types and various overloads to provide flexibility in comparisons.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_149\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsEquivalentTo<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Immutable.ImmutableArray<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsInDescendingOrder<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource) { }\n\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsOrderedBy<TInner, TComparisonItem>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Func<TInner, TComparisonItem> comparisonItemSelector, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparisonItemSelector\")] string doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for Generic Arguments Test in C#\nDESCRIPTION: Creates test metadata nodes for generic argument tests with support for resettable class factories and error handling. Includes configuration of test parameters, method arguments, and exception handling for test initialization failures.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests2136.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._2136.Tests>(() => \nnew global::TUnit.TestProject.Bugs._2136.Tests()\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._2136.Tests>\n{\n\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS4:TUnit.TestProject.Bugs._2136.Tests.GenericArgumentsTest(T,string):0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [methodArg, methodArg1],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.GenericArgumentsTest(methodArg, methodArg1)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 8,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\nresettableClassFactory = resettableClassFactoryDelegate();\ntestBuilderContext = new();\ntestBuilderContextAccessor.Current = testBuilderContext;\n\nnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._2136.Tests>\n{\n\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS4:TUnit.TestProject.Bugs._2136.Tests.GenericArgumentsTest(T,string):0\",\n\tMethodName = $\"GenericArgumentsTest\",\n\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"Tests.GenericArgumentsTest failed to initialize\", exception),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 8,\n});\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for Test3 Method in C# with TUnit Framework\nDESCRIPTION: This snippet creates test metadata for the Test3 method, including information about the method, its parameters, and the containing class. It uses SourceGeneratedMethodInformation and SourceGeneratedClassInformation to capture detailed test structure.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1889.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n    Type = typeof(global::TUnit.TestProject.Bugs._1889.DerivedTest),\n    Name = \"Test3\",\n    GenericTypeCount = 0,\n    ReturnType = typeof(void),\n    Attributes = \n    [\n    ],\n    Parameters = \n    [\n        new global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n        {\n            Name = \"condition\",\n            Attributes = [],\n        },\n    ],\n    Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._1889.DerivedTest\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n    {\n        Type = typeof(global::TUnit.TestProject.Bugs._1889.DerivedTest),\n        Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Tests1889\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n        {\n            Name = \"Tests1889\",\n            Attributes = [],\n        }),\n        Name = \"DerivedTest\",\n        Namespace = \"TUnit.TestProject.Bugs._1889\",\n        Attributes = \n        [\n            new global::TUnit.Core.InheritsTestsAttribute()\n        ],\n        Parameters = [],\n        Properties = [],\n    }),\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Delegate Assertion Condition Base Class (Actual/Exception Types) in TUnit (C#)\nDESCRIPTION: This abstract generic class serves as the base for delegate-based assertions, allowing specification of both the actual value type (`TActual`) and the expected exception type (`TException`). It inherits from `BaseAssertCondition<TActual>`, provides overrides for getting the expectation message (`GetExpectation`) and failure message (`GetFailureMessage`), implements the core `GetResult` logic, and allows customizing the comparison logic via `WithComparer`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_44\n\nLANGUAGE: csharp\nCODE:\n```\n    public abstract class DelegateAssertCondition<TActual, TException> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n        where TException : System.Exception\n    {\n        protected DelegateAssertCondition() { }\n        protected override string GetExpectation() { }\n        protected virtual string GetFailureMessage(TException? exception) { }\n        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n        public void WithComparer(System.Func<TException?, TUnit.Assertions.AssertionDecision> comparer) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing DateOnlyEqualToAssertionBuilderWrapper for DateOnly Comparisons\nDESCRIPTION: Specialized assertion builder for comparing DateOnly values with tolerance options. It allows specifying a day-based tolerance for date comparisons.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_81\n\nLANGUAGE: C#\nCODE:\n```\npublic class DateOnlyEqualToAssertionBuilderWrapper : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateOnly>\n{\n    public TUnit.Assertions.AssertionBuilders.Wrappers.DateOnlyEqualToAssertionBuilderWrapper WithinDays(int days, [System.Runtime.CompilerServices.CallerArgumentExpression(\"days\")] string doNotPopulateThis = \"\") { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Equivalence Assertion Methods for TUnit in C#\nDESCRIPTION: Collection of methods to assert that collections are equivalent, with various overloads for different comparison options. These methods allow comparing collections with or without custom equality comparers and specific ordering requirements.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_104\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsEquivalentTo<TActual, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n            where TActual : System.Collections.Generic.IEnumerable<TInner> { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsEquivalentTo<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparer\")] string doNotPopulateThisValue2 = null)\n            where TActual : System.Collections.Generic.IEnumerable<TInner> { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsEquivalentTo<TActual, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"collectionOrdering\")] string doNotPopulateThisValue2 = null)\n            where TActual : System.Collections.Generic.IEnumerable<TInner> { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsEquivalentTo<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"collectionOrdering\")] string doNotPopulateThisValue2 = null)\n            where TActual : System.Collections.Generic.IEnumerable<TInner> { }\n```\n\n----------------------------------------\n\nTITLE: Using Global Test IDs for Data Isolation in TUnit Tests (C#)\nDESCRIPTION: Illustrates how to use the assigned unique test identifier within a TUnit test class. A `[Before(HookType.Test)]` method retrieves the current test's ID using the `GetTestId` extension method on `TestContext.Current`. This ID is then used to configure an isolated resource, such as connecting to a specific Redis database number, ensuring data isolation for each test method (`[Test]`).\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/examples/instrumenting_global_test_ids.md#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nclass MyTestClassThatNeedsUniqueTestIds\n{\n    private IDatabase isolatedRedisDb = null!;\n\n    [Before(HookType.Test)]\n    public void BeforeEach()\n    {\n        // Call the extension method to retrieve the unique test id:\n        int currentTestId = TestContext.Current.GetTestId();\n\n        // Connect to the Redis database using the test id:\n        this.isolatedRedisDb = StackExchange.Redis.ConnectionMultiplexer\n                                .Connect(\"localhost\")\n                                .GetDatabase(currentTestId);\n    }\n\n    [Test]\n    public void MyTestCase()\n    {\n        // Do stuff with isolatedRedisDb\n    }\n\n    [Test]\n    public void MyOtherTestCase()\n    {\n        // Do stuff with isolatedRedisDb\n    }\n\n    [Test]\n    public void YetAnotherTestCase()\n    {\n        // Do stuff with isolatedRedisDb\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DefaultExecutor Class in C#\nDESCRIPTION: This C# class `DefaultExecutor` represents the standard execution strategy in TUnit. It inherits from `GenericAbstractExecutor` and provides a static `Instance` for singleton access. The `ExecuteAsync` method is overridden to run the provided asynchronous action directly, likely on the calling thread or using the default task scheduler.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\n    public class DefaultExecutor : TUnit.Core.GenericAbstractExecutor\n    {\n        public static readonly TUnit.Core.DefaultExecutor Instance;\n        protected override System.Threading.Tasks.ValueTask ExecuteAsync(System.Func<System.Threading.Tasks.ValueTask> action) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Hook Method Class in C#\nDESCRIPTION: Defines the HookMethod class which can represent either an instance or static hook method. It includes implicit operators for conversion.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_49\n\nLANGUAGE: C#\nCODE:\n```\npublic class HookMethod\n{\n    public HookMethod(TUnit.Core.Hooks.InstanceHookMethod instanceHookMethod) { }\n    public HookMethod(TUnit.Core.Hooks.StaticHookMethod staticHookMethod) { }\n    public TUnit.Core.Hooks.InstanceHookMethod? InstanceHookMethod { get; }\n    public TUnit.Core.Hooks.StaticHookMethod? StaticHookMethod { get; }\n    public static TUnit.Core.Hooks.HookMethod op_Implicit(TUnit.Core.Hooks.InstanceHookMethod instanceHookMethod) { }\n    public static TUnit.Core.Hooks.HookMethod op_Implicit(TUnit.Core.Hooks.StaticHookMethod staticHookMethod) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Retry Attribute in C#\nDESCRIPTION: Defines an attribute for automatically retrying failed tests. It includes customizable logic for determining when a retry should be attempted based on the exception and retry count.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\npublic class RetryAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver\n{\n    public RetryAttribute(int times) { }\n    public int Order { get; }\n    public int Times { get; }\n    public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }\n    public virtual System.Threading.Tasks.Task<bool> ShouldRetry(TUnit.Core.TestContext context, System.Exception exception, int currentRetryCount) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AndAssertionGroup Generic Class in C#\nDESCRIPTION: This generic class represents an 'and' assertion group. It inherits from AssertionGroup and provides methods for chaining assertions and getting an awaiter. It has a type constraint on TAssertionBuilder.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_70\n\nLANGUAGE: C#\nCODE:\n```\npublic class AndAssertionGroup<TActual, TAssertionBuilder> : TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder>\n    where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder\n{\n    public TUnit.Assertions.AssertionBuilders.Groups.AndAssertionGroup<TActual, TAssertionBuilder> And(System.Func<TAssertionBuilder, TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TActual>> assert) { }\n    public override System.Runtime.CompilerServices.TaskAwaiter<TActual?> GetAwaiter() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing String and Collection Assert Extensions in DoesExtensions Class\nDESCRIPTION: Extension methods for validating strings and collections. These methods provide capabilities for checking if strings contain substrings, match regex patterns, or have specific prefixes/suffixes, and if collections contain specific elements.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_114\n\nLANGUAGE: C#\nCODE:\n```\npublic static class DoesExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.StringContainsAssertionBuilderWrapper Contains(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.StringContainsAssertionBuilderWrapper Contains(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"stringComparison\")] string doNotPopulateThisValue2 = null) { }\n    public static TUnit.Assertions.AssertionBuilders.MappableResultAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>, TUnit.Assertions.AssertConditions.Collections.EnumerableContainsExpectedFuncAssertCondition<System.Collections.Generic.IEnumerable<TInner>, TInner>, TInner> Contains<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, bool> matcher, [System.Runtime.CompilerServices.CallerArgumentExpression(\"matcher\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> Contains<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TInner expected, System.Collections.Generic.IEqualityComparer<TInner> equalityComparer = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.Collections.Generic.IEnumerable<TInner> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TDictionary> ContainsKey<TDictionary, TKey>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TDictionary> valueSource, TKey expected, System.Collections.Generic.IEqualityComparer<TKey> equalityComparer = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TDictionary : System.Collections.IDictionary { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> ContainsOnly<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, bool> matcher, [System.Runtime.CompilerServices.CallerArgumentExpression(\"matcher\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TDictionary> ContainsValue<TDictionary, TValue>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TDictionary> valueSource, TValue expected, System.Collections.Generic.IEqualityComparer<TValue> equalityComparer = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TDictionary : System.Collections.IDictionary { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> EndsWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> EndsWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"stringComparison\")] string doNotPopulateThisValue2 = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> Matches(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, System.Text.RegularExpressions.Regex regex, [System.Runtime.CompilerServices.CallerArgumentExpression(\"regex\")] string expression = \"\") { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> Matches(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string regex, [System.Runtime.CompilerServices.CallerArgumentExpression(\"regex\")] string expression = \"\") { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> StartsWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> StartsWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"stringComparison\")] string doNotPopulateThisValue2 = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TestSessionContext Class in C# for TUnit Framework\nDESCRIPTION: This class represents the context for a test session in the TUnit framework. It includes properties for all tests, assemblies, test classes, and methods to add artifacts.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_50\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class TestSessionContext : TUnit.Core.Context\n{\n    public System.Collections.Generic.IEnumerable<TUnit.Core.TestContext> AllTests { get; }\n    public System.Collections.Generic.IEnumerable<TUnit.Core.AssemblyHookContext> Assemblies { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string Id { get; init; }\n    public System.Collections.Generic.IEnumerable<TUnit.Core.ClassHookContext> TestClasses { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string? TestFilter { get; init; }\n    public new static TUnit.Core.TestSessionContext? Current { get; }\n    public void AddArtifact(TUnit.Core.Artifact artifact) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DependencyInjectionDataSourceAttribute for DI-Based Data Generation - C#\nDESCRIPTION: DependencyInjectionDataSourceAttribute is an abstract generic attribute class for use on test methods or classes to generate test data based on a dependency injection (DI) scope. It requires implementers to provide logic for creating service scopes and resolving dependencies, as well as implementing data source enumeration. This attribute underpins DI-driven test methods in TUnit, facilitating advanced composition scenarios.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class DependencyInjectionDataSourceAttribute<TScope> : TUnit.Core.NonTypedDataSourceGeneratorAttribute\n{\n    protected DependencyInjectionDataSourceAttribute() { }\n    public abstract object? Create(TScope scope, System.Type type);\n    public abstract TScope CreateScope(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata);\n    public override System.Collections.Generic.IEnumerable<System.Func<object?[]?>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Data Sources\nDESCRIPTION: Method that generates test metadata for data-driven tests, handling both class-level and method-level data generation with support for AutoFixture data generation.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.Typed.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.DataSourceGeneratorTests),\n\t\t\tName = \"GeneratedData_Method\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute()\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t{\n\t\t\t\t\tName = \"value\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.DataSourceGeneratorTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.DataSourceGeneratorTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataSourceGeneratorTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"DataSourceGeneratorTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"DataSourceGeneratorTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value2\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value3\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: C# TUnit Test Discovery Context\nDESCRIPTION: Defines the TestDiscoveryContext class that manages test discovery with properties for accessing all tests, assemblies and test classes. Includes test filtering capability.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class TestDiscoveryContext : TUnit.Core.Context\n{\n    public System.Collections.Generic.IEnumerable<TUnit.Core.TestContext> AllTests { get; }\n    public System.Collections.Generic.IEnumerable<TUnit.Core.AssemblyHookContext> Assemblies { get; }\n    public System.Collections.Generic.IEnumerable<TUnit.Core.ClassHookContext> TestClasses { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string? TestFilter { get; init; }\n    public new static TUnit.Core.TestDiscoveryContext? Current { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Test Method Implementation in C#\nDESCRIPTION: Implements test method execution logic with argument handling, class initialization, and error handling. Generates test metadata nodes for test execution tracking.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests2112.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Tests2112\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n{\n    Name = \"Tests2112\",\n    Attributes = [],\n}),\nName = \"Tests\",\nNamespace = \"TUnit.TestProject.Bugs._2112\",\nAttributes = [],\nParameters = [],\nProperties = [],\n```\n\n----------------------------------------\n\nTITLE: Generic Assertion Extensions for TUnit\nDESCRIPTION: Extension methods for asserting non-equivalence, null checks, and reference comparisons. These methods extend IValueSource<T> to provide fluent assertion syntax.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_120\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.Wrappers.NotEquivalentToAssertionBuilderWrapper<TActual, TExpected> IsNotEquivalentTo<TActual, TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TExpected expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue1 = null) { }\npublic static TUnit.Assertions.AssertionBuilders.Wrappers.NotNullAssertionBuilderWrapper<TActual> IsNotNull<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual?> valueSource)\n    where TActual :  class { }\npublic static TUnit.Assertions.AssertionBuilders.Wrappers.NotNullStructAssertionBuilderWrapper<TActual> IsNotNull<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual?> valueSource)\n    where TActual :  struct { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotSameReferenceAs<TActual, TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TExpected expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue1 = null) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Collection Contains Assertion in C#\nDESCRIPTION: These methods extend IValueSource<IEnumerable<T>> to provide contains assertions for collections. They allow for custom matchers and equality comparers.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_138\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.MappableResultAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>, TUnit.Assertions.AssertConditions.Collections.EnumerableContainsExpectedFuncAssertCondition<System.Collections.Generic.IEnumerable<TInner>, TInner>, TInner> Contains<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, bool> matcher, [System.Runtime.CompilerServices.CallerArgumentExpression(\"matcher\")] string doNotPopulateThisValue = null) { }\n\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> Contains<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TInner expected, System.Collections.Generic.IEqualityComparer<TInner> equalityComparer = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n    where TActual : System.Collections.Generic.IEnumerable<TInner> { }\n```\n\n----------------------------------------\n\nTITLE: Global Context and Shared Data Key Definitions - TUnit - C#\nDESCRIPTION: This snippet introduces classes for maintaining global test context and shared data keys. GlobalContext tracks original console output writers, optional test filter, and provides the current context instance. GlobalSharedDataKey is used to identify and manage shared global data via a strongly-typed identifier, using a static Guid key. These classes depend on TUnit.Core base types and System.IO for TextWriter operations. They enable context and shared data management across test runs.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\npublic class GlobalContext : TUnit.Core.Context\n{\n    public System.IO.TextWriter OriginalConsoleError { get; set; }\n    public System.IO.TextWriter OriginalConsoleOut { get; set; }\n    public string? TestFilter { get; }\n    public new static TUnit.Core.GlobalContext Current { get; }\n}\npublic class GlobalSharedDataKey : TUnit.Core.SharedDataKey, System.IEquatable<TUnit.Core.GlobalSharedDataKey>\n{\n    public static readonly System.Guid RandomKey;\n    public GlobalSharedDataKey(System.Type Type) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Test Source Interface in C#\nDESCRIPTION: Defines an interface ITestSource for collecting tests in TUnit. It includes a method to collect tests based on a session ID.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_63\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ITestSource\n{\n    System.Collections.Generic.IReadOnlyList<TUnit.Core.TestMetadata> CollectTests(string sessionId);\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Delegate Throws Nothing with TUnit in C#\nDESCRIPTION: This snippet defines a C# asynchronous test using TUnit, asserting that executing a delegate does not throw any exceptions. It requires TUnit and an async test environment (likely xUnit/NUnit/MSTest with TUnit integration). The delegate passed to Assert.That is invoked, and ThrowsNothing checks that no exception is thrown, signaling a successful case. No inputs are required; the behavior of the code inside the delegate is verified by the test.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-assertions/delegates.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n    [Test]\n    public async Task MyTest()\n    {\n        await Assert.That(() =>\n        {\n            // Do something here\n        }).ThrowsNothing();\n    }\n```\n\n----------------------------------------\n\nTITLE: Using MethodDataSource with Tuples in TUnit (C#)\nDESCRIPTION: This C# snippet illustrates using `[MethodDataSource]` to supply test data as a tuple. The static `AdditionTestData` method returns a `Func<(int, int, int)>`, and the test method `MyTest` accepts the tuple elements as individual parameters (`value1`, `value2`, `expectedResult`). This avoids creating dedicated data classes for simple test cases. The `MethodDataSource` attribute targets the data source method by specifying its containing type and name. Dependencies include TUnit.Core and TUnit.Assertions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/method-data-source.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic static class MyTestDataSources\n{\n    public static Func<(int, int, int)> AdditionTestData()\n    {\n        return () => (1, 2, 3);\n    }\n}\n\npublic class MyTestClass\n{\n    [Test]\n    [MethodDataSource(typeof(MyTestDataSources), nameof(MyTestDataSources.AdditionTestData))]\n    public async Task MyTest(int value1, int value2, int expectedResult)\n    {\n        var result = Add(value1, value2);\n\n        await Assert.That(result).IsEqualTo(expectedResult);\n    }\n\n    private int Add(int x, int y)\n    {\n        return x + y;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Assertion Operator Classes\nDESCRIPTION: Implementation of logical operators (AND/OR) for combining assertions with support for both value and delegate-based assertions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_50\n\nLANGUAGE: C#\nCODE:\n```\npublic class ValueDelegateAnd<TActual> : IDelegateSource, ISource, IValueDelegateSource<TActual>, IValueSource<TActual>\n{\n    public ValueDelegateAnd(TUnit.Assertions.AssertionBuilders.AssertionBuilder assertionBuilder) { }\n    public static ValueDelegateAnd<TActual> Create(TUnit.Assertions.AssertionBuilders.AssertionBuilder assertionBuilder) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Negative Number Assertions in C#\nDESCRIPTION: Extension methods for negative number assertions. Provides methods to check if numbers are not divisible, not even, and various comparison operations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_129\n\nLANGUAGE: C#\nCODE:\n```\npublic static class NumberIsNotExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotDivisibleBy<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.Numerics.INumber<TActual>, System.Numerics.IModulusOperators<TActual, TActual, TActual> { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating TUnit Test Metadata for Data-Driven Test Case (Set 1) in C#\nDESCRIPTION: Similar to `Tests0`, this method generates `TestMetadata` for the second set of arguments (`2`, `\"String2\"`) provided via `ArgumentsAttribute` for the `DataSource_Method` test. It meticulously constructs the test's runtime information, including method details, arguments, class/method factories (`ResettableLazy`, `AsyncConvert`), and context (`TestBuilderContext`), tailored to this specific argument combination before adding the `TestMetadata` object to the `nodes` list.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests1(string sessionId)\n\t\t{\n\t\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\t\tvar classDataIndex = 0;\n\t\t\tvar testMethodDataIndex = 0;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.DataDrivenTests),\n\t\t\t\t\tName = \"DataSource_Method\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(void),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(1, \"String\"),\n\t\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(2, \"String2\"),\n\t\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(3, \"String3\")\n\t\t\t\t\t],\n\t\t\t\t\tParameters = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"value2\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.DataDrivenTests),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"DataDrivenTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"DataDrivenTests\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n};\n\n\t\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\t\tglobal::TUnit.TestProject.DataDrivenTests? classInstance = null;\n\t\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\t\tint methodArg = 2;\n\t\t\t\t\tstring methodArg1 = \"String2\";\n\n\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.DataDrivenTests>(() => \n\t\t\t\t\tnew global::TUnit.TestProject.DataDrivenTests()\n\t\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.DataDrivenTests>\n\t\t\t\t\t{\n\t\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS1:TUnit.TestProject.DataDrivenTests.DataSource_Method(int,string):0\",\n\t\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\t\tTestMethodArguments = [methodArg, methodArg1],\n\t\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_Method(methodArg, methodArg1)),\n\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\tTestLineNumber = 14,\n\t\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t\t});\n\t\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\t\ttestBuilderContext = new();\n\t\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t\t}\n```\n\n----------------------------------------\n\nTITLE: Registering AfterTest Hooks for Base1 using Source Generation in C#\nDESCRIPTION: This auto-generated C# snippet defines a partial class `Hooks_Base1` that implements `ITestHookSource`. It registers itself via `ModuleInitializer` with the TUnit `SourceRegistrar`. The `CollectAfterTestHooks` method returns metadata for the instance method `AfterEach1` from the `TUnit.TestProject.AfterTests.Base1` class, which is marked with the `[After(HookType.Test)]` attribute. This hook runs after each test within the class.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_Base1 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_Base1();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.AfterTests.Base1),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.Base1),\n\t\t\t\t\tName = \"AfterEach1\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.Base1\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.Base1),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AfterTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"AfterTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"Base1\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.AfterTests.Base1)classInstance).AfterEach1()),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: AsyncEvent<TEventArgs> Generic Class in C#\nDESCRIPTION: Implements a typed asynchronous event system with operator overloading for event registration and unregistration. Provides methods to invoke events asynchronously and unregister handlers.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class AsyncEvent<TEventArgs>\n{\n    public System.Threading.Tasks.ValueTask InvokeAsync(object sender, TEventArgs eventArgs) { }\n    public void Unregister() { }\n    public static TUnit.Core.AsyncEvent<TEventArgs> operator +(TUnit.Core.AsyncEvent<TEventArgs>? e, System.Func<object, TEventArgs, System.Threading.Tasks.Task> callback) { }\n    public static TUnit.Core.AsyncEvent<TEventArgs>? operator -(TUnit.Core.AsyncEvent<TEventArgs>? e, System.Func<object, TEventArgs, System.Threading.Tasks.Task> callback) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering and Collecting TUnit Source-Generated Tests - C#\nDESCRIPTION: This code registers a test source and collects test metadata for parameterized tests within the TUnit unit testing framework. It is auto-generated and sets up the source with a module initializer method, implements the ITestSource interface, and provides logic to iterate through test data sources, building detailed metadata objects for each test. Dependencies include TUnit.Core, various reflection and diagnostics APIs, and the test project's data-generating methods. Parameters to tests and data source methods are dynamically unpacked, supporting tests with both eight and sixteen arguments. The output is a list of test metadata objects configurable by session. If an exception occurs during test collection, a failed test entry is added. The code must be used within the context of the TUnit framework and requires proper namespace and type definitions from the referenced test projects.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\\n#pragma warning disable\\nusing global::System.Linq;\\nusing global::System.Reflection;\\nusing global::TUnit.Core;\\nusing global::TUnit.Core.Extensions;\\n\\nnamespace TUnit.SourceGenerated;\\n\\n[global::System.Diagnostics.StackTraceHidden]\\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\\nfile partial class Tests : TUnit.Core.Interfaces.SourceGenerator.ITestSource\\n{\\n\\t[global::System.Runtime.CompilerServices.ModuleInitializer]\\n\\tpublic static void Initialise()\\n\\t{\\n\\t\\tSourceRegistrar.Register(new Tests());\\n\\t}\\n\\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\\n\\t{\\n\\t\\treturn Tests0(sessionId);\\n\\t}\\n\\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\\n\\t{\\n\\t\\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\\n\\t\\tvar classDataIndex = 0;\\n\\t\\tvar testMethodDataIndex = 0;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tvar testClassType = typeof(global::TUnit.TestProject.Bugs._1538.Tests);\\n\\t\\t\\tvar methodInfo = global::TUnit.Core.Helpers.MethodInfoRetriever.GetMethodInfo(typeof(global::TUnit.TestProject.Bugs._1538.Tests), \\\"Eight_Args\\\", 0, [typeof(global::System.Boolean), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String)]);\\n\\n\\t\\t\\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\\n\\t\\t\\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\\n\\t\\t\\tforeach (var methodDataAccessor in global::TUnit.TestProject.Bugs._1538.Tests.EightItems())\\n\\t\\t\\t{\\n\\t\\t\\t\\ttestMethodDataIndex++;\\n\\n\\t\\t\\t\\tvar methodData = methodDataAccessor;\\n\\t\\t\\t\\tvar methodArgTuples = global::System.TupleExtensions.ToTuple<global::System.Boolean, global::System.String, global::System.String, global::System.String, global::System.String, global::System.String, global::System.String, global::System.String>(methodData);\\n\\t\\t\\t\\tglobal::System.Boolean methodArg = methodArgTuples.Item1;\\n\\t\\t\\t\\tglobal::System.String methodArg1 = methodArgTuples.Item2;\\n\\t\\t\\t\\tglobal::System.String methodArg2 = methodArgTuples.Item3;\\n\\t\\t\\t\\tglobal::System.String methodArg3 = methodArgTuples.Item4;\\n\\t\\t\\t\\tglobal::System.String methodArg4 = methodArgTuples.Item5;\\n\\t\\t\\t\\tglobal::System.String methodArg5 = methodArgTuples.Item6;\\n\\t\\t\\t\\tglobal::System.String methodArg6 = methodArgTuples.Item7;\\n\\t\\t\\t\\tglobal::System.String methodArg7 = methodArgTuples.Rest.Item1;\\n\\t\\t\\t\\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._1538.Tests>(() => \\n\\t\\t\\t\\tnew global::TUnit.TestProject.Bugs._1538.Tests()\\n\\t\\t\\t\\t, sessionId, testBuilderContext);\\n\\n\\t\\t\\t\\tvar resettableClassFactory = resettableClassFactoryDelegate();\\n\\n\\t\\t\\t\\tnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._1538.Tests>\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tTestId = $\\\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS0:{testMethodDataIndex}:TUnit.TestProject.Bugs._1538.Tests.Eight_Args(System.Boolean,System.String,System.String,System.String,System.String,System.String,System.String,System.String):0\\\",\\n\\t\\t\\t\\t\\tTestClassArguments = [],\\n\\t\\t\\t\\t\\tTestMethodArguments = [methodArg, methodArg1, methodArg2, methodArg3, methodArg4, methodArg5, methodArg6, methodArg7],\\n\\t\\t\\t\\t\\tTestClassProperties = [],\\n\\t\\t\\t\\t\\tCurrentRepeatAttempt = 0,\\n\\t\\t\\t\\t\\tRepeatLimit = 0,\\n\\t\\t\\t\\t\\tMethodInfo = methodInfo,\\n\\t\\t\\t\\t\\tResettableClassFactory = resettableClassFactory,\\n\\t\\t\\t\\t\\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Eight_Args(methodArg, methodArg1, methodArg2, methodArg3, methodArg4, methodArg5, methodArg6, methodArg7)),\\n\\t\\t\\t\\t\\tTestFilePath = @\\\"\\\",\\n\\t\\t\\t\\t\\tTestLineNumber = 5,\\n\\t\\t\\t\\t\\tTestAttributes = [ new global::TUnit.Core.TestAttribute()\\n{\\n    \\n}, new global::TUnit.Core.MethodDataSourceAttribute(\\\"EightItems\\\")\\n{\\n    \\n} ],\\n\\t\\t\\t\\t\\tClassAttributes = [  ],\\n\\t\\t\\t\\t\\tAssemblyAttributes = [  ],\\n\\t\\t\\t\\t\\tDataAttributes = [  ],\\n\\t\\t\\t\\t\\tTestBuilderContext = testBuilderContext,\\n\\t\\t\\t\\t});\\n\\t\\t\\t\\tresettableClassFactory = resettableClassFactoryDelegate();\\n\\t\\t\\t\\ttestBuilderContext = new();\\n\\t\\t\\t\\ttestBuilderContextAccessor.Current = testBuilderContext;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcatch (global::System.Exception exception)\\n\\t\\t{\\n\\t\\t\\tnodes.Add(new FailedInitializationTest\\n\\t\\t\\t{\\n\\t\\t\\t\\tTestId = $\\\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS0:{testMethodDataIndex}:TUnit.TestProject.Bugs._1538.Tests.Eight_Args(System.Boolean,System.String,System.String,System.String,System.String,System.String,System.String,System.String):0\\\",\\n\\t\\t\\t\\tTestClass = typeof(global::TUnit.TestProject.Bugs._1538.Tests),\\n\\t\\t\\t\\tReturnType = global::TUnit.Core.Helpers.MethodInfoRetriever.GetMethodInfo(typeof(global::TUnit.TestProject.Bugs._1538.Tests), \\\"Eight_Args\\\", 0, [typeof(global::System.Boolean), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String)]).ReturnType,\\n\\t\\t\\t\\tParameterTypeFullNames = [typeof(global::System.Boolean), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String)],\\n\\t\\t\\t\\tTestName = \\\"Eight_Args\\\",\\n\\t\\t\\t\\tTestFilePath = @\\\"\\\",\\n\\t\\t\\t\\tTestLineNumber = 5,\\n\\t\\t\\t\\tException = exception,\\n\\t\\t\\t});\\n\\t\\t}\\n\\t\\treturn nodes;\\n\\t}\\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\\n#pragma warning disable\\nusing global::System.Linq;\\nusing global::System.Reflection;\\nusing global::TUnit.Core;\\nusing global::TUnit.Core.Extensions;\\n\\nnamespace TUnit.SourceGenerated;\\n\\n[global::System.Diagnostics.StackTraceHidden]\\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\\nfile partial class Tests : TUnit.Core.Interfaces.SourceGenerator.ITestSource\\n{\\n\\t[global::System.Runtime.CompilerServices.ModuleInitializer]\\n\\tpublic static void Initialise()\\n\\t{\\n\\t\\tSourceRegistrar.Register(new Tests());\\n\\t}\\n\\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\\n\\t{\\n\\t\\treturn Tests0(sessionId);\\n\\t}\\n\\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\\n\\t{\\n\\t\\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\\n\\t\\tvar classDataIndex = 0;\\n\\t\\tvar testMethodDataIndex = 0;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tvar testClassType = typeof(global::TUnit.TestProject.Bugs._1538.Tests);\\n\\t\\t\\tvar methodInfo = global::TUnit.Core.Helpers.MethodInfoRetriever.GetMethodInfo(typeof(global::TUnit.TestProject.Bugs._1538.Tests), \\\"SixteenArgs\\\", 0, [typeof(global::System.Boolean), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String)]);\\n\\n\\t\\t\\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\\n\\t\\t\\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\\n\\t\\t\\tforeach (var methodDataAccessor in global::TUnit.TestProject.Bugs._1538.Tests.SixteenItems())\\n\\t\\t\\t{\\n\\t\\t\\t\\ttestMethodDataIndex++;\\n\\n\\t\\t\\t\\tvar methodData = methodDataAccessor;\\n\\t\\t\\t\\tvar methodArgTuples = global::System.TupleExtensions.ToTuple<global::System.Boolean, global::System.String, global::System.String, global::System.String, global::System.String, global::System.String, global::System.String, global::System.String, global::System.String, global::System.String, global::System.String, global::System.String, global::System.String, global::System.String, global::System.String, global::System.String>(methodData);\\n\\t\\t\\t\\tglobal::System.Boolean methodArg = methodArgTuples.Item1;\\n\\t\\t\\t\\tglobal::System.String methodArg1 = methodArgTuples.Item2;\\n\\t\\t\\t\\tglobal::System.String methodArg2 = methodArgTuples.Item3;\\n\\t\\t\\t\\tglobal::System.String methodArg3 = methodArgTuples.Item4;\\n\\t\\t\\t\\tglobal::System.String methodArg4 = methodArgTuples.Item5;\\n\\t\\t\\t\\tglobal::System.String methodArg5 = methodArgTuples.Item6;\\n\\t\\t\\t\\tglobal::System.String methodArg6 = methodArgTuples.Item7;\\n\\t\\t\\t\\tglobal::System.String methodArg7 = methodArgTuples.Rest.Item1;\\n\\t\\t\\t\\tglobal::System.String methodArg8 = methodArgTuples.Rest.Item2;\\n\\t\\t\\t\\tglobal::System.String methodArg9 = methodArgTuples.Rest.Item3;\\n\\t\\t\\t\\tglobal::System.String methodArg10 = methodArgTuples.Rest.Item4;\\n\\t\\t\\t\\tglobal::System.String methodArg11 = methodArgTuples.Rest.Item5;\\n\\t\\t\\t\\tglobal::System.String methodArg12 = methodArgTuples.Rest.Item6;\\n\\t\\t\\t\\tglobal::System.String methodArg13 = methodArgTuples.Rest.Item7;\\n\\t\\t\\t\\tglobal::System.String methodArg14 = methodArgTuples.Rest.Rest.Item1;\\n\\t\\t\\t\\tglobal::System.String methodArg15 = methodArgTuples.Rest.Rest.Item2;\\n\\t\\t\\t\\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._1538.Tests>(() => \\n\\t\\t\\t\\tnew global::TUnit.TestProject.Bugs._1538.Tests()\\n\\t\\t\\t\\t, sessionId, testBuilderContext);\\n\\n\\t\\t\\t\\tvar resettableClassFactory = resettableClassFactoryDelegate();\\n\\n\\t\\t\\t\\tnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._1538.Tests>\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tTestId = $\\\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS0:{testMethodDataIndex}:TUnit.TestProject.Bugs._1538.Tests.SixteenArgs(System.Boolean,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String):0\\\",\\n\\t\\t\\t\\t\\tTestClassArguments = [],\\n\\t\\t\\t\\t\\tTestMethodArguments = [methodArg, methodArg1, methodArg2, methodArg3, methodArg4, methodArg5, methodArg6, methodArg7, methodArg8, methodArg9, methodArg10, methodArg11, methodArg12, methodArg13, methodArg14, methodArg15],\\n\\t\\t\\t\\t\\tTestClassProperties = [],\\n\\t\\t\\t\\t\\tCurrentRepeatAttempt = 0,\\n\n```\n\n----------------------------------------\n\nTITLE: Correct Async Assertion with Await in TUnit Test - C#\nDESCRIPTION: Illustrates the recommended approach for writing asynchronous TUnit tests by returning a Task and awaiting the assertion chain. This pattern prevents sync-over-async issues and ensures the assertion logic executes correctly against asynchronous delegates or methods. The snippet requires the TUnit test framework, supports async/await semantics, takes integer parameters, and expects the result to match an expected value using Assert.That(...).IsEqualTo(...). It is suitable for both synchronous and asynchronous test targets and is fully compatible with modern C# testing conventions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-assertions/awaiting.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n    [Test]\n    public async Task MyTest()\n    {\n        var result = Add(1, 2);\n\n        await Assert.That(result).IsEqualTo(3);\n    }\n```\n\n----------------------------------------\n\nTITLE: Correctly Sharing State Between Tests Using Static Fields in TUnit (C#)\nDESCRIPTION: This C# code demonstrates the correct way to share state between TUnit tests within the same class by using a `private static int _value`. Because `_value` is static, it belongs to the `MyTests` type rather than individual instances, allowing `MyTest1` to set the value and `MyTest2` to successfully assert against it. This approach works even though TUnit creates separate instances for each test, but requires careful management, often in conjunction with `[NotInParallel]` for ordered execution. It depends on TUnit attributes (`[Test]`, `[NotInParallel]`) and assertion library (`Assert`).\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/things-to-know.md#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyTests\n{\n    private static int _value;\n\n    [Test, NotInParallel]\n    public void MyTest1() { _value = 99; }\n\n    [Test, NotInParallel]\n    public async Task MyTest2() { await Assert.That(_value).IsEqualTo(99); }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Function-Based Value Assertion Condition in TUnit (C#)\nDESCRIPTION: This class provides a concrete implementation of `ExpectedValueAssertCondition` where the comparison logic is defined by a `Func<TActual?, TExpected?, ..., bool>` delegate (`condition`). It also accepts delegates for generating the default failure message (`defaultMessageFactory`) and the expectation string (`expectation`).\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_49\n\nLANGUAGE: csharp\nCODE:\n```\n    public class FuncValueAssertCondition<TActual, TExpected> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TExpected>\n    {\n        public FuncValueAssertCondition(TExpected? expected, System.Func<TActual?, TExpected?, TUnit.Assertions.AssertConditions.FuncValueAssertCondition<TActual, TExpected>, bool> condition, System.Func<TActual?, System.Exception?, string?, string> defaultMessageFactory, string expectation) { }\n        protected override string GetExpectation() { }\n        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TExpected? expectedValue) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Assertion Group Factory Methods in C#\nDESCRIPTION: Static methods for creating and combining assertion groups in TUnit. These methods facilitate value comparison between assertion groups and logical combinations using 'Or' operations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_72\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<TActual, TUnit.Assertions.AssertionBuilders.ValueAssertionBuilder<TActual>> ForSameValueAs<TActual>(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TUnit.Assertions.AssertionBuilders.ValueAssertionBuilder<TActual>> otherGroup) { }\npublic static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<TActual, TUnit.Assertions.AssertionBuilders.ValueDelegateAssertionBuilder<TActual>> ForSameValueAs<TActual>(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TUnit.Assertions.AssertionBuilders.ValueDelegateAssertionBuilder<TActual>> otherGroup) { }\npublic static TUnit.Assertions.AssertionBuilders.Groups.OrAssertionGroupInvoker<TActual, TAssertionBuilder> Or<TActual, TAssertionBuilder>(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group1, TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group2)\n    where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Not In Parallel Attribute in C#\nDESCRIPTION: Defines an attribute for specifying tests that should not run in parallel with other tests. It can use constraint keys to group tests that should not run in parallel with each other.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\npublic class NotInParallelAttribute : TUnit.Core.SingleTUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver\n{\n    public NotInParallelAttribute() { }\n    public NotInParallelAttribute(string constraintKey) { }\n    public NotInParallelAttribute(string[] constraintKeys) { }\n    public string[] ConstraintKeys { get; }\n    public int Order { get; init; }\n    public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Comparable Value Assertion Methods in C#\nDESCRIPTION: A collection of extension methods for IComparable<T> types to perform comparison-based assertions. Includes methods for checking if values are between bounds, greater than, less than, or equal to expected values.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_132\n\nLANGUAGE: C#\nCODE:\n```\npublic static class ComparableIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.BetweenAssertionBuilderWrapper<TActual> IsBetween<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual lowerBound, TActual upperBound, [System.Runtime.CompilerServices.CallerArgumentExpression(\"lowerBound\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"upperBound\")] string doNotPopulateThisValue2 = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsGreaterThan<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsGreaterThanOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsLessThan<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsLessThanOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Data-Driven Tests Method in TUnit Framework\nDESCRIPTION: This method collects test metadata for data-driven tests with arguments. It creates TestMetadata objects with different argument values for the DataSource_Method test method and handles initialization failures with exception handling.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests2(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.DataDrivenTests),\n\t\t\tName = \"DataSource_Method\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(1, \"String\"),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(2, \"String2\"),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(3, \"String3\")\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t{\n\t\t\t\t\tName = \"value\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t{\n\t\t\t\t\tName = \"value2\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.DataDrivenTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"DataDrivenTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"DataDrivenTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.DataDrivenTests? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tclassInstanceArguments = [];\n\n\t\t\tint methodArg = 3;\n\t\t\tstring methodArg1 = \"String3\";\n\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.DataDrivenTests>(() => \n\t\t\tnew global::TUnit.TestProject.DataDrivenTests()\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.DataDrivenTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS2:TUnit.TestProject.DataDrivenTests.DataSource_Method(int,string):0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [methodArg, methodArg1],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_Method(methodArg, methodArg1)),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 14,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.DataDrivenTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS2:TUnit.TestProject.DataDrivenTests.DataSource_Method(int,string):0\",\n\t\t\t\tMethodName = $\"DataSource_Method\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"DataDrivenTests.DataSource_Method failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 14,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Assertion Extensions for TUnit\nDESCRIPTION: Collection of extension methods for value assertions including equivalence checks, null checks, and reference comparisons. Methods support generic type constraints and provide fluent assertion syntax.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_68\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.Wrappers.NotEquivalentToAssertionBuilderWrapper<TActual, TExpected> IsNotEquivalentTo<TActual, TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TExpected expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue1 = null) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Hook Attributes in C#\nDESCRIPTION: This snippet defines attributes for before and after test hooks, used to set up and tear down test environments.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class BeforeAttribute : TUnit.Core.HookAttribute\n{\n    public BeforeAttribute(TUnit.Core.HookType hookType, [System.Runtime.CompilerServices.CallerFilePath] string file = \"\", [System.Runtime.CompilerServices.CallerLineNumber] int line = 0) { }\n}\n\npublic sealed class AfterAttribute : TUnit.Core.HookAttribute\n{\n    public AfterAttribute(TUnit.Core.HookType hookType, [System.Runtime.CompilerServices.CallerFilePath] string file = \"\", [System.Runtime.CompilerServices.CallerLineNumber] int line = 0) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Building Test Metadata for Parameterized Tests\nDESCRIPTION: Creates test metadata for a parameterized test method with multiple argument values. This includes test information, class instantiation logic, and error handling for failed test initialization.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests2083.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.Bugs._2083.Tests),\n\t\t\tName = \"MyTest\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(0),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(255),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(32767),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute('\\uffff'),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(2147483647),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(9223372036854775807L)\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<long>\n\t\t\t\t{\n\t\t\t\t\tName = \"value\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._2083.Tests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._2083.Tests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Tests2083\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"Tests2083\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"Tests\",\n\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._2083\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.Bugs._2083.Tests? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tclassInstanceArguments = [];\n\n\t\t\tlong methodArg = 0;\n\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._2083.Tests>(() => \n\t\t\tnew global::TUnit.TestProject.Bugs._2083.Tests()\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._2083.Tests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.Bugs._2083.Tests.MyTest(long):0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.MyTest(methodArg)),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 5,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._2083.Tests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.Bugs._2083.Tests.MyTest(long):0\",\n\t\t\t\tMethodName = $\"MyTest\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"Tests.MyTest failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 5,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Collection Interface for TUnit Test Source\nDESCRIPTION: Implements the ITestSource interface method to collect test metadata for the testing session. This method returns all tests defined in the class with their metadata.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.NonTyped.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn Tests0(sessionId);\n}\n```\n\n----------------------------------------\n\nTITLE: TestFailedException for Test Failure Handling\nDESCRIPTION: A custom exception class that extends TUnitException to specifically capture and represent test failures. It overrides the StackTrace property to provide more detailed stack information.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class TestFailedException : TUnit.Core.Exceptions.TUnitException\n{\n    public TestFailedException(System.Exception exception) { }\n    public override string StackTrace { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Exception Assertion Conditions in C#\nDESCRIPTION: This snippet defines classes for asserting conditions on exceptions, such as checking the exception message content.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic class ExceptionMessageContainingExpectedValueAssertCondition<TException> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TException, string>\n    where TException : System.Exception\n{\n    public ExceptionMessageContainingExpectedValueAssertCondition(string expected, System.StringComparison stringComparison) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TException? actualValue, string? expectedValue) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Equality and Inequality Property Assertions\nDESCRIPTION: Methods to create equality and inequality assertions for object properties, with automatic argument capture for better error messages.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActualRootType> EqualTo(TPropertyType expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActualRootType> NotEqualTo(TPropertyType expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Capturing Exception from Async Delegate with TUnit in C#\nDESCRIPTION: This snippet defines a C# async test using TUnit's Assert.ThrowsAsync<T> to execute an asynchronous delegate and capture any ArgumentNullException thrown. It requires TUnit and an async test framework. The delegate is expected to return a Task and triggers the exception, which is then assigned to argumentNullException for further assertions or inspection. This method is best for detailed exception validation in asynchronous contexts.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-assertions/delegates.md#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n    [Test]\n    public async Task MyTest()\n    {\n        var argumentNullException = await Assert.ThrowsAsync<ArgumentNullException>(() =>\n        {\n            // Do something here\n            return Task.CompletedTask;\n        });\n    }\n```\n\n----------------------------------------\n\nTITLE: Declaring DependsOnAttribute for Test Dependency Specification - C#\nDESCRIPTION: DependsOnAttribute and its generic version provide mechanisms for declaring dependencies among test methods and classes in TUnit. These attributes support overloading for various ways of specifying the dependent test (by type, name, and parameter type), and can control behavior on dependency failure. This facilitates dependency-aware test execution ordering and constraints.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\npublic class DependsOnAttribute : TUnit.Core.TUnitAttribute\n{\n    public DependsOnAttribute(System.Type testClass) { }\n    public DependsOnAttribute(string testName) { }\n    public DependsOnAttribute(System.Type testClass, string testName) { }\n    public DependsOnAttribute(string testName, System.Type[] parameterTypes) { }\n    public DependsOnAttribute(System.Type testClass, string testName, System.Type[] parameterTypes) { }\n    public System.Type[]? ParameterTypes { get; }\n    public bool ProceedOnFailure { get; set; }\n    public System.Type? TestClass { get; }\n    public string? TestName { get; }\n    public override string ToString() { }\n}\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\npublic class DependsOnAttribute<T> : TUnit.Core.DependsOnAttribute\n{\n    public DependsOnAttribute() { }\n    public DependsOnAttribute(string testName) { }\n    public DependsOnAttribute(string testName, System.Type[] parameterTypes) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Test Discovery Hook Source Interface in C#\nDESCRIPTION: Defines an interface ITestDiscoveryHookSource for collecting test discovery hooks in TUnit. It includes methods for before and after test discovery hooks.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_60\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ITestDiscoveryHookSource\n{\n    System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.TestDiscoveryContext>> CollectAfterTestDiscoveryHooks(string sessionId);\n    System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.BeforeTestDiscoveryContext>> CollectBeforeTestDiscoveryHooks(string sessionId);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EnumHasExtensions in C#\nDESCRIPTION: A static class providing extension methods for fluent enum assertions, such as checking for flags, matching names or values, and validating definition status. These extensions provide a cleaner syntax for enum testing.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_108\n\nLANGUAGE: C#\nCODE:\n```\npublic static class EnumHasExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TEnum> DoesNotHaveFlag<TEnum>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TEnum> valueSource, TEnum expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue1 = null)\n        where TEnum : System.Enum { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TEnum> DoesNotHaveSameNameAs<TEnum, TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TEnum> valueSource, TExpected expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue1 = null)\n        where TEnum : System.Enum\n        where TExpected : System.Enum { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TEnum> DoesNotHaveSameValueAs<TEnum, TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TEnum> valueSource, TExpected expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue1 = null)\n        where TEnum : System.Enum\n        where TExpected : System.Enum { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TEnum> HasFlag<TEnum>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TEnum> valueSource, TEnum expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue1 = null)\n        where TEnum : System.Enum { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TEnum> HasSameNameAs<TEnum, TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TEnum> valueSource, TExpected expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue1 = null)\n        where TEnum : System.Enum\n        where TExpected : System.Enum { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TEnum> HasSameValueAs<TEnum, TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TEnum> valueSource, TExpected expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue1 = null)\n        where TEnum : System.Enum\n        where TExpected : System.Enum { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TEnum> IsDefined<TEnum>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TEnum> valueSource)\n        where TEnum : System.Enum { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TEnum> IsNotDefined<TEnum>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TEnum> valueSource)\n        where TEnum : System.Enum { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Source Generator Class in C#\nDESCRIPTION: A partial class implementing ITestSource interface to generate and register test metadata. Includes module initialization, test collection, and test metadata generation with support for parameterized tests using AutoFixture.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class DataSourceGeneratorTests : TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tSourceRegistrar.Register(new DataSourceGeneratorTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\t..Tests0(sessionId),\n\t\t\t..Tests1(sessionId),\n\t\t];\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Assertion Extensions for the Converted Type in TUnit (C#)\nDESCRIPTION: This snippet defines standard assertion extension methods (`HasTitle`, `HasDetail`) for the `ProblemDetails` type, which is the result of the conversion. These methods target `IValueSource<ProblemDetails>` and use `RegisterAssertion` (not `RegisterConversionAssertion`) to attach regular assert conditions (like `ProblemDetailsHasTitleAssertCondition`, `ProblemDetailsHasDetailAssertCondition`). These methods can be called after the type conversion in the assertion chain.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-assertions/extensibility/chaining-and-converting.md#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class ProblemDetailsAssertionExtensions\n{\n    public static InvokableValueAssertionBuilder<ProblemDetails> HasTitle(this IValueSource<ProblemDetails> valueSource,\n        string title, [CallerArgumentExpression(\"title\")] string? titleExpression = null)\n    {\n        return valueSource.RegisterAssertion(new ProblemDetailsHasTitleAssertCondition(title), [titleExpression]);\n    }\n    \n    public static InvokableValueAssertionBuilder<ProblemDetails> HasDetail(this IValueSource<ProblemDetails> valueSource,\n        string detail, [CallerArgumentExpression(\"detail\")] string? detailExpression = null)\n    {\n        return valueSource.RegisterAssertion(new ProblemDetailsHasDetailAssertCondition(detail), [detailExpression]);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ImmutableArray Assertion Extensions\nDESCRIPTION: Extension methods for asserting various properties of ImmutableArray collections including emptiness, equivalence, and ordering.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_125\n\nLANGUAGE: C#\nCODE:\n```\npublic static class ImmutableArrayIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsEmpty<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsEquivalentTo<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Immutable.ImmutableArray<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsInOrder<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Assertion Group Support\nDESCRIPTION: Defines assertion group classes that enable grouping and combining multiple assertions. Supports both synchronous and asynchronous operations with And/Or combinations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\npublic class AndAssertionGroupInvoker<TActual, TAssertionBuilder>\n    where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder\n{\n    public AndAssertionGroupInvoker(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group1, TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group2) { }\n    public TUnit.Assertions.AssertionBuilders.Groups.AndAssertionGroupInvoker<TActual, TAssertionBuilder> And(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group) { }\n    public System.Runtime.CompilerServices.TaskAwaiter<TActual?> GetAwaiter() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTimeOffset Equality Assertion in C#\nDESCRIPTION: This method extends IValueSource<DateTimeOffset> to provide an equality assertion for DateTimeOffset values. It returns a DateTimeOffsetEqualToAssertionBuilderWrapper for further configuration.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_136\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.Wrappers.DateTimeOffsetEqualToAssertionBuilderWrapper IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTimeOffset> valueSource, System.DateTimeOffset expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Helper Classes for TUnit Framework\nDESCRIPTION: Utility classes providing common functionality for the TUnit testing framework, including type casting, counting, parallel execution limiting, and method reflection. These helpers simplify common operations across the framework.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_58\n\nLANGUAGE: C#\nCODE:\n```\npublic static class CastHelper\n{\n    [System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessage(\"\", \"IL2072\")]\n    public static T? Cast<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods)]  T>(object? value) { }\n}\n[System.Diagnostics.DebuggerDisplay(\"Count = {CurrentCount}\")]\npublic class Counter\n{\n    public System.EventHandler<int>? OnCountChanged;\n    public Counter() { }\n    public int CurrentCount { get; }\n    public int Decrement() { }\n    public int Increment() { }\n}\npublic class DefaultParallelLimit : TUnit.Core.Interfaces.IParallelLimit\n{\n    public DefaultParallelLimit() { }\n    public int Limit { get; }\n}\npublic class MethodInfoRetriever\n{\n    public MethodInfoRetriever() { }\n    public static System.Reflection.MethodInfo GetMethodInfo([System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicMethods)] System.Type type, string methodName, int genericParameterCount, System.Type[] parameterTypes) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Assembly Hooks for TUnit in C#\nDESCRIPTION: Implements a partial class for TUnit's IAssemblyHookSource, providing methods to collect and register assembly-level hooks via the SourceRegistrar. Requires the TUnit.Core library and related namespaces. Key methods include Initialise and CollectBeforeAssemblyHooks, facilitating test setup hooks injection at the assembly level; dependencies include global::TUnit.Core and runtime support for source generation.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyBeforeTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_AssemblySetupTests : global::TUnit.Core.Interfaces.SourceGenerator.IAssemblyHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_AssemblySetupTests();\n\t\tSourceRegistrar.RegisterAssemblyHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectBeforeEveryAssemblyHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectAfterEveryAssemblyHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\t// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Comparable Assertion Conditions in C#\nDESCRIPTION: This snippet defines classes for asserting conditions on comparable objects, such as checking if a value is between a minimum and maximum.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic class BetweenAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n    where TActual : System.IComparable<TActual>\n{\n    public BetweenAssertCondition(TActual minimum, TActual maximum) { }\n    public void Exclusive() { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n    public void Inclusive() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for Method with Class/Method Data Sources in C# (TUnit)\nDESCRIPTION: This C# snippet generates test metadata for a specific test method (`GeneratedData_Method2`) within `TUnit.TestProject.DataSourceGeneratorTests`. It retrieves data sources defined by `AutoFixtureGeneratorAttribute` at both the class constructor level and the test method level. It iterates through all combinations of generated arguments, creating a `TestMetadata` instance for each combination, capturing arguments, factory delegates, attributes, and context. A try-catch block handles potential exceptions during data generation, creating `FailedInitializationTest` metadata in case of failure.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n\t\t\tvar classArgDataGeneratorMetadata = new DataGeneratorMetadata\n{\n   Type = TUnit.Core.Enums.DataGeneratorType.Parameters,\n   TestClassType = testClassType,\n   ParameterInfos = typeof(global::TUnit.TestProject.DataSourceGeneratorTests).GetConstructors().First().GetParameters(),\n   PropertyInfo = null,\n   TestBuilderContext = testBuilderContextAccessor,\n   TestSessionId = sessionId,\n};\n\t\t\tvar classDataAttribute = new global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute()\n{\n    \n};\n\n\t\t\tvar classArgGeneratedDataArray = classDataAttribute.GenerateDataSources(classArgDataGeneratorMetadata);\n\n\t\t\tforeach (var classArgGeneratedDataAccessor in classArgGeneratedDataArray)\n\t\t\t{\n\t\t\t\tclassDataIndex++;\n\t\t\t\tvar methodArgDataGeneratorMetadata = new DataGeneratorMetadata\n{\n   Type = TUnit.Core.Enums.DataGeneratorType.Parameters,\n   TestClassType = testClassType,\n   ParameterInfos = methodInfo.GetParameters(),\n   PropertyInfo = null,\n   TestBuilderContext = testBuilderContextAccessor,\n   TestSessionId = sessionId,\n};\n\t\t\t\tvar methodDataAttribute = new global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<global::System.Int32, global::System.String, global::System.Boolean>()\n{\n    \n};\n\n\t\t\t\tvar methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\n\n\t\t\t\tforeach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\n\t\t\t\t{\n\t\t\t\t\ttestMethodDataIndex++;\n\t\t\t\t\tvar classArgGeneratedData = classArgGeneratedDataAccessor();\n\t\t\t\t\tglobal::System.Int32 classArg = classArgGeneratedData.Item1;\n\t\t\t\t\tglobal::System.String classArg1 = classArgGeneratedData.Item2;\n\t\t\t\t\tglobal::System.Boolean classArg2 = classArgGeneratedData.Item3;\n\n\n\t\t\t\t\tvar methodArgGeneratedData = methodArgGeneratedDataAccessor();\n\t\t\t\t\tglobal::System.Int32 methodArg = methodArgGeneratedData.Item1;\n\t\t\t\t\tglobal::System.String methodArg1 = methodArgGeneratedData.Item2;\n\t\t\t\t\tglobal::System.Boolean methodArg2 = methodArgGeneratedData.Item3;\n\n\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.DataSourceGeneratorTests>(() => \n\t\t\t\t\tnew global::TUnit.TestProject.DataSourceGeneratorTests(classArg, classArg1, classArg2)\n\t\t\t\t\t, sessionId, testBuilderContext);\n\n\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.DataSourceGeneratorTests>\n\t\t\t\t\t{\n\t\t\t\t\t\tTestId = $\"global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute:{classDataIndex}:CL-GAC0:global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<global::System.Int32, global::System.String, global::System.Boolean>:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.DataSourceGeneratorTests(System.Int32,System.String,System.Boolean).GeneratedData_Method2(System.Int32,System.String,System.Boolean):0\",\n\t\t\t\t\t\tTestClassArguments = [classArg, classArg1, classArg2],\n\t\t\t\t\t\tTestMethodArguments = [methodArg, methodArg1, methodArg2],\n\t\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\t\tMethodInfo = methodInfo,\n\t\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.GeneratedData_Method2(methodArg, methodArg1, methodArg2)),\n\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\tTestLineNumber = 17,\n\t\t\t\t\t\tTestAttributes = [ new global::TUnit.Core.TestAttribute()\n{\n    \n}, new global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<global::System.Int32, global::System.String, global::System.Boolean>()\n{\n    \n} ],\n\t\t\t\t\t\tClassAttributes = [ new global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<global::System.Int32, global::System.String, global::System.Boolean>()\n{\n    \n}, new global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute()\n{\n    \n} ],\n\t\t\t\t\t\tAssemblyAttributes = [  ],\n\t\t\t\t\t\tDataAttributes = [ classDataAttribute, methodDataAttribute ],\n\t\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t\t});\n\t\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\t\ttestBuilderContext = new();\n\t\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedInitializationTest\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute:{classDataIndex}:CL-GAC0:global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<global::System.Int32, global::System.String, global::System.Boolean>:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.DataSourceGeneratorTests(System.Int32,System.String,System.Boolean).GeneratedData_Method2(System.Int32,System.String,System.Boolean):0\",\n\t\t\t\tTestClass = typeof(global::TUnit.TestProject.DataSourceGeneratorTests),\n\t\t\t\tReturnType = global::TUnit.Core.Helpers.MethodInfoRetriever.GetMethodInfo(typeof(global::TUnit.TestProject.DataSourceGeneratorTests), \"GeneratedData_Method2\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]).ReturnType,\n\t\t\t\tParameterTypeFullNames = [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)],\n\t\t\t\tTestName = \"GeneratedData_Method2\",\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 17,\n\t\t\t\tException = exception,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Incorrect State Sharing Using Instance Fields in TUnit (C#)\nDESCRIPTION: This C# code shows a TUnit test class attempting to share state between `MyTest1` and `MyTest2` using a private instance field `_value`. Although marked with `[NotInParallel]`, this approach fails because TUnit creates separate instances of `MyTests` for each test, meaning `_value` in `MyTest2` is different from the one modified in `MyTest1`. This snippet illustrates why instance fields cannot be reliably used for state persistence across tests in TUnit and will result in a failing test. It depends on TUnit attributes (`[Test]`, `[NotInParallel]`) and assertion library (`Assert`).\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/things-to-know.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyTests\n{\n    private int _value;\n\n    [Test, NotInParallel]\n    public void MyTest1() { _value = 99; }\n\n    [Test, NotInParallel]\n    public async Task MyTest2() { await Assert.That(_value).IsEqualTo(99); }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Non-Typed Data Source Generator Attribute in C#\nDESCRIPTION: Defines an abstract base class for data source generation attributes. It provides a framework for generating test data dynamically at runtime through the GenerateDataSources method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method | System.AttributeTargets.Property, AllowMultiple=true)]\npublic abstract class NonTypedDataSourceGeneratorAttribute : TUnit.Core.TestDataAttribute, TUnit.Core.IDataAttribute\n{\n    protected NonTypedDataSourceGeneratorAttribute() { }\n    public abstract System.Collections.Generic.IEnumerable<System.Func<object?[]?>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AssertionGroup Static Class in C#\nDESCRIPTION: This static class provides utility methods for working with assertion groups. It includes methods for creating and combining different types of assertion groups, as well as methods for asserting on specific values or delegates.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_71\n\nLANGUAGE: C#\nCODE:\n```\npublic static class AssertionGroup\n{\n    public static TUnit.Assertions.AssertionBuilders.Groups.AndAssertionGroupInvoker<TActual, TAssertionBuilder> And<TActual, TAssertionBuilder>(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group1, TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group2)\n        where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder { }\n    public static TUnit.Assertions.AssertionBuilders.Groups.UnknownAssertionGroupInvoker<TActual, TAssertionBuilder> Assert<TActual, TAssertionBuilder>(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group)\n        where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder { }\n    public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<object?, TUnit.Assertions.AssertionBuilders.DelegateAssertionBuilder> For(System.Action value) { }\n    public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<object?, TUnit.Assertions.AssertionBuilders.AsyncDelegateAssertionBuilder> For(System.Func<System.Threading.Tasks.Task> value) { }\n    public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<object?, TUnit.Assertions.AssertionBuilders.AsyncDelegateAssertionBuilder> For(System.Threading.Tasks.Task value) { }\n    public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<object?, TUnit.Assertions.AssertionBuilders.AsyncDelegateAssertionBuilder> For(System.Threading.Tasks.ValueTask value) { }\n    public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<TActual, TUnit.Assertions.AssertionBuilders.AsyncValueDelegateAssertionBuilder<TActual>> For<TActual>(System.Func<System.Threading.Tasks.Task<TActual>> value) { }\n    public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<TActual, TUnit.Assertions.AssertionBuilders.ValueDelegateAssertionBuilder<TActual>> For<TActual>(System.Func<TActual> value) { }\n    public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<TActual, TUnit.Assertions.AssertionBuilders.AsyncValueDelegateAssertionBuilder<TActual>> For<TActual>(System.Threading.Tasks.Task<TActual> value) { }\n    public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<TActual, TUnit.Assertions.AssertionBuilders.AsyncValueDelegateAssertionBuilder<TActual>> For<TActual>(System.Threading.Tasks.ValueTask<TActual> value) { }\n    public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<TActual, TUnit.Assertions.AssertionBuilders.ValueAssertionBuilder<TActual>> For<TActual>(TActual value) { }\n    public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<object?, TUnit.Assertions.AssertionBuilders.AsyncDelegateAssertionBuilder> ForSameValueAs(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<object?, TUnit.Assertions.AssertionBuilders.AsyncDelegateAssertionBuilder> otherGroup) { }\n    public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<object?, TUnit.Assertions.AssertionBuilders.DelegateAssertionBuilder> ForSameValueAs(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<object?, TUnit.Assertions.AssertionBuilders.DelegateAssertionBuilder> otherGroup) { }\n    public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<TActual, TUnit.Assertions.AssertionBuilders.AsyncValueDelegateAssertionBuilder<TActual>> ForSameValueAs<TActual>(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TUnit.Assertions.AssertionBuilders.AsyncValueDelegateAssertionBuilder<TActual>> otherGroup) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BaseAssertCondition Abstract Class in C#\nDESCRIPTION: This abstract class serves as a base for assertion conditions, providing common properties and methods for handling assertion failures and expectations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class BaseAssertCondition\n{\n    protected BaseAssertCondition() { }\n    public string? OverriddenMessage { get; }\n    public string? Subject { get; }\n    public virtual System.TimeSpan? WaitFor { get; protected set; }\n    public TUnit.Assertions.AssertConditions.AssertionResult FailWithMessage(string message) { }\n    protected abstract string GetExpectation();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Delegate Assertion Conditions in C#\nDESCRIPTION: Defines a CompleteWithinAssertCondition class and extension methods for asserting delegate completion within a specified time span.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_95\n\nLANGUAGE: C#\nCODE:\n```\npublic class CompleteWithinAssertCondition<TActual> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<TActual>\n{\n    public CompleteWithinAssertCondition(System.TimeSpan timeSpan) { }\n    public override System.TimeSpan? WaitFor { get; }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\npublic static class DelegateExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableDelegateAssertionBuilder CompletesWithin(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource, System.TimeSpan timeSpan, [System.Runtime.CompilerServices.CallerArgumentExpression(\"timeSpan\")] string? doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> CompletesWithin<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueDelegateSource<TActual> delegateSource, System.TimeSpan timeSpan, [System.Runtime.CompilerServices.CallerArgumentExpression(\"timeSpan\")] string? doNotPopulateThisValue = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FuncValueAssertCondition for TUnit Functional Assertions (C#)\nDESCRIPTION: Defines the `FuncValueAssertCondition` class, inheriting from `ExpectedValueAssertCondition`. This condition allows assertions based on a custom boolean function (`condition`) that takes the actual value, expected value, and the condition instance itself. It also allows specifying a custom message factory and an expectation string.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\n    public class FuncValueAssertCondition<TActual, TExpected> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TExpected>\n    {\n        public FuncValueAssertCondition(TExpected? expected, System.Func<TActual?, TExpected?, TUnit.Assertions.AssertConditions.FuncValueAssertCondition<TActual, TExpected>, bool> condition, System.Func<TActual?, System.Exception?, string?, string> defaultMessageFactory, string expectation) { }\n        protected override string GetExpectation() { }\n        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TExpected? expectedValue) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining Throws Assertion for Action Delegate (Any Exception) in C#\nDESCRIPTION: This overload of the static `Throws` method asserts that executing the provided `Action` delegate throws any `System.Exception`. It returns the caught exception if the assertion passes. The `CallerArgumentExpression` captures the source expression.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\n        public static System.Exception Throws(System.Action @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression(\"delegate\")] string? doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Throws Assertion for Action Delegate in C#\nDESCRIPTION: This generic overload of the static `Throws` method asserts that executing the provided `Action` delegate throws an exception of type `TException` (where `TException` derives from `System.Exception`). It returns the caught exception strongly typed as `TException` if the assertion passes. The `CallerArgumentExpression` captures the source expression.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\n        public static TException Throws<TException>(System.Action @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression(\"delegate\")] string? doNotPopulateThisValue = null)\n            where TException : System.Exception { }\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for ClassTupleDataSourceDrivenTests in C#\nDESCRIPTION: This code snippet creates test metadata for the DataSource_TupleMethod, including class and method arguments from tuple data sources. It handles error cases and creates FailedInitializationTest objects when exceptions occur.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=NamedTupleMethod_testMethodName=TupleMethod.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests1(string sessionId)\n{\n    global::System.Collections.Generic.List<TestMetadata> nodes = [];\n    var classDataIndex = 0;\n    var testMethodDataIndex = 0;\n    try\n    {\n        var testClassType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests);\n        var methodInfo = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests).GetMethod(\"DataSource_TupleMethod\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]);\n\n        var testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n        var testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n        var classArgTuples = global::System.TupleExtensions.ToTuple<global::System.Int32, global::System.String, global::System.Boolean>(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()());\n        global::System.Int32 classArg = classArgTuples.Item1;\n        global::System.String classArg1 = classArgTuples.Item2;\n        global::System.Boolean classArg2 = classArgTuples.Item3;\n        (global::System.Int32, global::System.String, global::System.Boolean) propertyArg = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()();\n        (global::System.Int32 Number, global::System.String Word, global::System.Boolean Flag) propertyArg1 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()();\n        (global::System.Int32, global::System.String, global::System.Boolean) propertyArg2 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()();\n        (global::System.Int32 Number, global::System.String Word, global::System.Boolean Flag) propertyArg3 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()();\n\n        var methodArgTuples = global::System.TupleExtensions.ToTuple<global::System.Int32, global::System.String, global::System.Boolean>(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()());\n        global::System.Int32 methodArg = methodArgTuples.Item1;\n        global::System.String methodArg1 = methodArgTuples.Item2;\n        global::System.Boolean methodArg2 = methodArgTuples.Item3;\n        var resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>(() => \n        new global::TUnit.TestProject.ClassTupleDataSourceDrivenTests(classArg, classArg1, classArg2)\n        {\n            Property1 = propertyArg,\n            Property2 = propertyArg1,\n            Property3 = propertyArg2,\n            Property4 = propertyArg3,\n        }\n        , sessionId, testBuilderContext);\n\n        var resettableClassFactory = resettableClassFactoryDelegate();\n\n        nodes.Add(new TestMetadata<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>\n        {\n            TestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS1:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.ClassTupleDataSourceDrivenTests(System.Int32,System.String,System.Boolean).DataSource_TupleMethod(System.Int32,System.String,System.Boolean):0\",\n            TestClassArguments = [classArg, classArg1, classArg2],\n            TestMethodArguments = [methodArg, methodArg1, methodArg2],\n            TestClassProperties = [propertyArg, propertyArg1, propertyArg2, propertyArg3],\n            CurrentRepeatAttempt = 0,\n            RepeatLimit = 0,\n            MethodInfo = methodInfo,\n            ResettableClassFactory = resettableClassFactory,\n            TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_TupleMethod(methodArg, methodArg1, methodArg2)),\n            TestFilePath = @\"\",\n            TestLineNumber = 24,\n            TestAttributes = [ new global::TUnit.Core.TestAttribute()\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n{\n    \n} ],\n            ClassAttributes = [ new global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n{\n    \n} ],\n            AssemblyAttributes = [  ],\n            DataAttributes = [  ],\n            TestBuilderContext = testBuilderContext,\n        });\n        resettableClassFactory = resettableClassFactoryDelegate();\n        testBuilderContext = new();\n        testBuilderContextAccessor.Current = testBuilderContext;\n    }\n    catch (global::System.Exception exception)\n    {\n        nodes.Add(new FailedInitializationTest\n        {\n            TestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS1:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.ClassTupleDataSourceDrivenTests(System.Int32,System.String,System.Boolean).DataSource_TupleMethod(System.Int32,System.String,System.Boolean):0\",\n            TestClass = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests),\n            ReturnType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests).GetMethod(\"DataSource_TupleMethod\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]).ReturnType,\n            ParameterTypeFullNames = [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)],\n            TestName = \"DataSource_TupleMethod\",\n            TestFilePath = @\"\",\n            TestLineNumber = 24,\n            Exception = exception,\n        });\n    }\n    return nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Collecting ValueTask Asynchronous Tests in C#\nDESCRIPTION: This snippet defines a partial class for collecting ValueTask asynchronous test methods from BasicTests. It includes test metadata creation, class instance initialization, and exception handling for the ValueTaskAsynchronousTest method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BasicTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class BasicTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new BasicTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BasicTests),\n\t\t\t\tName = \"ValueTaskAsynchronousTest\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.ValueTask),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute()\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BasicTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BasicTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"BasicTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"BasicTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"BasicTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.BasicTests? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tclassInstanceArguments = [];\n\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.BasicTests>(() => \n\t\t\tnew global::TUnit.TestProject.BasicTests()\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.BasicTests>\n\t\t\t{\n\t\t\t\tTestId = $\"TUnit.TestProject.BasicTests.ValueTaskAsynchronousTest:0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.ValueTaskAsynchronousTest()),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 11,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.BasicTests>\n\t\t\t{\n\t\t\t\tTestId = $\"TUnit.TestProject.BasicTests.ValueTaskAsynchronousTest:0\",\n\t\t\t\tMethodName = $\"ValueTaskAsynchronousTest\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"BasicTests.ValueTaskAsynchronousTest failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 11,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating User Test with Time Assertion in C#\nDESCRIPTION: This test demonstrates creating a user and asserting that the creation time is within the expected range using TUnit's assertion syntax.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/README.md#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n    [Test]\n    public async Task Create_User_Has_Expected_Creation_Time()\n    {\n        var user = await CreateUser();\n\n        await Assert.That(user.CreatedAt)\n            .IsEqualTo(DateTime.Now)\n            .Within(TimeSpan.FromMinutes(1));\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing String Contains Assertion in C#\nDESCRIPTION: These methods extend IValueSource<string> to provide contains assertions for strings. They return a StringContainsAssertionBuilderWrapper and allow for optional string comparison options.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_137\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.Wrappers.StringContainsAssertionBuilderWrapper Contains(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n\npublic static TUnit.Assertions.AssertionBuilders.Wrappers.StringContainsAssertionBuilderWrapper Contains(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"stringComparison\")] string doNotPopulateThisValue2 = null) { }\n```\n\n----------------------------------------\n\nTITLE: Defining Hook Interfaces in C#\nDESCRIPTION: Specifies interfaces for hook execution and message publishing, including IExecutableHook and IHookMessagePublisher. These interfaces define the contract for hook method execution and event publishing.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_59\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IExecutableHook<in T>\n{\n    TUnit.Core.SourceGeneratedMethodInformation MethodInfo { get; }\n    string Name { get; }\n    int Order { get; }\n    System.Threading.Tasks.ValueTask ExecuteAsync(T context, System.Threading.CancellationToken cancellationToken);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Runtime Dynamic Tests in C#\nDESCRIPTION: Shows how to create dynamic tests at runtime within another test method. The example includes class-level and method-level arguments, demonstrating complex test creation scenarios with multiple parameters.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/experimental/dynamic-tests.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[RunOnDiscovery]\n[Arguments(1, 2, 3)]\n[Arguments(101, 202, 303)]\npublic class Runtime(int a, int b, int c)\n{\n    public void SomeMethod(int arg1, int arg2, int arg3)\n    {\n        Console.WriteLine(@\"SomeMethod called with:\");\n        Console.WriteLine($@\"Class args: {a}, {b}, {c}\");\n        Console.WriteLine($@\"Method args: {arg1}, {arg2}, {arg3}\");\n    }\n    \n    [Test]\n    [Arguments(4, 5, 6)]\n    [Arguments(404, 505, 606)]\n    public async Task BuildTests(int d, int e, int f)\n    {\n        var context = TestContext.Current!;\n        \n        await context.AddDynamicTest(new DynamicTest<Runtime>\n        {\n            TestMethod = @class => @class.SomeMethod(0, 0, 0),\n            TestClassArguments = [a + 10, b + 10, c + 10],\n            TestMethodArguments = [d + 10, e + 10, f + 10],\n            Attributes = [new RepeatAttribute(5)]\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ThrowsWithin Extension Method in C#\nDESCRIPTION: Extends IDelegateSource to assert that an exception is thrown within a specified timespan. Uses generic type constraints and caller argument expression.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_70\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableDelegateAssertionBuilder ThrowsWithin<TException>(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource, System.TimeSpan timeSpan, [System.Runtime.CompilerServices.CallerArgumentExpression(\"timeSpan\")] string? doNotPopulateThisValue = null)\n    where TException : System.Exception { }\n```\n\n----------------------------------------\n\nTITLE: String Negative Assertion Extensions in TUnit\nDESCRIPTION: Extension methods for negative string assertions such as IsNotEmpty, IsNotEqualTo, IsNotNullOrEmpty, and IsNotNullOrWhitespace.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_155\n\nLANGUAGE: C#\nCODE:\n```\npublic static class StringIsNotExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> IsNotEmpty(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> IsNotEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> IsNotEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"stringComparison\")] string doNotPopulateThisValue2 = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> IsNotNullOrEmpty(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> IsNotNullOrWhitespace(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Enum-Based Test Data Collection in TUnit\nDESCRIPTION: This method collects test metadata for enum-based tests, creating TestMetadata objects for the EnumValue test method with different enum values as arguments. It demonstrates how TUnit handles enum parameters in tests and manages test initialization failures.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.DataDrivenTests),\n\t\t\tName = \"EnumValue\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(global::TUnit.TestProject.TestEnum.One),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(global::TUnit.TestProject.TestEnum.Two),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(-1)\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.TestEnum>\n\t\t\t\t{\n\t\t\t\t\tName = \"testEnum\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.DataDrivenTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"DataDrivenTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"DataDrivenTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.DataDrivenTests? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tclassInstanceArguments = [];\n\n\t\t\tglobal::TUnit.TestProject.TestEnum methodArg = global::TUnit.TestProject.TestEnum.One;\n\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.DataDrivenTests>(() => \n\t\t\tnew global::TUnit.TestProject.DataDrivenTests()\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.DataDrivenTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.DataDrivenTests.EnumValue(TUnit.TestProject.TestEnum):0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.EnumValue(methodArg)),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 23,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.DataDrivenTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.DataDrivenTests.EnumValue(TUnit.TestProject.TestEnum):0\",\n\t\t\t\tMethodName = $\"EnumValue\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"DataDrivenTests.EnumValue failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 23,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic ThrowsAsync Assertion for Func<Task> in C#\nDESCRIPTION: This generic overload of `ThrowsAsync` asserts that awaiting the `Task` from the `Func<Task>` delegate throws an exception of type `TException`. It returns a `Task<TException>` containing the strongly-typed caught exception. The `CallerArgumentExpression` captures the source expression.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_24\n\nLANGUAGE: csharp\nCODE:\n```\n        public static System.Threading.Tasks.Task<TException> ThrowsAsync<TException>(System.Func<System.Threading.Tasks.Task> @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression(\"delegate\")] string? doNotPopulateThisValue = null)\n            where TException : System.Exception { }\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract TUnitLogger Class in C#\nDESCRIPTION: Defines an abstract class TUnitLogger that implements the ILogger interface. It provides a base implementation for IsEnabled method and declares abstract methods for logging.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_68\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class TUnitLogger : TUnit.Core.Logging.ILogger\n{\n    protected TUnitLogger() { }\n    public virtual bool IsEnabled(TUnit.Core.Logging.LogLevel logLevel) { }\n    public abstract void Log<TState>(TUnit.Core.Logging.LogLevel logLevel, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter);\n    public abstract System.Threading.Tasks.ValueTask LogAsync<TState>(TUnit.Core.Logging.LogLevel logLevel, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Member Class for TUnit Class Member Assertions (C#)\nDESCRIPTION: Defines the generic `Member` class within the ClassMember namespace. It facilitates fluent assertions on properties or fields of an object (`TActualRootType`). It takes a value source and a property selector expression, providing `EqualTo` and `NotEqualTo` assertion methods that return an `InvokableValueAssertionBuilder`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_34\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace TUnit.Assertions.AssertConditions.ClassMember\n{\n    public class Member<TActualRootType, TPropertyType>\n    {\n        public Member(TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActualRootType> valueSource, System.Linq.Expressions.Expression<System.Func<TActualRootType, TPropertyType>> selector) { }\n        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActualRootType> EqualTo(TPropertyType expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActualRootType> NotEqualTo(TPropertyType expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    }\n    // ... other classes in namespace\n}\n```\n\n----------------------------------------\n\nTITLE: Running Published Test Project Executables in Powershell\nDESCRIPTION: Details executing standalone executables post-publishing. Windows executables use the .exe extension, while Linux/MacOS have no extension. Provides an example of invoking the executable directly with optional flags.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/running-your-tests.md#2025-04-22_snippet_3\n\nLANGUAGE: Powershell\nCODE:\n```\ncd 'C:/Your/Test/Directory/bin/Release/net8.0/win-x64/publish'\n./YourTestProject.exe\n# or with flags\n./YourTestProject.exe --report-trx --coverage\n```\n\n----------------------------------------\n\nTITLE: Initializing and Collecting Synchronous Tests in C#\nDESCRIPTION: This snippet defines a partial class for collecting synchronous test methods from BasicTests. It includes test metadata creation, class instance initialization, and exception handling for the SynchronousTest method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BasicTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class BasicTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new BasicTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BasicTests),\n\t\t\t\tName = \"SynchronousTest\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute()\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BasicTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BasicTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"BasicTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"BasicTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"BasicTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.BasicTests? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tclassInstanceArguments = [];\n\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.BasicTests>(() => \n\t\t\tnew global::TUnit.TestProject.BasicTests()\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.BasicTests>\n\t\t\t{\n\t\t\t\tTestId = $\"TUnit.TestProject.BasicTests.SynchronousTest:0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.SynchronousTest()),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 5,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.BasicTests>\n\t\t\t{\n\t\t\t\tTestId = $\"TUnit.TestProject.BasicTests.SynchronousTest:0\",\n\t\t\t\tMethodName = $\"SynchronousTest\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"BasicTests.SynchronousTest failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 5,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TupleDataSourceDrivenTests Class for TUnit Framework in C#\nDESCRIPTION: This code defines a partial class TupleDataSourceDrivenTests that implements ITestSource interface for the TUnit testing framework. It includes module initialization, test collection, and test metadata generation for tuple-based data source driven tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/TupleDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[  \n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class TupleDataSourceDrivenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new TupleDataSourceDrivenTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.TupleDataSourceDrivenTests),\n\t\t\t\tName = \"DataSource_TupleMethod\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value2\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value3\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.TupleDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.TupleDataSourceDrivenTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"TupleDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"TupleDataSourceDrivenTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"TupleDataSourceDrivenTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.TupleDataSourceDrivenTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tvar methodArgTuples = global::System.TupleExtensions.ToTuple<int, string, bool>(global::TUnit.TestProject.TupleDataSourceDrivenTests.TupleMethod());\n\t\t\t\tint methodArg = methodArgTuples.Item1;\n\t\t\t\tstring methodArg1 = methodArgTuples.Item2;\n\t\t\t\tbool methodArg2 = methodArgTuples.Item3;\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.TupleDataSourceDrivenTests>(() => \n\t\t\t\tnew global::TUnit.TestProject.TupleDataSourceDrivenTests()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.TupleDataSourceDrivenTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.TupleDataSourceDrivenTests.DataSource_TupleMethod(int,string,bool):0\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [methodArg, methodArg1, methodArg2],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_TupleMethod(methodArg, methodArg1, methodArg2)),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 5,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.TupleDataSourceDrivenTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.TupleDataSourceDrivenTests.DataSource_TupleMethod(int,string,bool):0\",\n\t\t\t\t\tMethodName = $\"DataSource_TupleMethod\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"TupleDataSourceDrivenTests.DataSource_TupleMethod failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 5,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n\t}\n\n]\n```\n\n----------------------------------------\n\nTITLE: Implementing TestHookSource Interface in C#\nDESCRIPTION: A partial class implementing ITestHookSource interface that manages test hooks for cleanup operations. It includes hook collection methods and automated registration functionality with proper attribute decorations and parameter configurations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterTests.Test.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_CleanupTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_CleanupTests();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.AfterTests.CleanupTests),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.CleanupTests),\n\t\t\t\t\tName = \"CleanupWithContext\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = [\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test),\n\t\t\t\t\t\tnew global::TUnit.Core.TimeoutAttribute(30_000)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.CleanupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.CleanupTests),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AfterTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"AfterTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"CleanupTests\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.AfterTests.CleanupTests)classInstance).CleanupWithContext(context, cancellationToken)),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tMethodAttributes = [],\n\t\t\t\tClassAttributes = [],\n\t\t\t\tAssemblyAttributes = []\n\t\t\t}\n\t\t];\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ITestSource for ConcreteClass2 in C#\nDESCRIPTION: This code snippet defines a partial class ConcreteClass2 that implements the ITestSource interface. It provides methods for test initialization and collection, including handling of test metadata and exception handling for failed initializations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AbstractTests.Concrete2.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class ConcreteClass2 : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new ConcreteClass2());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\t// ... (implementation details)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Test Configuration with JSON\nDESCRIPTION: This JSON file `testconfig.json` contains key-value pairs for storing configuration settings for tests. It supports nested objects for hierarchical configurations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/test-configuration.md#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"MyKey1\": \"MyValue1\",\n  \"Nested\": {\n    \"MyKey2\": \"MyValue2\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Not Null Assertion Condition for Struct Types in TUnit (C#)\nDESCRIPTION: This class implements an assertion condition that checks if a nullable value type (`TActual?`) is not null. It inherits from `ConvertToAssertCondition`, converting the input `TActual?` to its non-nullable struct type `TActual` if the assertion passes. The `where TActual : struct` constraint enforces that `TActual` is a value type.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_51\n\nLANGUAGE: csharp\nCODE:\n```\n    public class NotNullStructExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.ConvertToAssertCondition<TActual?, TActual>\n        where TActual :  struct\n    {\n        public NotNullStructExpectedValueAssertCondition() { }\n        public override System.Threading.Tasks.ValueTask<System.ValueTuple<TUnit.Assertions.AssertConditions.AssertionResult, TActual>> ConvertValue(TActual? value) { }\n        protected override string GetExpectation() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Initializing and Configuring TUnit Test Method (High Priority)\nDESCRIPTION: Initializes and configures a test method with High priority (High_3) for test execution. Creates test metadata including factory methods for instantiating the test class and executing the test method with proper context.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/PriorityFilteringTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.PriorityFilteringTests>(() => \nnew global::TUnit.TestProject.PriorityFilteringTests()\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.PriorityFilteringTests>\n{\n\tTestId = $\"TUnit.TestProject.PriorityFilteringTests.High_3:0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.High_3()),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 24,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining AssertionDecision Class in C#\nDESCRIPTION: Defines the `AssertionDecision` class, representing the result of an assertion check (Pass, Fail, or Continue). It provides static properties for `Pass` and `Continue` decisions and a static factory method `Fail` to create a failure decision with a message. It implements `IEquatable`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_28\n\nLANGUAGE: csharp\nCODE:\n```\n    public class AssertionDecision : System.IEquatable<TUnit.Assertions.AssertionDecision>\n    {\n        public static TUnit.Assertions.AssertionDecision Continue { get; }\n        public static TUnit.Assertions.AssertionDecision Pass { get; }\n        public static TUnit.Assertions.AssertionDecision Fail(string message) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining DateTimeOffsetEqualsExpectedValueAssertCondition for TUnit DateTimeOffset Assertions (C#)\nDESCRIPTION: Defines the `DateTimeOffsetEqualsExpectedValueAssertCondition` class within the Chronology namespace for comparing `System.DateTimeOffset` values. It inherits from `ExpectedValueAssertCondition` and provides a `SetTolerance` method using `System.TimeSpan` for approximate equality checks.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_31\n\nLANGUAGE: csharp\nCODE:\n```\n    public class DateTimeOffsetEqualsExpectedValueAssertCondition : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<System.DateTimeOffset, System.DateTimeOffset>\n    {\n        public DateTimeOffsetEqualsExpectedValueAssertCondition(System.DateTimeOffset expected) { }\n        protected override string GetExpectation() { }\n        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(System.DateTimeOffset actualValue, System.DateTimeOffset expectedValue) { }\n        public void SetTolerance(System.TimeSpan tolerance) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing BetweenAssertionBuilderWrapper for Range Comparison\nDESCRIPTION: Specialized assertion builder for checking if values fall within a range. It supports both inclusive and exclusive bounds for the comparison range.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_80\n\nLANGUAGE: C#\nCODE:\n```\npublic class BetweenAssertionBuilderWrapper<TActual> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>\n    where TActual : System.IComparable<TActual>\n{\n    public TUnit.Assertions.AssertionBuilders.Wrappers.BetweenAssertionBuilderWrapper<TActual> WithExclusiveBounds() { }\n    public TUnit.Assertions.AssertionBuilders.Wrappers.BetweenAssertionBuilderWrapper<TActual> WithInclusiveBounds() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ValueTask-based Async Exception Assertion\nDESCRIPTION: Overload of ThrowsAsync that accepts a ValueTask for lightweight asynchronous operations. Checks if the operation throws an exception of the specified type.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic static System.Threading.Tasks.Task<TException> ThrowsAsync<TException>(System.Threading.Tasks.ValueTask @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression(\"delegate\")] string? doNotPopulateThisValue = null)\n            where TException : System.Exception { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Class Constructor in C#\nDESCRIPTION: Shows the usage of ClassConstructorAttribute<T> where T must implement IClassConstructor interface to control test class instantiation. The interface requires implementing object generation functionality.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/class-constructors.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[ClassConstructorAttribute<T>]\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract DependencyInjectionDataSourceAttribute in C#\nDESCRIPTION: This abstract C# attribute `DependencyInjectionDataSourceAttribute<TScope>` facilitates creating TUnit data sources integrated with a dependency injection container. It inherits from `NonTypedDataSourceGeneratorAttribute`. Derived classes must implement methods to `CreateScope` (representing a DI scope) and `Create` an object of a specific type within that scope. The overridden `GenerateDataSources` method uses these implementations to provide test data.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\n    public abstract class DependencyInjectionDataSourceAttribute<TScope> : TUnit.Core.NonTypedDataSourceGeneratorAttribute\n    {\n        protected DependencyInjectionDataSourceAttribute() { }\n        public abstract object? Create(TScope scope, System.Type type);\n        public abstract TScope CreateScope(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata);\n        public override System.Collections.Generic.IEnumerable<System.Func<object?[]?>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Collection Assertion Methods for TUnit\nDESCRIPTION: Extension methods for asserting conditions on collections. Provides a method to check if a collection contains only elements that match a specific condition.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_59\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> ContainsOnly<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, bool> matcher, [System.Runtime.CompilerServices.CallerArgumentExpression(\"matcher\")] string doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Creating and Registering TestMetadata for Method Data Source Tests in C#\nDESCRIPTION: This snippet demonstrates how test metadata is created and added to the test collection. It sets up the test execution context, creates a factory for test class instances, and registers the test with proper identifiers and parameters.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.MethodDataSourceDrivenTests? classInstance = null;\nobject?[]? classInstanceArguments = null;\nclassInstanceArguments = [];\n\nglobal::TUnit.TestProject.MethodDataSourceDrivenTests.BaseValue methodArg = global::TUnit.TestProject.MethodDataSourceDrivenTests.MethodWithBaseReturn()();\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.MethodDataSourceDrivenTests>(() => \nnew global::TUnit.TestProject.MethodDataSourceDrivenTests()\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenTests>\n{\n\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.MethodDataSourceDrivenTests.DataSource_WithBaseReturn(TUnit.TestProject.MethodDataSourceDrivenTests.BaseValue):0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [methodArg],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_WithBaseReturn(methodArg)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 53,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Source Generator Class for Test Collection in C#\nDESCRIPTION: This code defines a partial class that implements ITestSource to register and collect tests. It includes the module initializer and methods for test collection that the TUnit framework calls to discover and run tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class MethodDataSourceDrivenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new MethodDataSourceDrivenTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n```\n\n----------------------------------------\n\nTITLE: Configuring BeforeClass Hook with Context Parameter in C#\nDESCRIPTION: Defines a BeforeClassHookMethod that calls the BeforeAllSetUpWithContext method, passing a ClassHookContext parameter. This hook provides context information to the setup method when it runs before a test class.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeTests.Test.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeClassHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.BeforeClassHookMethod\n\t\t{\n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\tName = \"BeforeAllSetUpWithContext\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.ClassHookContext>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"context\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.SetupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"BeforeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"BeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"SetupTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.BeforeTests.SetupTests.BeforeAllSetUpWithContext(context)),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tFilePath = @\"\",\n\t\t\t\tLineNumber = 56,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\tAssemblyAttributes = [],\n\t\t\t},\n\t\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Extension Methods for Exception Assertions in TUnit\nDESCRIPTION: Provides extension methods for creating various exception assertions, including type-specific exceptions and timing constraints.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_69\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class ThrowsExtensions\n{\n    public static TUnit.Assertions.AssertConditions.Throws.ThrowsException<object?, TException> Throws<TException>(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource)\n        where TException : System.Exception { }\n    public static TUnit.Assertions.AssertConditions.Throws.ThrowsException<object?, TException> ThrowsExactly<TException>(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource)\n        where TException : System.Exception { }\n    public static TUnit.Assertions.AssertConditions.Throws.ThrowsException<object?, System.Exception> ThrowsException(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource) { }\n    public static TUnit.Assertions.AssertionBuilders.CastableResultAssertionBuilder<object?, object?> ThrowsNothing(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource) { }\n    public static TUnit.Assertions.AssertionBuilders.CastableResultAssertionBuilder<TActual, TActual> ThrowsNothing<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueDelegateSource<TActual> delegateSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableDelegateAssertionBuilder ThrowsWithin(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource, System.TimeSpan timeSpan, [System.Runtime.CompilerServices.CallerArgumentExpression(\"timeSpan\")] string? doNotPopulateThisValue = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining StackTraceHidden Attribute in .NET (C#)\nDESCRIPTION: Implements a sealed StackTraceHiddenAttribute class in the System.Diagnostics namespace to allow developers to hide various program elements from stack traces. The attribute supports application to classes, methods, constructors, and structs, and prevents inheritance. Dependencies include System and System.Diagnostics.CodeAnalysis. Intended usage is in codebases where stack trace noise needs to be minimized or certain methods/types require concealment in runtime exceptions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/PolyfillTests.Test_Without_BuildProperty.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[AttributeUsage(\n    AttributeTargets.Class |\n    AttributeTargets.Method |\n    AttributeTargets.Constructor |\n    AttributeTargets.Struct,\n    Inherited = false)]\nsealed class StackTraceHiddenAttribute : Attribute;\n```\n\n----------------------------------------\n\nTITLE: Injecting Data into NUnit Test Fixtures via Constructor using TestFixtureSource in C#\nDESCRIPTION: This C# snippet illustrates using the `[TestFixtureSource]` attribute in NUnit to create multiple instances of the `MyTests` class, each initialized with a different `Tenant` object obtained from `Tenant.AllTenants`. This enables running the same tests against different data contexts (tenants), although the text notes limitations in dynamically setting properties based on this injected data for filtering purposes within NUnit.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/comparison/framework-differences.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[TestFixtureSource(typeof(Tenant), nameof(Tenant.AllTenants))]\npublic class MyTests(Tenant tenant)\n{\n    [Test]\n    public async Task Test1()\n    {\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Test Data Generation Implementation in C#\nDESCRIPTION: Implementation of test data generation logic using AutoFixture for parameterized tests. Handles class and method level test data generation with error handling and metadata creation.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testClassType = typeof(global::TUnit.TestProject.DataSourceGeneratorTests);\n\t\tvar methodInfo = global::TUnit.Core.Helpers.MethodInfoRetriever.GetMethodInfo(typeof(global::TUnit.TestProject.DataSourceGeneratorTests), \"GeneratedData_Method\", 0, [typeof(global::System.Int32)]);\n\n\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t// ... rest of implementation\n\t}\n\tcatch (global::System.Exception exception)\n\t{\n\t\t// ... exception handling\n\t}\n\treturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StringContainsAssertionBuilderWrapper for String Contains Testing\nDESCRIPTION: Specialized assertion builder for checking if strings contain specific substrings. It supports options for ignoring whitespace and trimming the strings before comparison.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_92\n\nLANGUAGE: C#\nCODE:\n```\npublic class StringContainsAssertionBuilderWrapper : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string>\n{\n    public TUnit.Assertions.AssertionBuilders.Wrappers.StringContainsAssertionBuilderWrapper IgnoringWhitespace() { }\n    public TUnit.Assertions.AssertionBuilders.Wrappers.StringContainsAssertionBuilderWrapper WithTrimming() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CultureExecutor Class in C#\nDESCRIPTION: This C# class `CultureExecutor` extends `DedicatedThreadExecutor` to run tests within a specific cultural context. It takes a `CultureInfo` object in its constructor and overrides `ConfigureThread` to set the culture for the dedicated thread before executing tests, ensuring culture-specific behavior.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n    public class CultureExecutor : TUnit.Core.DedicatedThreadExecutor\n    {\n        public CultureExecutor(System.Globalization.CultureInfo cultureInfo) { }\n        protected override void ConfigureThread(System.Threading.Thread thread) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing TimeOnly and TimeSpan Assertion Builders in C#\nDESCRIPTION: Defines wrapper classes for TimeOnly and TimeSpan assertion builders with a 'Within' method to specify tolerance.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_94\n\nLANGUAGE: C#\nCODE:\n```\npublic class TimeOnlyEqualToAssertionBuilderWrapper : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.TimeOnly>\n{\n    public TUnit.Assertions.AssertionBuilders.Wrappers.TimeOnlyEqualToAssertionBuilderWrapper Within(System.TimeSpan tolerance, [System.Runtime.CompilerServices.CallerArgumentExpression(\"tolerance\")] string doNotPopulateThis = \"\") { }\n}\npublic class TimeSpanEqualToAssertionBuilderWrapper : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.TimeSpan>\n{\n    public TUnit.Assertions.AssertionBuilders.Wrappers.TimeSpanEqualToAssertionBuilderWrapper Within(System.TimeSpan tolerance, [System.Runtime.CompilerServices.CallerArgumentExpression(\"tolerance\")] string doNotPopulateThis = \"\") { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ThrowsAsync Assertion for ValueTask (Any Exception) in C#\nDESCRIPTION: This overload of the static `ThrowsAsync` method asserts that awaiting the provided `ValueTask` delegate results in any `System.Exception`. It returns a `Task<System.Exception>` containing the caught exception. The `CallerArgumentExpression` captures the source expression.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\n        public static System.Threading.Tasks.Task<System.Exception> ThrowsAsync(System.Threading.Tasks.ValueTask @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression(\"delegate\")] string? doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Defining NotInParallelConstraint Class in C#\nDESCRIPTION: Implements the IParallelConstraint interface to specify tests that should not run in parallel. It contains a list of constraint keys and an order property.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic class NotInParallelConstraint : System.IEquatable<TUnit.Core.NotInParallelConstraint>, TUnit.Core.Interfaces.IParallelConstraint\n{\n    public NotInParallelConstraint(System.Collections.Generic.IReadOnlyList<string> NotInParallelConstraintKeys) { }\n    public System.Collections.Generic.IReadOnlyList<string> NotInParallelConstraintKeys { get; init; }\n    public int Order { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Enum Assertion Extensions in C#\nDESCRIPTION: Defines extension methods for enum assertions, including flag checks, name comparisons, value comparisons, and defined status checks.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_97\n\nLANGUAGE: C#\nCODE:\n```\npublic static class EnumHasExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TEnum> DoesNotHaveFlag<TEnum>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TEnum> valueSource, TEnum expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue1 = null)\n        where TEnum : System.Enum { }\n    \n    // ... (other enum assertion extension methods)\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Matrix Test Metadata for Method3\nDESCRIPTION: This snippet generates test metadata for the Method3 of MatrixTests class using matrix data sources. It handles test initialization, argument generation, and exception handling.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MatrixTests.Test.verified.txt#2025-04-22_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nnodes.Add(new TestMetadata<global::TUnit.TestProject.MatrixTests>\n{\n\tTestId = $\"global::TUnit.Core.MatrixDataSourceAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.MatrixTests.Method3(int):0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [methodArg],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Method3(methodArg)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 133,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Parallel Execution Control Classes in C#\nDESCRIPTION: Defines classes for managing parallel test execution including NotInParallelConstraint, ParallelGroupAttribute, and ParallelGroupConstraint. These classes handle test parallelization rules and grouping.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\npublic class NotInParallelConstraint : System.IEquatable<TUnit.Core.NotInParallelConstraint>, TUnit.Core.Interfaces.IParallelConstraint\n{\n    public NotInParallelConstraint(System.Collections.Generic.IReadOnlyList<string> NotInParallelConstraintKeys) { }\n    public System.Collections.Generic.IReadOnlyList<string> NotInParallelConstraintKeys { get; init; }\n    public int Order { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing and Registering Test Instances for DataSourceTest (TUnit, C#)\nDESCRIPTION: This snippet creates a test instance, prepares the factory delegates for class/method execution, and adds TestMetadata for 'DataSourceTest' to the list of discovered tests. It demonstrates retrieving class and method arguments from the data source, context initialization, and error handling via FailedTestMetadata. Inputs include test arguments and context objects, and outputs are appended test metadata instances. Dependencies include TUnit.Core, System.Threading, and TestProject implementations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/TimeoutCancellationTokenTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nint classArg = global::TUnit.TestProject.TimeoutCancellationTokenTests.DataSource();\nclassInstanceArguments = [classArg];\n\nint methodArg = global::TUnit.TestProject.TimeoutCancellationTokenTests.DataSource();\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.TimeoutCancellationTokenTests>(() => \nnew global::TUnit.TestProject.TimeoutCancellationTokenTests(classArg)\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.TimeoutCancellationTokenTests>\n{\n\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS0:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.TimeoutCancellationTokenTests(int).DataSourceTest(int,System.Threading.CancellationToken):0\",\n\tTestClassArguments = [classArg],\n\tTestMethodArguments = [methodArg],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSourceTest(methodArg, cancellationToken)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 47,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Exception Handling Assertions with ThrowsException\nDESCRIPTION: Provides comprehensive exception assertion capabilities including message validation and inner exception checking.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_67\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ThrowsException<TActual, TException>\n    where TException : System.Exception\n{\n    public ThrowsException(TUnit.Assertions.AssertionBuilders.InvokableDelegateAssertionBuilder delegateAssertionBuilder, TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource source, System.Func<System.Exception?, System.Exception?> selector) { }\n    public TUnit.Assertions.AssertConditions.Operators.ValueAnd<TException> And { get; }\n    public TUnit.Assertions.AssertConditions.Operators.DelegateOr<object?> Or { get; }\n    public System.Runtime.CompilerServices.TaskAwaiter<TException?> GetAwaiter() { }\n    public TUnit.Assertions.AssertConditions.Throws.ThrowsException<TActual, System.Exception> WithInnerException() { }\n    public TUnit.Assertions.AssertConditions.Throws.ThrowsException<TActual, TException> WithMessage(string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public TUnit.Assertions.AssertConditions.Throws.ThrowsException<TActual, TException> WithMessageMatching(TUnit.Assertions.AssertConditions.StringMatcher match, [System.Runtime.CompilerServices.CallerArgumentExpression(\"match\")] string? doNotPopulateThisValue = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ITestSource Interface for TUnit Test Registration in C#\nDESCRIPTION: This code defines a partial class that implements ITestSource to register tests with TUnit. It contains methods for test collection, initialization, and manages test metadata including class parameters and test methods.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1589.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[  \n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class MyTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new MyTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1589.MyTests),\n\t\t\t\tName = \"Test1\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute()\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._1589.MyTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1589.MyTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Tests1589\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"Tests1589\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"MyTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._1589\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.Bugs._1589.MyFixture>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"myFixture\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.Bugs._1589.MyTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tvar classArgDataGeneratorMetadata = new DataGeneratorMetadata\n\t\t\t\t{\n\t\t\t\t\tType = global::TUnit.Core.Enums.DataGeneratorType.ClassParameters,\n\t\t\t\t\tTestBuilderContext = testBuilderContextAccessor,\n\t\t\t\t\tTestInformation = testInformation,\n\t\t\t\t\tMembersToGenerate = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.Bugs._1589.MyFixture>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"myFixture\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tTestSessionId = sessionId,\n\t\t\t\t\tTestClassInstance = classInstance,\n\t\t\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t\t\t};\n\t\t\t\tvar classDataAttribute = new global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.Bugs._1589.MyFixture>()\n\t\t\t\t{\n\t\t\t\t\tShared = global::TUnit.Core.SharedType.None,\n};\n\n\t\t\t\t\ttestBuilderContext.DataAttributes.Add(classDataAttribute);\n\n\t\t\t\t\tvar classArgGeneratedDataArray = classDataAttribute.GenerateDataSources(classArgDataGeneratorMetadata);\n\n\t\t\t\t\tforeach (var classArgGeneratedDataAccessor in classArgGeneratedDataArray)\n\t\t\t\t\t{\n\t\t\t\t\t\tclassDataIndex++;\n\t\t\t\t\t\tvar classArgGeneratedData = classArgGeneratedDataAccessor();\n\t\t\t\t\t\tclassInstanceArguments = [classArgGeneratedData];\n\n\t\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._1589.MyTests>(() => \n\t\t\t\t\t\tnew global::TUnit.TestProject.Bugs._1589.MyTests(classArgGeneratedData)\n\t\t\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._1589.MyTests>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.Bugs._1589.MyFixture>:{classDataIndex}:CL-GAC0:TUnit.TestProject.Bugs._1589.MyTests(TUnit.TestProject.Bugs._1589.MyFixture).Test1:0\",\n\t\t\t\t\t\t\tTestClassArguments = [classArgGeneratedData],\n\t\t\t\t\t\t\tTestMethodArguments = [],\n\t\t\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Test1()),\n\t\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\t\tTestLineNumber = 15,\n\t\t\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\t\t\ttestBuilderContext = new();\n\t\t\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (global::System.Exception exception)\n\t\t\t\t{\n\t\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._1589.MyTests>\n\t\t\t\t\t{\n\t\t\t\t\t\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.Bugs._1589.MyFixture>:{classDataIndex}:CL-GAC0:TUnit.TestProject.Bugs._1589.MyTests(TUnit.TestProject.Bugs._1589.MyFixture).Test1:0\",\n\t\t\t\t\t\tMethodName = $\"Test1\",\n\t\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"MyTests.Test1 failed to initialize\", exception),\n\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\tTestLineNumber = 15,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn nodes;\n\t\t\t}\n\t\t}\n]\n```\n\n----------------------------------------\n\nTITLE: Class Data Source Attributes in C#\nDESCRIPTION: Defines attributes for generating test data from classes. Supports single and multiple (tuple-based) parameter types with options for sharing data between tests. Implements data source generation for parameterized tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method | System.AttributeTargets.Property, AllowMultiple=true)]\npublic sealed class ClassDataSourceAttribute<T> : TUnit.Core.DataSourceGeneratorAttribute<T>\n    where T : new()\n{\n    public ClassDataSourceAttribute() { }\n    public string Key { get; set; }\n    public TUnit.Core.SharedType Shared { get; set; }\n    public override System.Collections.Generic.IEnumerable<System.Func<T>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata) { }\n}\n\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\npublic sealed class ClassDataSourceAttribute<T1, T2> : TUnit.Core.DataSourceGeneratorAttribute<T1, T2>\n    where T1 : new()\n    where T2 : new()\n{\n    public ClassDataSourceAttribute() { }\n    public string[] Keys { get; set; }\n    public TUnit.Core.SharedType[] Shared { get; set; }\n    public override System.Collections.Generic.IEnumerable<System.Func<System.ValueTuple<T1, T2>>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata) { }\n}\n\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\npublic sealed class ClassDataSourceAttribute<T1, T2, T3> : TUnit.Core.DataSourceGeneratorAttribute<T1, T2, T3>\n    where T1 : new()\n    where T2 : new()\n    where T3 : new()\n{\n    public ClassDataSourceAttribute() { }\n    public string[] Keys { get; set; }\n```\n\n----------------------------------------\n\nTITLE: Defining That Assertion for Func<Task> Delegate in C#\nDESCRIPTION: This overload of the static `That` method in the `Assert` class handles asynchronous operations represented by a `Func<Task>`. It returns an `AsyncDelegateAssertionBuilder` for chaining assertions related to the asynchronous execution (e.g., checking for exceptions). The `CallerArgumentExpression` attribute captures the source expression.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n        public static TUnit.Assertions.AssertionBuilders.AsyncDelegateAssertionBuilder That(System.Func<System.Threading.Tasks.Task> value, [System.Runtime.CompilerServices.CallerArgumentExpression(\"value\")] string? doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Delegate Assertion Condition Base Class (Actual Type) in TUnit (C#)\nDESCRIPTION: This abstract generic class provides a base for assertion conditions implemented using delegates, specifying the type of the actual value (`TActual`). It inherits from the more specific generic `DelegateAssertCondition<TActual, System.Exception>`, defaulting the exception type to `System.Exception`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_43\n\nLANGUAGE: csharp\nCODE:\n```\n    public abstract class DelegateAssertCondition<TActual> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<TActual, System.Exception>\n    {\n        protected DelegateAssertCondition() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Creating Test Metadata for DataSourceClassCombinedWithDataSourceMethod Tests\nDESCRIPTION: This code creates test metadata objects for tests that have data sources at both class and method levels. It sets up the test context, creates class instances with appropriate arguments, and configures test metadata with proper identification and execution factories.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceClassCombinedWithDataSourceMethodTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod? classInstance = null;\nobject?[]? classInstanceArguments = null;\nint classArg = global::TUnit.TestProject.CommonTestData.Three();\nclassInstanceArguments = [classArg];\n\nint methodArg = global::TUnit.TestProject.CommonTestData.Two();\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod>(() => \nnew global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod(classArg)\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod>\n{\n    TestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS2:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod(int).DataSourceClassCombinedWithDataSourceMethodTest(int):0\",\n    TestClassArguments = [classArg],\n    TestMethodArguments = [methodArg],\n    TestClassProperties = [],\n    CurrentRepeatAttempt = 0,\n    RepeatLimit = 0,\n    ResettableClassFactory = resettableClassFactory,\n    TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSourceClassCombinedWithDataSourceMethodTest(methodArg)),\n    TestFilePath = @\"\",\n    TestLineNumber = 10,\n    TestMethod = testInformation,\n    TestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Code Coverage Extension for TUnit\nDESCRIPTION: Commands to install and run the code coverage extension via NuGet package Microsoft.Testing.Extensions.CodeCoverage.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/extensions/extensions.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndotnet add package Microsoft.Testing.Extensions.CodeCoverage\n```\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run --configuration Release --coverage\n```\n\n----------------------------------------\n\nTITLE: Defining ThrowsAsync Assertion for Task (Specific Exception Type) in C#\nDESCRIPTION: This overload of the static `ThrowsAsync` method asserts that awaiting the provided `Task` delegate throws an exception of the specified `System.Type`. It returns a `Task<System.Exception>` containing the caught exception. The `CallerArgumentExpression` captures the source expression.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\n        public static System.Threading.Tasks.Task<System.Exception> ThrowsAsync(System.Type type, System.Threading.Tasks.Task @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression(\"delegate\")] string? doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing EnumHasSameValueAsCondition in C#\nDESCRIPTION: A class that implements a condition to verify if one enum has the same underlying value as another enum of a different type. It extends BaseAssertCondition and requires both types to be enums.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_105\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumHasSameValueAsCondition<TEnum, TExpected> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TEnum>\n    where TEnum : System.Enum\n    where TExpected : System.Enum\n{\n    public EnumHasSameValueAsCondition(TExpected expected) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TEnum? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing String Start and End Assertions in C#\nDESCRIPTION: These methods extend IValueSource<string> to provide assertions for string start and end conditions. They allow for optional string comparison options.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_140\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> StartsWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> StartsWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"stringComparison\")] string doNotPopulateThisValue2 = null) { }\n\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> EndsWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> EndsWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"stringComparison\")] string doNotPopulateThisValue2 = null) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing EqualsExpectedValueAssertCondition in C#\nDESCRIPTION: A class that implements a condition to check if a value equals an expected value. It can use a custom equality comparer and extends ExpectedValueAssertCondition.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_114\n\nLANGUAGE: C#\nCODE:\n```\npublic class EqualsExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TActual>\n{\n    public EqualsExpectedValueAssertCondition(TActual expected) { }\n    public EqualsExpectedValueAssertCondition(TActual expected, System.Collections.Generic.IEqualityComparer<TActual> equalityComparer) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TActual? expectedValue) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CompareOptions in C#\nDESCRIPTION: Defines the 'CompareOptions' class, which is used to configure how comparisons should be performed, such as specifying equivalency criteria and which members to ignore. This class aids in customizing the behavior of the 'CheckEquivalent' function.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class CompareOptions : System.IEquatable<TUnit.Assertions.CompareOptions> { public CompareOptions() { } public TUnit.Assertions.Enums.EquivalencyKind EquivalencyKind { get; set; } public string[] MembersToIgnore { get; init; } }\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Source Collection for MatrixTests_Two in TUnit Framework\nDESCRIPTION: Auto-generated code for collecting matrix-based tests for the MatrixTest_Two method. This snippet configures test parameters with multiple int values and boolean values to generate all possible test combinations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MatrixTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.MatrixTests),\n\tName = \"MatrixTest_Two\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute(),\n\t\tnew global::TUnit.Core.MatrixDataSourceAttribute()\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t{\n\t\t\tName = \"i\",\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.MatrixAttribute(1, 2)\n\t\t\t],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t{\n\t\t\tName = \"i2\",\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.MatrixAttribute(1, 2, 3)\n\t\t\t],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t{\n\t\t\tName = \"i3\",\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.MatrixAttribute(1, 2, 3, 4)\n\t\t\t],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t{\n\t\t\tName = \"boolean\",\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.MatrixAttribute(true, false)\n\t\t\t],\n\t\t},\n\t],\n\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.MatrixTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t{\n\t\tType = typeof(global::TUnit.TestProject.MatrixTests),\n\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"MatrixTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t{\n\t\t\tName = \"MatrixTests\",\n\t\t\tAttributes = [],\n\t\t}),\n\t\tName = \"MatrixTests\",\n\t\tNamespace = \"TUnit.TestProject\",\n\t\tAttributes = [],\n\t\tParameters = [],\n\t\tProperties = [],\n\t}),\n};\n```\n\nLANGUAGE: C#\nCODE:\n```\nvar methodArgDataGeneratorMetadata = new DataGeneratorMetadata\n{\n\tType = global::TUnit.Core.Enums.DataGeneratorType.TestParameters,\n\tTestBuilderContext = testBuilderContextAccessor,\n\tTestInformation = testInformation,\n\tMembersToGenerate = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t{\n\t\t\tName = \"i\",\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.MatrixAttribute(1, 2)\n\t\t\t],\n\t\t}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Collecting Tests for ArgsAsArrayTests in C#\nDESCRIPTION: This code snippet defines a partial class ArgsAsArrayTests that implements ITestSource. It includes methods for initializing the test source and collecting test metadata for the Params, NonParams, and ParamsEnumerable test methods.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ArgsAsArrayTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class ArgsAsArrayTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new ArgsAsArrayTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\t// ... (test collection logic for each method)\n\t\treturn nodes;\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Test Metadata and Exception in C# TUnit\nDESCRIPTION: This code snippet demonstrates setting up and handling test metadata for data source-driven tests utilizing TUnit's framework in C#. It outlines the creation of a `TestBuilderContext`, specifies attributes and parameters, and manages exceptions by capturing failed test metadata. It is reliant on TUnit core classes and assumes a method named `DataSource_Method4`. It processes session IDs and method arguments, returning a list of test metadata.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n    Type = typeof(global::TUnit.TestProject.MethodDataSourceDrivenTests),\n    Name = \"DataSource_Method4\",\n    GenericTypeCount = 0,\n    ReturnType = typeof(void),\n    Attributes = \n    [\n        new global::TUnit.Core.TestAttribute(),\n        new global::TUnit.Core.MethodDataSourceAttribute(\"SomeMethod\")\n        {\n            Arguments = [\"Hello World!\", 5, true],\n        },\n        new global::TUnit.Core.MethodDataSourceAttribute(\"SomeMethod\")\n        {\n            Arguments = new object[] { \"Hello World!\", 6, true },\n        },\n        new global::TUnit.Core.MethodDataSourceAttribute(\"SomeMethod\")\n        {\n            Arguments = [\"Hello World!\", 7, true],\n        },\n        new global::TUnit.Core.MethodDataSourceAttribute(\"SomeMethod\")\n        {\n            Arguments = new object[] { \"Hello World!\", 8, true },\n        }\n    ],\n    Parameters = \n    [\n        new global::TUnit.Core.SourceGeneratedParameterInformation<int>\n        {\n            Name = \"value\",\n            Attributes = [],\n        },\n    ],\n    Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.MethodDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n    {\n        Type = typeof(global::TUnit.TestProject.MethodDataSourceDrivenTests),\n        Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"MethodDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n        {\n            Name = \"MethodDataSourceDrivenTests\",\n            Attributes = [],\n        }),\n        Name = \"MethodDataSourceDrivenTests\",\n        Namespace = \"TUnit.TestProject\",\n        Attributes = [],\n        Parameters = [],\n        Properties = [],\n    }),\n};\n\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.MethodDataSourceDrivenTests? classInstance = null;\nobject?[]? classInstanceArguments = null;\nclassInstanceArguments = [];\n\nint methodArg = global::TUnit.TestProject.MethodDataSourceDrivenTests.SomeMethod(\"Hello World!\", 7, true);\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.MethodDataSourceDrivenTests>(() => \nnew global::TUnit.TestProject.MethodDataSourceDrivenTests()\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n```\n\n----------------------------------------\n\nTITLE: Defining BeforeAllSetUp Hook with CancellationToken for TUnit in C#\nDESCRIPTION: Defines an assembly-level BeforeAllSetUp method for TUnit with a CancellationToken parameter, suitable for asynchronous cancellation-aware setup logic. Requires TUnit.Core and System.Threading for proper invocation. The method is registered and attributed for execution before running tests within the assembly.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyBeforeTests.Test.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.BeforeTests.AssemblySetupTests),\n\tName = \"BeforeAllSetUp\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Assembly)\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t{\n\t\t\tName = \"cancellationToken\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.AssemblySetupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t{\n\t\tType = typeof(global::TUnit.TestProject.BeforeTests.AssemblySetupTests),\n\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AssemblyBeforeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t{\n\t\t\tName = \"AssemblyBeforeTests\",\n\t\t\tAttributes = [],\n\t\t}),\n\t\tName = \"AssemblySetupTests\",\n\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\tAttributes = [],\n\t\tParameters = [],\n\t\tProperties = [],\n\t}),\n},\nBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.BeforeTests.AssemblySetupTests.BeforeAllSetUp(cancellationToken)),\nHookExecutor = DefaultExecutor.Instance,\nOrder = 0,\nFilePath = @\"\",\nLineNumber = 62,\nMethodAttributes = \n[\n\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Assembly)\n],\nClassAttributes = [],\nAssemblyAttributes = [],\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Last Test in Class Adapter in C#\nDESCRIPTION: Defines the LastTestInClassAdapter class which adapts the last test in a class event to the IExecutableHook interface.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_54\n\nLANGUAGE: C#\nCODE:\n```\npublic class LastTestInClassAdapter : TUnit.Core.Hooks.IExecutableHook<TUnit.Core.ClassHookContext>\n{\n    public LastTestInClassAdapter(TUnit.Core.Interfaces.ILastTestInClassEventReceiver lastTestInClassEventReceiver, TUnit.Core.TestContext testContext) { }\n    public TUnit.Core.SourceGeneratedMethodInformation MethodInfo { get; }\n    public string Name { get; }\n    public int Order { get; }\n    public bool Execute(TUnit.Core.ClassHookContext context, System.Threading.CancellationToken cancellationToken) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing with Explicit Attribute - TUnit Framework - C#\nDESCRIPTION: This code snippet demonstrates the use of the [Explicit] attribute in C# with the TUnit framework. The purpose is to define a test method that should only be executed explicitly, not with general test runs. It requires the TUnit.Core library and is useful for running tests in isolation, such as during local development. The key parameter is the [Explicit] attribute, indicating the test's explicit nature. The expected behavior is the test runs separately from other general tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/explicit.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    [Explicit]\n    public async Task MyTest()\n    {\n        \n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering and Collecting After-Test Global Clean-Up Hooks with TUnit in C#\nDESCRIPTION: This snippet shows the partial class Hooks_GlobalCleanUpTests, implementing the ITestHookSource for TUnit, and its CollectAfterEveryTestHooks method. It returns a static hook specifically for global clean-up, using detailed method/class metadata (for AfterAllCleanUp). The snippet also includes a ModuleInitializer to register the hook source at module load time. All hooks, parameters, and type details are explicitly provided for source-generated discovery. Dependencies: TUnit.Core, TUnit.Core.Hooks, SourceRegistrar. Inputs are typically sessionId strings; output: static list of after-every-test hooks. No before/after test hooks are defined for instance.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticAfterEachTests.Test.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_GlobalCleanUpTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_GlobalCleanUpTests();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.AfterTestHookMethod\n\t\t\t{ \n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),\n\t\t\t\tName = \"AfterAllCleanUp\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterEveryAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"context\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.GlobalCleanUpTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"GlobalStaticAfterEachTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"GlobalStaticAfterEachTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"GlobalCleanUpTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.GlobalCleanUpTests.AfterAllCleanUp(context)),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tFilePath = @\"\",\n\t\t\t\tLineNumber = 50,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterEveryAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\tAssemblyAttributes = [],\n\t\t\t},\n\t\t];\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TestMetadata Abstract Class in C# for TUnit Framework\nDESCRIPTION: This abstract class defines the metadata for a test in the TUnit framework. It includes properties for test details, arguments, and methods for building test details and cloning with a new method factory.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_46\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic abstract class TestMetadata : System.IEquatable<TUnit.Core.TestMetadata>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    protected TestMetadata() { }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public int CurrentRepeatAttempt { get; init; }\n    public System.Exception? DiscoveryException { get; init; }\n    public System.Attribute[] DynamicAttributes { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public int RepeatLimit { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Core.TestBuilderContext TestBuilderContext { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public object?[] TestClassArguments { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public object?[] TestClassProperties { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string TestFilePath { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string TestId { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public int TestLineNumber { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Core.SourceGeneratedMethodInformation TestMethod { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public object?[] TestMethodArguments { get; init; }\n    public abstract TUnit.Core.TestDetails BuildTestDetails();\n    public abstract TUnit.Core.TestMetadata CloneWithNewMethodFactory(System.Func<object, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask> testMethodFactory);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CollectionWrapper Class in C#\nDESCRIPTION: Defines a generic `CollectionWrapper<TInner>` class used for applying assertions to elements within a collection. It takes a value source for the collection and provides `Satisfy` methods to apply assertions (potentially with async or sync mapping) to each element.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_30\n\nLANGUAGE: csharp\nCODE:\n```\n    public class CollectionWrapper<TInner>\n    {\n        public CollectionWrapper(TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }\n        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> Satisfy(System.Func<TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TInner?>, TUnit.Assertions.AssertionBuilders.IInvokableAssertionBuilder> assert, [System.Runtime.CompilerServices.CallerArgumentExpression(\"assert\")] string assertionBuilderExpression = \"\") { }\n        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> Satisfy<TExpected>(System.Func<TInner?, System.Threading.Tasks.Task<TExpected>?> asyncMapper, System.Func<TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TExpected?>, TUnit.Assertions.AssertionBuilders.IInvokableAssertionBuilder> assert, [System.Runtime.CompilerServices.CallerArgumentExpression(\"asyncMapper\")] string mapperExpression = \"\", [System.Runtime.CompilerServices.CallerArgumentExpression(\"assert\")] string assertionBuilderExpression = \"\") { }\n        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> Satisfy<TExpected>(System.Func<TInner?, TExpected> mapper, System.Func<TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TExpected?>, TUnit.Assertions.AssertionBuilders.IInvokableAssertionBuilder> assert, [System.Runtime.CompilerServices.CallerArgumentExpression(\"mapper\")] string mapperExpression = \"\", [System.Runtime.CompilerServices.CallerArgumentExpression(\"assert\")] string assertionBuilderExpression = \"\") { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining That Assertion for IEnumerable in C#\nDESCRIPTION: This overload of the static `That` method in the `Assert` class accepts a `System.Collections.IEnumerable`. It returns a `ValueAssertionBuilder<IEnumerable<object>>` to enable fluent assertions on the properties or contents of the enumerable. The `CallerArgumentExpression` attribute captures the source expression for better reporting.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n        public static TUnit.Assertions.AssertionBuilders.ValueAssertionBuilder<System.Collections.Generic.IEnumerable<object>> That(System.Collections.IEnumerable enumerable, [System.Runtime.CompilerServices.CallerArgumentExpression(\"enumerable\")] string? doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Configuring DedicatedThreadExecutor and CultureExecutor for Test Execution - C#\nDESCRIPTION: DedicatedThreadExecutor and its subclass CultureExecutor encapsulate logic for test execution on dedicated threads, with methods for thread configuration, cleanup, initialization, and asynchronous execution. CultureExecutor configures thread culture before test execution. These classes are used to manage thread-specific execution environments in parallel or culture-sensitive TUnit test scenarios.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\npublic class CultureExecutor : TUnit.Core.DedicatedThreadExecutor\n{\n    public CultureExecutor(System.Globalization.CultureInfo cultureInfo) { }\n    protected override void ConfigureThread(System.Threading.Thread thread) { }\n}\npublic class DedicatedThreadExecutor : TUnit.Core.GenericAbstractExecutor\n{\n    public DedicatedThreadExecutor() { }\n    protected virtual void CleanUp() { }\n    protected virtual void ConfigureThread(System.Threading.Thread thread) { }\n    protected override sealed System.Threading.Tasks.ValueTask ExecuteAsync(System.Func<System.Threading.Tasks.ValueTask> action) { }\n    protected virtual void Initialize() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Context Management Classes\nDESCRIPTION: Classes for managing test context including class hooks and execution context. Provides functionality for output capture and logging.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class ClassHookContext : TUnit.Core.Context\n{\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Type ClassType { get; init; }\n    public int TestCount { get; }\n    public System.Collections.Generic.List<TUnit.Core.TestContext> Tests { get; init; }\n    public new static TUnit.Core.ClassHookContext? Current { get; }\n    public override bool Equals(object? obj) { }\n    public override int GetHashCode() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Satisfies Extensions for TUnit\nDESCRIPTION: Extension methods for collection satisfaction testing and value mapping assertions. Includes support for both synchronous and asynchronous mapping operations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_121\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.CollectionWrapper<TInner> All<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> Satisfies<TActual, TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Func<TActual, System.Threading.Tasks.Task<TExpected>?> asyncMapper, System.Func<TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TExpected?>, TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TExpected?>> assert, [System.Runtime.CompilerServices.CallerArgumentExpression(\"asyncMapper\")] string mapperExpression = \"\", [System.Runtime.CompilerServices.CallerArgumentExpression(\"assert\")] string assertionBuilderExpression = \"\") { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> Satisfies<TActual, TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Func<TActual, TExpected> mapper, System.Func<TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TExpected?>, TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TExpected?>> assert, [System.Runtime.CompilerServices.CallerArgumentExpression(\"mapper\")] string mapperExpression = \"\", [System.Runtime.CompilerServices.CallerArgumentExpression(\"assert\")] string assertionBuilderExpression = \"\") { }\n```\n\n----------------------------------------\n\nTITLE: Generating Matrix Test Metadata with Exclusions\nDESCRIPTION: This snippet sets up test metadata generation for a method named 'Exclusion' in MatrixTests class. It includes matrix data source attributes and exclusion attributes for specific test cases.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MatrixTests.Test.verified.txt#2025-04-22_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.MatrixTests),\n\tName = \"Exclusion\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute(),\n\t\tnew global::TUnit.Core.MatrixDataSourceAttribute(),\n\t\tnew global::TUnit.Core.MatrixExclusionAttribute(1, 1),\n\t\tnew global::TUnit.Core.MatrixExclusionAttribute(2, 2),\n\t\tnew global::TUnit.Core.MatrixExclusionAttribute(3, 3)\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t{\n\t\t\tName = \"item\",\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.MatrixMethodAttribute<global::TUnit.TestProject.MatrixTests>(\"EnumerableMethod\")\n\t\t\t],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t{\n\t\t\tName = \"item2\",\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.MatrixMethodAttribute<global::TUnit.TestProject.MatrixTests>(\"EnumerableMethod\")\n\t\t\t],\n\t\t},\n\t],\n\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.MatrixTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t{\n\t\tType = typeof(global::TUnit.TestProject.MatrixTests),\n\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"MatrixTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t{\n\t\t\tName = \"MatrixTests\",\n\t\t\tAttributes = [],\n\t\t}),\n\t\tName = \"MatrixTests\",\n\t\tNamespace = \"TUnit.TestProject\",\n\t\tAttributes = [],\n\t\tParameters = [],\n\t\tProperties = [],\n\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing DelegateConversionAssertionCondition in C#\nDESCRIPTION: A class that handles converting delegates to exceptions for assertion testing. This enables testing of exceptions thrown by delegates or async operations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_113\n\nLANGUAGE: C#\nCODE:\n```\npublic class DelegateConversionAssertionCondition<TToType> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TToType>\n    where TToType : System.Exception\n{\n    public DelegateConversionAssertionCondition(TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource source, TUnit.Assertions.AssertConditions.BaseAssertCondition<object?> assertCondition) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TToType? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering TUnit AfterEveryTest Hook Source (GlobalBase2) in C#\nDESCRIPTION: This auto-generated C# code defines a partial class `Hooks_GlobalBase2` implementing `ITestHookSource`. It registers itself using a `ModuleInitializer` with `SourceRegistrar`. The `CollectAfterEveryTestHooks` method provides metadata for the static `AfterAll2` method from `TUnit.TestProject.AfterTests.GlobalBase2` as an `AfterTestHookMethod`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticAfterEachTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_GlobalBase2 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_GlobalBase2();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.AfterTestHookMethod\n\t\t\t{ \n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.GlobalBase2),\n\t\t\t\tName = \"AfterAll2\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterEveryAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"context\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.GlobalBase2\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.GlobalBase2),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"GlobalStaticAfterEachTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"GlobalStaticAfterEachTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"GlobalBase2\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.GlobalBase2.AfterAll2(context)),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tFilePath = @\"\",\n\t\t\t\tLineNumber = 20,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterEveryAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\tAssemblyAttributes = [],\n\t\t\t},\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Extension Method to Retrieve Test ID in TUnit (C#)\nDESCRIPTION: Provides a static extension method `GetTestId` for the `TestContext` class. This method simplifies retrieving the unique test identifier previously stored in the `ObjectBag` by the `AssignTestIdentifiersAttribute`, using the predefined `TestIdObjectBagKey`. It casts the retrieved object back to an integer.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/examples/instrumenting_global_test_ids.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstatic class TestContextExtensions\n{\n    public static int GetTestId(this TestContext? testContext)\n    {\n        // Retrieve the test identifier from the ObjectBag\n        return (int)testContext!.ObjectBag[AssignTestIdentifiersAttribute.TestIdObjectBagKey]!;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Registering TUnit Source Generator with ModuleInitializer - C#\nDESCRIPTION: This C# snippet defines a partial class that implements the ITestSource interface for TUnit.SourceGenerated. It uses a static ModuleInitializer method to register the test source generator and provides a CollectTests method that aggregates test lists from multiple methods. This is central to enabling automated discovery and registration of source-generated unit tests. The dependencies are TUnit.Core, TUnit.Core.Interfaces.SourceGenerator.ITestSource, and a compatible C# project setup.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class MethodDataSourceDrivenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new MethodDataSourceDrivenTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\t..Tests0(sessionId),\n\t\t\t..Tests1(sessionId),\n\t\t\t..Tests2(sessionId),\n\t\t\t..Tests3(sessionId),\n\t\t];\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{ ... }\n```\n\n----------------------------------------\n\nTITLE: Setting AsyncLocal Values in TUnit Hooks - C#\nDESCRIPTION: Illustrates setting AsyncLocal values within hooks using TUnits [BeforeEvery] attribute. By calling context.AddAsyncLocalValues(), values are propagated into the testing framework. This ensures proper state management across asynchronous test phases. Context must be passed to access and update AsyncLocal values.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/setup.md#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n    [BeforeEvery(Class)]\n    public static void BeforeClass(ClassHookContext context)\n    {\n        _myAsyncLocal.Value = \"Some Value\";\n        context.AddAsyncLocalValues();\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Defining ThrowsAsync Assertion for ValueTask (Specific Exception Type) in C#\nDESCRIPTION: This overload of the static `ThrowsAsync` method asserts that awaiting the provided `ValueTask` delegate throws an exception of the specified `System.Type`. It returns a `Task<System.Exception>` containing the caught exception. The `CallerArgumentExpression` captures the source expression.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_23\n\nLANGUAGE: csharp\nCODE:\n```\n        public static System.Threading.Tasks.Task<System.Exception> ThrowsAsync(System.Type type, System.Threading.Tasks.ValueTask @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression(\"delegate\")] string? doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: TestResultJson Class for Test Result Serialization\nDESCRIPTION: JSON model class representing the result of a test execution, including status, timing information, exceptions, and output. This provides a structured format for test result serialization.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class TestResultJson : System.IEquatable<TUnit.Engine.Json.TestResultJson>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public TestResultJson() { }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string ComputerName { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.TimeSpan? Duration { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.DateTimeOffset? End { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Engine.Json.ExceptionJson? Exception { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string? Output { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.DateTimeOffset? Start { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Core.Enums.Status Status { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Hooks Base3\nDESCRIPTION: Defines test-level hooks for Base3 with support for before and after test execution methods and proper attribute handling.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_Base3 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_Base3();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n```\n\n----------------------------------------\n\nTITLE: Defining Test Context Classes in C#\nDESCRIPTION: This snippet defines context classes used during test execution, including assembly-level and before-test contexts.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class AssemblyHookContext : TUnit.Core.Context\n{\n    public System.Collections.Generic.IEnumerable<TUnit.Core.TestContext> AllTests { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Reflection.Assembly Assembly { get; init; }\n    public System.Collections.Generic.HashSet<TUnit.Core.ClassHookContext> TestClasses { get; init; }\n    public int TestCount { get; }\n    public new static TUnit.Core.AssemblyHookContext? Current { get; }\n}\n\npublic class BeforeTestContext\n{\n    public TUnit.Core.TestContext TestContext { get; }\n    public TUnit.Core.TestDetails TestDetails { get; }\n    public void AddAsyncLocalValues() { }\n    public void AddLinkedCancellationToken(System.Threading.CancellationToken cancellationToken) { }\n    public void SetHookExecutor(TUnit.Core.Interfaces.IHookExecutor hookExecutor) { }\n    public void SetTestExecutor(TUnit.Core.Interfaces.ITestExecutor testExecutor) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic ThrowsAsync Assertion for ValueTask in C#\nDESCRIPTION: This generic overload of `ThrowsAsync` asserts that awaiting the provided `ValueTask` delegate throws an exception of type `TException`. It returns a `Task<TException>` containing the strongly-typed caught exception. The `CallerArgumentExpression` captures the source expression.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_26\n\nLANGUAGE: csharp\nCODE:\n```\n        public static System.Threading.Tasks.Task<TException> ThrowsAsync<TException>(System.Threading.Tasks.ValueTask @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression(\"delegate\")] string? doNotPopulateThisValue = null)\n            where TException : System.Exception { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing InvokableAssertionBuilder Class in C#\nDESCRIPTION: Defines a generic class for building invokable assertions. Implements IInvokableAssertionBuilder interface and provides methods for getting assertion results and awaiter.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_78\n\nLANGUAGE: C#\nCODE:\n```\npublic class InvokableAssertionBuilder<TActual> : TUnit.Assertions.AssertionBuilders.AssertionBuilder, TUnit.Assertions.AssertConditions.Interfaces.ISource, TUnit.Assertions.AssertionBuilders.IInvokableAssertionBuilder\n{\n    protected System.Collections.Generic.Stack<TUnit.Assertions.AssertConditions.BaseAssertCondition> Assertions { get; }\n    public System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<TUnit.Assertions.AssertConditions.AssertionResult>> GetAssertionResults() { }\n    public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TestContext Extensions for Enhanced Test Functionality\nDESCRIPTION: Extension methods for the TestContext class that provide additional functionality for test discovery, dynamic test creation, and metadata access. These extensions help with retrieving test information and managing test relationships.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\npublic static class TestContextExtensions\n    {\n        [System.Diagnostics.CodeAnalysis.Experimental(\"WIP\")]\n        public static System.Threading.Tasks.Task AddDynamicTest<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicParameterlessConstructor | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]  T>(this TUnit.Core.TestContext testContext, TUnit.Core.DynamicTest<T> dynamicTest)\n            where T :  class { }\n        public static string GetClassTypeName(this TUnit.Core.TestContext testContext) { }\n        public static string GetTestDisplayName(this TUnit.Core.TestContext testContext) { }\n        public static TUnit.Core.TestContext[] GetTests(this TUnit.Core.TestContext context, string testName) { }\n        public static TUnit.Core.TestContext[] GetTests(this TUnit.Core.TestContext context, string testName, System.Type[] parameterTypes) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Run On Discovery Attribute in C#\nDESCRIPTION: Defines an attribute that triggers test execution during the discovery phase. This can be useful for validating test setup or for generating data needed by other tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\npublic class RunOnDiscoveryAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver\n{\n    public RunOnDiscoveryAttribute() { }\n    public int Order { get; }\n    public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTimeOffset Assertion Methods in C#\nDESCRIPTION: Extension methods for DateTimeOffset assertions in the TUnit framework. These methods provide temporal comparison capabilities for DateTimeOffset values, including before/after assertions with timezone support.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_135\n\nLANGUAGE: C#\nCODE:\n```\npublic static class DateTimeOffsetIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTimeOffset> IsAfter(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTimeOffset> valueSource, System.DateTimeOffset expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTimeOffset> IsAfterOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTimeOffset> valueSource, System.DateTimeOffset expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTimeOffset> IsBefore(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTimeOffset> valueSource, System.DateTimeOffset expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTimeOffset> IsBeforeOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTimeOffset> valueSource, System.DateTimeOffset expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing TUnit Test with Argument Display Formatter\nDESCRIPTION: Example of a test method using the ArgumentDisplayFormatter attribute to customize how test arguments appear in the test explorer. Uses MethodDataSource for data-driven testing.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/argument-formatters.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n    [Test]\n    [MethodDataSource(nameof(SomeMethod))]\n    [ArgumentDisplayFormatter<SomeClassFormatter>]\n    public async Task Test(SomeClass)\n    {\n        await Assert.That(TestContext.Current!.GetTestDisplayName()).IsEqualTo(\"A super important test!\");\n    }\n```\n\n----------------------------------------\n\nTITLE: Basic DisplayName Attribute Usage in CSharp Tests\nDESCRIPTION: Shows how to set a custom display name for a test method using the DisplayName attribute. This provides basic test name customization.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/display-names.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n    [Test]\n    [DisplayName(\"My first test!\")]\n    public async Task Test()\n    {\n        ...\n    }\n```\n\n----------------------------------------\n\nTITLE: Initializing Test Registration for TimeoutCancellationTokenTests in TUnit\nDESCRIPTION: Auto-generated code that handles the registration of the DefaultTest method from TimeoutCancellationTokenTests with the TUnit testing framework. It includes methods for test initialization, metadata collection, and proper error handling.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/TimeoutCancellationTokenTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tglobal::TUnit.Core.SourceRegistrar.Register(new TimeoutCancellationTokenTests());\n}\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn Tests0(sessionId);\n}\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.TimeoutCancellationTokenTests),\n\t\t\tName = \"DefaultTest\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute()\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t{\n\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.TimeoutCancellationTokenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.TimeoutCancellationTokenTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"TimeoutCancellationTokenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"TimeoutCancellationTokenTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"TimeoutCancellationTokenTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"DataSource\"),\n\t\t\t\t\tnew global::TUnit.Core.CategoryAttribute(\"Timeout Cancellation Token Tests\")\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\tglobal::TUnit.TestProject.TimeoutCancellationTokenTests? classInstance = null;\n\t\tobject?[]? classInstanceArguments = null;\n\t\tint classArg = global::TUnit.TestProject.TimeoutCancellationTokenTests.DataSource();\n\t\tclassInstanceArguments = [classArg];\n\n\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.TimeoutCancellationTokenTests>(() => \n\t\tnew global::TUnit.TestProject.TimeoutCancellationTokenTests(classArg)\n\t\t, sessionId, testBuilderContext);\n\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.TimeoutCancellationTokenTests>\n\t\t{\n\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS0:TUnit.TestProject.TimeoutCancellationTokenTests(int).DefaultTest(System.Threading.CancellationToken):0\",\n\t\t\tTestClassArguments = [classArg],\n\t\t\tTestMethodArguments = [],\n\t\t\tTestClassProperties = [],\n\t\t\tCurrentRepeatAttempt = 0,\n\t\t\tRepeatLimit = 0,\n\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DefaultTest(cancellationToken)),\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 15,\n\t\t\tTestMethod = testInformation,\n\t\t\tTestBuilderContext = testBuilderContext,\n\t\t});\n\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\ttestBuilderContext = new();\n\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t}\n\tcatch (global::System.Exception exception)\n\t{\n\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.TimeoutCancellationTokenTests>\n\t\t{\n\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS0:TUnit.TestProject.TimeoutCancellationTokenTests(int).DefaultTest(System.Threading.CancellationToken):0\",\n\t\t\tMethodName = $\"DefaultTest\",\n\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"TimeoutCancellationTokenTests.DefaultTest failed to initialize\", exception),\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 15,\n\t\t});\n\t}\n\treturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DedicatedThreadExecutor Class in C#\nDESCRIPTION: This C# class `DedicatedThreadExecutor` provides a mechanism within TUnit to execute asynchronous actions (`Func<ValueTask>`) on a dedicated background thread. It inherits from `GenericAbstractExecutor` and provides virtual methods for `Initialize`, `ConfigureThread`, and `CleanUp` to allow customization of the thread's lifecycle and configuration before executing the provided action via the sealed `ExecuteAsync` method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n    public class DedicatedThreadExecutor : TUnit.Core.GenericAbstractExecutor\n    {\n        public DedicatedThreadExecutor() { }\n        protected virtual void CleanUp() { }\n        protected virtual void ConfigureThread(System.Threading.Thread thread) { }\n        protected override sealed System.Threading.Tasks.ValueTask ExecuteAsync(System.Func<System.Threading.Tasks.ValueTask> action) { }\n        protected virtual void Initialize() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Collecting and Registering Test Hooks for a Type in TUnit - C#\nDESCRIPTION: Implements a partial class that registers itself as a test hook source and provides collection methods for test-level hooks. Specifically, it returns a 'BeforeEach3' method on AssemblyBase3 as an instance hook, detailed with type, method information, and TUnit attribute annotations. Other hooks return empty lists. The code relies on TUnit source generator infrastructure and must be integrated into the assembly registration process.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyBeforeTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_AssemblyBase3 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_AssemblyBase3();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.BeforeTests.AssemblyBase3),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.AssemblyBase3),\n\t\t\t\t\tName = \"BeforeEach3\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.AssemblyBase3\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.AssemblyBase3),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AssemblyBeforeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"AssemblyBeforeTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"AssemblyBase3\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.BeforeTests.AssemblyBase3)classInstance).BeforeEach3()),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t},\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing EnumDoesNotHaveSameValueAsCondition in C#\nDESCRIPTION: Assertion condition that checks if an enum value does not have the same underlying value as a specified enum value, even from a different enum type.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_102\n\nLANGUAGE: C#\nCODE:\n```\n    public class EnumDoesNotHaveSameValueAsCondition<TEnum, TExpected> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TEnum>\n        where TEnum : System.Enum\n        where TExpected : System.Enum\n    {\n        public EnumDoesNotHaveSameValueAsCondition(TExpected expected) { }\n        protected override string GetExpectation() { }\n        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TEnum? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Configuring .csproj for TUnit Test Project - XML\nDESCRIPTION: This XML snippet provides an example .csproj file configured for a TUnit test project. It sets fundamental .NET project properties (output type, target framework, implicit usings, nullability) and declares a PackageReference for TUnit. Replace $(TUnitVersion) with the required version string. No other testing SDK package (like Microsoft.NET.Test.Sdk) should be referenced to avoid conflicts.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/installing.md#2025-04-22_snippet_2\n\nLANGUAGE: xml\nCODE:\n```\n<Project Sdk=\\\"Microsoft.NET.Sdk\\\">\n\n    <PropertyGroup>\n        <OutputType>Exe</OutputType>\n        <TargetFramework>net8.0</TargetFramework>\n        <ImplicitUsings>enable</ImplicitUsings>\n        <Nullable>enable</Nullable>\n    </PropertyGroup>\n\n    <ItemGroup>\n      <PackageReference Include=\\\"TUnit\\\" Version=\\\"$(TUnitVersion)\\\" />\n    </ItemGroup>\n\n</Project>\n```\n\n----------------------------------------\n\nTITLE: Implementing ThrowsOfTypeAssertCondition Class in C#\nDESCRIPTION: Defines an assertion condition to check if an exception of a specific type is thrown. Inherits from DelegateAssertCondition.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_73\n\nLANGUAGE: C#\nCODE:\n```\npublic class ThrowsOfTypeAssertCondition<TActual, TExpectedException> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<TActual, System.Exception>\n{\n    public ThrowsOfTypeAssertCondition() { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic TestMetadata<T> Class in C# for TUnit Framework\nDESCRIPTION: This class extends TestMetadata to provide a generic implementation for specific test class types. It includes a resettable class factory and a test method factory.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_47\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class TestMetadata<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]  TClassType> : TUnit.Core.TestMetadata, System.IEquatable<TUnit.Core.TestMetadata<TClassType>>\n    where TClassType :  class\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public TestMetadata() { }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Core.ResettableLazy<TClassType> ResettableClassFactory { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Func<TClassType, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask> TestMethodFactory { get; init; }\n    public override TUnit.Core.TestDetails BuildTestDetails() { }\n    public override TUnit.Core.TestMetadata CloneWithNewMethodFactory(System.Func<object, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask> testMethodFactory) { }\n}\n```\n\n----------------------------------------\n\nTITLE: DateTimeOffset Comparison Extension Methods in C#\nDESCRIPTION: Extension methods for comparing DateTimeOffset values in test assertions. Provides methods to check if a value is before or equal to an expected value, or exactly equal to an expected value.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_56\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTimeOffset> IsBeforeOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTimeOffset> valueSource, System.DateTimeOffset expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\npublic static TUnit.Assertions.AssertionBuilders.Wrappers.DateTimeOffsetEqualToAssertionBuilderWrapper IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTimeOffset> valueSource, System.DateTimeOffset expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null) { }\n```\n\n----------------------------------------\n\nTITLE: Generating Matrix Test Metadata for Method2 Using MatrixDataSourceAttribute - C#\nDESCRIPTION: This code generates and collects test metadata for the Method2 method in MatrixTests using TUnit's MatrixDataSourceAttribute. It creates a TestBuilderContext, produces test parameter permutations via a method attribute (ArrayMethod), and wraps each in a node with appropriate initialization and error-handling logic. Required dependencies are TUnit.Core, source generation patterns, and correct implementation of user-supplied matrix methods; input is the session identifier, and outputs are detailed TestMetadata objects, each representing a distinct test case variant.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MatrixTests.Test.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\\n{\\n\\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\\n\\tvar classDataIndex = 0;\\n\\tvar testMethodDataIndex = 0;\\n\\ttry\\n\\t{\\n\\t\\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\\n\\t\\t{\\n\\t\\t\\tType = typeof(global::TUnit.TestProject.MatrixTests),\\n\\t\\t\\tName = \"Method2\",\\n\\t\\t\\tGenericTypeCount = 0,\\n\\t\\t\\tReturnType = typeof(global::System.Threading.Tasks.Task),\\n\\t\\t\\tAttributes = \\n\\t\\t\\t[\\n\\t\\t\\t\\tnew global::TUnit.Core.TestAttribute(),\\n\\t\\t\\t\\tnew global::TUnit.Core.MatrixDataSourceAttribute()\\n\\t\\t\\t],\\n\\t\\t\\tParameters = \\n\\t\\t\\t[\\n\\t\\t\\t\\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tName = \"item\",\\n\\t\\t\\t\\t\\tAttributes = \\n\\t\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\t\\tnew global::TUnit.Core.MatrixMethodAttribute<global::TUnit.TestProject.MatrixTests>(\"ArrayMethod\")\\n\\t\\t\\t\\t\\t],\\n\\t\\t\\t\\t},\\n\\t\\t\\t],\\n\\t\\t\\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.MatrixTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\\n\\t\\t\\t{\\n\\t\\t\\t\\tType = typeof(global::TUnit.TestProject.MatrixTests),\\n\\t\\t\\t\\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"MatrixTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tName = \"MatrixTests\",\\n\\t\\t\\t\\t\\tAttributes = [],\\n\\t\\t\\t\\t}),\\n\\t\\t\\t\\tName = \"MatrixTests\",\\n\\t\\t\\t\\tNamespace = \"TUnit.TestProject\",\\n\\t\\t\\t\\tAttributes = [],\\n\\t\\t\\t\\tParameters = [],\\n\\t\\t\\t\\tProperties = [],\\n\\t\\t\\t}),\\n};\\n\\n\\t\\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\\n\\t\\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\\n\\t\\tglobal::TUnit.TestProject.MatrixTests? classInstance = null;\\n\\t\\tobject?[]? classInstanceArguments = null;\\n\\t\\tvar methodArgDataGeneratorMetadata = new DataGeneratorMetadata\\n\\t\\t{\\n\\t\\t\\tType = global::TUnit.Core.Enums.DataGeneratorType.TestParameters,\\n\\t\\t\\tTestBuilderContext = testBuilderContextAccessor,\\n\\t\\t\\tTestInformation = testInformation,\\n\\t\\t\\tMembersToGenerate = \\n\\t\\t\\t[\\n\\t\\t\\t\\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tName = \"item\",\\n\\t\\t\\t\\t\\tAttributes = \\n\\t\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\t\\tnew global::TUnit.Core.MatrixMethodAttribute<global::TUnit.TestProject.MatrixTests>(\"ArrayMethod\")\\n\\t\\t\\t\\t\\t],\\n\\t\\t\\t\\t},\\n\\t\\t\\t],\\n\\t\\t\\tTestSessionId = sessionId,\\n\\t\\t\\tTestClassInstance = classInstance,\\n\\t\\t\\tClassInstanceArguments = classInstanceArguments,\\n\\t\\t};\\n\\t\\tvar methodDataAttribute = new global::TUnit.Core.MatrixDataSourceAttribute();\\n\\n\\t\\ttestBuilderContext.DataAttributes.Add(methodDataAttribute);\\n\\n\\t\\tvar methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\\n\\n\\t\\tforeach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\\n\\t\\t{\\n\\t\\t\\ttestMethodDataIndex++;\\n\\t\\t\\tclassInstanceArguments = [];\\n\\n\\t\\t\\tvar methodArgGeneratedData = methodArgGeneratedDataAccessor();\\n\\t\\t\\tint methodArg = global::TUnit.Core.Helpers.CastHelper.Cast<int>(methodArgGeneratedData[0]);\\n\\t\\t\\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.MatrixTests>(() => \\n\\t\\t\\tnew global::TUnit.TestProject.MatrixTests()\\n\\t\\t\\t, sessionId, testBuilderContext);\\n\\t\\t\\tvar resettableClassFactory = resettableClassFactoryDelegate();\\n\\n\\t\\t\\tnodes.Add(new TestMetadata<global::TUnit.TestProject.MatrixTests>\\n\\t\\t\\t{\\n\\t\\t\\t\\tTestId = $\"global::TUnit.Core.MatrixDataSourceAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.MatrixTests.Method2(int):0\",\\n\\t\\t\\t\\tTestClassArguments = [],\\n\\t\\t\\t\\tTestMethodArguments = [methodArg],\\n\\t\\t\\t\\tTestClassProperties = [],\\n\\t\\t\\t\\tCurrentRepeatAttempt = 0,\\n\\t\\t\\t\\tRepeatLimit = 0,\\n\\t\\t\\t\\tResettableClassFactory = resettableClassFactory,\\n\\t\\t\\t\\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Method2(methodArg)),\\n\\t\\t\\t\\tTestFilePath = @\"\",\\n\\t\\t\\t\\tTestLineNumber = 125,\\n\\t\\t\\t\\tTestMethod = testInformation,\\n\\t\\t\\t\\tTestBuilderContext = testBuilderContext,\\n\\t\\t\\t});\\n\\t\\t\\tresettableClassFactory = resettableClassFactoryDelegate();\\n\\t\\t\\ttestBuilderContext = new();\\n\\t\\t\\ttestBuilderContextAccessor.Current = testBuilderContext;\\n\\t\\t}\\n\\t}\\n\\tcatch (global::System.Exception exception)\\n\\t{\\n\\t\\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.MatrixTests>\\n\\t\\t{\\n\\t\\t\\tTestId = $\"global::TUnit.Core.MatrixDataSourceAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.MatrixTests.Method2(int):0\",\\n\\t\\t\\tMethodName = $\"Method2\",\\n\\t\\t\\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"MatrixTests.Method2 failed to initialize\", exception),\\n\\t\\t\\tTestFilePath = @\"\",\\n\\t\\t\\tTestLineNumber = 125,\\n\\t\\t});\\n\\t}\\n\\treturn nodes;\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining That Assertion for Action Delegate in C#\nDESCRIPTION: This overload of the static `That` method in the `Assert` class accepts a `System.Action` delegate. It returns a `DelegateAssertionBuilder` to allow chaining further assertion conditions on the execution of the action. The `CallerArgumentExpression` attribute captures the source code expression passed as the `value` argument for improved error messages.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n        public static TUnit.Assertions.AssertionBuilders.DelegateAssertionBuilder That(System.Action value, [System.Runtime.CompilerServices.CallerArgumentExpression(\"value\")] string? doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Defining Test Dependencies with Parameters using TUnit [DependsOn] in C#\nDESCRIPTION: Demonstrates how to make `Test2` dependent on `Test1` using the `[DependsOn]` attribute in TUnit. It shows the use of `nameof` to reference the target test method and specifies the parameter types (`string`, `int`) of the depended-on test `Test1`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/depends-on.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic void Test1(string value1, int value2) { ... }\n\n[DependsOn(nameof(Test1), [typeof(string), typeof(int)])]\npublic void Test2() { ... }\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTimeOffset Assertion Extensions in TUnit (C#)\nDESCRIPTION: Extension methods for DateTimeOffset type providing temporal assertions with timezone awareness. Includes methods for temporal ordering checks like IsAfter and IsBefore.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_55\n\nLANGUAGE: C#\nCODE:\n```\npublic static class DateTimeOffsetIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTimeOffset> IsAfter(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTimeOffset> valueSource, System.DateTimeOffset expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTimeOffset> IsAfterOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTimeOffset> valueSource, System.DateTimeOffset expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTimeOffset> IsBefore(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTimeOffset> valueSource, System.DateTimeOffset expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract DynamicTest Class in C#\nDESCRIPTION: This abstract C# class `DynamicTest` appears to be a base class for representing dynamically generated tests within the TUnit framework. It implements `IEquatable<DynamicTest>` for comparison. It includes an `Attributes` property (initialized via an init accessor) to associate attributes with the dynamic test.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\n    public abstract class DynamicTest : System.IEquatable<TUnit.Core.DynamicTest>\n    {\n        [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n            \"your compiler.\", true)]\n        protected DynamicTest() { }\n        public System.Attribute[] Attributes { get; init; }\n    }\n```\n\n----------------------------------------\n\nTITLE: Collecting Parameterized Tests for TUnit Source Generation in C#\nDESCRIPTION: This code provides the entry point for collecting test metadata through the TUnit Core interface. The CollectTests method returns a list of TestMetadata objects for a given session. The main collection logic delegates to the Tests0 helper function, describing the test cases and their argument variations for the CustomDisplayNameTests class.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/CustomDisplayNameTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn Tests0(sessionId);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Type Assertion Extensions in C#\nDESCRIPTION: Defines extension methods for generic type assertions, including type checking, equality comparisons, and reference comparisons.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_66\n\nLANGUAGE: C#\nCODE:\n```\npublic static class GenericIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsAssignableFrom(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource, System.Type type) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsAssignableFrom<TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsAssignableTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource, System.Type type) { }\n    public static TUnit.Assertions.AssertionBuilders.CastedAssertionBuilder<object, TExpected> IsAssignableTo<TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.GenericEqualToAssertionBuilderWrapper<TActual> IsEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null) { }\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.GenericEqualToAssertionBuilderWrapper<TActual> IsEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, System.Collections.Generic.IEqualityComparer<TActual> equalityComparer, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsEquatableOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null) { }\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.EquivalentToAssertionBuilderWrapper<TActual, TExpected> IsEquivalentTo<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TActual, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TExpected expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsNotAssignableFrom(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource, System.Type type) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsNotAssignableFrom<TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsNotAssignableTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource, System.Type type) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsNotAssignableTo<TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsNotTypeOf(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource, System.Type type) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsNotTypeOf<TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNull<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsSameReferenceAs<TActual, TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TExpected expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsTypeOf(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource, System.Type type) { }\n    public static TUnit.Assertions.AssertionBuilders.CastedAssertionBuilder<object, TExpected> IsTypeOf<TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Matrix Method Attribute in C#\nDESCRIPTION: Defines a base attribute for generating test parameters from methods. It gets objects from a specified method in a class and provides them as test parameters.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Parameter)]\npublic class MatrixMethodAttribute<TClass> : TUnit.Core.MatrixAttribute\n    where TClass :  class\n{\n    public MatrixMethodAttribute(string methodName) { }\n    public override object?[] GetObjects(object? instance) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Collecting Tests in TUnit C#\nDESCRIPTION: This snippet defines a partial class implementing the ITestSource interface from the TUnit framework. It contains functions to initialize tests and collect test data using different string arguments. Dependencies include TUnit.Core and System namespaces.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/StringArgumentTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class StringArgumentTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n    [global::System.Runtime.CompilerServices.ModuleInitializer]\n    public static void Initialise()\n    {\n        global::TUnit.Core.SourceRegistrar.Register(new StringArgumentTests());\n    }\n    public global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n    {\n        return\n        [\n            ..Tests0(sessionId),\n            ..Tests1(sessionId),\n            ..Tests2(sessionId),\n            ..Tests3(sessionId),\n            ..Tests4(sessionId),\n            ..Tests5(sessionId),\n            ..Tests6(sessionId),\n            ..Tests7(sessionId),\n        ];\n    }\n    private global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n    {\n        global::System.Collections.Generic.List<TestMetadata> nodes = [];\n        var classDataIndex = 0;\n        var testMethodDataIndex = 0;\n        try\n        {\n            var testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n            {\n                Type = typeof(global::TUnit.TestProject.StringArgumentTests),\n                Name = \"Normal\",\n                GenericTypeCount = 0,\n                ReturnType = typeof(void),\n                Attributes = \n                [\n                    new global::TUnit.Core.TestAttribute(),\n                    new global::TUnit.Core.ArgumentsAttribute(\"\"),\n                    new global::TUnit.Core.ArgumentsAttribute(@\"\\\"),\n                    new global::TUnit.Core.ArgumentsAttribute(@\"\\t\"),\n                    new global::TUnit.Core.ArgumentsAttribute(\"\\t\"),\n                    new global::TUnit.Core.ArgumentsAttribute(\"\\\\t\"),\n                    new global::TUnit.Core.ArgumentsAttribute(\"\\\\t\"),\n                    new global::TUnit.Core.ArgumentsAttribute(@\"         \"\"\"\n        Hello\n        World\n        \"\"\")\n                ],\n                Parameters = \n                [\n                    new global::TUnit.Core.SourceGeneratedParameterInformation<string>\n                    {\n                        Name = \"s\",\n                        Attributes = [],\n                    },\n                ],\n                Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.StringArgumentTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n                {\n                    Type = typeof(global::TUnit.TestProject.StringArgumentTests),\n                    Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"StringArgumentTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n                    {\n                        Name = \"StringArgumentTests\",\n                        Attributes = [],\n                    }),\n                    Name = \"StringArgumentTests\",\n                    Namespace = \"TUnit.TestProject\",\n                    Attributes = [],\n                    Parameters = [],\n                    Properties = [],\n                }),\n};\n\n                var testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n                var testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n                global::TUnit.TestProject.StringArgumentTests? classInstance = null;\n                object?[]? classInstanceArguments = null;\n                classInstanceArguments = [];\n\n                string methodArg = \"\";\n\n                var resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.StringArgumentTests>(() => \n                new global::TUnit.TestProject.StringArgumentTests()\n                , sessionId, testBuilderContext);\n                var resettableClassFactory = resettableClassFactoryDelegate();\n\n\n                nodes.Add(new TestMetadata<global::TUnit.TestProject.StringArgumentTests>\n                {\n                    TestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.StringArgumentTests.Normal(string):0\",\n                    TestClassArguments = [],\n                    TestMethodArguments = [methodArg],\n                    TestClassProperties = [],\n                    CurrentRepeatAttempt = 0,\n                    RepeatLimit = 0,\n                    ResettableClassFactory = resettableClassFactory,\n                    TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Normal(methodArg)),\n                    TestFilePath = @\"\",\n                    TestLineNumber = 5,\n                    TestMethod = testInformation,\n                    TestBuilderContext = testBuilderContext,\n                });\n                resettableClassFactory = resettableClassFactoryDelegate();\n                testBuilderContext = new();\n                testBuilderContextAccessor.Current = testBuilderContext;\n            }\n            catch (global::System.Exception exception)\n            {\n                nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.StringArgumentTests>\n                {\n                    TestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.StringArgumentTests.Normal(string):0\",\n                    MethodName = $\"Normal\",\n                    Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"StringArgumentTests.Normal failed to initialize\", exception),\n                    TestFilePath = @\"\",\n                    TestLineNumber = 5,\n                });\n            }\n            return nodes;\n        }\n```\n\n----------------------------------------\n\nTITLE: Implementing Class Data Source Driven Tests with TUnit in C#\nDESCRIPTION: This C# snippet defines a source-generated, partial class for data-driven testing using TUnit. It uses a module initializer to register the test source and generates test metadata for class data sources. It requires the TUnit framework and related core libraries as dependencies and takes a sessionId to collect relevant test cases. Key parameters include test method names, test data generators, and test parameter instances; outputs are lists of test metadata objects suitable for automated test discovery. Exception handling ensures test failures during metadata initialization are registered.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\n// <auto-generated/>\\n#pragma warning disable\\nusing global::System.Linq;\\nusing global::System.Reflection;\\nusing global::TUnit.Core;\\nusing global::TUnit.Core.Extensions;\\n\\nnamespace TUnit.SourceGenerated;\\n\\n[global::System.Diagnostics.StackTraceHidden]\\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\\nfile partial class ClassDataSourceDrivenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\\n{\\n\\t[global::System.Runtime.CompilerServices.ModuleInitializer]\\n\\tpublic static void Initialise()\\n\\t{\\n\\t\\tglobal::TUnit.Core.SourceRegistrar.Register(new ClassDataSourceDrivenTests());\\n\\t}\\n\\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\\n\\t{\\n\\t\\treturn Tests0(sessionId);\\n\\t}\\n\\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\\n\\t{\\n\\t\\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\\n\\t\\tvar classDataIndex = 0;\\n\\t\\tvar testMethodDataIndex = 0;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\\n\\t\\t\\t{\\n\\t\\t\\t\\tType = typeof(global::TUnit.TestProject.ClassDataSourceDrivenTests),\\n\\t\\t\\t\\tName = \\\"DataSource_Class\\\",\\n\\t\\t\\t\\tGenericTypeCount = 0,\\n\\t\\t\\t\\tReturnType = typeof(void),\\n\\t\\t\\t\\tAttributes = \\n\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\tnew global::TUnit.Core.TestAttribute()\\n\\t\\t\\t\\t],\\n\\t\\t\\t\\tParameters = \\n\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.Dummy.SomeAsyncDisposableClass>\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tName = \\\"value\\\",\\n\\t\\t\\t\\t\\t\\tAttributes = [],\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t],\\n\\t\\t\\t\\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\\\"global::TUnit.TestProject.ClassDataSourceDrivenTests\\\", () => new global::TUnit.Core.SourceGeneratedClassInformation\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tType = typeof(global::TUnit.TestProject.ClassDataSourceDrivenTests),\\n\\t\\t\\t\\t\\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\\\"ClassDataSourceDrivenTests\\\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tName = \\\"ClassDataSourceDrivenTests\\\",\\n\\t\\t\\t\\t\\t\\tAttributes = [],\\n\\t\\t\\t\\t\\t}),\\n\\t\\t\\t\\t\\tName = \\\"ClassDataSourceDrivenTests\\\",\\n\\t\\t\\t\\t\\tNamespace = \\\"TUnit.TestProject\\\",\\n\\t\\t\\t\\t\\tAttributes = [],\\n\\t\\t\\t\\t\\tParameters = [],\\n\\t\\t\\t\\t\\tProperties = [],\\n\\t\\t\\t\\t}),\\n};\\n\\n\\t\\t\\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\\n\\t\\t\\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\\n\\t\\t\\tglobal::TUnit.TestProject.ClassDataSourceDrivenTests? classInstance = null;\\n\\t\\t\\tobject?[]? classInstanceArguments = null;\\n\\t\\t\\tvar methodArgDataGeneratorMetadata = new DataGeneratorMetadata\\n\\t\\t\\t{\\n\\t\\t\\t\\tType = global::TUnit.Core.Enums.DataGeneratorType.TestParameters,\\n\\t\\t\\t\\tTestBuilderContext = testBuilderContextAccessor,\\n\\t\\t\\t\\tTestInformation = testInformation,\\n\\t\\t\\t\\tMembersToGenerate = \\n\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.Dummy.SomeAsyncDisposableClass>\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tName = \\\"value\\\",\\n\\t\\t\\t\\t\\t\\tAttributes = [],\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t],\\n\\t\\t\\t\\tTestSessionId = sessionId,\\n\\t\\t\\t\\tTestClassInstance = classInstance,\\n\\t\\t\\t\\tClassInstanceArguments = classInstanceArguments,\\n\\t\\t\\t};\\n\\t\\t\\tvar methodDataAttribute = new global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.Dummy.SomeAsyncDisposableClass>();\\n\\n\\t\\t\\ttestBuilderContext.DataAttributes.Add(methodDataAttribute);\\n\\n\\t\\t\\tvar methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\\n\\n\\t\\t\\tforeach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttestMethodDataIndex++;\\n\\t\\t\\t\\tclassInstanceArguments = [];\\n\\n\\t\\t\\t\\tvar methodArgGeneratedData = methodArgGeneratedDataAccessor();\\n\\t\\t\\t\\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ClassDataSourceDrivenTests>(() => \\n\\t\\t\\t\\tnew global::TUnit.TestProject.ClassDataSourceDrivenTests()\\n\\t\\t\\t\\t, sessionId, testBuilderContext);\\n\\t\\t\\t\\tvar resettableClassFactory = resettableClassFactoryDelegate();\\n\\n\\n\\t\\t\\t\\tnodes.Add(new TestMetadata<global::TUnit.TestProject.ClassDataSourceDrivenTests>\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tTestId = $\\\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.Dummy.SomeAsyncDisposableClass>:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.ClassDataSourceDrivenTests.DataSource_Class(TUnit.TestProject.Dummy.SomeAsyncDisposableClass):0\\\",\\n\\t\\t\\t\\t\\tTestClassArguments = [],\\n\\t\\t\\t\\t\\tTestMethodArguments = [methodArgGeneratedData],\\n\\t\\t\\t\\t\\tTestClassProperties = [],\\n\\t\\t\\t\\t\\tCurrentRepeatAttempt = 0,\\n\\t\\t\\t\\t\\tRepeatLimit = 0,\\n\\t\\t\\t\\t\\tResettableClassFactory = resettableClassFactory,\\n\\t\\t\\t\\t\\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_Class(methodArgGeneratedData)),\\n\\t\\t\\t\\t\\tTestFilePath = @\\\"\\\",\\n\\t\\t\\t\\t\\tTestLineNumber = 10,\\n\\t\\t\\t\\t\\tTestMethod = testInformation,\\n\\t\\t\\t\\t\\tTestBuilderContext = testBuilderContext,\\n\\t\\t\\t\\t});\\n\\t\\t\\t\\tresettableClassFactory = resettableClassFactoryDelegate();\\n\\t\\t\\t\\ttestBuilderContext = new();\\n\\t\\t\\t\\ttestBuilderContextAccessor.Current = testBuilderContext;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcatch (global::System.Exception exception)\\n\\t\\t{\\n\\t\\t\\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ClassDataSourceDrivenTests>\\n\\t\\t\\t{\\n\\t\\t\\t\\tTestId = $\\\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.Dummy.SomeAsyncDisposableClass>:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.ClassDataSourceDrivenTests.DataSource_Class(TUnit.TestProject.Dummy.SomeAsyncDisposableClass):0\\\",\\n\\t\\t\\t\\tMethodName = $\\\"DataSource_Class\\\",\\n\\t\\t\\t\\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\\\"ClassDataSourceDrivenTests.DataSource_Class failed to initialize\\\", exception),\\n\\t\\t\\t\\tTestFilePath = @\\\"\\\",\\n\\t\\t\\t\\tTestLineNumber = 10,\\n\\t\\t\\t});\\n\\t\\t}\\n\\t\\treturn nodes;\\n\\t}\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Hook Methods for Test Lifecycle Events\nDESCRIPTION: Defines various hook method classes that execute at different stages of the test lifecycle including before/after assembly, class, test discovery, test session, and individual tests. Each hook method inherits from StaticHookMethod with specific context types and implements IEquatable.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_60\n\nLANGUAGE: C#\nCODE:\n```\npublic class AfterAssemblyHookMethod : TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.AssemblyHookContext>, System.IEquatable<TUnit.Core.Hooks.AfterAssemblyHookMethod>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public AfterAssemblyHookMethod() { }\n    public override System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.AssemblyHookContext context, System.Threading.CancellationToken cancellationToken) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ComparisonFailure Class in C#\nDESCRIPTION: This class represents a comparison failure, with properties for actual and expected values, nested member names, and member type. It uses RequiredMember attribute and is marked as obsolete.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class ComparisonFailure : System.IEquatable<TUnit.Assertions.ComparisonFailure>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public ComparisonFailure() { }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public object? Actual { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public object? Expected { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string[] NestedMemberNames { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Assertions.MemberType Type { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TUnit BeforeTest Hook Source (Context & CancellationToken Params) in C#\nDESCRIPTION: This auto-generated C# code defines another part of the `Hooks_AssemblySetupTests` partial class, implementing `ITestHookSource`. It registers via `ModuleInitializer` and collects `BeforeTest` hooks. It registers the `SetupWithContext` method (taking `TestContext` and `CancellationToken`) from `TUnit.TestProject.BeforeTests.AssemblySetupTests` as an instance hook, including a `TimeoutAttribute` and providing detailed metadata.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyBeforeTests.Test.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_AssemblySetupTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_AssemblySetupTests();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.BeforeTests.AssemblySetupTests),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.AssemblySetupTests),\n\t\t\t\t\tName = \"SetupWithContext\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test),\n\t\t\t\t\t\tnew global::TUnit.Core.TimeoutAttribute(30_000)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"testContext\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.AssemblySetupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.AssemblySetupTests),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AssemblyBeforeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"AssemblyBeforeTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"AssemblySetupTests\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.BeforeTests.AssemblySetupTests)classInstance).SetupWithContext(context, cancellationToken)),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test),\n\t\t\t\t\t\tnew global::TUnit.Core.TimeoutAttribute(30_000)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\t\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t\t{\n\t\t\treturn\n\t\t\t[\n\t\t\t];\n\t\t}\n\t}\n\n]\n```\n\n----------------------------------------\n\nTITLE: Collection and String Has Extensions for TUnit\nDESCRIPTION: Extension methods for asserting collection properties like count and distinctness, and string properties like length and content matching. Includes specialized handling for ImmutableArray types.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_122\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.Extensions.EnumerableCount<System.Collections.Generic.IEnumerable<TInner>, TInner> HasCount<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }\npublic static TUnit.Assertions.Extensions.EnumerableCount<System.Collections.Immutable.ImmutableArray<TInner>, TInner> HasCount<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> HasCount<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, int count) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> HasDistinctItems<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }\n```\n\n----------------------------------------\n\nTITLE: Defining Core Assertion Builder Classes and Interfaces\nDESCRIPTION: Implements the base assertion builder classes and interfaces that handle various types of assertions including value, delegate, and async operations. Includes support for chaining assertions with And/Or operators.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\npublic class ConvertedValueAssertionBuilder<TFromType, TToType> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TToType>\n{\n    public ConvertedValueAssertionBuilder(TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TFromType> source, TUnit.Assertions.AssertConditions.ConvertToAssertCondition<TFromType, TToType> convertToAssertCondition) { }\n}\n\npublic class DelegateAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder, TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource, TUnit.Assertions.AssertConditions.Interfaces.ISource { }\n\npublic interface IInvokableAssertionBuilder : TUnit.Assertions.AssertConditions.Interfaces.ISource\n{\n    System.Runtime.CompilerServices.TaskAwaiter GetAwaiter();\n    string? GetExpression();\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Source-Generated Test Metadata with TUnit - C#\nDESCRIPTION: This C# snippet demonstrates the instantiation of test metadata for a data-source-driven unit test using the TUnit framework. It constructs data method arguments by invoking a static method, sets up resettable factory delegates for test classes, builds test metadata objects, and properly handles exceptions by logging initialization failures. Dependencies include TUnit.Core and TUnit.TestProject, and parameters such as sessionId. The function outputs a list of TestMetadata objects, each describing a test with context and argument information.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.MethodDataSourceDrivenTests? classInstance = null;\nobject?[]? classInstanceArguments = null;\nclassInstanceArguments = [];\n\nint methodArg = global::TUnit.TestProject.MethodDataSourceDrivenTests.SomeMethod(5 );\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.MethodDataSourceDrivenTests>(() => \nnew global::TUnit.TestProject.MethodDataSourceDrivenTests()\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenTests>\n{\n\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.MethodDataSourceDrivenTests.DataSource_Method3(int):0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [methodArg],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_Method3(methodArg)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 33,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\nresettableClassFactory = resettableClassFactoryDelegate();\ntestBuilderContext = new();\ntestBuilderContextAccessor.Current = testBuilderContext;\n```\n\n----------------------------------------\n\nTITLE: Handling Asynchronous Test Execution and Initialization in TUnit - C#\nDESCRIPTION: This C# snippet handles the asynchronous execution of a test method using ValueTask in the TUnit framework. It sets up test identifiers, manages test execution with factories, and handles exceptions if test initialization fails. Dependencies include the TUnit testing framework and a resettable class instance factory. Inputs include the class instance and cancellation token for the test method factory, while the expected output is a list of test nodes, which includes failed test metadata if any exception occurs.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Dynamic/Basic.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nTestId = $\"TUnit.TestProject.BasicTests.ValueTaskAsynchronousTest:0\",\nTestClassArguments = [],\nTestMethodArguments = [],\nTestClassProperties = [],\nCurrentRepeatAttempt = 0,\nRepeatLimit = 0,\nResettableClassFactory = resettableClassFactory,\nTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.ValueTaskAsynchronousTest()),\nTestFilePath = @\"\",\nTestLineNumber = 17,\nTestMethod = testInformation,\nTestBuilderContext = testBuilderContext,\n});\nresettableClassFactory = resettableClassFactoryDelegate();\ntestBuilderContext = new();\ntestBuilderContextAccessor.Current = testBuilderContext;\n}\ncatch (global::System.Exception exception)\n{\nnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.BasicTests>\n{\nTestId = $\"TUnit.TestProject.BasicTests.ValueTaskAsynchronousTest:0\",\nMethodName = $\"ValueTaskAsynchronousTest\",\nException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"BasicTests.ValueTaskAsynchronousTest failed to initialize\", exception),\nTestFilePath = @\"\",\nTestLineNumber = 17,\n});\n}\nreturn nodes;\n}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TUnit Enumerations for Test Framework\nDESCRIPTION: Core enumeration types used throughout the TUnit framework to represent test statuses, log levels, and data generator types. These enums provide standardized values for classifying test results and configuring framework behavior.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic enum DataGeneratorType\n    {\n        ClassParameters = 0,\n        TestParameters = 1,\n        Property = 2,\n    }\n    public enum LogLevel\n    {\n        None = -1,\n        Trace = 0,\n        Debug = 1,\n        Information = 2,\n        Warning = 3,\n        Error = 4,\n        Critical = 5,\n    }\n    public enum Status\n    {\n        None = 0,\n        Passed = 1,\n        Failed = 2,\n        Skipped = 3,\n        Cancelled = 4,\n    }\n```\n\n----------------------------------------\n\nTITLE: String Length Assertion Class in TUnit\nDESCRIPTION: A class for validating string length with methods for checking equality, greater/less than comparisons, and properties for positive and zero lengths.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_156\n\nLANGUAGE: C#\nCODE:\n```\npublic class StringLength\n{\n    public StringLength(TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> Positive { get; }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> Zero { get; }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> EqualTo(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> GreaterThan(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> GreaterThanOrEqualTo(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> LessThan(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> LessThanOrEqualTo(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing TUnit Test Metadata Generation for Class Data Source Tests in C#\nDESCRIPTION: This C# snippet shows the beginning of an auto-generated partial class `ClassDataSourceDrivenTests` for the TUnit framework. It includes standard using directives, attributes to suppress diagnostics and exclude from code coverage, and the class declaration implementing `ITestSource`. It defines a `ModuleInitializer` to register the test source and the `CollectTests` method signature which delegates to `Tests0`. The `Tests0` method starts defining logic to collect `TestMetadata` for the test method `IsInitialized_With_5_ClassDataSources`, initializing necessary variables and starting a try block to gather test information.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class ClassDataSourceDrivenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new ClassDataSourceDrivenTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.ClassDataSourceDrivenTests),\n\t\t\t\tName = \"IsInitialized_With_5_ClassDataSources\",\n\t\t\t\tGenericTypeCount = 0,\n```\n\n----------------------------------------\n\nTITLE: TUnit Source Generation Class Definition\nDESCRIPTION: Auto-generated class definition for the TUnit testing framework that implements the ITestSource interface. It contains initialization logic, test registration, and methods for collecting tests from various sources.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class DataDrivenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new DataDrivenTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\t..Tests0(sessionId),\n\t\t\t..Tests1(sessionId),\n\t\t\t..Tests2(sessionId),\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Registering TUnit Test Source in C#\nDESCRIPTION: This snippet defines a partial class that implements ITestSource interface. It includes a module initializer to register the test source and a method to collect test metadata.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AbstractTests.Concrete1.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Inherited_ConcreteClass1 : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new Inherited_ConcreteClass1());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Negative Dictionary Assertion Methods for TUnit\nDESCRIPTION: Extension methods for asserting that dictionaries do not contain specific keys or values. Provides methods with support for custom equality comparers.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_63\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TDictionary> DoesNotContainKey<TDictionary, TKey>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TDictionary> valueSource, TKey expected, System.Collections.Generic.IEqualityComparer<TKey> equalityComparer = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n    where TDictionary : System.Collections.IDictionary { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TDictionary> DoesNotContainValue<TDictionary, TValue>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TDictionary> valueSource, TValue expected, System.Collections.Generic.IEqualityComparer<TValue> equalityComparer = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n    where TDictionary : System.Collections.IDictionary { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ITestHookSource for Base3 in C#\nDESCRIPTION: This snippet implements the ITestHookSource interface for the Base3 class, defining methods to collect before and after test hooks. It includes a BeforeEach3 method as a before test hook.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeAllTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t{\n\t\t\tClassType = typeof(global::TUnit.TestProject.BeforeTests.Base3),\n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.Base3),\n\t\t\t\tName = \"BeforeEach3\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.Base3\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.Base3),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"BeforeAllTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"BeforeAllTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"Base3\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.BeforeTests.Base3)classInstance).BeforeEach3()),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t},\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Defining CompareOptions Class in C#\nDESCRIPTION: This class defines options for comparison, including EquivalencyKind and MembersToIgnore. It implements IEquatable<CompareOptions>.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic class CompareOptions : System.IEquatable<TUnit.Assertions.CompareOptions>\n{\n    public CompareOptions() { }\n    public TUnit.Assertions.Enums.EquivalencyKind EquivalencyKind { get; set; }\n    public string[] MembersToIgnore { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing String Regex Matching Assertion in C#\nDESCRIPTION: These methods extend IValueSource<string> to provide assertions for string regex matching. They accept either a Regex object or a string pattern.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_141\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> Matches(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, System.Text.RegularExpressions.Regex regex, [System.Runtime.CompilerServices.CallerArgumentExpression(\"regex\")] string expression = \"\") { }\n\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> Matches(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string regex, [System.Runtime.CompilerServices.CallerArgumentExpression(\"regex\")] string expression = \"\") { }\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract DataSourceGeneratorAttribute<T1..T4> in C#\nDESCRIPTION: This C# abstract attribute `DataSourceGeneratorAttribute<T1, T2, T3, T4>` serves as a foundation for TUnit data source attributes that provide test data consisting of four distinct types (T1 to T4). It inherits from `TestDataAttribute` and implements `IDataAttribute`. Subclasses must define the `GenerateDataSources` method to return functions generating `ValueTuple<T1, T2, T3, T4>` based on `DataGeneratorMetadata`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\n    public abstract class DataSourceGeneratorAttribute<T1, T2, T3, T4> : TUnit.Core.TestDataAttribute, TUnit.Core.IDataAttribute\n    {\n        protected DataSourceGeneratorAttribute() { }\n        public abstract System.Collections.Generic.IEnumerable<System.Func<System.ValueTuple<T1, T2, T3, T4>>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata);\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Class Hooks Base3\nDESCRIPTION: Implements class-level hooks for Base3 including registration and collection methods for before and after class execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_Base3 : global::TUnit.Core.Interfaces.SourceGenerator.IClassHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_Base3();\n\t\tSourceRegistrar.RegisterClassHookSource(instance);\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing BrowserTest Class for Playwright Testing in C#\nDESCRIPTION: This class extends PlaywrightTest and provides methods for browser setup, teardown, and context creation.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class BrowserTest : TUnit.Playwright.PlaywrightTest\n{\n    public BrowserTest() { }\n    public BrowserTest(Microsoft.Playwright.BrowserTypeLaunchOptions options) { }\n    public Microsoft.Playwright.IBrowser Browser { get; }\n    [TUnit.Core.Before(TUnit.Core.HookType.Test, \"\", 0)]\n    public System.Threading.Tasks.Task BrowserSetup() { }\n    [TUnit.Core.After(TUnit.Core.HookType.Test, \"\", 0)]\n    public System.Threading.Tasks.Task BrowserTearDown(TUnit.Core.TestContext testContext) { }\n    public System.Threading.Tasks.Task<Microsoft.Playwright.IBrowserContext> NewContext(Microsoft.Playwright.BrowserNewContextOptions options) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTime Assertion Extensions in TUnit (C#)\nDESCRIPTION: Extension methods for DateTime type providing temporal assertions. Includes methods for comparing dates and times with various precision options.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_54\n\nLANGUAGE: C#\nCODE:\n```\npublic static class DateTimeIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTime> IsAfter(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTime> valueSource, System.DateTime expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTime> IsAfterOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTime> valueSource, System.DateTime expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTime> IsBefore(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTime> valueSource, System.DateTime expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTime> IsBeforeOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTime> valueSource, System.DateTime expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.DateTimeEqualToAssertionBuilderWrapper IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTime> valueSource, System.DateTime expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Test Metadata for CustomDisplayNameTests in C#\nDESCRIPTION: This code snippet defines a method to collect test metadata for the CustomDisplayNameTests class. It creates TestMetadata objects for each test method, including information about the test method, its attributes, and the test class.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/CustomDisplayNameTests.Test.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n    global::System.Collections.Generic.List<TestMetadata> nodes = [];\n    var classDataIndex = 0;\n    var testMethodDataIndex = 0;\n    try\n    {\n        var testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n        {\n            Type = typeof(global::TUnit.TestProject.CustomDisplayNameTests),\n            Name = \"SameClassConstantTest\",\n            GenericTypeCount = 0,\n            ReturnType = typeof(global::System.Threading.Tasks.Task),\n            Attributes = \n            [\n                new global::TUnit.Core.TestAttribute(),\n                new global::TUnit.Core.DisplayNameAttribute($\"My test {\"My constant\"}\")\n            ],\n            Parameters = [],\n            Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.CustomDisplayNameTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n            {\n                Type = typeof(global::TUnit.TestProject.CustomDisplayNameTests),\n                Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"CustomDisplayNameTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n                {\n                    Name = \"CustomDisplayNameTests\",\n                    Attributes = [],\n                }),\n                Name = \"CustomDisplayNameTests\",\n                Namespace = \"TUnit.TestProject\",\n                Attributes = [],\n                Parameters = [],\n                Properties = \n                [\n                    new global::TUnit.Core.SourceGeneratedPropertyInformation\n                    {\n                        Type = typeof(int),\n                        Name = \"Order\",\n                        IsStatic = false,\n                        Attributes = [],\n                    },\n                ],\n            }),\n        };\n\n        // ... (rest of the method implementation)\n    }\n    catch (global::System.Exception exception)\n    {\n        nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.CustomDisplayNameTests>\n        {\n            TestId = $\"TUnit.TestProject.CustomDisplayNameTests.SameClassConstantTest:0\",\n            MethodName = $\"SameClassConstantTest\",\n            Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"CustomDisplayNameTests.SameClassConstantTest failed to initialize\", exception),\n            TestFilePath = @\"\",\n            TestLineNumber = 51,\n        });\n    }\n    return nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: String Assertion Conditions Implementation\nDESCRIPTION: Classes for string-specific assertion conditions including equality, contains, and not-equals comparisons. These classes provide various string comparison options with customizable behavior for whitespace and null handling.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\npublic class StringEqualsExpectedValueAssertCondition : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<string, string>\n{\n    public StringEqualsExpectedValueAssertCondition(string expected, System.StringComparison stringComparison) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(string? actualValue, string? expectedValue) { }\n    public TUnit.Assertions.AssertConditions.String.StringEqualsExpectedValueAssertCondition IgnoringWhitespace() { }\n    public TUnit.Assertions.AssertConditions.String.StringEqualsExpectedValueAssertCondition WithNullAndEmptyEquality() { }\n    public TUnit.Assertions.AssertConditions.String.StringEqualsExpectedValueAssertCondition WithTrimming() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing TUnit Templates via CLI\nDESCRIPTION: Commands to install the TUnit templates package and create a new TUnit project. This creates a starter project with sample tests that showcase different test types and features.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/README.md#2025-04-22_snippet_0\n\nLANGUAGE: cli\nCODE:\n```\ndotnet new install TUnit.Templates\n```\n\nLANGUAGE: cli\nCODE:\n```\ndotnet new TUnit -n \"YourProjectName\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Collection Method for NumberArgumentTests\nDESCRIPTION: This method collects test metadata for the NumberArgumentTests class. It creates test metadata objects with proper configuration for test execution, including arguments, class instantiation, and error handling.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/NumberArgumentTests.TestDE.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.NumberArgumentTests),\n\t\t\tName = \"UInt\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(1U)\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<uint>\n\t\t\t\t{\n\t\t\t\t\tName = \"i\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.NumberArgumentTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.NumberArgumentTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"NumberArgumentTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"NumberArgumentTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"NumberArgumentTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing DateOnly Assertion Extensions in TUnit (C#)\nDESCRIPTION: Extension methods for DateOnly type providing temporal assertions. Allows comparing dates with methods like IsAfter, IsBefore, and equality checks.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_53\n\nLANGUAGE: C#\nCODE:\n```\npublic static class DateOnlyIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateOnly> IsAfter(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateOnly> valueSource, System.DateOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateOnly> IsAfterOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateOnly> valueSource, System.DateOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateOnly> IsBefore(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateOnly> valueSource, System.DateOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateOnly> IsBeforeOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateOnly> valueSource, System.DateOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.DateOnlyEqualToAssertionBuilderWrapper IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateOnly> valueSource, System.DateOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Test Metadata for Null Test Arguments in TUnit\nDESCRIPTION: The Tests0 method creates test metadata for a test method called NullTest with null arguments. It sets up test metadata including class information, arguments, and test execution details with proper error handling.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1692.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1692.Tests),\n\t\t\tName = \"NullTest\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(null),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(null)\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t{\n\t\t\t\t\tName = \"t\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._1692.Tests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1692.Tests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Tests1692\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"Tests1692\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"Tests\",\n\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._1692\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.Bugs._1692.Tests? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tclassInstanceArguments = [];\n\n\t\t\tstring methodArg = (string)(null);\n\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._1692.Tests>(() => \n\t\t\tnew global::TUnit.TestProject.Bugs._1692.Tests()\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._1692.Tests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.Bugs._1692.Tests.NullTest(string):0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.NullTest(methodArg)),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 10,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._1692.Tests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.Bugs._1692.Tests.NullTest(string):0\",\n\t\t\t\tMethodName = $\"NullTest\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"Tests.NullTest failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 10,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n```\n\n----------------------------------------\n\nTITLE: Collecting Test Metadata in C#\nDESCRIPTION: This code snippet outlines a CollectTests method that aggregates test metadata using session IDs. It hinges on predetermined test methods like Tests0 and Tests1 for structured test data retrieval. The function requires session identifiers as input and outputs a collection of TestMetadata objects. Dependencies include TUnit.Core's metadata interfaces.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/RepeatTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n {\n return\n [\n ..Tests0(sessionId),\n ..Tests1(sessionId),\n ];\n }\n```\n\n----------------------------------------\n\nTITLE: Implementing Skip Test Utility in C#\nDESCRIPTION: Provides static methods for conditionally skipping tests. Includes methods for skipping tests unconditionally or based on specified conditions, with appropriate reason messages.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_46\n\nLANGUAGE: C#\nCODE:\n```\npublic static class Skip\n{\n    [System.Diagnostics.CodeAnalysis.DoesNotReturn]\n    public static void Test(string reason) { }\n    public static void Unless([System.Diagnostics.CodeAnalysis.DoesNotReturnIf(false)] bool condition, string reason) { }\n    public static void When([System.Diagnostics.CodeAnalysis.DoesNotReturnIf(true)] bool condition, string reason) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Base Class for Playwright Context Tests in C#\nDESCRIPTION: The `ContextTest` class inherits from `BrowserTest` and manages a Playwright `IBrowserContext`. It provides a `Context` property and includes a `[Before]` hook (`ContextSetup`) to initialize the context before a test. It also defines a virtual method `ContextOptions` to allow customization of context creation options.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet2_0.Net4_7.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ContextTest : TUnit.Playwright.BrowserTest\n{\n    public ContextTest() { }\n    public Microsoft.Playwright.IBrowserContext Context { get; }\n    public virtual Microsoft.Playwright.BrowserNewContextOptions ContextOptions(TUnit.Core.TestContext testContext) { }\n    [TUnit.Core.Before(TUnit.Core.HookType.Test, \"<FilePath>\", 19)]\n    public System.Threading.Tasks.Task ContextSetup(TUnit.Core.TestContext testContext) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TestRegisteredContext Class in C# for TUnit Framework\nDESCRIPTION: This class represents the context for a registered test in the TUnit framework. It provides methods to set parallel limits and skip tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_48\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestRegisteredContext : TUnit.Core.BeforeTestContext\n{\n    public void SetParallelLimiter(TUnit.Core.Interfaces.IParallelLimit parallelLimit) { }\n    public void SkipTest(string reason) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Exception Assertion Class Implementation in C#\nDESCRIPTION: Generic class implementation for handling exception assertions in TUnit framework. Provides methods for checking exception types, messages, and inner exceptions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic class ThrowsException<TActual, TException>\n    where TException : System.Exception\n{\n    public ThrowsException(TUnit.Assertions.AssertionBuilders.InvokableDelegateAssertionBuilder delegateAssertionBuilder, TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource source, System.Func<System.Exception?, System.Exception?> selector) { }\n    public TUnit.Assertions.AssertConditions.Operators.ValueAnd<TException> And { get; }\n    public TUnit.Assertions.AssertConditions.Operators.DelegateOr<object?> Or { get; }\n    public System.Runtime.CompilerServices.TaskAwaiter<TException?> GetAwaiter() { }\n    public TUnit.Assertions.AssertConditions.Throws.ThrowsException<TActual, System.Exception> WithInnerException() { }\n    public TUnit.Assertions.AssertConditions.Throws.ThrowsException<TActual, TException> WithMessage(string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public TUnit.Assertions.AssertConditions.Throws.ThrowsException<TActual, TException> WithMessageMatching(TUnit.Assertions.AssertConditions.StringMatcher match, [System.Runtime.CompilerServices.CallerArgumentExpression(\"match\")] string? doNotPopulateThisValue = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract TUnitLogger Class in C#\nDESCRIPTION: Defines an abstract base class for TUnit loggers, implementing the ILogger interface. It includes a virtual IsEnabled method and abstract Log and LogAsync methods to be implemented by derived classes.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_66\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class TUnitLogger : TUnit.Core.Logging.ILogger\n{\n    protected TUnitLogger() { }\n    public virtual bool IsEnabled(TUnit.Core.Logging.LogLevel logLevel) { }\n    public abstract void Log<TState>(TUnit.Core.Logging.LogLevel logLevel, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter);\n    public abstract System.Threading.Tasks.ValueTask LogAsync<TState>(TUnit.Core.Logging.LogLevel logLevel, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Collection Assertion Conditions in C#\nDESCRIPTION: Defines various classes for asserting conditions on collections, including containment, count equality, and distinct items checks. These classes provide flexible ways to test enumerable collections.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_58\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumerableAllExpectedFuncAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n    where TActual : System.Collections.Generic.IEnumerable<TInner>\n{\n    public EnumerableAllExpectedFuncAssertCondition(System.Func<TInner, bool> matcher, string? matcherString) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n\npublic class EnumerableContainsExpectedFuncAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n    where TActual : System.Collections.Generic.IEnumerable<TInner>\n{\n    public EnumerableContainsExpectedFuncAssertCondition(System.Func<TInner, bool> matcher, string? matcherString) { }\n    public TInner FoundItem { get; }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n\npublic class EnumerableContainsExpectedValueAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TInner>\n    where TActual : System.Collections.Generic.IEnumerable<TInner>\n{\n    public EnumerableContainsExpectedValueAssertCondition(TInner expected, System.Collections.Generic.IEqualityComparer<TInner?>? equalityComparer) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TInner? inner) { }\n}\n\npublic class EnumerableCountEqualToExpectedValueAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, int>\n    where TActual : System.Collections.Generic.IEnumerable<TInner>\n{\n    public EnumerableCountEqualToExpectedValueAssertCondition(int expected) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, int count) { }\n}\n\npublic class EnumerableCountNotEqualToExpectedValueAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, int>\n    where TActual : System.Collections.Generic.IEnumerable<TInner>\n{\n    public EnumerableCountNotEqualToExpectedValueAssertCondition(int expected) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, int count) { }\n}\n\npublic class EnumerableDistinctItemsExpectedValueAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n    where TActual : System.Collections.Generic.IEnumerable<TInner>\n{\n    public EnumerableDistinctItemsExpectedValueAssertCondition(System.Collections.Generic.IEqualityComparer<TInner?>? equalityComparer) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ExplicitAttribute in C#\nDESCRIPTION: Implements an ExplicitAttribute class that inherits from TUnitAttribute. It is used to mark tests as explicit, requiring them to be specifically included in test runs.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method)]\npublic sealed class ExplicitAttribute : TUnit.Core.TUnitAttribute\n{\n    public ExplicitAttribute([System.Runtime.CompilerServices.CallerFilePath] string callerFile = \"\", [System.Runtime.CompilerServices.CallerMemberName] string callerMemberName = \"\") { }\n    public string For { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FailedTestMetadata<TClassType> in C#\nDESCRIPTION: Defines a FailedTestMetadata<TClassType> class for representing metadata of failed tests. It includes properties for exception details and test information.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class FailedTestMetadata<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]  TClassType> : System.IEquatable<TUnit.Core.FailedTestMetadata<TClassType>>\n    where TClassType :  class\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public FailedTestMetadata() { }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Exception Exception { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string MethodName { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string TestFilePath { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string TestId { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public int TestLineNumber { get; init; }\n    public static TUnit.Core.TestMetadata<TClassType> op_Implicit(TUnit.Core.FailedTestMetadata<TClassType> failedTestMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ParallelGroupAttribute in C#\nDESCRIPTION: Defines an attribute for grouping parallel tests. It implements IEventReceiver and ITestDiscoveryEventReceiver interfaces to handle test discovery events.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic class ParallelGroupAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver\n{\n    public ParallelGroupAttribute(string group) { }\n    public string Group { get; }\n    public int Order { get; set; }\n    public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DynamicTestBuilderContext in C#\nDESCRIPTION: Defines a DynamicTestBuilderContext class for managing dynamic test creation. It provides methods for adding tests and handling test contexts.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic class DynamicTestBuilderContext\n{\n    public DynamicTestBuilderContext(TUnit.Core.TestContext testContext) { }\n    public DynamicTestBuilderContext(string filePath, int lineNumber) { }\n    public System.Collections.Generic.List<TUnit.Core.DynamicTest> Tests { get; }\n    public void AddTest<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicParameterlessConstructor | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]  TClass>(TUnit.Core.DynamicTest<TClass> dynamicTest)\n        where TClass :  class { }\n    public System.Threading.Tasks.Task AddTestAtRuntime<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicParameterlessConstructor | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]  TClass>(TUnit.Core.TestContext testContext, TUnit.Core.DynamicTest<TClass> dynamicTest)\n        where TClass :  class { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TUnit Source Generator for Argument Conversion Tests in C#\nDESCRIPTION: This C# snippet defines a partial class `ArgumentWithImplicitConverterTests` generated by the TUnit source generator. It implements `ITestSource` to enable test discovery. A `ModuleInitializer` registers this source with TUnit. The `CollectTests` method aggregates metadata from helper methods (`Tests0`, `Tests1`, `Tests2`). The `Tests0` method collects metadata for the `Implicit` test method with argument `1`, defining method/class information, attributes, parameters, and handling context/instance creation. The `Tests1` method starts similarly for argument `2`. This structure facilitates efficient, compile-time test discovery.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ArgumentWithImplicitConverterTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class ArgumentWithImplicitConverterTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new ArgumentWithImplicitConverterTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\t..Tests0(sessionId),\n\t\t\t..Tests1(sessionId),\n\t\t\t..Tests2(sessionId),\n\t\t];\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.ArgumentWithImplicitConverterTests),\n\t\t\t\tName = \"Implicit\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(1),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(2),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(3)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.ImplicitInteger>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"integer\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.ArgumentWithImplicitConverterTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.ArgumentWithImplicitConverterTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"ArgumentWithImplicitConverterTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"ArgumentWithImplicitConverterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"ArgumentWithImplicitConverterTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.ArgumentWithImplicitConverterTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tglobal::TUnit.TestProject.ImplicitInteger methodArg = 1;\n\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ArgumentWithImplicitConverterTests>(() => \n\t\t\t\tnew global::TUnit.TestProject.ArgumentWithImplicitConverterTests()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.ArgumentWithImplicitConverterTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.ArgumentWithImplicitConverterTests.Implicit(TUnit.TestProject.ImplicitInteger):0\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Implicit(methodArg)),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 14,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ArgumentWithImplicitConverterTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.ArgumentWithImplicitConverterTests.Implicit(TUnit.TestProject.ImplicitInteger):0\",\n\t\t\t\t\tMethodName = $\"Implicit\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ArgumentWithImplicitConverterTests.Implicit failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 14,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n\t\tprivate global::System.Collections.Generic.List<TestMetadata> Tests1(string sessionId)\n\t\t{\n\t\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\t\tvar classDataIndex = 0;\n\t\t\tvar testMethodDataIndex = 0;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.ArgumentWithImplicitConverterTests),\n\t\t\t\t\tName = \"Implicit\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(void),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(1),\n\t\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(2),\n\t\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(3)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.ImplicitInteger>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"integer\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.ArgumentWithImplicitConverterTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.ArgumentWithImplicitConverterTests),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"ArgumentWithImplicitConverterTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"ArgumentWithImplicitConverterTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"ArgumentWithImplicitConverterTests\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n};\n\n\t\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\t\tglobal::TUnit.TestProject.ArgumentWithImplicitConverterTests? classInstance = null;\n\t\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\t\tglobal::TUnit.TestProject.ImplicitInteger methodArg = 2;\n\n\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ArgumentWithImplicitConverterTests>(() => \n\t\t\t\t\tnew global::TUnit.TestProject.ArgumentWithImplicitConverterTests()\n\t\t\t\t\t, sessionId, testBuilderContext);\n\n```\n\n----------------------------------------\n\nTITLE: Registering TUnit Test Source via Module Initializer in C#\nDESCRIPTION: This static `Initialise` method, marked with `[ModuleInitializer]`, ensures that an instance of the generated `DataDrivenTests` class is registered with the TUnit framework's `SourceRegistrar` when the module loads. This mechanism makes the tests defined or collected by this source-generated class discoverable by the TUnit test runner.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new DataDrivenTests());\n\t}\n```\n\n----------------------------------------\n\nTITLE: Executing Tests with dotnet exec in Powershell\nDESCRIPTION: Shows how to run tests with dotnet exec, useful when a test project is already built. It involves running a DLL directly, with or without additional flags.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/running-your-tests.md#2025-04-22_snippet_2\n\nLANGUAGE: Powershell\nCODE:\n```\ncd 'C:/Your/Test/Directory/bin/Release/net8.0'\ndotnet exec YourTestProject.dll\n# or with flags\ndotnet exec YourTestProject.dll --report-trx --coverage\n```\n\nLANGUAGE: Powershell\nCODE:\n```\ncd 'C:/Your/Test/Directory/bin/Release/net8.0'\ndotnet YourTestProject.dll\n# or with flags\ndotnet YourTestProject.dll --report-trx --coverage\n```\n\n----------------------------------------\n\nTITLE: Registering TUnit Test Sources with Module Initializer\nDESCRIPTION: Implements the ModuleInitializer pattern to register the test source with TUnit's SourceRegistrar. This ensures the test source is automatically discovered and registered when the assembly loads.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/PriorityFilteringTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tglobal::TUnit.Core.SourceRegistrar.Register(new PriorityFilteringTests());\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Equivalence Testing for Enumerable Collections in C#\nDESCRIPTION: Classes for testing if two enumerable collections are equivalent or not equivalent. They support custom equality comparison and different collection ordering modes to control how the equivalence is determined.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumerableEquivalentToExpectedValueAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, System.Collections.Generic.IEnumerable<TInner>>\n    where TActual : System.Collections.Generic.IEnumerable<TInner>?\n{\n    public EnumerableEquivalentToExpectedValueAssertCondition(System.Collections.Generic.IEnumerable<TInner>? expected, System.Collections.Generic.IEqualityComparer<TInner?> equalityComparer, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Collections.Generic.IEnumerable<TInner>? expectedValue) { }\n}\n\npublic class EnumerableNotEquivalentToExpectedValueAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, System.Collections.Generic.IEnumerable<TInner>>\n    where TActual : System.Collections.Generic.IEnumerable<TInner>?\n{\n    public EnumerableNotEquivalentToExpectedValueAssertCondition(System.Collections.Generic.IEnumerable<TInner>? expected, System.Collections.Generic.IEqualityComparer<TInner?> equalityComparer, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Collections.Generic.IEnumerable<TInner>? expectedValue) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AssertionGroup Operations in C#\nDESCRIPTION: Static class providing methods for building and combining assertion groups with support for different value types and async operations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_80\n\nLANGUAGE: C#\nCODE:\n```\npublic static class AssertionGroup\n{\n    public static TUnit.Assertions.AssertionBuilders.Groups.AndAssertionGroupInvoker<TActual, TAssertionBuilder> And<TActual, TAssertionBuilder>(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group1, TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group2)\n        where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder { }\n\n    public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<TActual, TUnit.Assertions.AssertionBuilders.ValueAssertionBuilder<TActual>> For<TActual>(TActual value) { }\n\n    public static TUnit.Assertions.AssertionBuilders.Groups.OrAssertionGroupInvoker<TActual, TAssertionBuilder> Or<TActual, TAssertionBuilder>(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group1, TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group2)\n        where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing C# Assertion Condition Classes\nDESCRIPTION: A comprehensive set of assertion condition classes that handle different types of assertions like type checking, equality comparison, and reference comparison. Each class implements the BaseAssertCondition interface and provides specific assertion logic through GetResult and GetExpectation methods.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_99\n\nLANGUAGE: C#\nCODE:\n```\npublic class AssignableToExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n{\n    public AssignableToExpectedValueAssertCondition(System.Type expectedType) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class EqualsExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TActual>\n{\n    public EqualsExpectedValueAssertCondition(TActual expected) { }\n    public EqualsExpectedValueAssertCondition(TActual expected, System.Collections.Generic.IEqualityComparer<TActual> equalityComparer) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TActual? expectedValue) { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class SameReferenceExpectedValueAssertCondition<TActual, TExpected> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TExpected>\n{\n    public SameReferenceExpectedValueAssertCondition(TExpected expected) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TExpected? expectedValue) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering and Collecting Test Hooks for Base3 in C#\nDESCRIPTION: Auto-generated partial class `Hooks_Base3` implementing `ITestHookSource` for TUnit. It uses a `ModuleInitializer` for registration via `SourceRegistrar.RegisterTestHookSource` and provides methods to collect test-level hooks (`BeforeEveryTest`, `AfterEveryTest`, `BeforeTest`, `AfterTest`). The `CollectAfterTestHooks` method returns an `InstanceHookMethod` for the `AfterEach3` instance method in `TUnit.TestProject.AfterTests.Base3`, intended to run after each individual test method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterAllTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_Base3 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_Base3();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.AfterTests.Base3),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.Base3),\n\t\t\t\t\tName = \"AfterEach3\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.Base3\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.Base3),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AfterAllTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"AfterAllTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"Base3\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.AfterTests.Base3)classInstance).AfterEach3()),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Hooks for Base2 Tests in TUnit\nDESCRIPTION: Generated partial class implementing ITestHookSource interface for Base2 test class. Provides test hook collection and registration functionality.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterAllTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_Base2 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n    [global::System.Runtime.CompilerServices.ModuleInitializer]\n    public static void Initialise()\n    {\n        var instance = new Hooks_Base2();\n        SourceRegistrar.RegisterTestHookSource(instance);\n    }\n    public global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n    {\n        return\n        [\n        ];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Class Hooks for Base2\nDESCRIPTION: Source-generated partial class implementing IClassHookSource interface for Base2 test class. Contains class-level hook registration and collection methods.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_Base2 : global::TUnit.Core.Interfaces.SourceGenerator.IClassHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_Base2();\n\t\tSourceRegistrar.RegisterClassHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Creating Instance Method Data Source Attributes in C#\nDESCRIPTION: Attributes for sourcing test data from instance methods, supporting various data source configurations. Allows methods to access instance data for generating test cases with type-specific variants.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Method, AllowMultiple=true)]\npublic class InstanceMethodDataSourceAttribute : TUnit.Core.MethodDataSourceAttribute, TUnit.Core.IAccessesInstanceData\n{\n    public InstanceMethodDataSourceAttribute(string methodNameProvidingDataSource) { }\n    public InstanceMethodDataSourceAttribute(System.Type classProvidingDataSource, string methodNameProvidingDataSource) { }\n}\n\n[System.AttributeUsage(System.AttributeTargets.Method, AllowMultiple=true)]\npublic class InstanceMethodDataSourceAttribute<T> : TUnit.Core.MethodDataSourceAttribute<T>, TUnit.Core.IAccessesInstanceData\n{\n    public InstanceMethodDataSourceAttribute(string methodNameProvidingDataSource) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Test Metadata with TUnit in C#\nDESCRIPTION: This snippet handles the initialization and management of test metadata using the TUnit framework. It defines test attributes, data generation mechanisms, and exception handling for tests. It requires a connection to the TUnit library and involves setting up test contexts, defining resettable factors, and executing tests with generated data.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nvar classArgDataGeneratorMetadata = new DataGeneratorMetadata\n{\n   Type = TUnit.Core.Enums.DataGeneratorType.Parameters,\n   TestClassType = testClassType,\n   ParameterInfos = typeof(global::TUnit.TestProject.DataSourceGeneratorTests).GetConstructors().First().GetParameters(),\n   PropertyInfo = null,\n   TestBuilderContext = testBuilderContextAccessor,\n   TestSessionId = sessionId,\n};\nvar classDataAttribute = new global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<global::System.Int32, global::System.String, global::System.Boolean>()\n{\n    \n};\n\nvar classArgGeneratedDataArray = classDataAttribute.GenerateDataSources(classArgDataGeneratorMetadata);\n\nforeach (var classArgGeneratedDataAccessor in classArgGeneratedDataArray)\n{\n    classDataIndex++;\n    var methodArgDataGeneratorMetadata = new DataGeneratorMetadata\n{\n   Type = TUnit.Core.Enums.DataGeneratorType.Parameters,\n   TestClassType = testClassType,\n   ParameterInfos = methodInfo.GetParameters(),\n   PropertyInfo = null,\n   TestBuilderContext = testBuilderContextAccessor,\n   TestSessionId = sessionId,\n};\n    var methodDataAttribute = new global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<global::System.Int32, global::System.String, global::System.Boolean>()\n{\n    \n};\n\n    var methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\n\n    foreach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\n    {\n        testMethodDataIndex++;\n        var classArgGeneratedData = classArgGeneratedDataAccessor();\n        global::System.Int32 classArg = classArgGeneratedData.Item1;\n        global::System.String classArg1 = classArgGeneratedData.Item2;\n        global::System.Boolean classArg2 = classArgGeneratedData.Item3;\n\n\n        var methodArgGeneratedData = methodArgGeneratedDataAccessor();\n        global::System.Int32 methodArg = methodArgGeneratedData.Item1;\n        global::System.String methodArg1 = methodArgGeneratedData.Item2;\n        global::System.Boolean methodArg2 = methodArgGeneratedData.Item3;\n\n        var resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.DataSourceGeneratorTests>(() => \n        new global::TUnit.TestProject.DataSourceGeneratorTests(classArg, classArg1, classArg2)\n        , sessionId, testBuilderContext);\n\n        var resettableClassFactory = resettableClassFactoryDelegate();\n\n        nodes.Add(new TestMetadata<global::TUnit.TestProject.DataSourceGeneratorTests>\n        {\n            TestId = $\"global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<global::System.Int32, global::System.String, global::System.Boolean>:{classDataIndex}:CL-GAC0:global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<global::System.Int32, global::System.String, global::System.Boolean>:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.DataSourceGeneratorTests(System.Int32,System.String,System.Boolean).GeneratedData_Method2(System.Int32,System.String,System.Boolean):0\",\n            TestClassArguments = [classArg, classArg1, classArg2],\n            TestMethodArguments = [methodArg, methodArg1, methodArg2],\n            TestClassProperties = [],\n            CurrentRepeatAttempt = 0,\n            RepeatLimit = 0,\n            MethodInfo = methodInfo,\n            ResettableClassFactory = resettableClassFactory,\n            TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.GeneratedData_Method2(methodArg, methodArg1, methodArg2)),\n            TestFilePath = @\"\",\n            TestLineNumber = 17,\n            TestAttributes = [ new global::TUnit.Core.TestAttribute()\n{\n    \n}, new global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<global::System.Int32, global::System.String, global::System.Boolean>()\n{\n    \n} ],\n            ClassAttributes = [ new global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<global::System.Int32, global::System.String, global::System.Boolean>()\n{\n    \n}, new global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute()\n{\n    \n} ],\n            AssemblyAttributes = [  ],\n            DataAttributes = [ classDataAttribute, methodDataAttribute ],\n            TestBuilderContext = testBuilderContext,\n        });\n        resettableClassFactory = resettableClassFactoryDelegate();\n        testBuilderContext = new();\n        testBuilderContextAccessor.Current = testBuilderContext;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Type Assertion Conditions in C#\nDESCRIPTION: Collection of assertion conditions for type checking including AssignableTo, AssignableFrom, TypeOf and their negative variants. These classes extend BaseAssertCondition to provide type comparison functionality.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\npublic class AssignableToExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n{\n    public AssignableToExpectedValueAssertCondition(System.Type expectedType) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Hook Collection Methods in C#\nDESCRIPTION: Implementation of ITestHookSource interface methods for collecting before and after test hooks. Includes detailed configuration of hook methods with attributes, parameters, and execution context.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeAllTests.Test.verified.txt#2025-04-22_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n{\n    return\n    [\n        new global::TUnit.Core.Hooks.InstanceHookMethod\n        {\n            ClassType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n            MethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n            {\n                Type = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n                Name = \"SetupWithContext\",\n                GenericTypeCount = 0,\n                ReturnType = typeof(global::System.Threading.Tasks.Task),\n                Attributes = \n                [\n                    new global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test),\n                    new global::TUnit.Core.TimeoutAttribute(30_000)\n                ],\n                Parameters = \n                [\n                    new global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext>\n                    {\n                        Name = \"testContext\",\n                        Attributes = [],\n                    },\n                    new global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n                    {\n                        Name = \"cancellationToken\",\n                        Attributes = [],\n                    },\n                ],\n                Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.SetupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n                {\n                    // Class information configuration\n                })\n            }\n        }\n    ];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Negative Comparable Value Assertions in C#\nDESCRIPTION: Extension methods for asserting that comparable values do not meet certain conditions, such as not being between, not greater than, not less than, etc.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_109\n\nLANGUAGE: C#\nCODE:\n```\npublic static class ComparableIsNotExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.NotBetweenAssertionBuilderWrapper<TActual> IsNotBetween<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual lowerBound, TActual upperBound, [System.Runtime.CompilerServices.CallerArgumentExpression(\"lowerBound\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"upperBound\")] string doNotPopulateThisValue2 = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotGreaterThan<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotGreaterThanOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotLessThan<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotLessThanOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Single Item in Collections in C#\nDESCRIPTION: Extension methods for asserting that a collection or ImmutableArray contains a single item.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_72\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.Wrappers.SingleItemAssertionBuilderWrapper<System.Collections.Generic.IEnumerable<TInner>, TInner> HasSingleItem<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }\npublic static TUnit.Assertions.AssertionBuilders.Wrappers.SingleItemAssertionBuilderWrapper<System.Collections.Immutable.ImmutableArray<TInner>, TInner> HasSingleItem<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource) { }\n```\n\n----------------------------------------\n\nTITLE: Collecting Test Metadata\nDESCRIPTION: Method that aggregates test metadata from multiple test collections, combining results from Tests0 through Tests3\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=TupleMethod_testMethodName=NamedTupleMethod.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn\n\t[\n\t\t..Tests0(sessionId),\n\t\t..Tests1(sessionId),\n\t\t..Tests2(sessionId),\n\t\t..Tests3(sessionId),\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Test Metadata Collection for Method One in C#\nDESCRIPTION: This represents the code pattern for collecting and managing test metadata associated with the method 'One'. It manages a series of try-catch processes to handle initialization exceptions, engaging various TUnit.Core attributes. Key inputs include session IDs to define metadata structure, with TestMetadata outputs. Relies on System and TUnit components.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/RepeatTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n {\n global::System.Collections.Generic.List<TestMetadata> nodes = [];\n // ... \n return nodes;\n }\n```\n\n----------------------------------------\n\nTITLE: Defining AssertionData Struct in C#\nDESCRIPTION: Defines an immutable `AssertionData` struct to store the outcome of an assertion attempt. It includes the actual result or exception encountered, the source expression string, and start/end timestamps. It implements `IEquatable` and provides an implicit conversion from a ValueTuple.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_27\n\nLANGUAGE: csharp\nCODE:\n```\n    public readonly struct AssertionData : System.IEquatable<TUnit.Assertions.AssertionData>\n    {\n        public AssertionData(object? Result, System.Exception? Exception, string? ActualExpression, System.DateTimeOffset Start, System.DateTimeOffset End) { }\n        public string? ActualExpression { get; init; }\n        public System.DateTimeOffset End { get; init; }\n        public System.Exception? Exception { get; init; }\n        public object? Result { get; init; }\n        public System.DateTimeOffset Start { get; init; }\n        public static TUnit.Assertions.AssertionData op_Implicit(System.ValueTuple<object?, System.Exception?, string?, System.DateTimeOffset, System.DateTimeOffset> tuple) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Logger Interface and Log Level Enumeration in C#\nDESCRIPTION: Definition of logger interfaces and log level enumeration for the logging system. Includes basic and generic logger interfaces with synchronous and asynchronous logging capabilities.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_68\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ILogger\n{\n    bool IsEnabled(TUnit.Core.Logging.LogLevel logLevel);\n    void Log<TState>(TUnit.Core.Logging.LogLevel logLevel, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter);\n    System.Threading.Tasks.ValueTask LogAsync<TState>(TUnit.Core.Logging.LogLevel logLevel, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter);\n}\n\npublic enum LogLevel\n{\n    Trace = 0,\n    Debug = 1,\n    Information = 2,\n    Warning = 3,\n    Error = 4,\n    Critical = 5,\n    None = 6\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Negative Assertion Extensions in TUnit\nDESCRIPTION: Extension methods for asserting negative collection conditions in tests. Provides methods for checking non-emptiness and non-equivalence of collections.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_130\n\nLANGUAGE: C#\nCODE:\n```\npublic static class CollectionsIsNotExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsNotEmpty<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotEquivalentTo<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.Collections.Generic.IEnumerable<TInner> { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Test Metadata Instance for StringArgumentTests in C#\nDESCRIPTION: This snippet creates a TestMetadata instance for the Nullable method in StringArgumentTests. It sets up the test context, arguments, and factory methods for test execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/StringArgumentTests.Test.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nnodes.Add(new TestMetadata<global::TUnit.TestProject.StringArgumentTests>\n{\n    TestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS1:TUnit.TestProject.StringArgumentTests.Nullable(string):0\",\n    TestClassArguments = [],\n    TestMethodArguments = [methodArg],\n    TestClassProperties = [],\n    CurrentRepeatAttempt = 0,\n    RepeatLimit = 0,\n    ResettableClassFactory = resettableClassFactory,\n    TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Nullable(methodArg)),\n    TestFilePath = @\"\",\n    TestLineNumber = 24,\n    TestMethod = testInformation,\n    TestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Exception Message Assertion Extensions\nDESCRIPTION: Extension methods for asserting exception message contents with string comparison options.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_123\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> HasMessageStartingWith<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n    where TActual : System.Exception { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> HasMessageStartingWith<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"stringComparison\")] string doNotPopulateThisValue2 = null)\n    where TActual : System.Exception { }\n```\n\n----------------------------------------\n\nTITLE: Collecting After Test Hooks in C# for TUnit\nDESCRIPTION: This method collects and returns a list of after-test hooks for the CleanupTests class. It includes hooks for methods like 'Cleanup' and 'CleanupWithContext', specifying their attributes, parameters, and execution details.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterAllTests.Test.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t{\n\t\t\tClassType = typeof(global::TUnit.TestProject.AfterTests.CleanupTests),\n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.CleanupTests),\n\t\t\t\tName = \"Cleanup\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\t// ... (additional properties)\n\t\t\t},\n\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.AfterTests.CleanupTests)classInstance).Cleanup()),\n\t\t\t// ... (additional properties)\n\t\t},\n\t\t// ... (potentially more hooks)\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EquivalentToAssertionBuilderWrapper for Object Equivalence Testing\nDESCRIPTION: Assertion builder for testing object equivalence with customization options. It supports ignoring specific properties and partial equivalence checking between objects.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_84\n\nLANGUAGE: C#\nCODE:\n```\npublic class EquivalentToAssertionBuilderWrapper<TActual, TExpected> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>\n{\n    public TUnit.Assertions.AssertionBuilders.Wrappers.EquivalentToAssertionBuilderWrapper<TActual, TExpected> IgnoringMember(string propertyName, [System.Runtime.CompilerServices.CallerArgumentExpression(\"propertyName\")] string doNotPopulateThis = \"\") { }\n    public TUnit.Assertions.AssertionBuilders.Wrappers.EquivalentToAssertionBuilderWrapper<TActual, TExpected> WithPartialEquivalency() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Hook Methods for TUnit in C#\nDESCRIPTION: This snippet defines hook methods for executing code at various stages of the test process, such as before and after assemblies, classes, and individual tests. These methods inherit from StaticHookMethod<T> and implement IEquatable<T>.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_57\n\nLANGUAGE: C#\nCODE:\n```\nnamespace TUnit.Core.Hooks\n{\n    public class AfterAssemblyHookMethod : TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.AssemblyHookContext>, System.IEquatable<TUnit.Core.Hooks.AfterAssemblyHookMethod>\n    {\n        [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n            \"your compiler.\", true)]\n        public AfterAssemblyHookMethod() { }\n        public override System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.AssemblyHookContext context, System.Threading.CancellationToken cancellationToken) { }\n    }\n    // ... other hook method classes ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TimeoutAttribute Class in C# for TUnit Framework\nDESCRIPTION: This attribute class is used to set timeouts for tests in the TUnit framework. It implements IEventReceiver and ITestDiscoveryEventReceiver interfaces.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_51\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\npublic class TimeoutAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver\n{\n    public TimeoutAttribute(int timeoutInMilliseconds) { }\n    public int Order { get; }\n    public System.TimeSpan Timeout { get; }\n    public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Collection Non-Equivalence Assertion in TUnit (C#)\nDESCRIPTION: Extension method to assert that a collection is not equivalent to another collection. Allows specifying a custom comparer and collection ordering requirement.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_50\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotEquivalentTo<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"collectionOrdering\")] string doNotPopulateThisValue2 = null)\n            where TActual : System.Collections.Generic.IEnumerable<TInner> { }\n```\n\n----------------------------------------\n\nTITLE: Initializing TUnit Test Source Generator Class for NumberArgumentTests\nDESCRIPTION: This code defines a source-generated partial class for NumberArgumentTests that implements ITestSource interface to register and collect tests. It includes a module initializer to register the test class with the TUnit framework.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/NumberArgumentTests.TestDE.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class NumberArgumentTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new NumberArgumentTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Registering ValueTask-Based Asynchronous Tests using TUnit in C#\nDESCRIPTION: This snippet focuses on initializing and registering tests that use ValueTask for asynchronous operations in the TUnit framework. It handles instances through a resettable class factory and checks for exceptions during test collection, relying on the TUnit.Core libraries.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/PolyfillTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class BasicTests : TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tSourceRegistrar.Register(new BasicTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testClassType = typeof(global::TUnit.TestProject.BasicTests);\n\t\t\tvar methodInfo = global::TUnit.Core.Helpers.MethodInfoRetriever.GetMethodInfo(typeof(global::TUnit.TestProject.BasicTests), \"ValueTaskAsynchronousTest\", 0, []);\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.BasicTests>(() => \n\t\t\tnew global::TUnit.TestProject.BasicTests()\n\t\t\t, sessionId, testBuilderContext);\n\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.BasicTests>\n\t\t\t{\n\t\t\t\tTestId = $\"TUnit.TestProject.BasicTests.ValueTaskAsynchronousTest:0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tMethodInfo = methodInfo,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.ValueTaskAsynchronousTest()),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 17,\n\t\t\t\tTestAttributes = [ new global::TUnit.Core.TestAttribute()\n{\n    \n} ],\n\t\t\t\tClassAttributes = [  ],\n\t\t\t\tAssemblyAttributes = [  ],\n\t\t\t\tDataAttributes = [  ],\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedInitializationTest\n\t\t\t{\n\t\t\t\tTestId = $\"TUnit.TestProject.BasicTests.ValueTaskAsynchronousTest:0\",\n\t\t\t\tTestClass = typeof(global::TUnit.TestProject.BasicTests),\n\t\t\t\tReturnType = global::TUnit.Core.Helpers.MethodInfoRetriever.GetMethodInfo(typeof(global::TUnit.TestProject.BasicTests), \"ValueTaskAsynchronousTest\", 0, []).ReturnType,\n\t\t\t\tParameterTypeFullNames = [],\n\t\t\t\tTestName = \"ValueTaskAsynchronousTest\",\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 17,\n\t\t\t\tException = exception,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Method Data Source Attribute in C#\nDESCRIPTION: Defines an attribute for specifying a method as a data source. It can be applied to classes, methods, or properties and accepts either a method name or both a class type and method name.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method | System.AttributeTargets.Property, AllowMultiple=true)]\npublic class MethodDataSourceAttribute : TUnit.Core.TestDataAttribute\n{\n    public MethodDataSourceAttribute(string methodNameProvidingDataSource) { }\n    public MethodDataSourceAttribute(System.Type classProvidingDataSource, string methodNameProvidingDataSource) { }\n    public object?[] Arguments { get; set; }\n    public System.Type? ClassProvidingDataSource { get; }\n    public string MethodNameProvidingDataSource { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing TUnit TestMetadata Generation for StringArgumentTests.Nullable (Backslash Argument) in C#\nDESCRIPTION: This C# code snippet shows the beginning of the `Tests1` method, responsible for generating `TestMetadata` for the `Nullable` test method in `TUnit.TestProject.StringArgumentTests`. It initializes a list for metadata nodes and sets up index variables. Inside the `try` block, it starts constructing a `SourceGeneratedMethodInformation` object, defining the target type, method name (`Nullable`), return type, attributes (including the specific `ArgumentsAttribute(@\"\\\")` for this case), and parameter information.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/StringArgumentTests.Test.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests1(string sessionId)\n\t\t{\n\t\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\t\tvar classDataIndex = 0;\n\t\t\tvar testMethodDataIndex = 0;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.StringArgumentTests),\n\t\t\t\t\tName = \"Nullable\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(void),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\"),\n\t\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(@\"\\\"),\n\t\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(@\"\\t\"),\n\t\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\\t\"),\n\t\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\\\\t\"),\n```\n\n----------------------------------------\n\nTITLE: Constructing Method Metadata for Tuple-Driven Test - TUnit - C#\nDESCRIPTION: Creates metadata describing the method 'DataSource_TupleMethod' in the target test class, attaching parameter and data source information. Inputs: method parameters, attributes, class context. Outputs a SourceGeneratedMethodInformation object, which is required for accurate discovery and invocation of data-driven tests by TUnit. All relevant method-level binding and output typing are specified here.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests),\n\tName = \"DataSource_TupleMethod\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(void),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute(),\n\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\"),\n\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t{\n\t\t\tName = \"value\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"value2\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t{\n\t\t\tName = \"value3\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.ClassTupleDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t{\n\t\tType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests),\n\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"ClassTupleDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t{\n\t\t\tName = \"ClassTupleDataSourceDrivenTests\",\n\t\t\tAttributes = [],\n\t\t}),\n\t\tName = \"ClassTupleDataSourceDrivenTests\",\n\t\tNamespace = \"TUnit.TestProject\",\n\t\tAttributes = \n\t\t[\n\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\"),\n\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n\t\t],\n\t\tParameters = \n\t\t[\n\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t{\n\t\t\t\tName = \"value\",\n\t\t\t\tAttributes = [],\n\t\t\t},\n\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t{\n\t\t\t\tName = \"value2\",\n\t\t\t\tAttributes = [],\n\t\t\t},\n\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t\t{\n\t\t\t\tName = \"value3\",\n\t\t\t\tAttributes = [],\n\t\t\t},\n\t\t],\n\t\tProperties = \n\t\t[\nnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t{\n\t\t\t\tType = typeof((int, string, bool)),\n\t\t\t\tName = \"Property1\",\n\t\t\t\tIsStatic = false,\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n\t\t\t\t],\n\t\t\t},\nnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t{\n\t\t\t\tType = typeof((int, string, bool)),\n\t\t\t\tName = \"Property2\",\n\t\t\t\tIsStatic = false,\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n\t\t\t\t],\n\t\t\t},\nnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t{\n\t\t\t\tType = typeof((int Number, string Word, bool Flag)),\n\t\t\t\tName = \"Property3\",\n\t\t\t\tIsStatic = false,\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n\t\t\t\t],\n\t\t\t},\nnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t{\n\n```\n\n----------------------------------------\n\nTITLE: Defining Enumerable Items Satisfaction Assertion Condition in TUnit (C#)\nDESCRIPTION: This class implements an assertion condition that checks if items within an enumerable collection (`TActual` which is `IEnumerable<TInner?>`) satisfy a specific condition. It uses a provided `mapper` function to transform each item into a `TExpected` value and an `assertionBuilder` function to define the assertion logic for the mapped value. The constructor stores these delegates along with their string representations for reporting.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_45\n\nLANGUAGE: csharp\nCODE:\n```\n    public class EnumerableSatisfiesAssertCondition<TActual, TInner, TExpected> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n        where TActual : System.Collections.Generic.IEnumerable<TInner?>\n    {\n        public EnumerableSatisfiesAssertCondition(System.Func<TInner?, System.Threading.Tasks.Task<TExpected>?> mapper, System.Func<TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TExpected?>, TUnit.Assertions.AssertionBuilders.IInvokableAssertionBuilder> assertionBuilder, string mapperExpression, string assertionBuilderExpression) { }\n        protected override string GetExpectation() { }\n        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing ValueTask Test Source Generation in C#\nDESCRIPTION: Auto-generated source code for handling ValueTask-based asynchronous test method execution in TUnit. Includes test metadata collection, instance management, and error handling for the ValueTaskAsynchronousTest method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Dynamic/Basic.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class BasicTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new BasicTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BasicTests),\n\t\t\t\tName = \"ValueTaskAsynchronousTest\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.ValueTask),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute()\n\t\t\t\t],\n\t\t\t\tParameters = []\n\t\t\t}\n```\n\n----------------------------------------\n\nTITLE: Registering Test Hooks for Base2 using Source Generation in C#\nDESCRIPTION: This auto-generated C# snippet defines a partial class `Hooks_Base2` implementing `ITestHookSource` for TUnit. It registers itself with the `SourceRegistrar` using `ModuleInitializer`. The provided code includes the `CollectBeforeEveryTestHooks` method, which currently returns an empty list, indicating no static hooks are configured to run before every test associated with `Base2`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_Base2 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_Base2();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing IClassHookSource for SetupTests in C#\nDESCRIPTION: This snippet implements the IClassHookSource interface for the SetupTests class, defining methods to collect before and after class hooks. It includes a BeforeAllSetUp method as a before class hook.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeAllTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeClassHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.BeforeClassHookMethod\n\t\t{\n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\tName = \"BeforeAllSetUp\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t],\n\t\t\t\tParameters = [],\n```\n\n----------------------------------------\n\nTITLE: Registering and Implementing BeforeTest Hooks with TUnit Source Generator - C#\nDESCRIPTION: This snippet demonstrates an auto-generated partial class that implements the ITestHookSource interface for the TUnit framework. It uses a ModuleInitializer to register itself with the SourceRegistrar, and provides a CollectBeforeTestHooks method that returns an InstanceHookMethod describing a setup method for a test class. The method leverages reflection to specify method info and attributes, and employs AsyncConvert for async execution. No parameters are passed; the main output is a setup method attached to tests annotated with BeforeAttribute.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeAllTests.Test.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_SetupTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_SetupTests();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\t\tName = \"Setup\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.SetupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"BeforeAllTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"BeforeAllTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"SetupTests\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.BeforeTests.SetupTests)classInstance).Setup()),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t},\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining TUnit Exception Classes in C#\nDESCRIPTION: This snippet defines various exception classes that inherit from TUnitException. These exceptions are used to handle errors in different stages of test execution, such as before/after assembly, class, test discovery, and individual tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_55\n\nLANGUAGE: C#\nCODE:\n```\nnamespace TUnit.Core.Exceptions\n{\n    public class AfterAssemblyException : TUnit.Core.Exceptions.TUnitException\n    {\n        public AfterAssemblyException(string message, System.Exception innerException) { }\n    }\n    public class AfterClassException : TUnit.Core.Exceptions.TUnitException\n    {\n        public AfterClassException(string message, System.Exception innerException) { }\n    }\n    // ... other exception classes ...\n    public class TUnitException : System.Exception\n    {\n        public TUnitException() { }\n        public TUnitException(string? message) { }\n        public TUnitException(string? message, System.Exception? innerException) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Type Conversion Assertion Condition Base Class in TUnit (C#)\nDESCRIPTION: This abstract generic class extends `BaseAssertCondition<TFromType>` for assertions that require converting the actual value from `TFromType` to `TToType` before evaluation. It holds the `ConvertedValue` and requires derived classes to implement the asynchronous conversion logic (`ConvertValue`). The `GetResult` method is sealed and handles the conversion before calling the core logic.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_41\n\nLANGUAGE: csharp\nCODE:\n```\n    public abstract class ConvertToAssertCondition<TFromType, TToType> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TFromType>\n    {\n        protected ConvertToAssertCondition() { }\n        public TToType ConvertedValue { get; }\n        public abstract System.Threading.Tasks.ValueTask<System.ValueTuple<TUnit.Assertions.AssertConditions.AssertionResult, TToType?>> ConvertValue(TFromType? value);\n        protected override sealed System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TFromType? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Collecting Tests for TUnit Test Session\nDESCRIPTION: Implementation of the ITestSource interface method that collects all tests defined in the class. It combines tests from multiple test collection methods and returns them as a read-only list.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.Typed.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn\n\t[\n\t\t..Tests0(sessionId),\n\t\t..Tests1(sessionId),\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Ordering Assertion Methods for TUnit in C#\nDESCRIPTION: Methods to assert that collections are properly ordered. These include checks for collections being in ascending or descending order, with or without custom comparers, and ordered by specific item properties.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_105\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsInDescendingOrder<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsInDescendingOrder<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Collections.Generic.IComparer<TInner> comparer) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsInOrder<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsInOrder<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Collections.Generic.IComparer<TInner> comparer) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsOrderedBy<TInner, TComparisonItem>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, TComparisonItem> comparisonItemSelector, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparisonItemSelector\")] string doNotPopulateThisValue = null) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsOrderedBy<TInner, TComparisonItem>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, TComparisonItem> comparisonItemSelector, System.Collections.Generic.IComparer<TComparisonItem> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparisonItemSelector\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparer\")] string doNotPopulateThisValue2 = null) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsOrderedByDescending<TInner, TComparisonItem>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, TComparisonItem> comparisonItemSelector, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparisonItemSelector\")] string doNotPopulateThisValue = null) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsOrderedByDescending<TInner, TComparisonItem>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, TComparisonItem> comparisonItemSelector, System.Collections.Generic.IComparer<TComparisonItem> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparisonItemSelector\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparer\")] string doNotPopulateThisValue2 = null) { }\n```\n\n----------------------------------------\n\nTITLE: Negative String Assertion Methods for TUnit\nDESCRIPTION: Extension methods for asserting that strings do not contain specific patterns. Provides methods to verify a string does not contain a substring or does not end with a specific suffix.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_61\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> DoesNotContain(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> DoesNotContain(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"stringComparison\")] string doNotPopulateThisValue2 = null) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> DoesNotEndWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> DoesNotEndWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"stringComparison\")] string doNotPopulateThisValue2 = null) { }\n```\n\n----------------------------------------\n\nTITLE: Exception Handling for Test Metadata Creation with TUnit in C#\nDESCRIPTION: Handles initialisation exceptions during test metadata construction by creating a FailedTestMetadata object with error and context information. If test initialization fails due to an exception (e.g., in test method factory setup), a failed test record is added, including the exception and the line number. This ensures that failed setup does not prevent other tests from being discovered and runs are properly reported as failed with informative error details.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ConstantArgumentsTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ConstantArgumentsTests>\n\t{\n\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.ConstantArgumentsTests.Double(double):0\",\n\t\tMethodName = $\"Double\",\n\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ConstantArgumentsTests.Double failed to initialize\", exception),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 30,\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting TUnit Tests with Parameter Bindings in C#\nDESCRIPTION: Implementation of CollectTests method that gathers test metadata for test execution. It binds test methods with their data sources and prepares them for execution with proper parameter handling.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1538.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn Tests0(sessionId);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Before Test Discovery Hook Method in C#\nDESCRIPTION: Defines the BeforeTestDiscoveryHookMethod class which executes before test discovery. It inherits from StaticHookMethod and implements IEquatable.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_46\n\nLANGUAGE: C#\nCODE:\n```\npublic class BeforeTestDiscoveryHookMethod : TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.BeforeTestDiscoveryContext>, System.IEquatable<TUnit.Core.Hooks.BeforeTestDiscoveryHookMethod>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public BeforeTestDiscoveryHookMethod() { }\n    public override System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.BeforeTestDiscoveryContext context, System.Threading.CancellationToken cancellationToken) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting BeforeTest Hooks with CancellationToken in TUnit\nDESCRIPTION: Method that collects instance hooks for execution before tests with timeout attribute. Defines a hook for the Setup method that accepts a CancellationToken parameter and has a 30-second timeout.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeTests.Test.verified.txt#2025-04-22_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t{\n\t\t\tClassType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\tName = \"Setup\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test),\n\t\t\t\t\tnew global::TUnit.Core.TimeoutAttribute(30_000)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.SetupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"BeforeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"BeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"SetupTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.BeforeTests.SetupTests)classInstance).Setup(cancellationToken)),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test),\n\t\t\t\t\tnew global::TUnit.Core.TimeoutAttribute(30_000)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t},\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Creating AssertionDecision Class in C#\nDESCRIPTION: Defines the AssertionDecision class which represents the outcome of an assertion. It includes static properties for Continue and Pass decisions, and a static method to create a Fail decision with a message.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class AssertionDecision : System.IEquatable<TUnit.Assertions.AssertionDecision>\n{\n    public static TUnit.Assertions.AssertionDecision Continue { get; }\n    public static TUnit.Assertions.AssertionDecision Pass { get; }\n    public static TUnit.Assertions.AssertionDecision Fail(string message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Test Metadata with Alternative Arguments in C#\nDESCRIPTION: This snippet further demonstrates the process of collecting test metadata by using different arguments for `SomeTest`. The second snippet follows a similar structure as the first one but uses 'B' as the method argument. The dependencies remain the same with similar output expectations of a `TestMetadata` list.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/EnumMemberNamesTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n\nprivate global::System.Collections.Generic.List<TestMetadata> Tests1(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1432.EnumMemberNamesTests),\n\t\t\tName = \"SomeTest\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"A\"),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"B\"),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"C\")\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t{\n\t\t\t\t\tName = \"value\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._1432.EnumMemberNamesTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1432.EnumMemberNamesTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"EnumMemberNamesTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"EnumMemberNamesTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"EnumMemberNamesTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._1432\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n\t\t};\n\n\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\tglobal::TUnit.TestProject.Bugs._1432.EnumMemberNamesTests? classInstance = null;\n\t\tobject?[]? classInstanceArguments = null;\n\t\tclassInstanceArguments = [];\n\n\t\tstring methodArg = \"B\";\n\n\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._1432.EnumMemberNamesTests>(() => \n\t\tnew global::TUnit.TestProject.Bugs._1432.EnumMemberNamesTests()\n\t\t, sessionId, testBuilderContext);\n\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._1432.EnumMemberNamesTests>\n\t\t{\n\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS1:TUnit.TestProject.Bugs._1432.EnumMemberNamesTests.SomeTest(string):0\",\n\t\t\tTestClassArguments = [],\n\t\t\tTestMethodArguments = [methodArg],\n\t\t\tTestClassProperties = [],\n\t\t\tCurrentRepeatAttempt = 0,\n\t\t\tRepeatLimit = 0,\n\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.SomeTest(methodArg)),\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 5,\n\t\t\tTestMethod = testInformation,\n\t\t\tTestBuilderContext = testBuilderContext,\n\t\t});\n\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\ttestBuilderContext = new();\n\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t}\n\tcatch (global::System.Exception exception)\n\t{\n\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._1432.EnumMemberNamesTests>\n\t\t{\n\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS1:TUnit.TestProject.Bugs._1432.EnumMemberNamesTests.SomeTest(string):0\",\n\t\t\tMethodName = $\"SomeTest\",\n\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"EnumMemberNamesTests.SomeTest failed to initialize\", exception),\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 5,\n\t\t});\n\t}\n\treturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTimeOffset Comparison Extensions in C#\nDESCRIPTION: Extension methods for DateTimeOffset comparisons in test assertions. These methods enable fluent validation of DateTimeOffset values with specific conditions like before/equal to and equality comparisons.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_113\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTimeOffset> IsBeforeOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTimeOffset> valueSource, System.DateTimeOffset expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\npublic static TUnit.Assertions.AssertionBuilders.Wrappers.DateTimeOffsetEqualToAssertionBuilderWrapper IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTimeOffset> valueSource, System.DateTimeOffset expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing BetweenAssertionBuilderWrapper Class in C#\nDESCRIPTION: This class wraps assertions for checking if a value is between two other values. It provides methods to specify inclusive or exclusive bounds.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic class BetweenAssertionBuilderWrapper<TActual> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>\n    where TActual : System.IComparable<TActual>\n{\n    public TUnit.Assertions.AssertionBuilders.Wrappers.BetweenAssertionBuilderWrapper<TActual> WithExclusiveBounds() { }\n    public TUnit.Assertions.AssertionBuilders.Wrappers.BetweenAssertionBuilderWrapper<TActual> WithInclusiveBounds() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Before Test Hooks in TUnit with C#\nDESCRIPTION: This C# snippet defines a method to collect 'BeforeTest' hooks, involving the TUnit framework. It includes details on method information, such as type, name, parameters, and hook attributes required to set up the test environment. The method depends on TUnit.Core and other related namespaces.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticBeforeEachTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n{\n    return\n    [\n        new global::TUnit.Core.Hooks.InstanceHookMethod\n        {\n            ClassType = typeof(global::TUnit.TestProject.BeforeTests.GlobalSetUpTests),\n            MethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n            {\n                Type = typeof(global::TUnit.TestProject.BeforeTests.GlobalSetUpTests),\n                Name = \"SetUp\",\n                GenericTypeCount = 0,\n                ReturnType = typeof(global::System.Threading.Tasks.Task),\n                Attributes = \n                [\n                    new global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n                ],\n                Parameters = [],\n                Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.GlobalSetUpTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n                {\n                    Type = typeof(global::TUnit.TestProject.BeforeTests.GlobalSetUpTests),\n                    Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"GlobalStaticBeforeEachTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n                    {\n                        Name = \"GlobalStaticBeforeEachTests\",\n                        Attributes = [],\n                    }),\n                    Name = \"GlobalSetUpTests\",\n                    Namespace = \"TUnit.TestProject.BeforeTests\",\n                    Attributes = [],\n                    Parameters = [],\n                    Properties = [],\n                }),\n    },\n                Body = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.BeforeTests.GlobalSetUpTests)classInstance).SetUp()),\n                HookExecutor = DefaultExecutor.Instance,\n                Order = 0,\n                MethodAttributes = \n                [\n                    new global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n                ],\n                ClassAttributes = [],\n                                    AssemblyAttributes = \n[],\n            },\n        };\n    }\n\n```\n\n----------------------------------------\n\nTITLE: String Assertion Classes\nDESCRIPTION: Classes for string comparison assertions including equals, not equals, and contains operations with various comparison options.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_49\n\nLANGUAGE: C#\nCODE:\n```\npublic class StringEqualsExpectedValueAssertCondition : ExpectedValueAssertCondition<string, string>\n{\n    public StringEqualsExpectedValueAssertCondition(string expected, System.StringComparison stringComparison) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(string? actualValue, string? expectedValue) { }\n    public StringEqualsExpectedValueAssertCondition IgnoringWhitespace() { }\n    public StringEqualsExpectedValueAssertCondition WithNullAndEmptyEquality() { }\n    public StringEqualsExpectedValueAssertCondition WithTrimming() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Boolean Assertion Extensions in C#\nDESCRIPTION: Static extension methods for boolean value assertions including equality checks and true/false validations. Supports both nullable and non-nullable boolean types.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_45\n\nLANGUAGE: C#\nCODE:\n```\npublic static class BooleanIsExtensions {\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool> IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool> valueSource, bool expected) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool?> IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool?> valueSource, bool expected) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool?> IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool?> valueSource, bool? expected) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EnumerableCount Generic Class in C#\nDESCRIPTION: Generic class for asserting conditions on enumerable collections. Provides methods for comparing collection counts and checking empty/non-empty states.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_143\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumerableCount<TActual, TInner>\n    where TActual : System.Collections.Generic.IEnumerable<TInner>\n{\n    public EnumerableCount(TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> Empty { get; }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> EqualTo(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> EqualToOne() { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> EqualToZero() { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> GreaterThan(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> GreaterThanOrEqualTo(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> LessThan(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> LessThanOrEqualTo(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> Negative() { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> Positive() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring TestMetadata for InheritedPropertySetterTests in TUnit\nDESCRIPTION: This code creates a TestMetadata object for a test in the InheritedPropertySetterTests class. It includes configuration for test identifiers, arguments, properties, and execution methods, as well as file path and line number information.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/InheritedPropertySetterTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nnodes.Add(new TestMetadata<global::TUnit.TestProject.InheritedPropertySetterTests>\n{\n\tTestId = $\"TUnit.TestProject.InheritedPropertySetterTests.Test:0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [],\n\tTestClassProperties = [propertyArg, propertyArg1, propertyArg2, propertyArg3, propertyArg4, propertyArg5],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Test()),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 70,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\nresettableClassFactory = resettableClassFactoryDelegate();\ntestBuilderContext = new();\ntestBuilderContextAccessor.Current = testBuilderContext;\n```\n\n----------------------------------------\n\nTITLE: Implementing String Constant Argument Test Source Generation in C#\nDESCRIPTION: Auto-generated source code that implements test source generation for string constant arguments. Handles test metadata creation and execution for string parameter tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ConstantArgumentsTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class ConstantArgumentsTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new ConstantArgumentsTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.ConstantArgumentsTests),\n\t\t\t\tName = \"String1\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"123\")\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"dummy\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.ConstantArgumentsTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.ConstantArgumentsTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"ConstantArgumentsTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"ConstantArgumentsTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"ConstantArgumentsTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: Test Metadata Generation for Method 0\nDESCRIPTION: Generates metadata for the first set of tests in NullableByteArgumentTests, mapping test methods to metadata objects using TUnit constructs. Handles nullable byte arguments, leveraging TUnit's source-generated method and class information.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/NullableByteArgumentTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n    global::System.Collections.Generic.List<TestMetadata> nodes = [];\n    var classDataIndex = 0;\n    var testMethodDataIndex = 0;\n    try\n    {\n        var testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n        {\n            Type = typeof(global::TUnit.TestProject.NullableByteArgumentTests),\n            Name = \"Test\",\n            GenericTypeCount = 0,\n            ReturnType = typeof(void),\n            Attributes = \n            [\n                new global::TUnit.Core.TestAttribute(),\n                new global::TUnit.Core.ArgumentsAttribute((byte)1),\n                new global::TUnit.Core.ArgumentsAttribute(null)\n            ],\n            Parameters = \n            [\n                new global::TUnit.Core.SourceGeneratedParameterInformation<byte?>\n                {\n                    Name = \"someByte\",\n                    Attributes = [],\n                },\n            ],\n            Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.NullableByteArgumentTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n            {\n                Type = typeof(global::TUnit.TestProject.NullableByteArgumentTests),\n                Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"NullableByteArgumentTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n                {\n                    Name = \"NullableByteArgumentTests\",\n                    Attributes = [],\n                }),\n                Name = \"NullableByteArgumentTests\",\n                Namespace = \"TUnit.TestProject\",\n                Attributes = [],\n                Parameters = [],\n                Properties = [],\n            }),\n};\n\n        var testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n        var testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n        global::TUnit.TestProject.NullableByteArgumentTests? classInstance = null;\n        object?[]? classInstanceArguments = null;\n        classInstanceArguments = [];\n\n        byte? methodArg = (byte)1;\n\n        var resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.NullableByteArgumentTests>(() => \n        new global::TUnit.TestProject.NullableByteArgumentTests()\n        , sessionId, testBuilderContext);\n        var resettableClassFactory = resettableClassFactoryDelegate();\n\n\n        nodes.Add(new TestMetadata<global::TUnit.TestProject.NullableByteArgumentTests>\n        {\n            TestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NullableByteArgumentTests.Test(byte?):0\",\n            TestClassArguments = [],\n            TestMethodArguments = [methodArg],\n            TestClassProperties = [],\n            CurrentRepeatAttempt = 0,\n            RepeatLimit = 0,\n            ResettableClassFactory = resettableClassFactory,\n            TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Test(methodArg)),\n            TestFilePath = @\"\",\n            TestLineNumber = 5,\n            TestMethod = testInformation,\n            TestBuilderContext = testBuilderContext,\n        });\n        resettableClassFactory = resettableClassFactoryDelegate();\n        testBuilderContext = new();\n        testBuilderContextAccessor.Current = testBuilderContext;\n    }\n    catch (global::System.Exception exception)\n    {\n        nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.NullableByteArgumentTests>\n        {\n            TestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NullableByteArgumentTests.Test(byte?):0\",\n            MethodName = $\"Test\",\n            Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"NullableByteArgumentTests.Test failed to initialize\", exception),\n            TestFilePath = @\"\",\n            TestLineNumber = 5,\n        });\n    }\n    return nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests via Static Runner - TUnit - C#\nDESCRIPTION: Defines the TUnitRunner static class, providing an asynchronous static method RunTests to execute tests with optional string arguments. Returned Task\\<int\\> supplies the test runner exit code. Serves as a conventional entrypoint for running TUnit-based test suites, supporting parameterized execution via command-line or programmatic calls. No external dependencies beyond TUnit and standard .NET task support.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class TUnitRunner\n{\n    public static System.Threading.Tasks.Task<int> RunTests(params string[] args) { }\n}\n```\n\n----------------------------------------\n\nTITLE: C# File and Module Setup for Source-Generated Tests with TUnit\nDESCRIPTION: This snippet configures the partial class as a module-initializable test source, registers it with SourceRegistrar, and defines the entry point for test collection via the CollectTests method. Required dependencies are TUnit.Core, standard .NET libraries, and the partial class pattern for test code generation. Inputs are optional, and outputs are registration side effects and accessible test metadata at runtime, allowing seamless reflection-based discovery and execution of tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ConstantArgumentsTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class ConstantArgumentsTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new ConstantArgumentsTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\t// ...method continues\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: JsonExtensions for Test Context Serialization\nDESCRIPTION: Extension methods that convert various test context objects to their corresponding JSON model representations for reporting and persistence purposes.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class JsonExtensions\n{\n    public static TUnit.Engine.Json.ExceptionJson ToJsonModel(this System.Exception exception) { }\n    public static TUnit.Engine.Json.TestAssemblyJson ToJsonModel(this TUnit.Core.AssemblyHookContext context) { }\n    public static TUnit.Engine.Json.TestClassJson ToJsonModel(this TUnit.Core.ClassHookContext context) { }\n    public static TUnit.Engine.Json.TestJson ToJsonModel(this TUnit.Core.TestContext context) { }\n    public static TUnit.Engine.Json.TestResultJson ToJsonModel(this TUnit.Core.TestResult result) { }\n    public static TUnit.Engine.Json.TestSessionJson ToJsonModel(this TUnit.Core.TestSessionContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic IsNot Assertions in C#\nDESCRIPTION: Defines extension methods for generic negative assertions, including checks for non-default values and inequality. Uses CallerArgumentExpression for improved error reporting.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_119\n\nLANGUAGE: C#\nCODE:\n```\npublic static class GenericIsNotExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsDefault<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotDefault<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.GenericNotEqualToAssertionBuilderWrapper<TActual> IsNotEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotEquatableOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Exception Handling in TUnit Test Initialization\nDESCRIPTION: This code handles exceptions during test initialization in TUnit, creating a FailedInitializationTest node with detailed test metadata. It captures the test ID, class type, method information, and the exception that occurred.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=TupleMethod_testMethodName=NamedTupleMethod.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedInitializationTest\n\t{\n\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS1:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.ClassTupleDataSourceDrivenTests(System.Int32,System.String,System.Boolean).DataSource_TupleMethod(System.Int32,System.String,System.Boolean):0\",\n\t\tTestClass = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests),\n\t\tReturnType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests).GetMethod(\"DataSource_TupleMethod\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]).ReturnType,\n\t\tParameterTypeFullNames = [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)],\n\t\tTestName = \"DataSource_TupleMethod\",\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 24,\n\t\tException = exception,\n\t});\n}\nreturn nodes;\n```\n\n----------------------------------------\n\nTITLE: TUnitRunner for Test Execution\nDESCRIPTION: A static class that provides the entry point for running TUnit tests, accepting command-line arguments and returning an exit code representing the test execution result.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class TUnitRunner\n{\n    public static System.Threading.Tasks.Task<int> RunTests(params string[] args) { }\n}\n```\n\n----------------------------------------\n\nTITLE: FilterParser for Processing Test Filters in TUnit Engine\nDESCRIPTION: Utility class for parsing and extracting test filters from execution context. This helps determine which tests should be executed based on filter criteria specified in the execution request.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic class FilterParser\n{\n    public FilterParser() { }\n    public string? GetTestFilter(Microsoft.Testing.Platform.Extensions.TestFramework.ExecuteRequestContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Positive Assertion Extensions in TUnit\nDESCRIPTION: Extension methods for asserting collection state and ordering in tests. Provides methods for checking emptiness, equivalence, and various ordering scenarios with support for custom comparers.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_129\n\nLANGUAGE: C#\nCODE:\n```\npublic static class CollectionsIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsEmpty<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsEquivalentTo<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.Collections.Generic.IEnumerable<TInner> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsEquivalentTo<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparer\")] string doNotPopulateThisValue2 = null)\n        where TActual : System.Collections.Generic.IEnumerable<TInner> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsEquivalentTo<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"collectionOrdering\")] string doNotPopulateThisValue2 = null)\n        where TActual : System.Collections.Generic.IEnumerable<TInner> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsEquivalentTo<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"collectionOrdering\")] string doNotPopulateThisValue2 = null)\n        where TActual : System.Collections.Generic.IEnumerable<TInner> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsInDescendingOrder<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsInDescendingOrder<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Collections.Generic.IComparer<TInner> comparer) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsInOrder<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsInOrder<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Collections.Generic.IComparer<TInner> comparer) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsOrderedBy<TInner, TComparisonItem>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, TComparisonItem> comparisonItemSelector, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparisonItemSelector\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsOrderedBy<TInner, TComparisonItem>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, TComparisonItem> comparisonItemSelector, System.Collections.Generic.IComparer<TComparisonItem> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparisonItemSelector\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparer\")] string doNotPopulateThisValue2 = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsOrderedByDescending<TInner, TComparisonItem>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, TComparisonItem> comparisonItemSelector, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparisonItemSelector\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsOrderedByDescending<TInner, TComparisonItem>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, TComparisonItem> comparisonItemSelector, System.Collections.Generic.IComparer<TComparisonItem> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparisonItemSelector\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparer\")] string doNotPopulateThisValue2 = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing Test Metadata Nodes with TUnit in C#\nDESCRIPTION: This snippet iterates over a sequence of test data, unpacks method arguments, initializes test class and execution context objects, and dynamically creates test metadata entries for TUnit. Dependencies include the TUnit.Core and System libraries, and assumes access to the target test class. It expects test data sources and supports up to 16 method arguments, furnishing each metadata entry with arguments, context, and an async method factory. Exceptions are logged as failed tests via a failure metadata node.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1538.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.Bugs._1538.Tests? classInstance = null;\nobject?[]? classInstanceArguments = null;\nforeach (var methodDataAccessor in global::TUnit.TestProject.Bugs._1538.Tests.SixteenItems())\n{\n    testMethodDataIndex++;\n    classInstanceArguments = [];\n\n    var methodData = methodDataAccessor;\n    var methodArgTuples = global::System.TupleExtensions.ToTuple<bool, string, string, string, string, string, string, string, string, string, string, string, string, string, string, string>(methodData);\n    bool methodArg = methodArgTuples.Item1;\n    string methodArg1 = methodArgTuples.Item2;\n    string methodArg2 = methodArgTuples.Item3;\n    string methodArg3 = methodArgTuples.Item4;\n    string methodArg4 = methodArgTuples.Item5;\n    string methodArg5 = methodArgTuples.Item6;\n    string methodArg6 = methodArgTuples.Item7;\n    string methodArg7 = methodArgTuples.Rest.Item1;\n    string methodArg8 = methodArgTuples.Rest.Item2;\n    string methodArg9 = methodArgTuples.Rest.Item3;\n    string methodArg10 = methodArgTuples.Rest.Item4;\n    string methodArg11 = methodArgTuples.Rest.Item5;\n    string methodArg12 = methodArgTuples.Rest.Item6;\n    string methodArg13 = methodArgTuples.Rest.Item7;\n    string methodArg14 = methodArgTuples.Rest.Rest.Item1;\n    string methodArg15 = methodArgTuples.Rest.Rest.Item2;\n    var resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._1538.Tests>(() => \n    new global::TUnit.TestProject.Bugs._1538.Tests()\n    , sessionId, testBuilderContext);\n    var resettableClassFactory = resettableClassFactoryDelegate();\n\n    nodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._1538.Tests>\n    {\n        TestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS0:{testMethodDataIndex}:TUnit.TestProject.Bugs._1538.Tests.SixteenArgs(bool,string,string,string,string,string,string,string,string,string,string,string,string,string,string,string):0\",\n        TestClassArguments = [],\n        TestMethodArguments = [methodArg, methodArg1, methodArg2, methodArg3, methodArg4, methodArg5, methodArg6, methodArg7, methodArg8, methodArg9, methodArg10, methodArg11, methodArg12, methodArg13, methodArg14, methodArg15],\n        TestClassProperties = [],\n        CurrentRepeatAttempt = 0,\n        RepeatLimit = 0,\n        ResettableClassFactory = resettableClassFactory,\n        TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.SixteenArgs(methodArg, methodArg1, methodArg2, methodArg3, methodArg4, methodArg5, methodArg6, methodArg7, methodArg8, methodArg9, methodArg10, methodArg11, methodArg12, methodArg13, methodArg14, methodArg15)),\n        TestFilePath = @\"\",\n        TestLineNumber = 13,\n        TestMethod = testInformation,\n        TestBuilderContext = testBuilderContext,\n    });\n    resettableClassFactory = resettableClassFactoryDelegate();\n    testBuilderContext = new();\n    testBuilderContextAccessor.Current = testBuilderContext;\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n    nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._1538.Tests>\n    {\n        TestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS0:{testMethodDataIndex}:TUnit.TestProject.Bugs._1538.Tests.SixteenArgs(bool,string,string,string,string,string,string,string,string,string,string,string,string,string,string,string):0\",\n        MethodName = $\"SixteenArgs\",\n        Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"Tests.SixteenArgs failed to initialize\", exception),\n        TestFilePath = @\"\",\n        TestLineNumber = 13,\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Boolean Assertion Extensions in C#\nDESCRIPTION: This static class provides extension methods for boolean assertions, including IsEqualTo, IsFalse, and IsTrue. These methods extend IValueSource<bool> and IValueSource<bool?> to create InvokableValueAssertionBuilder instances.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_125\n\nLANGUAGE: C#\nCODE:\n```\npublic static class BooleanIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool> IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool> valueSource, bool expected) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool?> IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool?> valueSource, bool expected) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool?> IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool?> valueSource, bool? expected) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool> IsFalse(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool?> IsFalse(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool?> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool> IsTrue(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool?> IsTrue(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool?> valueSource) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NullExpectedValueAssertCondition for TUnit Null Assertions (C#)\nDESCRIPTION: Defines the `NullExpectedValueAssertCondition` class, inheriting from `BaseAssertCondition`. This condition is used to assert that an actual value of type `TActual` is null.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_23\n\nLANGUAGE: csharp\nCODE:\n```\n    public class NullExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n    {\n        public NullExpectedValueAssertCondition() { }\n        protected override string GetExpectation() { }\n        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic TestDetails<T> Class in C# for TUnit Framework\nDESCRIPTION: This class extends TestDetails to provide a generic implementation for specific test class types. It includes a lazy-loaded class instance and overrides the ClassInstance property.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class TestDetails<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]  TClassType> : TUnit.Core.TestDetails, System.IEquatable<TUnit.Core.TestDetails<TClassType>>\n    where TClassType :  class\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public TestDetails() { }\n    public override object ClassInstance { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    [System.Text.Json.Serialization.JsonIgnore]\n    public TUnit.Core.ResettableLazy<TClassType> LazyClassInstance { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: String Pattern Matching Extension Methods for TUnit\nDESCRIPTION: Extension methods for string pattern matching in test assertions. Includes methods for checking if a string starts with, ends with, or matches a pattern using regular expressions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_60\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> EndsWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> EndsWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"stringComparison\")] string doNotPopulateThisValue2 = null) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> Matches(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, System.Text.RegularExpressions.Regex regex, [System.Runtime.CompilerServices.CallerArgumentExpression(\"regex\")] string expression = \"\") { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> Matches(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string regex, [System.Runtime.CompilerServices.CallerArgumentExpression(\"regex\")] string expression = \"\") { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> StartsWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> StartsWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"stringComparison\")] string doNotPopulateThisValue2 = null) { }\n```\n\n----------------------------------------\n\nTITLE: Initializing Nullable Byte Argument Tests\nDESCRIPTION: This snippet initializes the source generator for NullableByteArgumentTests using TUnit. It registers the test class, sets up necessary metadata, and prepares for test execution. Dependencies include the TUnit framework and C# runtime.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/NullableByteArgumentTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n    global::TUnit.Core.SourceRegistrar.Register(new NullableByteArgumentTests());\n}\n```\n\n----------------------------------------\n\nTITLE: Test Collection Implementation for Float Special Constants in C#\nDESCRIPTION: Auto-generated C# code that implements test collection for the Float_SpecialConsts test method. It registers test cases using matrix data sources with special float constants (NaN, PositiveInfinity, NegativeInfinity) and handles test initialization and execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests2085.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Tests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new Tests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._2085.Tests),\n\t\t\t\tName = \"Float_SpecialConsts\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.MatrixDataSourceAttribute()\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<float>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"d\",\n\t\t\t\t\t\tAttributes = \n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tnew global::TUnit.Core.MatrixAttribute(float.NaN, float.PositiveInfinity, float.NegativeInfinity)\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._2085.Tests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._2085.Tests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Tests2085\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"Tests2085\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"Tests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._2085\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.Bugs._2085.Tests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tvar methodArgDataGeneratorMetadata = new DataGeneratorMetadata\n\t\t\t\t{\n\t\t\t\t\tType = global::TUnit.Core.Enums.DataGeneratorType.TestParameters,\n\t\t\t\t\tTestBuilderContext = testBuilderContextAccessor,\n\t\t\t\t\tTestInformation = testInformation,\n\t\t\t\t\tMembersToGenerate = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<float>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"d\",\n\t\t\t\t\t\t\tAttributes = \n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew global::TUnit.Core.MatrixAttribute(float.NaN, float.PositiveInfinity, float.NegativeInfinity)\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tTestSessionId = sessionId,\n\t\t\t\t\tTestClassInstance = classInstance,\n\t\t\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t\t\t};\n\t\t\t\tvar methodDataAttribute = new global::TUnit.Core.MatrixDataSourceAttribute();\n\n\t\t\t\ttestBuilderContext.DataAttributes.Add(methodDataAttribute);\n\n\t\t\t\tvar methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\n\n\t\t\t\tforeach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\n\t\t\t\t{\n\t\t\t\t\ttestMethodDataIndex++;\n\t\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\t\tvar methodArgGeneratedData = methodArgGeneratedDataAccessor();\n\t\t\t\t\tfloat methodArg = global::TUnit.Core.Helpers.CastHelper.Cast<float>(methodArgGeneratedData[0]);\n\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._2085.Tests>(() => \n\t\t\t\t\tnew global::TUnit.TestProject.Bugs._2085.Tests()\n\t\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._2085.Tests>\n\t\t\t\t\t{\n\t\t\t\t\t\tTestId = $\"global::TUnit.Core.MatrixDataSourceAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.Bugs._2085.Tests.Float_SpecialConsts(float):0\",\n\t\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\t\tRepeatLimit = 0,\n```\n\n----------------------------------------\n\nTITLE: Applying a Custom Test Skipping Attribute (WindowsOnly) in TUnit - C#\nDESCRIPTION: This snippet applies the custom WindowsOnly attribute to a test method, causing it to run only on Windows platforms. It demonstrates combining TUnit.Core's Test attribute with the user-defined WindowsOnly attribute. Dependencies are TUnit.Core, the WindowsOnlyAttribute definition, and proper namespacing. Inputs are the test method and custom attribute; output is test execution conditional on OS.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/skip.md#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test, WindowsOnly]\n    public async Task MyTest()\n    {\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for Data-Driven Tests in C#\nDESCRIPTION: Code that builds test metadata for data-driven tests using ClassDataSourceAttribute. It creates and configures test methods with parameters supplied by data sources, setting up the test context and handling test initialization.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\ntry\n{\n\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t{\n\t\tType = typeof(global::TUnit.TestProject.ClassDataSourceDrivenTests),\n\t\tName = \"IsInitialized_With_1_ClassDataSource\",\n\t\tGenericTypeCount = 0,\n\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\tAttributes = \n\t\t[\n\t\t\tnew global::TUnit.Core.TestAttribute()\n\t\t],\n\t\tParameters = \n\t\t[\n\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.InitializableClass>\n\t\t\t{\n\t\t\t\tName = \"class1\",\n\t\t\t\tAttributes = [],\n\t\t\t},\n\t\t],\n\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.ClassDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.ClassDataSourceDrivenTests),\n\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"ClassDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t{\n\t\t\t\tName = \"ClassDataSourceDrivenTests\",\n\t\t\t\tAttributes = [],\n\t\t\t}),\n\t\t\tName = \"ClassDataSourceDrivenTests\",\n\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\tAttributes = [],\n\t\t\tParameters = [],\n\t\t\tProperties = [],\n\t\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: LogLevelProvider for Logging Configuration\nDESCRIPTION: A service that provides the current log level based on command line options, allowing for configurable verbosity in test output.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\npublic class LogLevelProvider\n{\n    public LogLevelProvider(Microsoft.Testing.Platform.CommandLine.ICommandLineOptions commandLineOptions) { }\n    public TUnit.Core.Enums.LogLevel LogLevel { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TestMetadata Generic Class in C#\nDESCRIPTION: This class extends TestMetadata and provides specific implementation for a generic class type. It includes a method factory and the ability to build test details.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_51\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestMetadata<TClassType> : TUnit.Core.TestMetadata, System.IEquatable<TUnit.Core.TestMetadata<TClassType>>\n    where TClassType :  class\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public TestMetadata() { }\n    public TUnit.Core.ResettableLazy<TClassType> ResettableClassFactory { get; init; }\n    public System.Func<TClassType, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask> TestMethodFactory { get; init; }\n    public override TUnit.Core.TestDetails BuildTestDetails() { }\n    public override TUnit.Core.TestMetadata CloneWithNewMethodFactory(System.Func<object, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask> testMethodFactory) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Negative Collection Assertion Methods for TUnit in C#\nDESCRIPTION: Extension methods for negative assertions on collections, including checks that collections are not empty or not equivalent. These methods provide the opposite functionality of their positive counterparts.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_106\n\nLANGUAGE: C#\nCODE:\n```\npublic static class CollectionsIsNotExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsNotEmpty<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotEquivalentTo<TActual, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.Collections.Generic.IEnumerable<TInner> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotEquivalentTo<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparer\")] string doNotPopulateThisValue2 = null)\n        where TActual : System.Collections.Generic.IEnumerable<TInner> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotEquivalentTo<TActual, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"collectionOrdering\")] string doNotPopulateThisValue2 = null)\n        where TActual : System.Collections.Generic.IEnumerable<TInner> { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ChainType Enum in C#\nDESCRIPTION: This enum defines the types of chains that can be used in assertions, including None, And, and Or.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic enum ChainType\n{\n    None = 0,\n    And = 1,\n    Or = 2,\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for ClassTupleDataSourceDrivenTests in C#\nDESCRIPTION: This snippet defines a method Tests0 that generates test metadata for the DataSource_TupleMethod test method. It creates test information, sets up class and method arguments, and constructs TestMetadata objects.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests),\n\t\t\tName = \"DataSource_TupleMethod\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\"),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t{\n\t\t\t\t\tName = \"value\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t{\n\t\t\t\t\tName = \"value2\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t\t\t{\n\t\t\t\t\tName = \"value3\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.ClassTupleDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\t// ... (class information details)\n\t\t\t}),\n\t\t};\n\n\t\t// ... (test setup and metadata creation)\n\n\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>\n\t\t{\n\t\t\t// ... (test metadata details)\n\t\t});\n\t}\n\tcatch (global::System.Exception exception)\n\t{\n\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>\n\t\t{\n\t\t\t// ... (failed test metadata details)\n\t\t});\n\t}\n\treturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Collection Equivalency Comparison in C#\nDESCRIPTION: Generic class implementing collection equivalency comparison with support for dynamic member access and custom comparison options\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_100\n\nLANGUAGE: C#\nCODE:\n```\npublic class CollectionEquivalentToEqualityComparer<T> : TUnit.Assertions.Equality.EquivalentToEqualityComparer<T>\n{\n    public CollectionEquivalentToEqualityComparer() { }\n    public CollectionEquivalentToEqualityComparer(TUnit.Assertions.CompareOptions compareOptions) { }\n    public override int? EnumerableIndex { get; protected set; }\n    public override bool Equals(T? x, T? y) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Comparable Value Assertions in TUnit (C#)\nDESCRIPTION: Extension methods for IComparable<T> types to verify value relationships. Includes methods for between, greater than, less than and their inclusive variations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_51\n\nLANGUAGE: C#\nCODE:\n```\npublic static class ComparableIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.BetweenAssertionBuilderWrapper<TActual> IsBetween<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual lowerBound, TActual upperBound, [System.Runtime.CompilerServices.CallerArgumentExpression(\"lowerBound\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"upperBound\")] string doNotPopulateThisValue2 = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsGreaterThan<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsGreaterThanOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsLessThan<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsLessThanOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GenericIsExtensions Class in C#\nDESCRIPTION: Static class providing type checking and equality comparison extension methods for assertions. Includes methods for type assignment, equality checking, and reference comparison.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_144\n\nLANGUAGE: C#\nCODE:\n```\npublic static class GenericIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsAssignableFrom(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource, System.Type type) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsAssignableFrom<TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsAssignableTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource, System.Type type) { }\n    public static TUnit.Assertions.AssertionBuilders.CastedAssertionBuilder<object, TExpected> IsAssignableTo<TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource) { }\n    // ... additional methods omitted for brevity\n```\n\n----------------------------------------\n\nTITLE: Implementing Logical Operators for Assertion Chaining\nDESCRIPTION: Defines classes for combining assertions with logical AND and OR operators, supporting both value and delegate assertion types.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_68\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DelegateAnd<TActual> : TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource, TUnit.Assertions.AssertConditions.Interfaces.ISource\n{\n    public DelegateAnd(TUnit.Assertions.AssertionBuilders.AssertionBuilder assertionBuilder) { }\n    public static TUnit.Assertions.AssertConditions.Operators.DelegateAnd<TActual> Create(TUnit.Assertions.AssertionBuilders.AssertionBuilder assertionBuilder) { }\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ValueOr<TActual> : TUnit.Assertions.AssertConditions.Interfaces.ISource, TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual>\n{\n    public ValueOr(TUnit.Assertions.AssertionBuilders.AssertionBuilder assertionBuilder) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Collection Method in TUnit\nDESCRIPTION: The main test collection method that aggregates test metadata from multiple test sources. It returns a read-only list of test metadata by combining results from multiple internal methods.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1889.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn\n\t[\n\t\t..Tests0(sessionId),\n\t\t..Tests1(sessionId),\n\t\t..Tests2(sessionId),\n\t\t..Tests3(sessionId),\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Test Hooks for AssemblyBase1 in TUnit\nDESCRIPTION: Auto-generated class implementing ITestHookSource to register test-level hooks for AssemblyBase1. It initializes and registers hooks with the SourceRegistrar and implements methods to collect hooks for different stages of test execution, with an AfterEach1 hook defined.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyAfterTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_AssemblyBase1 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_AssemblyBase1();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase1),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase1),\n\t\t\t\t\tName = \"AfterEach1\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.AssemblyBase1\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase1),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AssemblyAfterTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"AssemblyAfterTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"AssemblyBase1\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.AfterTests.AssemblyBase1)classInstance).AfterEach1()),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n```\n\n----------------------------------------\n\nTITLE: Defining TestFailedException for TUnit Engine\nDESCRIPTION: Custom exception class for handling test failures, extending the base TUnitException. It contains the original exception and provides a customized stack trace for better error reporting.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestFailedException : TUnit.Core.Exceptions.TUnitException\n{\n    public TestFailedException(System.Exception exception) { }\n    public override string StackTrace { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ITestSource for ConcreteClass2 in C#\nDESCRIPTION: This snippet defines a partial class ConcreteClass2 that implements ITestSource interface. It includes methods for initialization and test collection, focusing on the 'SecondTest' method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ConcreteClassTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class ConcreteClass2 : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new ConcreteClass2());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\t// ... (implementation details)\n\t}\n```\n\n----------------------------------------\n\nTITLE: Initializing Test Registration in TUnit Source Generator\nDESCRIPTION: Implements a module initializer that registers the source-generated test collector class with TUnit's runtime system. This ensures tests are discoverable at runtime.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1889.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tglobal::TUnit.Core.SourceRegistrar.Register(new Inherited_DerivedTest());\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Negative Assertion Extensions in DoesNotExtensions Class\nDESCRIPTION: Extension methods for negative assertions on strings, collections, and dictionaries. These methods verify that strings do not contain specific substrings or patterns, and collections do not contain specific elements.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_115\n\nLANGUAGE: C#\nCODE:\n```\npublic static class DoesNotExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> DoesNotContain(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> DoesNotContain(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"stringComparison\")] string doNotPopulateThisValue2 = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> DoesNotContain<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, bool> matcher, [System.Runtime.CompilerServices.CallerArgumentExpression(\"matcher\")] string? doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> DoesNotContain<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TInner expected, System.Collections.Generic.IEqualityComparer<TInner?>? equalityComparer = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null)\n        where TActual : System.Collections.Generic.IEnumerable<TInner> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TDictionary> DoesNotContainKey<TDictionary, TKey>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TDictionary> valueSource, TKey expected, System.Collections.Generic.IEqualityComparer<TKey> equalityComparer = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TDictionary : System.Collections.IDictionary { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TDictionary> DoesNotContainValue<TDictionary, TValue>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TDictionary> valueSource, TValue expected, System.Collections.Generic.IEqualityComparer<TValue> equalityComparer = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TDictionary : System.Collections.IDictionary { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> DoesNotEndWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> DoesNotEndWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"stringComparison\")] string doNotPopulateThisValue2 = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Number Assertion Extensions in C#\nDESCRIPTION: Extension methods for numeric assertions like checking divisibility, evenness, and positivity. Uses generic constraints to ensure numeric type compatibility.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_128\n\nLANGUAGE: C#\nCODE:\n```\npublic static class NumberIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsDivisibleBy<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.Numerics.INumber<TActual>, System.Numerics.IModulusOperators<TActual, TActual, TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsEven<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource)\n        where TActual : System.Numerics.INumber<TActual>, System.Numerics.IModulusOperators<TActual, TActual, TActual> { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for Generic Arguments Test in C#\nDESCRIPTION: Creates test metadata for a generic arguments test method. It includes test information, argument setup, and test metadata generation with error handling.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests2136.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.Bugs._2136.Tests),\n\t\t\tName = \"GenericArgumentsTest\",\n\t\t\tGenericTypeCount = 1,\n\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(true, \"True\"),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(1, \"1\"),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(1.1, \"1.1\"),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"hello\", \"hello\"),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(global::TUnit.TestProject.Bugs._2136.MyEnum.Item, \"Item\")\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<object>\n\t\t\t\t{\n\t\t\t\t\tName = \"value\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t{\n\t\t\t\t\tName = \"expected\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._2136.Tests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._2136.Tests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Tests2136\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"Tests2136\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"Tests\",\n\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._2136\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\tglobal::TUnit.TestProject.Bugs._2136.Tests? classInstance = null;\n\t\tobject?[]? classInstanceArguments = null;\n\t\tclassInstanceArguments = [];\n\n\t\tglobal::System.Boolean methodArg = true;\n\t\tstring methodArg1 = \"True\";\n\n\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._2136.Tests>(() => \n\t\tnew global::TUnit.TestProject.Bugs._2136.Tests()\n\t\t, sessionId, testBuilderContext);\n\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._2136.Tests>\n\t\t{\n\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.Bugs._2136.Tests.GenericArgumentsTest(T,string):0\",\n\t\t\tTestClassArguments = [],\n\t\t\tTestMethodArguments = [methodArg, methodArg1],\n\t\t\tTestClassProperties = [],\n\t\t\tCurrentRepeatAttempt = 0,\n\t\t\tRepeatLimit = 0,\n\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.GenericArgumentsTest(methodArg, methodArg1)),\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 8,\n\t\t\tTestMethod = testInformation,\n\t\t\tTestBuilderContext = testBuilderContext,\n\t\t});\n\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\ttestBuilderContext = new();\n\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t}\n\tcatch (global::System.Exception exception)\n\t{\n\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._2136.Tests>\n\t\t{\n\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.Bugs._2136.Tests.GenericArgumentsTest(T,string):0\",\n\t\t\tMethodName = $\"GenericArgumentsTest\",\n\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"Tests.GenericArgumentsTest failed to initialize\", exception),\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 8,\n\t\t});\n\t}\n\treturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Hook Registration in C#\nDESCRIPTION: Module initializer method that registers a new instance of the Hooks_SetupTests class with the SourceRegistrar. This ensures the test hooks are registered when the module loads.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeAllTests.Test.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n    var instance = new Hooks_SetupTests();\n    SourceRegistrar.RegisterTestHookSource(instance);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Hook Message Publisher Interface in C#\nDESCRIPTION: Defines the IHookMessagePublisher interface for publishing hook-related messages. It includes methods for discovering and pushing hook methods.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_51\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IHookMessagePublisher\n{\n    System.Threading.Tasks.Task Discover(string sessionId, string displayName, TUnit.Core.Hooks.StaticHookMethod hookMethod);\n    System.Threading.Tasks.Task Push(string sessionId, string displayName, TUnit.Core.Hooks.StaticHookMethod hookMethod, System.Func<System.Threading.Tasks.Task> func);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EnumerableSatisfiesAssertCondition<TActual, TInner, TExpected> Class in C#\nDESCRIPTION: This class provides assertion conditions for enumerable types, with methods for mapping and building assertions on individual elements.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumerableSatisfiesAssertCondition<TActual, TInner, TExpected> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n    where TActual : System.Collections.Generic.IEnumerable<TInner?>\n{\n    public EnumerableSatisfiesAssertCondition(System.Func<TInner?, System.Threading.Tasks.Task<TExpected>?> mapper, System.Func<TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TExpected?>, TUnit.Assertions.AssertionBuilders.IInvokableAssertionBuilder> assertionBuilder, string mapperExpression, string assertionBuilderExpression) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing String Contains Expected Value Assertion in C#\nDESCRIPTION: This class implements an assertion condition to check if a string contains an expected substring. It extends the ExpectedValueAssertCondition class and includes a StringComparison parameter for customizable string comparison.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_121\n\nLANGUAGE: C#\nCODE:\n```\npublic class StringContainsExpectedValueAssertCondition : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<string, string>\n{\n    public StringContainsExpectedValueAssertCondition(string expected, System.StringComparison stringComparison) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(string? actualValue, string? expectedValue) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Expected Value Assertion Condition Base Class in TUnit (C#)\nDESCRIPTION: This abstract generic class provides a foundation for assertion conditions that compare an actual value (`TActual`) against an expected value (`TExpected`). It stores the `ExpectedValue`, requires derived classes to implement the core comparison logic (`GetResult`), and provides hooks to customize the comparison (`WithComparer`) or transform values before comparison (`WithTransform`).\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_47\n\nLANGUAGE: csharp\nCODE:\n```\n    public abstract class ExpectedValueAssertCondition<TActual, TExpected> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n    {\n        protected ExpectedValueAssertCondition(TExpected? expected) { }\n        public TExpected ExpectedValue { get; }\n        protected abstract System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TExpected? expectedValue);\n        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n        public void WithComparer(System.Func<TActual?, TExpected?, TUnit.Assertions.AssertionDecision> comparer) { }\n        public void WithTransform(System.Func<TActual?, TActual?> actualTransformation, System.Func<TExpected?, TExpected?> expectedTransformation) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Initializing and Registering EnumerableDataSourceDrivenTests in C#\nDESCRIPTION: Defines a static Initialise method to register the EnumerableDataSourceDrivenTests class with TUnit's SourceRegistrar. This method is marked with the ModuleInitializer attribute to ensure it's called automatically.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/EnumerableDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tglobal::TUnit.Core.SourceRegistrar.Register(new EnumerableDataSourceDrivenTests());\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Comparable Negative Assertions in TUnit (C#)\nDESCRIPTION: Extension methods for IComparable<T> types that provide negative assertions. These verify that a value does NOT satisfy specified comparison conditions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_52\n\nLANGUAGE: C#\nCODE:\n```\npublic static class ComparableIsNotExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.NotBetweenAssertionBuilderWrapper<TActual> IsNotBetween<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual lowerBound, TActual upperBound, [System.Runtime.CompilerServices.CallerArgumentExpression(\"lowerBound\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"upperBound\")] string doNotPopulateThisValue2 = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotGreaterThan<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotGreaterThanOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotLessThan<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotLessThanOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing InvokableValueDelegateAssertionBuilder Generic Class in C#\nDESCRIPTION: This generic class represents an invokable value delegate assertion builder. It inherits from InvokableAssertionBuilder and includes properties for 'And' and 'Or' operators specific to value delegates.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_63\n\nLANGUAGE: C#\nCODE:\n```\npublic class InvokableValueDelegateAssertionBuilder<TActual> : TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TActual>\n{\n    public TUnit.Assertions.AssertConditions.Operators.ValueDelegateAnd<TActual> And { get; }\n    public TUnit.Assertions.AssertionBuilders.AssertionBuilder AssertionBuilder { get; }\n    public TUnit.Assertions.AssertConditions.Operators.ValueDelegateOr<TActual> Or { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Data-Driven Test for NonEmptyString Argument - TUnit - C#\nDESCRIPTION: This code snippet auto-generates registration for a C# unit test named 'NonEmptyString', applying TUnit's ArgumentsAttribute to provide a specific string parameter ('Foo bar!'). It constructs and registers the test metadata, sets method arguments, and handles both normal execution and test initialization failures. Requires TUnit.Core and project test types.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class DataDrivenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new DataDrivenTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.DataDrivenTests),\n\t\t\t\tName = \"NonEmptyString\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"Foo bar!\")\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.DataDrivenTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"DataDrivenTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"DataDrivenTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.DataDrivenTests? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tclassInstanceArguments = [];\n\n\t\t\tstring methodArg = \"Foo bar!\";\n\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.DataDrivenTests>(() => \n\t\t\tnew global::TUnit.TestProject.DataDrivenTests()\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.DataDrivenTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.DataDrivenTests.NonEmptyString(string):0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.NonEmptyString(methodArg)),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 46,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.DataDrivenTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.DataDrivenTests.NonEmptyString(string):0\",\n\t\t\t\tMethodName = $\"NonEmptyString\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"DataDrivenTests.NonEmptyString failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 46,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Core Interface Contracts for TUnit Test Infrastructure - C#\nDESCRIPTION: This set of code snippets defines marker interfaces used in the TUnit framework for accessing instance data, describing data attributes, and dynamically registering tests. Notably, IDynamicTestRegistrar defines a generic Register method with constraints and attributes to ensure proper discovery and composition. These interfaces enable test runtime plumbing and dynamic extension points, and have no direct implementation logic themselves.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IAccessesInstanceData { }\npublic interface IDataAttribute { }\npublic interface IDynamicTestRegistrar\n{\n    System.Threading.Tasks.Task Register<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicParameterlessConstructor | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]  TClass>(TUnit.Core.DynamicTest<TClass> dynamicTest)\n        where TClass :  class;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating TUnit Test Metadata for Class Data Source Driven Tests in C#\nDESCRIPTION: This auto-generated C# code defines a partial class `ClassDataSourceDrivenTests` that implements `ITestSource` for TUnit. The `CollectTests` method, implemented via `Tests0`, dynamically generates `TestMetadata` for the test method `IsInitialized_With_4_ClassDataSources`. It uses `ClassDataSourceAttribute` to fetch parameter data, constructs test information (method details, parameters, attributes), creates instances of the test class using a resettable factory, and populates a list of `TestMetadata` objects. It also includes error handling to capture initialization exceptions and report them as `FailedTestMetadata`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class ClassDataSourceDrivenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new ClassDataSourceDrivenTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.ClassDataSourceDrivenTests),\n\t\t\t\tName = \"IsInitialized_With_4_ClassDataSources\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute()\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.InitializableClass>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"class1\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.InitializableClass>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"class2\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.InitializableClass>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"class3\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.InitializableClass>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"class4\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.ClassDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.ClassDataSourceDrivenTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"ClassDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"ClassDataSourceDrivenTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"ClassDataSourceDrivenTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.ClassDataSourceDrivenTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tvar methodArgDataGeneratorMetadata = new DataGeneratorMetadata\n\t\t\t\t{\n\t\t\t\t\tType = global::TUnit.Core.Enums.DataGeneratorType.TestParameters,\n\t\t\t\t\tTestBuilderContext = testBuilderContextAccessor,\n\t\t\t\t\tTestInformation = testInformation,\n\t\t\t\t\tMembersToGenerate = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.InitializableClass>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"class1\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.InitializableClass>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"class2\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.InitializableClass>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"class3\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.InitializableClass>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"class4\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tTestSessionId = sessionId,\n\t\t\t\t\tTestClassInstance = classInstance,\n\t\t\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t\t\t};\n\t\t\t\tvar methodDataAttribute = new global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.InitializableClass, global::TUnit.TestProject.InitializableClass, global::TUnit.TestProject.InitializableClass, global::TUnit.TestProject.InitializableClass>();\n\n\t\t\t\ttestBuilderContext.DataAttributes.Add(methodDataAttribute);\n\n\t\t\t\tvar methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\n\n\t\t\t\tforeach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\n\t\t\t\t{\n\t\t\t\t\ttestMethodDataIndex++;\n\t\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\t\tvar methodArgGeneratedData = methodArgGeneratedDataAccessor();\n\t\t\t\t\tglobal::TUnit.TestProject.InitializableClass methodArg = methodArgGeneratedData.Item1;\n\t\t\t\t\tglobal::TUnit.TestProject.InitializableClass methodArg1 = methodArgGeneratedData.Item2;\n\t\t\t\t\tglobal::TUnit.TestProject.InitializableClass methodArg2 = methodArgGeneratedData.Item3;\n\t\t\t\t\tglobal::TUnit.TestProject.InitializableClass methodArg3 = methodArgGeneratedData.Item4;\n\n\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ClassDataSourceDrivenTests>(() => \n\t\t\t\t\tnew global::TUnit.TestProject.ClassDataSourceDrivenTests()\n\t\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.ClassDataSourceDrivenTests>\n\t\t\t\t\t{\n\t\t\t\t\t\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.InitializableClass, global::TUnit.TestProject.InitializableClass, global::TUnit.TestProject.InitializableClass, global::TUnit.TestProject.InitializableClass>:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.ClassDataSourceDrivenTests.IsInitialized_With_4_ClassDataSources(TUnit.TestProject.InitializableClass,TUnit.TestProject.InitializableClass,TUnit.TestProject.InitializableClass,TUnit.TestProject.InitializableClass):0\",\n\t\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\t\tTestMethodArguments = [methodArg, methodArg1, methodArg2, methodArg3],\n\t\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.IsInitialized_With_4_ClassDataSources(methodArg, methodArg1, methodArg2, methodArg3)),\n\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\tTestLineNumber = 48,\n\t\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t\t});\n\t\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\t\ttestBuilderContext = new();\n\t\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ClassDataSourceDrivenTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.InitializableClass, global::TUnit.TestProject.InitializableClass, global::TUnit.TestProject.InitializableClass, global::TUnit.TestProject.InitializableClass>:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.ClassDataSourceDrivenTests.IsInitialized_With_4_ClassDataSources(TUnit.TestProject.InitializableClass,TUnit.TestProject.InitializableClass,TUnit.TestProject.InitializableClass,TUnit.TestProject.InitializableClass):0\",\n\t\t\t\t\tMethodName = $\"IsInitialized_With_4_ClassDataSources\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ClassDataSourceDrivenTests.IsInitialized_With_4_ClassDataSources failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 48,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: TestClassJson Class for Test Class Serialization\nDESCRIPTION: JSON model class representing a test class with its contained tests. This provides a structured serialization format for test class information in the TUnit framework.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class TestClassJson : System.IEquatable<TUnit.Engine.Json.TestClassJson>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public TestClassJson() { }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Engine.Json.TestJson[] Tests { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string? Type { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning SetupBase Hook Method Body for Concrete GrandParentTests with Fixture in C#\nDESCRIPTION: This snippet assigns the body for the SetupBase hook implementation in a concrete GrandParentTests< MyFixture > class, calling its SetupBase method in a way compatible with the asynchronous test execution. Requires AsyncConvert and DefaultExecutor support, with the input as the class instance and presumed existence of SetupBase().\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Hooks1594.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.Bugs._1594.GrandParentTests<global::TUnit.TestProject.Bugs._1594.MyFixture>)classInstance).SetupBase()),\n```\n\n----------------------------------------\n\nTITLE: Managing Global Context for Test Execution in C#\nDESCRIPTION: Class for managing global test context, including console redirection and test filtering. Provides access to original console output/error writers and current context instance through a static property.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic class GlobalContext : TUnit.Core.Context\n{\n    public System.IO.TextWriter OriginalConsoleError { get; set; }\n    public System.IO.TextWriter OriginalConsoleOut { get; set; }\n    public string? TestFilter { get; }\n    public new static TUnit.Core.GlobalContext Current { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NotEquivalentToAssertionBuilderWrapper for Object Non-Equivalence Testing\nDESCRIPTION: Assertion builder for testing object non-equivalence with customization options. It supports ignoring specific properties and partial equivalence checking between objects.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_88\n\nLANGUAGE: C#\nCODE:\n```\npublic class NotEquivalentToAssertionBuilderWrapper<TActual, TExpected> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>\n{\n    public TUnit.Assertions.AssertionBuilders.Wrappers.NotEquivalentToAssertionBuilderWrapper<TActual, TExpected> IgnoringMember(string propertyName, [System.Runtime.CompilerServices.CallerArgumentExpression(\"propertyName\")] string doNotPopulateThis = \"\") { }\n    public TUnit.Assertions.AssertionBuilders.Wrappers.NotEquivalentToAssertionBuilderWrapper<TActual, TExpected> WithPartialEquivalency() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating TUnit Test Metadata for ClassDataSourceDrivenTestsSharedKeyed in C#\nDESCRIPTION: This code snippet creates test metadata for a data-driven test using ClassDataSourceAttribute. It sets up the test context, generates a unique test ID, and handles exceptions during test initialization. The code is part of a larger method that likely iterates over multiple test cases.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTestsSharedKeyed.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<SomeAsyncDisposableClass>:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.ClassDataSourceDrivenTestsSharedKeyed.DataSource_Class_Generic(SomeAsyncDisposableClass):0\",\nTestClassArguments = [],\nTestMethodArguments = [methodArgGeneratedData],\nTestClassProperties = [],\nCurrentRepeatAttempt = 0,\nRepeatLimit = 0,\nResettableClassFactory = resettableClassFactory,\nTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_Class_Generic(methodArgGeneratedData)),\nTestFilePath = @\"\",\nTestLineNumber = 14,\nTestMethod = testInformation,\nTestBuilderContext = testBuilderContext,\n});\nresettableClassFactory = resettableClassFactoryDelegate();\ntestBuilderContext = new();\ntestBuilderContextAccessor.Current = testBuilderContext;\n```\n\n----------------------------------------\n\nTITLE: Implementing Enum Assertion Conditions in C#\nDESCRIPTION: Defines various assertion conditions for enum types, including flag checks, name comparisons, and value comparisons.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_96\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumDoesNotHaveFlagAssertCondition<TEnum> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TEnum>\n    where TEnum : System.Enum\n{\n    public EnumDoesNotHaveFlagAssertCondition(TEnum expected) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TEnum? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n\n// ... (other enum assertion conditions)\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTimeOffset Assertions in C#\nDESCRIPTION: Extension methods for asserting DateTimeOffset values, including checks for being after, before, and their inclusive variants.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_112\n\nLANGUAGE: C#\nCODE:\n```\npublic static class DateTimeOffsetIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTimeOffset> IsAfter(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTimeOffset> valueSource, System.DateTimeOffset expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTimeOffset> IsAfterOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTimeOffset> valueSource, System.DateTimeOffset expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTimeOffset> IsBefore(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTimeOffset> valueSource, System.DateTimeOffset expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Boolean Assertion Extensions in TUnit\nDESCRIPTION: Extension methods for boolean value assertions including equality and state checking. The methods support both nullable and non-nullable boolean types and return assertion builder objects for further chaining.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_126\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool?> IsNotEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool?> valueSource, bool expected) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool?> IsNotEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool?> valueSource, bool? expected) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool> IsNotFalse(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool> valueSource) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool?> IsNotFalse(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool?> valueSource) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool> IsNotTrue(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool> valueSource) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool?> IsNotTrue(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool?> valueSource) { }\n```\n\n----------------------------------------\n\nTITLE: Defining ThrowsException Class for Exception Assertions in C#\nDESCRIPTION: This class provides methods for asserting exceptions in unit tests. It includes functionality for checking exception types, messages, and inner exceptions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_51\n\nLANGUAGE: C#\nCODE:\n```\npublic class ThrowsException<TActual, TException>\n    where TException : System.Exception\n{\n    public ThrowsException(TUnit.Assertions.AssertionBuilders.InvokableDelegateAssertionBuilder delegateAssertionBuilder, TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource source, System.Func<System.Exception?, System.Exception?> selector) { }\n    public TUnit.Assertions.AssertConditions.Operators.ValueAnd<TException> And { get; }\n    public TUnit.Assertions.AssertConditions.Operators.DelegateOr<object?> Or { get; }\n    public System.Runtime.CompilerServices.TaskAwaiter<TException?> GetAwaiter() { }\n    public TUnit.Assertions.AssertConditions.Throws.ThrowsException<TActual, System.Exception> WithInnerException() { }\n    public TUnit.Assertions.AssertConditions.Throws.ThrowsException<TActual, TException> WithMessage(string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public TUnit.Assertions.AssertConditions.Throws.ThrowsException<TActual, TException> WithMessageMatching(TUnit.Assertions.AssertConditions.StringMatcher match, [System.Runtime.CompilerServices.CallerArgumentExpression(\"match\")] string? doNotPopulateThisValue = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Aggregating TUnit Test Metadata Collections in C#\nDESCRIPTION: The `CollectTests` method implements the `ITestSource` interface requirement. It aggregates test metadata by invoking separate private helper methods (`Tests0`, `Tests1`, `Tests2`) for different argument sets and combines their results into a single read-only list of `TestMetadata` objects using collection expressions. The `sessionId` parameter, likely used for context or isolation, is passed down to these helper methods.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\t..Tests0(sessionId),\n\t\t\t..Tests1(sessionId),\n\t\t\t..Tests2(sessionId),\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Defining Test Session Hook Source Interface in C#\nDESCRIPTION: Defines an interface ITestSessionHookSource for collecting test session hooks in TUnit. It includes methods for before and after test session hooks.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_62\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ITestSessionHookSource\n{\n    System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.TestSessionContext>> CollectAfterTestSessionHooks(string sessionId);\n    System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.TestSessionContext>> CollectBeforeTestSessionHooks(string sessionId);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining That Assertion for Func<TActual> Delegate in C#\nDESCRIPTION: This generic overload of the static `That` method accepts a synchronous function `Func<TActual>` that returns a value. It returns a `ValueDelegateAssertionBuilder<TActual>` enabling assertions on the value returned by the function. The `CallerArgumentExpression` captures the source expression.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n        public static TUnit.Assertions.AssertionBuilders.ValueDelegateAssertionBuilder<TActual> That<TActual>(System.Func<TActual> value, [System.Runtime.CompilerServices.CallerArgumentExpression(\"value\")] string? doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Registering Asynchronous Tests using TUnit in C#\nDESCRIPTION: This code snippet manages the initialization and registration of asynchronous tests in the TUnit framework. It similarly employs a resettable class factory to handle test class instances. The code relies on TUnit.Core for its core functionality and supports asynchronous test execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/PolyfillTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class BasicTests : TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tSourceRegistrar.Register(new BasicTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testClassType = typeof(global::TUnit.TestProject.BasicTests);\n\t\t\tvar methodInfo = global::TUnit.Core.Helpers.MethodInfoRetriever.GetMethodInfo(typeof(global::TUnit.TestProject.BasicTests), \"AsynchronousTest\", 0, []);\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.BasicTests>(() => \n\t\t\tnew global::TUnit.TestProject.BasicTests()\n\t\t\t, sessionId, testBuilderContext);\n\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.BasicTests>\n\t\t\t{\n\t\t\t\tTestId = $\"TUnit.TestProject.BasicTests.AsynchronousTest:0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tMethodInfo = methodInfo,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.AsynchronousTest()),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 11,\n\t\t\t\tTestAttributes = [ new global::TUnit.Core.TestAttribute()\n{\n    \n} ],\n\t\t\t\tClassAttributes = [  ],\n\t\t\t\tAssemblyAttributes = [  ],\n\t\t\t\tDataAttributes = [  ],\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedInitializationTest\n\t\t\t{\n\t\t\t\tTestId = $\"TUnit.TestProject.BasicTests.AsynchronousTest:0\",\n\t\t\t\tTestClass = typeof(global::TUnit.TestProject.BasicTests),\n\t\t\t\tReturnType = global::TUnit.Core.Helpers.MethodInfoRetriever.GetMethodInfo(typeof(global::TUnit.TestProject.BasicTests), \"AsynchronousTest\", 0, []).ReturnType,\n\t\t\t\tParameterTypeFullNames = [],\n\t\t\t\tTestName = \"AsynchronousTest\",\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 11,\n\t\t\t\tException = exception,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FilterParser in C#\nDESCRIPTION: Defines a class for parsing test filters from the execution context.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic class FilterParser\n{\n    public FilterParser() { }\n    public string? GetTestFilter(Microsoft.Testing.Platform.Extensions.TestFramework.ExecuteRequestContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Boolean Assertion Extensions in C#\nDESCRIPTION: Extension methods for boolean value assertions with support for nullable types\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_102\n\nLANGUAGE: C#\nCODE:\n```\npublic static class BooleanIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool> IsTrue(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool?> IsTrue(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool?> valueSource) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining After Class Hook Method with CancellationToken Parameter\nDESCRIPTION: Implementation of the CollectAfterClassHooks method that returns a hook for the AfterAllCleanUp method. This hook accepts a CancellationToken parameter, allowing for cancellation of cleanup operations if needed.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterTests.Test.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterClassHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.AfterClassHookMethod\n\t\t{\n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.CleanupTests),\n\t\t\t\tName = \"AfterAllCleanUp\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.CleanupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.CleanupTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AfterTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"AfterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"CleanupTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.CleanupTests.AfterAllCleanUp(cancellationToken)),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tFilePath = @\"\",\n\t\t\t\tLineNumber = 62,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\tAssemblyAttributes = [],\n\t\t\t},\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata with Data Sources in TUnit\nDESCRIPTION: Method that creates test metadata for a specific test method with data sources. It handles class instantiation, parameter generation using AutoFixtureGeneratorAttribute, and creates test runners with the generated data.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.Typed.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.DataSourceGeneratorTests),\n\t\t\tName = \"GeneratedData_Method3\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute()\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t{\n\t\t\t\t\tName = \"value\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t{\n\t\t\t\t\tName = \"value2\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t\t\t{\n\t\t\t\t\tName = \"value3\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.DataSourceGeneratorTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.DataSourceGeneratorTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataSourceGeneratorTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"DataSourceGeneratorTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"DataSourceGeneratorTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value2\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value3\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\tglobal::TUnit.TestProject.DataSourceGeneratorTests? classInstance = null;\n\t\tobject?[]? classInstanceArguments = null;\n\t\tvar classArgDataGeneratorMetadata = new DataGeneratorMetadata\n\t\t{\n\t\t\tType = global::TUnit.Core.Enums.DataGeneratorType.ClassParameters,\n\t\t\tTestBuilderContext = testBuilderContextAccessor,\n\t\t\tTestInformation = testInformation,\n\t\t\tMembersToGenerate = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t{\n\t\t\t\t\tName = \"value\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t{\n\t\t\t\t\tName = \"value2\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t\t\t{\n\t\t\t\t\tName = \"value3\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tTestSessionId = sessionId,\n\t\t\tTestClassInstance = classInstance,\n\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t};\n\t\tvar classDataAttribute = new global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<int, string, bool>();\n\n\t\ttestBuilderContext.DataAttributes.Add(classDataAttribute);\n\n\t\tvar classArgGeneratedDataArray = classDataAttribute.GenerateDataSources(classArgDataGeneratorMetadata);\n\n\t\tforeach (var classArgGeneratedDataAccessor in classArgGeneratedDataArray)\n\t\t{\n\t\t\tclassDataIndex++;\n\t\t\tvar methodArgDataGeneratorMetadata = new DataGeneratorMetadata\n\t\t\t{\n\t\t\t\tType = global::TUnit.Core.Enums.DataGeneratorType.TestParameters,\n\t\t\t\tTestBuilderContext = testBuilderContextAccessor,\n\t\t\t\tTestInformation = testInformation,\n\t\t\t\tMembersToGenerate = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value2\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value3\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tTestSessionId = sessionId,\n\t\t\t\tTestClassInstance = classInstance,\n\t\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t\t};\n\t\t\tvar methodDataAttribute = new global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute();\n\n\t\t\ttestBuilderContext.DataAttributes.Add(methodDataAttribute);\n\n\t\t\tvar methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\n\n\t\t\tforeach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\n\t\t\t{\n\t\t\t\ttestMethodDataIndex++;\n\t\t\t\tvar classArgGeneratedData = classArgGeneratedDataAccessor();\n\t\t\t\tint classArg = classArgGeneratedData.Item1;\n\t\t\t\tstring classArg1 = classArgGeneratedData.Item2;\n\t\t\t\tbool classArg2 = classArgGeneratedData.Item3;\n\n\t\t\t\tclassInstanceArguments = [classArg, classArg1, classArg2];\n\n\t\t\t\tvar methodArgGeneratedData = methodArgGeneratedDataAccessor();\n\t\t\t\tint methodArg = methodArgGeneratedData.Item1;\n\t\t\t\tstring methodArg1 = methodArgGeneratedData.Item2;\n\t\t\t\tbool methodArg2 = methodArgGeneratedData.Item3;\n\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.DataSourceGeneratorTests>(() => \n\t\t\t\tnew global::TUnit.TestProject.DataSourceGeneratorTests(classArg, classArg1, classArg2)\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.DataSourceGeneratorTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<int, string, bool>:{classDataIndex}:CL-GAC0:global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.DataSourceGeneratorTests(int,string,bool).GeneratedData_Method3(int,string,bool):0\",\n\t\t\t\t\tTestClassArguments = [classArg, classArg1, classArg2],\n\t\t\t\t\tTestMethodArguments = [methodArg, methodArg1, methodArg2],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.GeneratedData_Method3(methodArg, methodArg1, methodArg2)),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 25,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t}\n\t}\n\tcatch (global::System.Exception exception)\n\t{\n\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.DataSourceGeneratorTests>\n\t\t{\n\t\t\tTestId = $\"global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<int, string, bool>:{classDataIndex}:CL-GAC0:global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.DataSourceGeneratorTests(int,string,bool).GeneratedData_Method3(int,string,bool):0\",\n\t\t\tMethodName = $\"GeneratedData_Method3\",\n\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"DataSourceGeneratorTests.GeneratedData_Method3 failed to initialize\", exception),\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 25,\n\t\t});\n\t}\n\treturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DelegateExtensions for Completion Time Assertions in C#\nDESCRIPTION: Static extension methods that provide assertion capabilities for checking if delegates complete within a specified time span, with overloads for both void and value-returning delegates.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_99\n\nLANGUAGE: C#\nCODE:\n```\n    public static class DelegateExtensions\n    {\n        public static TUnit.Assertions.AssertionBuilders.InvokableDelegateAssertionBuilder CompletesWithin(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource, System.TimeSpan timeSpan, [System.Runtime.CompilerServices.CallerArgumentExpression(\"timeSpan\")] string? doNotPopulateThisValue = null) { }\n        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> CompletesWithin<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueDelegateSource<TActual> delegateSource, System.TimeSpan timeSpan, [System.Runtime.CompilerServices.CallerArgumentExpression(\"timeSpan\")] string? doNotPopulateThisValue = null) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Instantiating a Parameterized TUnit Test Node for Test3 in CustomDisplayNameTests (C#)\nDESCRIPTION: This snippet dynamically constructs and registers a parameterized test node for the method Test3 on the CustomDisplayNameTests class, injecting specific argument values and creating metadata describing the test's attributes, argument values, and corresponding factory delegates for both the test class instance and method execution. It leverages TUnit's source-generated type information and populates test containers with precise details so that TUnit can run the test with the intended data. The process handles errors by adding a FailedTestMetadata node if initialization fails.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/CustomDisplayNameTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nnodes.Add(new TestMetadata<global::TUnit.TestProject.CustomDisplayNameTests>\n{\n\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.CustomDisplayNameTests.Test3(string,int,bool):0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [methodArg, methodArg1, methodArg2],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Test3(methodArg, methodArg1, methodArg2)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 26,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Class Constructor Attributes and Metadata in C#\nDESCRIPTION: Defines attributes and metadata for class constructors in tests. Includes generic and non-generic attributes for registering class constructors and metadata for test class instantiation.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class ClassConstructorAttribute : TUnit.Core.TestDataAttribute\n{\n    public abstract System.Type ClassConstructorType { get; }\n}\n\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class)]\npublic sealed class ClassConstructorAttribute<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]  T> : TUnit.Core.ClassConstructorAttribute\n    where T : TUnit.Core.Interfaces.IClassConstructor, new ()\n{\n    public ClassConstructorAttribute() { }\n    public override System.Type ClassConstructorType { get; }\n}\n\n[System.Runtime.CompilerServices.RequiredMember]\npublic class ClassConstructorMetadata : System.IEquatable<TUnit.Core.ClassConstructorMetadata>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public ClassConstructorMetadata() { }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Core.TestBuilderContext TestBuilderContext { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string TestSessionId { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Before and After Class Hooks in TUnit\nDESCRIPTION: Methods that collect different types of hook methods for the test class. The implementation shown here returns collections of hook methods that will be executed at various points in the test lifecycle, with empty collections for everything except after-class hooks.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId)\n{\n\treturn\n\t[\n\t];\n}\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterEveryClassHooks(string sessionId)\n{\n\treturn\n\t[\n\t];\n}\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeClassHooks(string sessionId)\n{\n\treturn\n\t[\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Not Assignable To Expected Value Assertion in C#\nDESCRIPTION: This class implements an assertion condition to check if a value is not assignable to an expected type. It extends the BaseAssertCondition class and overrides methods to provide custom assertion logic.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_117\n\nLANGUAGE: C#\nCODE:\n```\npublic class NotAssignableToExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n{\n    public NotAssignableToExpectedValueAssertCondition(System.Type expectedType) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Count Validation for Enumerable Collections in C#\nDESCRIPTION: Classes for validating the count of elements in an enumerable collection. Both equality and inequality conditions are provided to check if the number of elements matches or differs from an expected value.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumerableCountEqualToExpectedValueAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, int>\n    where TActual : System.Collections.Generic.IEnumerable<TInner>\n{\n    public EnumerableCountEqualToExpectedValueAssertCondition(int expected) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, int count) { }\n}\n\npublic class EnumerableCountNotEqualToExpectedValueAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, int>\n    where TActual : System.Collections.Generic.IEnumerable<TInner>\n{\n    public EnumerableCountNotEqualToExpectedValueAssertCondition(int expected) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, int count) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Wildcard Matching with Case Sensitivity\nDESCRIPTION: Method to configure case sensitivity for wildcard matching in string assertions, returning the matcher for fluent API chaining.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic TUnit.Assertions.AssertConditions.StringMatcher.WildcardMatch IgnoringCase(bool ignoreCase = true) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing GenericEqualToAssertionBuilderWrapper in C#\nDESCRIPTION: Generic wrapper for equality assertions that can work with any type without additional configuration options.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_88\n\nLANGUAGE: C#\nCODE:\n```\n    public class GenericEqualToAssertionBuilderWrapper<TActual> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> { }\n```\n\n----------------------------------------\n\nTITLE: Defining StaticHookMethod Abstract Class in C#\nDESCRIPTION: Abstract base class for static hook methods with required members including assembly info, attributes, and hook execution properties.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_55\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class StaticHookMethod : System.IEquatable<TUnit.Core.Hooks.StaticHookMethod>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of your compiler.\", true)]\n    protected StaticHookMethod() { }\n    public System.Reflection.Assembly Assembly { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Attribute[] AssemblyAttributes { get; init; }\n    public System.Collections.Generic.IEnumerable<System.Attribute> Attributes { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Attribute[] ClassAttributes { get; init; }\n    public System.Type ClassType { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string FilePath { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Core.Interfaces.IHookExecutor HookExecutor { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public int LineNumber { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Attribute[] MethodAttributes { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Core.SourceGeneratedMethodInformation MethodInfo { get; init; }\n    public string Name { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public int Order { get; init; }\n    public System.TimeSpan? Timeout { get; }\n    public TAttribute? GetAttribute<TAttribute>()\n        where TAttribute : System.Attribute { }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering and Initializing Test Metadata with TUnit in C#\nDESCRIPTION: This snippet creates a SourceGeneratedClassInformation instance representing the test class, sets up its assembly and property metadata, and registers the class for use in the test discovery process. Dependencies include TUnit.Core and related types, and the expected input is the fully qualified class name; the output is a populated Class metadata object suitable for test registration. The pattern ensures that test context is available and metadata is cached for efficient test discovery.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ConstantArgumentsTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.ConstantArgumentsTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n{\n\tType = typeof(global::TUnit.TestProject.ConstantArgumentsTests),\n\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"ConstantArgumentsTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t{\n\t\tName = \"ConstantArgumentsTests\",\n\t\tAttributes = [],\n\t}),\n\tName = \"ConstantArgumentsTests\",\n\tNamespace = \"TUnit.TestProject\",\n\tAttributes = [],\n\tParameters = [],\n\tProperties = [],\n}),\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Data Source Generator Attributes in C#\nDESCRIPTION: Abstract base classes for generating test data with generic type parameters. Supports up to 5 type parameters with constraints requiring default constructors.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\npublic abstract class DataSourceGeneratorAttribute<T1, T2, T3, T4, T5> : TUnit.Core.TestDataAttribute, TUnit.Core.IDataAttribute\n{\n    protected DataSourceGeneratorAttribute() { }\n    public abstract System.Collections.Generic.IEnumerable<System.Func<System.ValueTuple<T1, T2, T3, T4, T5>>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining After Class Hook Method with Context Parameter\nDESCRIPTION: Implementation of the CollectAfterClassHooks method that returns a hook for the AfterAllCleanUpWithContext method. This hook accepts a ClassHookContext parameter, allowing access to test context information during cleanup operations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterTests.Test.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterClassHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.AfterClassHookMethod\n\t\t{\n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.CleanupTests),\n\t\t\t\tName = \"AfterAllCleanUpWithContext\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.ClassHookContext>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"context\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.CleanupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.CleanupTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AfterTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"AfterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"CleanupTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.CleanupTests.AfterAllCleanUpWithContext(context)),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tFilePath = @\"\",\n\t\t\t\tLineNumber = 56,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\tAssemblyAttributes = [],\n\t\t\t},\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Defining PageTest Class in Playwright C#\nDESCRIPTION: Creates a \"PageTest\" class, extending the \"ContextTest\" to include page-level operations in browser tests with Playwright. It adds a page setup method for initialization before tests, extending the Playwright C# test framework.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic class PageTest : TUnit.Playwright.ContextTest\n    {\n        public PageTest() { }\n        public Microsoft.Playwright.IPage Page { get; }\n        [TUnit.Core.Before(TUnit.Core.HookType.Test, \"\", 0)]\n        public System.Threading.Tasks.Task PageSetup() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Generating Matrix Test Metadata for Method4\nDESCRIPTION: This snippet generates test metadata for the Method4 of MatrixTests class. It creates test metadata using matrix data sources and handles class instantiation and method execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MatrixTests.Test.verified.txt#2025-04-22_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nnodes.Add(new TestMetadata<global::TUnit.TestProject.MatrixTests>\n{\n\tTestId = $\"global::TUnit.Core.MatrixDataSourceAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.MatrixTests.Method4(int):0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [methodArg],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Method4(methodArg)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 141,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Comparison Failures in C#\nDESCRIPTION: The 'ComparisonFailure' class represents a failed comparison between expected and actual values. It includes information about the mismatched values and nested member names. The class is marked obsolete for certain constructors.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember] public class ComparisonFailure : System.IEquatable<TUnit.Assertions.ComparisonFailure> { [System.Obsolete(\"Constructors of types with required members are not supported in this version of your compiler.\", true)] public ComparisonFailure() { } [System.Runtime.CompilerServices.RequiredMember] public object? Actual { get; init; } [System.Runtime.CompilerServices.RequiredMember] public object? Expected { get; init; } [System.Runtime.CompilerServices.RequiredMember] public string[] NestedMemberNames { get; init; } [System.Runtime.CompilerServices.RequiredMember] public TUnit.Assertions.MemberType Type { get; init; } }\n```\n\n----------------------------------------\n\nTITLE: Implementing Not Default Expected Value Assertion in C#\nDESCRIPTION: This class implements an assertion condition to check if a value is not the default value for its type. It extends the ExpectedValueAssertCondition class and overrides methods to provide custom assertion logic.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_118\n\nLANGUAGE: C#\nCODE:\n```\npublic class NotDefaultExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TActual>\n{\n    public NotDefaultExpectedValueAssertCondition() { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TActual? expectedValue) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Assembly Hooks for AssemblyBase1 in TUnit\nDESCRIPTION: Auto-generated class implementing IAssemblyHookSource to register assembly-level hooks for AssemblyBase1. It initializes and registers hooks with the SourceRegistrar and implements methods to collect hooks for different stages of assembly execution, with an AfterAll1 hook defined.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyAfterTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_AssemblyBase1 : global::TUnit.Core.Interfaces.SourceGenerator.IAssemblyHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_AssemblyBase1();\n\t\tSourceRegistrar.RegisterAssemblyHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectBeforeEveryAssemblyHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectAfterEveryAssemblyHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectBeforeAssemblyHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectAfterAssemblyHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.AfterAssemblyHookMethod\n\t\t\t{ \n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase1),\n\t\t\t\tName = \"AfterAll1\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Assembly)\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.AssemblyBase1\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase1),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AssemblyAfterTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"AssemblyAfterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"AssemblyBase1\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.AssemblyBase1.AfterAll1()),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tFilePath = @\"\",\n\t\t\t\tLineNumber = 5,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Assembly)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\tAssemblyAttributes = [],\n\t\t\t},\n\t\t];\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Equivalency in C#\nDESCRIPTION: This snippet defines the 'CheckEquivalent' method, which checks for the equivalency of two objects with specified comparison options and an optional index. This is intended for assertions in unit tests where objects are compared for equivalency instead of strict equality.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic static System.Collections.Generic.IEnumerable<TUnit.Assertions.ComparisonFailure> CheckEquivalent<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)] TActual, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)] TExpected>(TActual actual, TExpected expected, TUnit.Assertions.CompareOptions options, int? index) { }\n```\n\n----------------------------------------\n\nTITLE: Defining CompareOptions Class in C#\nDESCRIPTION: Defines the `CompareOptions` class used to configure the object comparison behavior within the `Compare.CheckEquivalent` method. It allows specifying the `EquivalencyKind` (e.g., strict, lenient) and an array of `MembersToIgnore` during the comparison. Implements `IEquatable`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_32\n\nLANGUAGE: csharp\nCODE:\n```\n    public class CompareOptions : System.IEquatable<TUnit.Assertions.CompareOptions>\n    {\n        public CompareOptions() { }\n        public TUnit.Assertions.Enums.EquivalencyKind EquivalencyKind { get; set; }\n        public string[] MembersToIgnore { get; init; }\n    }\n```\n\n----------------------------------------\n\nTITLE: String and Collection Contains Methods for TUnit Assertions\nDESCRIPTION: Extension methods that check if a string contains a substring or if a collection contains specific elements. Includes overloads for string comparison options and custom equality comparers for collections.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_57\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.Wrappers.StringContainsAssertionBuilderWrapper Contains(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\npublic static TUnit.Assertions.AssertionBuilders.Wrappers.StringContainsAssertionBuilderWrapper Contains(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"stringComparison\")] string doNotPopulateThisValue2 = null) { }\npublic static TUnit.Assertions.AssertionBuilders.MappableResultAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>, TUnit.Assertions.AssertConditions.Collections.EnumerableContainsExpectedFuncAssertCondition<System.Collections.Generic.IEnumerable<TInner>, TInner>, TInner> Contains<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, bool> matcher, [System.Runtime.CompilerServices.CallerArgumentExpression(\"matcher\")] string doNotPopulateThisValue = null) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> Contains<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TInner expected, System.Collections.Generic.IEqualityComparer<TInner> equalityComparer = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n    where TActual : System.Collections.Generic.IEnumerable<TInner> { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ITestHookSource for GrandParentTests Generic Class in C#\nDESCRIPTION: Auto-generated partial class that implements ITestHookSource for the GrandParentTests<T> generic class. It registers the SetupBase method as a before-test hook for test classes in a class inheritance hierarchy.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Hooks1594.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_GrandParentTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_GrandParentTests();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.Bugs._1594.GrandParentTests<>),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1594.GrandParentTests<>),\n\t\t\t\t\tName = \"SetupBase\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(void),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n```\n\n----------------------------------------\n\nTITLE: Collecting Tests for ClassDataSourceDrivenTests2\nDESCRIPTION: Collects all tests for the ClassDataSourceDrivenTests2 class. It combines the results of multiple test collection methods.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests2.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn\n\t[\n\t\t..Tests0(sessionId),\n\t\t..Tests1(sessionId),\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NotBetweenAssertionBuilderWrapper for Range Exclusion Testing\nDESCRIPTION: Specialized assertion builder for checking if values fall outside a range. It supports both inclusive and exclusive bounds for the exclusion range.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_87\n\nLANGUAGE: C#\nCODE:\n```\npublic class NotBetweenAssertionBuilderWrapper<TActual> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>\n    where TActual : System.IComparable<TActual>\n{\n    public TUnit.Assertions.AssertionBuilders.Wrappers.NotBetweenAssertionBuilderWrapper<TActual> WithExclusiveBounds() { }\n    public TUnit.Assertions.AssertionBuilders.Wrappers.NotBetweenAssertionBuilderWrapper<TActual> WithInclusiveBounds() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IWorkerService Interface in C#\nDESCRIPTION: Describes the \"IWorkerService\" interface indicating the required asynchronous operations like dispose and reset for worker services. It is central to managing resources during test execution, especially for clean-up and re-initialization tasks in the Playwright testing environment.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IWorkerService\n    {\n        System.Threading.Tasks.Task DisposeAsync();\n        System.Threading.Tasks.Task ResetAsync();\n    }\n```\n\n----------------------------------------\n\nTITLE: Test Collection Method for RepeatTests.Three Method\nDESCRIPTION: The Tests0 method that generates test metadata for the RepeatTests.Three test method. It initializes test contexts, creates a resettable class factory, and handles exceptions during initialization.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/RepeatTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.RepeatTests),\n\t\t\tName = \"Three\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute()\n\t\t\t],\n\t\t\tParameters = [],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.RepeatTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.RepeatTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"RepeatTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"RepeatTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"RepeatTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.RepeatAttribute(3)\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\tglobal::TUnit.TestProject.RepeatTests? classInstance = null;\n\t\tobject?[]? classInstanceArguments = null;\n\t\tclassInstanceArguments = [];\n\n\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.RepeatTests>(() => \n\t\tnew global::TUnit.TestProject.RepeatTests()\n\t\t, sessionId, testBuilderContext);\n\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.RepeatTests>\n\t\t{\n\t\t\tTestId = $\"TUnit.TestProject.RepeatTests.Three:0\",\n\t\t\tTestClassArguments = [],\n\t\t\tTestMethodArguments = [],\n\t\t\tTestClassProperties = [],\n\t\t\tCurrentRepeatAttempt = 0,\n\t\t\tRepeatLimit = 3,\n\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Three()),\n```\n\n----------------------------------------\n\nTITLE: Setting Up Test Builder Context and Data Generation in C#\nDESCRIPTION: This snippet initializes the test builder context, sets up data generation metadata, and creates a ClassDataSourceAttribute for generating test data. It prepares the environment for running multiple iterations of the test with different data.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.ClassDataSourceDrivenTests? classInstance = null;\nobject?[]? classInstanceArguments = null;\nvar methodArgDataGeneratorMetadata = new DataGeneratorMetadata\n{\n\tType = global::TUnit.Core.Enums.DataGeneratorType.TestParameters,\n\tTestBuilderContext = testBuilderContextAccessor,\n\tTestInformation = testInformation,\n\tMembersToGenerate = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.InitializableClass>\n\t\t{\n\t\t\tName = \"class1\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.InitializableClass>\n\t\t{\n\t\t\tName = \"class2\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.InitializableClass>\n\t\t{\n\t\t\tName = \"class3\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.InitializableClass>\n\t\t{\n\t\t\tName = \"class4\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.InitializableClass>\n\t\t{\n\t\t\tName = \"class5\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n\tTestSessionId = sessionId,\n\tTestClassInstance = classInstance,\n\tClassInstanceArguments = classInstanceArguments,\n};\nvar methodDataAttribute = new global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.InitializableClass, global::TUnit.TestProject.InitializableClass, global::TUnit.TestProject.InitializableClass, global::TUnit.TestProject.InitializableClass, global::TUnit.TestProject.InitializableClass>();\n\ntestBuilderContext.DataAttributes.Add(methodDataAttribute);\n\nvar methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\n```\n\n----------------------------------------\n\nTITLE: Defining ExpectedValueAssertCondition<TActual, TExpected> Abstract Class in C#\nDESCRIPTION: This abstract class provides a base for assertion conditions that compare actual values against expected values, with support for custom comparers.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ExpectedValueAssertCondition<TActual, TExpected> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n{\n    protected ExpectedValueAssertCondition(TExpected? expected) { }\n    public TExpected ExpectedValue { get; }\n    protected abstract System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TExpected? expectedValue);\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n    public void WithComparer(System.Func<TActual?, TExpected?, TUnit.Assertions.AssertionDecision> comparer) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Before Test Hook Method in C#\nDESCRIPTION: Defines the BeforeTestHookMethod class which executes before a test is run. It inherits from StaticHookMethod and implements IEquatable.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_47\n\nLANGUAGE: C#\nCODE:\n```\npublic class BeforeTestHookMethod : TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.TestContext>, System.IEquatable<TUnit.Core.Hooks.BeforeTestHookMethod>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public BeforeTestHookMethod() { }\n    public override System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.TestContext context, System.Threading.CancellationToken cancellationToken) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Enum Assertion Conditions in C#\nDESCRIPTION: Defines multiple assertion condition classes for enum-specific assertions, such as checking flags, names, values, and if an enum is defined.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumDoesNotHaveFlagAssertCondition<TEnum> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TEnum>\n    where TEnum : System.Enum\n{\n    public EnumDoesNotHaveFlagAssertCondition(TEnum expected) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TEnum? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n\n// Similar classes: EnumDoesNotHaveSameNameAsCondition, EnumDoesNotHaveSameValueAsCondition, EnumHasFlagAssertCondition, EnumHasSameNameAsCondition, EnumHasSameValueAsCondition, EnumIsDefinedAssertCondition, EnumIsNotDefinedAssertCondition\n```\n\n----------------------------------------\n\nTITLE: Initializing TUnit Test Registration\nDESCRIPTION: Module initializer that registers the Tests class with TUnit's source registrar. This ensures the test collection is available to the test runner.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests2083.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tglobal::TUnit.Core.SourceRegistrar.Register(new Tests());\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Regex and Wildcard String Matching in TUnit\nDESCRIPTION: Static methods to create regex and wildcard string matchers for assertions with optional case sensitivity. This allows flexible string comparison in test assertions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertConditions.StringMatcher.RegexMatch AsRegex([System.Diagnostics.CodeAnalysis.StringSyntax(\"regex\")] string pattern) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertConditions.StringMatcher.WildcardMatch AsWildcard(string pattern) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertConditions.StringMatcher op_Implicit(System.Text.RegularExpressions.Regex pattern) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertConditions.StringMatcher op_Implicit(string pattern) { }\n```\n\n----------------------------------------\n\nTITLE: Handling Test Initialization Failures in C#\nDESCRIPTION: This snippet demonstrates error handling for test initialization failures. It creates a FailedTestMetadata instance with details about the failed test and the exception that occurred during initialization.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/StringArgumentTests.Test.verified.txt#2025-04-22_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n    nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.StringArgumentTests>\n    {\n        TestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS1:TUnit.TestProject.StringArgumentTests.Nullable(string):0\",\n        MethodName = $\"Nullable\",\n        Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"StringArgumentTests.Nullable failed to initialize\", exception),\n        TestFilePath = @\"\",\n        TestLineNumber = 24,\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SatisfiesAssertCondition for Custom Assertions in C#\nDESCRIPTION: Defines a class for creating custom assertion conditions with mapping and assertion building functions. It handles the evaluation of assertion results based on provided criteria.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_53\n\nLANGUAGE: C#\nCODE:\n```\npublic class SatisfiesAssertCondition<TActual, TExpected> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n{\n    public SatisfiesAssertCondition(System.Func<TActual, System.Threading.Tasks.Task<TExpected>?> mapper, System.Func<TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TExpected?>, TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TExpected?>> assertionBuilder, string mapperExpression, string assertionBuilderExpression) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ExpectedExceptionDelegateAssertCondition<TException> Abstract Class in C#\nDESCRIPTION: This abstract class provides a base for assertion conditions that expect specific exceptions to be thrown.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ExpectedExceptionDelegateAssertCondition<TException> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<object?, System.Exception>\n{\n    protected ExpectedExceptionDelegateAssertCondition() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LogLevel Enum in C#\nDESCRIPTION: Defines an enum for different log levels including Trace, Debug, Information, Warning, Error, Critical, and None.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_64\n\nLANGUAGE: C#\nCODE:\n```\nInformation = 2,\nWarning = 3,\nError = 4,\nCritical = 5,\nNone = 6,\n```\n\n----------------------------------------\n\nTITLE: Collection Assertion Extensions for TUnit\nDESCRIPTION: Extension methods for asserting collection properties including count checks, distinct item validation, and custom equality comparisons. Supports both IEnumerable and ImmutableArray collections.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_69\n\nLANGUAGE: C#\nCODE:\n```\npublic static class HasExtensions {\n        public static TUnit.Assertions.Extensions.EnumerableCount<System.Collections.Generic.IEnumerable<TInner>, TInner> HasCount<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }\n        public static TUnit.Assertions.Extensions.EnumerableCount<System.Collections.Immutable.ImmutableArray<TInner>, TInner> HasCount<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PropertyEqualsExpectedValueAssertCondition for TUnit Property Assertions (C#)\nDESCRIPTION: Defines the `PropertyEqualsExpectedValueAssertCondition` class within the ClassMember namespace. It inherits from `ExpectedValueAssertCondition` and is used to assert whether a specific property of an object (`TRootObjectType`), selected via an expression (`propertySelector`), is equal or not equal (`isEqual` flag) to an expected value (`TPropertyType`).\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_35\n\nLANGUAGE: csharp\nCODE:\n```\n    public class PropertyEqualsExpectedValueAssertCondition<TRootObjectType, TPropertyType> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TRootObjectType, TPropertyType>\n    {\n        public PropertyEqualsExpectedValueAssertCondition(System.Linq.Expressions.Expression<System.Func<TRootObjectType, TPropertyType>> propertySelector, TPropertyType expected, bool isEqual) { }\n        protected override string GetExpectation() { }\n        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TRootObjectType? actualValue, TPropertyType? expectedValue) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building Double-Argument Test Metadata and Factory with TUnit in C#\nDESCRIPTION: This snippet constructs the test metadata and factory for a method taking a double argument, assembling all relevant SourceGeneratedMethodInformation, context, instance creation, and argument passing. It leverages TUnit.Core facilities to encapsulate test method factory, argument values, repeat limits, and error handling through test metadata records. Dependencies include TUnit.Core and any types referenced; inputs include the sessionId and method argument, and output is a populated TestMetadata object. Suitable for parameterized test execution where repeatability and context management are critical.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ConstantArgumentsTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.ConstantArgumentsTests? classInstance = null;\nobject?[]? classInstanceArguments = null;\nclassInstanceArguments = [];\n\ndouble methodArg = 1.23;\n\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ConstantArgumentsTests>(() => \nnew global::TUnit.TestProject.ConstantArgumentsTests()\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.ConstantArgumentsTests>\n{\n\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.ConstantArgumentsTests.Double(double):0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [methodArg],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Double(methodArg)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 30,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for Data-Driven Tests in C#\nDESCRIPTION: Creates test metadata for data-driven tests by combining class-level and method-level data sources. It handles test initialization, argument preparation, and exception handling for failed initializations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceClassCombinedWithDataSourceMethodTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod),\n\t\t\tName = \"DataSourceClassCombinedWithDataSourceMethodTest\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"One\"),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Two\"),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Three\")\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t{\n\t\t\t\t\tName = \"i\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataSourceClassCombinedWithDataSourceMethodTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"DataSourceClassCombinedWithDataSourceMethodTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"DataSourceClassCombinedWithDataSourceMethod\",\n\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"One\"),\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Two\"),\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Three\")\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"i\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tint classArg = global::TUnit.TestProject.CommonTestData.One();\n\t\t\tclassInstanceArguments = [classArg];\n\n\t\t\tint methodArg = global::TUnit.TestProject.CommonTestData.One();\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod>(() => \n\t\t\tnew global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod(classArg)\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS0:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod(int).DataSourceClassCombinedWithDataSourceMethodTest(int):0\",\n\t\t\t\tTestClassArguments = [classArg],\n\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSourceClassCombinedWithDataSourceMethodTest(methodArg)),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 10,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS0:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod(int).DataSourceClassCombinedWithDataSourceMethodTest(int):0\",\n\t\t\t\tMethodName = $\"DataSourceClassCombinedWithDataSourceMethodTest\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"DataSourceClassCombinedWithDataSourceMethod.DataSourceClassCombinedWithDataSourceMethodTest failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 10,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing ITestHookSource for AssemblyBase1 in C#\nDESCRIPTION: This snippet defines a partial class Hooks_AssemblyBase1 that implements ITestHookSource. It registers test hooks and provides methods to collect different types of test hooks.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyBeforeTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_AssemblyBase1 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_AssemblyBase1();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.BeforeTests.AssemblyBase1),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.AssemblyBase1),\n\t\t\t\t\tName = \"BeforeEach1\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.AssemblyBase1\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.AssemblyBase1),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AssemblyBeforeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"AssemblyBeforeTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"AssemblyBase1\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.BeforeTests.AssemblyBase1)classInstance).BeforeEach1()),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n}\n```\n\n----------------------------------------\n\nTITLE: WorkerAwareTest Class Definition in C#\nDESCRIPTION: A base class for tests that need worker awareness, implementing event receiver interfaces. Provides worker index tracking, service registration, and worker lifecycle management.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class WorkerAwareTest : TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestRegisteredEventReceiver\n{\n    public WorkerAwareTest() { }\n    public virtual bool UseDefaultParallelLimiter { get; }\n    public int WorkerIndex { get; }\n    public System.Threading.Tasks.ValueTask OnTestRegistered(TUnit.Core.TestRegisteredContext context) { }\n    public System.Threading.Tasks.Task<T> RegisterService<T>(string name, System.Func<System.Threading.Tasks.Task<T>> factory)\n        where T :  class, TUnit.Playwright.IWorkerService { }\n    protected bool TestOk(TUnit.Core.TestContext testContext) { }\n    [TUnit.Core.Before(TUnit.Core.HookType.Test, \"\", 0)]\n    public void WorkerSetup() { }\n    [TUnit.Core.After(TUnit.Core.HookType.Test, \"\", 0)]\n    public System.Threading.Tasks.Task WorkerTeardown(TUnit.Core.TestContext testContext) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for ClassConstructorTest in TUnit (C#)\nDESCRIPTION: This snippet demonstrates the creation of test metadata for the ClassConstructorTest class. It includes setting up test information, class information, and creating TestMetadata objects for each test method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassConstructorTest.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.ClassConstructorTest),\n\tName = \"Test\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(void),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute()\n\t],\n\tParameters = [],\n\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.ClassConstructorTest\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t{\n\t\t// ... (class information details)\n\t}),\n};\n\n// ... (test builder context setup)\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.ClassConstructorTest>\n{\n\tTestId = $\"global::TUnit.Core.ClassConstructorAttribute<global::TUnit.TestProject.DependencyInjectionClassConstructor>:{classDataIndex}:CL-CCA0:TUnit.TestProject.ClassConstructorTest(TUnit.TestProject.DummyReferenceTypeClass).Test:0\",\n\t// ... (other TestMetadata properties)\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Tolerance for DateOnly Equality Assertions\nDESCRIPTION: Method to set a tolerance in days for DateOnly equality assertions, allowing for approximate date comparisons within a specified range.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic void SetTolerance(int toleranceDays) { }\n```\n\n----------------------------------------\n\nTITLE: Evaluating Assertions with GetResult Method in Csharp\nDESCRIPTION: This code snippet defines a class that evaluates assertions on collections in Csharp by searching for and storing the first element that matches a given predicate. The main functionality is captured in the GetResult method, which iterates through the collection and checks each item against the matcher function. Dependencies include the IEnumerable interface and a base assert condition class.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-assertions/extensibility/returning-items-from-await.md#2025-04-22_snippet_0\n\nLANGUAGE: Csharp\nCODE:\n```\npublic class EnumerableContainsExpectedFuncAssertCondition<TActual, TInner>(\n    Func<TInner, bool> matcher, string? matcherString)\n    : BaseAssertCondition<TActual>\n    where TActual : IEnumerable<TInner>\n{\n    private bool _wasFound;\n    \n    protected override string GetExpectation() => $\"to contain an entry matching {matcherString ?? \"null\"}\";\n    \n    protected override ValueTask<AssertionResult> GetResult(\n        TActual? actualValue, Exception? exception,\n        AssertionMetadata assertionMetadata\n    )\n    {\n        if (actualValue is null)\n        {\n            return FailWithMessage($\"{ActualExpression ?? typeof(TActual).Name} is null\");\n        }\n\n        foreach (var inner in actualValue)\n        {\n            if (matcher(inner))\n            {\n                _wasFound = true;\n                FoundItem = inner;\n                break;\n            }\n        }\n        \n        return AssertionResult\n            .FailIf(_wasFound is false, \"there was no match found in the collection\");\n    }\n\n    public TInner? FoundItem { get; private set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Test Source Registration for GenericMethodTests in C#\nDESCRIPTION: Registers the GenericMethodTests class as a test source using a module initializer. This ensures the test source is automatically registered when the module is loaded.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GenericMethodTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tglobal::TUnit.Core.SourceRegistrar.Register(new GenericMethodTests());\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ImmutableArray Assertions in C#\nDESCRIPTION: Extension methods specific to ImmutableArray<T> assertions, including emptiness checks and equivalence comparisons.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_148\n\nLANGUAGE: C#\nCODE:\n```\npublic static class ImmutableArrayIsExtensions {\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsEmpty<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsEquivalentTo<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Immutable.ImmutableArray<TInner> expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Assertion Exceptions in C#\nDESCRIPTION: Defines custom exception classes for handling assertion failures and test conditions\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_101\n\nLANGUAGE: C#\nCODE:\n```\npublic class AssertionException : TUnit.Assertions.Exceptions.BaseAssertionException\n{\n    public AssertionException(string? message) { }\n    public AssertionException(string? message, System.Exception innerException) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Negative Collection Assertion Methods for TUnit\nDESCRIPTION: Extension methods for asserting that collections do not contain specific elements. Includes methods for checking that an enumerable does not contain elements matching a predicate or a specific value.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_62\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> DoesNotContain<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, bool> matcher, [System.Runtime.CompilerServices.CallerArgumentExpression(\"matcher\")] string? doNotPopulateThisValue = null) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> DoesNotContain<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TInner expected, System.Collections.Generic.IEqualityComparer<TInner?>? equalityComparer = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null)\n    where TActual : System.Collections.Generic.IEnumerable<TInner> { }\n```\n\n----------------------------------------\n\nTITLE: Implementing IInvokableAssertionBuilder Interface in C#\nDESCRIPTION: This interface represents an invokable assertion builder. It inherits from ISource and declares methods for getting an awaiter and expression.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_58\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IInvokableAssertionBuilder : TUnit.Assertions.AssertConditions.Interfaces.ISource\n{\n    System.Runtime.CompilerServices.TaskAwaiter GetAwaiter();\n    string? GetExpression();\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Test Hook Sources with TUnit Source Generator in C#\nDESCRIPTION: This snippet demonstrates a file-scoped partial class that implements the ITestHookSource interface, providing registration and collection of before and after test hooks for integration with the TUnit test framework. It features module initialization for automatic registration and explicit collections for both static and instance hook methods. Required dependencies include TUnit.Core, TUnit.Core.Interfaces, and .NET threading and reflection assemblies. The approach uses strong typing, partial classes, attribute metadata, and lambda expressions for flexible hook execution within test lifecycles.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeTests.Test.verified.txt#2025-04-22_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_SetupTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_SetupTests();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\t\tName = \"SetupWithContext\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test),\n\t\t\t\t\t\tnew global::TUnit.Core.TimeoutAttribute(30_000)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"testContext\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.SetupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"BeforeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"BeforeTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"SetupTests\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.BeforeTests.SetupTests)classInstance).SetupWithContext(context, cancellationToken)),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test),\n\t\t\t\t\t\tnew global::TUnit.Core.TimeoutAttribute(30_000)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t\t},\n\t\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing TestingPlatformBuilderHook in C#\nDESCRIPTION: Provides a static method for adding extensions to a test application builder.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic static class TestingPlatformBuilderHook\n{\n    public static void AddExtensions(Microsoft.Testing.Platform.Builder.ITestApplicationBuilder testApplicationBuilder, string[] _) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Method Data Source Attribute in C#\nDESCRIPTION: Defines a generic version of MethodDataSourceAttribute for specifying a method within a specific type as a data source. It simplifies usage by inferring the class type from the generic parameter.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method | System.AttributeTargets.Property, AllowMultiple=true)]\npublic class MethodDataSourceAttribute<T> : TUnit.Core.MethodDataSourceAttribute\n{\n    public MethodDataSourceAttribute(string methodNameProvidingDataSource) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining StackTraceHiddenAttribute in C#\nDESCRIPTION: This snippet defines the `StackTraceHiddenAttribute` class within the `System.Diagnostics` namespace. It's a sealed attribute, inheriting from `System.Attribute`, designed to be applied to classes, methods, constructors, or structs to exclude them from appearing in stack traces. It prevents inheritance (`Inherited = false`).\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/PolyfillTests.Test_Without_BuildProperty_WithoutType.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Diagnostics;\n\nusing System;\nusing System.Diagnostics.CodeAnalysis;\n\n[AttributeUsage(\n    AttributeTargets.Class |\n    AttributeTargets.Method |\n    AttributeTargets.Constructor |\n    AttributeTargets.Struct,\n    Inherited = false)]\nsealed class StackTraceHiddenAttribute : Attribute;\n```\n\n----------------------------------------\n\nTITLE: Defining That Assertion for ValueTask<TActual> in C#\nDESCRIPTION: This generic overload of the static `That` method accepts a `ValueTask<TActual>`. It returns an `AsyncValueDelegateAssertionBuilder<TActual>` used to assert conditions on the result of the asynchronous operation represented by the ValueTask. The `CallerArgumentExpression` captures the source expression.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\n        public static TUnit.Assertions.AssertionBuilders.AsyncValueDelegateAssertionBuilder<TActual> That<TActual>(System.Threading.Tasks.ValueTask<TActual> value, [System.Runtime.CompilerServices.CallerArgumentExpression(\"value\")] string? doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Defining DelegateAssertCondition Classes in C#\nDESCRIPTION: These classes provide base implementations for delegate-based assertion conditions, with various generic type parameters for actual values and exceptions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class DelegateAssertCondition : TUnit.Assertions.AssertConditions.DelegateAssertCondition<object?, System.Exception>\n{\n    protected DelegateAssertCondition() { }\n}\n\npublic abstract class DelegateAssertCondition<TActual> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<TActual, System.Exception>\n{\n    protected DelegateAssertCondition() { }\n}\n\npublic abstract class DelegateAssertCondition<TActual, TException> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n    where TException : System.Exception\n{\n    protected DelegateAssertCondition() { }\n    protected override string GetExpectation() { }\n    protected virtual string GetFailureMessage(TException? exception) { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n    public void WithComparer(System.Func<TException?, TUnit.Assertions.AssertionDecision> comparer) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TimeoutCancellationTokenTests Class for InheritedTimeoutAttribute\nDESCRIPTION: Auto-generated partial class implementing ITestSource interface to register and collect test metadata for timeout cancellation token tests. Handles initialization and test collection for InheritedTimeoutAttribute test method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/TimeoutCancellationTokenTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class TimeoutCancellationTokenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new TimeoutCancellationTokenTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.TimeoutCancellationTokenTests),\n\t\t\t\tName = \"InheritedTimeoutAttribute\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.TestProject.TimeoutCancellationTokenTests.FiveSecondTimeout()\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.TimeoutCancellationTokenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.TimeoutCancellationTokenTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"TimeoutCancellationTokenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"TimeoutCancellationTokenTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"TimeoutCancellationTokenTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"DataSource\"),\n\t\t\t\t\t\tnew global::TUnit.Core.CategoryAttribute(\"Timeout Cancellation Token Tests\")\n\t\t\t\t\t],\n\t\t\t\t\tParameters = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Before Test Session Hook Method in C#\nDESCRIPTION: Defines the BeforeTestSessionHookMethod class which executes before a test session. It inherits from StaticHookMethod and implements IEquatable.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_48\n\nLANGUAGE: C#\nCODE:\n```\npublic class BeforeTestSessionHookMethod : TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.TestSessionContext>, System.IEquatable<TUnit.Core.Hooks.BeforeTestSessionHookMethod>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public BeforeTestSessionHookMethod() { }\n    public override System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.TestSessionContext context, System.Threading.CancellationToken cancellationToken) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dictionary Key and Value Assertions in C#\nDESCRIPTION: These methods extend IValueSource<IDictionary> to provide assertions for dictionary keys and values. They allow for custom equality comparers.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_139\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TDictionary> ContainsKey<TDictionary, TKey>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TDictionary> valueSource, TKey expected, System.Collections.Generic.IEqualityComparer<TKey> equalityComparer = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n    where TDictionary : System.Collections.IDictionary { }\n\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TDictionary> ContainsValue<TDictionary, TValue>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TDictionary> valueSource, TValue expected, System.Collections.Generic.IEqualityComparer<TValue> equalityComparer = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n    where TDictionary : System.Collections.IDictionary { }\n```\n\n----------------------------------------\n\nTITLE: Collecting TUnit Test Metadata\nDESCRIPTION: Method to collect all test metadata by combining results from multiple test collection methods. Returns a read-only list of test metadata.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.Typed.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn\n\t[\n\t\t..Tests0(sessionId),\n\t\t..Tests1(sessionId),\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing After Test Hook Method in C#\nDESCRIPTION: Defines the AfterTestHookMethod class which executes after a test is run. It inherits from StaticHookMethod and implements IEquatable.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\npublic class AfterTestHookMethod : TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.TestContext>, System.IEquatable<TUnit.Core.Hooks.AfterTestHookMethod>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public AfterTestHookMethod() { }\n    public override System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.TestContext context, System.Threading.CancellationToken cancellationToken) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Exception Message Assertion Classes Implementation in C#\nDESCRIPTION: Classes for handling exception message assertions with various comparison methods including exact match, starts with, and pattern matching. These classes extend ExpectedValueAssertCondition and implement exception-specific assertion logic.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\npublic class ExceptionMessageMatchingExpectedAssertCondition<TException> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TException, TUnit.Assertions.AssertConditions.StringMatcher>\n    where TException : System.Exception\n{\n    public ExceptionMessageMatchingExpectedAssertCondition(TUnit.Assertions.AssertConditions.StringMatcher match) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TException? actualValue, TUnit.Assertions.AssertConditions.StringMatcher? expectedValue) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Static Failure Helper Methods in TUnit (C#)\nDESCRIPTION: Provides static helper methods within the `Fail` class to explicitly fail a test (`Test`) or fail conditionally based on a boolean expression (`Unless`, `When`). These methods likely throw exceptions or signal test failure to the TUnit framework.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_35\n\nLANGUAGE: csharp\nCODE:\n```\n    public static class Fail\n    {\n        [System.Diagnostics.CodeAnalysis.DoesNotReturn]\n        public static void Test(string reason) { }\n        public static void Unless([System.Diagnostics.CodeAnalysis.DoesNotReturnIf(false)] bool condition, string reason) { }\n        public static void When([System.Diagnostics.CodeAnalysis.DoesNotReturnIf(true)] bool condition, string reason) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: GitHubReporter for Publishing Test Results to GitHub\nDESCRIPTION: Reporter class that integrates with GitHub's reporting mechanisms for publishing test results. It implements several interfaces to integrate with the Microsoft Testing Platform and provide test result information to GitHub.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic class GitHubReporter : Microsoft.Testing.Platform.Extensions.IExtension, Microsoft.Testing.Platform.Extensions.TestHost.IDataConsumer, Microsoft.Testing.Platform.Extensions.TestHost.ITestApplicationLifecycleCallbacks, Microsoft.Testing.Platform.Extensions.TestHost.ITestHostExtension, TUnit.Engine.Framework.IFilterReceiver\n{\n    public GitHubReporter(Microsoft.Testing.Platform.Extensions.IExtension extension) { }\n    public System.Type[] DataTypesConsumed { get; }\n    public string Description { get; }\n    public string DisplayName { get; }\n    public string? Filter { get; set; }\n    public string Uid { get; }\n    public string Version { get; }\n    public System.Threading.Tasks.Task AfterRunAsync(int exitCode, System.Threading.CancellationToken cancellation) { }\n    public System.Threading.Tasks.Task BeforeRunAsync(System.Threading.CancellationToken cancellationToken) { }\n    public System.Threading.Tasks.Task ConsumeAsync(Microsoft.Testing.Platform.Extensions.Messages.IDataProducer dataProducer, Microsoft.Testing.Platform.Extensions.Messages.IData value, System.Threading.CancellationToken cancellationToken) { }\n    public System.Threading.Tasks.Task<bool> IsEnabledAsync() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Ordering Validation for Enumerable Collections in C#\nDESCRIPTION: Class for asserting that an enumerable collection is ordered according to a specified criterion. It supports custom comparison through IComparer and projection of items to comparison values.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumerableOrderedByAssertCondition<TActual, TInner, TComparisonItem> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n    where TActual : System.Collections.Generic.IEnumerable<TInner>\n{\n    public EnumerableOrderedByAssertCondition(System.Collections.Generic.IComparer<TComparisonItem?> comparer, System.Func<TInner, TComparisonItem> comparisonItemSelector, TUnit.Assertions.Enums.Order order) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating RepeatAttribute in C#\nDESCRIPTION: Defines an attribute for repeating test execution a specified number of times. It inherits from TUnitAttribute and can be applied to assembly, class, or method targets.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\npublic sealed class RepeatAttribute : TUnit.Core.TUnitAttribute\n{\n    public RepeatAttribute(int times) { }\n    public int Times { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Registering ClassTupleDataSourceDrivenTests in C#\nDESCRIPTION: This snippet defines the Initialise method that registers the ClassTupleDataSourceDrivenTests class with the SourceRegistrar. It's marked with the ModuleInitializer attribute to ensure it's called when the module is loaded.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=NamedTupleMethod_testMethodName=NamedTupleMethod.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tSourceRegistrar.Register(new ClassTupleDataSourceDrivenTests());\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Long Type Test Handler in C#\nDESCRIPTION: Auto-generated code for handling long type argument test cases in TUnit framework. Includes test metadata generation and exception handling for test initialization.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ConstantArgumentsTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.ConstantArgumentsTests.Long(long):0\",\nTestClassArguments = [],\nTestMethodArguments = [methodArg],\nTestClassProperties = [],\nCurrentRepeatAttempt = 0,\nRepeatLimit = 0,\nResettableClassFactory = resettableClassFactory,\nTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Long(methodArg)),\nTestFilePath = @\"\",\nTestLineNumber = 44,\nTestMethod = testInformation,\nTestBuilderContext = testBuilderContext\n```\n\n----------------------------------------\n\nTITLE: Implementing ThrowsWithParamNameAssertCondition Class in C#\nDESCRIPTION: Defines an assertion condition to check if an ArgumentException with a specific parameter name is thrown. Uses generic type constraints and string comparison.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_76\n\nLANGUAGE: C#\nCODE:\n```\npublic class ThrowsWithParamNameAssertCondition<TActual, TException> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<TActual, System.ArgumentException>\n    where TException : System.ArgumentException\n{\n    public ThrowsWithParamNameAssertCondition(string expectedParamName, System.StringComparison stringComparison, System.Func<System.Exception?, System.ArgumentException?> exceptionSelector) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Arguments for MatrixTest via MatrixDataSource (TUnit, C#)\nDESCRIPTION: This snippet illustrates the logic for generating test arguments programmatically from matrix attributes for 'MatrixTest.' It uses MatrixDataSourceAttribute to expand parameter combinations, builds generator metadata, and iterates combinations to create/queue TestMetadata for each. The code depends on TUnit.Core and correct attribute application. Inputs include the test context, session ID, and test method definitions; output is an expanded set of test cases.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/TimeoutCancellationTokenTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nvar methodArgDataGeneratorMetadata = new DataGeneratorMetadata\n{\n\tType = global::TUnit.Core.Enums.DataGeneratorType.TestParameters,\n\tTestBuilderContext = testBuilderContextAccessor,\n\tTestInformation = testInformation,\n\tMembersToGenerate = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t{\n\t\t\tName = \"value\",\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.MatrixAttribute(1, 2, 3)\n\t\t\t],\n\t\t},\n\t],\n\tTestSessionId = sessionId,\n\tTestClassInstance = classInstance,\n\tClassInstanceArguments = classInstanceArguments,\n};\nvar methodDataAttribute = new global::TUnit.Core.MatrixDataSourceAttribute();\n\ntestBuilderContext.DataAttributes.Add(methodDataAttribute);\n\nvar methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\n\nforeach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\n{\n\ttestMethodDataIndex++;\n\tint classArg = global::TUnit.TestProject.TimeoutCancellationTokenTests.DataSource();\n\tclassInstanceArguments = [classArg];\n\n\tvar methodArgGeneratedData = methodArgGeneratedDataAccessor();\n\tint methodArg = global::TUnit.Core.Helpers.CastHelper.Cast<int>(methodArgGeneratedData[0]);\n```\n\n----------------------------------------\n\nTITLE: Implementing WithParameterName Extension Method in C#\nDESCRIPTION: Extends ThrowsException to assert that an ArgumentException is thrown with a specific parameter name. Uses generic type constraints and caller argument expression.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_71\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertConditions.Throws.ThrowsException<TActual, TException> WithParameterName<TActual, TException>(this TUnit.Assertions.AssertConditions.Throws.ThrowsException<TActual, TException> throwsException, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null)\n    where TException : System.ArgumentException { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Class Hooks for Base1 Tests in TUnit\nDESCRIPTION: Generated partial class implementing IClassHookSource interface for Base1 test class. Provides methods for collecting before and after class hooks, with AfterAll1 hook implementation.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterAllTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_Base1 : global::TUnit.Core.Interfaces.SourceGenerator.IClassHookSource\n{\n    [global::System.Runtime.CompilerServices.ModuleInitializer]\n    public static void Initialise()\n    {\n        var instance = new Hooks_Base1();\n        SourceRegistrar.RegisterClassHookSource(instance);\n    }\n    public global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId)\n    {\n        return\n        [\n        ];\n    }\n    // Additional methods omitted for brevity\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NotNullStructExpectedValueAssertCondition for TUnit Nullable Struct Checks (C#)\nDESCRIPTION: Defines the `NotNullStructExpectedValueAssertCondition` class for value types (`struct`). It inherits from `ConvertToAssertCondition` and asserts that a nullable value type (`TActual?`) has a value, converting it to its non-nullable form (`TActual`) upon success.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\n    public class NotNullStructExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.ConvertToAssertCondition<TActual?, TActual>\n        where TActual :  struct\n    {\n        public NotNullStructExpectedValueAssertCondition() { }\n        public override System.Threading.Tasks.ValueTask<System.ValueTuple<TUnit.Assertions.AssertConditions.AssertionResult, TActual>> ConvertValue(TActual? value) { }\n        protected override string GetExpectation() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining ClassDataSourceAttribute for 3-5 Generic Parameters - C#\nDESCRIPTION: This code snippet defines sealed generic attribute classes ClassDataSourceAttribute with 3 to 5 generic type parameters. These attributes extend corresponding DataSourceGeneratorAttribute base classes and are intended to be used on classes or methods (with AllowMultiple=true) to specify how test data sources should be generated dynamically for parameterized tests in the TUnit framework. Each attribute provides a Keys property for identifying data sources and a Shared property for specifying shared types, requiring T1-T5 to have a parameterless constructor. The GenerateDataSources method must be overridden to supply data generation logic based on DataGeneratorMetadata context.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\npublic sealed class ClassDataSourceAttribute<T1, T2, T3> : TUnit.Core.DataSourceGeneratorAttribute<T1, T2, T3>\n    where T1 : new()\n    where T2 : new()\n    where T3 : new()\n{\n    public ClassDataSourceAttribute() { }\n    public string[] Keys { get; set; }\n    public TUnit.Core.SharedType[] Shared { get; set; }\n    public override System.Collections.Generic.IEnumerable<System.Func<System.ValueTuple<T1, T2, T3>>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata) { }\n}\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\npublic sealed class ClassDataSourceAttribute<T1, T2, T3, T4> : TUnit.Core.DataSourceGeneratorAttribute<T1, T2, T3, T4>\n    where T1 : new()\n    where T2 : new()\n    where T3 : new()\n    where T4 : new()\n{\n    public ClassDataSourceAttribute() { }\n    public string[] Keys { get; set; }\n    public TUnit.Core.SharedType[] Shared { get; set; }\n    public override System.Collections.Generic.IEnumerable<System.Func<System.ValueTuple<T1, T2, T3, T4>>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata) { }\n}\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\npublic sealed class ClassDataSourceAttribute<T1, T2, T3, T4, T5> : TUnit.Core.DataSourceGeneratorAttribute<T1, T2, T3, T4, T5>\n    where T1 : new()\n    where T2 : new()\n    where T3 : new()\n    where T4 : new()\n    where T5 : new()\n{\n    public ClassDataSourceAttribute() { }\n    public string[] Keys { get; set; }\n    public TUnit.Core.SharedType[] Shared { get; set; }\n    public override System.Collections.Generic.IEnumerable<System.Func<System.ValueTuple<T1, T2, T3, T4, T5>>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CheckEquivalent Generic Method in C#\nDESCRIPTION: This method checks for equivalence between two objects of different types. It uses DynamicallyAccessedMembers attribute to specify which members can be dynamically accessed.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic static System.Collections.Generic.IEnumerable<TUnit.Assertions.ComparisonFailure> CheckEquivalent<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TActual, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TExpected>(TActual actual, TExpected expected, TUnit.Assertions.CompareOptions options, int? index) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing SingleItemAssertionBuilderWrapper in C#\nDESCRIPTION: Wrapper for assertions on collections expected to contain a single item, providing a GetAwaiter method to allow awaiting to get the single item directly.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_94\n\nLANGUAGE: C#\nCODE:\n```\n    public class SingleItemAssertionBuilderWrapper<TActual, TInner> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>\n        where TActual : System.Collections.Generic.IEnumerable<TInner>\n    {\n        public new System.Runtime.CompilerServices.TaskAwaiter<TInner?> GetAwaiter() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing DisplayNameFormatterAttribute in C#\nDESCRIPTION: Defines an abstract class DisplayNameFormatterAttribute that inherits from TUnitAttribute and implements IEventReceiver and ITestDiscoveryEventReceiver interfaces. It provides a base for formatting display names of tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method, Inherited=false)]\npublic abstract class DisplayNameFormatterAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver\n{\n    protected DisplayNameFormatterAttribute() { }\n    public int Order { get; }\n    protected abstract string FormatDisplayName(TUnit.Core.TestContext testContext);\n    public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }\n}\n```\n\n----------------------------------------\n\nTITLE: JSON Extension Methods for TUnit Engine\nDESCRIPTION: Collection of extension methods for converting TUnit core objects to their JSON model counterparts. These methods facilitate serialization of test contexts, results, and exceptions for data exchange and reporting.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic static class JsonExtensions\n{\n    public static TUnit.Engine.Json.ExceptionJson ToJsonModel(this System.Exception exception) { }\n    public static TUnit.Engine.Json.TestAssemblyJson ToJsonModel(this TUnit.Core.AssemblyHookContext context) { }\n    public static TUnit.Engine.Json.TestClassJson ToJsonModel(this TUnit.Core.ClassHookContext context) { }\n    public static TUnit.Engine.Json.TestJson ToJsonModel(this TUnit.Core.TestContext context) { }\n    public static TUnit.Engine.Json.TestResultJson ToJsonModel(this TUnit.Core.TestResult result) { }\n    public static TUnit.Engine.Json.TestSessionJson ToJsonModel(this TUnit.Core.TestSessionContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Argument Display Formatter in C#\nDESCRIPTION: This snippet defines an abstract class for formatting test arguments and an attribute for applying formatters to tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ArgumentDisplayFormatter\n{\n    protected ArgumentDisplayFormatter() { }\n    public abstract bool CanHandle(object? value);\n    public abstract string FormatValue(object? value);\n}\n\npublic abstract class ArgumentDisplayFormatterAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver\n{\n    protected ArgumentDisplayFormatterAttribute() { }\n    public abstract TUnit.Core.ArgumentDisplayFormatter Formatter { get; }\n    public virtual int Order { get; }\n    public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Initialising Module in TUnit Source Generated with C#\nDESCRIPTION: This snippet initializes a module for TUnit source-generated hooks by registering the test hook source. It relies on TUnit's core and interface namespaces and sets up an instance of the hooks class to be used in testing.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticBeforeEachTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n    var instance = new Hooks_GlobalSetUpTests();\n    SourceRegistrar.RegisterTestHookSource(instance);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Single TUnit Attribute in C#\nDESCRIPTION: Defines a base class for TUnit attributes that can only be applied once. This helps enforce correct attribute usage in the testing framework.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_45\n\nLANGUAGE: C#\nCODE:\n```\npublic class SingleTUnitAttribute : TUnit.Core.TUnitAttribute { }\n```\n\n----------------------------------------\n\nTITLE: Registering and Collecting Assembly-Level Hooks for TUnit - C#\nDESCRIPTION: Presents a partial class that implements assembly hook collection and registration for TUnit, initializing with a module initializer. It defines CollectBeforeAssemblyHooks to return a hook for running the static async Task 'BeforeAll3' on the AssemblyBase3 class, including all method meta-data, execution body, and attributes necessary for TUnit's execution pipeline. All dependencies must be available from the TUnit.Core namespace. Other collector methods return empty lists, indicating no additional hooks at present.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyBeforeTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_AssemblyBase3 : global::TUnit.Core.Interfaces.SourceGenerator.IAssemblyHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_AssemblyBase3();\n\t\tSourceRegistrar.RegisterAssemblyHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectBeforeEveryAssemblyHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectAfterEveryAssemblyHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectBeforeAssemblyHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.BeforeAssemblyHookMethod\n\t\t\t{ \n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.AssemblyBase3),\n\t\t\t\tName = \"BeforeAll3\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Assembly)\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.AssemblyBase3\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.AssemblyBase3),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AssemblyBeforeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"AssemblyBeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"AssemblyBase3\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.BeforeTests.AssemblyBase3.BeforeAll3()),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tFilePath = @\"\",\n\t\t\t\tLineNumber = 35,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Assembly)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\tAssemblyAttributes = [],\n\t\t\t},\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectAfterAssemblyHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Generating Test Data Sources with Matrix Data Source Attribute\nDESCRIPTION: Creates and configures a matrix data source attribute, adds it to the test builder context, and generates data sources for test method parameters.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1821.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar methodDataAttribute = new global::TUnit.Core.MatrixDataSourceAttribute();\n\ntestBuilderContext.DataAttributes.Add(methodDataAttribute);\n\nvar methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\n```\n\n----------------------------------------\n\nTITLE: Character Inequality Assertion Extensions in TUnit\nDESCRIPTION: Extension methods for asserting character inequality in tests. The class provides methods for both nullable and non-nullable character types with multiple parameter combinations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_128\n\nLANGUAGE: C#\nCODE:\n```\npublic static class CharIsNotExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<char> IsNotEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<char> valueSource, char expected) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<char?> IsNotEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<char?> valueSource, char expected) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<char?> IsNotEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<char?> valueSource, char? expected) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting ImmutableArray Non-Equivalence in C#\nDESCRIPTION: This snippet defines extension methods for asserting that ImmutableArrays are not equivalent to other collections. It provides various overloads to accommodate different comparison scenarios.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_150\n\nLANGUAGE: C#\nCODE:\n```\npublic static class ImmutableArrayIsNotExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsNotEmpty<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsNotEquivalentTo<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsNotEquivalentTo<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"collectionOrdering\")] string doNotPopulateThisValue2 = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GenericEqualToAssertionBuilderWrapper for Generic Equality Testing\nDESCRIPTION: Generic assertion builder for equality checking between values. This serves as a base implementation for type-specific equality testing.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_85\n\nLANGUAGE: C#\nCODE:\n```\npublic class GenericEqualToAssertionBuilderWrapper<TActual> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Double Constant Argument Test Source Generation in C#\nDESCRIPTION: Auto-generated source code that implements test source generation for double constant arguments. Handles test metadata creation and execution for double parameter tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ConstantArgumentsTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class ConstantArgumentsTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new ConstantArgumentsTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.ConstantArgumentsTests),\n\t\t\t\tName = \"Double\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(1.23)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<double>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"dummy\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t]\n```\n\n----------------------------------------\n\nTITLE: Implementing StringEqualToAssertionBuilderWrapper Class in C#\nDESCRIPTION: This class provides assertions for string equality with additional options like ignoring whitespace, trimming, and treating null and empty strings as equal.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\npublic class StringEqualToAssertionBuilderWrapper : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string>\n{\n    public TUnit.Assertions.AssertionBuilders.Wrappers.StringEqualToAssertionBuilderWrapper IgnoringWhitespace() { }\n    public TUnit.Assertions.AssertionBuilders.Wrappers.StringEqualToAssertionBuilderWrapper WithNullAndEmptyEquality() { }\n    public TUnit.Assertions.AssertionBuilders.Wrappers.StringEqualToAssertionBuilderWrapper WithTrimming() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating TUnit TestMetadata for StringArgumentTests.Nullable (Empty String Argument) in C#\nDESCRIPTION: This C# method `Tests0` generates `TestMetadata` for the `Nullable` test method within `TUnit.TestProject.StringArgumentTests`. It specifically handles the first test case derived from `[ArgumentsAttribute(\"\")]`, where the argument is an empty string. The code initializes test information (`SourceGeneratedMethodInformation`), sets up `TestBuilderContext`, creates a `ResettableLazy` factory for the test class instance, defines the method argument (`methodArg = \"\"`), and adds the fully configured `TestMetadata` object to the `nodes` list. It includes error handling for initialization failures, creating `FailedTestMetadata` if an exception occurs.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/StringArgumentTests.Test.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.StringArgumentTests),\n\t\t\t\tName = \"Nullable\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\"),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(@\"\\\"),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(@\"\\t\"),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\\t\"),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\\\\t\"),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\\\\\\t\"),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\\\\\\\\t\"),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(null)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"s\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.StringArgumentTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.StringArgumentTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"StringArgumentTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"StringArgumentTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"StringArgumentTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.StringArgumentTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tstring methodArg = \"\";\n\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.StringArgumentTests>(() => \n\t\t\t\tnew global::TUnit.TestProject.StringArgumentTests()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.StringArgumentTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.StringArgumentTests.Nullable(string):0\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Nullable(methodArg)),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 24,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.StringArgumentTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.StringArgumentTests.Nullable(string):0\",\n\t\t\t\t\tMethodName = $\"Nullable\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"StringArgumentTests.Nullable failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 24,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing ThrowsExtensions Static Class for Exception Assertions in C#\nDESCRIPTION: This static class provides extension methods for asserting various types of exceptions, including specific exception types, timing constraints, and parameter name checks.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_52\n\nLANGUAGE: C#\nCODE:\n```\npublic static class ThrowsExtensions\n{\n    public static TUnit.Assertions.AssertConditions.Throws.ThrowsException<object?, TException> Throws<TException>(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource)\n        where TException : System.Exception { }\n    public static TUnit.Assertions.AssertConditions.Throws.ThrowsException<object?, TException> ThrowsExactly<TException>(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource)\n        where TException : System.Exception { }\n    public static TUnit.Assertions.AssertConditions.Throws.ThrowsException<object?, System.Exception> ThrowsException(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource) { }\n    public static TUnit.Assertions.AssertionBuilders.CastableResultAssertionBuilder<object?, object?> ThrowsNothing(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource) { }\n    public static TUnit.Assertions.AssertionBuilders.CastableResultAssertionBuilder<TActual, TActual> ThrowsNothing<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueDelegateSource<TActual> delegateSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableDelegateAssertionBuilder ThrowsWithin(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource, System.TimeSpan timeSpan, [System.Runtime.CompilerServices.CallerArgumentExpression(\"timeSpan\")] string? doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableDelegateAssertionBuilder ThrowsWithin<TException>(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource, System.TimeSpan timeSpan, [System.Runtime.CompilerServices.CallerArgumentExpression(\"timeSpan\")] string? doNotPopulateThisValue = null)\n        where TException : System.Exception { }\n    public static TUnit.Assertions.AssertConditions.Throws.ThrowsException<TActual, TException> WithParameterName<TActual, TException>(this TUnit.Assertions.AssertConditions.Throws.ThrowsException<TActual, TException> throwsException, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null)\n        where TException : System.ArgumentException { }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Test Initialization Exceptions in C#\nDESCRIPTION: Exception handling block that creates a failed test metadata entry when a test initialization fails. It captures the exception and wraps it in a TestFailedInitializationException.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenWithCancellationTokenTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests>\n\t{\n\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS3:{testMethodDataIndex}:TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests.MyTest(int,System.Threading.CancellationToken):0\",\n\t\tMethodName = $\"MyTest\",\n\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"MethodDataSourceDrivenWithCancellationTokenTests.MyTest failed to initialize\", exception),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 10,\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RegexMatch Nested Class within StringMatcher in TUnit (C#)\nDESCRIPTION: Defines the sealed `RegexMatch` class, nested within `StringMatcher`, representing a regular expression-based string matching strategy. It includes a method `IgnoringCase` to configure case sensitivity and overrides `ToString`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_26\n\nLANGUAGE: csharp\nCODE:\n```\n        public sealed class RegexMatch : TUnit.Assertions.AssertConditions.StringMatcher\n        {\n            public TUnit.Assertions.AssertConditions.StringMatcher.RegexMatch IgnoringCase(bool ignoreCase = true) { }\n            public override string ToString() { }\n        }\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Hook Source for Base1\nDESCRIPTION: Auto-generated class implementing ITestHookSource interface for Base1 test class, handling test-level hooks including BeforeEach1 method registration\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeAllTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_Base1 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_Base1();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Applying a Global Parallel Execution Limit with ParallelLimiter in C#\nDESCRIPTION: This snippet shows how to apply the ParallelLimiter attribute at the assembly level, enforcing a global parallel execution limit specified by an implementation of IParallelLimit. It requires a type such as MyParallelLimit that defines the limit and has a public parameterless constructor. This ensures the constraint is shared across all relevant tests in the assembly unless overridden at a lower scope. The attribute must be placed at the assembly level for global effect.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/parallel-limiter.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: ParallelLimiter<MyParallelLimit>]\n```\n\n----------------------------------------\n\nTITLE: Creating ThrowsWithMessageAssertCondition Class in C#\nDESCRIPTION: Implements an assertion condition to check if an exception with a specific message is thrown. Uses generic type constraints and string comparison.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_74\n\nLANGUAGE: C#\nCODE:\n```\npublic class ThrowsWithMessageAssertCondition<TActual, TException> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<TActual, System.Exception>\n    where TException : System.Exception\n{\n    public ThrowsWithMessageAssertCondition(string expectedMessage, System.StringComparison stringComparison, System.Func<System.Exception?, System.Exception?> exceptionSelector) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting TUnit Test Metadata for Explicit Method Arguments in C#\nDESCRIPTION: This C# code snippet demonstrates the latter part of a source-generated method responsible for collecting test metadata for a specific test case. It initializes a `TestBuilderContext`, sets up a factory (`ResettableLazy`) for creating test class instances (`ArgumentWithImplicitConverterTests`), and prepares the method argument (`ExplicitInteger` with value 3). It then adds a `TestMetadata` object to a list, containing details like test ID, arguments, class factory, method factory, and source location. A try-catch block handles potential initialization exceptions by adding `FailedTestMetadata` instead.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ArgumentWithImplicitConverterTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.ArgumentWithImplicitConverterTests),\n\t\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"ArgumentWithImplicitConverterTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName = \"ArgumentWithImplicitConverterTests\",\n\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\tName = \"ArgumentWithImplicitConverterTests\",\n\t\t\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t\t}),\n};\n\n\t\t\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\t\t\tglobal::TUnit.TestProject.ArgumentWithImplicitConverterTests? classInstance = null;\n\t\t\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\t\t\tglobal::TUnit.TestProject.ExplicitInteger methodArg = (global::TUnit.TestProject.ExplicitInteger)(3);\n\n\t\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ArgumentWithImplicitConverterTests>(() => \n\t\t\t\t\t\tnew global::TUnit.TestProject.ArgumentWithImplicitConverterTests()\n\t\t\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.ArgumentWithImplicitConverterTests>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS2:TUnit.TestProject.ArgumentWithImplicitConverterTests.Explicit(TUnit.TestProject.ExplicitInteger):0\",\n\t\t\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Explicit(methodArg)),\n\t\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\t\tTestLineNumber = 5,\n\t\t\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\t\t\ttestBuilderContext = new();\n\t\t\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (global::System.Exception exception)\n\t\t\t\t\t{\n\t\t\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ArgumentWithImplicitConverterTests>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS2:TUnit.TestProject.ArgumentWithImplicitConverterTests.Explicit(TUnit.TestProject.ExplicitInteger):0\",\n\t\t\t\t\t\t\tMethodName = $\"Explicit\",\n\t\t\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ArgumentWithImplicitConverterTests.Explicit failed to initialize\", exception),\n\t\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\t\tTestLineNumber = 5,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn nodes;\n\t\t\t\t}\n\t\t\t}\n\n  \n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for Params Method in C#\nDESCRIPTION: This snippet shows the process of generating test metadata for the Params method in ArgsAsArrayTests. It includes creating test information, setting up test builder context, and adding the test metadata to the collection.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ArgsAsArrayTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.ArgsAsArrayTests),\n\tName = \"Params\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(void),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute(),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(\"arg1\", \"arg2\", \"arg3\")\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string[]>\n\t\t{\n\t\t\tName = \"arguments\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n\t// ... (class information)\n};\n\n// ... (test builder context setup)\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.ArgsAsArrayTests>\n{\n\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.ArgsAsArrayTests.Params(string[]):0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [methodArg],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Params(methodArg)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 5,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining DynamicTest Abstract Class in C#\nDESCRIPTION: Implements an abstract class DynamicTest with required members for dynamic test generation. It includes properties for test attributes, arguments, and methods for building test metadata.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic abstract class DynamicTest : System.IEquatable<TUnit.Core.DynamicTest>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    protected DynamicTest() { }\n    public System.Attribute[] Attributes { get; init; }\n    public System.Collections.Generic.Dictionary<string, object?>? Properties { get; init; }\n    public object?[]? TestClassArguments { get; init; }\n    [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicParameterlessConstructor | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]\n    public abstract System.Type TestClassType { get; }\n    public abstract string TestId { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public object?[] TestMethodArguments { get; init; }\n    public string? TestName { get; init; }\n    public abstract System.Collections.Generic.IEnumerable<TUnit.Core.TestMetadata> BuildTestMetadatas();\n    public System.Attribute[] GetAttributes() { }\n    public static T Argument<T>() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating and Managing Test Metadata with TUnit in CSharp\nDESCRIPTION: This snippet illustrates the creation and management of test method metadata, including data retrieval from methods and classes using AutoFixtureGeneratorAttributes. It requires the TUnit framework and encompasses data generation, lifecycle management, and error handling for test instances.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.Typed.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: CSharp\nCODE:\n```\nvar methodDataAttribute = new global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<int, string, bool>();\n\ntestBuilderContext.DataAttributes.Add(methodDataAttribute);\n\nvar methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\n\nforeach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\n{\n    testMethodDataIndex++;\n    var classArgGeneratedData = classArgGeneratedDataAccessor();\n    int classArg = classArgGeneratedData.Item1;\n    string classArg1 = classArgGeneratedData.Item2;\n    bool classArg2 = classArgGeneratedData.Item3;\n\n    classInstanceArguments = [classArg, classArg1, classArg2];\n\n    var methodArgGeneratedData = methodArgGeneratedDataAccessor();\n    int methodArg = methodArgGeneratedData.Item1;\n    string methodArg1 = methodArgGeneratedData.Item2;\n    bool methodArg2 = methodArgGeneratedData.Item3;\n\n    var resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.DataSourceGeneratorTests>(() => \n    new global::TUnit.TestProject.DataSourceGeneratorTests(classArg, classArg1, classArg2)\n    , sessionId, testBuilderContext);\n    var resettableClassFactory = resettableClassFactoryDelegate();\n\n\n    nodes.Add(new TestMetadata<global::TUnit.TestProject.DataSourceGeneratorTests>\n    {\n        TestId = $\"global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<int, string, bool>:{classDataIndex}:CL-GAC0:global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<int, string, bool>:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.DataSourceGeneratorTests(int,string,bool).GeneratedData_Method2(int,string,bool):0\",\n        TestClassArguments = [classArg, classArg1, classArg2],\n        TestMethodArguments = [methodArg, methodArg1, methodArg2],\n        TestClassProperties = [],\n        CurrentRepeatAttempt = 0,\n        RepeatLimit = 0,\n        ResettableClassFactory = resettableClassFactory,\n        TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.GeneratedData_Method2(methodArg, methodArg1, methodArg2)),\n        TestFilePath = @\"\",\n        TestLineNumber = 17,\n        TestMethod = testInformation,\n        TestBuilderContext = testBuilderContext,\n    });\n    resettableClassFactory = resettableClassFactoryDelegate();\n    testBuilderContext = new();\n    testBuilderContextAccessor.Current = testBuilderContext;\n}\n```\n\nLANGUAGE: CSharp\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n    nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.DataSourceGeneratorTests>\n    {\n        TestId = $\"global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<int, string, bool>:{classDataIndex}:CL-GAC0:global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<int, string, bool>:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.DataSourceGeneratorTests(int,string,bool).GeneratedData_Method2(int,string,bool):0\",\n        MethodName = $\"GeneratedData_Method2\",\n        Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"DataSourceGeneratorTests.GeneratedData_Method2 failed to initialize\", exception),\n        TestFilePath = @\"\",\n        TestLineNumber = 17,\n    });\n}\n```\n\nLANGUAGE: CSharp\nCODE:\n```\nglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\nvar classDataIndex = 0;\nvar testMethodDataIndex = 0;\ntry\n{\n    var testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n    {\n        Type = typeof(global::TUnit.TestProject.DataSourceGeneratorTests),\n        Name = \"GeneratedData_Method2\",\n        GenericTypeCount = 0,\n        ReturnType = typeof(void),\n        Attributes = \n        [\n            new global::TUnit.Core.TestAttribute()\n        ],\n        Parameters = \n        [\n            new global::TUnit.Core.SourceGeneratedParameterInformation<int>\n            {\n                Name = \"value\",\n                Attributes = [],\n            },\n            new global::TUnit.Core.SourceGeneratedParameterInformation<string>\n            {\n                Name = \"value2\",\n                Attributes = [],\n            },\n            new global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n            {\n                Name = \"value3\",\n                Attributes = [],\n            },\n        ],\n        Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.DataSourceGeneratorTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n        {\n            Type = typeof(global::TUnit.TestProject.DataSourceGeneratorTests),\n            Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataSourceGeneratorTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n            {\n                Name = \"DataSourceGeneratorTests\",\n                Attributes = [],\n            }),\n            Name = \"DataSourceGeneratorTests\",\n            Namespace = \"TUnit.TestProject\",\n            Attributes = [],\n            Parameters = \n            [\n                new global::TUnit.Core.SourceGeneratedParameterInformation<int>\n                {\n                    Name = \"value\",\n                    Attributes = [],\n                },\n                new global::TUnit.Core.SourceGeneratedParameterInformation<string>\n                {\n                    Name = \"value2\",\n                    Attributes = [],\n                },\n                new global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n                {\n                    Name = \"value3\",\n                    Attributes = [],\n                },\n            ],\n            Properties = [],\n        }),\n    };\n\n    var testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n    var testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n    global::TUnit.TestProject.DataSourceGeneratorTests? classInstance = null;\n    object?[]? classInstanceArguments = null;\n    var classArgDataGeneratorMetadata = new DataGeneratorMetadata\n    {\n        Type = global::TUnit.Core.Enums.DataGeneratorType.ClassParameters,\n        TestBuilderContext = testBuilderContextAccessor,\n        TestInformation = testInformation,\n        MembersToGenerate = \n        [\n            new global::TUnit.Core.SourceGeneratedParameterInformation<int>\n            {\n                Name = \"value\",\n                Attributes = [],\n            },\n            new global::TUnit.Core.SourceGeneratedParameterInformation<string>\n            {\n                Name = \"value2\",\n                Attributes = [],\n            },\n            new global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n            {\n                Name = \"value3\",\n                Attributes = [],\n            },\n        ],\n        TestSessionId = sessionId,\n        TestClassInstance = classInstance,\n        ClassInstanceArguments = classInstanceArguments,\n    };\n    var classDataAttribute = new global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute();\n\n    testBuilderContext.DataAttributes.Add(classDataAttribute);\n\n    var classArgGeneratedDataArray = classDataAttribute.GenerateDataSources(classArgDataGeneratorMetadata);\n\n    foreach (var classArgGeneratedDataAccessor in classArgGeneratedDataArray)\n    {\n        classDataIndex++;\n        var methodArgDataGeneratorMetadata = new DataGeneratorMetadata\n        {\n            Type = global::TUnit.Core.Enums.DataGeneratorType.TestParameters,\n            TestBuilderContext = testBuilderContextAccessor,\n            TestInformation = testInformation,\n            MembersToGenerate = \n            [\n                new global::TUnit.Core.SourceGeneratedParameterInformation<int>\n                {\n                    Name = \"value\",\n                    Attributes = [],\n                },\n                new global::TUnit.Core.SourceGeneratedParameterInformation<string>\n                {\n                    Name = \"value2\",\n                    Attributes = [],\n                },\n                new global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n                {\n                    Name = \"value3\",\n                    Attributes = [],\n                },\n            ],\n            TestSessionId = sessionId,\n            TestClassInstance = classInstance,\n            ClassInstanceArguments = classInstanceArguments,\n        };\n        var methodDataAttribute = new global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<int, string, bool>();\n\n        testBuilderContext.DataAttributes.Add(methodDataAttribute);\n\n        var methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\n\n        foreach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\n        {\n            testMethodDataIndex++;\n            var classArgGeneratedData = classArgGeneratedDataAccessor();\n            int classArg = classArgGeneratedData.Item1;\n            string classArg1 = classArgGeneratedData.Item2;\n            bool classArg2 = classArgGeneratedData.Item3;\n\n            classInstanceArguments = [classArg, classArg1, classArg2];\n\n            var methodArgGeneratedData = methodArgGeneratedDataAccessor();\n            int methodArg = methodArgGeneratedData.Item1;\n            string methodArg1 = methodArgGeneratedData.Item2;\n            bool methodArg2 = methodArgGeneratedData.Item3;\n\n            var resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.DataSourceGeneratorTests>(() => \n            new global::TUnit.TestProject.DataSourceGeneratorTests(classArg, classArg1, classArg2)\n            , sessionId, testBuilderContext);\n            var resettableClassFactory = resettableClassFactoryDelegate();\n\n\n            nodes.Add(new TestMetadata<global::TUnit.TestProject.DataSourceGeneratorTests>\n            {\n                TestId = $\"global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<{classDataIndex}:CL-GAC0:global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<int, string, bool>:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.DataSourceGeneratorTests(int,string,bool).GeneratedData_Method2(int,string,bool):0\",\n                TestClassArguments = [classArg, classArg1, classArg2],\n                TestMethodArguments = [methodArg, methodArg1, methodArg2],\n                TestClassProperties = [],\n                CurrentRepeatAttempt = 0,\n                RepeatLimit = 0,\n                ResettableClassFactory = resettableClassFactory,\n                TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.GeneratedData_Method2(methodArg, methodArg1, methodArg2)),\n                TestFilePath = @\"\",\n                TestLineNumber = 17,\n                TestMethod = testInformation,\n                TestBuilderContext = testBuilderContext,\n            });\n            resettableClassFactory = resettableClassFactoryDelegate();\n            testBuilderContext = new();\n            testBuilderContextAccessor.Current = testBuilderContext;\n        }\n    }\n}\ncatch (global::System.Exception exception)\n{\n    nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.DataSourceGeneratorTests>\n    {\n        TestId = $\"global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<int, string, bool>:{classDataIndex}:CL-GAC0:global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<int, string, bool>:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.DataSourceGeneratorTests(int,string,bool).GeneratedData_Method2(int,string,bool):0\",\n        MethodName = $\"GeneratedData_Method2\",\n        Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"DataSourceGeneratorTests.GeneratedData_Method2 failed to initialize\", exception),\n        TestFilePath = @\"\",\n        TestLineNumber = 17,\n    });\n}\nreturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: TestingPlatformBuilderHook for Microsoft Testing Platform Integration\nDESCRIPTION: Static utility class that provides a hook for adding TUnit extensions to the Microsoft Testing Platform builder. This enables seamless integration between TUnit and the testing platform.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic static class TestingPlatformBuilderHook\n{\n    public static void AddExtensions(Microsoft.Testing.Platform.Builder.ITestApplicationBuilder testApplicationBuilder, string[] _) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MappableResultAssertionBuilder Generic Class with Constraint in C#\nDESCRIPTION: This generic class represents a mappable result assertion builder with a type constraint. It inherits from InvokableValueAssertionBuilder and overrides the GetAwaiter method to return a TaskAwaiter for the expected type.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_65\n\nLANGUAGE: C#\nCODE:\n```\npublic class MappableResultAssertionBuilder<TActual, TAssertCondition, TExpected> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>\n    where TAssertCondition : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n{\n    public new System.Runtime.CompilerServices.TaskAwaiter<TExpected?> GetAwaiter() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ThrowsWithMessageMatchingAssertCondition Class in C#\nDESCRIPTION: Implements an assertion condition to check if an exception message matches a given pattern. Uses generic type constraints and a custom StringMatcher.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_75\n\nLANGUAGE: C#\nCODE:\n```\npublic class ThrowsWithMessageMatchingAssertCondition<TActual, TException> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<TActual, System.Exception>\n    where TException : System.Exception\n{\n    public ThrowsWithMessageMatchingAssertCondition(TUnit.Assertions.AssertConditions.StringMatcher match, System.Func<System.Exception?, System.Exception?> exceptionSelector) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Execution Hooks in TUnit - C#\nDESCRIPTION: This snippet defines an abstract class GenericAbstractExecutor that implements hook and test execution interfaces for the TUnit framework. The class provides method signatures for executing before/after hooks for assemblies, classes, tests, sessions, and discovery, and requires implementing an abstract ExecuteAsync method. Dependencies include interfaces and type references to TUnit.Core and System.Threading.Tasks, and the expected input for each method involves context objects and an async action delegate. Outputs are ValueTask-based for asynchronous orchestration. All methods are designed for extensibility, to be implemented by custom executors.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class GenericAbstractExecutor : TUnit.Core.Interfaces.IHookExecutor, TUnit.Core.Interfaces.ITestExecutor\n{\n    protected GenericAbstractExecutor() { }\n    public System.Threading.Tasks.ValueTask ExecuteAfterAssemblyHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.AssemblyHookContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteAfterClassHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.ClassHookContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteAfterTestDiscoveryHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestDiscoveryContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteAfterTestHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteAfterTestSessionHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestSessionContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    protected abstract System.Threading.Tasks.ValueTask ExecuteAsync(System.Func<System.Threading.Tasks.ValueTask> action);\n    public System.Threading.Tasks.ValueTask ExecuteBeforeAssemblyHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.AssemblyHookContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteBeforeClassHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.ClassHookContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteBeforeTestDiscoveryHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.BeforeTestDiscoveryContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteBeforeTestHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteBeforeTestSessionHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestSessionContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public System.Threading.Tasks.ValueTask ExecuteTest(TUnit.Core.TestContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Failed Test Metadata for Exception Handling in C#\nDESCRIPTION: This snippet shows how the framework handles exceptions during test initialization. It creates a FailedTestMetadata object that captures the exception information along with test details for error reporting.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/StringArgumentTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.StringArgumentTests>\n{\n\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS2:TUnit.TestProject.StringArgumentTests.Normal(string):0\",\n\tMethodName = $\"Normal\",\n\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"StringArgumentTests.Normal failed to initialize\", exception),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 5,\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing DefaultExpectedValueAssertCondition in C#\nDESCRIPTION: A class that implements a condition to check if a value is equal to the default value for its type. This allows for testing whether objects have their default values.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_112\n\nLANGUAGE: C#\nCODE:\n```\npublic class DefaultExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n{\n    public DefaultExpectedValueAssertCondition() { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StringEqualToAssertionBuilderWrapper for String Equality Testing\nDESCRIPTION: Specialized assertion builder for string equality checking with various options. It supports ignoring whitespace, treating null and empty strings as equal, and trimming strings before comparison.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_93\n\nLANGUAGE: C#\nCODE:\n```\npublic class StringEqualToAssertionBuilderWrapper : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string>\n{\n    public TUnit.Assertions.AssertionBuilders.Wrappers.StringEqualToAssertionBuilderWrapper IgnoringWhitespace() { }\n    public TUnit.Assertions.AssertionBuilders.Wrappers.StringEqualToAssertionBuilderWrapper WithNullAndEmptyEquality() { }\n    public TUnit.Assertions.AssertionBuilders.Wrappers.StringEqualToAssertionBuilderWrapper WithTrimming() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Null Assertion Condition in TUnit (C#)\nDESCRIPTION: This class implements a basic assertion condition that checks if an actual value (`TActual`) is null. It inherits directly from the generic `BaseAssertCondition<TActual>` and overrides `GetExpectation` to indicate that the expectation is 'null'.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_52\n\nLANGUAGE: csharp\nCODE:\n```\n    public class NullExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n    {\n        public NullExpectedValueAssertCondition() { }\n        protected override string GetExpectation() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Hooks for Base1 Tests in TUnit\nDESCRIPTION: Generated partial class implementing ITestHookSource interface for Base1 test class. Handles test-level hooks including BeforeEveryTest and AfterEveryTest methods.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterAllTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_Base1 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n    [global::System.Runtime.CompilerServices.ModuleInitializer]\n    public static void Initialise()\n    {\n        var instance = new Hooks_Base1();\n        SourceRegistrar.RegisterTestHookSource(instance);\n    }\n    public global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n    {\n        return\n        [\n        ];\n    }\n    // Additional methods omitted for brevity\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing TUnit Test Hook Source in ModuleInitializer\nDESCRIPTION: ModuleInitializer method that registers a new instance of the Hooks_SetupTests class with the SourceRegistrar. This automatically executes when the module is loaded.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeTests.Test.verified.txt#2025-04-22_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tvar instance = new Hooks_SetupTests();\n\tSourceRegistrar.RegisterTestHookSource(instance);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ConvertExceptionToValueAssertCondition in C#\nDESCRIPTION: A class that provides functionality to convert an exception to a value for assertion purposes. This allows for testing exception properties as part of the assertion framework.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_111\n\nLANGUAGE: C#\nCODE:\n```\npublic class ConvertExceptionToValueAssertCondition<TException> : TUnit.Assertions.AssertConditions.BaseAssertCondition<object?>\n    where TException : System.Exception\n{\n    public ConvertExceptionToValueAssertCondition() { }\n    public TException ConvertedExceptionValue { get; }\n    protected override string GetExpectation() { }\n    protected override sealed System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(object? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Negative Assertions in C#\nDESCRIPTION: Extension methods for negative collection assertions including non-equivalence and non-emptiness checks. Provides inverse validation capabilities for collection properties.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_49\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsNotEmpty<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }\n```\n\n----------------------------------------\n\nTITLE: Configuring Method Data Generator Metadata in C#\nDESCRIPTION: Sets up metadata for generating test method parameters, specifying the parameter type, name, and associated attributes. This configuration is used to generate data for matrix-based tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1821.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar methodArgDataGeneratorMetadata = new DataGeneratorMetadata\n{\n\tType = global::TUnit.Core.Enums.DataGeneratorType.TestParameters,\n\tTestBuilderContext = testBuilderContextAccessor,\n\tTestInformation = testInformation,\n\tMembersToGenerate = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"value\",\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.MatrixInstanceMethodAttribute<global::TUnit.TestProject.Bugs._1821.Tests>(\"DataSource\")\n\t\t\t],\n\t\t},\n\t],\n\tTestSessionId = sessionId,\n\tTestClassInstance = classInstance,\n\tClassInstanceArguments = classInstanceArguments,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining WithTransform Method Signature in TUnit (C#)\nDESCRIPTION: This method signature, likely part of a base class or interface within TUnit assertions, defines a way to apply transformations to both the actual and expected values before comparison. It accepts two function delegates (`actualTransformation` and `expectedTransformation`) for this purpose.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\n        public void WithTransform(System.Func<TActual?, TActual?> actualTransformation, System.Func<TExpected?, TExpected?> expectedTransformation) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing StringEqualToAssertionBuilderWrapper in C#\nDESCRIPTION: Wrapper for string equality assertions with options to ignore whitespace, trim strings, or treat null and empty strings as equal.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_96\n\nLANGUAGE: C#\nCODE:\n```\n    public class StringEqualToAssertionBuilderWrapper : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string>\n    {\n        public TUnit.Assertions.AssertionBuilders.Wrappers.StringEqualToAssertionBuilderWrapper IgnoringWhitespace() { }\n        public TUnit.Assertions.AssertionBuilders.Wrappers.StringEqualToAssertionBuilderWrapper WithNullAndEmptyEquality() { }\n        public TUnit.Assertions.AssertionBuilders.Wrappers.StringEqualToAssertionBuilderWrapper WithTrimming() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Registering and Initializing High Priority Tests in TUnit C# (High_1)\nDESCRIPTION: This snippet defines a method to register and initialize a high priority test named 'High_1'. It sets up necessary test metadata and creates instances required for test execution within the TUnit framework. In case of exceptions during initialization, they are captured and handled properly. It depends on TUnit.Core and related namespaces.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/PriorityFilteringTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class PriorityFilteringTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new PriorityFilteringTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.PriorityFilteringTests),\n\t\t\t\tName = \"High_1\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.TestProject.PriorityAttribute(global::TUnit.TestProject.Enums.PriorityLevel.High)\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.PriorityFilteringTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.PriorityFilteringTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"PriorityFilteringTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"PriorityFilteringTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"PriorityFilteringTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.PriorityFilteringTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.PriorityFilteringTests>(() => \n\t\t\t\tnew global::TUnit.TestProject.PriorityFilteringTests()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.PriorityFilteringTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"TUnit.TestProject.PriorityFilteringTests.High_1:0\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.High_1()),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 12,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.PriorityFilteringTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"TUnit.TestProject.PriorityFilteringTests.High_1:0\",\n\t\t\t\t\tMethodName = $\"High_1\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"PriorityFilteringTests.High_1 failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 12,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n\t}\n\n```\n\n----------------------------------------\n\nTITLE: Declaring Abstract DataSourceGeneratorAttribute for Custom Test Data Generation - C#\nDESCRIPTION: This set of abstract attribute classes (with 1-5 generic type parameters) allows implementation of custom test data generation for parameterized tests in TUnit. When inherited and applied to classes or methods, these attributes mandate overriding GenerateDataSources to enumerate functions returning the desired parameters as single objects or tuples. This powers extensible, strongly-typed data-driven testing.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method | System.AttributeTargets.Property, AllowMultiple=true)]\npublic abstract class DataSourceGeneratorAttribute<T> : TUnit.Core.TestDataAttribute, TUnit.Core.IDataAttribute\n{\n    protected DataSourceGeneratorAttribute() { }\n    public abstract System.Collections.Generic.IEnumerable<System.Func<T>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata);\n}\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\npublic abstract class DataSourceGeneratorAttribute<T1, T2> : TUnit.Core.TestDataAttribute, TUnit.Core.IDataAttribute\n{\n    protected DataSourceGeneratorAttribute() { }\n    public abstract System.Collections.Generic.IEnumerable<System.Func<System.ValueTuple<T1, T2>>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata);\n}\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\npublic abstract class DataSourceGeneratorAttribute<T1, T2, T3> : TUnit.Core.TestDataAttribute, TUnit.Core.IDataAttribute\n{\n    protected DataSourceGeneratorAttribute() { }\n    public abstract System.Collections.Generic.IEnumerable<System.Func<System.ValueTuple<T1, T2, T3>>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata);\n}\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\npublic abstract class DataSourceGeneratorAttribute<T1, T2, T3, T4> : TUnit.Core.TestDataAttribute, TUnit.Core.IDataAttribute\n{\n    protected DataSourceGeneratorAttribute() { }\n    public abstract System.Collections.Generic.IEnumerable<System.Func<System.ValueTuple<T1, T2, T3, T4>>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata);\n}\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\npublic abstract class DataSourceGeneratorAttribute<T1, T2, T3, T4, T5> : TUnit.Core.TestDataAttribute, TUnit.Core.IDataAttribute\n{\n    protected DataSourceGeneratorAttribute() { }\n    public abstract System.Collections.Generic.IEnumerable<System.Func<System.ValueTuple<T1, T2, T3, T4, T5>>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ITestHookSource for MyTests Class in C#\nDESCRIPTION: Auto-generated partial class that implements ITestHookSource for MyTests class. It includes module initialization and methods to collect test hooks, specifically registering a SetupMyTests method as a before-test hook.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Hooks1594.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_MyTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_MyTests();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.Bugs._1594.MyTests),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1594.MyTests),\n\t\t\t\t\tName = \"SetupMyTests\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(void),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._1594.MyTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1594.MyTests),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Hooks1594\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"Hooks1594\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"MyTests\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._1594\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = \n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.Bugs._1594.MyFixture>\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName = \"myFixture\",\n\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.Bugs._1594.MyTests)classInstance).SetupMyTests()),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\t\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t\t{\n\t\t\treturn\n\t\t\t[\n\t\t\t];\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing InvokableAssertionBuilder Generic Class in C#\nDESCRIPTION: This generic class represents an invokable assertion builder. It inherits from AssertionBuilder and implements ISource and IInvokableAssertionBuilder interfaces. It includes methods for getting assertion results and an awaiter.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_60\n\nLANGUAGE: C#\nCODE:\n```\npublic class InvokableAssertionBuilder<TActual> : TUnit.Assertions.AssertionBuilders.AssertionBuilder, TUnit.Assertions.AssertConditions.Interfaces.ISource, TUnit.Assertions.AssertionBuilders.IInvokableAssertionBuilder\n{\n    protected System.Collections.Generic.Stack<TUnit.Assertions.AssertConditions.BaseAssertCondition> Assertions { get; }\n    public System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<TUnit.Assertions.AssertConditions.AssertionResult>> GetAssertionResults() { }\n    public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Comparable Value Assertions in C#\nDESCRIPTION: Classes for asserting comparable value ranges with inclusive and exclusive bounds checking\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_60\n\nLANGUAGE: C#\nCODE:\n```\npublic class BetweenAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n    where TActual : System.IComparable<TActual>\n{\n    public BetweenAssertCondition(TActual minimum, TActual maximum) { }\n    public void Exclusive() { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n    public void Inclusive() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Auto-Generated TUnit Test Class Implementation in C#\nDESCRIPTION: This code defines a source-generated partial class 'MyTests' that implements TUnit's ITestSource interface. It provides test collection functionality, generating test metadata for test discovery and execution from the TUnit.TestProject.Bugs._1594.MyTests class.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1594.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[  \n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class MyTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new MyTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1594.MyTests),\n\t\t\t\tName = \"Test1\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute()\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._1594.MyTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1594.MyTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Tests1594\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"Tests1594\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"MyTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._1594\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.Bugs._1594.MyFixture>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"myFixture\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.Bugs._1594.MyTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tvar classArgDataGeneratorMetadata = new DataGeneratorMetadata\n\t\t\t\t{\n\t\t\t\t\tType = global::TUnit.Core.Enums.DataGeneratorType.ClassParameters,\n\t\t\t\t\tTestBuilderContext = testBuilderContextAccessor,\n\t\t\t\t\tTestInformation = testInformation,\n\t\t\t\t\tMembersToGenerate = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.Bugs._1594.MyFixture>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"myFixture\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tTestSessionId = sessionId,\n\t\t\t\t\tTestClassInstance = classInstance,\n\t\t\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t\t\t};\n\t\t\t\tvar classDataAttribute = new global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.Bugs._1594.MyFixture>()\n\t\t\t\t{\n\t\t\t\t\tShared = global::TUnit.Core.SharedType.None,\n};\n\n\t\t\t\t\ttestBuilderContext.DataAttributes.Add(classDataAttribute);\n\n\t\t\t\t\tvar classArgGeneratedDataArray = classDataAttribute.GenerateDataSources(classArgDataGeneratorMetadata);\n\n\t\t\t\t\tforeach (var classArgGeneratedDataAccessor in classArgGeneratedDataArray)\n\t\t\t\t\t{\n\t\t\t\t\t\tclassDataIndex++;\n\t\t\t\t\t\tvar classArgGeneratedData = classArgGeneratedDataAccessor();\n\t\t\t\t\t\tclassInstanceArguments = [classArgGeneratedData];\n\n\t\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._1594.MyTests>(() => \n\t\t\t\t\t\tnew global::TUnit.TestProject.Bugs._1594.MyTests(classArgGeneratedData)\n\t\t\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._1594.MyTests>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.Bugs._1594.MyFixture>:{classDataIndex}:CL-GAC0:TUnit.TestProject.Bugs._1594.MyTests(TUnit.TestProject.Bugs._1594.MyFixture).Test1:0\",\n\t\t\t\t\t\t\tTestClassArguments = [classArgGeneratedData],\n\t\t\t\t\t\t\tTestMethodArguments = [],\n\t\t\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Test1()),\n\t\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\t\tTestLineNumber = 12,\n\t\t\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\t\t\ttestBuilderContext = new();\n\t\t\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (global::System.Exception exception)\n\t\t\t\t{\n\t\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._1594.MyTests>\n\t\t\t\t\t{\n\t\t\t\t\t\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.Bugs._1594.MyFixture>:{classDataIndex}:CL-GAC0:TUnit.TestProject.Bugs._1594.MyTests(TUnit.TestProject.Bugs._1594.MyFixture).Test1:0\",\n\t\t\t\t\t\tMethodName = $\"Test1\",\n\t\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"MyTests.Test1 failed to initialize\", exception),\n\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\tTestLineNumber = 12,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn nodes;\n\t\t\t}\n\t\t}\n\n]\n```\n\n----------------------------------------\n\nTITLE: Implementing OrAssertionException for Handling Multiple Assertion Failures\nDESCRIPTION: Custom exception class extending AggregateException to handle multiple assertion failures in OR conditions. It collects all exceptions that occurred during evaluation of logical OR assertion groups.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_75\n\nLANGUAGE: C#\nCODE:\n```\npublic class OrAssertionException : System.AggregateException\n{\n    public OrAssertionException(System.Collections.Generic.IEnumerable<System.Exception> exceptions) { }\n    public override string Message { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Test Collection Method for Null Arguments in TUnit\nDESCRIPTION: The Tests1 method creates additional test metadata for the NullTest method, similar to Tests0 but with a different approach to handling null string arguments. This implementation helps test different null handling scenarios.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1692.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests1(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1692.Tests),\n\t\t\tName = \"NullTest\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(null),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(null)\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t{\n\t\t\t\t\tName = \"t\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._1692.Tests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1692.Tests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Tests1692\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"Tests1692\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"Tests\",\n\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._1692\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.Bugs._1692.Tests? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tclassInstanceArguments = [];\n\n\t\t\tstring methodArg = null;\n\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._1692.Tests>(() => \n\t\t\tnew global::TUnit.TestProject.Bugs._1692.Tests()\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._1692.Tests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS1:TUnit.TestProject.Bugs._1692.Tests.NullTest(string):0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.NullTest(methodArg)),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 10,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._1692.Tests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS1:TUnit.TestProject.Bugs._1692.Tests.NullTest(string):0\",\n\t\t\t\tMethodName = $\"NullTest\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"Tests.NullTest failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 10,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n```\n\n----------------------------------------\n\nTITLE: Starting Local Docusaurus Development Server - Shell\nDESCRIPTION: Executes the Yarn start command to run Docusaurus's local development server. Automatically opens the website in the browser and enables hot reloading for live previews of content changes. No extra dependencies beyond Docusaurus are required. Intended for development use only; server listens locally by default.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/README.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n```\n$ yarn start\n```\n```\n\n----------------------------------------\n\nTITLE: IFilterReceiver Interface for TUnit Engine\nDESCRIPTION: Interface for components that can receive test filters. This allows filter criteria to be passed to various components in the testing framework to control which tests are executed.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IFilterReceiver\n{\n    string? Filter { set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Global Shared Data Key for Test Data in C#\nDESCRIPTION: Class for managing shared data keys with global scope. Includes type-based key creation and equality comparison functionality with a static random key for unique identification.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic class GlobalSharedDataKey : TUnit.Core.SharedDataKey, System.IEquatable<TUnit.Core.GlobalSharedDataKey>\n{\n    public static readonly System.Guid RandomKey;\n    public GlobalSharedDataKey(System.Type Type) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Test Metadata Generation with Error Handling in C#\nDESCRIPTION: Creates test metadata including test IDs, arguments, factories and error handling. Sets up test builder context and manages test class instantiation.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceClassCombinedWithDataSourceMethodTests.Test.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod? classInstance = null;\nobject?[]? classInstanceArguments = null;\nint classArg = global::TUnit.TestProject.CommonTestData.Two();\nclassInstanceArguments = [classArg];\n\nint methodArg = global::TUnit.TestProject.CommonTestData.Three();\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod>(() => \nnew global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod(classArg)\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod>\n{\n    TestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS1:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS2:TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod(int).DataSourceClassCombinedWithDataSourceMethodTest(int):0\",\n    TestClassArguments = [classArg],\n    TestMethodArguments = [methodArg],\n    TestClassProperties = [],\n    CurrentRepeatAttempt = 0,\n    RepeatLimit = 0,\n    ResettableClassFactory = resettableClassFactory,\n    TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSourceClassCombinedWithDataSourceMethodTest(methodArg)),\n    TestFilePath = @\"\",\n    TestLineNumber = 10,\n    TestMethod = testInformation,\n    TestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Inheritance Attribute in C#\nDESCRIPTION: Attribute for marking test classes that should inherit tests from parent classes. Used to enable test inheritance in the class hierarchy.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Class)]\npublic sealed class InheritsTestsAttribute : TUnit.Core.TUnitAttribute\n{\n    public InheritsTestsAttribute() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ResettableLazy<T> Class in C#\nDESCRIPTION: Creates a resettable lazy-loading implementation that supports asynchronous disposal. It includes methods for cloning and resetting the lazy instance.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\npublic class ResettableLazy<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]  T> : System.IAsyncDisposable\n    where T :  class\n{\n    protected readonly string SessionId;\n    protected System.Func<T> _factory;\n    public ResettableLazy(System.Func<T> factory, string sessionId, TUnit.Core.TestBuilderContext testBuilderContext) { }\n    protected ResettableLazy(TUnit.Core.Interfaces.IClassConstructor classConstructor, string sessionId, TUnit.Core.TestBuilderContext testBuilderContext) { }\n    public TUnit.Core.Interfaces.IClassConstructor? ClassConstructor { get; protected set; }\n    public TUnit.Core.TestBuilderContext TestBuilderContext { get; }\n    public T Value { get; }\n    public TUnit.Core.ResettableLazy<T> Clone() { }\n    public System.Threading.Tasks.ValueTask DisposeAsync() { }\n    public virtual System.Threading.Tasks.ValueTask ResetLazy() { }\n    protected static System.Threading.Tasks.ValueTask DisposeAsync(object? obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Synchronous Test Source Generation in C#\nDESCRIPTION: Auto-generated source code for handling synchronous test method execution in TUnit. Includes test metadata collection, instance management, and error handling for the SynchronousTest method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Dynamic/Basic.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class BasicTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new BasicTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BasicTests),\n\t\t\t\tName = \"SynchronousTest\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute()\n\t\t\t\t],\n\t\t\t\tParameters = []\n\t\t\t}\n```\n\n----------------------------------------\n\nTITLE: Registering Assertions and Conversions in C#\nDESCRIPTION: This snippet defines extension methods for registering assertions and conversions in TUnit. It includes methods for both delegate and value sources, as well as a specialized method for exception conversions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_151\n\nLANGUAGE: C#\nCODE:\n```\npublic static class SourceExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableDelegateAssertionBuilder RegisterAssertion<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource, TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual> assertCondition, string?[] argumentExpressions, [System.Runtime.CompilerServices.CallerMemberName] string? caller = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> RegisterAssertion<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> source, TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual> assertCondition, string?[] argumentExpressions, [System.Runtime.CompilerServices.CallerMemberName] string? caller = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TToType> RegisterConversionAssertion<TToType>(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource source)\n        where TToType : System.Exception { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TToType> RegisterConversionAssertion<TFromType, TToType>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TFromType> source, TUnit.Assertions.AssertConditions.ConvertToAssertCondition<TFromType, TToType> assertCondition, string?[] argumentExpressions, [System.Runtime.CompilerServices.CallerMemberName] string? caller = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CollectionWrapper Class in C#\nDESCRIPTION: Implements a generic CollectionWrapper class for asserting conditions on collections. It provides methods to satisfy assertions on individual elements or mapped values of the collection.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class CollectionWrapper<TInner>\n{\n    public CollectionWrapper(TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> Satisfy(System.Func<TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TInner?>, TUnit.Assertions.AssertionBuilders.IInvokableAssertionBuilder> assert, [System.Runtime.CompilerServices.CallerArgumentExpression(\"assert\")] string assertionBuilderExpression = \"\") { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> Satisfy<TExpected>(System.Func<TInner?, System.Threading.Tasks.Task<TExpected>?> asyncMapper, System.Func<TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TExpected?>, TUnit.Assertions.AssertionBuilders.IInvokableAssertionBuilder> assert, [System.Runtime.CompilerServices.CallerArgumentExpression(\"asyncMapper\")] string mapperExpression = \"\", [System.Runtime.CompilerServices.CallerArgumentExpression(\"assert\")] string assertionBuilderExpression = \"\") { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> Satisfy<TExpected>(System.Func<TInner?, TExpected> mapper, System.Func<TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TExpected?>, TUnit.Assertions.AssertionBuilders.IInvokableAssertionBuilder> assert, [System.Runtime.CompilerServices.CallerArgumentExpression(\"mapper\")] string mapperExpression = \"\", [System.Runtime.CompilerServices.CallerArgumentExpression(\"assert\")] string assertionBuilderExpression = \"\") { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Timing Class for Performance Measurement\nDESCRIPTION: A class for measuring and storing execution timing information. It captures the start and end times of a test step and calculates the duration, providing a standardized way to track performance metrics across tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\npublic Timing(string StepName, System.DateTimeOffset Start, System.DateTimeOffset End) { }\n        public System.TimeSpan Duration { get; }\n        public System.DateTimeOffset End { get; init; }\n        public System.DateTimeOffset Start { get; init; }\n        public string StepName { get; init; }\n```\n\n----------------------------------------\n\nTITLE: Assigning Setup Hook Method Body for TUnit Test Class in C#\nDESCRIPTION: This snippet provides the body implementation for the setup hook method, invoking the 'SetupBase' method on the test class instance via reflection and converting its execution for asynchronous handling. Dependencies include AsyncConvert utility, reflection, and proper definition of the 'SetupBase' method. Input is a class instance, and output is an async operation, with limitations tied to method existence and correct binding.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Hooks1594.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nBody = (classInstance, context, cancellationToken) => AsyncConvert.ConvertObject(() => classInstance.GetType().GetMethod(\"SetupBase\", []).Invoke(classInstance, [])),\n```\n\n----------------------------------------\n\nTITLE: TimeSpan Creation Extensions in TUnit\nDESCRIPTION: Extension methods that provide a fluent interface for creating TimeSpan objects from integer values for days, hours, minutes, seconds, and milliseconds.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_157\n\nLANGUAGE: C#\nCODE:\n```\npublic static class TimeSpanExtensions\n{\n    public static System.TimeSpan Days(this int days) { }\n    public static System.TimeSpan Hours(this int hours) { }\n    public static System.TimeSpan Milliseconds(this int milliseconds) { }\n    public static System.TimeSpan Minutes(this int minutes) { }\n    public static System.TimeSpan Seconds(this int seconds) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Member Type Enum in TUnit Assertions (C#)\nDESCRIPTION: This enum defines the different types of members that can be involved in an assertion within the TUnit framework, such as properties, fields, direct values, or items within an enumerable collection.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_36\n\nLANGUAGE: csharp\nCODE:\n```\n    public enum MemberType\n    {\n        Property = 0,\n        Field = 1,\n        Value = 2,\n        EnumerableItem = 3,\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTime and TimeSpan Assertion Conditions in C#\nDESCRIPTION: Defines classes for asserting equality of DateTime, DateTimeOffset, and TimeSpan values. These classes allow setting tolerance for comparisons.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_56\n\nLANGUAGE: C#\nCODE:\n```\npublic class DateTimeEqualsExpectedValueAssertCondition : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<System.DateTime, System.DateTime>\n{\n    public DateTimeEqualsExpectedValueAssertCondition(System.DateTime expected) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(System.DateTime actualValue, System.DateTime expectedValue) { }\n    public void SetTolerance(System.TimeSpan tolerance) { }\n}\n\npublic class DateTimeOffsetEqualsExpectedValueAssertCondition : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<System.DateTimeOffset, System.DateTimeOffset>\n{\n    public DateTimeOffsetEqualsExpectedValueAssertCondition(System.DateTimeOffset expected) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(System.DateTimeOffset actualValue, System.DateTimeOffset expectedValue) { }\n    public void SetTolerance(System.TimeSpan tolerance) { }\n}\n\npublic class TimeSpanEqualsExpectedValueAssertCondition : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<System.TimeSpan, System.TimeSpan>\n{\n    public TimeSpanEqualsExpectedValueAssertCondition(System.TimeSpan expected) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(System.TimeSpan actualValue, System.TimeSpan expectedValue) { }\n    public void SetTolerance(System.TimeSpan tolerance) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining OrAssertionBuilder Class in C#\nDESCRIPTION: This class represents an 'or' assertion builder. It inherits from AssertionBuilder and implements the IOrAssertionBuilder interface.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_66\n\nLANGUAGE: C#\nCODE:\n```\npublic class OrAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder, TUnit.Assertions.AssertionBuilders.IOrAssertionBuilder { }\n```\n\n----------------------------------------\n\nTITLE: Defining TUnit BeforeTest Hook Source (Context Param) in C#\nDESCRIPTION: This auto-generated C# code defines a partial class `Hooks_AssemblySetupTests` implementing `ITestHookSource`. It collects `BeforeTest` hooks. Specifically, it identifies and registers the `SetupWithContext` method (taking `TestContext`) from `TUnit.TestProject.BeforeTests.AssemblySetupTests` as an instance hook, providing detailed metadata including parameters, attributes, and execution body.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyBeforeTests.Test.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.AssemblySetupTests),\n\t\t\t\t\tName = \"SetupWithContext\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"testContext\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.AssemblySetupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.AssemblySetupTests),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AssemblyBeforeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"AssemblyBeforeTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"AssemblySetupTests\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.BeforeTests.AssemblySetupTests)classInstance).SetupWithContext(context)),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\t\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t\t{\n\t\t\treturn\n\t\t\t[\n\t\t\t];\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: Defining DelegateAssertionBuilder Class in C#\nDESCRIPTION: This class represents a delegate assertion builder. It inherits from AssertionBuilder and implements IDelegateSource and ISource interfaces.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_56\n\nLANGUAGE: C#\nCODE:\n```\npublic class DelegateAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder, TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource, TUnit.Assertions.AssertConditions.Interfaces.ISource { }\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for AggregateBy_HasExpectedOutput Method in C#\nDESCRIPTION: Creates test metadata for the AggregateBy_HasExpectedOutput method, including method information, parameters, and test data sources. It handles both numeric and string test data.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GenericMethodTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.GenericMethodTests),\n\t\t\tName = \"AggregateBy_HasExpectedOutput\",\n\t\t\tGenericTypeCount = 3,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"AggregateBy_Numeric_TestData\"),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"AggregateBy_String_TestData\")\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\t// ... (parameter information)\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.GenericMethodTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\t// ... (class information)\n\t\t\t}),\n\t\t};\n\n\t\t// ... (test metadata generation logic)\n\t}\n\tcatch (global::System.Exception exception)\n\t{\n\t\t// ... (exception handling)\n\t}\n\treturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Test Initialization Failures in C#\nDESCRIPTION: This code adds a FailedTestMetadata object to the nodes collection when a test fails to initialize. It captures the exception information and wraps it in a TestFailedInitializationException to provide context about why initialization failed.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/PropertySetterTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.PropertySetterTests>\n\t{\n\t\tTestId = $\"TUnit.TestProject.PropertySetterTests.Test:0\",\n\t\tMethodName = $\"Test\",\n\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"PropertySetterTests.Test failed to initialize\", exception),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 70,\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly Metadata Configuration in TUnit\nDESCRIPTION: These assembly attributes configure internals visibility and target framework for the TUnit.Core library. The InternalsVisibleTo attribute allows the TUnit.Engine assembly to access internal members of this assembly.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@\"TUnit.Engine, PublicKey=0024000004800000940000000602000000240000525341310004000001000100698a70398fa0b2230c5a72e3bd9d56b48f809f6173e49a19fbb942d621be93ad48c5566b47b28faabc359b9ad3ff4e00bbdea88f5bdfa250f391fedd28182b2e37b55d429c0151a42a98ea7a5821818cd15a79fef9903e8607a88304cf3e0317bf86ec96e32e1381535a6582251e5a6eed40b5a3ed82bc444598b1269cce57a7\")]\n[assembly: System.Runtime.Versioning.TargetFramework(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Implementing Assertion Source Interfaces in TUnit\nDESCRIPTION: Shows the hierarchy of assertion source interfaces including IDelegateSource, IValueSource<>, and IValueDelegateSource<> which extend the base ISource interface.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_64\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IDelegateSource : TUnit.Assertions.AssertConditions.Interfaces.ISource { }\npublic interface IValueSource<out TActual> : TUnit.Assertions.AssertConditions.Interfaces.ISource { }\npublic interface IValueDelegateSource<out TActual> : TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource, TUnit.Assertions.AssertConditions.Interfaces.ISource, TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> { }\n```\n\n----------------------------------------\n\nTITLE: Implementing GenericIsNotExtensions Class in C#\nDESCRIPTION: Static class providing negative assertion extension methods. Includes methods for checking non-equality, non-null states, and reference inequality.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_145\n\nLANGUAGE: C#\nCODE:\n```\npublic static class GenericIsNotExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsDefault<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotDefault<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource) { }\n    // ... additional methods omitted for brevity\n```\n\n----------------------------------------\n\nTITLE: Registering Data-Driven Test with Empty String Argument - TUnit - C#\nDESCRIPTION: This snippet defines and registers a C# unit test for the 'EmptyString' method of 'DataDrivenTests', using a data-driven approach with arguments provided by TUnit attributes. It sets up a TestMetadata instance, handles test context instantiation, and captures initialization exceptions. Dependencies are TUnit.Core and .NET standard libraries. The test is integrated via source generator patterns, facilitating repeatable, parameterized unit testing.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class DataDrivenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new DataDrivenTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.DataDrivenTests),\n\t\t\t\tName = \"EmptyString\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\")\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.DataDrivenTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"DataDrivenTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"DataDrivenTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.DataDrivenTests? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tclassInstanceArguments = [];\n\n\t\t\tstring methodArg = \"\";\n\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.DataDrivenTests>(() => \n\t\t\tnew global::TUnit.TestProject.DataDrivenTests()\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.DataDrivenTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.DataDrivenTests.EmptyString(string):0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.EmptyString(methodArg)),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 39,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.DataDrivenTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.DataDrivenTests.EmptyString(string):0\",\n\t\t\t\tMethodName = $\"EmptyString\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"DataDrivenTests.EmptyString failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 39,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing ValueDelegateAssertionBuilder Generic Class in C#\nDESCRIPTION: This generic class represents a value delegate assertion builder. It inherits from AssertionBuilder and implements multiple interfaces including IDelegateSource, ISource, IValueDelegateSource, and IValueSource.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_68\n\nLANGUAGE: C#\nCODE:\n```\npublic class ValueDelegateAssertionBuilder<TActual> : TUnit.Assertions.AssertionBuilders.AssertionBuilder, TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource, TUnit.Assertions.AssertConditions.Interfaces.ISource, TUnit.Assertions.AssertConditions.Interfaces.IValueDelegateSource<TActual>, TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> { }\n```\n\n----------------------------------------\n\nTITLE: Handling Test Initialization Failures in TUnit\nDESCRIPTION: Error handling code for test initialization failures. It captures exceptions and creates a FailedInitializationTest object with detailed information about the test that failed to initialize.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=NamedTupleMethod_testMethodName=NamedTupleMethod.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedInitializationTest\n\t{\n\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS1:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.ClassTupleDataSourceDrivenTests(System.Int32,System.String,System.Boolean).DataSource_TupleMethod(System.Int32,System.String,System.Boolean):0\",\n\t\tTestClass = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests),\n\t\tReturnType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests).GetMethod(\"DataSource_TupleMethod\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]).ReturnType,\n\t\tParameterTypeFullNames = [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)],\n\t\tTestName = \"DataSource_TupleMethod\",\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 24,\n\t\tException = exception,\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Building Test Metadata for Double Arguments - TUnit Source Generator - C#\nDESCRIPTION: Creates and adds a TestMetadata node for a generic unit test which accepts a double and string parameter using the TUnit framework. The snippet builds supporting source-generation metadata objects, initializes a factory for lazy class instantiation, sets the test context, and constructs arguments before adding the configured test to the nodes collection. Prerequisites: TUnit and source generation infrastructure. Inputs: test method arguments, session id, and context; Output: updated list of test metadata.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests2136.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\\nglobal::TUnit.TestProject.Bugs._2136.Tests? classInstance = null;\\nobject?[]? classInstanceArguments = null;\\nclassInstanceArguments = [];\\n\\nglobal::System.Double methodArg = 1.1;\\nstring methodArg1 = \"1.1\";\\n\\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._2136.Tests>(() => \\nnew global::TUnit.TestProject.Bugs._2136.Tests()\\n, sessionId, testBuilderContext);\\nvar resettableClassFactory = resettableClassFactoryDelegate();\\n\\nnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._2136.Tests>\\n{\\n    TestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS2:TUnit.TestProject.Bugs._2136.Tests.GenericArgumentsTest(T,string):0\",\\n    TestClassArguments = [],\\n    TestMethodArguments = [methodArg, methodArg1],\\n    TestClassProperties = [],\\n    CurrentRepeatAttempt = 0,\\n    RepeatLimit = 0,\\n    ResettableClassFactory = resettableClassFactory,\\n    TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.GenericArgumentsTest(methodArg, methodArg1)),\\n    TestFilePath = @\"\",\\n    TestLineNumber = 8,\\n    TestMethod = testInformation,\\n    TestBuilderContext = testBuilderContext,\\n});\\nresettableClassFactory = resettableClassFactoryDelegate();\\ntestBuilderContext = new();\\ntestBuilderContextAccessor.Current = testBuilderContext;\n```\n\n----------------------------------------\n\nTITLE: Implementing ValueAssertionBuilder Generic Class in C#\nDESCRIPTION: This generic class represents a value assertion builder. It inherits from AssertionBuilder and implements ISource and IValueSource interfaces. It takes an ISource as a parameter in its constructor.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_67\n\nLANGUAGE: C#\nCODE:\n```\npublic class ValueAssertionBuilder<TActual> : TUnit.Assertions.AssertionBuilders.AssertionBuilder, TUnit.Assertions.AssertConditions.Interfaces.ISource, TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual>\n{\n    public ValueAssertionBuilder(TUnit.Assertions.AssertConditions.Interfaces.ISource source) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MappableResultAssertionBuilder Generic Class in C#\nDESCRIPTION: This generic class represents a mappable result assertion builder. It inherits from InvokableValueAssertionBuilder and overrides the GetAwaiter method to return a TaskAwaiter for the expected type.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_64\n\nLANGUAGE: C#\nCODE:\n```\npublic class MappableResultAssertionBuilder<TActual, TExpected> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>\n{\n    public new System.Runtime.CompilerServices.TaskAwaiter<TExpected?> GetAwaiter() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ITestSource Interface for ConstantsInInterpolatedStringsTests in C#\nDESCRIPTION: Auto-generated implementation of the ITestSource interface for collecting and registering test metadata for the ConstantsInInterpolatedStringsTests class. It initializes the test environment, collects test metadata including arguments with interpolated strings, and handles test execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ConstantsInInterpolatedStringsTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[  \n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class ConstantsInInterpolatedStringsTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new ConstantsInInterpolatedStringsTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1432.ConstantsInInterpolatedStringsTests),\n\t\t\t\tName = \"SomeTest\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute($\"{\\\"Value\\\"}1\")\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._1432.ConstantsInInterpolatedStringsTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1432.ConstantsInInterpolatedStringsTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"ConstantsInInterpolatedStringsTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"ConstantsInInterpolatedStringsTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"ConstantsInInterpolatedStringsTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._1432\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.Bugs._1432.ConstantsInInterpolatedStringsTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tstring methodArg = $\"{\\\"Value\\\"}1\";\n\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._1432.ConstantsInInterpolatedStringsTests>(() => \n\t\t\t\tnew global::TUnit.TestProject.Bugs._1432.ConstantsInInterpolatedStringsTests()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._1432.ConstantsInInterpolatedStringsTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.Bugs._1432.ConstantsInInterpolatedStringsTests.SomeTest(string):0\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.SomeTest(methodArg)),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 13,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._1432.ConstantsInInterpolatedStringsTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.Bugs._1432.ConstantsInInterpolatedStringsTests.SomeTest(string):0\",\n\t\t\t\t\tMethodName = $\"SomeTest\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ConstantsInInterpolatedStringsTests.SomeTest failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 13,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n\t}\n\n]\n```\n\n----------------------------------------\n\nTITLE: Implementing Collection Equivalence Assertion in C#\nDESCRIPTION: Extension method for asserting that a collection is not equivalent to another collection. It uses a custom comparer and allows specifying collection ordering.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_107\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotEquivalentTo<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"collectionOrdering\")] string doNotPopulateThisValue2 = null)\n    where TActual : System.Collections.Generic.IEnumerable<TInner> { }\n```\n\n----------------------------------------\n\nTITLE: Defining TestFailedException in C#\nDESCRIPTION: Creates a custom exception class for test failures, inheriting from TUnitException.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestFailedException : TUnit.Core.Exceptions.TUnitException\n{\n    public TestFailedException(System.Exception exception) { }\n    public override string StackTrace { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ModuleInitializer Attribute in .NET (C#)\nDESCRIPTION: Defines a sealed ModuleInitializerAttribute class within the System.Runtime.CompilerServices namespace to mark methods as module initializers. Requires the System namespace and utilizes the AttributeUsage attribute to restrict usage to methods without inheritance. This attribute enables methods to run automatically when the assembly is loaded, supporting advanced initialization patterns. No constructor or parameters are defined, and the intended use is in source code targeting post-.NET 5 platforms.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/PolyfillTests.Test_Without_BuildProperty.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[AttributeUsage(AttributeTargets.Method, Inherited = false)]\nsealed class ModuleInitializerAttribute : Attribute;\n```\n\n----------------------------------------\n\nTITLE: Implementing TimeSpanEqualToAssertionBuilderWrapper in C#\nDESCRIPTION: Wrapper for TimeSpan equality assertions that supports specifying a tolerance within which two TimeSpans can be considered equal.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_97\n\nLANGUAGE: C#\nCODE:\n```\n    public class TimeSpanEqualToAssertionBuilderWrapper : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.TimeSpan>\n    {\n        public TUnit.Assertions.AssertionBuilders.Wrappers.TimeSpanEqualToAssertionBuilderWrapper Within(System.TimeSpan tolerance, [System.Runtime.CompilerServices.CallerArgumentExpression(\"tolerance\")] string doNotPopulateThis = \"\") { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing After Class Hook Method in C#\nDESCRIPTION: Defines the AfterClassHookMethod class which executes after a class is processed. It inherits from StaticHookMethod and implements IEquatable.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\npublic class AfterClassHookMethod : TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.ClassHookContext>, System.IEquatable<TUnit.Core.Hooks.AfterClassHookMethod>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public AfterClassHookMethod() { }\n    public override System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.ClassHookContext context, System.Threading.CancellationToken cancellationToken) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Test Builder Context and Data Sources in C#\nDESCRIPTION: Code that sets up the test builder context and configures data sources for test parameters. It creates data generator metadata and uses ClassDataSourceAttribute to generate data for test method parameters.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.ClassDataSourceDrivenTests? classInstance = null;\nobject?[]? classInstanceArguments = null;\nvar methodArgDataGeneratorMetadata = new DataGeneratorMetadata\n{\n\tType = global::TUnit.Core.Enums.DataGeneratorType.TestParameters,\n\tTestBuilderContext = testBuilderContextAccessor,\n\tTestInformation = testInformation,\n\tMembersToGenerate = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.InitializableClass>\n\t\t{\n\t\t\tName = \"class1\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n\tTestSessionId = sessionId,\n\tTestClassInstance = classInstance,\n\tClassInstanceArguments = classInstanceArguments,\n};\nvar methodDataAttribute = new global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.InitializableClass>();\n\ntestBuilderContext.DataAttributes.Add(methodDataAttribute);\n\nvar methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\n```\n\n----------------------------------------\n\nTITLE: Implementing Resettable Lazy in C#\nDESCRIPTION: Defines a generic class for lazy initialization of resources that can be reset between tests. This facilitates efficient resource management in test fixtures, especially for resources that are expensive to create.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\npublic class ResettableLazy<T> : System.IAsyncDisposable\n    where T :  class\n{\n    protected readonly string SessionId;\n    protected System.Func<T> _factory;\n    public ResettableLazy(System.Func<T> factory, string sessionId, TUnit.Core.TestBuilderContext testBuilderContext) { }\n    protected ResettableLazy(TUnit.Core.Interfaces.IClassConstructor classConstructor, string sessionId, TUnit.Core.TestBuilderContext testBuilderContext) { }\n    public TUnit.Core.Interfaces.IClassConstructor? ClassConstructor { get; protected set; }\n    public TUnit.Core.TestBuilderContext TestBuilderContext { get; }\n    public T Value { get; }\n    public TUnit.Core.ResettableLazy<T> Clone() { }\n    public System.Threading.Tasks.ValueTask DisposeAsync() { }\n    public virtual System.Threading.Tasks.ValueTask ResetLazy() { }\n    protected static System.Threading.Tasks.ValueTask DisposeAsync(object? obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GetOnlyDictionary Class in C#\nDESCRIPTION: A generic dictionary implementation with read-only access pattern that requires non-null keys. Provides methods for retrieving values, adding key-value pairs conditionally, and removing entries.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_53\n\nLANGUAGE: C#\nCODE:\n```\npublic class GetOnlyDictionary<TKey, TValue>\n    where TKey :  notnull\n{\n    public GetOnlyDictionary() { }\n    public TValue this[TKey key] { get; }\n    public System.Collections.Generic.ICollection<TKey> Keys { get; }\n    public System.Collections.Generic.ICollection<TValue> Values { get; }\n    public TValue GetOrAdd(TKey key, System.Func<TKey, TValue> func) { }\n    public TValue GetOrAdd(TKey key, System.Func<TKey, TValue> func, out bool previouslyExisted) { }\n    public TValue? Remove(TKey key) { }\n    public bool TryGetValue(TKey key, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out TValue? value) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Test Source Class in C#\nDESCRIPTION: Auto-generated partial class that implements IDynamicTestSource interface to collect and execute dynamic tests. Includes initialization logic and exception handling for test collection failures.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Basic.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[  \n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Basic : global::TUnit.Core.Interfaces.SourceGenerator.IDynamicTestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterDynamic(new Basic());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<DynamicTest> CollectDynamicTests(string sessionId)\n\t{\n\t\ttry\n\t\t{\n\t\t\tvar context = new global::TUnit.Core.DynamicTestBuilderContext(@\"\", 40);\n\t\t\tnew global::TUnit.TestProject.DynamicTests.Basic().BuildTests(context);\n\t\t\treturn context.Tests;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\treturn\n\t\t\t[\n\t\t\t\tnew FailedDynamicTest<global::TUnit.TestProject.DynamicTests.Basic>\n\t\t\t\t{\n\t\t\t\t\tTestId = @\"global::TUnit.TestProject.DynamicTests.BasicBuildTests\",\n\t\t\t\t\tMethodName = $\"BuildTests\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"Basic.BuildTests failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 40,\n\t\t\t\t}\n\t\t\t];\n\t\t}\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for DataSource_Class Method in C#\nDESCRIPTION: This snippet shows the generation of test metadata for the DataSource_Class method. It uses ClassDataSourceAttribute with shared keyed data sources and creates TestMetadata objects for each generated data source.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTestsSharedKeyed.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.ClassDataSourceDrivenTestsSharedKeyed),\n\tName = \"DataSource_Class\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(void),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute()\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<SomeAsyncDisposableClass>\n\t\t{\n\t\t\tName = \"value\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n\t// ... (additional properties)\n};\n\n// ... (test builder context and data generation)\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.ClassDataSourceDrivenTestsSharedKeyed>\n{\n\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<SomeAsyncDisposableClass>:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.ClassDataSourceDrivenTestsSharedKeyed.DataSource_Class(SomeAsyncDisposableClass):0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [methodArgGeneratedData],\n\t// ... (additional properties)\n});\n```\n\n----------------------------------------\n\nTITLE: Character Comparison Extensions in C#\nDESCRIPTION: Extension methods for character value assertions with support for both nullable and non-nullable char types. Provides equality comparison functionality.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_46\n\nLANGUAGE: C#\nCODE:\n```\npublic static class CharIsExtensions {\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<char> IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<char> valueSource, char expected) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<char?> IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<char?> valueSource, char expected) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<char?> IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<char?> valueSource, char? expected) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing After Test Discovery Hook Method in C#\nDESCRIPTION: Defines the AfterTestDiscoveryHookMethod class which executes after test discovery. It inherits from StaticHookMethod and implements IEquatable.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\npublic class AfterTestDiscoveryHookMethod : TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.TestDiscoveryContext>, System.IEquatable<TUnit.Core.Hooks.AfterTestDiscoveryHookMethod>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public AfterTestDiscoveryHookMethod() { }\n    public override System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.TestDiscoveryContext context, System.Threading.CancellationToken cancellationToken) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring and Catching Exceptions in Test Initialization for TUnit\nDESCRIPTION: This snippet shows how TUnit initializes test execution with data source parameters and handles exceptions during test setup. It creates test nodes, configures test properties, and catches initialization exceptions to add failed test records.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=TupleMethod_testMethodName=NamedTupleMethod.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nTestClassProperties = [propertyArg, propertyArg1, propertyArg2, propertyArg3],\nCurrentRepeatAttempt = 0,\nRepeatLimit = 0,\nMethodInfo = methodInfo,\nResettableClassFactory = resettableClassFactory,\nTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_TupleMethod(methodArg, methodArg1, methodArg2)),\nTestFilePath = @\"\",\nTestLineNumber = 24,\nTestAttributes = [ new global::TUnit.Core.TestAttribute()\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n{\n    \n} ],\nClassAttributes = [ new global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n{\n    \n} ],\nAssemblyAttributes = [  ],\nDataAttributes = [  ],\nTestBuilderContext = testBuilderContext,\n});\nresettableClassFactory = resettableClassFactoryDelegate();\ntestBuilderContext = new();\ntestBuilderContextAccessor.Current = testBuilderContext;\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Negative Assertion Extensions in C#\nDESCRIPTION: Defines extension methods for generic negative assertions, including checks for default values and inequality comparisons.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_67\n\nLANGUAGE: C#\nCODE:\n```\npublic static class GenericIsNotExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsDefault<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotDefault<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.GenericNotEqualToAssertionBuilderWrapper<TActual> IsNotEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotEquatableOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Exception Message Assertions in C#\nDESCRIPTION: Classes for asserting exception message content including equality, containing, starting with, and ending with conditions\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_61\n\nLANGUAGE: C#\nCODE:\n```\npublic class ExceptionMessageContainingExpectedValueAssertCondition<TException> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TException, string>\n    where TException : System.Exception\n{\n    public ExceptionMessageContainingExpectedValueAssertCondition(string expected, System.StringComparison stringComparison) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TException? actualValue, string? expectedValue) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Matrix Attribute in C#\nDESCRIPTION: Defines a generic Matrix attribute that allows specifying test parameters for matrix-style combinatorial testing.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic class MatrixAttribute<T> : TUnit.Core.MatrixAttribute\n{\n    public MatrixAttribute(params T?[]? objects) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Regex Matching with Case Sensitivity\nDESCRIPTION: Method to configure case sensitivity for regex matching in string assertions, returning the matcher for fluent API chaining.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic TUnit.Assertions.AssertConditions.StringMatcher.RegexMatch IgnoringCase(bool ignoreCase = true) { }\n```\n\n----------------------------------------\n\nTITLE: Defining BeforeAllSetUpWithContext Hook for TUnit in C#\nDESCRIPTION: Creates a hook method to be invoked before assembly execution in TUnit, accepting an AssemblyHookContext parameter. Depends on TUnit.Core, and the containing class must be registered via SourceRegistrar. Accepts a context for advanced setup scenarios; the hook is asynchronous and is decorated as an assembly-level before hook.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyBeforeTests.Test.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.BeforeTests.AssemblySetupTests),\n\tName = \"BeforeAllSetUpWithContext\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Assembly)\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.AssemblyHookContext>\n\t\t{\n\t\t\tName = \"context\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.AssemblySetupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t{\n\t\tType = typeof(global::TUnit.TestProject.BeforeTests.AssemblySetupTests),\n\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AssemblyBeforeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t{\n\t\t\tName = \"AssemblyBeforeTests\",\n\t\t\tAttributes = [],\n\t\t}),\n\t\tName = \"AssemblySetupTests\",\n\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\tAttributes = [],\n\t\tParameters = [],\n\t\tProperties = [],\n\t}),\n},\nBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.BeforeTests.AssemblySetupTests.BeforeAllSetUpWithContext(context)),\nHookExecutor = DefaultExecutor.Instance,\nOrder = 0,\nFilePath = @\"\",\nLineNumber = 56,\nMethodAttributes = \n[\n\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Assembly)\n],\nClassAttributes = [],\nAssemblyAttributes = [],\n\n```\n\n----------------------------------------\n\nTITLE: Source Interface Implementations for Assertion Framework\nDESCRIPTION: Implementation of source interfaces and classes that handle value conversion and delegation in the assertion framework. Includes ConvertedDelegateSource and ConvertedValueSource for type conversion operations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ISource\n{\n    string? ActualExpression { get; }\n    TUnit.Assertions.AssertConditions.Interfaces.ISource AppendExpression(string expression);\n    TUnit.Assertions.AssertConditions.Interfaces.ISource WithAssertion(TUnit.Assertions.AssertConditions.BaseAssertCondition assertCondition);\n}\n```\n\n----------------------------------------\n\nTITLE: Test Hook Source Class Implementation in C#\nDESCRIPTION: Implements ITestHookSource interface with initialization and hook collection methods. Contains hook registration for cleanup tests with default empty collections for various hook types.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyAfterTests.Test.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_AssemblyCleanupTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_AssemblyCleanupTests();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Registering and Collecting 'Test' Method with Custom Display Name in TUnit\nDESCRIPTION: This code snippet implements a source-generated test collector for the 'Test' method in CustomDisplayNameTests class. It registers the test with a custom display name 'A super important test!' and provides necessary metadata for execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/CustomDisplayNameTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tglobal::TUnit.Core.SourceRegistrar.Register(new CustomDisplayNameTests());\n}\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn Tests0(sessionId);\n}\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.CustomDisplayNameTests),\n\t\t\tName = \"Test\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.DisplayNameAttribute(\"A super important test!\")\n\t\t\t],\n\t\t\tParameters = [],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.CustomDisplayNameTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.CustomDisplayNameTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"CustomDisplayNameTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"CustomDisplayNameTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"CustomDisplayNameTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = \n\t\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType = typeof(int),\n\t\t\t\t\t\t\tName = \"Order\",\n\t\t\t\t\t\t\tIsStatic = false,\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.CustomDisplayNameTests? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tclassInstanceArguments = [];\n\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.CustomDisplayNameTests>(() => \n\t\t\tnew global::TUnit.TestProject.CustomDisplayNameTests()\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.CustomDisplayNameTests>\n\t\t\t{\n\t\t\t\tTestId = $\"TUnit.TestProject.CustomDisplayNameTests.Test:0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Test()),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 12,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.CustomDisplayNameTests>\n\t\t\t{\n\t\t\t\tTestId = $\"TUnit.TestProject.CustomDisplayNameTests.Test:0\",\n\t\t\t\tMethodName = $\"Test\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"CustomDisplayNameTests.Test failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 12,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for Long Argument in C#\nDESCRIPTION: This snippet creates test metadata for a method with a long argument. It follows a similar pattern to the float argument test, setting up the test context and adding the metadata to the nodes list.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/NumberArgumentTests.TestDE.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nlong methodArg = 1L;\n\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.NumberArgumentTests>(() => \nnew global::TUnit.TestProject.NumberArgumentTests()\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.NumberArgumentTests>\n{\n\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NumberArgumentTests.Long(long):0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [methodArg],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Long(methodArg)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 26,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Timing Class in C# for TUnit Framework\nDESCRIPTION: This class represents timing information in the TUnit framework. It implements the IEquatable interface for Timing objects.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_52\n\nLANGUAGE: C#\nCODE:\n```\npublic class Timing : System.IEquatable<TUnit.Core.Timing>\n{\n\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EnumIsNotDefinedAssertCondition in C#\nDESCRIPTION: A class that implements a condition to verify if an enum value is not defined in its enum type. It extends BaseAssertCondition and requires the type to be an enum.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_107\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumIsNotDefinedAssertCondition<TEnum> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TEnum>\n    where TEnum : System.Enum\n{\n    public EnumIsNotDefinedAssertCondition() { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TEnum? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Matrix Data Source Attribute in C#\nDESCRIPTION: Defines an attribute for generating matrix data sources that can be applied to classes or methods. It inherits from NonTypedDataSourceGeneratorAttribute and generates data combinations for tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method)]\npublic sealed class MatrixDataSourceAttribute : TUnit.Core.NonTypedDataSourceGeneratorAttribute\n{\n    public MatrixDataSourceAttribute() { }\n    public override System.Collections.Generic.IEnumerable<System.Func<object?[]?>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Test Metadata Generation for Method 1\nDESCRIPTION: This section handles the generation of test metadata for the second test configuration in NullableByteArgumentTests, accounting for different nullable byte inputs. It structures test execution data using TUnit's framework.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/NullableByteArgumentTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests1(string sessionId)\n{\n    global::System.Collections.Generic.List<TestMetadata> nodes = [];\n    var classDataIndex = 0;\n    var testMethodDataIndex = 0;\n    try\n    {\n        var testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n        {\n            Type = typeof(global::TUnit.TestProject.NullableByteArgumentTests),\n            Name = \"Test\",\n            GenericTypeCount = 0,\n            ReturnType = typeof(void),\n            Attributes = \n            [\n                new global::TUnit.Core.TestAttribute(),\n                new global::TUnit.Core.ArgumentsAttribute((byte)1),\n                new global::TUnit.Core.ArgumentsAttribute(null)\n            ],\n            Parameters = \n            [\n                new global::TUnit.Core.SourceGeneratedParameterInformation<byte?>\n                {\n                    Name = \"someByte\",\n                    Attributes = [],\n                },\n            ],\n            Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.NullableByteArgumentTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n            {\n                Type = typeof(global::TUnit.TestProject.NullableByteArgumentTests),\n                Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"NullableByteArgumentTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n                {\n                    Name = \"NullableByteArgumentTests\",\n                    Attributes = [],\n                }),\n                Name = \"NullableByteArgumentTests\",\n                Namespace = \"TUnit.TestProject\",\n                Attributes = [],\n                Parameters = [],\n                Properties = [],\n            }),\n};\n\n        var testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n        var testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n        global::TUnit.TestProject.NullableByteArgumentTests? classInstance = null;\n        object?[]? classInstanceArguments = null;\n        classInstanceArguments = [];\n\n        byte? methodArg = null;\n\n        var resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.NullableByteArgumentTests>(() => \n        new global::TUnit.TestProject.NullableByteArgumentTests()\n        , sessionId, testBuilderContext);\n        var resettableClassFactory = resettableClassFactoryDelegate();\n\n\n        nodes.Add(new TestMetadata<global::TUnit.TestProject.NullableByteArgumentTests>\n        {\n            TestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS1:TUnit.TestProject.NullableByteArgumentTests.Test(byte?):0\",\n            TestClassArguments = [],\n            TestMethodArguments = [methodArg],\n            TestClassProperties = [],\n            CurrentRepeatAttempt = 0,\n            RepeatLimit = 0,\n            ResettableClassFactory = resettableClassFactory,\n            TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Test(methodArg)),\n            TestFilePath = @\"\",\n            TestLineNumber = 5,\n            TestMethod = testInformation,\n            TestBuilderContext = testBuilderContext,\n        });\n        resettableClassFactory = resettableClassFactoryDelegate();\n        testBuilderContext = new();\n        testBuilderContextAccessor.Current = testBuilderContext;\n    }\n    catch (global::System.Exception exception)\n    {\n        nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.NullableByteArgumentTests>\n        {\n            TestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS1:TUnit.TestProject.NullableByteArgumentTests.Test(byte?):0\",\n            MethodName = $\"Test\",\n            Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"NullableByteArgumentTests.Test failed to initialize\", exception),\n            TestFilePath = @\"\",\n            TestLineNumber = 5,\n        });\n    }\n    return nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating TUnit Test Metadata for ULong Method in C#\nDESCRIPTION: This auto-generated C# snippet defines a partial `NumberArgumentTests` class for TUnit, implementing `ITestSource`. It features a `ModuleInitializer` for source registration and a `CollectTests` method. The core logic resides in the `Tests0` method, which gathers metadata for the `ULong` test method, defines the `ulong` argument (1UL), sets up `ResettableLazy` factories for the test class and method execution, and adds a `TestMetadata` entry. Error handling logic is present to manage initialization failures.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/NumberArgumentTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class NumberArgumentTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new NumberArgumentTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.NumberArgumentTests),\n\t\t\t\tName = \"ULong\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(1UL)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<ulong>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"l\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.NumberArgumentTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.NumberArgumentTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"NumberArgumentTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"NumberArgumentTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"NumberArgumentTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.NumberArgumentTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tulong methodArg = 1UL;\n\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.NumberArgumentTests>(() => \n\t\t\t\tnew global::TUnit.TestProject.NumberArgumentTests()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.NumberArgumentTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NumberArgumentTests.ULong(ulong):0\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.ULong(methodArg)),\n\t\t\t\t\tTestFilePath = @\"\" // Incomplete snippet, missing rest of method and catch block\n\n```\n\n----------------------------------------\n\nTITLE: Implementing InvokableValueAssertionBuilder Generic Class in C#\nDESCRIPTION: This generic class represents an invokable value assertion builder. It inherits from InvokableAssertionBuilder and implements ISource and IValueSource interfaces. It includes methods for chaining assertions and getting an awaiter.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_62\n\nLANGUAGE: C#\nCODE:\n```\npublic class InvokableValueAssertionBuilder<TActual> : TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TActual>, TUnit.Assertions.AssertConditions.Interfaces.ISource, TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual>\n{\n    public InvokableValueAssertionBuilder(TUnit.Assertions.AssertConditions.Interfaces.ISource source) { }\n    public TUnit.Assertions.AssertConditions.Operators.ValueAnd<TActual> And { get; }\n    public TUnit.Assertions.AssertConditions.Operators.ValueOr<TActual> Or { get; }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> Because(string reason) { }\n    public new System.Runtime.CompilerServices.TaskAwaiter<TActual?> GetAwaiter() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Exceptions in TUnit Test Initialization for ClassDataSourceDrivenTestsSharedKeyed in C#\nDESCRIPTION: This code snippet captures and handles exceptions that occur during the initialization of a ClassDataSourceDrivenTestsSharedKeyed test. It creates a FailedTestMetadata object with details about the failed test, including the test ID, method name, and exception information.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTestsSharedKeyed.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ClassDataSourceDrivenTestsSharedKeyed>\n\t{\n\t\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<SomeAsyncDisposableClass>:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.ClassDataSourceDrivenTestsSharedKeyed.DataSource_Class_Generic(SomeAsyncDisposableClass):0\",\n\t\tMethodName = $\"DataSource_Class_Generic\",\n\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ClassDataSourceDrivenTestsSharedKeyed.DataSource_Class_Generic failed to initialize\", exception),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 14,\n\t});\n}\nreturn nodes;\n```\n\n----------------------------------------\n\nTITLE: Negative ImmutableArray Assertion Extensions in C#\nDESCRIPTION: Extension methods for asserting negative conditions on ImmutableArray, such as not being empty or not equivalent to another collection.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_74\n\nLANGUAGE: C#\nCODE:\n```\npublic static class ImmutableArrayIsNotExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsNotEmpty<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsNotEquivalentTo<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Assembly Target Framework in C#\nDESCRIPTION: This attribute specifies the target framework for the assembly as .NET Standard 2.0.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Runtime.Versioning.TargetFramework(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Defining Test Hook Source Interface in C#\nDESCRIPTION: Defines an interface ITestHookSource for collecting test hooks in TUnit. It includes methods for before and after test hooks, as well as hooks that run before and after every test.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_61\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ITestHookSource\n{\n    System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId);\n    System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId);\n    System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId);\n    System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId);\n}\n```\n\n----------------------------------------\n\nTITLE: Dictionary Key and Value Assertion Methods for TUnit\nDESCRIPTION: Extension methods for asserting conditions on dictionary objects. Provides methods to check if a dictionary contains specific keys or values, with support for custom equality comparers.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_58\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TDictionary> ContainsKey<TDictionary, TKey>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TDictionary> valueSource, TKey expected, System.Collections.Generic.IEqualityComparer<TKey> equalityComparer = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n    where TDictionary : System.Collections.IDictionary { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TDictionary> ContainsValue<TDictionary, TValue>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TDictionary> valueSource, TValue expected, System.Collections.Generic.IEqualityComparer<TValue> equalityComparer = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n    where TDictionary : System.Collections.IDictionary { }\n```\n\n----------------------------------------\n\nTITLE: Registering and Collecting Test Metadata for NameOfArgumentTests using TUnit Source Generation (C#)\nDESCRIPTION: This auto-generated C# class `NameOfArgumentTests` implements the `ITestSource` interface for the TUnit testing framework. It uses a `ModuleInitializer` to register itself with `TUnit.Core.SourceRegistrar`. The `CollectTests` method gathers and returns `TestMetadata` for the tests defined within the `TUnit.TestProject.NameOfArgumentTests` class, specifically setting up the `TestName` method with its arguments (provided via `ArgumentsAttribute`) and associated metadata like type information, attributes, and factory delegates for class instantiation. It includes error handling for initialization failures.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/NameOfArgumentTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[  \n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class NameOfArgumentTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new NameOfArgumentTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.NameOfArgumentTests),\n\t\t\t\tName = \"TestName\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"TestName\")\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"name\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.NameOfArgumentTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.NameOfArgumentTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"NameOfArgumentTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"NameOfArgumentTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"NameOfArgumentTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.NameOfArgumentTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tstring methodArg = \"TestName\";\n\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.NameOfArgumentTests>(() => \n\t\t\t\tnew global::TUnit.TestProject.NameOfArgumentTests()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.NameOfArgumentTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NameOfArgumentTests.TestName(string):0\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.TestName(methodArg)),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 5,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.NameOfArgumentTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NameOfArgumentTests.TestName(string):0\",\n\t\t\t\t\tMethodName = $\"TestName\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"NameOfArgumentTests.TestName failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 5,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n\t}\n\n]\n```\n\n----------------------------------------\n\nTITLE: Creating Source Generated Class Information for StringArgumentTests in C#\nDESCRIPTION: This snippet shows how the framework builds class information for a test class through source generation. It creates an object describing the StringArgumentTests class with its type, assembly, namespace, and other metadata properties.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/StringArgumentTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.StringArgumentTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n{\n\tType = typeof(global::TUnit.TestProject.StringArgumentTests),\n\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"StringArgumentTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t{\n\t\tName = \"StringArgumentTests\",\n\t\tAttributes = [],\n\t}),\n\tName = \"StringArgumentTests\",\n\tNamespace = \"TUnit.TestProject\",\n\tAttributes = [],\n\tParameters = [],\n\tProperties = [],\n}),\n```\n\n----------------------------------------\n\nTITLE: Implementing Distinct Items Validation for Enumerables in C#\nDESCRIPTION: Class for asserting that an enumerable collection contains only distinct items. It uses an optional IEqualityComparer to determine item uniqueness and extends BaseAssertCondition.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumerableDistinctItemsExpectedValueAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n    where TActual : System.Collections.Generic.IEnumerable<TInner>\n{\n    public EnumerableDistinctItemsExpectedValueAssertCondition(System.Collections.Generic.IEqualityComparer<TInner?>? equalityComparer) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: PlaywrightSkipAttribute Class in C#\nDESCRIPTION: An attribute class for skipping Playwright tests based on specified combinations of operating systems and browser types. Uses a flags enum to define skip targets.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class PlaywrightSkipAttribute : TUnit.Core.SkipAttribute\n{\n    public PlaywrightSkipAttribute(params TUnit.Playwright.PlaywrightSkipAttribute.Targets[] combinations) { }\n    public TUnit.Core.TestContext? TestContext { get; set; }\n    public override System.Threading.Tasks.Task<bool> ShouldSkip(TUnit.Core.BeforeTestContext context) { }\n    [System.Flags]\n    public enum Targets : short\n    {\n        Windows = 1,\n        Linux = 2,\n        OSX = 4,\n        Chromium = 8,\n        Firefox = 16,\n        Webkit = 32,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Registering ClassConstructorTest in TUnit (C#)\nDESCRIPTION: This snippet defines the ClassConstructorTest class, implements the ITestSource interface, and registers the class with TUnit's SourceRegistrar. It includes a module initializer and methods for collecting tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassConstructorTest.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class ClassConstructorTest : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new ClassConstructorTest());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\t// ... (rest of the method implementation)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Test Source Generator Class in C#\nDESCRIPTION: Auto-generated class that implements the ITestSource interface to register and collect test metadata. This code initializes the test source generator and provides methods to collect and register tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class ClassDataSourceDrivenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new ClassDataSourceDrivenTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n```\n\n----------------------------------------\n\nTITLE: JSON Model Classes for TUnit Engine\nDESCRIPTION: Comprehensive set of JSON model classes used for serialization and data exchange within the TUnit framework. These classes provide a structured representation of test sessions, assemblies, classes, tests, results, and exceptions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class ExceptionJson : System.IEquatable<TUnit.Engine.Json.ExceptionJson>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public ExceptionJson() { }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Engine.Json.ExceptionJson? InnerException { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string Message { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string? Stacktrace { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string? Type { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Base Class for General Playwright Tests in C#\nDESCRIPTION: The `PlaywrightTest` class inherits from `WorkerAwareTest` and serves as a fundamental base for Playwright tests in TUnit. It provides access to the core Playwright instance (`Playwright`), the browser type (`BrowserType`), and helper methods (`Expect`) for creating Playwright assertions. It also includes static `[Before]` and `[After]` hooks (`PlaywrightSetup`, `PlaywrightCleanup`) for session-level Playwright initialization and disposal.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet2_0.Net4_7.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic class PlaywrightTest : TUnit.Playwright.WorkerAwareTest\n{\n    public PlaywrightTest() { }\n    public virtual string BrowserName { get; }\n    public Microsoft.Playwright.IBrowserType BrowserType { get; }\n    public static Microsoft.Playwright.IPlaywright Playwright { get; }\n    public Microsoft.Playwright.IAPIResponseAssertions Expect(Microsoft.Playwright.IAPIResponse response) { }\n    public Microsoft.Playwright.ILocatorAssertions Expect(Microsoft.Playwright.ILocator locator) { }\n    public Microsoft.Playwright.IPageAssertions Expect(Microsoft.Playwright.IPage page) { }\n    [TUnit.Core.After(TUnit.Core.HookType.TestSession, \"<FilePath>\", 22)]\n    public static void PlaywrightCleanup() { }\n    [TUnit.Core.Before(TUnit.Core.HookType.TestSession, \"<FilePath>\", 15)]\n    public static System.Threading.Tasks.Task PlaywrightSetup() { }\n    public static void SetDefaultExpectTimeout(float timeout) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Target Framework for Assembly in C#\nDESCRIPTION: This assembly-level attribute specifies that the compiled code targets .NET Standard 2.0. The `TargetFrameworkAttribute` is used by the .NET runtime to determine compatibility.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: System.Runtime.Versioning.TargetFramework(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Registering SetupTest Hook Without Parameters Using TUnit Source Generator in C#\nDESCRIPTION: This snippet auto-registers a before-class hook that sets up test state without requiring parameters, using TUnit source generation. It instantiates and registers the hook source using a static initializer and exposes a static hooks list via CollectBeforeClassHooks. The method executes a setup method asynchronously for the test class using a default executor, and exposes hook metadata. Dependencies include TUnit.Core, TUnit.Core.Hooks, and a SetupTests class with a BeforeAllSetUp method. Expected output is the execution of BeforeAllSetUp before all test cases in the class.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeAllTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_SetupTests : global::TUnit.Core.Interfaces.SourceGenerator.IClassHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_SetupTests();\n\t\tSourceRegistrar.RegisterClassHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.BeforeClassHookMethod\n\t\t\t{\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\t\tName = \"BeforeAllSetUp\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.SetupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"BeforeAllTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"BeforeAllTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"SetupTests\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.BeforeTests.SetupTests.BeforeAllSetUp(cancellationToken)),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tFilePath = @\"\",\n\t\t\t\t\tLineNumber = 62,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\tAssemblyAttributes = [],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\t\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterClassHooks(string sessionId)\n\t\t{\n\t\t\treturn\n\t\t\t[\n\t\t\t];\n\t\t}\n\t}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing AssignableToExpectedValueAssertCondition in C#\nDESCRIPTION: A class that implements a condition to verify if a type is assignable to an expected type. This allows for testing type compatibility in the reverse direction from AssignableFrom.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_110\n\nLANGUAGE: C#\nCODE:\n```\npublic class AssignableToExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n{\n    public AssignableToExpectedValueAssertCondition(System.Type expectedType) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel Group Constraint in C#\nDESCRIPTION: Defines a constraint for tests in parallel execution groups. It implements comparison interfaces to allow ordering of parallel groups during test execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic class ParallelGroupConstraint : System.IComparable, System.IComparable<TUnit.Core.ParallelGroupConstraint>, System.IEquatable<TUnit.Core.ParallelGroupConstraint>, TUnit.Core.Interfaces.IParallelConstraint\n{\n    public ParallelGroupConstraint(string Group, int Order) { }\n    public string Group { get; init; }\n    public int Order { get; init; }\n    public int CompareTo(TUnit.Core.ParallelGroupConstraint? other) { }\n    public int CompareTo(object? obj) { }\n    public virtual bool Equals(TUnit.Core.ParallelGroupConstraint? other) { }\n    public override int GetHashCode() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AssertionMetadata Class in C#\nDESCRIPTION: Defines the AssertionMetadata class to store timing information for assertions. It includes required members for start and end times, and a computed Duration property.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class AssertionMetadata\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public AssertionMetadata() { }\n    public System.TimeSpan Duration { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.DateTimeOffset EndTime { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.DateTimeOffset StartTime { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling and Test Metadata Creation for RepeatTests\nDESCRIPTION: Error handling logic to catch exceptions during test initialization and create FailedTestMetadata objects with detailed error information. This ensures that test failures are properly captured and reported.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/RepeatTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.RepeatTests>\n\t{\n\t\tTestId = $\"TUnit.TestProject.RepeatTests.Two:0\",\n\t\tMethodName = $\"Two\",\n\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"RepeatTests.Two failed to initialize\", exception),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 13,\n\t});\n}\nreturn nodes;\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTimeEqualToAssertionBuilderWrapper in C#\nDESCRIPTION: Wrapper for DateTime equality assertions that supports specifying a tolerance time span within which two DateTimes can be considered equal.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_85\n\nLANGUAGE: C#\nCODE:\n```\n    public class DateTimeEqualToAssertionBuilderWrapper : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTime>\n    {\n        public TUnit.Assertions.AssertionBuilders.Wrappers.DateTimeEqualToAssertionBuilderWrapper Within(System.TimeSpan tolerance, [System.Runtime.CompilerServices.CallerArgumentExpression(\"tolerance\")] string doNotPopulateThis = \"\") { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Collecting Aggregated TUnit Test Metadata in C#\nDESCRIPTION: This method implements the `ITestSource.CollectTests` interface. It aggregates `TestMetadata` objects generated by separate private helper methods (`Tests0` through `Tests5`) into a single read-only list. Each helper method corresponds to tests driven by a different data source defined in the original test class. The `sessionId` parameter is passed down to the helper methods, likely for managing state or resources across test executions within a session.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenWithCancellationTokenTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\t..Tests0(sessionId),\n\t\t\t..Tests1(sessionId),\n\t\t\t..Tests2(sessionId),\n\t\t\t..Tests3(sessionId),\n\t\t\t..Tests4(sessionId),\n\t\t\t..Tests5(sessionId),\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing AndAssertionGroupInvoker Generic Class in C#\nDESCRIPTION: This generic class represents an 'and' assertion group invoker. It provides methods for chaining assertion groups and getting an awaiter. It has a type constraint on TAssertionBuilder.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_69\n\nLANGUAGE: C#\nCODE:\n```\npublic class AndAssertionGroupInvoker<TActual, TAssertionBuilder>\n    where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder\n{\n    public AndAssertionGroupInvoker(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group1, TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group2) { }\n    public TUnit.Assertions.AssertionBuilders.Groups.AndAssertionGroupInvoker<TActual, TAssertionBuilder> And(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group) { }\n    public System.Runtime.CompilerServices.TaskAwaiter<TActual?> GetAwaiter() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ValueAssertCondition Abstract Class for TUnit (C#)\nDESCRIPTION: Defines the abstract `ValueAssertCondition` class, inheriting from `BaseAssertCondition`. It serves as a base for conditions that primarily evaluate the actual value (`TActual`). It introduces abstract methods `GetFailureMessage` and `Passes` to be implemented by derived classes and provides methods `WithComparer` and `WithTransform` for customization.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_28\n\nLANGUAGE: csharp\nCODE:\n```\n    public abstract class ValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n    {\n        protected ValueAssertCondition() { }\n        protected override string GetExpectation() { }\n        protected abstract string GetFailureMessage(TActual? actualValue);\n        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n        protected abstract TUnit.Assertions.AssertConditions.AssertionResult Passes(TActual? actualValue);\n        public void WithComparer(System.Func<TActual?, TUnit.Assertions.AssertionDecision> comparer) { }\n        public void WithTransform(System.Func<TActual?, TActual?> actualTransformation) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing EngineCancellationToken in C#\nDESCRIPTION: Defines an EngineCancellationToken class that implements IDisposable. It provides a cancellation token for the test engine.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic class EngineCancellationToken : System.IDisposable\n{\n    public EngineCancellationToken() { }\n    public System.Threading.CancellationToken Token { get; }\n    public void Dispose() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Not Equals Expected Value Assertion in C#\nDESCRIPTION: This class implements an assertion condition to check if two values are not equal. It extends the ExpectedValueAssertCondition class and overrides methods to provide custom assertion logic.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_119\n\nLANGUAGE: C#\nCODE:\n```\npublic class NotEqualsExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TActual>\n{\n    public NotEqualsExpectedValueAssertCondition(TActual expected) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TActual? expectedValue) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TimeoutAttribute in C#\nDESCRIPTION: This attribute is used to set a timeout for test execution. It can be applied to assemblies, classes, or methods and implements interfaces for event handling during test discovery.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_53\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\npublic class TimeoutAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver\n{\n    public TimeoutAttribute(int timeoutInMilliseconds) { }\n    public int Order { get; }\n    public System.TimeSpan Timeout { get; }\n    public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Multi-Parameter Test Method Information in C#\nDESCRIPTION: Sets up test metadata for a Test2 method with multiple parameters. This snippet shows how TUnit handles test methods with multiple arguments in an array format.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests2112.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.Bugs._2112.Tests),\n\tName = \"Test2\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(void),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute(),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(0, 1L, 2L, 3L),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(0, 1, 2, 3)\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t{\n\t\t\tName = \"a\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<long[]>\n\t\t{\n\t\t\tName = \"arr\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._2112.Tests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t{\n\t\tType = typeof(global::TUnit.TestProject.Bugs._2112.Tests),\n```\n\n----------------------------------------\n\nTITLE: Initializing and Registering CustomDisplayNameTests in C#\nDESCRIPTION: This code snippet defines a partial class CustomDisplayNameTests that implements the ITestSource interface. It includes a static initializer to register the class with the TUnit.Core.SourceRegistrar and a method to collect test metadata.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/CustomDisplayNameTests.Test.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class CustomDisplayNameTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n    [global::System.Runtime.CompilerServices.ModuleInitializer]\n    public static void Initialise()\n    {\n        global::TUnit.Core.SourceRegistrar.Register(new CustomDisplayNameTests());\n    }\n    public global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n    {\n        return Tests0(sessionId);\n    }\n    // ... (Tests0 method implementation)\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Test Metadata in TUnit C#\nDESCRIPTION: This snippet initializes and collects test metadata using the TUnit framework, a unit testing framework. It sets up data source attributes and leverages source-generated classes to create test instances and arguments. Dependencies include the TUnit.Core and System.Threading.Tasks namespaces, and custom types such as TestMetadata and ClassDataSourceDrivenTests. It is responsible for generating test methods using a source-generated parameter information strategy.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nvar classDataIndex = 0;\nvar testMethodDataIndex = 0;\ntry\n{\n  var testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n  {\n    Type = typeof(global::TUnit.TestProject.ClassDataSourceDrivenTests),\n    Name = \"IsInitialized_With_3_ClassDataSources\",\n    GenericTypeCount = 0,\n    ReturnType = typeof(global::System.Threading.Tasks.Task),\n    Attributes = \n    [\n      new global::TUnit.Core.TestAttribute()\n    ],\n    Parameters = \n    [\n      new global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.InitializableClass>\n      {\n        Name = \"class1\",\n        Attributes = [],\n      },\n      new global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.InitializableClass>\n      {\n        Name = \"class2\",\n        Attributes = [],\n      },\n      new global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.InitializableClass>\n      {\n        Name = \"class3\",\n        Attributes = [],\n      },\n    ],\n    Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.ClassDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n    {\n      Type = typeof(global::TUnit.TestProject.ClassDataSourceDrivenTests),\n      Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"ClassDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n      {\n        Name = \"ClassDataSourceDrivenTests\",\n        Attributes = [],\n      }),\n      Name = \"ClassDataSourceDrivenTests\",\n      Namespace = \"TUnit.TestProject\",\n      Attributes = [],\n      Parameters = [],\n      Properties = [],\n    }),\n};\n...\n```\n\n----------------------------------------\n\nTITLE: Implementing String Extension Methods in C#\nDESCRIPTION: A collection of utility extension methods for string manipulation including empty checks, truncation, and line ending handling.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_79\n\nLANGUAGE: C#\nCODE:\n```\npublic static class StringExtensions\n{\n    public static string GetStringOr(this string? value, string defaultValue) { }\n    public static string GetStringOrEmpty(this string? value) { }\n    public static string PrependAOrAn(this string value) { }\n    public static string ReplaceNewLines(this string value) { }\n    public static string ShowNewLines(this string value) { }\n    public static string TruncateWithEllipsis(this string value, int maxLength) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Test Initialization Exception in C#\nDESCRIPTION: Exception handling code for test initialization failures in TUnit framework. Creates a TestFailedInitializationException with file path and line number tracking for tuple data source driven tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/EnumerableTupleDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"EnumerableTupleDataSourceDrivenTests.DataSource_TupleMethod failed to initialize\", exception),\nTestFilePath = @\"\",\nTestLineNumber = 5,\n});\n}\nreturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Assembly Hooks Implementation in C#\nDESCRIPTION: Implements method to collect after-assembly hooks with context. Defines a hook method using TUnit.Core.Hooks infrastructure with assembly cleanup configuration.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyAfterTests.Test.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectAfterAssemblyHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.AfterAssemblyHookMethod\n\t\t{ \n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),\n\t\t\t\tName = \"AfterAllCleanUpWithContext\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Assembly)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.AssemblyHookContext>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"context\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.AssemblyCleanupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AssemblyAfterTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"AssemblyAfterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"AssemblyCleanupTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.AssemblyCleanupTests.AfterAllCleanUpWithContext(context, cancellationToken)),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tFilePath = @\"\",\n\t\t\t\tLineNumber = 68,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Assembly)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\tAssemblyAttributes = [],\n\t\t\t},\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Declaring the TUnit.Assertions Namespace in C#\nDESCRIPTION: This code declares the `TUnit.Assertions` namespace, which encapsulates all the assertion-related classes and types for the TUnit framework.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace TUnit.Assertions\n{\n```\n\n----------------------------------------\n\nTITLE: Defining ConvertedDelegateAssertionBuilder Class in C#\nDESCRIPTION: This class represents a converted delegate assertion builder. It inherits from InvokableDelegateAssertionBuilder and takes an IDelegateSource as a parameter in its constructor.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_54\n\nLANGUAGE: C#\nCODE:\n```\npublic class ConvertedDelegateAssertionBuilder(TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource source) { }\n```\n\n----------------------------------------\n\nTITLE: Creating Test Metadata for StringArgumentTests.Normal Method in C#\nDESCRIPTION: This snippet creates a TestMetadata object that contains all information needed to execute a test method. It includes the test ID, arguments, factory methods for creating test instances, file path, and test method information.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/StringArgumentTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nnodes.Add(new TestMetadata<global::TUnit.TestProject.StringArgumentTests>\n{\n\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS2:TUnit.TestProject.StringArgumentTests.Normal(string):0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [methodArg],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Normal(methodArg)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 5,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing EnumHasSameNameAsCondition in C#\nDESCRIPTION: A class that implements a condition to check if one enum has the same name as another enum of a different type. It extends the BaseAssertCondition class and requires both types to be enums.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_104\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumHasSameNameAsCondition<TEnum, TExpected> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TEnum>\n    where TEnum : System.Enum\n    where TExpected : System.Enum\n{\n    public EnumHasSameNameAsCondition(TExpected expected) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TEnum? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Nodes for Class Data Source Driven Tests in C#\nDESCRIPTION: This snippet iterates through generated data sources, creates test metadata for each iteration, and adds test nodes to the collection. It handles the creation of test class instances and method arguments for each test run.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nforeach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\n{\n\ttestMethodDataIndex++;\n\tclassInstanceArguments = [];\n\n\tvar methodArgGeneratedData = methodArgGeneratedDataAccessor();\n\tglobal::TUnit.TestProject.InitializableClass methodArg = methodArgGeneratedData.Item1;\n\tglobal::TUnit.TestProject.InitializableClass methodArg1 = methodArgGeneratedData.Item2;\n\tglobal::TUnit.TestProject.InitializableClass methodArg2 = methodArgGeneratedData.Item3;\n\tglobal::TUnit.TestProject.InitializableClass methodArg3 = methodArgGeneratedData.Item4;\n\tglobal::TUnit.TestProject.InitializableClass methodArg4 = methodArgGeneratedData.Item5;\n\n\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ClassDataSourceDrivenTests>(() => \n\tnew global::TUnit.TestProject.ClassDataSourceDrivenTests()\n\t, sessionId, testBuilderContext);\n\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\tnodes.Add(new TestMetadata<global::TUnit.TestProject.ClassDataSourceDrivenTests>\n\t{\n\t\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.InitializableClass, global::TUnit.TestProject.InitializableClass, global::TUnit.TestProject.InitializableClass, global::TUnit.TestProject.InitializableClass, global::TUnit.TestProject.InitializableClass>:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.ClassDataSourceDrivenTests.IsInitialized_With_5_ClassDataSources(TUnit.TestProject.InitializableClass,TUnit.TestProject.InitializableClass,TUnit.TestProject.InitializableClass,TUnit.TestProject.InitializableClass,TUnit.TestProject.InitializableClass):0\",\n\t\tTestClassArguments = [],\n\t\tTestMethodArguments = [methodArg, methodArg1, methodArg2, methodArg3, methodArg4],\n\t\tTestClassProperties = [],\n\t\tCurrentRepeatAttempt = 0,\n\t\tRepeatLimit = 0,\n\t\tResettableClassFactory = resettableClassFactory,\n\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.IsInitialized_With_5_ClassDataSources(methodArg, methodArg1, methodArg2, methodArg3, methodArg4)),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 58,\n\t\tTestMethod = testInformation,\n\t\tTestBuilderContext = testBuilderContext,\n\t});\n\tresettableClassFactory = resettableClassFactoryDelegate();\n\ttestBuilderContext = new();\n\ttestBuilderContextAccessor.Current = testBuilderContext;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing TUnit Test Source Generator Implementation in C#\nDESCRIPTION: Defines a partial class that implements ITestSource to register and collect tests for the TUnit framework. The class includes a module initializer that registers itself with the SourceRegistrar.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1692.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Tests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new Tests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\t..Tests0(sessionId),\n\t\t\t..Tests1(sessionId),\n\t\t];\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Dynamic Test Source Interface in C#\nDESCRIPTION: Defines an interface IDynamicTestSource for collecting dynamic tests in TUnit. It includes a method to collect dynamic tests based on a session ID.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_59\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IDynamicTestSource\n{\n    System.Collections.Generic.IReadOnlyList<TUnit.Core.DynamicTest> CollectDynamicTests(string sessionId);\n}\n```\n\n----------------------------------------\n\nTITLE: PlaywrightTest Class Definition in C#\nDESCRIPTION: A base test class for Playwright testing that inherits from WorkerAwareTest. Provides browser type access, assertion methods, and global Playwright instance management.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic class PlaywrightTest : TUnit.Playwright.WorkerAwareTest\n{\n    public PlaywrightTest() { }\n    public virtual string BrowserName { get; }\n    public Microsoft.Playwright.IBrowserType BrowserType { get; }\n    public static Microsoft.Playwright.IPlaywright Playwright { get; }\n    public Microsoft.Playwright.IAPIResponseAssertions Expect(Microsoft.Playwright.IAPIResponse response) { }\n    public Microsoft.Playwright.ILocatorAssertions Expect(Microsoft.Playwright.ILocator locator) { }\n    public Microsoft.Playwright.IPageAssertions Expect(Microsoft.Playwright.IPage page) { }\n    [TUnit.Core.After(TUnit.Core.HookType.TestSession, \"\", 0)]\n    public static void PlaywrightCleanup() { }\n    [TUnit.Core.Before(TUnit.Core.HookType.TestSession, \"\", 0)]\n    public static System.Threading.Tasks.Task PlaywrightSetup() { }\n    public static void SetDefaultExpectTimeout(float timeout) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Tests with Null Values in TUnit Framework\nDESCRIPTION: Generates test metadata for the NullValue test method that accepts a null string parameter. This method sets up the test context, creates a factory for the test class instance, and prepares the test method for execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.DataDrivenTests),\n\t\t\t\tName = \"NullValue\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(null)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.DataDrivenTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"DataDrivenTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"DataDrivenTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.DataDrivenTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tstring methodArg = null;\n\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.DataDrivenTests>(() => \n\t\t\t\tnew global::TUnit.TestProject.DataDrivenTests()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.DataDrivenTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.DataDrivenTests.NullValue(string):0\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.NullValue(methodArg)),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 32,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.DataDrivenTests>\n\t\t\t\t{\n```\n\n----------------------------------------\n\nTITLE: Setting Tolerance for DateTime Equality Assertions\nDESCRIPTION: Method to set a TimeSpan tolerance for DateTime equality assertions, allowing for approximate datetime comparisons within a specified range.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic void SetTolerance(System.TimeSpan tolerance) { }\n```\n\n----------------------------------------\n\nTITLE: Defining DateOnlyEqualsExpectedValueAssertCondition for TUnit DateOnly Assertions (C#)\nDESCRIPTION: Defines the `DateOnlyEqualsExpectedValueAssertCondition` class within the Chronology namespace for comparing `System.DateOnly` values. It inherits from `ExpectedValueAssertCondition` and provides a `SetTolerance` method to allow comparisons within a specified number of days.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_29\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace TUnit.Assertions.AssertConditions.Chronology\n{\n    public class DateOnlyEqualsExpectedValueAssertCondition : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<System.DateOnly, System.DateOnly>\n    {\n        public DateOnlyEqualsExpectedValueAssertCondition(System.DateOnly expected) { }\n        protected override string GetExpectation() { }\n        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(System.DateOnly actualValue, System.DateOnly expectedValue) { }\n        public void SetTolerance(int toleranceDays) { }\n    }\n    // ... other classes in namespace\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DateTimeEqualsExpectedValueAssertCondition for TUnit DateTime Assertions (C#)\nDESCRIPTION: Defines the `DateTimeEqualsExpectedValueAssertCondition` class within the Chronology namespace for comparing `System.DateTime` values. It inherits from `ExpectedValueAssertCondition` and includes a `SetTolerance` method allowing comparisons within a specified `System.TimeSpan`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_30\n\nLANGUAGE: csharp\nCODE:\n```\n    public class DateTimeEqualsExpectedValueAssertCondition : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<System.DateTime, System.DateTime>\n    {\n        public DateTimeEqualsExpectedValueAssertCondition(System.DateTime expected) { }\n        protected override string GetExpectation() { }\n        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(System.DateTime actualValue, System.DateTime expectedValue) { }\n        public void SetTolerance(System.TimeSpan tolerance) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Lifecycle Adapters\nDESCRIPTION: Implements adapter classes for handling the last test in assembly and class scenarios. These adapters implement IExecutableHook interface and provide execution context for test completion events.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_62\n\nLANGUAGE: C#\nCODE:\n```\npublic class LastTestInAssemblyAdapter : TUnit.Core.Hooks.IExecutableHook<TUnit.Core.AssemblyHookContext>\n{\n    public LastTestInAssemblyAdapter(TUnit.Core.Interfaces.ILastTestInAssemblyEventReceiver lastTestInAssemblyEventReceiver, TUnit.Core.TestContext testContext) { }\n    public TUnit.Core.SourceGeneratedMethodInformation MethodInfo { get; }\n    public string Name { get; }\n    public int Order { get; }\n    public bool Execute(TUnit.Core.AssemblyHookContext context, System.Threading.CancellationToken cancellationToken) { }\n    public System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.AssemblyHookContext context, System.Threading.CancellationToken cancellationToken) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NotBetweenAssertionBuilderWrapper in C#\nDESCRIPTION: Wrapper for assertions that check if a value is not between two bounds. Supports configuration with inclusive or exclusive bounds for comparison operations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_90\n\nLANGUAGE: C#\nCODE:\n```\n    public class NotBetweenAssertionBuilderWrapper<TActual> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>\n        where TActual : System.IComparable<TActual>\n    {\n        public TUnit.Assertions.AssertionBuilders.Wrappers.NotBetweenAssertionBuilderWrapper<TActual> WithExclusiveBounds() { }\n        public TUnit.Assertions.AssertionBuilders.Wrappers.NotBetweenAssertionBuilderWrapper<TActual> WithInclusiveBounds() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Creating TUnit Test Metadata for Class Data Source in C#\nDESCRIPTION: This C# snippet is part of a generated method responsible for processing class data sources for TUnit tests. It assigns properties to a TestMetadata object (or similar), including a generated TestId, class/method arguments, factories, and source location information. It appears to be within a loop (indexed by `classDataIndex`) and a try block. Upon successful setup for a data source instance, it resets the class factory and test builder context for the next iteration. The accompanying catch block handles exceptions during this setup process, creating a `FailedTestMetadata` object with error details instead.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests2.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n\t\t\t\t\t\t\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.ClassDataSourceDrivenTests2.Derived2>:{classDataIndex}:CL-GAC0:TUnit.TestProject.ClassDataSourceDrivenTests2(TUnit.TestProject.ClassDataSourceDrivenTests2.Base).Base_Derived2:0\",\n\t\t\t\t\t\t\tTestClassArguments = [classArgGeneratedData],\n\t\t\t\t\t\t\tTestMethodArguments = [],\n\t\t\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Base_Derived2()),\n\t\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\t\tTestLineNumber = 15,\n\t\t\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\t\t\ttestBuilderContext = new();\n\t\t\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (global::System.Exception exception)\n\t\t\t\t{\n\t\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ClassDataSourceDrivenTests2>\n\t\t\t\t\t{\n\t\t\t\t\t\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.ClassDataSourceDrivenTests2.Derived2>:{classDataIndex}:CL-GAC0:TUnit.TestProject.ClassDataSourceDrivenTests2(TUnit.TestProject.ClassDataSourceDrivenTests2.Base).Base_Derived2:0\",\n\t\t\t\t\t\tMethodName = $\"Base_Derived2\",\n\t\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ClassDataSourceDrivenTests2.Base_Derived2 failed to initialize\", exception),\n\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\tTestLineNumber = 15,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn nodes;\n\t\t\t}\n\t\t}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Source Generated Method Information for Multi-Parameter Test in C#\nDESCRIPTION: Creates a SourceGeneratedMethodInformation object for a test method with sixteen parameters. This metadata provides information about the test method, its parameters, and attributes to the test execution engine.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1538.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.Bugs._1538.Tests),\n\tName = \"SixteenArgs\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(void),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute(),\n\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"SixteenItems\")\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t{\n\t\t\tName = \"expectedSuccess\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"item1\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"item2\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"item3\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"item4\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"item5\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"item6\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"item7\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"item8\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"item9\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"item10\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"item11\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"item12\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"item13\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"item14\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"item15\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._1538.Tests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t{\n\t\tType = typeof(global::TUnit.TestProject.Bugs._1538.Tests),\n\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Tests1538\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t{\n\t\t\tName = \"Tests1538\",\n\t\t\tAttributes = [],\n\t\t}),\n\t\tName = \"Tests\",\n\t\tNamespace = \"TUnit.TestProject.Bugs._1538\",\n\t\tAttributes = [],\n\t\tParameters = [],\n\t\tProperties = [],\n\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: Adding Failed Initialization Test Node for TUnit Test Discovery - C#\nDESCRIPTION: This snippet adds a FailedInitializationTest node to the list of test metadata in case of an exception during test node creation, ensuring test discovery and diagnostic information for initialization errors. It leverages the test method info, expected parameter types, and exception details, and is fully compatible only if TUnit and required method signatures are present. Inputs are the caught exception and current test configuration context; output is a failed test record to facilitate reporting and debugging.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=TupleMethod_testMethodName=TupleMethod.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedInitializationTest\n\t{\n\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS0:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.ClassTupleDataSourceDrivenTests(System.Int32,System.String,System.Boolean).DataSource_TupleMethod(System.Int32,System.String,System.Boolean):0\",\n\t\tTestClass = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests),\n\t\tReturnType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests).GetMethod(\"DataSource_TupleMethod\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]).ReturnType,\n\t\tParameterTypeFullNames = [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)],\n\t\tTestName = \"DataSource_TupleMethod\",\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 24,\n\t\tException = exception,\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DynamicTestBuilderAttribute in C#\nDESCRIPTION: Defines a DynamicTestBuilderAttribute class that inherits from BaseTestAttribute. It is marked as experimental and used for building dynamic tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\n[System.Diagnostics.CodeAnalysis.Experimental(\"TUnitWIP0001\")]\npublic class DynamicTestBuilderAttribute : TUnit.Core.BaseTestAttribute\n{\n    public DynamicTestBuilderAttribute([System.Runtime.CompilerServices.CallerFilePath] string file = \"\", [System.Runtime.CompilerServices.CallerLineNumber] int line = 0) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Test Initialization Failures in TUnit\nDESCRIPTION: Implements exception handling for test initialization failures. Captures exceptions that occur during test setup and creates FailedTestMetadata objects with descriptive error information.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/PriorityFilteringTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.PriorityFilteringTests>\n\t{\n\t\tTestId = $\"TUnit.TestProject.PriorityFilteringTests.High_3:0\",\n\t\tMethodName = $\"High_3\",\n\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"PriorityFilteringTests.High_3 failed to initialize\", exception),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 24,\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Tests with Enum Values in TUnit Framework\nDESCRIPTION: Generates test metadata for the EnumValue test method that accepts TestEnum parameters. This method handles different enum values as test arguments and provides error handling for test initialization failures.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests2(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.DataDrivenTests),\n\t\t\t\tName = \"EnumValue\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(global::TUnit.TestProject.TestEnum.One),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(global::TUnit.TestProject.TestEnum.Two),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(-1)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.TestEnum>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"testEnum\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.DataDrivenTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"DataDrivenTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"DataDrivenTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.DataDrivenTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tglobal::TUnit.TestProject.TestEnum methodArg = (global::TUnit.TestProject.TestEnum)(-1);\n\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.DataDrivenTests>(() => \n\t\t\t\tnew global::TUnit.TestProject.DataDrivenTests()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.DataDrivenTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS2:TUnit.TestProject.DataDrivenTests.EnumValue(TUnit.TestProject.TestEnum):0\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.EnumValue(methodArg)),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 23,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.DataDrivenTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS2:TUnit.TestProject.DataDrivenTests.EnumValue(TUnit.TestProject.TestEnum):0\",\n\t\t\t\t\tMethodName = $\"EnumValue\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"DataDrivenTests.EnumValue failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 23,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Class Data Source Driven Tests with TUnit in C#\nDESCRIPTION: This C# snippet mirrors the previous generated code, but targets a generic data-driven test method. It constructs test metadata for a method named 'DataSource_Class_Generic' and manages instantiation, argument preparation, and exception handling identically, demonstrating the ability to support generically-named test source methods. All required dependencies and parameters follow the same conventions as the previous example.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\n// <auto-generated/>\\n#pragma warning disable\\nusing global::System.Linq;\\nusing global::System.Reflection;\\nusing global::TUnit.Core;\\nusing global::TUnit.Core.Extensions;\\n\\nnamespace TUnit.SourceGenerated;\\n\\n[global::System.Diagnostics.StackTraceHidden]\\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\\nfile partial class ClassDataSourceDrivenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\\n{\\n\\t[global::System.Runtime.CompilerServices.ModuleInitializer]\\n\\tpublic static void Initialise()\\n\\t{\\n\\t\\tglobal::TUnit.Core.SourceRegistrar.Register(new ClassDataSourceDrivenTests());\\n\\t}\\n\\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\\n\\t{\\n\\t\\treturn Tests0(sessionId);\\n\\t}\\n\\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\\n\\t{\\n\\t\\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\\n\\t\\tvar classDataIndex = 0;\\n\\t\\tvar testMethodDataIndex = 0;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\\n\\t\\t\\t{\\n\\t\\t\\t\\tType = typeof(global::TUnit.TestProject.ClassDataSourceDrivenTests),\\n\\t\\t\\t\\tName = \\\"DataSource_Class_Generic\\\",\\n\\t\\t\\t\\tGenericTypeCount = 0,\\n\\t\\t\\t\\tReturnType = typeof(void),\\n\\t\\t\\t\\tAttributes = \\n\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\tnew global::TUnit.Core.TestAttribute()\\n\\t\\t\\t\\t],\\n\\t\\t\\t\\tParameters = \\n\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.Dummy.SomeAsyncDisposableClass>\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tName = \\\"value\\\",\\n\\t\\t\\t\\t\\t\\tAttributes = [],\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t],\\n\\t\\t\\t\\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\\\"global::TUnit.TestProject.ClassDataSourceDrivenTests\\\", () => new global::TUnit.Core.SourceGeneratedClassInformation\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tType = typeof(global::TUnit.TestProject.ClassDataSourceDrivenTests),\\n\\t\\t\\t\\t\\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\\\"ClassDataSourceDrivenTests\\\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tName = \\\"ClassDataSourceDrivenTests\\\",\\n\\t\\t\\t\\t\\t\\tAttributes = [],\\n\\t\\t\\t\\t\\t}),\\n\\t\\t\\t\\t\\tName = \\\"ClassDataSourceDrivenTests\\\",\\n\\t\\t\\t\\t\\tNamespace = \\\"TUnit.TestProject\\\",\\n\\t\\t\\t\\t\\tAttributes = [],\\n\\t\\t\\t\\t\\tParameters = [],\\n\\t\\t\\t\\t\\tProperties = [],\\n\\t\\t\\t\\t}),\\n};\\n\\n\\t\\t\\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\\n\\t\\t\\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\\n\\t\\t\\tglobal::TUnit.TestProject.ClassDataSourceDrivenTests? classInstance = null;\\n\\t\\t\\tobject?[]? classInstanceArguments = null;\\n\\t\\t\\tvar methodArgDataGeneratorMetadata = new DataGeneratorMetadata\\n\\t\\t\\t{\\n\\t\\t\\t\\tType = global::TUnit.Core.Enums.DataGeneratorType.TestParameters,\\n\\t\\t\\t\\tTestBuilderContext = testBuilderContextAccessor,\\n\\t\\t\\t\\tTestInformation = testInformation,\\n\\t\\t\\t\\tMembersToGenerate = \\n\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.Dummy.SomeAsyncDisposableClass>\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tName = \\\"value\\\",\\n\\t\\t\\t\\t\\t\\tAttributes = [],\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t],\\n\\t\\t\\t\\tTestSessionId = sessionId,\\n\\t\\t\\t\\tTestClassInstance = classInstance,\\n\\t\\t\\t\\tClassInstanceArguments = classInstanceArguments,\\n\\t\\t\\t};\\n\\t\\t\\tvar methodDataAttribute = new global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.Dummy.SomeAsyncDisposableClass>();\\n\\n\\t\\t\\ttestBuilderContext.DataAttributes.Add(methodDataAttribute);\\n\\n\\t\\t\\tvar methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\\n\\n\\t\\t\\tforeach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttestMethodDataIndex++;\\n\\t\\t\\t\\tclassInstanceArguments = [];\\n\\n\\t\\t\\t\\tvar methodArgGeneratedData = methodArgGeneratedDataAccessor();\\n\\t\\t\\t\\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ClassDataSourceDrivenTests>(() => \\n\\t\\t\\t\\tnew global::TUnit.TestProject.ClassDataSourceDrivenTests()\\n\\t\\t\\t\\t, sessionId, testBuilderContext);\\n\\t\\t\\t\\tvar resettableClassFactory = resettableClassFactoryDelegate();\\n\\n\\n\\t\\t\\t\\tnodes.Add(new TestMetadata<global::TUnit.TestProject.ClassDataSourceDrivenTests>\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tTestId = $\\\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.Dummy.SomeAsyncDisposableClass>:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.ClassDataSourceDrivenTests.DataSource_Class_Generic(TUnit.TestProject.Dummy.SomeAsyncDisposableClass):0\\\",\\n\n```\n\n----------------------------------------\n\nTITLE: Creating OrAssertionException Class in C#\nDESCRIPTION: This class represents an exception that occurs when multiple assertions in an 'Or' group fail. It inherits from AggregateException and provides a custom Message property.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic class OrAssertionException : System.AggregateException\n{\n    public OrAssertionException(System.Collections.Generic.IEnumerable<System.Exception> exceptions) { }\n    public override string Message { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Test Source Generator Class Definition - Part 1\nDESCRIPTION: Partial class implementation for CustomDisplayNameTests that handles test collection and initialization for MethodDataSourceTest. Includes test metadata generation and error handling.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/CustomDisplayNameTests.Test.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class CustomDisplayNameTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new CustomDisplayNameTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Test Initialization Failures and Updating FailedTestMetadata - TUnit - C#\nDESCRIPTION: Captures test initialization exceptions and adds a FailedTestMetadata node for logging and reporting. Wraps the original exception in a TestFailedInitializationException, retaining method names and context. Inputs are method context and exception object; output is a FailedTestMetadata record for error tracking. Dependency: TUnit.Core.Exceptions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>\n\t{\n\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS1:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.ClassTupleDataSourceDrivenTests(int,string,bool).DataSource_TupleMethod(int,string,bool):0\",\n\t\tMethodName = $\"DataSource_TupleMethod\",\n\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ClassTupleDataSourceDrivenTests.DataSource_TupleMethod failed to initialize\", exception),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 24,\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Log Level Provider in C#\nDESCRIPTION: Class for managing log levels based on command line options\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic class LogLevelProvider\n{\n    public LogLevelProvider(Microsoft.Testing.Platform.CommandLine.ICommandLineOptions commandLineOptions) { }\n    public TUnit.Core.Enums.LogLevel LogLevel { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Test Metadata Generation Method in C#\nDESCRIPTION: Implementation of test metadata collection method that creates test instances with specified arguments and handles test initialization failures. Includes exception handling and test context setup.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassAndMethodArgumentsTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n    global::System.Collections.Generic.List<TestMetadata> nodes = [];\n    var classDataIndex = 0;\n    var testMethodDataIndex = 0;\n    try\n    {\n        var testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n        {\n            Type = typeof(global::TUnit.TestProject.ClassAndMethodArgumentsTests),\n            Name = \"Simple\",\n            GenericTypeCount = 0,\n            ReturnType = typeof(global::System.Threading.Tasks.Task),\n            Attributes = \n            [\n                new global::TUnit.Core.TestAttribute()\n            ],\n            Parameters = []\n        };\n        // ... initialization code ...\n    }\n    catch (global::System.Exception exception)\n    {\n        nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ClassAndMethodArgumentsTests>\n        {\n            TestId = $\"global::TUnit.Core.ArgumentsAttribute:{classDataIndex}:CL-ARGS0:TUnit.TestProject.ClassAndMethodArgumentsTests(string).Simple:0\",\n            MethodName = $\"Simple\",\n            Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ClassAndMethodArgumentsTests.Simple failed to initialize\", exception),\n            TestFilePath = @\"\",\n            TestLineNumber = 8,\n        });\n    }\n    return nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering TUnit Tests by Class Name (Shell)\nDESCRIPTION: This command runs all TUnit tests within the class named `LoginTests`, regardless of the assembly or namespace. It utilizes the `dotnet run` command with the `--treenode-filter` flag and a specific filter pattern incorporating wildcards `*` for assembly and namespace, targeting the class name.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/test-filters.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet run --treenode-filter /*/*/LoginTests/*\n```\n\n----------------------------------------\n\nTITLE: Defining Compare Class with CheckEquivalent Method in C#\nDESCRIPTION: Defines a static `Compare` class containing methods for object comparison. The `CheckEquivalent` method compares two objects (`actual` and `expected`) for structural equivalence based on the provided `CompareOptions` and returns an enumerable of `ComparisonFailure` detailing any differences found.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_31\n\nLANGUAGE: csharp\nCODE:\n```\n    public static class Compare\n    {\n        public static System.Collections.Generic.IEnumerable<TUnit.Assertions.ComparisonFailure> CheckEquivalent<TActual, TExpected>(TActual actual, TExpected expected, TUnit.Assertions.CompareOptions options, int? index) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing ITestSource for Inherited_ConcreteClass2 in C#\nDESCRIPTION: This code snippet defines a partial class Inherited_ConcreteClass2 that implements the ITestSource interface. It provides similar functionality to ConcreteClass2 but for a different test class, including test collection and initialization.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AbstractTests.Concrete2.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Inherited_ConcreteClass2 : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new Inherited_ConcreteClass2());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\t// ... (implementation details)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Generating TUnit Test Metadata with Property Data Sources in C#\nDESCRIPTION: This C# method `Tests0` is responsible for generating a list of `TestMetadata` for TUnit tests. It defines test information (like method, class, attributes), sets up a `TestBuilderContext`, and initializes various property arguments (`propertyArg` to `propertyArg6`). It demonstrates using hardcoded values, method calls (`MethodData`), and multiple instances of `ClassDataSourceAttribute` to fetch data for test properties, including configuring different sharing scopes (`PerTestSession`, `PerClass`, `Keyed`) and targeting both instance and static properties.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/InheritedPropertySetterTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.InheritedPropertySetterTests),\n\t\t\t\tName = \"Test\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute()\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.InheritedPropertySetterTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.InheritedPropertySetterTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"InheritedPropertySetterTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"InheritedPropertySetterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"InheritedPropertySetterTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.InheritsTestsAttribute(),\n\t\t\t\t\t\tnew global::TUnit.Core.NotInParallelAttribute(\"PropertySetterTests\")\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.InheritedPropertySetterTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\t\t\t\tstring propertyArg = \"1\";\n\n\t\t\t\tstring propertyArg1 = global::TUnit.TestProject.InheritedPropertySetterTests.MethodData();\n\t\t\t\tvar propertyDataAttribute2 = new global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.PropertySetterTests.InnerModel>();\n\t\t\t\ttestBuilderContext.DataAttributes.Add(propertyDataAttribute2);\n\n\t\t\t\tvar propertyArg2 = propertyDataAttribute2.GenerateDataSources(new DataGeneratorMetadata\t\t\t\t{\n\t\t\t\t\tType = global::TUnit.Core.Enums.DataGeneratorType.Property,\n\t\t\t\t\tTestBuilderContext = testBuilderContextAccessor,\n\t\t\t\t\tTestInformation = testInformation,\n\t\t\t\t\tMembersToGenerate = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.PropertySetterTests.InnerModel),\n\t\t\t\t\t\t\tName = \"Property3\",\n\t\t\t\t\t\t\tIsStatic = false,\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tTestSessionId = sessionId,\n\t\t\t\t\tTestClassInstance = classInstance,\n\t\t\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t\t\t}).ElementAtOrDefault(0)();\n\n\t\t\t\tvar propertyDataAttribute3 = new global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.PropertySetterTests.InnerModel>()\n\t\t\t\t{\n\t\t\t\t\tShared = global::TUnit.Core.SharedType.PerTestSession,\n};\n\t\t\t\t\ttestBuilderContext.DataAttributes.Add(propertyDataAttribute3);\n\n\t\t\t\t\tvar propertyArg3 = propertyDataAttribute3.GenerateDataSources(new DataGeneratorMetadata\t\t\t\t\t{\n\t\t\t\t\t\tType = global::TUnit.Core.Enums.DataGeneratorType.Property,\n\t\t\t\t\t\tTestBuilderContext = testBuilderContextAccessor,\n\t\t\t\t\t\tTestInformation = testInformation,\n\t\t\t\t\t\tMembersToGenerate = \n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.PropertySetterTests.InnerModel),\n\t\t\t\t\t\t\t\tName = \"Property4\",\n\t\t\t\t\t\t\t\tIsStatic = false,\n\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t\tTestSessionId = sessionId,\n\t\t\t\t\t\tTestClassInstance = classInstance,\n\t\t\t\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t\t\t\t}).ElementAtOrDefault(0)();\n\n\t\t\t\t\tvar propertyDataAttribute4 = new global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.PropertySetterTests.InnerModel>()\n\t\t\t\t\t{\n\t\t\t\t\t\tShared = global::TUnit.Core.SharedType.PerClass,\n};\n\t\t\t\t\t\ttestBuilderContext.DataAttributes.Add(propertyDataAttribute4);\n\n\t\t\t\t\t\tvar propertyArg4 = propertyDataAttribute4.GenerateDataSources(new DataGeneratorMetadata\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType = global::TUnit.Core.Enums.DataGeneratorType.Property,\n\t\t\t\t\t\t\tTestBuilderContext = testBuilderContextAccessor,\n\t\t\t\t\t\t\tTestInformation = testInformation,\n\t\t\t\t\t\t\tMembersToGenerate = \n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.PropertySetterTests.InnerModel),\n\t\t\t\t\t\t\t\t\tName = \"Property5\",\n\t\t\t\t\t\t\t\t\tIsStatic = false,\n\t\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\tTestSessionId = sessionId,\n\t\t\t\t\t\t\tTestClassInstance = classInstance,\n\t\t\t\t\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t\t\t\t\t}).ElementAtOrDefault(0)();\n\n\t\t\t\t\t\tvar propertyDataAttribute5 = new global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.PropertySetterTests.InnerModel>()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tShared = global::TUnit.Core.SharedType.Keyed,\n\t\t\t\t\t\t\tKey = \"Key\",\n};\n\t\t\t\t\t\t\ttestBuilderContext.DataAttributes.Add(propertyDataAttribute5);\n\n\t\t\t\t\t\t\tvar propertyArg5 = propertyDataAttribute5.GenerateDataSources(new DataGeneratorMetadata\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tType = global::TUnit.Core.Enums.DataGeneratorType.Property,\n\t\t\t\t\t\t\t\tTestBuilderContext = testBuilderContextAccessor,\n\t\t\t\t\t\t\t\tTestInformation = testInformation,\n\t\t\t\t\t\t\t\tMembersToGenerate = \n\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.PropertySetterTests.InnerModel),\n\t\t\t\t\t\t\t\t\t\tName = \"Property6\",\n\t\t\t\t\t\t\t\t\t\tIsStatic = false,\n\t\t\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\tTestSessionId = sessionId,\n\t\t\t\t\t\t\t\tTestClassInstance = classInstance,\n\t\t\t\t\t\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t\t\t\t\t\t}).ElementAtOrDefault(0)();\n\n\t\t\t\t\t\t\tvar propertyDataAttribute6 = new global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.PropertySetterTests.StaticInnerModel>()\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tShared = global::TUnit.Core.SharedType.PerTestSession,\n};\n\t\t\t\t\t\t\t\ttestBuilderContext.DataAttributes.Add(propertyDataAttribute6);\n\n\t\t\t\t\t\t\t\tvar propertyArg6 = propertyDataAttribute6.GenerateDataSources(new DataGeneratorMetadata\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tType = global::TUnit.Core.Enums.DataGeneratorType.Property,\n\t\t\t\t\t\t\t\t\tTestBuilderContext = testBuilderContextAccessor,\n\t\t\t\t\t\t\t\t\tTestInformation = testInformation,\n\t\t\t\t\t\t\t\t\tMembersToGenerate = \n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.PropertySetterTests.StaticInnerModel),\n\t\t\t\t\t\t\t\t\t\t\tName = \"StaticProperty\",\n\t\t\t\t\t\t\t\t\t\t\tIsStatic = true,\n\t\t\t\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\tTestSessionId = sessionId,\n\t\t\t\t\t\t\t\t\tTestClassInstance = classInstance,\n\t\t\t\t\t\t\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t\t\t\t\t\t\t}).ElementAtOrDefault(0)();\n\n```\n\n----------------------------------------\n\nTITLE: Defining Auto-Generated TUnit Test Source for Property Setter Tests in C#\nDESCRIPTION: This C# code defines an auto-generated partial class `PropertySetterTests` implementing `ITestSource` for the TUnit framework. It registers itself via `ModuleInitializer` and contains the `CollectTests` method to gather test metadata. The `Tests0` method constructs `TestMetadata` by defining test information (method, class, properties, attributes) and generates property values using various data source attributes (`ArgumentsAttribute`, `MethodDataSourceAttribute`, `ClassDataSourceAttribute`) and helper classes like `TestBuilderContext` and `DataGeneratorMetadata`. It prepares a factory delegate using `ResettableLazy` to instantiate the test class (`TUnit.TestProject.PropertySetterTests`) with properties populated from the generated data.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/PropertySetterTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[  \n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class PropertySetterTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new PropertySetterTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.PropertySetterTests),\n\t\t\t\tName = \"Test\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute()\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.PropertySetterTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.PropertySetterTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"PropertySetterTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"PropertySetterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"PropertySetterTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.NotInParallelAttribute(\"PropertySetterTests\")\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = \n\t\t\t\t\t[\nnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType = typeof(string),\n\t\t\t\t\t\t\tName = \"Property1\",\n\t\t\t\t\t\t\tIsStatic = false,\n\t\t\t\t\t\t\tAttributes = \n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"1\")\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\nnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType = typeof(string),\n\t\t\t\t\t\t\tName = \"Property2\",\n\t\t\t\t\t\t\tIsStatic = false,\n\t\t\t\t\t\t\tAttributes = \n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"MethodData\")\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\nnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.PropertySetterTests.InnerModel),\n\t\t\t\t\t\t\tName = \"Property3\",\n\t\t\t\t\t\t\tIsStatic = false,\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\nnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.PropertySetterTests.InnerModel),\n\t\t\t\t\t\t\tName = \"Property4\",\n\t\t\t\t\t\t\tIsStatic = false,\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\nnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.PropertySetterTests.InnerModel),\n\t\t\t\t\t\t\tName = \"Property5\",\n\t\t\t\t\t\t\tIsStatic = false,\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\nnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.PropertySetterTests.InnerModel),\n\t\t\t\t\t\t\tName = \"Property6\",\n\t\t\t\t\t\t\tIsStatic = false,\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\nnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType = typeof(string),\n\t\t\t\t\t\t\tName = \"Property7\",\n\t\t\t\t\t\t\tIsStatic = false,\n\t\t\t\t\t\t\tAttributes = \n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew DataSourceGeneratorTests.AutoFixtureGenerator<string>()\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\nnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.PropertySetterTests.StaticInnerModel),\n\t\t\t\t\t\t\tName = \"StaticProperty\",\n\t\t\t\t\t\t\tIsStatic = true,\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.PropertySetterTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\t\t\t\tstring propertyArg = \"1\";\n\n\t\t\t\tstring propertyArg1 = global::TUnit.TestProject.PropertySetterTests.MethodData();\n\t\t\t\tvar propertyDataAttribute2 = new global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.PropertySetterTests.InnerModel>();\n\t\t\t\ttestBuilderContext.DataAttributes.Add(propertyDataAttribute2);\n\n\t\t\t\tvar propertyArg2 = propertyDataAttribute2.GenerateDataSources(new DataGeneratorMetadata\t\t\t\t{\n\t\t\t\t\tType = global::TUnit.Core.Enums.DataGeneratorType.Property,\n\t\t\t\t\tTestBuilderContext = testBuilderContextAccessor,\n\t\t\t\t\tTestInformation = testInformation,\n\t\t\t\t\tMembersToGenerate = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.PropertySetterTests.InnerModel),\n\t\t\t\t\t\t\tName = \"Property3\",\n\t\t\t\t\t\t\tIsStatic = false,\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tTestSessionId = sessionId,\n\t\t\t\t\tTestClassInstance = classInstance,\n\t\t\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t\t\t}).ElementAtOrDefault(0)();\n\n\t\t\t\tvar propertyDataAttribute3 = new global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.PropertySetterTests.InnerModel>()\n\t\t\t\t{\n\t\t\t\t\tShared = global::TUnit.Core.SharedType.PerTestSession,\n};\n\t\t\t\t\ttestBuilderContext.DataAttributes.Add(propertyDataAttribute3);\n\n\t\t\t\t\tvar propertyArg3 = propertyDataAttribute3.GenerateDataSources(new DataGeneratorMetadata\t\t\t\t\t{\n\t\t\t\t\t\tType = global::TUnit.Core.Enums.DataGeneratorType.Property,\n\t\t\t\t\t\tTestBuilderContext = testBuilderContextAccessor,\n\t\t\t\t\t\tTestInformation = testInformation,\n\t\t\t\t\t\tMembersToGenerate = \n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.PropertySetterTests.InnerModel),\n\t\t\t\t\t\t\t\tName = \"Property4\",\n\t\t\t\t\t\t\t\tIsStatic = false,\n\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t\tTestSessionId = sessionId,\n\t\t\t\t\t\tTestClassInstance = classInstance,\n\t\t\t\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t\t\t\t}).ElementAtOrDefault(0)();\n\n\t\t\t\t\tvar propertyDataAttribute4 = new global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.PropertySetterTests.InnerModel>()\n\t\t\t\t\t{\n\t\t\t\t\t\tShared = global::TUnit.Core.SharedType.PerClass,\n};\n\t\t\t\t\t\ttestBuilderContext.DataAttributes.Add(propertyDataAttribute4);\n\n\t\t\t\t\t\tvar propertyArg4 = propertyDataAttribute4.GenerateDataSources(new DataGeneratorMetadata\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType = global::TUnit.Core.Enums.DataGeneratorType.Property,\n\t\t\t\t\t\t\tTestBuilderContext = testBuilderContextAccessor,\n\t\t\t\t\t\t\tTestInformation = testInformation,\n\t\t\t\t\t\t\tMembersToGenerate = \n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.PropertySetterTests.InnerModel),\n\t\t\t\t\t\t\t\t\tName = \"Property5\",\n\t\t\t\t\t\t\t\t\tIsStatic = false,\n\t\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\tTestSessionId = sessionId,\n\t\t\t\t\t\t\tTestClassInstance = classInstance,\n\t\t\t\t\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t\t\t\t\t}).ElementAtOrDefault(0)();\n\n\t\t\t\t\t\tvar propertyDataAttribute5 = new global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.PropertySetterTests.InnerModel>()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tShared = global::TUnit.Core.SharedType.Keyed,\n\t\t\t\t\t\t\tKey = \"Key\",\n};\n\t\t\t\t\t\t\ttestBuilderContext.DataAttributes.Add(propertyDataAttribute5);\n\n\t\t\t\t\t\t\tvar propertyArg5 = propertyDataAttribute5.GenerateDataSources(new DataGeneratorMetadata\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tType = global::TUnit.Core.Enums.DataGeneratorType.Property,\n\t\t\t\t\t\t\t\tTestBuilderContext = testBuilderContextAccessor,\n\t\t\t\t\t\t\t\tTestInformation = testInformation,\n\t\t\t\t\t\t\t\tMembersToGenerate = \n\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.PropertySetterTests.InnerModel),\n\t\t\t\t\t\t\t\t\t\tName = \"Property6\",\n\t\t\t\t\t\t\t\t\t\tIsStatic = false,\n\t\t\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\tTestSessionId = sessionId,\n\t\t\t\t\t\t\t\tTestClassInstance = classInstance,\n\t\t\t\t\t\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t\t\t\t\t\t}).ElementAtOrDefault(0)();\n\n\t\t\t\t\t\t\tvar propertyDataAttribute6 = new global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.PropertySetterTests.StaticInnerModel>()\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tShared = global::TUnit.Core.SharedType.PerTestSession,\n};\n\t\t\t\t\t\t\t\ttestBuilderContext.DataAttributes.Add(propertyDataAttribute6);\n\n\t\t\t\t\t\t\t\tvar propertyArg6 = propertyDataAttribute6.GenerateDataSources(new DataGeneratorMetadata\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tType = global::TUnit.Core.Enums.DataGeneratorType.Property,\n\t\t\t\t\t\t\t\t\tTestBuilderContext = testBuilderContextAccessor,\n\t\t\t\t\t\t\t\t\tTestInformation = testInformation,\n\t\t\t\t\t\t\t\t\tMembersToGenerate = \n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.PropertySetterTests.StaticInnerModel),\n\t\t\t\t\t\t\t\t\t\t\tName = \"StaticProperty\",\n\t\t\t\t\t\t\t\t\t\t\tIsStatic = true,\n\t\t\t\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\tTestSessionId = sessionId,\n\t\t\t\t\t\t\t\t\tTestClassInstance = classInstance,\n\t\t\t\t\t\t\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t\t\t\t\t\t\t}).ElementAtOrDefault(0)();\n\n\n\t\t\t\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.PropertySetterTests>(() => \n\t\t\t\t\t\t\t\tnew global::TUnit.TestProject.PropertySetterTests()\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tProperty1 = global::TUnit.Core.Helpers.CastHelper.Cast<string>(propertyArg),\n\t\t\t\t\t\t\t\t\tProperty2 = global::TUnit.Core.Helpers.CastHelper.Cast<string>(propertyArg1),\n\t\t\t\t\t\t\t\t\tProperty3 = global::TUnit.Core.Helpers.CastHelper.Cast<global::TUnit.TestProject.PropertySetterTests.InnerModel>(propertyArg2),\n\n```\n\n----------------------------------------\n\nTITLE: HookMessagePublisher for Test Hook Communication\nDESCRIPTION: A service that implements the IHookMessagePublisher interface to facilitate communication between test hooks and the Microsoft Testing Platform message bus.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\npublic class HookMessagePublisher : Microsoft.Testing.Platform.Extensions.IExtension, Microsoft.Testing.Platform.Extensions.Messages.IDataProducer, TUnit.Core.Hooks.IHookMessagePublisher\n{\n    public HookMessagePublisher(Microsoft.Testing.Platform.Extensions.IExtension extension, Microsoft.Testing.Platform.Messages.IMessageBus messageBus) { }\n    public System.Type[] DataTypesProduced { get; }\n    public string Description { get; }\n    public string DisplayName { get; }\n    public string Uid { get; }\n    public string Version { get; }\n    public System.Threading.Tasks.Task Discover(string sessionId, string displayName, TUnit.Core.Hooks.StaticHookMethod hookMethod) { }\n    public System.Threading.Tasks.Task<bool> IsEnabledAsync() { }\n    public System.Threading.Tasks.Task Push(string sessionId, string displayName, TUnit.Core.Hooks.StaticHookMethod hookMethod, System.Func<System.Threading.Tasks.Task> func) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Tests for EnumerableDataSourceDrivenTests in C#\nDESCRIPTION: Implements the CollectTests method from the ITestSource interface. This method returns a list of TestMetadata objects representing the tests to be executed, based on the provided session ID.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/EnumerableDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn Tests0(sessionId);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ITestSource Interface in Auto-Generated Tests Class for TUnit Framework in C#\nDESCRIPTION: This code defines a source-generated partial class that implements ITestSource to collect and register test metadata for the TUnit testing framework. It includes module initialization, test collection methods, and handling of test attributes with support for dependency injection.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1539.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[  \n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Tests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new Tests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1539.Tests),\n\t\t\t\tName = \"Test\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.TestProject.Bugs._1539.Tests.AttributeWithPositionalArgs(),\n\t\t\t\t\tnew global::TUnit.TestProject.Bugs._1539.Tests.AttributeWithPositionalArgs(11),\n\t\t\t\t\tnew global::TUnit.TestProject.Bugs._1539.Tests.AttributeWithPositionalArgs(two: \"two\"),\n\t\t\t\t\tnew global::TUnit.TestProject.Bugs._1539.Tests.AttributeWithPositionalArgs(three: false)\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._1539.Tests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1539.Tests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Tests1539\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"Tests1539\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"Tests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._1539\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.Bugs._1539.Tests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._1539.Tests>(() => \n\t\t\t\tnew global::TUnit.TestProject.Bugs._1539.Tests()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._1539.Tests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"TUnit.TestProject.Bugs._1539.Tests.Test:0\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Test()),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 5,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresetableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._1539.Tests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"TUnit.TestProject.Bugs._1539.Tests.Test:0\",\n\t\t\t\t\tMethodName = $\"Test\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"Tests.Test failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 5,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n\t}\n\n]\n```\n\n----------------------------------------\n\nTITLE: Publishing Hook Messages - Microsoft Testing Platform & TUnit - C#\nDESCRIPTION: Defines the HookMessagePublisher class, implementing extension and data producer interfaces for interoperating with both the Microsoft Testing Platform and TUnit's hook system. It includes constructors for dependency injection, properties for describing the extension, and async methods for discovering and pushing hook method messages. Ensures integration with the message bus and supports dynamic enabling/disabling of the publisher.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\npublic class HookMessagePublisher : Microsoft.Testing.Platform.Extensions.IExtension, Microsoft.Testing.Platform.Extensions.Messages.IDataProducer, TUnit.Core.Hooks.IHookMessagePublisher\n{\n    public HookMessagePublisher(Microsoft.Testing.Platform.Extensions.IExtension extension, Microsoft.Testing.Platform.Messages.IMessageBus messageBus) { }\n    public System.Type[] DataTypesProduced { get; }\n    public string Description { get; }\n    public string DisplayName { get; }\n    public string Uid { get; }\n    public string Version { get; }\n    public System.Threading.Tasks.Task Discover(string sessionId, string displayName, TUnit.Core.Hooks.StaticHookMethod hookMethod) { }\n    public System.Threading.Tasks.Task<bool> IsEnabledAsync() { }\n    public System.Threading.Tasks.Task Push(string sessionId, string displayName, TUnit.Core.Hooks.StaticHookMethod hookMethod, System.Func<System.Threading.Tasks.Task> func) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Auto-Generated TUnit Test Source Class in C#\nDESCRIPTION: This auto-generated code defines a partial class `DataDrivenTests` within the `TUnit.SourceGenerated` namespace. It implements the `TUnit.Core.Interfaces.SourceGenerator.ITestSource` interface, indicating its role in providing test metadata for the TUnit framework. It includes necessary using directives and attributes for diagnostics and code coverage exclusion, typical for source-generated files.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class DataDrivenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTimeEqualToAssertionBuilderWrapper Class in C#\nDESCRIPTION: This class provides assertions for comparing DateTime values with a specified tolerance. It allows checking if two DateTimes are equal within a given time span.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\npublic class DateTimeEqualToAssertionBuilderWrapper : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTime>\n{\n    public TUnit.Assertions.AssertionBuilders.Wrappers.DateTimeEqualToAssertionBuilderWrapper Within(System.TimeSpan tolerance, [System.Runtime.CompilerServices.CallerArgumentExpression(\"tolerance\")] string doNotPopulateThis = \"\") { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Enumerable Contains Value Assertion in C#\nDESCRIPTION: Class definition for asserting that an enumerable collection contains a specific expected value. It extends ExpectedValueAssertCondition and provides methods for validation and result generation.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumerableContainsExpectedValueAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TInner>\n    where TActual : System.Collections.Generic.IEnumerable<TInner>\n{\n    public EnumerableContainsExpectedValueAssertCondition(TInner expected, System.Collections.Generic.IEqualityComparer<TInner?>? equalityComparer) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TInner? inner) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TimeSpanEqualsExpectedValueAssertCondition for TUnit TimeSpan Assertions (C#)\nDESCRIPTION: Defines the `TimeSpanEqualsExpectedValueAssertCondition` class within the Chronology namespace for comparing `System.TimeSpan` values. Inheriting from `ExpectedValueAssertCondition`, it includes a `SetTolerance` method using `System.TimeSpan` to specify an acceptable margin of error.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_33\n\nLANGUAGE: csharp\nCODE:\n```\n    public class TimeSpanEqualsExpectedValueAssertCondition : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<System.TimeSpan, System.TimeSpan>\n    {\n        public TimeSpanEqualsExpectedValueAssertCondition(System.TimeSpan expected) { }\n        protected override string GetExpectation() { }\n        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(System.TimeSpan actualValue, System.TimeSpan expectedValue) { }\n        public void SetTolerance(System.TimeSpan tolerance) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IFirstTestInClassEventReceiver Interface in C#\nDESCRIPTION: This interface defines a method for handling the first test in a class event. It inherits from IEventReceiver and includes a single method OnFirstTestInClass.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_61\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IFirstTestInClassEventReceiver : TUnit.Core.Interfaces.IEventReceiver\n{\n    System.Threading.Tasks.ValueTask OnFirstTestInClass(TUnit.Core.ClassHookContext context, TUnit.Core.TestContext testContext);\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for NonParams Method in C#\nDESCRIPTION: This snippet demonstrates the generation of test metadata for the NonParams method in ArgsAsArrayTests. It follows a similar pattern to the Params method, but with a different method name and line number.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ArgsAsArrayTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.ArgsAsArrayTests),\n\tName = \"NonParams\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(void),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute(),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(\"arg1\", \"arg2\", \"arg3\")\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string[]>\n\t\t{\n\t\t\tName = \"arguments\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n\t// ... (class information)\n};\n\n// ... (test builder context setup)\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.ArgsAsArrayTests>\n{\n\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.ArgsAsArrayTests.NonParams(string[]):0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [methodArg],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.NonParams(methodArg)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 15,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing AssertionGroupBuilder Class for Creating Assertions\nDESCRIPTION: Generic class for building assertion groups with a fluent API. It allows creating custom assertions using a functional approach with delegates.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_73\n\nLANGUAGE: C#\nCODE:\n```\npublic class AssertionGroupBuilder<TActual, TAssertionBuilder>\n    where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder\n{\n    public TUnit.Assertions.AssertionBuilders.Groups.UnknownAssertionGroup<TActual, TAssertionBuilder> WithAssertion(System.Func<TAssertionBuilder, TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TActual>> assert) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Test Properties and Creating Test Metadata in C#\nDESCRIPTION: This C# snippet demonstrates the final steps of initializing test properties and constructing `TestMetadata`. It casts several property arguments (`propertyArg2` to `propertyArg5`) to `InnerModel` using `CastHelper`, assigns a value to a static property (`StaticProperty`), and then adds a `TestMetadata` object to the `nodes` collection. The `TestMetadata` includes test identifiers, arguments, properties, factories for test execution, and context information. It also features a try-catch block to handle exceptions during initialization, creating a `FailedTestMetadata` object if an error occurs.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/InheritedPropertySetterTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n\t\t\t\t\t\t\t\t\tProperty3 = global::TUnit.Core.Helpers.CastHelper.Cast<global::TUnit.TestProject.PropertySetterTests.InnerModel>(propertyArg2),\n\t\t\t\t\t\t\t\t\tProperty4 = global::TUnit.Core.Helpers.CastHelper.Cast<global::TUnit.TestProject.PropertySetterTests.InnerModel>(propertyArg3),\n\t\t\t\t\t\t\t\t\tProperty5 = global::TUnit.Core.Helpers.CastHelper.Cast<global::TUnit.TestProject.PropertySetterTests.InnerModel>(propertyArg4),\n\t\t\t\t\t\t\t\t\tProperty6 = global::TUnit.Core.Helpers.CastHelper.Cast<global::TUnit.TestProject.PropertySetterTests.InnerModel>(propertyArg5),\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\t\t\t\t\tglobal::TUnit.TestProject.PropertySetterTests.StaticProperty = propertyArg6;\n\n\n\t\t\t\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.PropertySetterTests>\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tTestId = $\"TUnit.TestProject.PropertySetterTests.Test:0\",\n\t\t\t\t\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\t\t\t\t\tTestMethodArguments = [],\n\t\t\t\t\t\t\t\t\tTestClassProperties = [propertyArg, propertyArg1, propertyArg2, propertyArg3, propertyArg4, propertyArg5],\n\t\t\t\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Test()),\n\t\t\t\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\t\t\t\tTestLineNumber = 70,\n\t\t\t\t\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\t\t\t\t\ttestBuilderContext = new();\n\t\t\t\t\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (global::System.Exception exception)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.PropertySetterTests>\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tTestId = $\"TUnit.TestProject.PropertySetterTests.Test:0\",\n\t\t\t\t\t\t\t\t\tMethodName = $\"Test\",\n\t\t\t\t\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"PropertySetterTests.Test failed to initialize\", exception),\n\t\t\t\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\t\t\t\tTestLineNumber = 70,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn nodes;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Resettable Lazy with Class Constructor in C#\nDESCRIPTION: Extends ResettableLazy to use a specific class constructor for creating instances. This provides a more structured approach to object creation for test resources.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\npublic class ResettableLazy<TClassConstructor, T> : TUnit.Core.ResettableLazy<T>\n    where TClassConstructor : TUnit.Core.Interfaces.IClassConstructor, new ()\n    where T :  class\n{\n    public ResettableLazy(string sessionId, TUnit.Core.TestBuilderContext testBuilderContext) { }\n    public override System.Threading.Tasks.ValueTask ResetLazy() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DisplayNameAttribute in C#\nDESCRIPTION: Defines a sealed class DisplayNameAttribute that inherits from DisplayNameFormatterAttribute. It is used to set a custom display name for a test method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Method, Inherited=false)]\npublic sealed class DisplayNameAttribute : TUnit.Core.DisplayNameFormatterAttribute\n{\n    public DisplayNameAttribute(string displayName) { }\n    protected override string FormatDisplayName(TUnit.Core.TestContext testContext) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for Simple Test Method\nDESCRIPTION: Creates test metadata for a simple test method without parameters. It handles exception handling and sets up the necessary test context including class instantiation and method invocation delegates.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1889.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1889.DerivedTest),\n\t\t\tName = \"Test1\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\t\t\t\t],\n\t\t\tParameters = [],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._1889.DerivedTest\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1889.DerivedTest),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Tests1889\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"Tests1889\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"DerivedTest\",\n\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._1889\",\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.InheritsTestsAttribute()\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.Bugs._1889.DerivedTest? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tclassInstanceArguments = [];\n\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._1889.DerivedTest>(() => \n\t\t\tnew global::TUnit.TestProject.Bugs._1889.DerivedTest()\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._1889.DerivedTest>\n\t\t\t{\n\t\t\t\tTestId = $\"TUnit.TestProject.Bugs._1889.DerivedTest.Test1:0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Test1()),\n\t\t\t\tTestLineNumber = 7,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._1889.DerivedTest>\n\t\t\t{\n\t\t\t\tTestId = $\"TUnit.TestProject.Bugs._1889.DerivedTest.Test1:0\",\n\t\t\t\tMethodName = $\"Test1\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"DerivedTest.Test1 failed to initialize\", exception),\n\t\t\t\tTestLineNumber = 7,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing Source Registration Extensions in C#\nDESCRIPTION: Extension methods for registering assertions with delegate and value sources. These methods facilitate the registration of assertion conditions and value conversions for use in test assertions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_78\n\nLANGUAGE: C#\nCODE:\n```\npublic static class SourceExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableDelegateAssertionBuilder RegisterAssertion<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource, TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual> assertCondition, string?[] argumentExpressions, [System.Runtime.CompilerServices.CallerMemberName] string? caller = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> RegisterAssertion<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> source, TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual> assertCondition, string?[] argumentExpressions, [System.Runtime.CompilerServices.CallerMemberName] string? caller = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TToType> RegisterConversionAssertion<TToType>(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource source)\n        where TToType : System.Exception { }\n```\n\n----------------------------------------\n\nTITLE: Creating Test Metadata for Medium Priority Tests\nDESCRIPTION: Builds test metadata for Medium priority test methods. Sets up configuration for test method Medium_1 including test attributes, factory methods, and context initialization.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/PriorityFilteringTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.PriorityFilteringTests),\n\tName = \"Medium_1\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute(),\n\t\tnew global::TUnit.TestProject.PriorityAttribute(global::TUnit.TestProject.Enums.PriorityLevel.Medium)\n\t],\n\tParameters = [],\n\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.PriorityFilteringTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t{\n\t\tType = typeof(global::TUnit.TestProject.PriorityFilteringTests),\n\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"PriorityFilteringTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t{\n\t\t\tName = \"PriorityFilteringTests\",\n\t\t\tAttributes = [],\n\t\t}),\n\t\tName = \"PriorityFilteringTests\",\n\t\tNamespace = \"TUnit.TestProject\",\n\t\tAttributes = [],\n\t\tParameters = [],\n\t\tProperties = [],\n\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Data Source Generator Base in C#\nDESCRIPTION: Abstract base class for non-typed data source generators. Provides infrastructure for dynamically generating test data sources based on metadata.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method | System.AttributeTargets.Property, AllowMultiple=true)]\npublic abstract class NonTypedDataSourceGeneratorAttribute : TUnit.Core.TestDataAttribute, TUnit.Core.IDataAttribute\n{\n    protected NonTypedDataSourceGeneratorAttribute() { }\n    public abstract System.Collections.Generic.IEnumerable<System.Func<object?[]?>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Hooks Base2\nDESCRIPTION: Defines test hook collection methods for Base2 class including after-test hooks implementation with proper attribute decoration and class registration.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t{\n\t\t\tClassType = typeof(global::TUnit.TestProject.AfterTests.Base2),\n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.Base2),\n\t\t\t\tName = \"AfterEach2\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tParameters = []\n\t\t\t}\n\t\t}\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IFilterReceiver Interface in C#\nDESCRIPTION: Declares an interface for objects that can receive a filter string.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IFilterReceiver\n{\n    string? Filter { set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Not Null Assertion Condition for Reference Types in TUnit (C#)\nDESCRIPTION: This class implements an assertion condition that checks if a nullable reference type (`TActual?`) is not null. It inherits from `ConvertToAssertCondition`, converting the input `TActual?` to a non-nullable `TActual` if the assertion passes, allowing subsequent chained assertions to operate on the non-null value. The `where TActual : class?` constraint enforces that `TActual` is a reference type.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_50\n\nLANGUAGE: csharp\nCODE:\n```\n    public class NotNullExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.ConvertToAssertCondition<TActual?, TActual>\n        where TActual :  class?\n    {\n        public NotNullExpectedValueAssertCondition() { }\n        public override System.Threading.Tasks.ValueTask<System.ValueTuple<TUnit.Assertions.AssertConditions.AssertionResult, TActual?>> ConvertValue(TActual? value) { }\n        protected override string GetExpectation() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Dependency Management\nDESCRIPTION: Attributes for specifying test dependencies and execution order. Supports dependency specification by type and method name with optional parameter types.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\npublic class DependsOnAttribute : TUnit.Core.TUnitAttribute\n{\n    public DependsOnAttribute(System.Type testClass) { }\n    public DependsOnAttribute(string testName) { }\n    public DependsOnAttribute(System.Type testClass, string testName) { }\n    public DependsOnAttribute(string testName, System.Type[] parameterTypes) { }\n    public DependsOnAttribute(System.Type testClass, string testName, System.Type[] parameterTypes) { }\n    public System.Type[]? ParameterTypes { get; }\n    public bool ProceedOnFailure { get; set; }\n    public System.Type? TestClass { get; }\n    public string? TestName { get; }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Multiple Assertion Method in C#\nDESCRIPTION: This static method `Multiple` within the `Assert` class likely enables a mode where multiple assertion failures within a scope are collected and reported together, rather than failing the test on the first encountered failure. It returns an `IDisposable`, suggesting a `using` block pattern for defining the scope.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n        public static System.IDisposable Multiple() { }\n```\n\n----------------------------------------\n\nTITLE: Defining DefaultPlaywrightParallelLimiter Class in C#\nDESCRIPTION: This class implements IParallelLimit interface and defines a parallel execution limit for Playwright tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DefaultPlaywrightParallelLimiter : TUnit.Core.Interfaces.IParallelLimit\n{\n    public DefaultPlaywrightParallelLimiter() { }\n    public int Limit { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Test Class for Integer to Short Conversion\nDESCRIPTION: Auto-generated test class that handles test initialization and execution for the Integer_To_Short_Converts test method. Includes test metadata collection, argument handling, and error management.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1603.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Tests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new Tests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1603.Tests),\n\t\t\t\tName = \"Integer_To_Short_Converts\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(-123)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<short>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._1603.Tests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1603.Tests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Tests1603\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"Tests1603\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"Tests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._1603\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing ITestHookSource for GlobalSetUpTests in C#\nDESCRIPTION: This code snippet defines a partial class that implements ITestHookSource interface for GlobalSetUpTests. It includes methods for collecting before and after test hooks, with a focus on the BeforeAllSetUp method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticBeforeEachTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_GlobalSetUpTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_GlobalSetUpTests();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.BeforeTestHookMethod\n\t\t\t{ \n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.GlobalSetUpTests),\n\t\t\t\tName = \"BeforeAllSetUp\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeEveryAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"context\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.GlobalSetUpTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.GlobalSetUpTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"GlobalStaticBeforeEachTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"GlobalStaticBeforeEachTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"GlobalSetUpTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.BeforeTests.GlobalSetUpTests.BeforeAllSetUp(context)),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tFilePath = @\"\",\n\t\t\t\tLineNumber = 50,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeEveryAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\tAssemblyAttributes = [],\n\t\t\t},\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for DataSource_Class_Generic Method in C#\nDESCRIPTION: This snippet demonstrates the generation of test metadata for the DataSource_Class_Generic method. It uses ClassDataSourceAttribute with shared keyed data sources and creates TestMetadata objects for each generated data source.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTestsSharedKeyed.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.ClassDataSourceDrivenTestsSharedKeyed),\n\tName = \"DataSource_Class_Generic\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(void),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute()\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<SomeAsyncDisposableClass>\n\t\t{\n\t\t\tName = \"value\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n\t// ... (additional properties)\n};\n\n// ... (test builder context and data generation)\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.ClassDataSourceDrivenTestsSharedKeyed>\n{\n\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<SomeAsyncDisposableClass>:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.ClassDataSourceDrivenTestsSharedKeyed.DataSource_Class_Generic(SomeAsyncDisposableClass):0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [methodArgGeneratedData],\n\t// ... (additional properties)\n});\n```\n\n----------------------------------------\n\nTITLE: Matrix Test Source Generation Class Implementation (C#)\nDESCRIPTION: Implementation of a partial class MatrixTests that provides source-generated test collection functionality for matrix-based test cases. It handles test metadata creation, parameter processing, and test execution setup.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MatrixTests.Test.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class MatrixTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n    [global::System.Runtime.CompilerServices.ModuleInitializer]\n    public static void Initialise()\n    {\n        global::TUnit.Core.SourceRegistrar.Register(new MatrixTests());\n    }\n    public global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n    {\n        return Tests0(sessionId);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Hook Source Class in C#\nDESCRIPTION: Partial class implementing ITestHookSource interface that manages test hooks for the TUnit testing framework. The class handles registration and collection of test hooks, particularly focusing on after-test cleanup operations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterAllTests.Test.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_CleanupTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_CleanupTests();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.AfterTests.CleanupTests),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.CleanupTests),\n\t\t\t\t\tName = \"CleanupWithContext\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test),\n\t\t\t\t\t\tnew global::TUnit.Core.TimeoutAttribute(30_000)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"testContext\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.CleanupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.CleanupTests),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AfterAllTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"AfterAllTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"CleanupTests\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.AfterTests.CleanupTests)classInstance).CleanupWithContext(context, cancellationToken)),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test),\n\t\t\t\t\t\tnew global::TUnit.Core.TimeoutAttribute(30_000)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: Registering and Collecting Source-Generated Class Data-Driven Tests with TUnit in C#\nDESCRIPTION: Implements a source-generated partial class that registers itself via a module initializer and provides a method to collect test metadata for data-driven tests with multiple injectable class parameters using the TUnit framework. Depends on TUnit.Core, TUnit.Core.Extensions, and several source-generated metadata and context classes. The CollectTests method routes to a generated method that builds test metadata, handles class argument data setup and exception scenarios, and returns a list of test metadata which can be executed by the TUnit engine. Expected inputs include a session ID; outputs are collections of test metadata describing data-driven test cases, each with all needed arguments and factory delegates for instantiating the test instances. Requires the TUnit.Core APIs and the project-specific injectable parameter types.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MultipleClassDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class MultipleClassDataSourceDrivenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new MultipleClassDataSourceDrivenTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.MultipleClassDataSourceDrivenTests),\n\t\t\t\tName = \"Test1\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute()\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.MultipleClassDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.MultipleClassDataSourceDrivenTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"MultipleClassDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"MultipleClassDataSourceDrivenTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"MultipleClassDataSourceDrivenTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject1>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"inject1\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject2>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"inject2\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject3>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"inject3\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject4>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"inject4\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject5>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"inject5\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.MultipleClassDataSourceDrivenTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tvar classArgDataGeneratorMetadata = new DataGeneratorMetadata\n\t\t\t\t{\n\t\t\t\t\tType = global::TUnit.Core.Enums.DataGeneratorType.ClassParameters,\n\t\t\t\t\tTestBuilderContext = testBuilderContextAccessor,\n\t\t\t\t\tTestInformation = testInformation,\n\t\t\t\t\tMembersToGenerate = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject1>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"inject1\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject2>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"inject2\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject3>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"inject3\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject4>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"inject4\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject5>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"inject5\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tTestSessionId = sessionId,\n\t\t\t\t\tTestClassInstance = classInstance,\n\t\t\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t\t\t};\n\t\t\t\tvar classDataAttribute = new global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject1, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject2, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject3, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject4, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject5>()\n\t\t\t\t{\n\t\t\t\t\tShared = [global::TUnit.Core.SharedType.None, global::TUnit.Core.SharedType.None, global::TUnit.Core.SharedType.None, global::TUnit.Core.SharedType.None, global::TUnit.Core.SharedType.None],\n};\n\n\t\t\t\t\ttestBuilderContext.DataAttributes.Add(classDataAttribute);\n\n\t\t\t\t\tvar classArgGeneratedDataArray = classDataAttribute.GenerateDataSources(classArgDataGeneratorMetadata);\n\n\t\t\t\t\tforeach (var classArgGeneratedDataAccessor in classArgGeneratedDataArray)\n\t\t\t\t\t{\n\t\t\t\t\t\tclassDataIndex++;\n\t\t\t\t\t\tvar classArgGeneratedData = classArgGeneratedDataAccessor();\n\t\t\t\t\t\tglobal::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject1 classArg = classArgGeneratedData.Item1;\n\t\t\t\t\t\tglobal::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject2 classArg1 = classArgGeneratedData.Item2;\n\t\t\t\t\t\tglobal::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject3 classArg2 = classArgGeneratedData.Item3;\n\t\t\t\t\t\tglobal::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject4 classArg3 = classArgGeneratedData.Item4;\n\t\t\t\t\t\tglobal::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject5 classArg4 = classArgGeneratedData.Item5;\n\n\t\t\t\t\t\tclassInstanceArguments = [classArg, classArg1, classArg2, classArg3, classArg4];\n\n\t\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests>(() => \n\t\t\t\t\t\tnew global::TUnit.TestProject.MultipleClassDataSourceDrivenTests(classArg, classArg1, classArg2, classArg3, classArg4)\n\t\t\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject1, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject2, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject3, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject4, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject5>:{classDataIndex}:CL-GAC0:TUnit.TestProject.MultipleClassDataSourceDrivenTests(TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject1,TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject2,TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject3,TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject4,TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject5).Test1:0\",\n\t\t\t\t\t\t\tTestClassArguments = [classArg, classArg1, classArg2, classArg3, classArg4],\n\t\t\t\t\t\t\tTestMethodArguments = [],\n\t\t\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Test1()),\n\t\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\t\tTestLineNumber = 14,\n\t\t\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\t\t\ttestBuilderContext = new();\n\t\t\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (global::System.Exception exception)\n\t\t\t\t{\n\t\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests>\n\t\t\t\t\t{\n\t\t\t\t\t\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject1, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject2, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject3, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject4, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject5>:{classDataIndex}:CL-GAC0:TUnit.TestProject.MultipleClassDataSourceDrivenTests(TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject1,TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject2,TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject3,TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject4,TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject5).Test1:0\",\n\t\t\t\t\t\tMethodName = $\"Test1\",\n\t\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"MultipleClassDataSourceDrivenTests.Test1 failed to initialize\", exception),\n\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\tTestLineNumber = 14,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn nodes;\n\t\t\t}\n\t\t}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing StopExecutionCapability in C# for TUnit Engine\nDESCRIPTION: Implementation of a capability class for gracefully stopping test execution, implementing Microsoft Testing Platform interfaces. This class exposes a mechanism to request stopping test execution and notify subscribers.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class StopExecutionCapability : Microsoft.Testing.Platform.Capabilities.ICapability, Microsoft.Testing.Platform.Capabilities.TestFramework.IGracefulStopTestExecutionCapability, Microsoft.Testing.Platform.Capabilities.TestFramework.ITestFrameworkCapability\n{\n    public StopExecutionCapability() { }\n    public bool IsStopRequested { get; }\n    public TUnit.Core.AsyncEvent<System.EventArgs>? OnStopRequested { get; set; }\n    public System.Threading.Tasks.Task StopTestExecutionAsync(System.Threading.CancellationToken cancellationToken) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata using Tuple/NamedTuple Sources (Tests2) in C#\nDESCRIPTION: This private C# method `Tests2` generates a list of `TestMetadata` for the `DataSource_TupleMethod` test within the `ClassTupleDataSourceDrivenTests` class. It fetches class constructor arguments from `TupleMethod` and method arguments from `NamedTupleMethod` using `MethodDataSourceAttribute`. It initializes the test class properties using both `TupleMethod` and `NamedTupleMethod`. A `ResettableLazy` factory is created for the test class instance, associated with a specific `sessionId` and `TestBuilderContext`. An error handling block catches exceptions during this setup process and records them as `FailedInitializationTest` objects.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=TupleMethod_testMethodName=NamedTupleMethod.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests2(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testClassType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests);\n\t\t\tvar methodInfo = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests).GetMethod(\"DataSource_TupleMethod\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]);\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tvar classArgTuples = global::System.TupleExtensions.ToTuple<global::System.Int32, global::System.String, global::System.Boolean>(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()());\n\t\t\tglobal::System.Int32 classArg = classArgTuples.Item1;\n\t\t\tglobal::System.String classArg1 = classArgTuples.Item2;\n\t\t\tglobal::System.Boolean classArg2 = classArgTuples.Item3;\n\t\t\t(global::System.Int32, global::System.String, global::System.Boolean) propertyArg = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()();\n\t\t\t(global::System.Int32 Number, global::System.String Word, global::System.Boolean Flag) propertyArg1 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()();\n\t\t\t(global::System.Int32, global::System.String, global::System.Boolean) propertyArg2 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()();\n\t\t\t(global::System.Int32 Number, global::System.String Word, global::System.Boolean Flag) propertyArg3 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()();\n\n\t\t\tvar methodArgTuples = global::System.TupleExtensions.ToTuple<global::System.Int32, global::System.String, global::System.Boolean>(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()());\n\t\t\tglobal::System.Int32 methodArg = methodArgTuples.Item1;\n\t\t\tglobal::System.String methodArg1 = methodArgTuples.Item2;\n\t\t\tglobal::System.Boolean methodArg2 = methodArgTuples.Item3;\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>(() => \n\t\t\tnew global::TUnit.TestProject.ClassTupleDataSourceDrivenTests(classArg, classArg1, classArg2)\n\t\t\t{\n\t\t\t\tProperty1 = propertyArg,\n\t\t\t\tProperty2 = propertyArg1,\n\t\t\t\tProperty3 = propertyArg2,\n\t\t\t\tProperty4 = propertyArg3,\n\t\t\t}\n\t\t\t, sessionId, testBuilderContext);\n\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS0:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.ClassTupleDataSourceDrivenTests(System.Int32,System.String,System.Boolean).DataSource_TupleMethod(System.Int32,System.String,System.Boolean):0\",\n\t\t\t\tTestClassArguments = [classArg, classArg1, classArg2],\n\t\t\t\tTestMethodArguments = [methodArg, methodArg1, methodArg2],\n\t\t\t\tTestClassProperties = [propertyArg, propertyArg1, propertyArg2, propertyArg3],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tMethodInfo = methodInfo,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_TupleMethod(methodArg, methodArg1, methodArg2)),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 24,\n\t\t\t\tTestAttributes = [ new global::TUnit.Core.TestAttribute()\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n{\n    \n} ],\n\t\t\t\tClassAttributes = [ new global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n{\n    \n} ],\n\t\t\t\tAssemblyAttributes = [  ],\n\t\t\t\tDataAttributes = [  ],\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedInitializationTest\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS0:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.ClassTupleDataSourceDrivenTests(System.Int32,System.String,System.Boolean).DataSource_TupleMethod(System.Int32,System.String,System.Boolean):0\",\n\t\t\t\tTestClass = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests),\n\t\t\t\tReturnType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests).GetMethod(\"DataSource_TupleMethod\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]).ReturnType,\n\t\t\t\tParameterTypeFullNames = [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)],\n\t\t\t\tTestName = \"DataSource_TupleMethod\",\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 24,\n\t\t\t\tException = exception,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n```\n\n----------------------------------------\n\nTITLE: TestContext Extension Methods for Test Reregistration\nDESCRIPTION: Extension method for TestContext that enables dynamic re-registration of tests with custom arguments. This experimental feature allows modifying test parameters at runtime for advanced testing scenarios.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic static class TestContextExtensions\n{\n    [System.Diagnostics.CodeAnalysis.Experimental(\"WIP\")]\n    [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode(\"Reflection\")]\n    public static System.Threading.Tasks.Task ReregisterTestWithArguments(this TUnit.Core.TestContext testContext, object?[]? methodArguments, System.Collections.Generic.Dictionary<string, object?>? objectBag = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Base Class for Playwright Browser Tests in C#\nDESCRIPTION: The `BrowserTest` class inherits from `PlaywrightTest` and provides setup and teardown logic specifically for managing a Playwright `IBrowser` instance during a test. It includes methods decorated with TUnit's `[Before]` and `[After]` attributes for automated execution and exposes the `Browser` property. It also provides a method to create a new browser context.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet2_0.Net4_7.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class BrowserTest : TUnit.Playwright.PlaywrightTest\n{\n    public BrowserTest() { }\n    public BrowserTest(Microsoft.Playwright.BrowserTypeLaunchOptions options) { }\n    public Microsoft.Playwright.IBrowser Browser { get; }\n    [TUnit.Core.Before(TUnit.Core.HookType.Test, \"<FilePath>\", 29)]\n    public System.Threading.Tasks.Task BrowserSetup() { }\n    [TUnit.Core.After(TUnit.Core.HookType.Test, \"<FilePath>\", 36)]\n    public System.Threading.Tasks.Task BrowserTearDown(TUnit.Core.TestContext testContext) { }\n    public System.Threading.Tasks.Task<Microsoft.Playwright.IBrowserContext> NewContext(Microsoft.Playwright.BrowserNewContextOptions options) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PlaywrightSkipAttribute Class in C#\nDESCRIPTION: This class extends SkipAttribute and provides functionality to skip Playwright tests based on specified targets.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class PlaywrightSkipAttribute : TUnit.Core.SkipAttribute\n{\n    public PlaywrightSkipAttribute(params TUnit.Playwright.PlaywrightSkipAttribute.Targets[] combinations) { }\n    public TUnit.Core.TestContext? TestContext { get; set; }\n    public override System.Threading.Tasks.Task<bool> ShouldSkip(TUnit.Core.BeforeTestContext context) { }\n    [System.Flags]\n    public enum Targets : short\n    {\n        Windows = 1,\n        Linux = 2,\n        OSX = 4,\n        Chromium = 8,\n        Firefox = 16,\n        Webkit = 32,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating ParallelGroupConstraint Class in C#\nDESCRIPTION: Implements IParallelConstraint and provides comparison functionality for parallel group constraints. It includes properties for group and order.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic class ParallelGroupConstraint : System.IComparable, System.IComparable<TUnit.Core.ParallelGroupConstraint>, System.IEquatable<TUnit.Core.ParallelGroupConstraint>, TUnit.Core.Interfaces.IParallelConstraint\n{\n    public ParallelGroupConstraint(string Group, int Order) { }\n    public string Group { get; init; }\n    public int Order { get; init; }\n    public int CompareTo(TUnit.Core.ParallelGroupConstraint? other) { }\n    public int CompareTo(object? obj) { }\n    public virtual bool Equals(TUnit.Core.ParallelGroupConstraint? other) { }\n    public override int GetHashCode() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StringMatcher for Regex and Wildcard Matching in C#\nDESCRIPTION: Defines an abstract class and derived classes for string matching using regular expressions and wildcards. It provides methods for creating matchers and ignoring case sensitivity.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_54\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class StringMatcher\n{\n    protected StringMatcher() { }\n    public static TUnit.Assertions.AssertConditions.StringMatcher.RegexMatch AsRegex(string pattern) { }\n    public static TUnit.Assertions.AssertConditions.StringMatcher.WildcardMatch AsWildcard(string pattern) { }\n    public static TUnit.Assertions.AssertConditions.StringMatcher op_Implicit(System.Text.RegularExpressions.Regex pattern) { }\n    public static TUnit.Assertions.AssertConditions.StringMatcher op_Implicit(string pattern) { }\n    public sealed class RegexMatch : TUnit.Assertions.AssertConditions.StringMatcher\n    {\n        public TUnit.Assertions.AssertConditions.StringMatcher.RegexMatch IgnoringCase(bool ignoreCase = true) { }\n        public override string ToString() { }\n    }\n    public sealed class WildcardMatch : TUnit.Assertions.AssertConditions.StringMatcher\n    {\n        public TUnit.Assertions.AssertConditions.StringMatcher.WildcardMatch IgnoringCase(bool ignoreCase = true) { }\n        public override string ToString() { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for GenericMethodTests.AggregateBy_HasExpectedOutput (C#)\nDESCRIPTION: This C# snippet dynamically generates test execution metadata for the `TUnit.TestProject.GenericMethodTests.AggregateBy_HasExpectedOutput` method. It unpacks method arguments provided via `methodData` (likely from a `MethodDataSourceAttribute`), creates a resettable factory for the `GenericMethodTests` class instance using `ResettableLazy`, and populates `TestMetadata` objects with details like test ID, arguments, and the test method invocation logic. Error handling is included to create `FailedTestMetadata` if data source initialization fails. It depends on TUnit core types (`TestMetadata`, `FailedTestMetadata`, `ResettableLazy`, `AsyncConvert`, `TestBuilderContext`) and external context variables like `sessionId`, `testBuilderContextAccessor`, `testInformation`, and `testMethodDataIndex`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GenericMethodTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar methodArgTuples = global::System.TupleExtensions.ToTuple<global::System.Collections.Generic.IEnumerable<string>, global::System.Func<string, string>, global::System.Func<string, string>, global::System.Func<string, string, string>, global::System.Collections.Generic.IEqualityComparer<string>, global::System.Collections.Generic.IEnumerable<global::System.Collections.Generic.KeyValuePair<string, string>>>(methodData);\n\t\t\t\t\t\tglobal::System.Collections.Generic.IEnumerable<string> methodArg = methodArgTuples.Item1;\n\t\t\t\t\t\tglobal::System.Func<string, string> methodArg1 = methodArgTuples.Item2;\n\t\t\t\t\t\tglobal::System.Func<string, string> methodArg2 = methodArgTuples.Item3;\n\t\t\t\t\t\tglobal::System.Func<string, string, string> methodArg3 = methodArgTuples.Item4;\n\t\t\t\t\t\tglobal::System.Collections.Generic.IEqualityComparer<string> methodArg4 = methodArgTuples.Item5;\n\t\t\t\t\t\tglobal::System.Collections.Generic.IEnumerable<global::System.Collections.Generic.KeyValuePair<string, string>> methodArg5 = methodArgTuples.Item6;\n\t\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.GenericMethodTests>(() => \n\t\t\t\t\t\tnew global::TUnit.TestProject.GenericMethodTests()\n\t\t\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.GenericMethodTests>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS1:{testMethodDataIndex}:TUnit.TestProject.GenericMethodTests.AggregateBy_HasExpectedOutput(System.Collections.Generic.IEnumerable<TSource>,TKey System.Func<TSource, TKey>(TSource),TAccumulate System.Func<TKey, TAccumulate>(TKey),TAccumulate System.Func<TAccumulate, TSource, TAccumulate>(TAccumulate, TSource),System.Collections.Generic.IEqualityComparer<TKey>,System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TAccumulate>>):0\",\n\t\t\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\t\t\tTestMethodArguments = [methodArg, methodArg1, methodArg2, methodArg3, methodArg4, methodArg5],\n\t\t\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.AggregateBy_HasExpectedOutput(methodArg, methodArg1, methodArg2, methodArg3, methodArg4, methodArg5)),\n\t\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\t\tTestLineNumber = 5,\n\t\t\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\t\t\ttestBuilderContext = new();\n\t\t\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (global::System.Exception exception)\n\t\t\t\t{\n\t\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.GenericMethodTests>\n\t\t\t\t\t{\n\t\t\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS1:{testMethodDataIndex}:TUnit.TestProject.GenericMethodTests.AggregateBy_HasExpectedOutput(System.Collections.Generic.IEnumerable<TSource>,TKey System.Func<TSource, TKey>(TSource),TAccumulate System.Func<TKey, TAccumulate>(TKey),TAccumulate System.Func<TAccumulate, TSource, TAccumulate>(TAccumulate, TSource),System.Collections.Generic.IEqualityComparer<TKey>,System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TAccumulate>>):0\",\n\t\t\t\t\t\tMethodName = $\"AggregateBy_HasExpectedOutput\",\n\t\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"GenericMethodTests.AggregateBy_HasExpectedOutput failed to initialize\", exception),\n\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\tTestLineNumber = 5,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn nodes;\n\t\t\t}\n\t\t}\n```\n\n----------------------------------------\n\nTITLE: PriorityQueue Implementation for Element Prioritization\nDESCRIPTION: A generic priority queue implementation that allows elements to be dequeued based on their assigned priority. Useful for ordered processing of test cases or results.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic class PriorityQueue<TElement, TPriority>\n    where TPriority : System.IComparable<TPriority>\n{\n    public PriorityQueue() { }\n    public int Count { get; }\n    public TElement Dequeue() { }\n    public void Enqueue(TElement value, TPriority priority) { }\n    public TElement Peek() { }\n    public bool TryDequeue([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out TElement? value, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out TPriority? priority) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Global Test ID Attribute at Assembly Level in TUnit (C#)\nDESCRIPTION: Demonstrates how to apply the custom `AssignTestIdentifiersAttribute` globally to all tests within an assembly. This is typically done in the `AssemblyInfo.cs` file using an assembly-level attribute declaration (`[assembly: ...]`), ensuring that the test discovery hook runs for every test.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/examples/instrumenting_global_test_ids.md#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: AssignTestIdentifiers]\n```\n\n----------------------------------------\n\nTITLE: Category Attribute for Test Classification in C#\nDESCRIPTION: Defines the CategoryAttribute used to categorize tests at assembly, class, or method level. Implements IEventReceiver and ITestDiscoveryEventReceiver for test discovery integration.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\npublic class CategoryAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver\n{\n    public CategoryAttribute(string category) { }\n    public string Category { get; }\n    public int Order { get; }\n    public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Test Metadata in C# TUnit\nDESCRIPTION: The snippet manages test metadata for data source-driven tests using TUnit framework in C#. It initializes a `TestBuilderContext`, sets up test metadata with parameters, attributes and factories, and handles exceptions by adding failed test metadata. Dependencies include TUnit.Core classes like `TestMetadata` and `TestBuilderContext`. Inputs include session IDs and method arguments; outputs are lists of test metadata.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.MethodDataSourceDrivenTests? classInstance = null;\nobject?[]? classInstanceArguments = null;\nclassInstanceArguments = [];\n\nint methodArg = global::TUnit.TestProject.MethodDataSourceDrivenTests.SomeMethod(\"Hello World!\", 6, true );\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.MethodDataSourceDrivenTests>(() => \nnew global::TUnit.TestProject.MethodDataSourceDrivenTests()\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenTests>\n{\n    TestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.MethodDataSourceDrivenTests.DataSource_Method4(int):0\",\n    TestClassArguments = [],\n    TestMethodArguments = [methodArg],\n    TestClassProperties = [],\n    CurrentRepeatAttempt = 0,\n    RepeatLimit = 0,\n    ResettableClassFactory = resettableClassFactory,\n    TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_Method4(methodArg)),\n    TestFilePath = @\"\",\n    TestLineNumber = 42,\n    TestMethod = testInformation,\n    TestBuilderContext = testBuilderContext,\n});\nresettableClassFactory = resettableClassFactoryDelegate();\ntestBuilderContext = new();\ntestBuilderContextAccessor.Current = testBuilderContext;\n\ncatch (global::System.Exception exception)\n{\n    nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenTests>\n    {\n        TestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.MethodDataSourceDrivenTests.DataSource_Method4(int):0\",\n        MethodName = $\"DataSource_Method4\",\n        Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"MethodDataSourceDrivenTests.DataSource_Method4 failed to initialize\", exception),\n        TestFilePath = @\"\",\n        TestLineNumber = 42,\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Matrix Testing Attributes in C#\nDESCRIPTION: Collection of attributes for matrix-based test data generation with support for exclusions, ranges, and method-sourced matrices. Enables combination testing by generating test cases from multiple parameter values.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Parameter)]\npublic class MatrixAttribute : TUnit.Core.TestDataAttribute\n{\n    protected MatrixAttribute() { }\n    public MatrixAttribute(params object?[]? objects) { }\n    public object?[]? Excluding { get; init; }\n    public virtual object?[] GetObjects(object? instance) { }\n}\n\n[System.AttributeUsage(System.AttributeTargets.Parameter)]\npublic class MatrixAttribute<T> : TUnit.Core.MatrixAttribute\n{\n    public MatrixAttribute(params T?[]? objects) { }\n}\n\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method)]\npublic sealed class MatrixDataSourceAttribute : TUnit.Core.NonTypedDataSourceGeneratorAttribute\n{\n    public MatrixDataSourceAttribute() { }\n    public override System.Collections.Generic.IEnumerable<System.Func<object?[]?>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata) { }\n}\n\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\npublic class MatrixExclusionAttribute : TUnit.Core.TUnitAttribute\n{\n    public MatrixExclusionAttribute(params object?[]? objects) { }\n    public object?[] Objects { get; }\n}\n\n[System.AttributeUsage(System.AttributeTargets.Parameter)]\npublic class MatrixInstanceMethodAttribute<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicMethods)]  TClass> : TUnit.Core.MatrixMethodAttribute<TClass>, TUnit.Core.IAccessesInstanceData\n    where TClass :  class\n{\n    public MatrixInstanceMethodAttribute(string methodName) { }\n}\n\n[System.AttributeUsage(System.AttributeTargets.Parameter)]\npublic class MatrixMethodAttribute<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicMethods)]  TClass> : TUnit.Core.MatrixAttribute\n    where TClass :  class\n{\n    public MatrixMethodAttribute(string methodName) { }\n    public override object?[] GetObjects(object? instance) { }\n}\n\n[System.AttributeUsage(System.AttributeTargets.Parameter)]\npublic class MatrixRangeAttribute<T> : TUnit.Core.MatrixAttribute<T>\n    where T : System.Numerics.INumber<T>\n{\n    public MatrixRangeAttribute(T min, T max) { }\n    public MatrixRangeAttribute(T min, T max, T step) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Test Initialization Failures with FailedTestMetadata in C#\nDESCRIPTION: This code handles exceptions during test initialization by adding a FailedTestMetadata object to the test collection. It captures the exception details and wraps them in a TestFailedInitializationException for reporting.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>\n\t{\n\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS0:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.ClassTupleDataSourceDrivenTests(int,string,bool).DataSource_TupleMethod(int,string,bool):0\",\n\t\tMethodName = $\"DataSource_TupleMethod\",\n\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ClassTupleDataSourceDrivenTests.DataSource_TupleMethod failed to initialize\", exception),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 24,\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ULong Test Source Generator in C#\nDESCRIPTION: Source-generated implementation for handling unsigned long test cases with constant arguments. Includes test metadata generation and exception handling.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ConstantArgumentsTests.Test.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class ConstantArgumentsTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new ConstantArgumentsTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n```\n\n----------------------------------------\n\nTITLE: String Assertion Extensions in TUnit\nDESCRIPTION: Extension methods for string assertions to check conditions like IsEmpty, IsEqualTo, IsNullOrEmpty, and IsNullOrWhitespace.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_154\n\nLANGUAGE: C#\nCODE:\n```\npublic static class StringIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> IsEmpty(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.StringEqualToAssertionBuilderWrapper IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null) { }\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.StringEqualToAssertionBuilderWrapper IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"stringComparison\")] string doNotPopulateThisValue2 = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> IsNullOrEmpty(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> IsNullOrWhitespace(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Test Context and Instance for StringArgumentTests in C#\nDESCRIPTION: This code creates the test builder context and class instance for test execution. It initializes a context accessor, prepares for the test class instantiation, and sets up arguments with special string handling.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/StringArgumentTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.StringArgumentTests? classInstance = null;\nobject?[]? classInstanceArguments = null;\nclassInstanceArguments = [];\n\nstring methodArg = @\"\\t\";\n\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.StringArgumentTests>(() => \nnew global::TUnit.TestProject.StringArgumentTests()\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n```\n\n----------------------------------------\n\nTITLE: JSON Model Classes for Test Data Serialization\nDESCRIPTION: Defines a set of record-like classes that represent the serializable structure of test execution data, including exceptions, assemblies, classes, tests, and results.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ExceptionJson : System.IEquatable<TUnit.Engine.Json.ExceptionJson>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public ExceptionJson() { }\n    public TUnit.Engine.Json.ExceptionJson? InnerException { get; init; }\n    public string Message { get; init; }\n    public string? Stacktrace { get; init; }\n    public string? Type { get; init; }\n}\npublic class TestAssemblyJson : System.IEquatable<TUnit.Engine.Json.TestAssemblyJson>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public TestAssemblyJson() { }\n    public string? AssemblyName { get; init; }\n    public TUnit.Engine.Json.TestClassJson[] Classes { get; init; }\n}\npublic class TestClassJson : System.IEquatable<TUnit.Engine.Json.TestClassJson>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public TestClassJson() { }\n    public TUnit.Engine.Json.TestJson[] Tests { get; init; }\n    public string? Type { get; init; }\n}\npublic class TestJson : System.IEquatable<TUnit.Engine.Json.TestJson>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public TestJson() { }\n    public System.Collections.Generic.IReadOnlyList<string> Categories { get; init; }\n    public string? ClassType { get; init; }\n    public System.Collections.Generic.IReadOnlyDictionary<string, string> CustomProperties { get; init; }\n    public string DisplayName { get; set; }\n    public System.Collections.Generic.Dictionary<string, object?> ObjectBag { get; init; }\n    public TUnit.Engine.Json.TestResultJson? Result { get; set; }\n    public int RetryLimit { get; init; }\n    public string? ReturnType { get; init; }\n    public object?[]? TestClassArguments { get; init; }\n    public string?[]? TestClassParameterTypes { get; init; }\n    public string TestFilePath { get; init; }\n    public string TestId { get; init; }\n    public int TestLineNumber { get; init; }\n    public object?[]? TestMethodArguments { get; init; }\n    public string?[]? TestMethodParameterTypes { get; init; }\n    public string TestName { get; init; }\n    public System.TimeSpan? Timeout { get; init; }\n}\npublic class TestResultJson : System.IEquatable<TUnit.Engine.Json.TestResultJson>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public TestResultJson() { }\n    public string ComputerName { get; init; }\n    public System.TimeSpan? Duration { get; init; }\n    public System.DateTimeOffset? End { get; init; }\n    public TUnit.Engine.Json.ExceptionJson? Exception { get; init; }\n    public string? Output { get; init; }\n    public System.DateTimeOffset? Start { get; init; }\n    public TUnit.Core.Enums.Status Status { get; init; }\n}\npublic class TestSessionJson : System.IEquatable<TUnit.Engine.Json.TestSessionJson>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public TestSessionJson() { }\n    public TUnit.Engine.Json.TestAssemblyJson[] Assemblies { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating TUnit Test Metadata from 'FuncT' Source in C#\nDESCRIPTION: This private helper method generates `TestMetadata` for tests associated with the `MyTest` method, specifically using the data source method named \"FuncT\". It retrieves test arguments by invoking the function returned by `TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests.FuncT()()`. Similar to `Tests0`, it sets up test information, handles class instantiation via `ResettableLazy`, defines the test execution logic, and includes error handling for initialization failures, creating `FailedTestMetadata` if necessary. The `sessionId` is used in the lazy factory.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenWithCancellationTokenTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests1(string sessionId)\n\t\t{\n\t\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\t\tvar classDataIndex = 0;\n\t\t\tvar testMethodDataIndex = 0;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests),\n\t\t\t\t\tName = \"MyTest\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(void),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"T\"),\n\t\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"FuncT\"),\n\t\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"EnumerableT\"),\n\t\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"EnumerableFuncT\"),\n\t\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"ArrayT\"),\n\t\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"ArrayFuncT\")\n\t\t\t\t\t],\n\t\t\t\t\tParameters = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"MethodDataSourceDrivenWithCancellationTokenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"MethodDataSourceDrivenWithCancellationTokenTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"MethodDataSourceDrivenWithCancellationTokenTests\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\t\tAttributes = \n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tnew global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute(\"Usage\", \"TUnit0046:Return a `Func<T>` rather than a `<T>`\")\n\t\t\t\t\t\t],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n};\n\n\t\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\t\tglobal::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests? classInstance = null;\n\t\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\t\tint methodArg = global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests.FuncT()();\n\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests>(() => \n\t\t\t\t\tnew global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests()\n\t\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests>\n\t\t\t\t\t{\n\t\t\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests.MyTest(int,System.Threading.CancellationToken):0\",\n\t\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.MyTest(methodArg, cancellationToken)),\n\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\tTestLineNumber = 10,\n\t\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t\t});\n\t\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\t\ttestBuilderContext = new();\n\t\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t\t}\n\t\t\t\tcatch (global::System.Exception exception)\n\t\t\t\t{\n\t\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests>\n\t\t\t\t\t{\n\n```\n\n----------------------------------------\n\nTITLE: Generating TUnit Test Metadata with Class Data Source in C#\nDESCRIPTION: This C# code defines a partial class `MultipleClassDataSourceDrivenTests` that implements `TUnit.Core.Interfaces.SourceGenerator.ITestSource`. It uses a module initializer (`Initialise`) to register itself with `TUnit.Core.SourceRegistrar`. The `CollectTests` method delegates to `Tests0`, which constructs `TestMetadata` for the `Test2` method within `TUnit.TestProject.MultipleClassDataSourceDrivenTests`. It leverages `TUnit.Core.ClassDataSourceAttribute` to generate constructor arguments (Inject1 to Inject5), creates resettable factories for test class instances, and builds `TestMetadata` objects containing test IDs, arguments, factories, and source location. Error handling is included to create `FailedTestMetadata` if initialization fails.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MultipleClassDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class MultipleClassDataSourceDrivenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new MultipleClassDataSourceDrivenTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.MultipleClassDataSourceDrivenTests),\n\t\t\t\tName = \"Test2\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute()\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.MultipleClassDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.MultipleClassDataSourceDrivenTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"MultipleClassDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"MultipleClassDataSourceDrivenTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"MultipleClassDataSourceDrivenTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject1>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"inject1\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject2>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"inject2\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject3>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"inject3\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject4>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"inject4\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject5>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"inject5\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.MultipleClassDataSourceDrivenTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tvar classArgDataGeneratorMetadata = new DataGeneratorMetadata\n\t\t\t\t{\n\t\t\t\t\tType = global::TUnit.Core.Enums.DataGeneratorType.ClassParameters,\n\t\t\t\t\tTestBuilderContext = testBuilderContextAccessor,\n\t\t\t\t\tTestInformation = testInformation,\n\t\t\t\t\tMembersToGenerate = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject1>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"inject1\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject2>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"inject2\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject3>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"inject3\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject4>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"inject4\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject5>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"inject5\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tTestSessionId = sessionId,\n\t\t\t\t\tTestClassInstance = classInstance,\n\t\t\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t\t\t};\n\t\t\t\tvar classDataAttribute = new global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject1, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject2, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject3, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject4, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject5>()\n\t\t\t\t{\n\t\t\t\t\tShared = [global::TUnit.Core.SharedType.None, global::TUnit.Core.SharedType.None, global::TUnit.Core.SharedType.None, global::TUnit.Core.SharedType.None, global::TUnit.Core.SharedType.None],\n};\n\n\t\t\t\t\ttestBuilderContext.DataAttributes.Add(classDataAttribute);\n\n\t\t\t\t\tvar classArgGeneratedDataArray = classDataAttribute.GenerateDataSources(classArgDataGeneratorMetadata);\n\n\t\t\t\t\tforeach (var classArgGeneratedDataAccessor in classArgGeneratedDataArray)\n\t\t\t\t\t{\n\t\t\t\t\t\tclassDataIndex++;\n\t\t\t\t\t\tvar classArgGeneratedData = classArgGeneratedDataAccessor();\n\t\t\t\t\t\tglobal::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject1 classArg = classArgGeneratedData.Item1;\n\t\t\t\t\t\tglobal::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject2 classArg1 = classArgGeneratedData.Item2;\n\t\t\t\t\t\tglobal::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject3 classArg2 = classArgGeneratedData.Item3;\n\t\t\t\t\t\tglobal::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject4 classArg3 = classArgGeneratedData.Item4;\n\t\t\t\t\t\tglobal::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject5 classArg4 = classArgGeneratedData.Item5;\n\n\t\t\t\t\t\tclassInstanceArguments = [classArg, classArg1, classArg2, classArg3, classArg4];\n\n\t\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests>(() => \n\t\t\t\t\t\tnew global::TUnit.TestProject.MultipleClassDataSourceDrivenTests(classArg, classArg1, classArg2, classArg3, classArg4)\n\t\t\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject1, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject2, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject3, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject4, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject5>:{classDataIndex}:CL-GAC0:TUnit.TestProject.MultipleClassDataSourceDrivenTests(TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject1,TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject2,TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject3,TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject4,TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject5).Test2:0\",\n\t\t\t\t\t\t\tTestClassArguments = [classArg, classArg1, classArg2, classArg3, classArg4],\n\t\t\t\t\t\t\tTestMethodArguments = [],\n\t\t\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Test2()),\n\t\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\t\tTestLineNumber = 20,\n\t\t\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\t\t\ttestBuilderContext = new();\n\t\t\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (global::System.Exception exception)\n\t\t\t\t{\n\t\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests>\n\t\t\t\t\t{\n\t\t\t\t\t\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject1, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject2, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject3, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject4, global::TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject5>:{classDataIndex}:CL-GAC0:TUnit.TestProject.MultipleClassDataSourceDrivenTests(TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject1,TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject2,TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject3,TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject4,TUnit.TestProject.MultipleClassDataSourceDrivenTests.Inject5).Test2:0\",\n\t\t\t\t\t\tMethodName = $\"Test2\",\n\t\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"MultipleClassDataSourceDrivenTests.Test2 failed to initialize\", exception),\n\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\tTestLineNumber = 20,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn nodes;\n\t\t\t}\n\t\t}\n\n```\n\n----------------------------------------\n\nTITLE: Exception Message Assertion Extensions\nDESCRIPTION: Specialized assertion methods for validating exception messages with various string comparison options. Includes methods for exact matching, contains, starts with, and pattern matching.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_70\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> HasMessageEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"stringComparison\")] string doNotPopulateThisValue2 = null)\n            where TActual : System.Exception { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Before Assembly Hook Method in C#\nDESCRIPTION: Defines the BeforeAssemblyHookMethod class which executes before an assembly is processed. It inherits from StaticHookMethod and implements IEquatable.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\npublic class BeforeAssemblyHookMethod : TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.AssemblyHookContext>, System.IEquatable<TUnit.Core.Hooks.BeforeAssemblyHookMethod>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public BeforeAssemblyHookMethod() { }\n    public override System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.AssemblyHookContext context, System.Threading.CancellationToken cancellationToken) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Test Initialization Failures in C#\nDESCRIPTION: Error handling for test initialization that adds a FailedTestMetadata node when exceptions occur. This captures the error details and maintains test traceability even when setup fails.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/TimeoutCancellationTokenTests.Test.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.TimeoutCancellationTokenTests>\n\t{\n\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS0:global::TUnit.Core.MatrixDataSourceAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.TimeoutCancellationTokenTests(int).MatrixTest(int,System.Threading.CancellationToken):0\",\n\t\tMethodName = $\"MatrixTest\",\n\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"TimeoutCancellationTokenTests.MatrixTest failed to initialize\", exception),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 54,\n\t});\n}\nreturn nodes;\n```\n\n----------------------------------------\n\nTITLE: Implementing UnknownAssertionGroupInvoker class in C#\nDESCRIPTION: This class implements an invoker for unknown assertion groups with methods to combine assertions using 'And' and 'Or' logical operators. It's a generic class that works with any type and assertion builder.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_82\n\nLANGUAGE: C#\nCODE:\n```\n    where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder\n    {\n        public UnknownAssertionGroupInvoker(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group) { }\n        public TUnit.Assertions.AssertionBuilders.Groups.AndAssertionGroupInvoker<TActual, TAssertionBuilder> And(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> otherGroup) { }\n        public TUnit.Assertions.AssertionBuilders.Groups.OrAssertionGroupInvoker<TActual, TAssertionBuilder> Or(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> otherGroup) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Test Metadata Generation with Error Handling\nDESCRIPTION: Private method that generates test metadata for individual test cases, including test initialization and error handling logic. Creates TestMetadata objects with test context and execution parameters.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ArgumentWithImplicitConverterTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\t// ... test initialization code ...\n\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.ArgumentWithImplicitConverterTests>\n\t\t{\n\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.ArgumentWithImplicitConverterTests.Explicit(TUnit.TestProject.ExplicitInteger):0\",\n\t\t\t// ... other metadata properties ...\n\t\t});\n\t}\n\tcatch (global::System.Exception exception)\n\t{\n\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ArgumentWithImplicitConverterTests>\n\t\t{\n\t\t\t// ... error metadata ...\n\t\t});\n\t}\n\treturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Test Metadata Generation Method Implementation (C#)\nDESCRIPTION: Implementation of test metadata generation including parameter information, test builder context setup, and test execution configuration. Handles matrix-based test data generation and test instance creation.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MatrixTests.Test.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n    global::System.Collections.Generic.List<TestMetadata> nodes = [];\n    var classDataIndex = 0;\n    var testMethodDataIndex = 0;\n    try\n    {\n        var testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n        {\n            Type = typeof(global::TUnit.TestProject.MatrixTests),\n            Name = \"Method1\",\n            GenericTypeCount = 0,\n            ReturnType = typeof(global::System.Threading.Tasks.Task),\n            Attributes = \n            [\n                new global::TUnit.Core.TestAttribute(),\n                new global::TUnit.Core.MatrixDataSourceAttribute()\n            ],\n            Parameters = \n            [\n                new global::TUnit.Core.SourceGeneratedParameterInformation<int>\n                {\n                    Name = \"item\",\n                    Attributes = \n                    [\n                        new global::TUnit.Core.MatrixMethodAttribute<global::TUnit.TestProject.MatrixTests>(\"EnumerableMethod\")\n                    ],\n                },\n            ]\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enumerating Hook Types for Test Lifecycle in C#\nDESCRIPTION: Enumeration of available hook types, defining the scope at which hooks can operate. Includes test, class, assembly, test session, and test discovery levels.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic enum HookType\n{\n    Test = 0,\n    Class = 1,\n    Assembly = 2,\n    TestSession = 3,\n    TestDiscovery = 4,\n}\n```\n\n----------------------------------------\n\nTITLE: Auto-generating TUnit Test Source for MatrixTests.MatrixTest_Enum in C#\nDESCRIPTION: This auto-generated C# code implements the `ITestSource` interface for the `MatrixTests` class within the TUnit framework. It registers the source generator, defines the `CollectTests` method to gather metadata for the `MatrixTest_Enum` test method, specifying parameters (including `TestEnum`) with `MatrixAttribute`. It uses `MatrixDataSourceAttribute` to generate test cases, casts arguments, creates `TestMetadata` for each case, and includes error handling.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MatrixTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class MatrixTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new MatrixTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.MatrixTests),\n\t\t\t\tName = \"MatrixTest_Enum\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.MatrixDataSourceAttribute()\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"i\",\n\t\t\t\t\t\tAttributes = \n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tnew global::TUnit.Core.MatrixAttribute(1, 2)\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.TestEnum>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"testEnum\",\n\t\t\t\t\t\tAttributes = \n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tnew global::TUnit.Core.MatrixAttribute(-1, global::TUnit.TestProject.TestEnum.One)\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.TestEnum?>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"testEnum2\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.MatrixTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.MatrixTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"MatrixTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"MatrixTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"MatrixTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.MatrixTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tvar methodArgDataGeneratorMetadata = new DataGeneratorMetadata\n\t\t\t\t{\n\t\t\t\t\tType = global::TUnit.Core.Enums.DataGeneratorType.TestParameters,\n\t\t\t\t\tTestBuilderContext = testBuilderContextAccessor,\n\t\t\t\t\tTestInformation = testInformation,\n\t\t\t\t\tMembersToGenerate = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"i\",\n\t\t\t\t\t\t\tAttributes = \n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew global::TUnit.Core.MatrixAttribute(1, 2)\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.TestEnum>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"testEnum\",\n\t\t\t\t\t\t\tAttributes = \n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew global::TUnit.Core.MatrixAttribute(-1, global::TUnit.TestProject.TestEnum.One)\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.TestEnum?>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"testEnum2\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tTestSessionId = sessionId,\n\t\t\t\t\tTestClassInstance = classInstance,\n\t\t\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t\t\t};\n\t\t\t\tvar methodDataAttribute = new global::TUnit.Core.MatrixDataSourceAttribute();\n\n\t\t\t\ttestBuilderContext.DataAttributes.Add(methodDataAttribute);\n\n\t\t\t\tvar methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\n\n\t\t\t\tforeach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\n\t\t\t\t{\n\t\t\t\t\ttestMethodDataIndex++;\n\t\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\t\tvar methodArgGeneratedData = methodArgGeneratedDataAccessor();\n\t\t\t\t\tint methodArg = global::TUnit.Core.Helpers.CastHelper.Cast<int>(methodArgGeneratedData[0]);\n\t\t\t\t\tglobal::TUnit.TestProject.TestEnum methodArg1 = global::TUnit.Core.Helpers.CastHelper.Cast<global::TUnit.TestProject.TestEnum>(methodArgGeneratedData[1]);\n\t\t\t\t\tglobal::TUnit.TestProject.TestEnum? methodArg2 = global::TUnit.Core.Helpers.CastHelper.Cast<global::TUnit.TestProject.TestEnum?>(methodArgGeneratedData[2]);\n\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.MatrixTests>(() => \n\t\t\t\t\tnew global::TUnit.TestProject.MatrixTests()\n\t\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.MatrixTests>\n\t\t\t\t\t{\n\t\t\t\t\t\tTestId = $\"global::TUnit.Core.MatrixDataSourceAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.MatrixTests.MatrixTest_Enum(int,TUnit.TestProject.TestEnum,TUnit.TestProject.TestEnum?):0\",\n\t\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\t\tTestMethodArguments = [methodArg, methodArg1, methodArg2],\n\t\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.MatrixTest_Enum(methodArg, methodArg1, methodArg2)),\n\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\tTestLineNumber = 31,\n\t\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t\t});\n\t\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\t\ttestBuilderContext = new();\n\t\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.MatrixTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.MatrixDataSourceAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.MatrixTests.MatrixTest_Enum(int,TUnit.TestProject.TestEnum,TUnit.TestProject.TestEnum?):0\",\n\t\t\t\t\tMethodName = $\"MatrixTest_Enum\",\n```\n\n----------------------------------------\n\nTITLE: Excluding Matrix Test Cases with TUnit in C#\nDESCRIPTION: Shows how to use `[MatrixExclusion]` attribute in TUnit to exclude specific cases from the test matrix. This approach is useful for ignoring redundant test scenarios, maintaining test clarity without additional logic. It requires TUnit framework and sample includes exclusions for specified `(value1, value2)` pairs.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/matrix-tests.md#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nusing TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Assertions.Extensions.Is;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    [MatrixDataSource]\n    [MatrixExclusion(1, 1)]\n    [MatrixExclusion(2, 2)]\n    [MatrixExclusion(3, 3)]\n    public async Task MyTest(\n        [MatrixRange<int>(1, 3)] int value1,\n        [MatrixRange<int>(1, 3)] int value2\n        )\n    {\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for DataSource_TupleMethod in C#\nDESCRIPTION: This method generates test metadata for the DataSource_TupleMethod, handling tuple data sources for both class constructor and method parameters. It creates a resettable class factory and sets up the test execution environment.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=NamedTupleMethod_testMethodName=NamedTupleMethod.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testClassType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests);\n\t\tvar methodInfo = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests).GetMethod(\"DataSource_TupleMethod\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]);\n\n\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\tvar classArgTuples = global::System.TupleExtensions.ToTuple<global::System.Int32, global::System.String, global::System.Boolean>(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()());\n\t\tglobal::System.Int32 classArg = classArgTuples.Item1;\n\t\tglobal::System.String classArg1 = classArgTuples.Item2;\n\t\tglobal::System.Boolean classArg2 = classArgTuples.Item3;\n\t\t(global::System.Int32, global::System.String, global::System.Boolean) propertyArg = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()();\n\t\t(global::System.Int32 Number, global::System.String Word, global::System.Boolean Flag) propertyArg1 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()();\n\t\t(global::System.Int32, global::System.String, global::System.Boolean) propertyArg2 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()();\n\t\t(global::System.Int32 Number, global::System.String Word, global::System.Boolean Flag) propertyArg3 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()();\n\n\t\tvar methodArgTuples = global::System.TupleExtensions.ToTuple<global::System.Int32, global::System.String, global::System.Boolean>(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()());\n\t\tglobal::System.Int32 methodArg = methodArgTuples.Item1;\n\t\tglobal::System.String methodArg1 = methodArgTuples.Item2;\n\t\tglobal::System.Boolean methodArg2 = methodArgTuples.Item3;\n\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>(() => \n\t\tnew global::TUnit.TestProject.ClassTupleDataSourceDrivenTests(classArg, classArg1, classArg2)\n\t\t{\n\t\t\tProperty1 = propertyArg,\n\t\t\tProperty2 = propertyArg1,\n\t\t\tProperty3 = propertyArg2,\n\t\t\tProperty4 = propertyArg3,\n\t\t}\n\t\t, sessionId, testBuilderContext);\n\n\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>\n\t\t{\n\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS0:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.ClassTupleDataSourceDrivenTests(System.Int32,System.String,System.Boolean).DataSource_TupleMethod(System.Int32,System.String,System.Boolean):0\",\n\t\t\tTestClassArguments = [classArg, classArg1, classArg2],\n\t\t\tTestMethodArguments = [methodArg, methodArg1, methodArg2],\n\t\t\tTestClassProperties = [propertyArg, propertyArg1, propertyArg2, propertyArg3],\n\t\t\tCurrentRepeatAttempt = 0,\n\t\t\tRepeatLimit = 0,\n\t\t\tMethodInfo = methodInfo,\n\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_TupleMethod(methodArg, methodArg1, methodArg2)),\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 24,\n\t\t\tTestAttributes = [ new global::TUnit.Core.TestAttribute()\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n{\n    \n} ],\n\t\t\tClassAttributes = [ new global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n{\n    \n} ],\n\t\t\tAssemblyAttributes = [  ],\n\t\t\tDataAttributes = [  ],\n\t\t\tTestBuilderContext = testBuilderContext,\n\t\t});\n\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\ttestBuilderContext = new();\n\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t}\n\tcatch (global::System.Exception exception)\n\t{\n\t\tnodes.Add(new FailedInitializationTest\n\t\t{\n\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS0:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.ClassTupleDataSourceDrivenTests(System.Int32,System.String,System.Boolean).DataSource_TupleMethod(System.Int32,System.String,System.Boolean):0\",\n\t\t\tTestClass = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests),\n\t\t\tReturnType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests).GetMethod(\"DataSource_TupleMethod\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]).ReturnType,\n\t\t\tParameterTypeFullNames = [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)],\n\t\t\tTestName = \"DataSource_TupleMethod\",\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 24,\n\t\t\tException = exception,\n\t\t});\n\t}\n\treturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Registering BasicTest Method with Timeout in TUnit\nDESCRIPTION: Auto-generated code that handles the registration of the BasicTest method from TimeoutCancellationTokenTests with timeout configuration. It includes test metadata with a 5000ms timeout and 'Blah' category attribute for the test method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/TimeoutCancellationTokenTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.TimeoutCancellationTokenTests),\n\tName = \"BasicTest\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute(),\n\t\tnew global::TUnit.Core.TimeoutAttribute(5_000),\n\t\tnew global::TUnit.Core.CategoryAttribute(\"Blah\")\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t{\n\t\t\tName = \"cancellationToken\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.TimeoutCancellationTokenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t{\n\t\tType = typeof(global::TUnit.TestProject.TimeoutCancellationTokenTests),\n\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"TimeoutCancellationTokenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t{\n\t\t\tName = \"TimeoutCancellationTokenTests\",\n\t\t\tAttributes = [],\n\t\t}),\n\t\tName = \"TimeoutCancellationTokenTests\",\n\t\tNamespace = \"TUnit.TestProject\",\n\t\tAttributes = \n\t\t[\n\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"DataSource\"),\n\t\t\tnew global::TUnit.Core.CategoryAttribute(\"Timeout Cancellation Token Tests\")\n\t\t],\n\t\tParameters = \n\t\t[\n\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t{\n\t\t\t\tName = \"value\",\n\t\t\t\tAttributes = [],\n\t\t\t},\n\t\t],\n\t\tProperties = [],\n\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Base Class for Worker-Aware Tests in C#\nDESCRIPTION: The `WorkerAwareTest` class implements TUnit event receiver interfaces (`IEventReceiver`, `ITestRegisteredEventReceiver`) to manage test execution within TUnit workers. It provides properties like `WorkerIndex`, methods for registering worker-specific services (`RegisterService`), and `[Before]` / `[After]` hooks (`WorkerSetup`, `WorkerTeardown`) for per-test setup and teardown within the worker context. It also includes logic related to parallel limiting.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet2_0.Net4_7.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\npublic class WorkerAwareTest : TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestRegisteredEventReceiver\n{\n    public WorkerAwareTest() { }\n    public virtual bool UseDefaultParallelLimiter { get; }\n    public int WorkerIndex { get; }\n    public System.Threading.Tasks.ValueTask OnTestRegistered(TUnit.Core.TestRegisteredContext context) { }\n    public System.Threading.Tasks.Task<T> RegisterService<T>(string name, System.Func<System.Threading.Tasks.Task<T>> factory)\n        where T :  class, TUnit.Playwright.IWorkerService { }\n    protected bool TestOk(TUnit.Core.TestContext testContext) { }\n    [TUnit.Core.Before(TUnit.Core.HookType.Test, \"<FilePath>\", 34)]\n    public void WorkerSetup() { }\n    [TUnit.Core.After(TUnit.Core.HookType.Test, \"<FilePath>\", 45)]\n    public System.Threading.Tasks.Task WorkerTeardown(TUnit.Core.TestContext testContext) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Reference Comparison Assertions in C#\nDESCRIPTION: Classes for reference comparison including SameReference and NotSameReference conditions. These classes check if two objects refer to the same instance in memory.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\npublic class SameReferenceExpectedValueAssertCondition<TActual, TExpected> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TExpected>\n{\n    public SameReferenceExpectedValueAssertCondition(TExpected expected) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TExpected? expectedValue) { }\n}\n```\n\n----------------------------------------\n\nTITLE: ResettableLazy Implementation in C#\nDESCRIPTION: Generic implementation of a resettable lazy loading pattern with async disposal support. Includes specialized version for class constructors and value management.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic class ResettableLazy<T> : System.IAsyncDisposable\n    where T : class\n{\n    protected readonly string SessionId;\n    protected System.Func<T> _factory;\n    public ResettableLazy(System.Func<T> factory, string sessionId, TUnit.Core.TestBuilderContext testBuilderContext) { }\n    public T Value { get; }\n    public System.Threading.Tasks.ValueTask DisposeAsync() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NotNullExpectedValueAssertCondition for TUnit Null Checks (C#)\nDESCRIPTION: Defines the `NotNullExpectedValueAssertCondition` class for reference types (`class?`). It inherits from `ConvertToAssertCondition` and is used to assert that a nullable reference type value is not null, converting it to its non-nullable counterpart if the assertion passes.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\n    public class NotNullExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.ConvertToAssertCondition<TActual?, TActual>\n        where TActual :  class?\n    {\n        public NotNullExpectedValueAssertCondition() { }\n        public override System.Threading.Tasks.ValueTask<System.ValueTuple<TUnit.Assertions.AssertConditions.AssertionResult, TActual?>> ConvertValue(TActual? value) { }\n        protected override string GetExpectation() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Registering and Collecting Class Hooks for CleanupTests in C#\nDESCRIPTION: Auto-generated partial class `Hooks_CleanupTests` implementing `IClassHookSource` for TUnit. Registers itself via `ModuleInitializer` and `SourceRegistrar.RegisterClassHookSource`, and defines methods for collecting class-level hooks. The `CollectAfterClassHooks` method is defined to return a `StaticHookMethod` representing the `AfterAllCleanUp` method from the `TUnit.TestProject.AfterTests.CleanupTests` class, designed to run after all tests in the class. (Note: Snippet is incomplete in the provided input).\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterAllTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_CleanupTests : global::TUnit.Core.Interfaces.SourceGenerator.IClassHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_CleanupTests();\n\t\tSourceRegistrar.RegisterClassHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.AfterClassHookMethod\n\t\t\t{\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.CleanupTests),\n\t\t\t\t\tName = \"AfterAllCleanUp\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Hooks for GlobalBase3 in C#\nDESCRIPTION: Source-generated partial class implementing ITestHookSource interface for GlobalBase3. Similar structure to previous classes but implements AfterEach3 hook.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticAfterEachTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_GlobalBase3 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_GlobalBase3();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\t// ... rest of implementation\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Exceptions in Test Initialization for TUnit in C#\nDESCRIPTION: This snippet catches exceptions during test initialization and creates a FailedTestMetadata object. It ensures that initialization failures are properly recorded and reported in the test results.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ClassDataSourceDrivenTests>\n\t{\n\t\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.InitializableClass, global::TUnit.TestProject.InitializableClass, global::TUnit.TestProject.InitializableClass, global::TUnit.TestProject.InitializableClass, global::TUnit.TestProject.InitializableClass>:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.ClassDataSourceDrivenTests.IsInitialized_With_5_ClassDataSources(TUnit.TestProject.InitializableClass,TUnit.TestProject.InitializableClass,TUnit.TestProject.InitializableClass,TUnit.TestProject.InitializableClass,TUnit.TestProject.InitializableClass):0\",\n\t\tMethodName = $\"IsInitialized_With_5_ClassDataSources\",\n\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ClassDataSourceDrivenTests.IsInitialized_With_5_ClassDataSources failed to initialize\", exception),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 58,\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Logging Extensions in C#\nDESCRIPTION: Defines extension methods for ILogger interface to provide convenient logging methods for different log levels, including both synchronous and asynchronous versions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_65\n\nLANGUAGE: C#\nCODE:\n```\npublic static class LoggingExtensions\n{\n    public static void LogCritical(this TUnit.Core.Logging.ILogger logger, string message) { }\n    public static System.Threading.Tasks.ValueTask LogCriticalAsync(this TUnit.Core.Logging.ILogger logger, string message) { }\n    public static void LogDebug(this TUnit.Core.Logging.ILogger logger, string message) { }\n    public static System.Threading.Tasks.ValueTask LogDebugAsync(this TUnit.Core.Logging.ILogger logger, string message) { }\n    public static void LogError(this TUnit.Core.Logging.ILogger logger, System.Exception ex) { }\n    public static void LogError(this TUnit.Core.Logging.ILogger logger, string message) { }\n    public static void LogError(this TUnit.Core.Logging.ILogger logger, string message, System.Exception ex) { }\n    public static System.Threading.Tasks.ValueTask LogErrorAsync(this TUnit.Core.Logging.ILogger logger, System.Exception ex) { }\n    public static System.Threading.Tasks.ValueTask LogErrorAsync(this TUnit.Core.Logging.ILogger logger, string message) { }\n    public static System.Threading.Tasks.ValueTask LogErrorAsync(this TUnit.Core.Logging.ILogger logger, string message, System.Exception ex) { }\n    public static void LogInformation(this TUnit.Core.Logging.ILogger logger, string message) { }\n    public static System.Threading.Tasks.ValueTask LogInformationAsync(this TUnit.Core.Logging.ILogger logger, string message) { }\n    public static void LogTrace(this TUnit.Core.Logging.ILogger logger, string message) { }\n    public static System.Threading.Tasks.ValueTask LogTraceAsync(this TUnit.Core.Logging.ILogger logger, string message) { }\n    public static void LogWarning(this TUnit.Core.Logging.ILogger logger, string message) { }\n    public static System.Threading.Tasks.ValueTask LogWarningAsync(this TUnit.Core.Logging.ILogger logger, string message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Range Comparison for Comparable Values in C#\nDESCRIPTION: Classes for asserting that a comparable value is between or not between specified minimum and maximum values. They support both inclusive and exclusive range boundaries.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\npublic class BetweenAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n    where TActual : System.IComparable<TActual>\n{\n    public BetweenAssertCondition(TActual minimum, TActual maximum) { }\n    public void Exclusive() { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n    public void Inclusive() { }\n}\n\npublic class NotBetweenAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n    where TActual : System.IComparable<TActual>\n{\n    public NotBetweenAssertCondition(TActual minimum, TActual maximum) { }\n    public void Exclusive() { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n    public void Inclusive() { }\n}\n```\n\n----------------------------------------\n\nTITLE: TestSessionJson Class for Test Session Serialization\nDESCRIPTION: JSON model class representing an entire test session with its contained test assemblies. This provides a top-level serialization format for complete test sessions in the TUnit framework.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class TestSessionJson : System.IEquatable<TUnit.Engine.Json.TestSessionJson>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public TestSessionJson() { }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Engine.Json.TestAssemblyJson[] Assemblies { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: TimeSpan Formatting Utility in TUnit\nDESCRIPTION: A utility for formatting TimeSpan values in a human-readable format.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_163\n\nLANGUAGE: C#\nCODE:\n```\npublic static class TimeSpanFormatter\n{\n    public static string PrettyPrint(this System.TimeSpan timeSpan) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Throws Within Assertion Condition in C#\nDESCRIPTION: This class implements an assertion condition to check if an exception is thrown within a specified time span. It extends the DelegateAssertCondition class and includes a WaitFor property to specify the timeout.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_122\n\nLANGUAGE: C#\nCODE:\n```\npublic class ThrowsWithinAssertCondition<TActual, TExpectedException> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<TActual, TExpectedException>\n    where TExpectedException : System.Exception\n{\n    public ThrowsWithinAssertCondition(System.TimeSpan timeSpan) { }\n    public override System.TimeSpan? WaitFor { get; }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating TestMetadata Object for BooleanString Method in C#\nDESCRIPTION: This snippet creates a TestMetadata object for the BooleanString method, including test ID, arguments, class instantiation, and method invocation setup. It's repeated for different boolean argument values.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\nnodes.Add(new TestMetadata<global::TUnit.TestProject.DataDrivenTests>\n{\n    TestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.DataDrivenTests.BooleanString(bool?):0\",\n    TestClassArguments = [],\n    TestMethodArguments = [methodArg],\n    TestClassProperties = [],\n    CurrentRepeatAttempt = 0,\n    RepeatLimit = 0,\n    ResettableClassFactory = resettableClassFactory,\n    TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.BooleanString(methodArg)),\n    TestFilePath = @\"\",\n    TestLineNumber = 53,\n    TestMethod = testInformation,\n    TestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Completing TestMetadata Initialization and Handling Errors (Tests1) in C#\nDESCRIPTION: This C# snippet shows the latter part of initializing a `TestMetadata` object within a method likely named `Tests1`. It sets various attribute collections (`ClassAttributes`, `AssemblyAttributes`, `DataAttributes`) and the `TestBuilderContext`. It also includes the `catch` block which handles exceptions during initialization by creating a `FailedInitializationTest` object and adding it to the `nodes` list, followed by the method's return statement. This suggests the surrounding method (`Tests1`) is designed to generate test metadata for `TUnit.TestProject.ClassTupleDataSourceDrivenTests.DataSource_TupleMethod`, handling potential setup errors.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=TupleMethod_testMethodName=NamedTupleMethod.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nClassAttributes = [ new global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n{\n    \n} ],\n\t\t\t\tAssemblyAttributes = [  ],\n\t\t\t\tDataAttributes = [  ],\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedInitializationTest\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS1:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.ClassTupleDataSourceDrivenTests(System.Int32,System.String,System.Boolean).DataSource_TupleMethod(System.Int32,System.String,System.Boolean):0\",\n\t\t\t\tTestClass = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests),\n\t\t\t\tReturnType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests).GetMethod(\"DataSource_TupleMethod\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]).ReturnType,\n\t\t\t\tParameterTypeFullNames = [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)],\n\t\t\t\tTestName = \"DataSource_TupleMethod\",\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 24,\n\t\t\t\tException = exception,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing Comparable Value Negation Assertion Methods in C#\nDESCRIPTION: A set of extension methods that provide negated comparison assertions for IComparable<T> types. These methods assert that values are not between bounds, not greater than, not less than, or not equal to expected values.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_133\n\nLANGUAGE: C#\nCODE:\n```\npublic static class ComparableIsNotExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.NotBetweenAssertionBuilderWrapper<TActual> IsNotBetween<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual lowerBound, TActual upperBound, [System.Runtime.CompilerServices.CallerArgumentExpression(\"lowerBound\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"upperBound\")] string doNotPopulateThisValue2 = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotGreaterThan<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotGreaterThanOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotLessThan<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotLessThanOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.IComparable<TActual> { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Enumerable Count Assertions in C#\nDESCRIPTION: Defines a class for asserting counts on enumerable collections, including methods for checking if a collection is empty, has a specific count, or comparing counts.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_65\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumerableCount<TActual, TInner>\n    where TActual : System.Collections.Generic.IEnumerable<TInner>\n{\n    public EnumerableCount(TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> Empty { get; }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> EqualTo(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> EqualToOne() { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> EqualToZero() { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> GreaterThan(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> GreaterThanOrEqualTo(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> LessThan(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> LessThanOrEqualTo(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> Negative() { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> Positive() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Executor Attributes for TUnit Test Framework\nDESCRIPTION: Custom attributes for controlling test execution in the TUnit framework. These attributes configure culture settings, thread models, and custom executors that can be applied at assembly, class, or method level to customize test behavior.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\n    public class CultureAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestRegisteredEventReceiver\n    {\n        public CultureAttribute(System.Globalization.CultureInfo cultureInfo) { }\n        public CultureAttribute(string cultureName) { }\n        public int Order { get; }\n        public System.Threading.Tasks.ValueTask OnTestRegistered(TUnit.Core.TestRegisteredContext context) { }\n    }\n    public abstract class HookExecutorAttribute : TUnit.Core.TUnitAttribute\n    {\n        public abstract System.Type HookExecutorType { get; }\n    }\n    [System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\n    public sealed class HookExecutorAttribute<T> : TUnit.Core.Executors.HookExecutorAttribute\n        where T : TUnit.Core.Interfaces.IHookExecutor, new ()\n    {\n        public HookExecutorAttribute() { }\n        public override System.Type HookExecutorType { get; }\n    }\n    [System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\n    public class InvariantCultureAttribute : TUnit.Core.Executors.CultureAttribute\n    {\n        public InvariantCultureAttribute() { }\n    }\n    [System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\n    [System.Runtime.Versioning.SupportedOSPlatform(\"windows\")]\n    public class STAThreadExecutorAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestRegisteredEventReceiver\n    {\n        public STAThreadExecutorAttribute() { }\n        public int Order { get; }\n        public System.Threading.Tasks.ValueTask OnTestRegistered(TUnit.Core.TestRegisteredContext context) { }\n    }\n    [System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\n    public sealed class TestExecutorAttribute<T> : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestRegisteredEventReceiver\n        where T : TUnit.Core.Interfaces.ITestExecutor, new ()\n    {\n        public TestExecutorAttribute() { }\n        public int Order { get; }\n        public System.Threading.Tasks.ValueTask OnTestRegistered(TUnit.Core.TestRegisteredContext context) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Runner for Repeated Tests in C#\nDESCRIPTION: This code implements the test runner for a method named 'Three' in the RepeatTests class, which is configured to run 3 times via the RepeatAttribute. It creates TestMetadata objects for each test iteration, initializes test instances, handles execution context, and manages exceptions during test initialization.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/RepeatTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests1(string sessionId)\n{\n    global::System.Collections.Generic.List<TestMetadata> nodes = [];\n    var classDataIndex = 0;\n    var testMethodDataIndex = 0;\n    try\n    {\n        var testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n        {\n            Type = typeof(global::TUnit.TestProject.RepeatTests),\n            Name = \"Three\",\n            GenericTypeCount = 0,\n            ReturnType = typeof(void),\n            Attributes = \n            [\n                new global::TUnit.Core.TestAttribute()\n            ],\n            Parameters = [],\n            Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.RepeatTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n            {\n                Type = typeof(global::TUnit.TestProject.RepeatTests),\n                Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"RepeatTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n                {\n                    Name = \"RepeatTests\",\n                    Attributes = [],\n                }),\n                Name = \"RepeatTests\",\n                Namespace = \"TUnit.TestProject\",\n                Attributes = \n                [\n                    new global::TUnit.Core.RepeatAttribute(3)\n                ],\n                Parameters = [],\n                Properties = [],\n            }),\n};\n\n            var testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n            var testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n            global::TUnit.TestProject.RepeatTests? classInstance = null;\n            object?[]? classInstanceArguments = null;\n            classInstanceArguments = [];\n\n            var resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.RepeatTests>(() => \n            new global::TUnit.TestProject.RepeatTests()\n            , sessionId, testBuilderContext);\n            var resettableClassFactory = resettableClassFactoryDelegate();\n\n\n            nodes.Add(new TestMetadata<global::TUnit.TestProject.RepeatTests>\n            {\n                TestId = $\"TUnit.TestProject.RepeatTests.Three:1\",\n                TestClassArguments = [],\n                TestMethodArguments = [],\n                TestClassProperties = [],\n                CurrentRepeatAttempt = 1,\n                RepeatLimit = 3,\n                ResettableClassFactory = resettableClassFactory,\n                TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Three()),\n                TestFilePath = @\"\",\n                TestLineNumber = 20,\n                TestMethod = testInformation,\n                TestBuilderContext = testBuilderContext,\n            });\n            resettableClassFactory = resettableClassFactoryDelegate();\n            testBuilderContext = new();\n            testBuilderContextAccessor.Current = testBuilderContext;\n        }\n        catch (global::System.Exception exception)\n        {\n            nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.RepeatTests>\n            {\n                TestId = $\"TUnit.TestProject.RepeatTests.Three:1\",\n                MethodName = $\"Three\",\n                Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"RepeatTests.Three failed to initialize\", exception),\n                TestFilePath = @\"\",\n                TestLineNumber = 20,\n            });\n        }\n        return nodes;\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing AssertionData Struct in C#\nDESCRIPTION: Defines a readonly struct AssertionData that holds information about an assertion, including the result, exception, actual expression, and timing details. It implements IEquatable for comparison purposes.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic readonly struct AssertionData : System.IEquatable<TUnit.Assertions.AssertionData>\n{\n    public AssertionData(object? Result, System.Exception? Exception, string? ActualExpression, System.DateTimeOffset Start, System.DateTimeOffset End) { }\n    public string? ActualExpression { get; init; }\n    public System.DateTimeOffset End { get; init; }\n    public System.Exception? Exception { get; init; }\n    public object? Result { get; init; }\n    public System.DateTimeOffset Start { get; init; }\n    public static TUnit.Assertions.AssertionData op_Implicit(System.ValueTuple<object?, System.Exception?, string?, System.DateTimeOffset, System.DateTimeOffset> tuple) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Tests2 Method for Test Metadata Generation in C#\nDESCRIPTION: Method that generates test metadata for the 'Implicit' test with different argument values. It creates TestMetadata objects with test execution context, handles initialization failures, and returns a collection of test metadata nodes.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ArgumentWithImplicitConverterTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests2(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.ArgumentWithImplicitConverterTests),\n\t\t\tName = \"Implicit\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(1),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(2),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(3)\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.ImplicitInteger>\n\t\t\t\t{\n\t\t\t\t\tName = \"integer\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.ArgumentWithImplicitConverterTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.ArgumentWithImplicitConverterTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"ArgumentWithImplicitConverterTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"ArgumentWithImplicitConverterTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"ArgumentWithImplicitConverterTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.ArgumentWithImplicitConverterTests? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tclassInstanceArguments = [];\n\n\t\t\tglobal::TUnit.TestProject.ImplicitInteger methodArg = 3;\n\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ArgumentWithImplicitConverterTests>(() => \n\t\t\tnew global::TUnit.TestProject.ArgumentWithImplicitConverterTests()\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.ArgumentWithImplicitConverterTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS2:TUnit.TestProject.ArgumentWithImplicitConverterTests.Implicit(TUnit.TestProject.ImplicitInteger):0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Implicit(methodArg)),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 14,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ArgumentWithImplicitConverterTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS2:TUnit.TestProject.ArgumentWithImplicitConverterTests.Implicit(TUnit.TestProject.ImplicitInteger):0\",\n\t\t\t\tMethodName = $\"Implicit\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ArgumentWithImplicitConverterTests.Implicit failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 14,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n```\n\n----------------------------------------\n\nTITLE: Initializing Test Class with Data Source Method in C#\nDESCRIPTION: This snippet shows how test metadata is created for a method data source test scenario. It demonstrates how the test framework constructs test instances, applies method arguments from a data source, and prepares the test execution context.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.MethodDataSourceDrivenTests),\n\tName = \"DataSource_WithBaseReturn\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(void),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute(),\n\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"MethodWithBaseReturn\")\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.MethodDataSourceDrivenTests.BaseValue>\n\t\t{\n\t\t\tName = \"value\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.MethodDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t{\n\t\tType = typeof(global::TUnit.TestProject.MethodDataSourceDrivenTests),\n\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"MethodDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t{\n\t\t\tName = \"MethodDataSourceDrivenTests\",\n\t\t\tAttributes = [],\n\t\t}),\n\t\tName = \"MethodDataSourceDrivenTests\",\n\t\tNamespace = \"TUnit.TestProject\",\n\t\tAttributes = [],\n\t\tParameters = [],\n\t\tProperties = [],\n\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Throws Assertion for Action Delegate (Specific Exception Type) in C#\nDESCRIPTION: This overload of the static `Throws` method asserts that executing the provided `Action` delegate throws an exception of the specified `System.Type`. It returns the caught exception (as `System.Exception`) if the assertion passes. The `CallerArgumentExpression` captures the source expression.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\n        public static System.Exception Throws(System.Type type, System.Action @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression(\"delegate\")] string? doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Configuring BeforeClass Hook with CancellationToken Parameter in C#\nDESCRIPTION: Defines a BeforeClassHookMethod that calls the BeforeAllSetUp method with a CancellationToken parameter. This hook allows for cancellation of the setup operation and is decorated with the BeforeAttribute to specify its hook type.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeTests.Test.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeClassHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.BeforeClassHookMethod\n\t\t{\n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\tName = \"BeforeAllSetUp\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.SetupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"BeforeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"BeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"SetupTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.BeforeTests.SetupTests.BeforeAllSetUp(cancellationToken)),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tFilePath = @\"\",\n\t\t\t\tLineNumber = 62,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\tAssemblyAttributes = [],\n\t\t\t},\n\t\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Basic xUnit Assertion Syntax in C#\nDESCRIPTION: Demonstrates the `Assert.Equal` method in xUnit, used to compare expected and actual values. The surrounding text points out that the order of arguments (expected vs. actual) might not be immediately clear without documentation or Intellisense, potentially leading to confusion.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/comparison/framework-differences.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar one = 2;\nAssert.Equal(1, one)\nAssert.Equal(one, 1)\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for MethodDataSource Test in C#\nDESCRIPTION: This C# code snippet is part of a source-generated test collection method within the TUnit framework. It specifically generates `TestMetadata` for the `NonGenericMethodDataSource` test method located in the `TUnit.TestProject.InheritedTestsFromDifferentProjectTests` class. The snippet initializes test information, including attributes like `TestAttribute` and `MethodDataSourceAttribute` (referencing `TestData.Foo`), sets up the test execution context (`TestBuilderContext`), prepares arguments obtained from the data source (`TestData.Foo`), creates a resettable factory (`ResettableLazy`) for lazy instantiation of the test class, and adds the fully configured `TestMetadata` object to a collection (`nodes`). It also includes a try-catch block to wrap the metadata generation, creating a `FailedTestMetadata` object if any exception occurs during initialization.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/InheritedTestsFromDifferentProjectTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.InheritedTestsFromDifferentProjectTests),\n\t\t\t\tName = \"NonGenericMethodDataSource\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.TestData), \"Foo\")\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.InheritedTestsFromDifferentProjectTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.InheritedTestsFromDifferentProjectTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"InheritedTestsFromDifferentProjectTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"InheritedTestsFromDifferentProjectTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"InheritedTestsFromDifferentProjectTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.InheritsTestsAttribute()\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.InheritedTestsFromDifferentProjectTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tstring methodArg = global::TUnit.TestProject.TestData.Foo();\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.InheritedTestsFromDifferentProjectTests>(() => \n\t\t\t\tnew global::TUnit.TestProject.InheritedTestsFromDifferentProjectTests()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.InheritedTestsFromDifferentProjectTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.InheritedTestsFromDifferentProjectTests.NonGenericMethodDataSource(string):0\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.NonGenericMethodDataSource(methodArg)),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 17,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.InheritedTestsFromDifferentProjectTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.InheritedTestsFromDifferentProjectTests.NonGenericMethodDataSource(string):0\",\n\t\t\t\t\tMethodName = $\"NonGenericMethodDataSource\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"InheritedTestsFromDifferentProjectTests.NonGenericMethodDataSource failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 17,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: Defining DataSourceTest Parameterized Metadata for TUnit (C#)\nDESCRIPTION: This code builds metadata for a parameterized unit test 'DataSourceTest' featuring a timeout and method data source. It constructs objects describing the test method, its parameters, and class context using TUnit.Core source generation types. Inputs include type information for the class and method, attributes for test discovery, and parameter lists. Output is a TestMetadata instance describing the test, essential for the test runner to execute the test with correct arguments. Dependencies are TUnit.Core and System.Threading.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/TimeoutCancellationTokenTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.TimeoutCancellationTokenTests),\n\tName = \"DataSourceTest\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"DataSource\"),\n\t\tnew global::TUnit.Core.TimeoutAttribute(5_000),\n\t\tnew global::TUnit.Core.TestAttribute()\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t{\n\t\t\tName = \"value\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t{\n\t\t\tName = \"cancellationToken\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.TimeoutCancellationTokenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t{\n\t\tType = typeof(global::TUnit.TestProject.TimeoutCancellationTokenTests),\n\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"TimeoutCancellationTokenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t{\n\t\t\tName = \"TimeoutCancellationTokenTests\",\n\t\t\tAttributes = [],\n\t\t}),\n\t\tName = \"TimeoutCancellationTokenTests\",\n\t\tNamespace = \"TUnit.TestProject\",\n\t\tAttributes = \n\t\t[\n\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"DataSource\"),\n\t\t\tnew global::TUnit.Core.CategoryAttribute(\"Timeout Cancellation Token Tests\")\n\t\t],\n\t\tParameters = \n\t\t[\n\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t{\n\t\t\t\tName = \"value\",\n\t\t\t\tAttributes = [],\n\t\t\t},\n\t\t],\n\t\tProperties = [],\n\t}),\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing WorkerAwareTest Class in C#\nDESCRIPTION: This code snippet details the \"WorkerAwareTest\" class, implementing event and test registration interfaces. It supports parallel test execution by leveraging worker index and setup/teardown hooks, essential for managing multiple concurrent tests in TUnit.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic class WorkerAwareTest : TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestRegisteredEventReceiver\n    {\n        public WorkerAwareTest() { }\n        public virtual bool UseDefaultParallelLimiter { get; }\n        public int WorkerIndex { get; }\n        public System.Threading.Tasks.ValueTask OnTestRegistered(TUnit.Core.TestRegisteredContext context) { }\n        public System.Threading.Tasks.Task<T> RegisterService<T>(string name, System.Func<System.Threading.Tasks.Task<T>> factory)\n            where T :  class, TUnit.Playwright.IWorkerService { }\n        protected bool TestOk(TUnit.Core.TestContext testContext) { }\n        [TUnit.Core.Before(TUnit.Core.HookType.Test, \"\", 0)]\n        public void WorkerSetup() { }\n        [TUnit.Core.After(TUnit.Core.HookType.Test, \"\", 0)]\n        public System.Threading.Tasks.Task WorkerTeardown(TUnit.Core.TestContext testContext) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Global Test Hooks for GlobalBase1 in C#\nDESCRIPTION: Defines a partial class Hooks_GlobalBase1 that implements ITestHookSource. It registers a before-test hook method 'BeforeEach1' from the GlobalBase1 class.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticBeforeEachTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_GlobalBase1 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_GlobalBase1();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.BeforeTests.GlobalBase1),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.GlobalBase1),\n\t\t\t\t\tName = \"BeforeEach1\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.GlobalBase1\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.GlobalBase1),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"GlobalStaticBeforeEachTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"GlobalStaticBeforeEachTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"GlobalBase1\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.BeforeTests.GlobalBase1)classInstance).BeforeEach1()),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DefaultPlaywrightParallelLimiter Class in C#\nDESCRIPTION: Defines a class \"DefaultPlaywrightParallelLimiter\" that implements the \"IParallelLimit\" interface from TUnit.Core. It provides a limitation of parallel test execution by giving access to a configurable limit, integral to controlling concurrency in testing\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DefaultPlaywrightParallelLimiter : TUnit.Core.Interfaces.IParallelLimit\n    {\n        public DefaultPlaywrightParallelLimiter() { }\n        public int Limit { get; }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining SatisfiesAssertCondition for TUnit Complex Assertions (C#)\nDESCRIPTION: Defines the `SatisfiesAssertCondition` class, inheriting from `BaseAssertCondition`. This complex condition allows asserting that a value, after being asynchronously mapped (`mapper`) to another type (`TExpected`), satisfies further assertions defined by an `assertionBuilder`. It stores the expressions for mapping and building assertions as strings.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_24\n\nLANGUAGE: csharp\nCODE:\n```\n    public class SatisfiesAssertCondition<TActual, TExpected> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n    {\n        public SatisfiesAssertCondition(System.Func<TActual, System.Threading.Tasks.Task<TExpected>?> mapper, System.Func<TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TExpected?>, TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TExpected?>> assertionBuilder, string mapperExpression, string assertionBuilderExpression) { }\n        protected override string GetExpectation() { }\n        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for Data-Driven Tests in C#\nDESCRIPTION: This snippet demonstrates the process of creating test metadata for data-driven tests using a method data source. It iterates through test data, creates unique test IDs, and sets up class instances and test method factories.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nforeach (var methodDataAccessor in global::TUnit.TestProject.MethodDataSourceDrivenTests.EnumerableFuncArrayTestData())\n{\n    testMethodDataIndex++;\n    classInstanceArguments = [];\n\n    var methodData = methodDataAccessor();\n    var resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.MethodDataSourceDrivenTests>(() => \n    new global::TUnit.TestProject.MethodDataSourceDrivenTests()\n    , sessionId, testBuilderContext);\n    var resettableClassFactory = resettableClassFactoryDelegate();\n\n\n    nodes.Add(new TestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenTests>\n    {\n        TestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS0:{testMethodDataIndex}:TUnit.TestProject.MethodDataSourceDrivenTests.EnumerableFuncArrayTest(string[]):0\",\n        TestClassArguments = [],\n        TestMethodArguments = [methodData],\n        TestClassProperties = [],\n        CurrentRepeatAttempt = 0,\n        RepeatLimit = 0,\n        ResettableClassFactory = resettableClassFactory,\n        TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.EnumerableFuncArrayTest(methodData)),\n        TestFilePath = @\"\",\n        TestLineNumber = 59,\n        TestMethod = testInformation,\n        TestBuilderContext = testBuilderContext,\n    });\n    resettableClassFactory = resettableClassFactoryDelegate();\n    testBuilderContext = new();\n    testBuilderContextAccessor.Current = testBuilderContext;\n}\n```\n\n----------------------------------------\n\nTITLE: Registering and Executing After Test Hook with TUnit in C#\nDESCRIPTION: This code snippet sets up and executes an `AfterTest` hook with the TUnit framework for STAThreadTests. Similar to the `BeforeTest`, it uses InstanceHookMethod to define method execution properties, ensuring that post-test activities specific to STAThread tests are properly executed. Dependencies are similar, focusing on TUnit.Core components and proper initialization of hook attributes.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/STAThreadHooksTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t{\n\t\t\tClassType = typeof(global::TUnit.TestProject.STAThreadTests),\n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.STAThreadTests),\n\t\t\t\tName = \"AfterTest\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test),\n\t\t\t\t\tnew global::TUnit.Core.Executors.HookExecutorAttribute<global::TUnit.Core.STAThreadExecutor>()\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.STAThreadTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.STAThreadTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"STAThreadHooksTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"STAThreadHooksTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"STAThreadTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute(\"Interoperability\", \"CA1416:Validate platform compatibility\")\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.STAThreadTests)classInstance).AfterTest()),\n\t\t\t\t\tHookExecutor = new global::TUnit.Core.STAThreadExecutor(),\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test),\n\t\t\t\t\t\tnew global::TUnit.Core.Executors.HookExecutorAttribute<global::TUnit.Core.STAThreadExecutor>()\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute(\"Interoperability\", \"CA1416:Validate platform compatibility\")\n\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing TUnit Test Source in C#\nDESCRIPTION: Defines a partial Tests class that implements ITestSource. It includes a static initializer to register the tests and methods to collect test metadata.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests2136.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Tests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new Tests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\t..Tests0(sessionId),\n\t\t\t..Tests1(sessionId),\n\t\t\t..Tests2(sessionId),\n\t\t\t..Tests3(sessionId),\n\t\t\t..Tests4(sessionId),\n\t\t];\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Hook Method Classes in C#\nDESCRIPTION: Defines various hook method classes for test lifecycle events like BeforeAssembly, BeforeClass, BeforeTestDiscovery, etc. Each class inherits from StaticHookMethod and implements async execution logic.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_58\n\nLANGUAGE: C#\nCODE:\n```\npublic class BeforeAssemblyHookMethod : TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.AssemblyHookContext>, System.IEquatable<TUnit.Core.Hooks.BeforeAssemblyHookMethod>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of your compiler.\", true)]\n    public BeforeAssemblyHookMethod() { }\n    public override System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.AssemblyHookContext context, System.Threading.CancellationToken cancellationToken) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NotEquivalentToAssertionBuilderWrapper in C#\nDESCRIPTION: Wrapper for object non-equivalence assertions with options to ignore specific members or enable partial equivalency checking between actual and expected objects.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_91\n\nLANGUAGE: C#\nCODE:\n```\n    public class NotEquivalentToAssertionBuilderWrapper<TActual, TExpected> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>\n    {\n        public TUnit.Assertions.AssertionBuilders.Wrappers.NotEquivalentToAssertionBuilderWrapper<TActual, TExpected> IgnoringMember(string propertyName, [System.Runtime.CompilerServices.CallerArgumentExpression(\"propertyName\")] string doNotPopulateThis = \"\") { }\n        public TUnit.Assertions.AssertionBuilders.Wrappers.NotEquivalentToAssertionBuilderWrapper<TActual, TExpected> WithPartialEquivalency() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Exception Message Validation in C#\nDESCRIPTION: Classes for validating exception messages. They provide assertions for checking if a message contains, ends with, or equals a specific string, with support for string comparison options.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_45\n\nLANGUAGE: C#\nCODE:\n```\npublic class ExceptionMessageContainingExpectedValueAssertCondition<TException> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TException, string>\n    where TException : System.Exception\n{\n    public ExceptionMessageContainingExpectedValueAssertCondition(string expected, System.StringComparison stringComparison) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TException? actualValue, string? expectedValue) { }\n}\n\npublic class ExceptionMessageEndingWithExpectedValueAssertCondition<TException> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TException, string>\n    where TException : System.Exception\n{\n    public ExceptionMessageEndingWithExpectedValueAssertCondition(string expected, System.StringComparison stringComparison) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TException? actualValue, string? expectedValue) { }\n}\n\npublic class ExceptionMessageEqualsExpectedValueAssertCondition<TException> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TException, string>\n    where TException : System.Exception\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring BeforeClass Hook with No Parameters in C#\nDESCRIPTION: Defines a BeforeClassHookMethod that calls the BeforeAllSetUp method without parameters. This hook runs before a test class is executed and is decorated with the BeforeAttribute to specify its hook type.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeTests.Test.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeClassHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.BeforeClassHookMethod\n\t\t{\n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\tName = \"BeforeAllSetUp\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.SetupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"BeforeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"BeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"SetupTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.BeforeTests.SetupTests.BeforeAllSetUp()),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tFilePath = @\"\",\n\t\t\t\tLineNumber = 50,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\tAssemblyAttributes = [],\n\t\t\t},\n\t\t}];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Exception Message Assertions in C#\nDESCRIPTION: Extension methods for asserting exception message properties including contains, starts with, ends with, and equality checks. Supports custom string comparison options.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_147\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> HasMessageContaining<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n    where TActual : System.Exception { }\n\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> HasMessageEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"stringComparison\")] string doNotPopulateThisValue2 = null)\n    where TActual : System.Exception { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Method Generation in C#\nDESCRIPTION: Generates test method metadata and execution logic for data-driven tests with parameter values 1, 2, and 3. Includes error handling and test context setup.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.DataDrivenTests),\n\t\t\tName = \"DataSource_Method\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(1),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(2),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(3)\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t{\n\t\t\t\t\tName = \"value\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t]\n\t\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ConvertToAssertCondition<TFromType, TToType> Abstract Class in C#\nDESCRIPTION: This abstract class provides a base for assertion conditions that involve type conversion, with methods for converting values and getting results.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ConvertToAssertCondition<TFromType, TToType> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TFromType>\n{\n    protected ConvertToAssertCondition() { }\n    public TToType ConvertedValue { get; }\n    public abstract System.Threading.Tasks.ValueTask<System.ValueTuple<TUnit.Assertions.AssertConditions.AssertionResult, TToType?>> ConvertValue(TFromType? value);\n    protected override sealed System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TFromType? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Collecting Asynchronous Tests in C#\nDESCRIPTION: This snippet defines a partial class for collecting asynchronous test methods from BasicTests. It includes test metadata creation, class instance initialization, and exception handling for the AsynchronousTest method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BasicTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class BasicTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new BasicTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BasicTests),\n\t\t\t\tName = \"AsynchronousTest\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute()\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BasicTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BasicTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"BasicTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"BasicTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"BasicTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.BasicTests? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tclassInstanceArguments = [];\n\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.BasicTests>(() => \n\t\t\tnew global::TUnit.TestProject.BasicTests()\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.BasicTests>\n\t\t\t{\n\t\t\t\tTestId = $\"TUnit.TestProject.BasicTests.AsynchronousTest:0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.AsynchronousTest()),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 11,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.BasicTests>\n\t\t\t{\n\t\t\t\tTestId = $\"TUnit.TestProject.BasicTests.AsynchronousTest:0\",\n\t\t\t\tMethodName = $\"AsynchronousTest\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"BasicTests.AsynchronousTest failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 11,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing String Assertion Extensions in C#\nDESCRIPTION: Extension methods for string assertions in TUnit, providing methods to check equality, emptiness, and whitespace conditions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_80\n\nLANGUAGE: C#\nCODE:\n```\npublic static class StringIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> IsEmpty(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.StringEqualToAssertionBuilderWrapper IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> IsNullOrEmpty(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> IsNullOrWhitespace(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating TestMetadata for DataSourceClassCombinedWithDataSourceMethod test class in C#\nDESCRIPTION: This code creates a TestMetadata object for a test class that uses data sources at both class and method levels. It sets up the test identification, arguments, factory methods, and context information needed to run the test.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceClassCombinedWithDataSourceMethodTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nnodes.Add(new TestMetadata<global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod>\n{\n\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS0:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod(int).DataSourceClassCombinedWithDataSourceMethodTest(int):0\",\n\tTestClassArguments = [classArg],\n\tTestMethodArguments = [methodArg],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSourceClassCombinedWithDataSourceMethodTest(methodArg)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 10,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Resettable Class Factory in C#\nDESCRIPTION: Defines a resettable lazy factory for creating PropertySetterTests instances with initialized properties.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/InheritedPropertySetterTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.PropertySetterTests>(() => \nnew global::TUnit.TestProject.PropertySetterTests()\n{\n\tProperty1 = global::TUnit.Core.Helpers.CastHelper.Cast<string>(propertyArg),\n\tProperty2 = global::TUnit.Core.Helpers.CastHelper.Cast<string>(propertyArg1),\n\t// ... (other property initializations)\n});\n```\n\n----------------------------------------\n\nTITLE: Generating Matrix Tests for AutoGenerateBools2 Method in C#\nDESCRIPTION: This code snippet generates matrix tests for the AutoGenerateBools2 method in the MatrixTests class. It creates test cases combining string inputs with nullable boolean values.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MatrixTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.MatrixTests),\n\tName = \"AutoGenerateBools2\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute(),\n\t\tnew global::TUnit.Core.MatrixDataSourceAttribute()\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"str\",\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.MatrixAttribute(\"A\", \"B\", \"C\")\n\t\t\t],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool?>\n\t\t{\n\t\t\tName = \"boolean\",\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.MatrixAttribute()\n\t\t\t],\n\t\t},\n\t],\n\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.MatrixTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t{\n\t\tType = typeof(global::TUnit.TestProject.MatrixTests),\n\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"MatrixTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t{\n\t\t\tName = \"MatrixTests\",\n\t\t\tAttributes = [],\n\t\t}),\n\t\tName = \"MatrixTests\",\n\t\tNamespace = \"TUnit.TestProject\",\n\t\tAttributes = [],\n\t\tParameters = [],\n\t\tProperties = [],\n\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing Test Information and Parameters in C#\nDESCRIPTION: This snippet defines test information including return type, attributes, and parameters for a test method. It sets up multiple parameters of the InitializableClass type.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nReturnType = typeof(global::System.Threading.Tasks.Task),\nAttributes = \n[\n\tnew global::TUnit.Core.TestAttribute()\n],\nParameters = \n[\n\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.InitializableClass>\n\t{\n\t\tName = \"class1\",\n\t\tAttributes = [],\n\t},\n\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.InitializableClass>\n\t{\n\t\tName = \"class2\",\n\t\tAttributes = [],\n\t},\n\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.InitializableClass>\n\t{\n\t\tName = \"class3\",\n\t\tAttributes = [],\n\t},\n\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.InitializableClass>\n\t{\n\t\tName = \"class4\",\n\t\tAttributes = [],\n\t},\n\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.InitializableClass>\n\t{\n\t\tName = \"class5\",\n\t\tAttributes = [],\n\t},\n],\n```\n\n----------------------------------------\n\nTITLE: Generating TUnit Test Metadata for Tuple Data Source\nDESCRIPTION: Creates TestMetadata objects for a test method with tuple data sources. Handles class and method level data sources, including property initialization.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=TupleMethod_testMethodName=TupleMethod.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testClassType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests);\n\t\tvar methodInfo = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests).GetMethod(\"DataSource_TupleMethod\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]);\n\n\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\tvar classArgTuples = global::System.TupleExtensions.ToTuple<global::System.Int32, global::System.String, global::System.Boolean>(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()());\n\t\tglobal::System.Int32 classArg = classArgTuples.Item1;\n\t\tglobal::System.String classArg1 = classArgTuples.Item2;\n\t\tglobal::System.Boolean classArg2 = classArgTuples.Item3;\n\t\t(global::System.Int32, global::System.String, global::System.Boolean) propertyArg = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()();\n\t\t(global::System.Int32 Number, global::System.String Word, global::System.Boolean Flag) propertyArg1 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()();\n\t\t(global::System.Int32, global::System.String, global::System.Boolean) propertyArg2 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()();\n\t\t(global::System.Int32 Number, global::System.String Word, global::System.Boolean Flag) propertyArg3 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()();\n\n\t\tvar methodArgTuples = global::System.TupleExtensions.ToTuple<global::System.Int32, global::System.String, global::System.Boolean>(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()());\n\t\tglobal::System.Int32 methodArg = methodArgTuples.Item1;\n\t\tglobal::System.String methodArg1 = methodArgTuples.Item2;\n\t\tglobal::System.Boolean methodArg2 = methodArgTuples.Item3;\n\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>(() => \n\t\tnew global::TUnit.TestProject.ClassTupleDataSourceDrivenTests(classArg, classArg1, classArg2)\n\t\t{\n\t\t\tProperty1 = propertyArg,\n\t\t\tProperty2 = propertyArg1,\n\t\t\tProperty3 = propertyArg2,\n\t\t\tProperty4 = propertyArg3,\n\t\t}\n\t\t, sessionId, testBuilderContext);\n\n\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>\n\t\t{\n\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS0:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.ClassTupleDataSourceDrivenTests(System.Int32,System.String,System.Boolean).DataSource_TupleMethod(System.Int32,System.String,System.Boolean):0\",\n\t\t\tTestClassArguments = [classArg, classArg1, classArg2],\n\t\t\tTestMethodArguments = [methodArg, methodArg1, methodArg2],\n\t\t\tTestClassProperties = [propertyArg, propertyArg1, propertyArg2, propertyArg3],\n\t\t\tCurrentRepeatAttempt = 0,\n\t\t\tRepeatLimit = 0,\n\t\t\tMethodInfo = methodInfo,\n\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_TupleMethod(methodArg, methodArg1, methodArg2)),\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 24,\n\t\t\tTestAttributes = [ new global::TUnit.Core.TestAttribute()\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n{\n    \n} ],\n\t\t\tClassAttributes = [ new global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n{\n    \n} ],\n\t\t\tAssemblyAttributes = [  ],\n\t\t\tDataAttributes = [  ],\n\t\t\tTestBuilderContext = testBuilderContext,\n\t\t});\n\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\ttestBuilderContext = new();\n\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t}\n\tcatch (global::System.Exception exception)\n\t{\n\t\tnodes.Add(new FailedInitializationTest\n\t\t{\n\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS0:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.ClassTupleDataSourceDrivenTests(System.Int32,System.String,System.Boolean).DataSource_TupleMethod(System.Int32,System.String,System.Boolean):0\",\n\t\t\tTestClass = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests),\n\t\t\tReturnType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests).GetMethod(\"DataSource_TupleMethod\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]).ReturnType,\n\t\t\tParameterTypeFullNames = [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)],\n\t\t\tTestName = \"DataSource_TupleMethod\",\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 24,\n\t\t\tException = exception,\n\t\t});\n\t}\n\treturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing String DoesNotStartWith Assertion in C#\nDESCRIPTION: Defines extension methods for asserting that a string does not start with a given value. Includes overloads for case-sensitive and case-insensitive comparisons.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_116\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> DoesNotStartWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> DoesNotStartWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"stringComparison\")] string doNotPopulateThisValue2 = null) { }\n```\n\n----------------------------------------\n\nTITLE: Initializing TUnit Data Source Driven Test Metadata - C#\nDESCRIPTION: This snippet sets up test metadata for TUnit data-driven tests by extracting arguments from tuple and named tuple methods, configuring class and method properties, and managing lifecycle via a resettable class factory. Dependencies include the TUnit framework, supporting tuple extensions, and a compatible test context. Inputs are derived from data source methods (TupleMethod and NamedTupleMethod) along with sessionId, with outputs being populated lists of TestMetadata objects for test discovery. Limitations include reliance on proper tuple structures and available method signatures.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=TupleMethod_testMethodName=TupleMethod.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests2(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testClassType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests);\n\t\tvar methodInfo = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests).GetMethod(\"DataSource_TupleMethod\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]);\n\n\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\tvar classArgTuples = global::System.TupleExtensions.ToTuple<global::System.Int32, global::System.String, global::System.Boolean>(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()());\n\t\tglobal::System.Int32 classArg = classArgTuples.Item1;\n\t\tglobal::System.String classArg1 = classArgTuples.Item2;\n\t\tglobal::System.Boolean classArg2 = classArgTuples.Item3;\n\t\t(global::System.Int32, global::System.String, global::System.Boolean) propertyArg = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()();\n\t\t(global::System.Int32 Number, global::System.String Word, global::System.Boolean Flag) propertyArg1 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()();\n\t\t(global::System.Int32, global::System.String, global::System.Boolean) propertyArg2 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()();\n\t\t(global::System.Int32 Number, global::System.String Word, global::System.Boolean Flag) propertyArg3 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()();\n\n\t\tvar methodArgTuples = global::System.TupleExtensions.ToTuple<global::System.Int32, global::System.String, global::System.Boolean>(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()());\n\t\tglobal::System.Int32 methodArg = methodArgTuples.Item1;\n\t\tglobal::System.String methodArg1 = methodArgTuples.Item2;\n\t\tglobal::System.Boolean methodArg2 = methodArgTuples.Item3;\n\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>(() => \n\t\tnew global::TUnit.TestProject.ClassTupleDataSourceDrivenTests(classArg, classArg1, classArg2)\n\t\t{\n\t\t\tProperty1 = propertyArg,\n\t\t\tProperty2 = propertyArg1,\n\t\t\tProperty3 = propertyArg2,\n\t\t\tProperty4 = propertyArg3,\n\t\t}\n\t\t, sessionId, testBuilderContext);\n\n\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>\n\t\t{\n\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS0:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.ClassTupleDataSourceDrivenTests(System.Int32,System.String,System.Boolean).DataSource_TupleMethod(System.Int32,System.String,System.Boolean):0\",\n\t\t\tTestClassArguments = [classArg, classArg1, classArg2],\n\t\t\tTestMethodArguments = [methodArg, methodArg1, methodArg2],\n\t\t\tTestClassProperties = [propertyArg, propertyArg1, propertyArg2, propertyArg3],\n\t\t\tCurrentRepeatAttempt = 0,\n\t\t\tRepeatLimit = 0,\n\t\t\tMethodInfo = methodInfo,\n\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_TupleMethod(methodArg, methodArg1, methodArg2)),\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 24,\n\t\t\tTestAttributes = [ new global::TUnit.Core.TestAttribute()\n\t{\n\t    \n\t}, new global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n\t{\n\t    \n\t}, new global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n\t{\n\t    \n\t} ],\n\t\t\tClassAttributes = [ new global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n\t{\n\t    \n\t}, new global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n\t{\n\t    \n\t} ],\n\t\t\tAssemblyAttributes = [  ],\n\t\t\tDataAttributes = [  ],\n\t\t\tTestBuilderContext = testBuilderContext,\n\t\t});\n\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\ttestBuilderContext = new();\n\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t}\n\tcatch (global::System.Exception exception)\n\t{\n\t\tnodes.Add(new FailedInitializationTest\n\t\t{\n\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS0:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.ClassTupleDataSourceDrivenTests(System.Int32,System.String,System.Boolean).DataSource_TupleMethod(System.Int32,System.String,System.Boolean):0\",\n\t\t\tTestClass = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests),\n\t\t\tReturnType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests).GetMethod(\"DataSource_TupleMethod\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]).ReturnType,\n\t\t\tParameterTypeFullNames = [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)],\n\t\t\tTestName = \"DataSource_TupleMethod\",\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 24,\n\t\t\tException = exception,\n\t\t});\n\t}\n\treturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring and Executing TUnit Tests with Method Data Sources\nDESCRIPTION: This code snippet handles the initialization and execution of tests that use method data sources in the TUnit framework. It configures test properties, applies attributes, and implements error handling for test initialization failures.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=NamedTupleMethod_testMethodName=NamedTupleMethod.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nTestClassProperties = [propertyArg, propertyArg1, propertyArg2, propertyArg3],\nCurrentRepeatAttempt = 0,\nRepeatLimit = 0,\nMethodInfo = methodInfo,\nResettableClassFactory = resettableClassFactory,\nTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_TupleMethod(methodArg, methodArg1, methodArg2)),\nTestFilePath = @\"\",\nTestLineNumber = 24,\nTestAttributes = [ new global::TUnit.Core.TestAttribute()\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n{\n    \n} ],\nClassAttributes = [ new global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n{\n    \n} ],\nAssemblyAttributes = [  ],\nDataAttributes = [  ],\nTestBuilderContext = testBuilderContext,\n});\nresettableClassFactory = resettableClassFactoryDelegate();\ntestBuilderContext = new();\ntestBuilderContextAccessor.Current = testBuilderContext;\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for Parameterized Test Method with Matrix Data\nDESCRIPTION: Creates test metadata for a test method with parameters, using the MatrixDataSourceAttribute to generate test cases. This implementation shows how TUnit handles data-driven tests with proper metadata for each test case variation.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1889.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests1(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1889.DerivedTest),\n\t\t\tName = \"Test2\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t\t\t{\n\t\t\t\t\tName = \"condition\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._1889.DerivedTest\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1889.DerivedTest),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Tests1889\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"Tests1889\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"DerivedTest\",\n\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._1889\",\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.InheritsTestsAttribute()\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.Bugs._1889.DerivedTest? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tvar methodArgDataGeneratorMetadata = new DataGeneratorMetadata\n\t\t\t{\n\t\t\t\tType = global::TUnit.Core.Enums.DataGeneratorType.TestParameters,\n\t\t\t\tTestBuilderContext = testBuilderContextAccessor,\n\t\t\t\tTestInformation = testInformation,\n\t\t\t\tMembersToGenerate = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"condition\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tTestSessionId = sessionId,\n\t\t\t\tTestClassInstance = classInstance,\n\t\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t\t};\n\t\t\tvar methodDataAttribute = new global::TUnit.Core.MatrixDataSourceAttribute();\n\n\t\t\ttestBuilderContext.DataAttributes.Add(methodDataAttribute);\n\n\t\t\tvar methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\n\n\t\t\tforeach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\n\t\t\t{\n\t\t\t\ttestMethodDataIndex++;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tvar methodArgGeneratedData = methodArgGeneratedDataAccessor();\n\t\t\t\tbool methodArg = global::TUnit.Core.Helpers.CastHelper.Cast<bool>(methodArgGeneratedData[0]);\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._1889.DerivedTest>(() => \n\t\t\t\tnew global::TUnit.TestProject.Bugs._1889.DerivedTest()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._1889.DerivedTest>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.MatrixDataSourceAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.Bugs._1889.DerivedTest.Test2(bool):0\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Test2(methodArg)),\n\t\t\t\t\tTestLineNumber = 12,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._1889.DerivedTest>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.MatrixDataSourceAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.Bugs._1889.DerivedTest.Test2(bool):0\",\n\t\t\t\tMethodName = $\"Test2\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"DerivedTest.Test2 failed to initialize\", exception),\n\t\t\t\tTestLineNumber = 12,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n```\n\n----------------------------------------\n\nTITLE: Declaring IAndAssertionBuilder Interface in C#\nDESCRIPTION: This interface represents an 'and' assertion builder. It is an empty interface used for type identification.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_57\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IAndAssertionBuilder { }\n```\n\n----------------------------------------\n\nTITLE: Defining Parameters and Generating Test Cases for MatrixTest_Two in C#\nDESCRIPTION: This C# code snippet defines the parameters for the `MatrixTest_Two` test method using `SourceGeneratedParameterInformation` and populates them with data values via `MatrixAttribute`. It utilizes `MatrixDataSourceAttribute` to generate combinations of these parameters, iterates through them, casts the arguments to their appropriate types (int, bool), creates `TestMetadata` objects for each test case, and adds them to a collection. Includes error handling for test initialization failures.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MatrixTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"i2\",\n\t\t\t\t\t\t\tAttributes = \n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew global::TUnit.Core.MatrixAttribute(1, 2, 3)\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"i3\",\n\t\t\t\t\t\t\tAttributes = \n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew global::TUnit.Core.MatrixAttribute(1, 2, 3, 4)\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"boolean\",\n\t\t\t\t\t\t\tAttributes = \n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew global::TUnit.Core.MatrixAttribute(true, false)\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tTestSessionId = sessionId,\n\t\t\t\t\tTestClassInstance = classInstance,\n\t\t\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t\t\t};\n\t\t\t\tvar methodDataAttribute = new global::TUnit.Core.MatrixDataSourceAttribute();\n\n\t\t\t\ttestBuilderContext.DataAttributes.Add(methodDataAttribute);\n\n\t\t\t\tvar methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\n\n\t\t\t\tforeach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\n\t\t\t\t{\n\t\t\t\t\ttestMethodDataIndex++;\n\t\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\t\tvar methodArgGeneratedData = methodArgGeneratedDataAccessor();\n\t\t\t\t\tint methodArg = global::TUnit.Core.Helpers.CastHelper.Cast<int>(methodArgGeneratedData[0]);\n\t\t\t\t\tint methodArg1 = global::TUnit.Core.Helpers.CastHelper.Cast<int>(methodArgGeneratedData[1]);\n\t\t\t\t\tint methodArg2 = global::TUnit.Core.Helpers.CastHelper.Cast<int>(methodArgGeneratedData[2]);\n\t\t\t\t\tbool methodArg3 = global::TUnit.Core.Helpers.CastHelper.Cast<bool>(methodArgGeneratedData[3]);\n\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.MatrixTests>(() => \n\t\t\t\t\tnew global::TUnit.TestProject.MatrixTests()\n\t\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.MatrixTests>\n\t\t\t\t\t{\n\t\t\t\t\t\tTestId = $\"global::TUnit.Core.MatrixDataSourceAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.MatrixTests.MatrixTest_Two(int,int,int,bool):0\",\n\t\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\t\tTestMethodArguments = [methodArg, methodArg1, methodArg2, methodArg3],\n\t\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.MatrixTest_Two(methodArg, methodArg1, methodArg2, methodArg3)),\n\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\tTestLineNumber = 20,\n\t\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t\t});\n\t\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\t\ttestBuilderContext = new();\n\t\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.MatrixTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.MatrixDataSourceAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.MatrixTests.MatrixTest_Two(int,int,int,bool):0\",\n\t\t\t\t\tMethodName = $\"MatrixTest_Two\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"MatrixTests.MatrixTest_Two failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 20,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing Source Registration Extensions in C#\nDESCRIPTION: Extension methods for registering assertions and handling delegate sources. Includes methods for converting assertions and registering base conditions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_130\n\nLANGUAGE: C#\nCODE:\n```\npublic static class SourceExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableDelegateAssertionBuilder RegisterAssertion<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource, TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual> assertCondition, string?[] argumentExpressions, [System.Runtime.CompilerServices.CallerMemberName] string? caller = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WorkerAwareTest Class for Playwright Testing in C#\nDESCRIPTION: This class implements IEventReceiver and ITestRegisteredEventReceiver interfaces, providing worker-aware test functionality for Playwright tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class WorkerAwareTest : TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestRegisteredEventReceiver\n{\n    public WorkerAwareTest() { }\n    public virtual bool UseDefaultParallelLimiter { get; }\n    public int WorkerIndex { get; }\n    public System.Threading.Tasks.ValueTask OnTestRegistered(TUnit.Core.TestRegisteredContext context) { }\n    public System.Threading.Tasks.Task<T> RegisterService<T>(string name, System.Func<System.Threading.Tasks.Task<T>> factory)\n        where T :  class, TUnit.Playwright.IWorkerService { }\n    protected bool TestOk(TUnit.Core.TestContext testContext) { }\n    [TUnit.Core.Before(TUnit.Core.HookType.Test, \"\", 0)]\n    public void WorkerSetup() { }\n    [TUnit.Core.After(TUnit.Core.HookType.Test, \"\", 0)]\n    public System.Threading.Tasks.Task WorkerTeardown(TUnit.Core.TestContext testContext) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DefaultLogger Class in C#\nDESCRIPTION: This class implements the TUnitLogger abstract class and provides default logging functionality. It includes methods for synchronous and asynchronous logging, as well as property management.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_62\n\nLANGUAGE: C#\nCODE:\n```\npublic class DefaultLogger : TUnit.Core.Logging.TUnitLogger\n{\n    public DefaultLogger(TUnit.Core.Context context) { }\n    public override void Log<TState>(TUnit.Core.Logging.LogLevel logLevel, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter) { }\n    public override System.Threading.Tasks.ValueTask LogAsync<TState>(TUnit.Core.Logging.LogLevel logLevel, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter) { }\n    public void PushProperties(System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<object>> dictionary) { }\n    public void PushProperty(string name, object? value) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Class Level BeforeAll and AfterAll Hooks in TUnit\nDESCRIPTION: Methods that collect static hooks at the class level, including BeforeAll hooks with a ClassHookContext parameter. These methods define hooks that run once before or after all tests in a class.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeTests.Test.verified.txt#2025-04-22_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeClassHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>\n\t\t{\n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\tName = \"BeforeAllSetUpWithContext\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.ClassHookContext>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"context\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.SetupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"BeforeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"BeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"SetupTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.BeforeTests.SetupTests.BeforeAllSetUpWithContext(context, cancellationToken)),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tFilePath = @\"\",\n\t\t\t\tLineNumber = 68,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\tAssemblyAttributes = [],\n\t\t\t},\n\t];\n}\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterClassHooks(string sessionId)\n{\n\treturn\n\t[\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Registering and Collecting Tests in TUnit\nDESCRIPTION: This snippet shows the process of registering tests, collecting test metadata, and preparing test execution for data-driven tests. It uses reflection and custom attributes to gather test information and create TestMetadata objects.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/EnumerableDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nglobal::TUnit.Core.SourceRegistrar.Register(new EnumerableDataSourceDrivenTests());\n\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn Tests0(sessionId);\n}\n\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.EnumerableDataSourceDrivenTests),\n\t\t\tName = \"DataSource_WithBaseReturn\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"MethodWithBaseReturn\")\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.EnumerableDataSourceDrivenTests.BaseValue>\n\t\t\t\t{\n\t\t\t\t\tName = \"value\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.EnumerableDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.EnumerableDataSourceDrivenTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"EnumerableDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"EnumerableDataSourceDrivenTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"EnumerableDataSourceDrivenTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\tglobal::TUnit.TestProject.EnumerableDataSourceDrivenTests? classInstance = null;\n\t\tobject?[]? classInstanceArguments = null;\n\t\tforeach (var methodDataAccessor in global::TUnit.TestProject.EnumerableDataSourceDrivenTests.MethodWithBaseReturn())\n\t\t{\n\t\t\ttestMethodDataIndex++;\n\t\t\tclassInstanceArguments = [];\n\n\t\t\tvar methodData = methodDataAccessor();\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.EnumerableDataSourceDrivenTests>(() => \n\t\t\tnew global::TUnit.TestProject.EnumerableDataSourceDrivenTests()\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.EnumerableDataSourceDrivenTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS0:{testMethodDataIndex}:TUnit.TestProject.EnumerableDataSourceDrivenTests.DataSource_WithBaseReturn(TUnit.TestProject.EnumerableDataSourceDrivenTests.BaseValue):0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [methodData],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_WithBaseReturn(methodData)),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 22,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t}\n\tcatch (global::System.Exception exception)\n\t{\n\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.EnumerableDataSourceDrivenTests>\n\t\t{\n\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS0:{testMethodDataIndex}:TUnit.TestProject.EnumerableDataSourceDrivenTests.DataSource_WithBaseReturn(TUnit.TestProject.EnumerableDataSourceDrivenTests.BaseValue):0\",\n\t\t\tMethodName = $\"DataSource_WithBaseReturn\",\n\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"EnumerableDataSourceDrivenTests.DataSource_WithBaseReturn failed to initialize\", exception),\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 22,\n\t\t});\n\t}\n\treturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Source Generated Member Information Base Class in C#\nDESCRIPTION: Abstract base class defining the core structure for source generated member information. Contains required members for attributes, name and type along with equality comparison functionality.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class SourceGeneratedMemberInformation : System.IEquatable<TUnit.Core.SourceGeneratedMemberInformation>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of your compiler.\", true)]\n    protected SourceGeneratedMemberInformation() { }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Attribute[] Attributes { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string Name { get; init; }\n    public abstract System.Type Type { get; init; }\n    public virtual bool Equals(TUnit.Core.SourceGeneratedMemberInformation? other) { }\n    public override int GetHashCode() { }\n    protected virtual bool PrintMembers(System.Text.StringBuilder stringBuilder) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ClassHookContext in C#\nDESCRIPTION: This C# class represents the context for class-level hooks within the TUnit framework, inheriting from `TUnit.Core.Context`. It provides information about the test class, including its type (`ClassType`), the number of tests within it (`TestCount`), and a list of individual test contexts (`Tests`). It also offers access to the current class hook context via a static property `Current`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n    public class ClassHookContext : TUnit.Core.Context\n    {\n        public System.Type ClassType { get; init; }\n        public int TestCount { get; }\n        public System.Collections.Generic.List<TUnit.Core.TestContext> Tests { get; init; }\n        public new static TUnit.Core.ClassHookContext? Current { get; }\n        public override bool Equals(object? obj) { }\n        public override int GetHashCode() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Initializing and Registering TUnit Priority Filtering Tests in C#\nDESCRIPTION: This snippet defines the PriorityFilteringTests class with a static Initialise method to register the test source. It implements the ITestSource interface to collect test metadata.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/PriorityFilteringTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class PriorityFilteringTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new PriorityFilteringTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n```\n\n----------------------------------------\n\nTITLE: Initializing Unit Tests with TUnit in C#\nDESCRIPTION: This snippet shows how to initialize a unit test using TUnit's `SourceRegistrar` by registering a new instance of `EnumMemberNamesTests`. It is required to have the TUnit.Core extension installed. The static `Initialise` method is used to set up the test registration.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/EnumMemberNamesTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new EnumMemberNamesTests());\n\t}\n```\n\n----------------------------------------\n\nTITLE: Adding Test Metadata Node for Successful Test Initialization\nDESCRIPTION: Creates and adds a TestMetadata node containing test configuration, arguments, and execution details for a successfully initialized test case.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\nnodes.Add(new TestMetadata<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>\n{\n    TestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS1:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.ClassTupleDataSourceDrivenTests(int,string,bool).DataSource_TupleMethod(int,string,bool):0\",\n    TestClassArguments = [classArg, classArg1, classArg2],\n    TestMethodArguments = [methodArg, methodArg1, methodArg2],\n    TestClassProperties = [propertyArg, propertyArg1, propertyArg2, propertyArg3],\n    CurrentRepeatAttempt = 0,\n    RepeatLimit = 0,\n    ResettableClassFactory = resettableClassFactory,\n    TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_TupleMethod(methodArg, methodArg1, methodArg2)),\n    TestFilePath = @\"\",\n    TestLineNumber = 24,\n    TestMethod = testInformation,\n    TestBuilderContext = testBuilderContext\n});\n```\n\n----------------------------------------\n\nTITLE: Collecting BeforeTest Hooks with TestContext in TUnit\nDESCRIPTION: Method that collects instance hooks for execution before tests with context. Defines a hook for the SetupWithContext method that accepts a TestContext parameter.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeTests.Test.verified.txt#2025-04-22_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t{\n\t\t\tClassType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\tName = \"SetupWithContext\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"testContext\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.SetupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"BeforeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"BeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"SetupTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Non-Generic Delegate Assertion Condition Base Class in TUnit (C#)\nDESCRIPTION: This abstract class provides a non-generic base for assertion conditions implemented using delegates. It inherits from the generic `DelegateAssertCondition<object?, System.Exception>`, providing a default implementation for `object?` actual values and `System.Exception`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_42\n\nLANGUAGE: csharp\nCODE:\n```\n    public abstract class DelegateAssertCondition : TUnit.Assertions.AssertConditions.DelegateAssertCondition<object?, System.Exception>\n    {\n        protected DelegateAssertCondition() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining and Executing Nullable Byte Argument Tests in C#\nDESCRIPTION: This C# snippet demonstrates the setup and execution of unit tests for the 'Test2' method within a class called NullableByteArgumentTests. Various TUnit components, including SourceGeneratedMethodInformation and TestBuilderContext, are leveraged to manage test contexts and factories. The snippet outlines the use of nullable byte arguments in testing scenarios, handling both non-nullable and nullable byte inputs.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/NullableByteArgumentTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nType = typeof(global::TUnit.TestProject.NullableByteArgumentTests),\nAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"NullableByteArgumentTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n{\nName = \"NullableByteArgumentTests\",\nAttributes = [],\n}),\nName = \"NullableByteArgumentTests\",\nNamespace = \"TUnit.TestProject\",\nAttributes = [],\nParameters = [],\nProperties = [],\n}),\n};\n\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.NullableByteArgumentTests? classInstance = null;\nobject?[]? classInstanceArguments = null;\nclassInstanceArguments = [];\n\nbyte methodArg = (byte)1;\nbyte? methodArg1 = (byte)1;\n\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.NullableByteArgumentTests>(() => \nnew global::TUnit.TestProject.NullableByteArgumentTests()\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.NullableByteArgumentTests>\n{\nTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NullableByteArgumentTests.Test2(byte,byte?):0\",\nTestClassArguments = [],\nTestMethodArguments = [methodArg, methodArg1],\nTestClassProperties = [],\nCurrentRepeatAttempt = 0,\nRepeatLimit = 0,\nResettableClassFactory = resettableClassFactory,\nTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Test2(methodArg, methodArg1)),\nTestFilePath = @\"\",\nTestLineNumber = 12,\nTestMethod = testInformation,\nTestBuilderContext = testBuilderContext,\n});\nresettableClassFactory = resettableClassFactoryDelegate();\ntestBuilderContext = new();\ntestBuilderContextAccessor.Current = testBuilderContext;\n}\ncatch (global::System.Exception exception)\n{\nnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.NullableByteArgumentTests>\n{\nTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NullableByteArgumentTests.Test2(byte,byte?):0\",\nMethodName = $\"Test2\",\nException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"NullableByteArgumentTests.Test2 failed to initialize\", exception),\nTestFilePath = @\"\",\nTestLineNumber = 12,\n});\n}\nreturn nodes;\n}\nprivate global::System.Collections.Generic.List<TestMetadata> Tests1(string sessionId)\n{\nglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\nvar classDataIndex = 0;\nvar testMethodDataIndex = 0;\ntry\n{\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\nType = typeof(global::TUnit.TestProject.NullableByteArgumentTests),\nName = \"Test2\",\nGenericTypeCount = 0,\nReturnType = typeof(void),\nAttributes = \n[\nnew global::TUnit.Core.TestAttribute(),\nnew global::TUnit.Core.ArgumentsAttribute((byte)1, (byte)1),\nnew global::TUnit.Core.ArgumentsAttribute((byte)1, null)\n],\nParameters = \n[\nnew global::TUnit.Core.SourceGeneratedParameterInformation<byte>\n{\nName = \"byte1\",\nAttributes = [],\n},\nnew global::TUnit.Core.SourceGeneratedParameterInformation<byte?>\n{\nName = \"byte2\",\nAttributes = [],\n},\n],\nClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.NullableByteArgumentTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n{\nType = typeof(global::TUnit.TestProject.NullableByteArgumentTests),\nAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"NullableByteArgumentTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n{\nName = \"NullableByteArgumentTests\",\nAttributes = [],\n}),\nName = \"NullableByteArgumentTests\",\nNamespace = \"TUnit.TestProject\",\nAttributes = [],\nParameters = [],\nProperties = [],\n}),\n};\n\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.NullableByteArgumentTests? classInstance = null;\nobject?[]? classInstanceArguments = null;\nclassInstanceArguments = [];\n\nbyte methodArg = (byte)1;\nbyte? methodArg1 = (byte?)(null);\n\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.NullableByteArgumentTests>(() => \nnew global::TUnit.TestProject.NullableByteArgumentTests()\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.NullableByteArgumentTests>\n{\nTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS1:TUnit.TestProject.NullableByteArgumentTests.Test2(byte,byte?):0\",\nTestClassArguments = [],\nTestMethodArguments = [methodArg, methodArg1],\nTestClassProperties = [],\nCurrentRepeatAttempt = 0,\nRepeatLimit = 0,\nResettableClassFactory = resettableClassFactory,\nTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Test2(methodArg, methodArg1)),\nTestFilePath = @\"\",\nTestLineNumber = 12,\nTestMethod = testInformation,\nTestBuilderContext = testBuilderContext,\n});\nresettableClassFactory = resettableClassFactoryDelegate();\ntestBuilderContext = new();\ntestBuilderContextAccessor.Current = testBuilderContext;\n}\ncatch (global::System.Exception exception)\n{\nnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.NullableByteArgumentTests>\n{\nTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS1:TUnit.TestProject.NullableByteArgumentTests.Test2(byte,byte?):0\",\nMethodName = $\"Test2\",\nException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"NullableByteArgumentTests.Test2 failed to initialize\", exception),\nTestFilePath = @\"\",\nTestLineNumber = 12,\n});\n}\nreturn nodes;\n}\n}\n```\n\n----------------------------------------\n\nTITLE: IWorkerService Interface Definition in C#\nDESCRIPTION: An interface for worker services in the Playwright testing framework, providing methods for async disposal and resetting of worker state.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IWorkerService\n{\n    System.Threading.Tasks.Task DisposeAsync();\n    System.Threading.Tasks.Task ResetAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ContextTest Class for Playwright Testing in C#\nDESCRIPTION: This class extends BrowserTest and provides methods for context setup and configuration.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class ContextTest : TUnit.Playwright.BrowserTest\n{\n    public ContextTest() { }\n    public Microsoft.Playwright.IBrowserContext Context { get; }\n    public virtual Microsoft.Playwright.BrowserNewContextOptions ContextOptions(TUnit.Core.TestContext testContext) { }\n    [TUnit.Core.Before(TUnit.Core.HookType.Test, \"\", 0)]\n    public System.Threading.Tasks.Task ContextSetup(TUnit.Core.TestContext testContext) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing String Assertion Extensions in C#\nDESCRIPTION: Defines extension methods for string assertions, including 'DoesNotStartWith' with overloads for case-sensitive and case-insensitive comparisons.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_64\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> DoesNotStartWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> DoesNotStartWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"stringComparison\")] string doNotPopulateThisValue2 = null) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ContextTest with Playwright in C#\nDESCRIPTION: This snippet defines the \"ContextTest\" class, which extends \"BrowserTest\" in C#. The class provides browser context management features including context options and setup tasks. It is designed for handling tasks specific to browser context configurations during tests in Playwright.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class ContextTest : TUnit.Playwright.BrowserTest\n    {\n        public ContextTest() { }\n        public Microsoft.Playwright.IBrowserContext Context { get; }\n        public virtual Microsoft.Playwright.BrowserNewContextOptions ContextOptions(TUnit.Core.TestContext testContext) { }\n        [TUnit.Core.Before(TUnit.Core.HookType.Test, \"\", 0)]\n        public System.Threading.Tasks.Task ContextSetup(TUnit.Core.TestContext testContext) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Registering SetupTest Hook With ClassHookContext Parameter Using TUnit Source Generator in C#\nDESCRIPTION: This snippet registers a before-class test hook for TUnit, passing a ClassHookContext parameter to the setup method. It uses a source-generated partial class with a static initializer to ensure registration. The hook exposes metadata about the BeforeAllSetUpWithContext method, including its required context parameter, and is executed through a default executor. Dependencies include TUnit.Core and a SetupTests class with BeforeAllSetUpWithContext; expected use is initialization logic requiring context before all tests in the class.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeAllTests.Test.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_SetupTests : global::TUnit.Core.Interfaces.SourceGenerator.IClassHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_SetupTests();\n\t\tSourceRegistrar.RegisterClassHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.BeforeClassHookMethod\n\t\t\t{\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\t\tName = \"BeforeAllSetUpWithContext\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.ClassHookContext>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"context\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.SetupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"BeforeAllTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"BeforeAllTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"SetupTests\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.BeforeTests.SetupTests.BeforeAllSetUpWithContext(context)),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tFilePath = @\"\",\n\t\t\t\t\tLineNumber = 56,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\tAssemblyAttributes = [],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\t\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterClassHooks(string sessionId)\n\t\t{\n\t\t\treturn\n\t\t\t[\n\t\t\t];\n\t\t}\n\t}\n\n```\n\n----------------------------------------\n\nTITLE: Collecting Test-Level Hooks for TUnit - C#\nDESCRIPTION: Defines a partial class implementing test hook collection methods for TUnit, providing hooks to be run before or after each test. The CollectBeforeTestHooks method returns a hook for running the 'BeforeEach2' method of AssemblyBase2 as an async Task, with relevant metadata and attributes. Required dependencies are TUnit.Core namespaces and test context types. All returned hooks are described with precise type, parameter, attribute, and assembly information.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyBeforeTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t];\n}\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t];\n}\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t{\n\t\t\tClassType = typeof(global::TUnit.TestProject.BeforeTests.AssemblyBase2),\n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.AssemblyBase2),\n\t\t\t\tName = \"BeforeEach2\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.AssemblyBase2\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.AssemblyBase2),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AssemblyBeforeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"AssemblyBeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"AssemblyBase2\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.BeforeTests.AssemblyBase2)classInstance).BeforeEach2()),\n\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\tOrder = 0,\n\t\t\tMethodAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t],\n\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t},\n\t];\n}\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for Base_Derived1 Method with Derived1 Data Source\nDESCRIPTION: This method generates test metadata for the Base_Derived1 test method using Derived1 as the class data source. It sets up the test context, generates data, and creates TestMetadata objects for each data combination.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests2.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\t// ... (test setup code)\n\n\t\tvar classDataAttribute = new global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.ClassDataSourceDrivenTests2.Derived1>();\n\n\t\ttestBuilderContext.DataAttributes.Add(classDataAttribute);\n\n\t\tvar classArgGeneratedDataArray = classDataAttribute.GenerateDataSources(classArgDataGeneratorMetadata);\n\n\t\tforeach (var classArgGeneratedDataAccessor in classArgGeneratedDataArray)\n\t\t{\n\t\t\t// ... (test metadata generation code)\n\t\t}\n\t}\n\tcatch (global::System.Exception exception)\n\t{\n\t\t// ... (exception handling code)\n\t}\n\treturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for BooleanString Method in C#\nDESCRIPTION: This snippet creates test metadata for the BooleanString method with different boolean arguments (null, false, true). It sets up the test execution context, including class instantiation and method invocation.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n    Type = typeof(global::TUnit.TestProject.DataDrivenTests),\n    Name = \"BooleanString\",\n    GenericTypeCount = 0,\n    ReturnType = typeof(void),\n    Attributes = \n    [\n        new global::TUnit.Core.TestAttribute(),\n        new global::TUnit.Core.ArgumentsAttribute(null),\n        new global::TUnit.Core.ArgumentsAttribute(false),\n        new global::TUnit.Core.ArgumentsAttribute(true)\n    ],\n    Parameters = \n    [\n        new global::TUnit.Core.SourceGeneratedParameterInformation<bool?>\n        {\n            Name = \"value\",\n            Attributes = [],\n        },\n    ],\n    Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n    {\n        Type = typeof(global::TUnit.TestProject.DataDrivenTests),\n        Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n        {\n            Name = \"DataDrivenTests\",\n            Attributes = [],\n        }),\n        Name = \"DataDrivenTests\",\n        Namespace = \"TUnit.TestProject\",\n        Attributes = [],\n        Parameters = [],\n        Properties = [],\n    }),\n};\n```\n\n----------------------------------------\n\nTITLE: Defining ThrowsNothingAssertCondition Class in C#\nDESCRIPTION: Implements an assertion condition to check that no exception is thrown. Inherits from DelegateAssertCondition.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_72\n\nLANGUAGE: C#\nCODE:\n```\npublic class ThrowsNothingAssertCondition<TActual> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<TActual, System.Exception>\n{\n    public ThrowsNothingAssertCondition() { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering BeforeTest Hooks with Timeout and Parameter Support in TUnit Source Generator - C#\nDESCRIPTION: This snippet extends the test setup hook registration by including a TimeoutAttribute and support for a CancellationToken parameter in the method signature. It uses reflection metadata to describe the attributes and parameters of a setup method, and wraps the invocation to handle cancellation tokens. The ModuleInitializer ensures proper registration, and the setup method is limited to a 30,000 ms timeout when executed in TUnit's test lifecycle.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeAllTests.Test.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_SetupTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_SetupTests();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\t\tName = \"Setup\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test),\n\t\t\t\t\t\tnew global::TUnit.Core.TimeoutAttribute(30_000)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.SetupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"BeforeAllTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"BeforeAllTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"SetupTests\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.BeforeTests.SetupTests)classInstance).Setup(cancellationToken)),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test),\n\t\t\t\t\tnew global::TUnit.Core.TimeoutAttribute(30_000)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t},\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Generating Matrix Tests for AutoGenerateBools Method in C#\nDESCRIPTION: This code snippet generates matrix tests for the AutoGenerateBools method in the MatrixTests class. It creates test cases combining string inputs with boolean values.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MatrixTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.MatrixTests),\n\tName = \"AutoGenerateBools\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute(),\n\t\tnew global::TUnit.Core.MatrixDataSourceAttribute()\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"str\",\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.MatrixAttribute(\"A\", \"B\", \"C\")\n\t\t\t],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t{\n\t\t\tName = \"boolean\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.MatrixTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t{\n\t\tType = typeof(global::TUnit.TestProject.MatrixTests),\n\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"MatrixTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t{\n\t\t\tName = \"MatrixTests\",\n\t\t\tAttributes = [],\n\t\t}),\n\t\tName = \"MatrixTests\",\n\t\tNamespace = \"TUnit.TestProject\",\n\t\tAttributes = [],\n\t\tParameters = [],\n\t\tProperties = [],\n\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: Creating TestMetadata for ClassAndMethodArgumentsTests in C#\nDESCRIPTION: This snippet creates a TestMetadata object for a specific test method in the ClassAndMethodArgumentsTests class. It sets up the test context, arguments, and factories for class and method execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassAndMethodArgumentsTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nnodes.Add(new TestMetadata<global::TUnit.TestProject.ClassAndMethodArgumentsTests>\n{\n\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{classDataIndex}:CL-ARGS0:global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.ClassAndMethodArgumentsTests(string).WithMethodLevel(string):0\",\n\tTestClassArguments = [classArg],\n\tTestMethodArguments = [methodArg],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.WithMethodLevel(methodArg)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 11,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Method Information with String Argument Attributes in C#\nDESCRIPTION: This code creates detailed method information including test attributes and parameters. It demonstrates how the framework handles various string argument formats including escape sequences, raw strings, and multi-line strings in test attributes.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/StringArgumentTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.StringArgumentTests),\n\tName = \"Normal\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(void),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute(),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\"),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(@\"\\\"),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(@\"\\t\"),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\\t\"),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\\\\t\"),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\\\\\\t\"),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\\\\\\\\t\"),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(        \"\"\"\n        Hello\n        World\n        \"\"\"\n)\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"s\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n```\n\n----------------------------------------\n\nTITLE: Registering Integer Argument Test in TUnit (C#)\nDESCRIPTION: This snippet implements the registration and metadata assembly for a TUnit test method that accepts an integer argument. It defines metadata describing the method, sets up context and class instancing through resettable lazy factories, and adds the test to the collection. Dependencies include TUnit.Core and TUnit.Core.SourceGenerated classes. It expects a sessionId input and returns a list of TestMetadata with argument values set to 1. Handles failed initialization via exception handling.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/NumberArgumentTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class NumberArgumentTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new NumberArgumentTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.NumberArgumentTests),\n\t\t\t\tName = \"Int\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(1)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"i\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.NumberArgumentTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.NumberArgumentTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"NumberArgumentTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"NumberArgumentTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"NumberArgumentTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.NumberArgumentTests? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tclassInstanceArguments = [];\n\n\t\t\tint methodArg = 1;\n\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.NumberArgumentTests>(() => \n\t\t\tnew global::TUnit.TestProject.NumberArgumentTests()\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.NumberArgumentTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NumberArgumentTests.Int(int):0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Int(methodArg)),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 5,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.NumberArgumentTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NumberArgumentTests.Int(int):0\",\n\t\t\t\tMethodName = $\"Int\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"NumberArgumentTests.Int failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 5,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Registering and Collecting TUnit Assembly Hooks for AssemblyBase3 in C#\nDESCRIPTION: This auto-generated C# partial class `Hooks_AssemblyBase3` implements `IAssemblyHookSource` to manage assembly-level hooks for `TUnit.TestProject.AfterTests.AssemblyBase3`. It uses `[ModuleInitializer]` to register itself via `SourceRegistrar`. The `CollectAfterAssemblyHooks` method retrieves static methods marked with `[After(HookType.Assembly)]`, specifically finding `AfterAll3`. Other collection methods return empty lists, indicating no other assembly hooks were found for this class.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyAfterTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_AssemblyBase3 : global::TUnit.Core.Interfaces.SourceGenerator.IAssemblyHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_AssemblyBase3();\n\t\tSourceRegistrar.RegisterAssemblyHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectBeforeEveryAssemblyHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectAfterEveryAssemblyHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectBeforeAssemblyHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectAfterAssemblyHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.AfterAssemblyHookMethod\n\t\t\t{ \n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase3),\n\t\t\t\tName = \"AfterAll3\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Assembly)\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.AssemblyBase3\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase3),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AssemblyAfterTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"AssemblyAfterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"AssemblyBase3\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.AssemblyBase3.AfterAll3()),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tFilePath = @\"\",\n\t\t\t\tLineNumber = 35,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Assembly)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\tAssemblyAttributes = [],\n\t\t\t},\n\t\t];\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EnumerableAllExpectedFuncAssertCondition for TUnit Collection Assertions (C#)\nDESCRIPTION: Defines the `EnumerableAllExpectedFuncAssertCondition` class within the Collections namespace, inheriting from `BaseAssertCondition`. This generic condition is designed to assert that all elements (`TInner`) within an `IEnumerable<TInner>` collection (`TActual`) satisfy a specific condition (likely defined via a function, though the constructor isn't shown).\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_36\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace TUnit.Assertions.AssertConditions.Collections\n{\n    public class EnumerableAllExpectedFuncAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n        where TActual : System.Collections.Generic.IEnumerable<TInner>\n    {\n```\n\n----------------------------------------\n\nTITLE: Defining Property or Method Accessor in C#\nDESCRIPTION: A utility class for accessing properties or methods of objects. It provides a generic interface for interacting with object members in a type-safe way.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_47\n\nLANGUAGE: C#\nCODE:\n```\npublic class PropertyOrMethodAccessor<TActual>\n{\n    public PropertyOrMethodAccessor() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting BeforeTest Hooks Without Parameters in TUnit\nDESCRIPTION: Method that collects instance hooks for execution before tests. Defines a hook for the Setup method without parameters that returns a Task.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeTests.Test.verified.txt#2025-04-22_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t{\n\t\t\tClassType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\tName = \"Setup\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.SetupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"BeforeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"BeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"SetupTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.BeforeTests.SetupTests)classInstance).Setup()),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t},\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Registering TUnit AfterEveryTest Hook Source (GlobalBase1) in C#\nDESCRIPTION: This auto-generated C# code defines a partial class `Hooks_GlobalBase1` implementing `ITestHookSource`. It uses a `ModuleInitializer` to register itself with `SourceRegistrar`. The `CollectAfterEveryTestHooks` method provides metadata for the static `AfterAll1` method from `TUnit.TestProject.AfterTests.GlobalBase1` as an `AfterTestHookMethod`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticAfterEachTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_GlobalBase1 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_GlobalBase1();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.AfterTestHookMethod\n\t\t\t{ \n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.GlobalBase1),\n\t\t\t\tName = \"AfterAll1\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterEveryAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"context\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.GlobalBase1\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.GlobalBase1),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"GlobalStaticAfterEachTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"GlobalStaticAfterEachTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"GlobalBase1\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.GlobalBase1.AfterAll1(context)),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tFilePath = @\"\",\n\t\t\t\tLineNumber = 5,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterEveryAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\tAssemblyAttributes = [],\n\t\t\t},\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Registering SetupTest Hook with No Parameters Using TUnit Source Generator in C# (Old Signature)\nDESCRIPTION: This snippet demonstrates a before-class test hook registered for TUnit that invokes a SetupTests method called BeforeAllSetUp with no parameters except for implicit context, using source generation. The hook and containing class are registered with TUnit's SourceRegistrar through a static initializer. The setup method is invoked asynchronously via the AsyncConvert helper, and hook metadata including order, file path, and attributes is generated for runtime execution. Dependencies include TUnit.Core, TUnit.TestProject.BeforeTests, and an implementation of SetupTests.BeforeAllSetUp. No parameters are required for this setup method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeAllTests.Test.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.SetupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"BeforeAllTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"BeforeAllTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"SetupTests\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.BeforeTests.SetupTests.BeforeAllSetUp()),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tFilePath = @\"\",\n\t\t\t\tLineNumber = 50,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\tAssemblyAttributes = [],\n\t\t\t},\n```\n\n----------------------------------------\n\nTITLE: Defining Log Levels Enum in C#\nDESCRIPTION: Defines an enumeration LogLevel for various logging levels in TUnit, ranging from Trace to Critical, including a None option.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_66\n\nLANGUAGE: C#\nCODE:\n```\npublic enum LogLevel\n{\n    Trace = 0,\n    Debug = 1,\n    Information = 2,\n    Warning = 3,\n    Error = 4,\n    Critical = 5,\n    None = 6,\n}\n```\n\n----------------------------------------\n\nTITLE: TestAssemblyJson Class for Test Assembly Serialization\nDESCRIPTION: JSON model class representing a test assembly with its contained test classes. This is used for serializing test assembly information for reporting and data exchange purposes.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class TestAssemblyJson : System.IEquatable<TUnit.Engine.Json.TestAssemblyJson>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public TestAssemblyJson() { }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string? AssemblyName { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Engine.Json.TestClassJson[] Classes { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Exception Handling for Test Initialization in C#\nDESCRIPTION: This snippet shows how the framework handles exceptions that occur during test initialization. It creates a FailedTestMetadata object that captures the exception information and registers it in the test collection.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenTests>\n\t{\n\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.MethodDataSourceDrivenTests.DataSource_WithBaseReturn(TUnit.TestProject.MethodDataSourceDrivenTests.BaseValue):0\",\n\t\tMethodName = $\"DataSource_WithBaseReturn\",\n\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"MethodDataSourceDrivenTests.DataSource_WithBaseReturn failed to initialize\", exception),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 53,\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Test Method: Test\nDESCRIPTION: This snippet shows the registration of a test method named 'Test' in the InheritedTestsFromDifferentProjectTests class. It includes test metadata creation and exception handling for initialization failures.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/InheritedTestsFromDifferentProjectTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.InheritedTestsFromDifferentProjectTests),\n\tName = \"Test\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(void),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute()\n\t],\n\tParameters = [],\n\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.InheritedTestsFromDifferentProjectTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t{\n\t\t// ... (class information)\n\t}),\n};\n\n// ... (test metadata creation and registration)\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.InheritedTestsFromDifferentProjectTests>\n{\n\tTestId = $\"TUnit.TestProject.InheritedTestsFromDifferentProjectTests.Test:0\",\n\t// ... (other metadata properties)\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Expected Exception Delegate Assertion Condition Base Class in TUnit (C#)\nDESCRIPTION: This abstract generic class serves as a base for delegate-based assertions specifically designed to check for the occurrence of a particular exception type (`TException`). It inherits from `DelegateAssertCondition<object?, System.Exception>`, indicating it operates on a generic object input but focuses on exception analysis.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_46\n\nLANGUAGE: csharp\nCODE:\n```\n    public abstract class ExpectedExceptionDelegateAssertCondition<TException> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<object?, System.Exception>\n    {\n        protected ExpectedExceptionDelegateAssertCondition() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Method Data Source with Cancellation Token in C#\nDESCRIPTION: Implements test method execution configuration with data source support and error handling. Contains logic for test initialization, execution context setup, and failure metadata generation when tests fail to initialize.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenWithCancellationTokenTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nRepeatLimit = 0,\nResettableClassFactory = resettableClassFactory,\nTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.MyTest(methodData, cancellationToken)),\nTestFilePath = @\"\",\nTestLineNumber = 10,\nTestMethod = testInformation,\nTestBuilderContext = testBuilderContext,\n});\nresettableClassFactory = resettableClassFactoryDelegate();\ntestBuilderContext = new();\ntestBuilderContextAccessor.Current = testBuilderContext;\n}\n}\ncatch (global::System.Exception exception)\n{\nnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests>\n{\nTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS5:{testMethodDataIndex}:TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests.MyTest(int,System.Threading.CancellationToken):0\",\nMethodName = $\"MyTest\",\nException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"MethodDataSourceDrivenWithCancellationTokenTests.MyTest failed to initialize\", exception),\nTestFilePath = @\"\",\nTestLineNumber = 10,\n});\n}\nreturn nodes;\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract DataSourceGeneratorAttribute<T1..T5> in C#\nDESCRIPTION: This C# abstract attribute `DataSourceGeneratorAttribute<T1, T2, T3, T4, T5>` acts as a base for TUnit data sources providing quintuplets of data types (T1 to T5). Extending `TestDataAttribute` and implementing `IDataAttribute`, it mandates the implementation of `GenerateDataSources` in derived classes. This method uses `DataGeneratorMetadata` to produce an enumerable of functions, each returning a `ValueTuple<T1, T2, T3, T4, T5>`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\n    public abstract class DataSourceGeneratorAttribute<T1, T2, T3, T4, T5> : TUnit.Core.TestDataAttribute, TUnit.Core.IDataAttribute\n    {\n        protected DataSourceGeneratorAttribute() { }\n        public abstract System.Collections.Generic.IEnumerable<System.Func<System.ValueTuple<T1, T2, T3, T4, T5>>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata);\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Collection Assertions in C#\nDESCRIPTION: Extension methods for asserting collection properties including count, distinct items, and single item checks. Supports both IEnumerable<T> and ImmutableArray<T> collections.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_146\n\nLANGUAGE: C#\nCODE:\n```\npublic static class HasExtensions {\n    public static TUnit.Assertions.Extensions.EnumerableCount<System.Collections.Generic.IEnumerable<TInner>, TInner> HasCount<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }\n    public static TUnit.Assertions.Extensions.EnumerableCount<System.Collections.Immutable.ImmutableArray<TInner>, TInner> HasCount<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> HasDistinctItems<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ThrowsAsync Assertion for Task (Any Exception) in C#\nDESCRIPTION: This overload of the static `ThrowsAsync` method asserts that awaiting the provided `Task` delegate results in any `System.Exception`. It returns a `Task<System.Exception>` containing the caught exception. The `CallerArgumentExpression` captures the source expression.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\n        public static System.Threading.Tasks.Task<System.Exception> ThrowsAsync(System.Threading.Tasks.Task @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression(\"delegate\")] string? doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract DisplayNameFormatterAttribute in C#\nDESCRIPTION: This abstract C# attribute `DisplayNameFormatterAttribute` serves as a base for customizing how test names are displayed in TUnit results. It inherits from `TUnitAttribute` and implements `IEventReceiver` and `ITestDiscoveryEventReceiver`. Derived classes must implement `FormatDisplayName` to provide the formatting logic based on the `TestContext`. It also hooks into the test discovery process via `OnTestDiscovery`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\n    [System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method, Inherited=false)]\n    public abstract class DisplayNameFormatterAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver\n    {\n        protected DisplayNameFormatterAttribute() { }\n        public int Order { get; }\n        protected abstract string FormatDisplayName(TUnit.Core.TestContext testContext);\n        public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Class Hook Source for Base1\nDESCRIPTION: Auto-generated class implementing IClassHookSource interface for Base1 test class, handling class-level hooks including BeforeAll1 method registration\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeAllTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_Base1 : global::TUnit.Core.Interfaces.SourceGenerator.IClassHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_Base1();\n\t\tSourceRegistrar.RegisterClassHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Creating Test Metadata Instances with TUnit in C#\nDESCRIPTION: This snippet initializes test context using TUnit's API to create and manage test instances for the EnumMemberNamesTests class. It sets up test metadata and manages test execution. Dependencies include TUnit.Core and TUnit.TestProject.Bugs._1432 namespaces. Key parameters include method arguments and context settings. Inputs are from predefined variables, and outputs are test nodes. There are constrained by specific TUnit class and method dependencies.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/EnumMemberNamesTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.Bugs._1432.EnumMemberNamesTests? classInstance = null;\nobject?[]? classInstanceArguments = null;\nclassInstanceArguments = [];\n\nstring methodArg = \"C\";\n\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._1432.EnumMemberNamesTests>(() => \nnew global::TUnit.TestProject.Bugs._1432.EnumMemberNamesTests()\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._1432.EnumMemberNamesTests>\n{\n\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS2:TUnit.TestProject.Bugs._1432.EnumMemberNamesTests.SomeTest(string):0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [methodArg],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.SomeTest(methodArg)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 5,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\nresettableClassFactory = resettableClassFactoryDelegate();\ntestBuilderContext = new();\ntestBuilderContextAccessor.Current = testBuilderContext;\n}\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._1432.EnumMemberNamesTests>\n\t{\n\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS2:TUnit.TestProject.Bugs._1432.EnumMemberNamesTests.SomeTest(string):0\",\n\t\tMethodName = $\"SomeTest\",\n\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"EnumMemberNamesTests.SomeTest failed to initialize\", exception),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 5,\n\t});\n}\nreturn nodes;\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for ArrayT Method Data Source in C#\nDESCRIPTION: Method that generates test metadata for tests using the ArrayT data source. It creates test nodes for each data item, configures class instances, and handles initialization exceptions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenWithCancellationTokenTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests4(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests),\n\t\t\tName = \"MyTest\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"T\"),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"FuncT\"),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"EnumerableT\"),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"EnumerableFuncT\"),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"ArrayT\"),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"ArrayFuncT\")\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t{\n\t\t\t\t\tName = \"value\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t{\n\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"MethodDataSourceDrivenWithCancellationTokenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"MethodDataSourceDrivenWithCancellationTokenTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"MethodDataSourceDrivenWithCancellationTokenTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute(\"Usage\", \"TUnit0046:Return a `Func<T>` rather than a `<T>`\")\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tforeach (var methodDataAccessor in global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests.ArrayT())\n\t\t\t\t{\n\t\t\t\t\ttestMethodDataIndex++;\n\t\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\t\tvar methodData = methodDataAccessor;\n\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests>(() => \n\t\t\t\t\tnew global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests()\n\t\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests>\n\t\t\t\t\t{\n\t\t\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS4:{testMethodDataIndex}:TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests.MyTest(int,System.Threading.CancellationToken):0\",\n\t\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\t\tTestMethodArguments = [methodData],\n\t\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.MyTest(methodData, cancellationToken)),\n\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\tTestLineNumber = 10,\n\t\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t\t});\n\t\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\t\ttestBuilderContext = new();\n\t\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS4:{testMethodDataIndex}:TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests.MyTest(int,System.Threading.CancellationToken):0\",\n\t\t\t\t\tMethodName = $\"MyTest\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"MethodDataSourceDrivenWithCancellationTokenTests.MyTest failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 10,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n```\n\n----------------------------------------\n\nTITLE: Creating Test Metadata and Class Initialization with Tuple Parameters in C#\nDESCRIPTION: This code snippet initializes test metadata for ClassTupleDataSourceDrivenTests. It extracts tuple values from data sources, creates class instances with those values, initializes properties with tuple data, and registers the test in a collection for execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests),\n\tName = \"DataSource_TupleMethod\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(void),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute(),\n\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\"),\n\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t{\n\t\t\tName = \"value\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"value2\",\n\t\t\tAttributes = [],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t{\n\t\t\tName = \"value3\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.ClassTupleDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t{\n\t\tType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests),\n\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"ClassTupleDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t{\n\t\t\tName = \"ClassTupleDataSourceDrivenTests\",\n\t\t\tAttributes = [],\n\t\t}),\n\t\tName = \"ClassTupleDataSourceDrivenTests\",\n\t\tNamespace = \"TUnit.TestProject\",\n\t\tAttributes = \n\t\t[\n\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\"),\n\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n\t\t],\n\t\tParameters = \n\t\t[\n\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t{\n\t\t\t\tName = \"value\",\n\t\t\t\tAttributes = [],\n\t\t\t},\n\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t{\n\t\t\t\tName = \"value2\",\n\t\t\t\tAttributes = [],\n\t\t\t},\n\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t\t{\n\t\t\t\tName = \"value3\",\n\t\t\t\tAttributes = [],\n\t\t\t},\n\t\t],\n\t\tProperties = \n\t\t[\n\t\t\tnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t{\n\t\t\t\tType = typeof((int, string, bool)),\n\t\t\t\tName = \"Property1\",\n\t\t\t\tIsStatic = false,\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n\t\t\t\t],\n\t\t\t},\n\t\t\tnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t{\n\t\t\t\tType = typeof((int, string, bool)),\n\t\t\t\tName = \"Property2\",\n\t\t\t\tIsStatic = false,\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n\t\t\t\t],\n\t\t\t},\n\t\t\tnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t{\n\t\t\t\tType = typeof((int Number, string Word, bool Flag)),\n\t\t\t\tName = \"Property3\",\n\t\t\t\tIsStatic = false,\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n\t\t\t\t],\n\t\t\t},\n\t\t\tnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t{\n\t\t\t\tType = typeof((int Number, string Word, bool Flag)),\n\t\t\t\tName = \"Property4\",\n\t\t\t\tIsStatic = false,\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n\t\t\t\t],\n\t\t\t},\n\t\t],\n\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: Class and Method Data Source Attribute Metadata Initialization for TUnit - C#\nDESCRIPTION: This snippet demonstrates the setup of data source and attribute metadata for both the test class and method within the TUnit framework. It shows use of multiple MethodDataSourceAttributes with different data providers, establishing links to tuple and named tuple data sources. No external parameters are needed at this stage, but the attributes connect to actual data provider methods in the test class. The snippet ensures both class and method-level attributes are accurately configured for discovery and execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=TupleMethod_testMethodName=TupleMethod.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nClassAttributes = [ new global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n{\n    \n} ],\nAssemblyAttributes = [  ],\nDataAttributes = [  ],\nTestBuilderContext = testBuilderContext,\n```\n\n----------------------------------------\n\nTITLE: Defining Simple After Class Hook Method\nDESCRIPTION: Implementation of the CollectAfterClassHooks method that returns a hook for the AfterAllCleanUp method with no parameters. This represents the simplest form of a cleanup method that executes after all tests in a class have completed.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterTests.Test.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.CleanupTests.AfterAllCleanUp()),\nHookExecutor = DefaultExecutor.Instance,\nOrder = 0,\nFilePath = @\"\",\nLineNumber = 50,\nMethodAttributes = \n[\n\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Class)\n],\nClassAttributes = [],\nAssemblyAttributes = [],\n```\n\n----------------------------------------\n\nTITLE: Defining MatrixTest with Matrix Data Source and Attributes (TUnit, C#)\nDESCRIPTION: This code defines metadata for the 'MatrixTest' method, a unit test supporting matrix-style parameterization through the MatrixDataSourceAttribute and MatrixAttribute. It sets up method and parameter metadata, including timeout, category, and attribute-based data generation instructions. Inputs are the static class/type/attribute metadata as well as declared parameter matrices. Outputs are TestMetadata objects configured for matrix parameter combinations. TUnit.Core and its extensions are required.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/TimeoutCancellationTokenTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.TimeoutCancellationTokenTests),\n\tName = \"MatrixTest\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute(),\n\t\tnew global::TUnit.Core.MatrixDataSourceAttribute(),\n\t\tnew global::TUnit.Core.TimeoutAttribute(5_000),\n\t\tnew global::TUnit.Core.CategoryAttribute(\"Blah\")\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t{\n\t\t\tName = \"value\",\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.MatrixAttribute(1, 2, 3)\n\t\t\t],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t{\n\t\t\tName = \"cancellationToken\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.TimeoutCancellationTokenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t{\n\t\tType = typeof(global::TUnit.TestProject.TimeoutCancellationTokenTests),\n\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"TimeoutCancellationTokenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t{\n\t\t\tName = \"TimeoutCancellationTokenTests\",\n\t\t\tAttributes = [],\n\t\t}),\n\t\tName = \"TimeoutCancellationTokenTests\",\n\t\tNamespace = \"TUnit.TestProject\",\n\t\tAttributes = \n\t\t[\n\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"DataSource\"),\n\t\t\tnew global::TUnit.Core.CategoryAttribute(\"Timeout Cancellation Token Tests\")\n\t\t],\n\t\tParameters = \n\t\t[\n\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t{\n\t\t\t\tName = \"value\",\n\t\t\t\tAttributes = [],\n\t\t\t},\n\t\t],\n\t\tProperties = [],\n\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing UInt Test Source Generator in C#\nDESCRIPTION: Source-generated implementation for handling unsigned integer test cases with argument validation and metadata collection. Includes test initialization and execution logic.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ConstantArgumentsTests.Test.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class ConstantArgumentsTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new ConstantArgumentsTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing String Argument Test Metadata Generation in C#\nDESCRIPTION: Generates test metadata for string argument tests including various escape sequences and null values. The code sets up test information, handles test initialization, and configures test execution with different string argument patterns.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/StringArgumentTests.Test.verified.txt#2025-04-22_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.StringArgumentTests),\n\tName = \"Nullable\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(void),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute(),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\"),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(@\"\\\"),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(@\"\\t\"),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\\t\"),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\\\\t\"),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\\\\\\t\"),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\\\\\\\\t\"),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(null)\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"s\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.StringArgumentTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t{\n\t\tType = typeof(global::TUnit.TestProject.StringArgumentTests),\n\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"StringArgumentTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t{\n\t\t\tName = \"StringArgumentTests\",\n\t\t\tAttributes = [],\n\t\t}),\n\t\tName = \"StringArgumentTests\",\n\t\tNamespace = \"TUnit.TestProject\",\n\t\tAttributes = [],\n\t\tParameters = [],\n\t\tProperties = [],\n\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for Float Argument in C#\nDESCRIPTION: This snippet creates test metadata for a method with a float argument. It sets up the test context, creates a resettable class factory, and adds the test metadata to a list of nodes.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/NumberArgumentTests.TestDE.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nfloat methodArg = 1.1f;\n\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.NumberArgumentTests>(() => \nnew global::TUnit.TestProject.NumberArgumentTests()\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.NumberArgumentTests>\n{\n\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NumberArgumentTests.Float(float):0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [methodArg],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Float(methodArg)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 19,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing EnumHasFlagAssertCondition in C#\nDESCRIPTION: Assertion condition that checks if an enum value has a specific flag set. Used for bitwise enum assertions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_103\n\nLANGUAGE: C#\nCODE:\n```\n    public class EnumHasFlagAssertCondition<TEnum> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TEnum>\n        where TEnum : System.Enum\n    {\n        public EnumHasFlagAssertCondition(TEnum expected) { }\n        protected override string GetExpectation() { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Not-Contains Assertion for Enumerable Collections in C#\nDESCRIPTION: Classes for asserting that an enumerable collection does not contain specific items. Both predicate-based and value-based assertions are provided with support for custom equality comparison.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumerableNotContainsExpectedFuncAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n    where TActual : System.Collections.Generic.IEnumerable<TInner>\n{\n    public EnumerableNotContainsExpectedFuncAssertCondition(System.Func<TInner, bool> matcher, string? matcherString) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n\npublic class EnumerableNotContainsExpectedValueAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TInner>\n    where TActual : System.Collections.Generic.IEnumerable<TInner>\n{\n    public EnumerableNotContainsExpectedValueAssertCondition(TInner expected, System.Collections.Generic.IEqualityComparer<TInner?>? equalityComparer) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TInner? inner) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FailureLocation Class for TUnit Assertions (C#)\nDESCRIPTION: Defines the `FailureLocation` class used within TUnit assertions to pinpoint where a failure occurred, typically within collections or sequences. It implements `IEquatable` and provides properties for the actual value, expected value, and the position (index) of the failure.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\n    public class FailureLocation : System.IEquatable<TUnit.Assertions.AssertConditions.FailureLocation>\n    {\n        public FailureLocation() { }\n        public object? ActualValue { get; }\n        public object? ExpectedValue { get; }\n        public long Position { get; }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Runner in C#\nDESCRIPTION: Static class providing the main entry point for running tests with command line arguments\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic static class TUnitRunner\n{\n    public static System.Threading.Tasks.Task<int> RunTests(params string[] args) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DisplayNameAttribute in C#\nDESCRIPTION: This sealed C# attribute `DisplayNameAttribute` allows setting a custom, static display name for a test method in TUnit. It inherits from `DisplayNameFormatterAttribute`. The constructor takes the desired display name string, and the overridden `FormatDisplayName` method returns this string.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\n    [System.AttributeUsage(System.AttributeTargets.Method, Inherited=false)]\n    public sealed class DisplayNameAttribute : TUnit.Core.DisplayNameFormatterAttribute\n    {\n        public DisplayNameAttribute(string displayName) { }\n        protected override string FormatDisplayName(TUnit.Core.TestContext testContext) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Collecting Test Metadata with Arguments in C#\nDESCRIPTION: This snippet collects test metadata by creating a list of `TestMetadata` objects, each configured with different method arguments. It demonstrates constructing test information, handling potential exceptions, and setting up test contexts and factories. The system requires the TUnit.Core library and supports input session IDs, while outputting a list of `TestMetadata` objects.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/EnumMemberNamesTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1432.EnumMemberNamesTests),\n\t\t\tName = \"SomeTest\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"A\"),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"B\"),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"C\")\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t{\n\t\t\t\t\tName = \"value\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._1432.EnumMemberNamesTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1432.EnumMemberNamesTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"EnumMemberNamesTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"EnumMemberNamesTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"EnumMemberNamesTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._1432\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n\t\t};\n\n\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\tglobal::TUnit.TestProject.Bugs._1432.EnumMemberNamesTests? classInstance = null;\n\t\tobject?[]? classInstanceArguments = null;\n\t\tclassInstanceArguments = [];\n\n\t\tstring methodArg = \"A\";\n\n\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._1432.EnumMemberNamesTests>(() => \n\t\tnew global::TUnit.TestProject.Bugs._1432.EnumMemberNamesTests()\n\t\t, sessionId, testBuilderContext);\n\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._1432.EnumMemberNamesTests>\n\t\t{\n\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.Bugs._1432.EnumMemberNamesTests.SomeTest(string):0\",\n\t\t\tTestClassArguments = [],\n\t\t\tTestMethodArguments = [methodArg],\n\t\t\tTestClassProperties = [],\n\t\t\tCurrentRepeatAttempt = 0,\n\t\t\tRepeatLimit = 0,\n\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.SomeTest(methodArg)),\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 5,\n\t\t\tTestMethod = testInformation,\n\t\t\tTestBuilderContext = testBuilderContext,\n\t\t});\n\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\ttestBuilderContext = new();\n\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t}\n\tcatch (global::System.Exception exception)\n\t{\n\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._1432.EnumMemberNamesTests>\n\t\t{\n\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.Bugs._1432.EnumMemberNamesTests.SomeTest(string):0\",\n\t\t\tMethodName = $\"SomeTest\",\n\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"EnumMemberNamesTests.SomeTest failed to initialize\", exception),\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 5,\n\t\t});\n\t}\n\treturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Initializing Source-Generated TUnit Test Source in C#\nDESCRIPTION: This auto-generated C# code defines a file-scoped partial class `Inherited_InheritedTestsFromDifferentProjectTests` implementing `ITestSource` for TUnit. It uses a `ModuleInitializer` (`Initialise`) to register itself with the `SourceRegistrar`. The `CollectTests` method calls `Tests0` to gather `TestMetadata` for tests within `TUnit.TestProject.InheritedTestsFromDifferentProjectTests`. The `Tests0` method specifically generates metadata for the `BaseTest` method, sets up its context (`TestBuilderContext`), creates a lazy factory (`ResettableLazy`) for the test class instance, and adds the `TestMetadata` to a list, handling potential initialization errors by adding `FailedTestMetadata` instead.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/InheritedTestsFromDifferentProjectTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Inherited_InheritedTestsFromDifferentProjectTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new Inherited_InheritedTestsFromDifferentProjectTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.InheritedTestsFromDifferentProjectTests),\n\t\t\t\tName = \"BaseTest\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute()\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.InheritedTestsFromDifferentProjectTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.InheritedTestsFromDifferentProjectTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"InheritedTestsFromDifferentProjectTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"InheritedTestsFromDifferentProjectTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"InheritedTestsFromDifferentProjectTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.InheritsTestsAttribute()\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.InheritedTestsFromDifferentProjectTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.InheritedTestsFromDifferentProjectTests>(() => \n\t\t\t\tnew global::TUnit.TestProject.InheritedTestsFromDifferentProjectTests()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.InheritedTestsFromDifferentProjectTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"TUnit.TestProject.InheritedTestsFromDifferentProjectTests.BaseTest:0\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.BaseTest()),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 7,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.InheritedTestsFromDifferentProjectTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"TUnit.TestProject.InheritedTestsFromDifferentProjectTests.BaseTest:0\",\n\t\t\t\t\tMethodName = $\"BaseTest\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"InheritedTestsFromDifferentProjectTests.BaseTest failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 7,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: GitHubReporter for GitHub Integration\nDESCRIPTION: A reporter class that integrates with GitHub, implementing multiple interfaces to receive test execution data and produce formatted output suitable for GitHub environments.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\npublic class GitHubReporter : Microsoft.Testing.Platform.Extensions.IExtension, Microsoft.Testing.Platform.Extensions.TestHost.IDataConsumer, Microsoft.Testing.Platform.Extensions.TestHost.ITestApplicationLifecycleCallbacks, Microsoft.Testing.Platform.Extensions.TestHost.ITestHostExtension, TUnit.Engine.Framework.IFilterReceiver\n{\n    public GitHubReporter(Microsoft.Testing.Platform.Extensions.IExtension extension) { }\n    public System.Type[] DataTypesConsumed { get; }\n    public string Description { get; }\n    public string DisplayName { get; }\n    public string? Filter { get; set; }\n    public string Uid { get; }\n    public string Version { get; }\n    public System.Threading.Tasks.Task AfterRunAsync(int exitCode, System.Threading.CancellationToken cancellation) { }\n    public System.Threading.Tasks.Task BeforeRunAsync(System.Threading.CancellationToken cancellationToken) { }\n    public System.Threading.Tasks.Task ConsumeAsync(Microsoft.Testing.Platform.Extensions.Messages.IDataProducer dataProducer, Microsoft.Testing.Platform.Extensions.Messages.IData value, System.Threading.CancellationToken cancellationToken) { }\n    public System.Threading.Tasks.Task<bool> IsEnabledAsync() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Delegate Assertion Conditions in C#\nDESCRIPTION: Defines a CompleteWithinAssertCondition class for asserting that a delegate completes within a specified timespan, along with extension methods for delegate assertions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\npublic class CompleteWithinAssertCondition<TActual> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<TActual>\n{\n    public CompleteWithinAssertCondition(System.TimeSpan timeSpan) { }\n    public override System.TimeSpan? WaitFor { get; }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n\npublic static class DelegateExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableDelegateAssertionBuilder CompletesWithin(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource, System.TimeSpan timeSpan, [System.Runtime.CompilerServices.CallerArgumentExpression(\"timeSpan\")] string? doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> CompletesWithin<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueDelegateSource<TActual> delegateSource, System.TimeSpan timeSpan, [System.Runtime.CompilerServices.CallerArgumentExpression(\"timeSpan\")] string? doNotPopulateThisValue = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Resetting Class Factories and Managing Builder Context Access in TUnit - C#\nDESCRIPTION: This snippet reassigns the class factory by invoking 'resettableClassFactoryDelegate', initializes a new test builder context, and sets the current context via an accessor. Dependencies include a factory delegate and a context accessor. Inputs are the delegate and context accessor; the output is an updated test context ready for use, with potential constraints around stateful factory objects.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests2085.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nresettableClassFactory = resettableClassFactoryDelegate();\ntestBuilderContext = new();\ntestBuilderContextAccessor.Current = testBuilderContext;\n```\n\n----------------------------------------\n\nTITLE: String Manipulation Extensions in TUnit\nDESCRIPTION: Extension methods for string manipulation including showing new lines and truncating strings with ellipsis.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_153\n\nLANGUAGE: C#\nCODE:\n```\npublic static string ShowNewLines(this string value) { }\npublic static string TruncateWithEllipsis(this string value, int maxLength) { }\n```\n\n----------------------------------------\n\nTITLE: Collecting Various Assembly Hooks in C#\nDESCRIPTION: These methods collect different types of assembly hooks (before every, after every, before, and after). Most return empty lists except for the after assembly hooks, which includes a hook for AfterAllCleanUpWithContext.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyAfterTests.Test.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectBeforeEveryAssemblyHooks(string sessionId)\n{\n\treturn\n\t[\n\t];\n}\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectAfterEveryAssemblyHooks(string sessionId)\n{\n\treturn\n\t[\n\t];\n}\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectBeforeAssemblyHooks(string sessionId)\n{\n\treturn\n\t[\n\t];\n}\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectAfterAssemblyHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.AfterAssemblyHookMethod\n\t\t{ \n\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),\n\t\t\tName = \"AfterAllCleanUpWithContext\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Assembly)\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.AssemblyHookContext>\n\t\t\t\t{\n\t\t\t\t\tName = \"context\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.AssemblyCleanupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AssemblyAfterTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"AssemblyAfterTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"AssemblyCleanupTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n},\n\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.AssemblyCleanupTests.AfterAllCleanUpWithContext(context)),\n\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\tOrder = 0,\n\t\t\tFilePath = @\"\",\n\t\t\tLineNumber = 56,\n\t\t\tMethodAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Assembly)\n\t\t\t],\n\t\t\tClassAttributes = [],\n\t\t\tAssemblyAttributes = [],\n\t\t},\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing OrAssertionException in C#\nDESCRIPTION: Custom exception class for handling OR assertion failures, extending AggregateException to collect multiple assertion errors.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_81\n\nLANGUAGE: C#\nCODE:\n```\npublic class OrAssertionException : System.AggregateException\n{\n    public OrAssertionException(System.Collections.Generic.IEnumerable<System.Exception> exceptions) { }\n    public override string Message { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Building SourceGeneratedClassInformation Properties and Attributes - TUnit - C#\nDESCRIPTION: Defines the 'ClassTupleDataSourceDrivenTests' as a TUnit test class, attaching tuple-based MethodDataSource attributes and specifying parameters and properties for the test class. Requires TUnit.Core. The snippet shows metadata construction for reflection-based test generation, including tuple-typed properties and their respective data source bindings. Inputs include data source method names and tuples, outputting a class metadata object for TUnit's test engine.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nName = \"ClassTupleDataSourceDrivenTests\",\nNamespace = \"TUnit.TestProject\",\nAttributes = \n[\n\tnew global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\"),\n\tnew global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n],\nParameters = \n[\n\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t{\n\t\tName = \"value\",\n\t\tAttributes = [],\n\t},\n\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t{\n\t\tName = \"value2\",\n\t\tAttributes = [],\n\t},\n\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t{\n\t\tName = \"value3\",\n\t\tAttributes = [],\n\t},\n],\nProperties = \n[\nnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t{\n\t\tType = typeof((int, string, bool)),\n\t\tName = \"Property1\",\n\t\tIsStatic = false,\n\t\tAttributes = \n\t\t[\n\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n\t\t],\n\t},\nnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t{\n\t\tType = typeof((int, string, bool)),\n\t\tName = \"Property2\",\n\t\tIsStatic = false,\n\t\tAttributes = \n\t\t[\n\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n\t\t],\n\t},\nnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t{\n\t\tType = typeof((int Number, string Word, bool Flag)),\n\t\tName = \"Property3\",\n\t\tIsStatic = false,\n\t\tAttributes = \n\t\t[\n\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n\t\t],\n\t},\nnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t{\n\t\tType = typeof((int Number, string Word, bool Flag)),\n\t\tName = \"Property4\",\n\t\tIsStatic = false,\n\t\tAttributes = \n\t\t[\n\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n\t\t],\n\t},\n],\n```\n\n----------------------------------------\n\nTITLE: Handling Assertion Results with C#\nDESCRIPTION: Defines the 'AssertionResult' class, which encapsulates the outcomes of assertions, including passed states and failure messages. It supports additional functionality for combining results, asynchronous operations, and more complex failure scenarios, including handling interpolated strings.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class AssertionResult { public bool IsPassed { get; } public string Message { get; } public static TUnit.Assertions.AssertConditions.AssertionResult Passed { get; } public TUnit.Assertions.AssertConditions.AssertionResult And(TUnit.Assertions.AssertConditions.AssertionResult other) { } public System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> OrAsync(System.Func<System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult>> otherResult) { } public TUnit.Assertions.AssertConditions.AssertionResult OrFailIf(bool isFailed, [System.Runtime.CompilerServices.InterpolatedStringHandlerArgument(\"isFailed\")] TUnit.Assertions.AssertConditions.AssertionResult.InterpolatedStringHandler stringHandler) { } public TUnit.Assertions.AssertConditions.AssertionResult OrFailIf(bool isFailed, string message) { } public static TUnit.Assertions.AssertConditions.AssertionResult Fail(string message) { } public static TUnit.Assertions.AssertConditions.AssertionResult FailIf(bool isFailed, [System.Runtime.CompilerServices.InterpolatedStringHandlerArgument(\"isFailed\")] TUnit.Assertions.AssertConditions.AssertionResult.InterpolatedStringHandler stringHandler) { } public static TUnit.Assertions.AssertConditions.AssertionResult FailIf(bool isFailed, string message) { } public static System.Threading.Tasks.Task<TUnit.Assertions.AssertConditions.AssertionResult> op_Implicit(TUnit.Assertions.AssertConditions.AssertionResult result) { } public static System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> op_Implicit(TUnit.Assertions.AssertConditions.AssertionResult result) { } [System.Runtime.CompilerServices.InterpolatedStringHandler] public readonly struct InterpolatedStringHandler { public InterpolatedStringHandler(int literalLength, int formattedCount, bool isFailed, out bool enabled) { } public void AppendFormatted<T>(T? t) { } public void AppendFormatted<T>(T? t, string format) where T : System.IFormattable { } public void AppendLiteral(string s) { } } }\n```\n\n----------------------------------------\n\nTITLE: ContextTest Class Definition in C#\nDESCRIPTION: A test class for browser context testing that inherits from BrowserTest. Manages browser context instances and provides setup methods with context options.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class ContextTest : TUnit.Playwright.BrowserTest\n{\n    public ContextTest() { }\n    public Microsoft.Playwright.IBrowserContext Context { get; }\n    public virtual Microsoft.Playwright.BrowserNewContextOptions ContextOptions(TUnit.Core.TestContext testContext) { }\n    [TUnit.Core.Before(TUnit.Core.HookType.Test, \"\", 0)]\n    public System.Threading.Tasks.Task ContextSetup(TUnit.Core.TestContext testContext) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Class Hooks for Base1\nDESCRIPTION: Source-generated partial class implementing IClassHookSource interface for Base1 test class. Defines before/after class hooks and registration logic.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_Base1 : global::TUnit.Core.Interfaces.SourceGenerator.IClassHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_Base1();\n\t\tSourceRegistrar.RegisterClassHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Creating Resettable Class Factory for Test Instances in C#\nDESCRIPTION: Initializes a resettable lazy factory for TimeoutCancellationTokenTests instances. This factory allows test objects to be recreated with consistent state between test runs.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/TimeoutCancellationTokenTests.Test.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.TimeoutCancellationTokenTests>(() => \nnew global::TUnit.TestProject.TimeoutCancellationTokenTests(classArg)\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n```\n\n----------------------------------------\n\nTITLE: Processing Generated Test Data and Creating Test Metadata in C#\nDESCRIPTION: Iterates through generated test data, creates test metadata for each data item, and prepares test execution lambdas. This loop handles creating multiple test variants based on the provided data sources.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1821.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nforeach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\n{\n\ttestMethodDataIndex++;\n\tvar methodArgGeneratedData = methodArgGeneratedDataAccessor();\n\tstring methodArg = global::TUnit.Core.Helpers.CastHelper.Cast<string>(methodArgGeneratedData[0]);\n\n\n\tnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._1821.Tests>\n\t{\n\t\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.Bugs._1821.MyData>:{classDataIndex}:CL-GAC0:global::TUnit.Core.MatrixDataSourceAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.Bugs._1821.Tests(TUnit.TestProject.Bugs._1821.MyData).MatrixDataSource(string):0\",\n\t\tTestClassArguments = [classArgGeneratedData],\n\t\tTestMethodArguments = [methodArg],\n\t\tTestClassProperties = [],\n\t\tCurrentRepeatAttempt = 0,\n\t\tRepeatLimit = 0,\n\t\tResettableClassFactory = resettableClassFactory,\n\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.MatrixDataSource(methodArg)),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 16,\n\t\tTestMethod = testInformation,\n\t\tTestBuilderContext = testBuilderContext,\n\t});\n\tresettableClassFactory = resettableClassFactoryDelegate();\n\ttestBuilderContext = new();\n\ttestBuilderContextAccessor.Current = testBuilderContext;\n}\n```\n\n----------------------------------------\n\nTITLE: Exception Handling for Test Initialization in C#\nDESCRIPTION: This snippet shows the exception handling mechanism for test initialization failures. It creates a FailedTestMetadata object with details about the failed test initialization, including the exception and test method information.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n    nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenTests>\n    {\n        TestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS0:{testMethodDataIndex}:TUnit.TestProject.MethodDataSourceDrivenTests.EnumerableFuncArrayTest(string[]):0\",\n        MethodName = $\"EnumerableFuncArrayTest\",\n        Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"MethodDataSourceDrivenTests.EnumerableFuncArrayTest failed to initialize\", exception),\n        TestFilePath = @\"\",\n        TestLineNumber = 59,\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Hook Attribute for Test Lifecycle in C#\nDESCRIPTION: Attribute class for marking test lifecycle hooks with optional ordering. Used to define methods that execute at specific points in the test lifecycle.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic class HookAttribute : TUnit.Core.TUnitAttribute\n{\n    public int Order { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing TUnit Data Source Test Generator in C#\nDESCRIPTION: Defines a partial class that implements ITestSource interface to register and collect tests. It includes a module initializer and methods to generate test metadata based on data source attributes.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceClassCombinedWithDataSourceMethodTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class DataSourceClassCombinedWithDataSourceMethod : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new DataSourceClassCombinedWithDataSourceMethod());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\t..Tests0(sessionId),\n\t\t\t..Tests1(sessionId),\n\t\t\t..Tests2(sessionId),\n\t\t\t..Tests3(sessionId),\n\t\t\t..Tests4(sessionId),\n\t\t\t..Tests5(sessionId),\n\t\t\t..Tests6(sessionId),\n\t\t\t..Tests7(sessionId),\n\t\t\t..Tests8(sessionId),\n\t\t];\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Cases with String Arguments in C#\nDESCRIPTION: Implements test case generation with string arguments, including special handling for escape sequences like \\t. The code creates test metadata with different string inputs and handles test initialization failures.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/StringArgumentTests.Test.verified.txt#2025-04-22_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests4(string sessionId)\n{\n    global::System.Collections.Generic.List<TestMetadata> nodes = [];\n    var classDataIndex = 0;\n    var testMethodDataIndex = 0;\n    try\n    {\n        var testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n        {\n            Type = typeof(global::TUnit.TestProject.StringArgumentTests),\n            Name = \"Nullable\",\n            GenericTypeCount = 0,\n            ReturnType = typeof(void),\n            Attributes = \n            [\n                new global::TUnit.Core.TestAttribute(),\n                new global::TUnit.Core.ArgumentsAttribute(\"\"),\n                new global::TUnit.Core.ArgumentsAttribute(@\"\\\"),\n                new global::TUnit.Core.ArgumentsAttribute(@\"\\t\"),\n                new global::TUnit.Core.ArgumentsAttribute(\"\\t\"),\n                new global::TUnit.Core.ArgumentsAttribute(\"\\\\t\"),\n                new global::TUnit.Core.ArgumentsAttribute(\"\\\\\\t\"),\n                new global::TUnit.Core.ArgumentsAttribute(\"\\\\\\\\t\"),\n                new global::TUnit.Core.ArgumentsAttribute(null)\n            ]\n        }\n    }\n    catch (global::System.Exception exception)\n    {\n        nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.StringArgumentTests>\n        {\n            TestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS4:TUnit.TestProject.StringArgumentTests.Nullable(string):0\",\n            MethodName = $\"Nullable\",\n            Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"StringArgumentTests.Nullable failed to initialize\", exception),\n            TestFilePath = @\"\",\n            TestLineNumber = 24\n        });\n    }\n    return nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating an Alternate Parameterized TUnit Test Node for Test3 with Different Arguments in C#\nDESCRIPTION: This snippet is functionally similar to the previous Test3 node, but creates a distinct parameterized test instance using a different set of argument values (e.g., 'bar', 2, false), corresponding to a separate ArgumentsAttribute in the TUnit metadata. It supports data-driven tests by enumerating all variations for a test method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/CustomDisplayNameTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nnodes.Add(new TestMetadata<global::TUnit.TestProject.CustomDisplayNameTests>\n{\n\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS1:TUnit.TestProject.CustomDisplayNameTests.Test3(string,int,bool):0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [methodArg, methodArg1, methodArg2],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Test3(methodArg, methodArg1, methodArg2)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 26,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing AfterClassHooks with No Parameters\nDESCRIPTION: Auto-generated class implementing IClassHookSource interface to register class-level hooks, specifically for 'AfterAllCleanUp' method with no parameters. The code handles hook registration via ModuleInitializer and provides methods to collect hooks of different types.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterAllTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_CleanupTests : global::TUnit.Core.Interfaces.SourceGenerator.IClassHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_CleanupTests();\n\t\tSourceRegistrar.RegisterClassHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.AfterClassHookMethod\n\t\t\t{\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.CleanupTests),\n\t\t\t\t\tName = \"AfterAllCleanUp\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.CleanupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.CleanupTests),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AfterAllTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"AfterAllTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"CleanupTests\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.CleanupTests.AfterAllCleanUp()),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tFilePath = @\"\",\n\t\t\t\t\tLineNumber = 50,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\tAssemblyAttributes = [],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: Registering Source-Generated Test Module in TUnit\nDESCRIPTION: Static initializer method that registers the DataSourceGeneratorTests class with TUnit's source registrar. This allows the framework to discover and execute the tests defined in this class.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.Typed.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tglobal::TUnit.Core.SourceRegistrar.Register(new DataSourceGeneratorTests());\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic Test Base Class in C#\nDESCRIPTION: Abstract base class for dynamic test creation with required members and test metadata building capabilities\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic abstract class DynamicTest : System.IEquatable<TUnit.Core.DynamicTest>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of your compiler.\", true)]\n    protected DynamicTest() { }\n    public System.Attribute[] Attributes { get; init; }\n    public System.Collections.Generic.Dictionary<string, object?>? Properties { get; init; }\n    public object?[]? TestClassArguments { get; init; }\n    public abstract System.Type TestClassType { get; }\n    public abstract string TestId { get; }\n    public object?[] TestMethodArguments { get; init; }\n    public string? TestName { get; init; }\n    public abstract System.Collections.Generic.IEnumerable<TUnit.Core.TestMetadata> BuildTestMetadatas();\n    public System.Attribute[] GetAttributes() { }\n    public static T Argument<T>() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ConvertedValueAssertionBuilder Generic Class in C#\nDESCRIPTION: This generic class represents a converted value assertion builder. It inherits from InvokableValueAssertionBuilder and takes an IValueSource and a ConvertToAssertCondition as parameters in its constructor.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_55\n\nLANGUAGE: C#\nCODE:\n```\npublic class ConvertedValueAssertionBuilder<TFromType, TToType> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TToType>\n{\n    public ConvertedValueAssertionBuilder(TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TFromType> source, TUnit.Assertions.AssertConditions.ConvertToAssertCondition<TFromType, TToType> convertToAssertCondition) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Registering ClassDataSourceDrivenTests2 Test Source\nDESCRIPTION: Initializes the ClassDataSourceDrivenTests2 class and registers it as a test source. This method is marked as a module initializer to ensure it runs when the module is loaded.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests2.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tglobal::TUnit.Core.SourceRegistrar.Register(new ClassDataSourceDrivenTests2());\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Executor Attributes in TUnit\nDESCRIPTION: A collection of attributes for configuring test execution behavior, including culture settings, hook executors, and thread model specifications. These attributes implement various interfaces for test registration and event handling.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_56\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\npublic class CultureAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestRegisteredEventReceiver\n{\n    public CultureAttribute(System.Globalization.CultureInfo cultureInfo) { }\n    public CultureAttribute(string cultureName) { }\n    public int Order { get; }\n    public System.Threading.Tasks.ValueTask OnTestRegistered(TUnit.Core.TestRegisteredContext context) { }\n}\npublic abstract class HookExecutorAttribute : TUnit.Core.TUnitAttribute\n{\n    public abstract System.Type HookExecutorType { get; }\n}\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\npublic sealed class HookExecutorAttribute<T> : TUnit.Core.Executors.HookExecutorAttribute\n    where T : TUnit.Core.Interfaces.IHookExecutor, new ()\n{\n    public HookExecutorAttribute() { }\n    public override System.Type HookExecutorType { get; }\n}\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\npublic class InvariantCultureAttribute : TUnit.Core.Executors.CultureAttribute\n{\n    public InvariantCultureAttribute() { }\n}\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\n[System.Runtime.Versioning.SupportedOSPlatform(\"windows\")]\npublic class STAThreadExecutorAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestRegisteredEventReceiver\n{\n    public STAThreadExecutorAttribute() { }\n    public int Order { get; }\n    public System.Threading.Tasks.ValueTask OnTestRegistered(TUnit.Core.TestRegisteredContext context) { }\n}\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\npublic sealed class TestExecutorAttribute<T> : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestRegisteredEventReceiver\n    where T : TUnit.Core.Interfaces.ITestExecutor, new ()\n{\n    public TestExecutorAttribute() { }\n    public int Order { get; }\n    public System.Threading.Tasks.ValueTask OnTestRegistered(TUnit.Core.TestRegisteredContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Tests5 Method Implementation for Test Discovery in C#\nDESCRIPTION: This method is similar to Tests4 but represents another test discovery implementation. It creates source-generated method information with test attributes and begins setting up the test context.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceClassCombinedWithDataSourceMethodTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests5(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod),\n\t\t\tName = \"DataSourceClassCombinedWithDataSourceMethodTest\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"One\"),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Two\"),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Three\")\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t{\n\t\t\t\t\tName = \"i\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataSourceClassCombinedWithDataSourceMethodTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"DataSourceClassCombinedWithDataSourceMethodTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"DataSourceClassCombinedWithDataSourceMethod\",\n\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"One\"),\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Two\"),\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Three\")\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"i\",\n```\n\n----------------------------------------\n\nTITLE: Defining TimeOnlyEqualsExpectedValueAssertCondition for TUnit TimeOnly Assertions (C#)\nDESCRIPTION: Defines the `TimeOnlyEqualsExpectedValueAssertCondition` class within the Chronology namespace for comparing `System.TimeOnly` values. It inherits from `ExpectedValueAssertCondition` and features a `SetTolerance` method using `System.TimeSpan` for allowing slight differences.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_32\n\nLANGUAGE: csharp\nCODE:\n```\n    public class TimeOnlyEqualsExpectedValueAssertCondition : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<System.TimeOnly, System.TimeOnly>\n    {\n        public TimeOnlyEqualsExpectedValueAssertCondition(System.TimeOnly expected) { }\n        protected override string GetExpectation() { }\n        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(System.TimeOnly actualValue, System.TimeOnly expectedValue) { }\n        public void SetTolerance(System.TimeSpan tolerance) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Creating Test Metadata with AutoFixtureGenerator in C#\nDESCRIPTION: This code snippet generates test metadata for a test method using the AutoFixtureGeneratorAttribute to create test data. It creates data for both class and method parameters, configures test execution context, and handles exceptions by creating a FailedInitializationTest entry.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests1(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testClassType = typeof(global::TUnit.TestProject.DataSourceGeneratorTests);\n\t\tvar methodInfo = global::TUnit.Core.Helpers.MethodInfoRetriever.GetMethodInfo(typeof(global::TUnit.TestProject.DataSourceGeneratorTests), \"GeneratedData_Method3\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]);\n\n\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\tvar classArgDataGeneratorMetadata = new DataGeneratorMetadata\n{\n   Type = TUnit.Core.Enums.DataGeneratorType.Parameters,\n   TestClassType = testClassType,\n   ParameterInfos = typeof(global::TUnit.TestProject.DataSourceGeneratorTests).GetConstructors().First().GetParameters(),\n   PropertyInfo = null,\n   TestBuilderContext = testBuilderContextAccessor,\n   TestSessionId = sessionId,\n};\n\t\tvar classDataAttribute = new global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute()\n{\n    \n};\n\n\t\tvar classArgGeneratedDataArray = classDataAttribute.GenerateDataSources(classArgDataGeneratorMetadata);\n\n\t\tforeach (var classArgGeneratedDataAccessor in classArgGeneratedDataArray)\n\t\t{\n\t\t\tclassDataIndex++;\n\t\t\tvar methodArgDataGeneratorMetadata = new DataGeneratorMetadata\n{\n   Type = TUnit.Core.Enums.DataGeneratorType.Parameters,\n   TestClassType = testClassType,\n   ParameterInfos = methodInfo.GetParameters(),\n   PropertyInfo = null,\n   TestBuilderContext = testBuilderContextAccessor,\n   TestSessionId = sessionId,\n};\n\t\t\tvar methodDataAttribute = new global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute()\n{\n    \n};\n\n\t\t\tvar methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\n\n\t\t\tforeach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\n\t\t\t{\n\t\t\t\ttestMethodDataIndex++;\n\t\t\t\tvar classArgGeneratedData = classArgGeneratedDataAccessor();\n\t\t\t\tglobal::System.Int32 classArg = classArgGeneratedData.Item1;\n\t\t\t\tglobal::System.String classArg1 = classArgGeneratedData.Item2;\n\t\t\t\tglobal::System.Boolean classArg2 = classArgGeneratedData.Item3;\n\n\n\t\t\t\tvar methodArgGeneratedData = methodArgGeneratedDataAccessor();\n\t\t\t\tglobal::System.Int32 methodArg = methodArgGeneratedData.Item1;\n\t\t\t\tglobal::System.String methodArg1 = methodArgGeneratedData.Item2;\n\t\t\t\tglobal::System.Boolean methodArg2 = methodArgGeneratedData.Item3;\n\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.DataSourceGeneratorTests>(() => \n\t\t\t\tnew global::TUnit.TestProject.DataSourceGeneratorTests(classArg, classArg1, classArg2)\n\t\t\t\t, sessionId, testBuilderContext);\n\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.DataSourceGeneratorTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute:{classDataIndex}:CL-GAC0:global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.DataSourceGeneratorTests(System.Int32,System.String,System.Boolean).GeneratedData_Method3(System.Int32,System.String,System.Boolean):0\",\n\t\t\t\t\tTestClassArguments = [classArg, classArg1, classArg2],\n\t\t\t\t\tTestMethodArguments = [methodArg, methodArg1, methodArg2],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tMethodInfo = methodInfo,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.GeneratedData_Method3(methodArg, methodArg1, methodArg2)),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 25,\n\t\t\t\t\tTestAttributes = [ new global::TUnit.Core.TestAttribute()\n{\n    \n}, new global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute()\n{\n    \n} ],\n\t\t\t\t\tClassAttributes = [ new global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<global::System.Int32, global::System.String, global::System.Boolean>()\n{\n    \n}, new global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute()\n{\n    \n} ],\n\t\t\t\t\tAssemblyAttributes = [  ],\n\t\t\t\t\tDataAttributes = [ classDataAttribute, methodDataAttribute ],\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t}\n\t}\n\tcatch (global::System.Exception exception)\n\t{\n\t\tnodes.Add(new FailedInitializationTest\n\t\t{\n\t\t\tTestId = $\"global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute:{classDataIndex}:CL-GAC0:global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.DataSourceGeneratorTests(System.Int32,System.String,System.Boolean).GeneratedData_Method3(System.Int32,System.String,System.Boolean):0\",\n\t\t\tTestClass = typeof(global::TUnit.TestProject.DataSourceGeneratorTests),\n\t\t\tReturnType = global::TUnit.Core.Helpers.MethodInfoRetriever.GetMethodInfo(typeof(global::TUnit.TestProject.DataSourceGeneratorTests), \"GeneratedData_Method3\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]).ReturnType,\n\t\t\tParameterTypeFullNames = [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)],\n\t\t\tTestName = \"GeneratedData_Method3\",\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 25,\n\t\t\tException = exception,\n\t\t});\n\t}\n\treturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring TUnit Implicit Usings in Project File\nDESCRIPTION: XML configuration to disable TUnit's implicit usings in the project file. This temporary setting prevents type clashes during migration and helps code fixers distinguish between xUnit and TUnit types.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/migration/xunit.md#2025-04-22_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n    <PropertyGroup>\n        <TUnitImplicitUsings>false</TUnitImplicitUsings>\n        <TUnitAssertionsImplicitUsings>false</TUnitAssertionsImplicitUsings>\n    </PropertyGroup>\n```\n\n----------------------------------------\n\nTITLE: Static Assertion Group Factory Methods\nDESCRIPTION: Provides static factory methods for creating different types of assertion groups. Supports various input types including actions, tasks, and value tasks with generic type support.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\npublic static class AssertionGroup\n{\n    public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<object?, TUnit.Assertions.AssertionBuilders.DelegateAssertionBuilder> For(System.Action value) { }\n    public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<object?, TUnit.Assertions.AssertionBuilders.AsyncDelegateAssertionBuilder> For(System.Func<System.Threading.Tasks.Task> value) { }\n    public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<TActual, TUnit.Assertions.AssertionBuilders.ValueAssertionBuilder<TActual>> For<TActual>(TActual value) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Method Factories and Contexts in TUnit - C#\nDESCRIPTION: This snippet sets up class and method factories, initializes test file context, and assigns delegates for asynchronous test method execution within the TUnit framework. It requires the AsyncConvert utility and expects test information objects to be defined. Key parameters include 'resettableClassFactory', 'testInformation', and 'testBuilderContext'. Output is the correct factory and context assignments used for subsequent test orchestration.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests2085.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nResettableClassFactory = resettableClassFactory,\nTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Float_SpecialConsts(methodArg)),\nTestFilePath = @\"\",\nTestLineNumber = 15,\nTestMethod = testInformation,\nTestBuilderContext = testBuilderContext,\n```\n\n----------------------------------------\n\nTITLE: TestingPlatformBuilderHook for Platform Integration\nDESCRIPTION: Static class that provides the integration point between TUnit and Microsoft Testing Platform by registering TUnit's extensions with the testing framework.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class TestingPlatformBuilderHook\n{\n    public static void AddExtensions(Microsoft.Testing.Platform.Builder.ITestApplicationBuilder testApplicationBuilder, string[] _) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering and Collecting TUnit Test Hooks for AssemblyBase3 in C#\nDESCRIPTION: This auto-generated C# partial class `Hooks_AssemblyBase3` implements `ITestHookSource` to manage test-level hooks for `TUnit.TestProject.AfterTests.AssemblyBase3`. It registers itself using `[ModuleInitializer]` and `SourceRegistrar`. The `CollectAfterTestHooks` method identifies instance methods marked with `[After(HookType.Test)]`, specifically finding `AfterEach3`. Other collection methods for before/after every test and before test hooks return empty lists.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyAfterTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_AssemblyBase3 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_AssemblyBase3();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase3),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase3),\n\t\t\t\t\tName = \"AfterEach3\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.AssemblyBase3\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase3),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AssemblyAfterTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"AssemblyAfterTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"AssemblyBase3\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.AfterTests.AssemblyBase3)classInstance).AfterEach3()),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Collecting Tests for ClassDataSourceDrivenTestsSharedKeyed in C#\nDESCRIPTION: This snippet defines a partial class ClassDataSourceDrivenTestsSharedKeyed that implements ITestSource. It includes methods for initialization and collecting test metadata for data-driven tests using ClassDataSourceAttribute with shared keyed data sources.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTestsSharedKeyed.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class ClassDataSourceDrivenTestsSharedKeyed : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new ClassDataSourceDrivenTestsSharedKeyed());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\t// ... (additional implementation details)\n\t}\n```\n\n----------------------------------------\n\nTITLE: Creating PlaywrightSkipAttribute Class in C#\nDESCRIPTION: Implements a \"PlaywrightSkipAttribute\" class used to mark tests for skipping based on platform or browser criteria. It establishes targets with flags for different environments, empowering selective test execution within the Playwright test suite.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class PlaywrightSkipAttribute : TUnit.Core.SkipAttribute\n    {\n        public PlaywrightSkipAttribute(params TUnit.Playwright.PlaywrightSkipAttribute.Targets[] combinations) { }\n        public TUnit.Core.TestContext? TestContext { get; set; }\n        public override System.Threading.Tasks.Task<bool> ShouldSkip(TUnit.Core.BeforeTestContext context) { }\n        [System.Flags]\n        public enum Targets : short\n        {\n            Windows = 1,\n            Linux = 2,\n            OSX = 4,\n            Chromium = 8,\n            Firefox = 16,\n            Webkit = 32,\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Collecting After Test Hooks for Base2 Class in C#\nDESCRIPTION: Defines methods within a TUnit hook source class to collect test lifecycle hooks. The `CollectAfterTestHooks` method returns a specific `InstanceHookMethod` representing the `AfterEach2` method from the `TUnit.TestProject.AfterTests.Base2` class, intended to run after each test within that class or derived classes. Other hook collection methods (`CollectAfterEveryTestHooks`, `CollectBeforeTestHooks`) return empty lists in this snippet.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterAllTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.AfterTests.Base2),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.Base2),\n\t\t\t\t\tName = \"AfterEach2\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.Base2\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.Base2),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AfterAllTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"AfterAllTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"Base2\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.AfterTests.Base2)classInstance).AfterEach2()),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: Adding Test Metadata Node in C#\nDESCRIPTION: Creates and adds a TestMetadata object to the nodes collection with test configuration, arguments, and execution details. Includes file path, line number, and method information for test tracking.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ArgsAsArrayTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nnodes.Add(new TestMetadata<global::TUnit.TestProject.ArgsAsArrayTests>\n{\n\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.ArgsAsArrayTests.Following_Non_Params(int,System.Collections.Generic.IEnumerable<string>):0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [methodArg, methodArg1],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Following_Non_Params(methodArg, methodArg1)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 45,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Registering Class-Level Setup Hooks - TUnit Source Generator - C#\nDESCRIPTION: This snippet comprises the registration and collection logic for class-level setup hooks in a test suite using TUnit. It features module initialization to register the hook source and methods to yield hooks that execute code before individual class runs. The snippet leverages TUnit.Core's SourceGeneratedMethodInformation and related classes. Input is typically the sessionId for identifying the test session. Outputs are collections of static hook metadata that represent setup steps at the class level, making use of reflection and code metadata for hook invocation.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_SetupTests : global::TUnit.Core.Interfaces.SourceGenerator.IClassHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_SetupTests();\n\t\tSourceRegistrar.RegisterClassHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.BeforeClassHookMethod\n\t\t\t{\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\t\tName = \"BeforeAllSetUp\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n```\n\n----------------------------------------\n\nTITLE: Generating Matrix Test Metadata in C#\nDESCRIPTION: Creates test metadata nodes for matrix-based tests including parameter information, data source attributes, and test execution context. Handles test initialization failures and generates appropriate metadata for both successful and failed cases.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MatrixTests.Test.verified.txt#2025-04-22_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nTestBuilderContext = testBuilderContextAccessor,\nTestInformation = testInformation,\nMembersToGenerate = \n[\n    new global::TUnit.Core.SourceGeneratedParameterInformation<int>\n    {\n        Name = \"item\",\n        Attributes = \n        [\n            new global::TUnit.Core.MatrixMethodAttribute<global::TUnit.TestProject.MatrixTests>(\"EnumerableMethod\")\n        ],\n    },\n    new global::TUnit.Core.SourceGeneratedParameterInformation<int>\n    {\n        Name = \"item2\",\n        Attributes = \n        [\n            new global::TUnit.Core.MatrixMethodAttribute<global::TUnit.TestProject.MatrixTests>(\"EnumerableMethod\")\n        ],\n    },\n],\nTestSessionId = sessionId,\nTestClassInstance = classInstance,\nClassInstanceArguments = classInstanceArguments,\n};\nvar methodDataAttribute = new global::TUnit.Core.MatrixDataSourceAttribute();\n\ntestBuilderContext.DataAttributes.Add(methodDataAttribute);\n\nvar methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\n\nforeach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\n{\n    testMethodDataIndex++;\n    classInstanceArguments = [];\n\n    var methodArgGeneratedData = methodArgGeneratedDataAccessor();\n    int methodArg = global::TUnit.Core.Helpers.CastHelper.Cast<int>(methodArgGeneratedData[0]);\n    int methodArg1 = global::TUnit.Core.Helpers.CastHelper.Cast<int>(methodArgGeneratedData[1]);\n    var resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.MatrixTests>(() => \n    new global::TUnit.TestProject.MatrixTests()\n    , sessionId, testBuilderContext);\n    var resettableClassFactory = resettableClassFactoryDelegate();\n\n\n    nodes.Add(new TestMetadata<global::TUnit.TestProject.MatrixTests>\n    {\n        TestId = $\"global::TUnit.Core.MatrixDataSourceAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.MatrixTests.Exclusion(int,int):0\",\n        TestClassArguments = [],\n        TestMethodArguments = [methodArg, methodArg1],\n        TestClassProperties = [],\n        CurrentRepeatAttempt = 0,\n        RepeatLimit = 0,\n        ResettableClassFactory = resettableClassFactory,\n        TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Exclusion(methodArg, methodArg1)),\n        TestFilePath = @\"\",\n        TestLineNumber = 149,\n        TestMethod = testInformation,\n        TestBuilderContext = testBuilderContext,\n    });\n    resettableClassFactory = resettableClassFactoryDelegate();\n    testBuilderContext = new();\n    testBuilderContextAccessor.Current = testBuilderContext;\n}\n}\ncatch (global::System.Exception exception)\n{\n    nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.MatrixTests>\n    {\n        TestId = $\"global::TUnit.Core.MatrixDataSourceAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.MatrixTests.Exclusion(int,int):0\",\n        MethodName = $\"Exclusion\",\n        Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"MatrixTests.Exclusion failed to initialize\", exception),\n        TestFilePath = @\"\",\n        TestLineNumber = 149,\n    });\n}\nreturn nodes;\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for ClassAndMethodArgumentsTests in C#\nDESCRIPTION: This snippet creates test metadata for the ClassAndMethodArgumentsTests class. It sets up class and method arguments, initializes test contexts, and handles potential exceptions during test setup.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassAndMethodArgumentsTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.ClassAndMethodArgumentsTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n{\n\tType = typeof(global::TUnit.TestProject.ClassAndMethodArgumentsTests),\n\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"ClassAndMethodArgumentsTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t{\n\t\tName = \"ClassAndMethodArgumentsTests\",\n\t\tAttributes = [],\n\t}),\n\tName = \"ClassAndMethodArgumentsTests\",\n\tNamespace = \"TUnit.TestProject\",\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.ArgumentsAttribute(\"1\"),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(\"2\")\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"arg1\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n\tProperties = [],\n}),\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Test Initialization in C# with TUnit Framework\nDESCRIPTION: This snippet handles exceptions that may occur during test initialization. It creates a FailedTestMetadata object with details about the failed initialization, including the test ID, method name, and the exception that occurred.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1889.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n    nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._1889.DerivedTest>\n    {\n        TestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.Bugs._1889.DerivedTest.Test3(bool):0\",\n        MethodName = $\"Test3\",\n        Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"DerivedTest.Test3 failed to initialize\", exception),\n        TestLineNumber = 18,\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Parallel Test Groups with TUnit in C#\nDESCRIPTION: This C# code snippet demonstrates how to define parallel test groups using the TUnit testing framework. The ParallelGroup attribute is applied to test classes to specify which tests can run in parallel based on their group. In the snippet, MyTestClass and MyTestClass2 are set up in different parallel groups, ensuring their tests run simultaneously only within their respective groups and not at the same time as tests from other groups. This configuration requires the TUnit.Core dependency.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/parallel-groups.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\n[ParallelGroup(\"Group1\")]\npublic class MyTestClass\n{\n    [Test]\n    public async Task MyTest()\n    {\n        \n    }\n\n    [Test]\n    public async Task MyTest2()\n    {\n        \n    }\n\n    [Test]\n    public async Task MyTest3()\n    {\n        \n    }\n}\n\n[ParallelGroup(\"Group2\")]\npublic class MyTestClass2\n{\n    [Test]\n    public async Task MyTest()\n    {\n        \n    }\n\n    [Test]\n    public async Task MyTest2()\n    {\n        \n    }\n\n    [Test]\n    public async Task MyTest3()\n    {\n        \n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Source Generated Test Source Class for MethodDataSourceDrivenTests (C#)\nDESCRIPTION: This C# code defines an auto-generated partial class `MethodDataSourceDrivenTests` within the `TUnit.SourceGenerated` namespace. It implements `ITestSource` for TUnit integration. A `ModuleInitializer` registers an instance of this class with `TUnit.Core.SourceRegistrar`. The `CollectTests` method aggregates test metadata by calling helper methods (`Tests0`, `Tests1`) specific to test methods within the original class.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class MethodDataSourceDrivenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new MethodDataSourceDrivenTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\t..Tests0(sessionId),\n\t\t\t..Tests1(sessionId),\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Collecting Test Metadata for DataSource_Method3 (Tests0) in TUnit (C#)\nDESCRIPTION: This C# method `Tests0` is part of the auto-generated test source infrastructure for TUnit. It specifically collects test metadata for the `DataSource_Method3` test, which is driven by a `MethodDataSourceAttribute` referencing `SomeMethod` with an argument `5`. The method initializes test information, retrieves the argument by calling `SomeMethod(5)`, prepares the test execution environment (context, class factory), and adds `TestMetadata` to a list, handling potential initialization errors by adding `FailedTestMetadata`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.MethodDataSourceDrivenTests),\n\t\t\t\tName = \"DataSource_Method3\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"SomeMethod\")\n\t\t\t\t\t{\n\t\t\t\t\t\tArguments = [5],\n},\n\t\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"SomeMethod\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tArguments = new object[] { 5 },\n}\n\t\t\t\t\t\t],\n\t\t\t\t\t\tParameters = \n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.MethodDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.MethodDataSourceDrivenTests),\n\t\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"MethodDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName = \"MethodDataSourceDrivenTests\",\n\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\tName = \"MethodDataSourceDrivenTests\",\n\t\t\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t\t}),\n};\n\n\t\t\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\t\t\tglobal::TUnit.TestProject.MethodDataSourceDrivenTests? classInstance = null;\n\t\t\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\t\t\tint methodArg = global::TUnit.TestProject.MethodDataSourceDrivenTests.SomeMethod(5);\n\t\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.MethodDataSourceDrivenTests>(() => \n\t\t\t\t\t\tnew global::TUnit.TestProject.MethodDataSourceDrivenTests()\n\t\t\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenTests>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.MethodDataSourceDrivenTests.DataSource_Method3(int):0\",\n\t\t\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_Method3(methodArg)),\n\t\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\t\tTestLineNumber = 33,\n\t\t\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\t\t\ttestBuilderContext = new();\n\t\t\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (global::System.Exception exception)\n\t\t\t\t\t{\n\t\t\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenTests>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.MethodDataSourceDrivenTests.DataSource_Method3(int):0\",\n\t\t\t\t\t\t\tMethodName = $\"DataSource_Method3\",\n\t\t\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"MethodDataSourceDrivenTests.DataSource_Method3 failed to initialize\", exception),\n\t\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\t\tTestLineNumber = 33,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn nodes;\n\t\t\t\t}\n```\n\n----------------------------------------\n\nTITLE: Registering Source-Generated Unit Tests with TUnit in C#\nDESCRIPTION: This snippet provides the partial class and module initializer that performs registration of the generated test source with the TUnit framework at module load. This enables automated test discovery for the tests defined in this partial class. It depends on TUnit.Core, and uses attributes to ensure the code is excluded from coverage and stack traces. The primary input is the static call to register the class, and there are no external outputs.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/TimeoutCancellationTokenTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class TimeoutCancellationTokenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new TimeoutCancellationTokenTests());\n\t}\n\n```\n\n----------------------------------------\n\nTITLE: Registering AfterClass Hooks for Base1 using Source Generation in C#\nDESCRIPTION: This auto-generated C# snippet defines a partial class `Hooks_Base1` that implements `IClassHookSource`. It uses a `ModuleInitializer` to register itself with the TUnit `SourceRegistrar`. The `CollectAfterClassHooks` method returns a list containing metadata for the `AfterAll1` static method from the `TUnit.TestProject.AfterTests.Base1` class, marked with the `[After(HookType.Class)]` attribute. Other hook collection methods return empty lists.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_Base1 : global::TUnit.Core.Interfaces.SourceGenerator.IClassHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_Base1();\n\t\tSourceRegistrar.RegisterClassHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.AfterClassHookMethod\n\t\t\t{\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.Base1),\n\t\t\t\t\tName = \"AfterAll1\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.Base1\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.Base1),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AfterTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"AfterTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"Base1\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.Base1.AfterAll1()),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tFilePath = @\"\",\n\t\t\t\t\tLineNumber = 5,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\tAssemblyAttributes = [],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: Initializing Test Source Implementation in C#\nDESCRIPTION: Defines a partial class implementing ITestSource interface for data-driven tests with module initialization and test collection functionality.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class DataDrivenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new DataDrivenTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\t..Tests0(sessionId),\n\t\t\t..Tests1(sessionId),\n\t\t\t..Tests2(sessionId),\n\t\t];\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EnumIsDefinedAssertCondition in C#\nDESCRIPTION: A class that implements a condition to check if an enum value is defined in its enum type. It extends BaseAssertCondition and requires the type to be an enum.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_106\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumIsDefinedAssertCondition<TEnum> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TEnum>\n    where TEnum : System.Enum\n{\n    public EnumIsDefinedAssertCondition() { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TEnum? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining StringMatcher Abstract Class and Factory Methods in TUnit (C#)\nDESCRIPTION: Defines the abstract `StringMatcher` base class for string comparison strategies in TUnit assertions. It provides static factory methods (`AsRegex`, `AsWildcard`) to create specific matcher instances (RegexMatch, WildcardMatch) and implicit conversion operators from `Regex` and `string`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_25\n\nLANGUAGE: csharp\nCODE:\n```\n    public abstract class StringMatcher\n    {\n        protected StringMatcher() { }\n        public static TUnit.Assertions.AssertConditions.StringMatcher.RegexMatch AsRegex([System.Diagnostics.CodeAnalysis.StringSyntax(\"regex\")] string pattern) { }\n        public static TUnit.Assertions.AssertConditions.StringMatcher.WildcardMatch AsWildcard(string pattern) { }\n        public static TUnit.Assertions.AssertConditions.StringMatcher op_Implicit(System.Text.RegularExpressions.Regex pattern) { }\n        public static TUnit.Assertions.AssertConditions.StringMatcher op_Implicit(string pattern) { }\n        // Nested class definitions follow...\n    }\n```\n\n----------------------------------------\n\nTITLE: Installing TUnit Package via CLI\nDESCRIPTION: Command to add the main TUnit package to an existing project. This installs the combined package that includes Core, Engine, and Assertions components.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/README.md#2025-04-22_snippet_1\n\nLANGUAGE: cli\nCODE:\n```\ndotnet add package TUnit --prerelease\n```\n\n----------------------------------------\n\nTITLE: Implementing BetweenAssertionBuilderWrapper in C#\nDESCRIPTION: Wrapper for assertions that check if a value is between two bounds. Supports configuration with inclusive or exclusive bounds for comparison operations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_84\n\nLANGUAGE: C#\nCODE:\n```\n    public class BetweenAssertionBuilderWrapper<TActual> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>\n        where TActual : System.IComparable<TActual>\n    {\n        public TUnit.Assertions.AssertionBuilders.Wrappers.BetweenAssertionBuilderWrapper<TActual> WithExclusiveBounds() { }\n        public TUnit.Assertions.AssertionBuilders.Wrappers.BetweenAssertionBuilderWrapper<TActual> WithInclusiveBounds() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Collecting Test Metadata for GenericMethodTests in C#\nDESCRIPTION: Implements the CollectTests method to gather all test metadata for the GenericMethodTests class. It combines results from multiple test collection methods.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GenericMethodTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn\n\t[\n\t\t..Tests0(sessionId),\n\t\t..Tests1(sessionId),\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Property Equality Assertions in C#\nDESCRIPTION: Defines classes for asserting equality of object properties. It allows creating assertions for specific properties of complex objects.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_57\n\nLANGUAGE: C#\nCODE:\n```\npublic class Member<TActualRootType, TPropertyType>\n{\n    public Member(TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActualRootType> valueSource, System.Linq.Expressions.Expression<System.Func<TActualRootType, TPropertyType>> selector) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActualRootType> EqualTo(TPropertyType expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n    public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActualRootType> NotEqualTo(TPropertyType expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue = null) { }\n}\n\npublic class PropertyEqualsExpectedValueAssertCondition<TRootObjectType, TPropertyType> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TRootObjectType, TPropertyType>\n{\n    public PropertyEqualsExpectedValueAssertCondition(System.Linq.Expressions.Expression<System.Func<TRootObjectType, TPropertyType>> propertySelector, TPropertyType expected, bool isEqual) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TRootObjectType? actualValue, TPropertyType? expectedValue) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Matrix Test Cases for ExcludingAutoGeneratedMatrixValues Method\nDESCRIPTION: This snippet initializes and collects matrix tests for the ExcludingAutoGeneratedMatrixValues method. It sets up the test information and prepares for generating test cases using matrix data sources.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MatrixTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tglobal::TUnit.Core.SourceRegistrar.Register(new MatrixTests());\n}\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn Tests0(sessionId);\n}\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.MatrixTests),\n\t\t\tName = \"ExcludingAutoGeneratedMatrixValues\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.MatrixDataSourceAttribute()\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.MatrixTests.CountToTenEnum>\n\t\t\t\t{\n\t\t\t\t\tName = \"enum\",\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.MatrixAttribute<global::TUnit.TestProject.MatrixTests.CountToTenEnum>()\n\t\t\t\t\t\t{\n\n\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Class Hooks for Base2 Tests in TUnit\nDESCRIPTION: Generated partial class implementing IClassHookSource interface for Base2 test class. Includes AfterAll2 hook implementation and class-level hook collection methods.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterAllTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_Base2 : global::TUnit.Core.Interfaces.SourceGenerator.IClassHookSource\n{\n    [global::System.Runtime.CompilerServices.ModuleInitializer]\n    public static void Initialise()\n    {\n        var instance = new Hooks_Base2();\n        SourceRegistrar.RegisterClassHookSource(instance);\n    }\n    // Methods omitted for brevity\n}\n```\n\n----------------------------------------\n\nTITLE: Generating TUnit Test Metadata for Data-Driven Test Case (Set 0) in C#\nDESCRIPTION: This method generates `TestMetadata` for the first set of arguments (`1`, `\"String\"`) provided via `ArgumentsAttribute` for the `DataSource_Method` test in `TUnit.TestProject.DataDrivenTests`. It defines detailed test information (method signature, attributes, parameters, class/assembly info), sets up the test execution context (`TestBuilderContext`), defines factories for class instantiation (`ResettableLazy`) and method invocation (`AsyncConvert`), and packages everything into a `TestMetadata` object. This object is then added to the `nodes` list.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.DataDrivenTests),\n\t\t\t\tName = \"DataSource_Method\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(1, \"String\"),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(2, \"String2\"),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(3, \"String3\")\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value2\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.DataDrivenTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"DataDrivenTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"DataDrivenTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.DataDrivenTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tint methodArg = 1;\n\t\t\t\tstring methodArg1 = \"String\";\n\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.DataDrivenTests>(() => \n\t\t\t\tnew global::TUnit.TestProject.DataDrivenTests()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.DataDrivenTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.DataDrivenTests.DataSource_Method(int,string):0\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [methodArg, methodArg1],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_Method(methodArg, methodArg1)),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 14,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n```\n\n----------------------------------------\n\nTITLE: Defining WildcardMatch Nested Class within StringMatcher in TUnit (C#)\nDESCRIPTION: Defines the sealed `WildcardMatch` class, nested within `StringMatcher`, representing a wildcard pattern-based string matching strategy (e.g., using '*' and '?'). It includes a method `IgnoringCase` to configure case sensitivity and overrides `ToString`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_27\n\nLANGUAGE: csharp\nCODE:\n```\n        public sealed class WildcardMatch : TUnit.Assertions.AssertConditions.StringMatcher\n        {\n            public TUnit.Assertions.AssertConditions.StringMatcher.WildcardMatch IgnoringCase(bool ignoreCase = true) { }\n            public override string ToString() { }\n        }\n```\n\n----------------------------------------\n\nTITLE: Implementing ITestHookSource for ParentTests Generic Class in C#\nDESCRIPTION: Auto-generated partial class that implements ITestHookSource for the ParentTests<T> generic class. It registers SetupParentTests methods as before-test hooks for both the generic type definition and the specific instantiation with MyFixture.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Hooks1594.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_ParentTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_ParentTests();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.Bugs._1594.ParentTests<>),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1594.ParentTests<>),\n\t\t\t\t\tName = \"SetupParentTests\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(void),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._1594.ParentTests<>\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1594.ParentTests<>),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Hooks1594\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"Hooks1594\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"ParentTests\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._1594\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.ConvertObject(() => classInstance.GetType().GetMethod(\"SetupParentTests\", []).Invoke(classInstance, [])),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t\t{\n\t\t\t\t\tClassType = typeof(global::TUnit.TestProject.Bugs._1594.ParentTests<global::TUnit.TestProject.Bugs._1594.MyFixture>),\n\t\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1594.ParentTests<global::TUnit.TestProject.Bugs._1594.MyFixture>),\n\t\t\t\t\t\tName = \"SetupParentTests\",\n\t\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\t\tReturnType = typeof(void),\n\t\t\t\t\t\tAttributes = \n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t\t],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._1594.ParentTests<global::TUnit.TestProject.Bugs._1594.MyFixture>\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1594.ParentTests<global::TUnit.TestProject.Bugs._1594.MyFixture>),\n\t\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Hooks1594\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName = \"Hooks1594\",\n\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\tName = \"ParentTests\",\n\t\t\t\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._1594\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\tParameters = \n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.Bugs._1594.MyFixture>\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tName = \"fixture\",\n\t\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t\t}),\n},\n\t\t\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.Bugs._1594.ParentTests<global::TUnit.TestProject.Bugs._1594.MyFixture>)classInstance).SetupParentTests()),\n\t\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\t\tOrder = 0,\n\t\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t\t],\n\t\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t\t\t},\n\t\t\t\t];\n\t\t\t}\n\t\t\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t\t\t{\n\t\t\t\treturn\n\t\t\t\t[\n\t\t\t\t];\n\t\t\t}\n\t\t}\n```\n\n----------------------------------------\n\nTITLE: Defining Failure Location Class in TUnit Assertions (C#)\nDESCRIPTION: This class represents the specific location where an assertion failed, particularly useful for collection or sequence comparisons. It stores the `ActualValue` and `ExpectedValue` at the point of failure, along with the `Position` (e.g., index) where the failure occurred. It implements `IEquatable` for comparison purposes.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_48\n\nLANGUAGE: csharp\nCODE:\n```\n    public class FailureLocation : System.IEquatable<TUnit.Assertions.AssertConditions.FailureLocation>\n    {\n        public FailureLocation() { }\n        public object? ActualValue { get; }\n        public object? ExpectedValue { get; }\n        public long Position { get; }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing ITestSource Interface for ConstantInBaseClassTests in C#\nDESCRIPTION: Auto-generated partial class that implements ITestSource to register and provide test metadata for the TUnit testing framework. It handles test discovery, initialization, and parameter setup for the ConstantInBaseClassTests class.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ConstantInBaseClassTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[  \n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class ConstantInBaseClassTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new ConstantInBaseClassTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1432.ConstantInBaseClassTests),\n\t\t\t\tName = \"SomeTest\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"Value\")\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._1432.ConstantInBaseClassTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1432.ConstantInBaseClassTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"ConstantInBaseClassTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"ConstantInBaseClassTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"ConstantInBaseClassTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._1432\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.Bugs._1432.ConstantInBaseClassTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tstring methodArg = \"Value\";\n\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._1432.ConstantInBaseClassTests>(() => \n\t\t\t\tnew global::TUnit.TestProject.Bugs._1432.ConstantInBaseClassTests()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._1432.ConstantInBaseClassTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.Bugs._1432.ConstantInBaseClassTests.SomeTest(string):0\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.SomeTest(methodArg)),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 13,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._1432.ConstantInBaseClassTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.Bugs._1432.ConstantInBaseClassTests.SomeTest(string):0\",\n\t\t\t\t\tMethodName = $\"SomeTest\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ConstantInBaseClassTests.SomeTest failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 13,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n\t}\n\n]\n```\n\n----------------------------------------\n\nTITLE: Initializing TUnit Test Source Registration\nDESCRIPTION: Static initializer method that registers the test source implementation with TUnit's source registrar system.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.Typed.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tglobal::TUnit.Core.SourceRegistrar.Register(new DataSourceGeneratorTests());\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Logging Extensions in C#\nDESCRIPTION: Defines static extension methods for ILogger interface in TUnit. These methods provide convenience functions for logging at different levels with various overloads.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_67\n\nLANGUAGE: C#\nCODE:\n```\npublic static class LoggingExtensions\n{\n    public static void LogCritical(this TUnit.Core.Logging.ILogger logger, string message) { }\n    public static System.Threading.Tasks.ValueTask LogCriticalAsync(this TUnit.Core.Logging.ILogger logger, string message) { }\n    public static void LogDebug(this TUnit.Core.Logging.ILogger logger, string message) { }\n    public static System.Threading.Tasks.ValueTask LogDebugAsync(this TUnit.Core.Logging.ILogger logger, string message) { }\n    public static void LogError(this TUnit.Core.Logging.ILogger logger, System.Exception ex) { }\n    public static void LogError(this TUnit.Core.Logging.ILogger logger, string message) { }\n    public static void LogError(this TUnit.Core.Logging.ILogger logger, string message, System.Exception ex) { }\n    public static System.Threading.Tasks.ValueTask LogErrorAsync(this TUnit.Core.Logging.ILogger logger, System.Exception ex) { }\n    public static System.Threading.Tasks.ValueTask LogErrorAsync(this TUnit.Core.Logging.ILogger logger, string message) { }\n    public static System.Threading.Tasks.ValueTask LogErrorAsync(this TUnit.Core.Logging.ILogger logger, string message, System.Exception ex) { }\n    public static void LogInformation(this TUnit.Core.Logging.ILogger logger, string message) { }\n    public static System.Threading.Tasks.ValueTask LogInformationAsync(this TUnit.Core.Logging.ILogger logger, string message) { }\n    public static void LogTrace(this TUnit.Core.Logging.ILogger logger, string message) { }\n    public static System.Threading.Tasks.ValueTask LogTraceAsync(this TUnit.Core.Logging.ILogger logger, string message) { }\n    public static void LogWarning(this TUnit.Core.Logging.ILogger logger, string message) { }\n    public static System.Threading.Tasks.ValueTask LogWarningAsync(this TUnit.Core.Logging.ILogger logger, string message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Hooks_SetupTests Class with Module Initializer in C#\nDESCRIPTION: Defines a partial class that implements IClassHookSource interface with a module initializer method to register the hook source instance. This pattern ensures the hooks are automatically registered when the assembly loads.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tvar instance = new Hooks_SetupTests();\n\tSourceRegistrar.RegisterClassHookSource(instance);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Global Test Hooks for GlobalSetUpTests in C#\nDESCRIPTION: Defines a partial class Hooks_GlobalSetUpTests that implements ITestHookSource. This class is set up to collect global test hooks but currently doesn't define any specific hooks.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticBeforeEachTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_GlobalSetUpTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_GlobalSetUpTests();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating ResettableLazy Class Factory with Tuple Parameters in C#\nDESCRIPTION: This code defines a factory delegate for creating resettable lazy instances of the test class with tuple parameters. It initializes the class with constructor parameters and sets tuple property values using CastHelper for proper type conversion.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>(() => \nnew global::TUnit.TestProject.ClassTupleDataSourceDrivenTests(classArg, classArg1, classArg2)\n{\n\tProperty1 = global::TUnit.Core.Helpers.CastHelper.Cast<(int, string, bool)>(propertyArg),\n\tProperty2 = global::TUnit.Core.Helpers.CastHelper.Cast<(int, string, bool)>(propertyArg1),\n\tProperty3 = global::TUnit.Core.Helpers.CastHelper.Cast<(int Number, string Word, bool Flag)>(propertyArg2),\n\tProperty4 = global::TUnit.Core.Helpers.CastHelper.Cast<(int Number, string Word, bool Flag)>(propertyArg3),\n}\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n```\n\n----------------------------------------\n\nTITLE: Collecting Test Metadata for DataSource_Method3 (Tests1) in TUnit (C#)\nDESCRIPTION: This C# method `Tests1` is part of the auto-generated test source infrastructure for TUnit, similar to `Tests0`. It collects test metadata for the `DataSource_Method3` test, likely corresponding to a different data source invocation (although the provided snippet reuses the same `MethodDataSourceAttribute` information as `Tests0`). It initializes test information, presumably retrieves arguments from the referenced `SomeMethod`, prepares the test context, and is expected to add `TestMetadata` or `FailedTestMetadata` to a list.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n\t\t\t\tprivate global::System.Collections.Generic.List<TestMetadata> Tests1(string sessionId)\n\t\t\t\t{\n\t\t\t\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\t\t\t\tvar classDataIndex = 0;\n\t\t\t\t\tvar testMethodDataIndex = 0;\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.MethodDataSourceDrivenTests),\n\t\t\t\t\t\t\tName = \"DataSource_Method3\",\n\t\t\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\t\t\tReturnType = typeof(void),\n\t\t\t\t\t\t\tAttributes = \n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"SomeMethod\")\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tArguments = [5],\n},\n\t\t\t\t\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"SomeMethod\")\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tArguments = new object[] { 5 },\n}\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\tParameters = \n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.MethodDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.MethodDataSourceDrivenTests),\n\t\t\t\t\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"MethodDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tName = \"MethodDataSourceDrivenTests\",\n\t\t\t\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t\t\tName = \"MethodDataSourceDrivenTests\",\n\t\t\t\t\t\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n```\n\n----------------------------------------\n\nTITLE: Parameterized DisplayName with Arguments in CSharp Tests\nDESCRIPTION: Demonstrates how to create parameterized test names using the DisplayName attribute with parameter references. Parameters are referenced using $parameterName syntax within the display name string.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/display-names.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n    [Test]\n    [Arguments(\"foo\", 1, true)]\n    [Arguments(\"bar\", 2, false)]\n    [DisplayName(\"Test with: $value1 $value2 $value3!\")]\n    public async Task Test3(string value1, int value2, bool value3)\n    {\n        ...\n    }\n```\n\n----------------------------------------\n\nTITLE: Initializing and Registering MatrixTests Source Generator - C#\nDESCRIPTION: This snippet defines the partial class MatrixTests implementing TUnit's ITestSource, registering itself in a module initializer and collecting test metadata by generating nodes for each parameterized test. Dependencies include TUnit.Core, reflection, source generation mechanisms, and specific attribute classes for test discovery and generation. The CollectTests method delegates to an internal method that prepares test information, handles test context, applies data-source attributes, and returns properly configured test metadata for the TUnit runner.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MatrixTests.Test.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\n// <auto-generated/>\\n#pragma warning disable\\nusing global::System.Linq;\\nusing global::System.Reflection;\\nusing global::TUnit.Core;\\nusing global::TUnit.Core.Extensions;\\n\\nnamespace TUnit.SourceGenerated;\\n\\n[global::System.Diagnostics.StackTraceHidden]\\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\\nfile partial class MatrixTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\\n{\\n\\t[global::System.Runtime.CompilerServices.ModuleInitializer]\\n\\tpublic static void Initialise()\\n\\t{\\n\\t\\tglobal::TUnit.Core.SourceRegistrar.Register(new MatrixTests());\\n\\t}\\n\\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\\n\\t{\\n\\t\\treturn Tests0(sessionId);\\n\\t}\n```\n\n----------------------------------------\n\nTITLE: Initializing Data-Driven Test with Error Handling in TUnit (C#)\nDESCRIPTION: This C# snippet demonstrates the setup of a `DataSourceDrivenTest` object within the TUnit framework. It configures properties like `RepeatLimit`, `MethodInfo`, and factories (`ResettableClassFactory`, `TestMethodFactory`). The `TestMethodFactory` lambda invokes the target test method (`SixteenArgs`) with parameters obtained from a data source (`SixteenItems` referenced by `MethodDataSourceAttribute`). It includes associated test attributes and context. A try-catch block handles exceptions during this setup, creating a `FailedInitializationTest` object with relevant details (TestId, Class, ReturnType, Parameters, Name, Location, Exception) if initialization fails.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tMethodInfo = methodInfo,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.SixteenArgs(methodArg, methodArg1, methodArg2, methodArg3, methodArg4, methodArg5, methodArg6, methodArg7, methodArg8, methodArg9, methodArg10, methodArg11, methodArg12, methodArg13, methodArg14, methodArg15)),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 13,\n\t\t\t\t\tTestAttributes = [ new global::TUnit.Core.TestAttribute()\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"SixteenItems\")\n{\n    \n} ],\n\t\t\t\t\tClassAttributes = [  ],\n\t\t\t\t\tAssemblyAttributes = [  ],\n\t\t\t\t\tDataAttributes = [  ],\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedInitializationTest\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS0:{testMethodDataIndex}:TUnit.TestProject.Bugs._1538.Tests.SixteenArgs(System.Boolean,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String):0\",\n\t\t\t\tTestClass = typeof(global::TUnit.TestProject.Bugs._1538.Tests),\n\t\t\t\tReturnType = global::TUnit.Core.Helpers.MethodInfoRetriever.GetMethodInfo(typeof(global::TUnit.TestProject.Bugs._1538.Tests), \"SixteenArgs\", 0, [typeof(global::System.Boolean), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String)]).ReturnType,\n\t\t\t\tParameterTypeFullNames = [typeof(global::System.Boolean), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String), typeof(global::System.String)],\n\t\t\t\tTestName = \"SixteenArgs\",\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 13,\n\t\t\t\tException = exception,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Resettable Test Class Factory in C#\nDESCRIPTION: Initializes a resettable lazy factory for test class instances. Creates a delegate that produces new instances of ArgsAsArrayTests class with session and context information.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ArgsAsArrayTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ArgsAsArrayTests>(() => \nnew global::TUnit.TestProject.ArgsAsArrayTests()\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n```\n\n----------------------------------------\n\nTITLE: Declaring and Resetting Test Contexts in TUnit C#\nDESCRIPTION: This snippet demonstrates the declaration of test builder contexts, context accessors, and a resettable class factory delegate in a TUnit test setup. It initializes test-related objects and setups required for running tests using the TUnit framework.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ArgsAsArrayTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.ArgsAsArrayTests? classInstance = null;\nobject?[]? classInstanceArguments = null;\nclassInstanceArguments = [];\nglobal::System.Collections.Generic.IEnumerable<string> methodArg = [\"arg1\", \"arg2\", \"arg3\"];\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ArgsAsArrayTests>(() => \n    new global::TUnit.TestProject.ArgsAsArrayTests()\n    , sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n```\n\n----------------------------------------\n\nTITLE: Initializing and Registering ClassDataSourceDrivenTests2 in TUnit\nDESCRIPTION: This snippet defines a module initializer that registers the ClassDataSourceDrivenTests2 class with the TUnit SourceRegistrar. It ensures that the test source is properly registered with the testing framework.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests2.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tglobal::TUnit.Core.SourceRegistrar.Register(new ClassDataSourceDrivenTests2());\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing TUnit Data Generation Process in C#\nDESCRIPTION: The snippet demonstrates initializing data generation settings for parameterized tests using TUnit. Dependencies include TUnit.Core and System.Linq. It requires a session ID and test context setup. The operation generates data for class and method parameters and captures metadata for test execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.Typed.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar classDataAttribute = new global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute();\n\ntestBuilderContext.DataAttributes.Add(classDataAttribute);\n\nvar classArgGeneratedDataArray = classDataAttribute.GenerateDataSources(classArgDataGeneratorMetadata);\n\nforeach (var classArgGeneratedDataAccessor in classArgGeneratedDataArray)\n{\n  classDataIndex++;\n  var methodArgDataGeneratorMetadata = new DataGeneratorMetadata\n  {\n    Type = global::TUnit.Core.Enums.DataGeneratorType.TestParameters,\n    TestBuilderContext = testBuilderContextAccessor,\n    TestInformation = testInformation;\n  };\n  // Continuing code for generating method data...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NotNullStructAssertionBuilderWrapper for Value Type Null Checking\nDESCRIPTION: Specialized assertion builder for checking that nullable value type values are not null. It implements the awaitable pattern to return the actual value when awaited.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_90\n\nLANGUAGE: C#\nCODE:\n```\npublic class NotNullStructAssertionBuilderWrapper<TActual> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>\n    where TActual :  struct\n{\n    public new System.Runtime.CompilerServices.TaskAwaiter<TActual> GetAwaiter() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Test Initialization Errors\nDESCRIPTION: This catch block handles any exceptions that occur during test initialization by adding a FailedTestMetadata object to the nodes collection with details about the failure.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/NumberArgumentTests.TestDE.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.NumberArgumentTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NumberArgumentTests.UInt(uint):0\",\n\t\t\t\tMethodName = $\"UInt\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"NumberArgumentTests.UInt failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 40,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for ParamsEnumerable Method in C#\nDESCRIPTION: This snippet shows the beginning of test metadata generation for the ParamsEnumerable method in ArgsAsArrayTests. It defines the test information with a different parameter type (IEnumerable<string>) compared to the other methods.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ArgsAsArrayTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.ArgsAsArrayTests),\n\tName = \"ParamsEnumerable\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(void),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute(),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(\"arg1\", \"arg2\", \"arg3\")\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Collections.Generic.IEnumerable<string>>\n\t\t{\n\t\t\tName = \"arguments\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n\t// ... (class information)\n};\n```\n\n----------------------------------------\n\nTITLE: Registering and Collecting 'Test2' Method with Custom Display Name in TUnit\nDESCRIPTION: This code snippet implements a source-generated test collector for the 'Test2' method in CustomDisplayNameTests class. It registers the test with a custom display name 'Another super important test!' and handles test initialization and execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/CustomDisplayNameTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tglobal::TUnit.Core.SourceRegistrar.Register(new CustomDisplayNameTests());\n}\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn Tests0(sessionId);\n}\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.CustomDisplayNameTests),\n\t\t\tName = \"Test2\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.DisplayNameAttribute(\"Another super important test!\")\n\t\t\t],\n\t\t\tParameters = [],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.CustomDisplayNameTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.CustomDisplayNameTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"CustomDisplayNameTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"CustomDisplayNameTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"CustomDisplayNameTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = \n\t\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType = typeof(int),\n\t\t\t\t\t\t\tName = \"Order\",\n\t\t\t\t\t\t\tIsStatic = false,\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.CustomDisplayNameTests? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tclassInstanceArguments = [];\n\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.CustomDisplayNameTests>(() => \n\t\t\tnew global::TUnit.TestProject.CustomDisplayNameTests()\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.CustomDisplayNameTests>\n\t\t\t{\n\t\t\t\tTestId = $\"TUnit.TestProject.CustomDisplayNameTests.Test2:0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Test2()),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 19,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.CustomDisplayNameTests>\n\t\t\t{\n\t\t\t\tTestId = $\"TUnit.TestProject.CustomDisplayNameTests.Test2:0\",\n\t\t\t\tMethodName = $\"Test2\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"CustomDisplayNameTests.Test2 failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 19,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test-Specific Hook Collection - TUnit Source Generator - C#\nDESCRIPTION: This snippet implements a generated partial class for registering and providing test-level hooks in TUnit. It features method overrides for collecting hooks that should run before or after every test or specific tests in a test class. The method CollectBeforeTestHooks returns metadata for an instance-specific test method, leveraging TUnit's core interfaces and classes. The main dependencies are on TUnit.Core, TUnit.Core.Hooks, and reflection APIs. Inputs focus on sessionId and test context, while outputs are collections of hook metadata required for orchestrating test lifecycle events.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_Base3 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_Base3();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.BeforeTests.Base3),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.Base3),\n\t\t\t\t\tName = \"BeforeEach3\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.Base3\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.Base3),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"BeforeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"BeforeTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"Base3\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.BeforeTests.Base3)classInstance).BeforeEach3()),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t},\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing ITestHookSource for Base2 in C#\nDESCRIPTION: This snippet implements the ITestHookSource interface for the Base2 class, defining methods to collect before and after test hooks. It includes a BeforeEach2 method as a before test hook.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeAllTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t{\n\t\t\tClassType = typeof(global::TUnit.TestProject.BeforeTests.Base2),\n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.Base2),\n\t\t\t\tName = \"BeforeEach2\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.Base2\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.Base2),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"BeforeAllTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"BeforeAllTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"Base2\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.BeforeTests.Base2)classInstance).BeforeEach2()),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t},\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Configuring Value Transformations for Assertions\nDESCRIPTION: Methods to configure transformations for actual and expected values before assertion comparison is performed, enabling more flexible assertion conditions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic void WithTransform(System.Func<TActual?, TActual?> actualTransformation) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic void WithTransform(System.Func<TActual?, TActual?> actualTransformation, System.Func<TExpected?, TExpected?> expectedTransformation) { }\n```\n\n----------------------------------------\n\nTITLE: Generating TUnit Test Metadata for Long Method in C#\nDESCRIPTION: This auto-generated C# snippet defines a partial `NumberArgumentTests` class implementing `ITestSource` for TUnit. It includes a `ModuleInitializer` for registration and a `CollectTests` method which delegates to `Tests0`. The `Tests0` method gathers metadata for the `Long` test method, setting the `long` argument (1L), creating factories for the test class (`ResettableLazy`) and method execution, and adding a `TestMetadata` object to a list. Error handling captures initialization exceptions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/NumberArgumentTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class NumberArgumentTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new NumberArgumentTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.NumberArgumentTests),\n\t\t\t\tName = \"Long\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(1L)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<long>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"l\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.NumberArgumentTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.NumberArgumentTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"NumberArgumentTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"NumberArgumentTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"NumberArgumentTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.NumberArgumentTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tlong methodArg = 1L;\n\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.NumberArgumentTests>(() => \n\t\t\t\tnew global::TUnit.TestProject.NumberArgumentTests()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.NumberArgumentTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NumberArgumentTests.Long(long):0\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Long(methodArg)),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 26,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.NumberArgumentTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NumberArgumentTests.Long(long):0\",\n\t\t\t\t\tMethodName = $\"Long\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"NumberArgumentTests.Long failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 26,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing InvokableDelegateAssertionBuilder Class in C#\nDESCRIPTION: This class represents an invokable delegate assertion builder. It inherits from InvokableAssertionBuilder and implements IDelegateSource and ISource interfaces. It includes properties for 'And' and 'Or' operators.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_61\n\nLANGUAGE: C#\nCODE:\n```\npublic class InvokableDelegateAssertionBuilder : TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<object?>, TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource, TUnit.Assertions.AssertConditions.Interfaces.ISource\n{\n    public TUnit.Assertions.AssertConditions.Operators.DelegateAnd<object?> And { get; }\n    public TUnit.Assertions.AssertionBuilders.AssertionBuilder AssertionBuilder { get; }\n    public TUnit.Assertions.AssertConditions.Operators.DelegateOr<object?> Or { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Static After Every Test Hooks with CancellationToken - TUnit Core - C#\nDESCRIPTION: This method collects and returns static hook methods to be executed after every test, with the hook method supporting both TestContext and CancellationToken parameters, enhancing flexibility for async or cancelled test operations. It builds the required SourceGeneratedMethodInformation including parameter metadata and ties the hook method to its proper executor within TUnits core infrastructure. Inputs are session ID (string), and the method returns a list suitable for consumption by the test system.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticAfterEachTests.Test.verified.txt#2025-04-22_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.AfterTestHookMethod\n\t\t{ \n\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),\n\t\t\tName = \"AfterAllCleanUpWithContext\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.AfterEveryAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext>\n\t\t\t\t{\n\t\t\t\t\tName = \"context\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t{\n\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.GlobalCleanUpTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"GlobalStaticAfterEachTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"GlobalStaticAfterEachTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"GlobalCleanUpTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n},\n\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.GlobalCleanUpTests.AfterAllCleanUpWithContext(context, cancellationToken)),\n\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\tOrder = 0,\n\t\t\tFilePath = @\"\",\n\t\t\tLineNumber = 68,\n\t\t\tMethodAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.AfterEveryAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t],\n\t\t\tClassAttributes = [],\n\t\t\tAssemblyAttributes = [],\n\t\t},\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Fail Static Class in C#\nDESCRIPTION: This static class provides methods for failing tests with reasons and conditions. It includes attributes for code analysis.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic static class Fail\n{\n    [System.Diagnostics.CodeAnalysis.DoesNotReturn]\n    public static void Test(string reason) { }\n    public static void Unless([System.Diagnostics.CodeAnalysis.DoesNotReturnIf(false)] bool condition, string reason) { }\n    public static void When([System.Diagnostics.CodeAnalysis.DoesNotReturnIf(true)] bool condition, string reason) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Float-Argument Test Metadata with TUnit in C#\nDESCRIPTION: This snippet mirrors the double method metadata creation, but targets a parameterized test method accepting a float value (1.23F). It includes complete SourceGeneratedMethodInformation with argument and parameter metadata for float, establishing the context and resettable factory for running this kind of test. The snippet is used to ensure argument-based test discovery and invocation works seamlessly for tests with float parameters.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ConstantArgumentsTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.ConstantArgumentsTests),\n\tName = \"Float\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute(),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(1.23F)\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<float>\n\t\t{\n\t\t\tName = \"dummy\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.ConstantArgumentsTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t{\n\t\tType = typeof(global::TUnit.TestProject.ConstantArgumentsTests),\n\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"ConstantArgumentsTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t{\n\t\t\tName = \"ConstantArgumentsTests\",\n\t\t\tAttributes = [],\n\t\t}),\n\t\tName = \"ConstantArgumentsTests\",\n\t\tNamespace = \"TUnit.TestProject\",\n\t\tAttributes = [],\n\t\tParameters = [],\n\t\tProperties = [],\n\t}),\n};\n\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.ConstantArgumentsTests? classInstance = null;\nobject?[]? classInstanceArguments = null;\nclassInstanceArguments = [];\n\nfloat methodArg = 1.23F;\n\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ConstantArgumentsTests>(() => \nnew global::TUnit.TestProject.ConstantArgumentsTests()\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.ConstantArgumentsTests>\n{\n\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.ConstantArgumentsTests.Float(float):0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [methodArg],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Float(methodArg)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 37,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing AssemblyLoader with .NET Core\nDESCRIPTION: This snippet initializes the \"AssemblyLoader_Guid\" class using the ModuleInitializer attribute in C#. It sets the runtime version and framework display name for .NET Core applications. There are no inputs or outputs, and it serves as an entry point for assembly initialization.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Runtime.Versioning.TargetFramework(\".NETCoreApp,Version=v8.0\", FrameworkDisplayName=\".NET 8.0\")]\npublic static class AssemblyLoader_Guid\n{\n    [System.Runtime.CompilerServices.ModuleInitializer]\n    public static void Initialize() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PageTest Class for Playwright Testing in C#\nDESCRIPTION: This class extends ContextTest and provides methods for page setup in Playwright tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class PageTest : TUnit.Playwright.ContextTest\n{\n    public PageTest() { }\n    public Microsoft.Playwright.IPage Page { get; }\n    [TUnit.Core.Before(TUnit.Core.HookType.Test, \"\", 0)]\n    public System.Threading.Tasks.Task PageSetup() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Registering Test Hook Source in C#\nDESCRIPTION: This snippet defines a static Initialise method that creates an instance of Hooks_CleanupTests and registers it as a test hook source. It's marked with the ModuleInitializer attribute to ensure it's called automatically.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterAllTests.Test.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tvar instance = new Hooks_CleanupTests();\n\tSourceRegistrar.RegisterTestHookSource(instance);\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting AfterTest Hooks for AssemblyBase2 in C#\nDESCRIPTION: This C# method `CollectAfterTestHooks` is part of an auto-generated class (likely `Hooks_AssemblyBase2` inferred from context). It collects instance-level methods marked to run after each test within the `TUnit.TestProject.AfterTests.AssemblyBase2` class. It returns a read-only list of `InstanceHookMethod` objects, specifically populating it with metadata for the `AfterEach2` method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyAfterTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase2),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase2),\n\t\t\t\t\tName = \"AfterEach2\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.AssemblyBase2\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase2),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AssemblyAfterTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"AssemblyAfterTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"AssemblyBase2\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.AfterTests.AssemblyBase2)classInstance).AfterEach2()),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: Collecting TUnit Tests with Tuple Data Sources\nDESCRIPTION: Collects all tests from multiple test methods, combining them into a single list of TestMetadata objects.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=TupleMethod_testMethodName=TupleMethod.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn\n\t[\n\t\t..Tests0(sessionId),\n\t\t..Tests1(sessionId),\n\t\t..Tests2(sessionId),\n\t\t..Tests3(sessionId),\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Source Generation for RepeatTests in TUnit Test Framework\nDESCRIPTION: Auto-generated partial class that implements the ITestSource interface to register and collect tests from RepeatTests. Contains the initialization method and test collection logic for tests with repeat attributes.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/RepeatTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class RepeatTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new RepeatTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\t..Tests0(sessionId),\n\t\t\t..Tests1(sessionId),\n\t\t\t..Tests2(sessionId),\n\t\t\t..Tests3(sessionId),\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing Default Logger in C#\nDESCRIPTION: Defines a DefaultLogger class that implements the TUnitLogger abstract class. It provides methods for logging and pushing properties.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_64\n\nLANGUAGE: C#\nCODE:\n```\npublic class DefaultLogger : TUnit.Core.Logging.TUnitLogger\n{\n    public DefaultLogger(TUnit.Core.Context context) { }\n    public override void Log<TState>(TUnit.Core.Logging.LogLevel logLevel, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter) { }\n    public override System.Threading.Tasks.ValueTask LogAsync<TState>(TUnit.Core.Logging.LogLevel logLevel, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter) { }\n    public void PushProperties(System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<object>> dictionary) { }\n    public void PushProperty(string name, object? value) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for AutoData Tests\nDESCRIPTION: Creates test metadata for tests decorated with AutoDataAttribute, setting up test parameters, class information, and execution context. This method handles the automated generation of test data based on parameter types and attributes.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.NonTyped.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.AutoDataTests),\n\t\t\tName = \"Test1\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.TestProject.Attributes.AutoDataAttribute(),\n\t\t\t\tnew global::TUnit.Core.TestAttribute()\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t{\n\t\t\t\t\tName = \"value1\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t{\n\t\t\t\t\tName = \"value2\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<double>\n\t\t\t\t{\n\t\t\t\t\tName = \"value3\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t\t\t{\n\t\t\t\t\tName = \"value4\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AutoDataTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.AutoDataTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataSourceGeneratorTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"DataSourceGeneratorTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"AutoDataTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: Handling Initialization Errors for TUnit Data-Driven Test Case (Set 0) in C#\nDESCRIPTION: This `catch` block handles exceptions occurring during the setup (within the `try` block of the `Tests0` method) of the first test case (`ArgumentsAttribute` set 0) for `DataSource_Method`. If an error occurs during initialization, it creates a `FailedTestMetadata` object containing details about the failure (Test ID, method name, exception wrapped in `TestFailedInitializationException`, location) and adds it to the results list (`nodes`) instead of a successful `TestMetadata`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.DataDrivenTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.DataDrivenTests.DataSource_Method(int,string):0\",\n\t\t\t\t\tMethodName = $\"DataSource_Method\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"DataDrivenTests.DataSource_Method failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 14,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing UnknownAssertionGroupInvoker for Initial Assertion Combinations\nDESCRIPTION: Class that handles the initial invocation of assertion groups before determining whether they will be combined with AND or OR logic. It provides methods for both combinations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_78\n\nLANGUAGE: C#\nCODE:\n```\npublic class UnknownAssertionGroupInvoker<TActual, TAssertionBuilder>\n    where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder\n{\n    public UnknownAssertionGroupInvoker(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group) { }\n    public TUnit.Assertions.AssertionBuilders.Groups.AndAssertionGroupInvoker<TActual, TAssertionBuilder> And(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> otherGroup) { }\n    public TUnit.Assertions.AssertionBuilders.Groups.OrAssertionGroupInvoker<TActual, TAssertionBuilder> Or(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> otherGroup) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IAssemblyHookSource for AssemblyBase1 in C#\nDESCRIPTION: This snippet defines a partial class Hooks_AssemblyBase1 that implements IAssemblyHookSource. It registers assembly hooks and provides methods to collect different types of assembly hooks.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyBeforeTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_AssemblyBase1 : global::TUnit.Core.Interfaces.SourceGenerator.IAssemblyHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_AssemblyBase1();\n\t\tSourceRegistrar.RegisterAssemblyHookSource(instance);\n\t}\n\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectBeforeAssemblyHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.BeforeAssemblyHookMethod\n\t\t\t{ \n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.AssemblyBase1),\n\t\t\t\tName = \"BeforeAll1\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Assembly)\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.AssemblyBase1\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.AssemblyBase1),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AssemblyBeforeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"AssemblyBeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"AssemblyBase1\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.BeforeTests.AssemblyBase1.BeforeAll1()),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tFilePath = @\"\",\n\t\t\t\tLineNumber = 5,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Assembly)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\tAssemblyAttributes = [],\n\t\t\t},\n\t\t];\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Resettable Test Class Factory with Tuple Properties\nDESCRIPTION: Initializes a resettable lazy factory for test class instances with tuple-based properties. Sets up class arguments and properties using CastHelper for type conversion.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>(() => \nnew global::TUnit.TestProject.ClassTupleDataSourceDrivenTests(classArg, classArg1, classArg2)\n{\n    Property1 = global::TUnit.Core.Helpers.CastHelper.Cast<(int, string, bool)>(propertyArg),\n    Property2 = global::TUnit.Core.Helpers.CastHelper.Cast<(int, string, bool)>(propertyArg1),\n    Property3 = global::TUnit.Core.Helpers.CastHelper.Cast<(int Number, string Word, bool Flag)>(propertyArg2),\n    Property4 = global::TUnit.Core.Helpers.CastHelper.Cast<(int Number, string Word, bool Flag)>(propertyArg3),\n}\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n```\n\n----------------------------------------\n\nTITLE: Initializing Test Metadata for StringArgumentTests in C#\nDESCRIPTION: This snippet creates test metadata for the Nullable method in StringArgumentTests class. It sets up test attributes, parameters, and handles various string argument cases including escaped characters and null values.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/StringArgumentTests.Test.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n    Type = typeof(global::TUnit.TestProject.StringArgumentTests),\n    Name = \"Nullable\",\n    GenericTypeCount = 0,\n    ReturnType = typeof(void),\n    Attributes = \n    [\n        new global::TUnit.Core.TestAttribute(),\n        new global::TUnit.Core.ArgumentsAttribute(\"\"),\n        new global::TUnit.Core.ArgumentsAttribute(@\"\\\"),\n        new global::TUnit.Core.ArgumentsAttribute(@\"\\t\"),\n        new global::TUnit.Core.ArgumentsAttribute(\"\\t\"),\n        new global::TUnit.Core.ArgumentsAttribute(\"\\\\t\"),\n        new global::TUnit.Core.ArgumentsAttribute(\"\\\\\\t\"),\n        new global::TUnit.Core.ArgumentsAttribute(\"\\\\\\\\t\"),\n        new global::TUnit.Core.ArgumentsAttribute(null)\n    ],\n    Parameters = \n    [\n        new global::TUnit.Core.SourceGeneratedParameterInformation<string>\n        {\n            Name = \"s\",\n            Attributes = [],\n        },\n    ],\n    Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.StringArgumentTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n    {\n        Type = typeof(global::TUnit.TestProject.StringArgumentTests),\n        Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"StringArgumentTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n        {\n            Name = \"StringArgumentTests\",\n            Attributes = [],\n        }),\n        Name = \"StringArgumentTests\",\n        Namespace = \"TUnit.TestProject\",\n        Attributes = [],\n        Parameters = [],\n        Properties = [],\n    }),\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Task-based Async Exception Assertion\nDESCRIPTION: Overload of ThrowsAsync that accepts a Task directly instead of a delegate returning a Task. Used for testing asynchronous code that might throw exceptions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic static System.Threading.Tasks.Task<TException> ThrowsAsync<TException>(System.Threading.Tasks.Task @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression(\"delegate\")] string? doNotPopulateThisValue = null)\n            where TException : System.Exception { }\n```\n\n----------------------------------------\n\nTITLE: Implementing AssertionGroup Abstract Class in C#\nDESCRIPTION: This abstract class represents a group of assertions. It defines a GetAwaiter method, allowing assertions to be awaited asynchronously.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class AssertionGroup<TActual, TAssertionBuilder>\n    where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder\n{\n    public abstract System.Runtime.CompilerServices.TaskAwaiter<TActual?> GetAwaiter();\n}\n```\n\n----------------------------------------\n\nTITLE: Building Test Metadata for Alternative Parameterization in C#\nDESCRIPTION: Creates test metadata for the second set of parameterized tests with different argument values. This code handles integer array arguments for the same Test method and provides error handling.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests2112.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests1(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.Bugs._2112.Tests),\n\t\t\tName = \"Test\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(0, 1L),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(0, 1)\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t{\n\t\t\t\t\tName = \"a\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<long[]>\n\t\t\t\t{\n\t\t\t\t\tName = \"arr\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._2112.Tests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._2112.Tests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Tests2112\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"Tests2112\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"Tests\",\n\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._2112\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.Bugs._2112.Tests? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tclassInstanceArguments = [];\n\n\t\t\tint methodArg = 0;\n\t\t\tlong[] methodArg1 = [1];\n\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._2112.Tests>(() => \n\t\t\tnew global::TUnit.TestProject.Bugs._2112.Tests()\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._2112.Tests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS1:TUnit.TestProject.Bugs._2112.Tests.Test(int,long[]):0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [methodArg, methodArg1],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Test(methodArg, methodArg1)),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 5,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._2112.Tests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS1:TUnit.TestProject.Bugs._2112.Tests.Test(int,long[]):0\",\n\t\t\t\tMethodName = $\"Test\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"Tests.Test failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 5,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing PlaywrightTest Class for Playwright Testing in C#\nDESCRIPTION: This class extends WorkerAwareTest and provides core functionality for Playwright tests, including browser setup and assertions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic class PlaywrightTest : TUnit.Playwright.WorkerAwareTest\n{\n    public PlaywrightTest() { }\n    public virtual string BrowserName { get; }\n    public Microsoft.Playwright.IBrowserType BrowserType { get; }\n    public static Microsoft.Playwright.IPlaywright Playwright { get; }\n    public Microsoft.Playwright.IAPIResponseAssertions Expect(Microsoft.Playwright.IAPIResponse response) { }\n    public Microsoft.Playwright.ILocatorAssertions Expect(Microsoft.Playwright.ILocator locator) { }\n    public Microsoft.Playwright.IPageAssertions Expect(Microsoft.Playwright.IPage page) { }\n    [TUnit.Core.After(TUnit.Core.HookType.TestSession, \"\", 0)]\n    public static void PlaywrightCleanup() { }\n    [TUnit.Core.Before(TUnit.Core.HookType.TestSession, \"\", 0)]\n    public static System.Threading.Tasks.Task PlaywrightSetup() { }\n    public static void SetDefaultExpectTimeout(float timeout) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TimeSpan Extensions in C#\nDESCRIPTION: Extension methods for creating TimeSpan objects from integer values representing different time units.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_81\n\nLANGUAGE: C#\nCODE:\n```\npublic static class TimeSpanExtensions\n{\n    public static System.TimeSpan Days(this int days) { }\n    public static System.TimeSpan Hours(this int hours) { }\n    public static System.TimeSpan Milliseconds(this int milliseconds) { }\n    public static System.TimeSpan Minutes(this int minutes) { }\n    public static System.TimeSpan Seconds(this int seconds) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Assembly Hooks for AssemblyBase2 in TUnit\nDESCRIPTION: Auto-generated class implementing IAssemblyHookSource to register assembly-level hooks for AssemblyBase2. It initializes and registers hooks with the SourceRegistrar and implements methods to collect hooks for different stages of assembly execution, with an AfterAll2 hook defined.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyAfterTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_AssemblyBase2 : global::TUnit.Core.Interfaces.SourceGenerator.IAssemblyHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_AssemblyBase2();\n\t\tSourceRegistrar.RegisterAssemblyHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectBeforeEveryAssemblyHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectAfterEveryAssemblyHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectBeforeAssemblyHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectAfterAssemblyHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.AfterAssemblyHookMethod\n\t\t\t{ \n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase2),\n\t\t\t\tName = \"AfterAll2\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Assembly)\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.AssemblyBase2\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase2),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AssemblyAfterTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"AssemblyAfterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"AssemblyBase2\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.AssemblyBase2.AfterAll2()),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tFilePath = @\"\",\n\t\t\t\tLineNumber = 20,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Assembly)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\tAssemblyAttributes = [],\n\t\t\t},\n\t\t];\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Core TUnit Interfaces in C#\nDESCRIPTION: Core interfaces for the TUnit framework, including IAccessesInstanceData for instance data access, IDataAttribute for data providers, and IDynamicTestRegistrar for dynamic test registration with support for dynamically accessed members.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IAccessesInstanceData { }\npublic interface IDataAttribute { }\npublic interface IDynamicTestRegistrar\n{\n    System.Threading.Tasks.Task Register<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicParameterlessConstructor | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]  TClass>(TUnit.Core.DynamicTest<TClass> dynamicTest)\n        where TClass :  class;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating TUnit Test Metadata from 'T' Source in C#\nDESCRIPTION: This private helper method generates `TestMetadata` for tests associated with the `MyTest` method, specifically using the data source method named \"T\". It retrieves test arguments by calling `TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests.T()`. It sets up test information, handles class instantiation using a `ResettableLazy` factory for potential test isolation or cleanup, defines the test execution logic via `TestMethodFactory`, and includes error handling to create `FailedTestMetadata` if initialization fails. The `sessionId` is used in the lazy factory.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenWithCancellationTokenTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests),\n\t\t\t\tName = \"MyTest\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"T\"),\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"FuncT\"),\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"EnumerableT\"),\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"EnumerableFuncT\"),\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"ArrayT\"),\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"ArrayFuncT\")\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"MethodDataSourceDrivenWithCancellationTokenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"MethodDataSourceDrivenWithCancellationTokenTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"MethodDataSourceDrivenWithCancellationTokenTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute(\"Usage\", \"TUnit0046:Return a `Func<T>` rather than a `<T>`\")\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tint methodArg = global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests.T();\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests>(() => \n\t\t\t\tnew global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests.MyTest(int,System.Threading.CancellationToken):0\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.MyTest(methodArg, cancellationToken)),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 10,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests.MyTest(int,System.Threading.CancellationToken):0\",\n\t\t\t\t\tMethodName = $\"MyTest\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"MethodDataSourceDrivenWithCancellationTokenTests.MyTest failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 10,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing OrAssertionGroupInvoker for Handling OR Logic Between Assertions\nDESCRIPTION: Class that handles the invocation of OR operations between assertion groups. It implements the awaitable pattern and allows chaining of multiple OR conditions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_76\n\nLANGUAGE: C#\nCODE:\n```\npublic class OrAssertionGroupInvoker<TActual, TAssertionBuilder>\n    where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder\n{\n    public OrAssertionGroupInvoker(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group1, TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group2) { }\n    public System.Runtime.CompilerServices.TaskAwaiter<TActual?> GetAwaiter() { }\n    public TUnit.Assertions.AssertionBuilders.Groups.OrAssertionGroupInvoker<TActual, TAssertionBuilder> Or(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Test Failure Result on Initialization Exception in TUnit (C#)\nDESCRIPTION: This C# snippet demonstrates how to handle an exception caught during the initialization of the \"RepeatTests.Three\" test. It creates a new `TUnit.Core.Exceptions.TestFailedInitializationException` instance, embedding the original `exception`, and populates a result node with this custom exception, an empty test file path, and the line number 20. This is part of the error reporting mechanism within the TUnit framework, likely used within a try-catch block that returns a collection of 'nodes' representing test results.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/RepeatTests.Test.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n\t\t\t\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"RepeatTests.Three failed to initialize\", exception),\n\t\t\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\t\t\tTestLineNumber = 20,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn nodes;\n\t\t\t\t\t}\n\t\t\t\t}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Data Generation for AutoData Test Parameters\nDESCRIPTION: Configures the data generation context for test parameters using the AutoDataAttribute. This creates the necessary metadata for generating test data instances based on parameter types.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.NonTyped.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.AutoDataTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tvar methodArgDataGeneratorMetadata = new DataGeneratorMetadata\n\t\t\t\t{\n\t\t\t\t\tType = global::TUnit.Core.Enums.DataGeneratorType.TestParameters,\n\t\t\t\t\tTestBuilderContext = testBuilderContextAccessor,\n\t\t\t\t\tTestInformation = testInformation,\n\t\t\t\t\tMembersToGenerate = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"value1\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"value2\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<double>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"value3\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"value4\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tTestSessionId = sessionId,\n\t\t\t\t\tTestClassInstance = classInstance,\n\t\t\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t\t\t};\n\t\t\t\tvar methodDataAttribute = new global::TUnit.TestProject.Attributes.AutoDataAttribute();\n\n\t\t\t\ttestBuilderContext.DataAttributes.Add(methodDataAttribute);\n\n\t\t\t\tvar methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\n```\n\n----------------------------------------\n\nTITLE: Collecting After-Test Hooks with Cancellation Support for TUnit Global Clean-Up Tests in C#\nDESCRIPTION: This snippet expands on the previous global clean-up hook, now providing a CollectAfterEveryTestHooks implementation capturing both the test context and CancellationToken as parameters. It sets up the static after-every-test hook with detailed parameter metadata for cancellation, facilitating async cancellation support in the executed test clean-up logic. Used in auto-generated files with TUnit, this supports more graceful teardown operations that honor cancellation requests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticAfterEachTests.Test.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_GlobalCleanUpTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_GlobalCleanUpTests();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.AfterTestHookMethod\n\t\t\t{ \n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),\n\t\t\t\tName = \"AfterAllCleanUp\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterEveryAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"context\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.GlobalCleanUpTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"GlobalStaticAfterEachTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"GlobalStaticAfterEachTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"GlobalCleanUpTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.GlobalCleanUpTests.AfterAllCleanUp(context, cancellationToken)),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tFilePath = @\"\",\n\t\t\t\tLineNumber = 56,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterEveryAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\tAssemblyAttributes = [],\n\t\t\t},\n\t\t];\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AssertionMetadata Class in C#\nDESCRIPTION: Defines the `AssertionMetadata` class to hold metadata about an assertion's execution. It includes the start time, end time (both as `DateTimeOffset` with init-only setters), and calculates the duration. The `Obsolete` attribute indicates a potential issue with required members in older compiler versions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_29\n\nLANGUAGE: csharp\nCODE:\n```\n    public class AssertionMetadata\n    {\n        [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n            \"your compiler.\", true)]\n        public AssertionMetadata() { }\n        public System.TimeSpan Duration { get; }\n        public System.DateTimeOffset EndTime { get; init; }\n        public System.DateTimeOffset StartTime { get; init; }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Time-Related Assertion Builders in C#\nDESCRIPTION: Defines wrapper classes for TimeOnly and TimeSpan assertion builders with a 'Within' method for specifying tolerance.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\npublic class TimeOnlyEqualToAssertionBuilderWrapper : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.TimeOnly>\n{\n    public TUnit.Assertions.AssertionBuilders.Wrappers.TimeOnlyEqualToAssertionBuilderWrapper Within(System.TimeSpan tolerance, [System.Runtime.CompilerServices.CallerArgumentExpression(\"tolerance\")] string doNotPopulateThis = \"\") { }\n}\n\npublic class TimeSpanEqualToAssertionBuilderWrapper : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.TimeSpan>\n{\n    public TUnit.Assertions.AssertionBuilders.Wrappers.TimeSpanEqualToAssertionBuilderWrapper Within(System.TimeSpan tolerance, [System.Runtime.CompilerServices.CallerArgumentExpression(\"tolerance\")] string doNotPopulateThis = \"\") { }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Registering Before Test Discovery Hooks in TUnit - C#\nDESCRIPTION: This C# snippet defines an auto-generated partial class implementing TUnit.Core.Interfaces.SourceGenerator.ITestDiscoveryHookSource. It provides a module initializer that registers the source with TUnit's SourceRegistrar, and implements CollectBeforeTestDiscoveryHooks to return a list of BeforeTestDiscoveryHookMethod instances, representing hooks to run before test discovery begins. The method metadata, including type, name, attributes (BeforeEveryAttribute), and a delegate for execution, are constructed using TUnit core utilities. No after-discovery hooks are collected in this snippet. Expected input is a sessionId string. Requires TUnit.Core.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/TestDiscoveryHookTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// <auto-generated/>\\n#pragma warning disable\\nusing global::System.Linq;\\nusing global::System.Reflection;\\nusing global::System.Runtime.CompilerServices;\\nusing global::TUnit.Core;\\nusing global::TUnit.Core.Hooks;\\nusing global::TUnit.Core.Interfaces;\\n\\nnamespace TUnit.SourceGenerated;\\n\\n[global::System.Diagnostics.StackTraceHidden]\\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\\nfile partial class Hooks_TestDiscoveryHookTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestDiscoveryHookSource\\n{\\n\\t[global::System.Runtime.CompilerServices.ModuleInitializer]\\n\\tpublic static void Initialise()\\n\\t{\\n\\t\\tvar instance = new Hooks_TestDiscoveryHookTests();\\n\\t\\tSourceRegistrar.RegisterTestDiscoveryHookSource(instance);\\n\\t}\\n\\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.BeforeTestDiscoveryContext>> CollectBeforeTestDiscoveryHooks(string sessionId)\\n\\t{\\n\\t\\treturn\\n\\t\\t[\\n\\t\\t\\tnew global::TUnit.Core.Hooks.BeforeTestDiscoveryHookMethod\\n\\t\\t\\t{\\n\\t\\t\\t\\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tType = typeof(global::TUnit.TestProject.TestDiscoveryHookTests),\\n\\t\\t\\t\\t\\tName = \\\"BeforeDiscovery\\\",\\n\\t\\t\\t\\t\\tGenericTypeCount = 0,\\n\\t\\t\\t\\t\\tReturnType = typeof(void),\\n\\t\\t\\t\\t\\tAttributes = \\n\\t\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\t\\tnew global::TUnit.Core.BeforeEveryAttribute(global::TUnit.Core.HookType.TestDiscovery)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tOrder = 5,\\n}\\n\\t\\t\\t\\t\\t\\t],\\n\\t\\t\\t\\t\\tParameters = [],\\n\\t\\t\\t\\t\\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\\\"global::TUnit.TestProject.TestDiscoveryHookTests\\\", () => new global::TUnit.Core.SourceGeneratedClassInformation\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tType = typeof(global::TUnit.TestProject.TestDiscoveryHookTests),\\n\\t\\t\\t\\t\\t\\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\\\"TestDiscoveryHookTests\\\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tName = \\\"TestDiscoveryHookTests\\\",\\n\\t\\t\\t\\t\\t\\t\\tAttributes = [],\\n\\t\\t\\t\\t\\t\\t}),\\n\\t\\t\\t\\t\\t\\tName = \\\"TestDiscoveryHookTests\\\",\\n\\t\\t\\t\\t\\t\\tNamespace = \\\"TUnit.TestProject\\\",\\n\\t\\t\\t\\t\\t\\tAttributes = [],\\n\\t\\t\\t\\t\\t\\tParameters = [],\\n\\t\\t\\t\\t\\t\\tProperties = [],\\n\\t\\t\\t\\t\\t}),\\n},\\n\\t\\t\\t\\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.TestDiscoveryHookTests.BeforeDiscovery()),\\n\\t\\t\\t\\tHookExecutor = DefaultExecutor.Instance,\\n\\t\\t\\t\\tOrder = 5,\\n\\t\\t\\t\\tFilePath = @\\\"\\\",\\n\\t\\t\\t\\tLineNumber = 5,\\n\\t\\t\\t\\tMethodAttributes = \\n\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\tnew global::TUnit.Core.BeforeEveryAttribute(global::TUnit.Core.HookType.TestDiscovery)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tOrder = 5,\\n}\\n\\t\\t\\t\\t],\\n\\t\\t\\t\\tClassAttributes = [],\\n\\t\\t\\t\\tAssemblyAttributes = [],\\n\\t\\t\\t},\\n\\t\\t];\\n\\t}\\n\\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestDiscoveryContext>> CollectAfterTestDiscoveryHooks(string sessionId)\\n\\t{\\n\\t\\treturn\\n\\t\\t[\\n\\t\\t];\\n\\t}\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Assembly Hook Source in C#\nDESCRIPTION: This static method initializes an instance of Hooks_AssemblyCleanupTests and registers it as an assembly hook source. It's marked with the ModuleInitializer attribute to ensure it's called when the module is loaded.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyAfterTests.Test.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tvar instance = new Hooks_AssemblyCleanupTests();\n\tSourceRegistrar.RegisterAssemblyHookSource(instance);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring TUnit Test Properties in C#\nDESCRIPTION: This snippet demonstrates setting up properties and attributes for tests in the TUnit framework. It initializes various properties such as test attributes, method factories, and handles exceptions by creating failed test initialization nodes. The snippet requires the TUnit framework and depends on classes like MethodDataSourceAttribute and TestAttribute. Inputs are assigned directly within the code, output is the list of nodes which may contain failed test elements in case of exceptions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=NamedTupleMethod_testMethodName=TupleMethod.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nTestClassProperties = [propertyArg, propertyArg1, propertyArg2, propertyArg3],\nCurrentRepeatAttempt = 0,\nRepeatLimit = 0,\nMethodInfo = methodInfo,\nResettableClassFactory = resettableClassFactory,\nTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_TupleMethod(methodArg, methodArg1, methodArg2)),\nTestFilePath = @\"\",\nTestLineNumber = 24,\nTestAttributes = [ new global::TUnit.Core.TestAttribute()\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n{\n    \n} ],\nClassAttributes = [ new global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n{\n    \n} ],\nAssemblyAttributes = [  ],\nDataAttributes = [  ],\nTestBuilderContext = testBuilderContext,\n});\nresettableClassFactory = resettableClassFactoryDelegate();\ntestBuilderContext = new();\ntestBuilderContextAccessor.Current = testBuilderContext;\n}\ncatch (global::System.Exception exception)\n{\nnodes.Add(new FailedInitializationTest\n{\nTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS1:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.ClassTupleDataSourceDrivenTests(System.Int32,System.String,System.Boolean).DataSource_TupleMethod(System.Int32,System.String,System.Boolean):0\",\nTestClass = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests),\nReturnType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests).GetMethod(\"DataSource_TupleMethod\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]).ReturnType,\nParameterTypeFullNames = [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)],\nTestName = \"DataSource_TupleMethod\",\nTestFilePath = @\"\",\nTestLineNumber = 24,\nException = exception,\n});\n}\nreturn nodes;\n}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Hooks for Base1\nDESCRIPTION: Source-generated partial class implementing ITestHookSource interface for Base1 test class. Defines instance-level test hooks and registration logic.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_Base1 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_Base1();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing Value Source Interfaces in C#\nDESCRIPTION: Classes implementing value source interfaces for delegate and value conversion in the assertion framework\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_62\n\nLANGUAGE: C#\nCODE:\n```\npublic class ConvertedDelegateSource<TToType> : TUnit.Assertions.AssertConditions.Interfaces.ISource, TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TToType?>\n    where TToType : System.Exception\n{\n    public ConvertedDelegateSource(TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource source) { }\n    public string? ActualExpression { get; }\n    public System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertionData> AssertionDataTask { get; }\n    public System.Collections.Generic.Stack<TUnit.Assertions.AssertConditions.BaseAssertCondition> Assertions { get; }\n    public System.Text.StringBuilder ExpressionBuilder { get; }\n    public TUnit.Assertions.AssertConditions.Interfaces.ISource AppendExpression(string expression) { }\n    public TUnit.Assertions.AssertConditions.Interfaces.ISource WithAssertion(TUnit.Assertions.AssertConditions.BaseAssertCondition assertCondition) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Test Initialization Failures in C#\nDESCRIPTION: Exception handling code that captures failures during test initialization. It creates FailedTestMetadata entries with detailed error information to help with debugging and test reporting.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ClassDataSourceDrivenTests>\n\t{\n\t\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.InitializableClass>:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.ClassDataSourceDrivenTests.IsInitialized_With_1_ClassDataSource(TUnit.TestProject.InitializableClass):0\",\n\t\tMethodName = $\"IsInitialized_With_1_ClassDataSource\",\n\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ClassDataSourceDrivenTests.IsInitialized_With_1_ClassDataSource failed to initialize\", exception),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 24,\n\t});\n}\nreturn nodes;\n```\n\n----------------------------------------\n\nTITLE: Registering Int-Parameterized Tests - TUnit Source Generator - C#\nDESCRIPTION: Defines the source-generated implementation for discovering and registering parameterized tests (with an integer argument) using TUnit. This snippet creates all runtime objects, attributes, parameters, and metadata for the test method named 'Int'. It registers the generated test with the TUnit test runner using a module initializer. Dependencies include TUnit.Core and related metadata classes; the input is a sessionId and the output is a list of TestMetadata representing all discovered int tests. Intended for auto-generated environments; users should not edit this code directly.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/NumberArgumentTests.TestDE.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\\n#pragma warning disable\\nusing global::System.Linq;\\nusing global::System.Reflection;\\nusing global::TUnit.Core;\\nusing global::TUnit.Core.Extensions;\\n\\nnamespace TUnit.SourceGenerated;\\n\\n[global::System.Diagnostics.StackTraceHidden]\\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\\nfile partial class NumberArgumentTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\\n{\\n\\t[global::System.Runtime.CompilerServices.ModuleInitializer]\\n\\tpublic static void Initialise()\\n\\t{\\n\\t\\tglobal::TUnit.Core.SourceRegistrar.Register(new NumberArgumentTests());\\n\\t}\\n\\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\\n\\t{\\n\\t\\treturn Tests0(sessionId);\\n\\t}\\n\\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\\n\\t{\\n\\t\\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\\n\\t\\tvar classDataIndex = 0;\\n\\t\\tvar testMethodDataIndex = 0;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\\n\\t\\t\\t{\\n\\t\\t\\t\\tType = typeof(global::TUnit.TestProject.NumberArgumentTests),\\n\\t\\t\\t\\tName = \"Int\",\\n\\t\\t\\t\\tGenericTypeCount = 0,\\n\\t\\t\\t\\tReturnType = typeof(void),\\n\\t\\t\\t\\tAttributes = \\n\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\tnew global::TUnit.Core.TestAttribute(),\\n\\t\\t\\t\\t\\tnew global::TUnit.Core.ArgumentsAttribute(1)\\n\\t\\t\\t\\t],\\n\\t\\t\\t\\tParameters = \\n\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tName = \"i\",\\n\\t\\t\\t\\t\\t\\tAttributes = [],\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t],\\n\\t\\t\\t\\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.NumberArgumentTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tType = typeof(global::TUnit.TestProject.NumberArgumentTests),\\n\\t\\t\\t\\t\\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"NumberArgumentTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tName = \"NumberArgumentTests\",\\n\\t\\t\\t\\t\\t\\tAttributes = [],\\n\\t\\t\\t\\t\\t}),\\n\\t\\t\\t\\t\\tName = \"NumberArgumentTests\",\\n\\t\\t\\t\\t\\tNamespace = \"TUnit.TestProject\",\\n\\t\\t\\t\\t\\tAttributes = [],\\n\\t\\t\\t\\t\\tParameters = [],\\n\\t\\t\\t\\t\\tProperties = [],\\n\\t\\t\\t\\t}),\\n};\\n\\n\\t\\t\\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\\n\\t\\t\\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\\n\\t\\t\\tglobal::TUnit.TestProject.NumberArgumentTests? classInstance = null;\\n\\t\\t\\tobject?[]? classInstanceArguments = null;\\n\\t\\t\\tclassInstanceArguments = [];\\n\\n\\t\\t\\tint methodArg = 1;\\n\\n\\t\\t\\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.NumberArgumentTests>(() => \\n\\t\\t\\tnew global::TUnit.TestProject.NumberArgumentTests()\\n\\t\\t\\t, sessionId, testBuilderContext);\\n\\t\\t\\tvar resettableClassFactory = resettableClassFactoryDelegate();\\n\\n\\t\\t\\tnodes.Add(new TestMetadata<global::TUnit.TestProject.NumberArgumentTests>\\n\\t\\t\\t{\\n\\t\\t\\t\\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NumberArgumentTests.Int(int):0\",\\n\\t\\t\\t\\tTestClassArguments = [],\\n\\t\\t\\t\\tTestMethodArguments = [methodArg],\\n\\t\\t\\t\\tTestClassProperties = [],\\n\\t\\t\\t\\tCurrentRepeatAttempt = 0,\\n\\t\\t\\t\\tRepeatLimit = 0,\\n\\t\\t\\t\\tResettableClassFactory = resettableClassFactory,\\n\\t\\t\\t\\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Int(methodArg)),\\n\\t\\t\\t\\tTestFilePath = @\"\",\\n\\t\\t\\t\\tTestLineNumber = 5,\\n\\t\\t\\t\\tTestMethod = testInformation,\\n\\t\\t\\t\\tTestBuilderContext = testBuilderContext,\\n\\t\\t\\t});\\n\\t\\t\\tresettableClassFactory = resettableClassFactoryDelegate();\\n\\t\\t\\ttestBuilderContext = new();\\n\\t\\t\\ttestBuilderContextAccessor.Current = testBuilderContext;\\n\\t\\t}\\n\\t\\tcatch (global::System.Exception exception)\\n\\t\\t{\\n\\t\\t\\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.NumberArgumentTests>\\n\\t\\t\\t{\\n\\t\\t\\t\\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NumberArgumentTests.Int(int):0\",\\n\\t\\t\\t\\tMethodName = $\"Int\",\\n\\t\\t\\t\\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"NumberArgumentTests.Int failed to initialize\", exception),\\n\\t\\t\\t\\tTestFilePath = @\"\",\\n\\t\\t\\t\\tTestLineNumber = 5,\\n\\t\\t\\t});\\n\\t\\t}\\n\\t\\treturn nodes;\\n\\t}\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Implementing After Test Session Hook Method in C#\nDESCRIPTION: Defines the AfterTestSessionHookMethod class which executes after a test session. It inherits from StaticHookMethod and implements IEquatable.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\npublic class AfterTestSessionHookMethod : TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.TestSessionContext>, System.IEquatable<TUnit.Core.Hooks.AfterTestSessionHookMethod>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public AfterTestSessionHookMethod() { }\n    public override System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.TestSessionContext context, System.Threading.CancellationToken cancellationToken) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BeforeAllSetUp Hook with No Parameters for TUnit in C#\nDESCRIPTION: Defines a SourceGeneratedMethodInformation for a BeforeAllSetUp method executed before assembly tests in TUnit, with no parameters. Requires TUnit.Core, System.Threading.Tasks, and proper registration of AssemblySetupTests. The method is attributed for use as an assembly-level before-test hook and is executed asynchronously.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyBeforeTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.BeforeTests.AssemblySetupTests),\n\tName = \"BeforeAllSetUp\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Assembly)\n\t],\n\tParameters = [],\n\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.AssemblySetupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t{\n\t\tType = typeof(global::TUnit.TestProject.BeforeTests.AssemblySetupTests),\n\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AssemblyBeforeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t{\n\t\t\tName = \"AssemblyBeforeTests\",\n\t\t\tAttributes = [],\n\t\t}),\n\t\tName = \"AssemblySetupTests\",\n\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\tAttributes = [],\n\t\tParameters = [],\n\t\tProperties = [],\n\t}),\n},\nBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.BeforeTests.AssemblySetupTests.BeforeAllSetUp()),\nHookExecutor = DefaultExecutor.Instance,\nOrder = 0,\nFilePath = @\"\",\nLineNumber = 50,\nMethodAttributes = \n[\n\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Assembly)\n],\nClassAttributes = [],\nAssemblyAttributes = [],\n\n```\n\n----------------------------------------\n\nTITLE: Initializing TUnit Test Source Registration\nDESCRIPTION: Module initializer that registers the test source with TUnit's source registrar system\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=TupleMethod_testMethodName=NamedTupleMethod.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tSourceRegistrar.Register(new ClassTupleDataSourceDrivenTests());\n}\n```\n\n----------------------------------------\n\nTITLE: Tests4 Method Implementation for Test Discovery in C#\nDESCRIPTION: This method generates test metadata for a specific test scenario. It creates source-generated method information with test attributes, sets up the test context, and handles both successful setup and exceptions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceClassCombinedWithDataSourceMethodTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests4(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod),\n\t\t\tName = \"DataSourceClassCombinedWithDataSourceMethodTest\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"One\"),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Two\"),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Three\")\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t{\n\t\t\t\t\tName = \"i\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataSourceClassCombinedWithDataSourceMethodTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"DataSourceClassCombinedWithDataSourceMethodTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"DataSourceClassCombinedWithDataSourceMethod\",\n\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"One\"),\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Two\"),\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Three\")\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"i\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tint classArg = global::TUnit.TestProject.CommonTestData.Two();\n\t\t\tclassInstanceArguments = [classArg];\n\n\t\t\tint methodArg = global::TUnit.TestProject.CommonTestData.Two();\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod>(() => \n\t\t\tnew global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod(classArg)\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS1:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod(int).DataSourceClassCombinedWithDataSourceMethodTest(int):0\",\n\t\t\t\tTestClassArguments = [classArg],\n\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSourceClassCombinedWithDataSourceMethodTest(methodArg)),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 10,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS1:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod(int).DataSourceClassCombinedWithDataSourceMethodTest(int):0\",\n\t\t\t\tMethodName = $\"DataSourceClassCombinedWithDataSourceMethodTest\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"DataSourceClassCombinedWithDataSourceMethod.DataSourceClassCombinedWithDataSourceMethodTest failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 10,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing NotNullAssertionBuilderWrapper for Reference Type Null Checking\nDESCRIPTION: Specialized assertion builder for checking that reference type values are not null. It implements the awaitable pattern to return the actual value when awaited.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_89\n\nLANGUAGE: C#\nCODE:\n```\npublic class NotNullAssertionBuilderWrapper<TActual> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>\n    where TActual :  class\n{\n    public new System.Runtime.CompilerServices.TaskAwaiter<TActual> GetAwaiter() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel Group Attribute in C#\nDESCRIPTION: Defines an attribute for organizing tests into parallel execution groups. Tests in the same group may have special parallel execution rules applied to them.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic class ParallelGroupAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver\n{\n    public ParallelGroupAttribute(string group) { }\n    public string Group { get; }\n    public int Order { get; set; }\n    public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Benchmarking .NET Tests using BenchmarkDotNet on Windows\nDESCRIPTION: This snippet shows benchmarking statistics for various .NET testing frameworks using BenchmarkDotNet. It includes performance metrics like mean execution times and error margins for methodologies implemented on .NET 9.0. The setup references specific hardware and SDK versions used during the benchmarking.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/README.md#2025-04-22_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\nBenchmarkDotNet v0.14.0, Windows 10 (10.0.20348.3328) (Hyper-V)\nAMD EPYC 7763, 1 CPU, 4 logical and 2 physical cores\n.NET SDK 9.0.203\n  [Host]   : .NET 9.0.4 (9.0.425.16305), X64 RyuJIT AVX2\n  .NET 9.0 : .NET 9.0.4 (9.0.425.16305), X64 RyuJIT AVX2\n\nJob=.NET 9.0  Runtime=.NET 9.0\n\n| Method    | Mean       | Error    | StdDev   |\n|---------- |-----------:|---------:|---------:|\n| TUnit_AOT |   110.3 ms |  2.16 ms |  2.31 ms |\n| TUnit     |   931.0 ms | 18.43 ms | 27.02 ms |\n| NUnit     | 7,492.7 ms | 16.53 ms | 15.46 ms |\n| xUnit     | 7,566.1 ms | 32.37 ms | 30.28 ms |\n| MSTest    | 7,433.9 ms | 23.68 ms | 22.15 ms |\n```\n\n----------------------------------------\n\nTITLE: Instantiating Test Class Arguments and Tuple Properties - TUnit - C#\nDESCRIPTION: Prepares and extracts class and property arguments using static tuple-producing methods for use in test instantiation, leveraging System.TupleExtensions and referencing static test methods. Assumes ClassTupleDataSourceDrivenTests implements TupleMethod and NamedTupleMethod. Inputs are method calls returning tuples, outputs are properly-typed arguments used in test construction. No external dependencies beyond TUnit.Core and System.TupleExtensions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.ClassTupleDataSourceDrivenTests? classInstance = null;\nobject?[]? classInstanceArguments = null;\nvar classArgTuples = global::System.TupleExtensions.ToTuple<int, string, bool>(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()());\nint classArg = classArgTuples.Item1;\nstring classArg1 = classArgTuples.Item2;\nbool classArg2 = classArgTuples.Item3;\nclassInstanceArguments = [classArg, classArg1, classArg2];\n(int, string, bool) propertyArg = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()();\n(int Number, string Word, bool Flag) propertyArg1 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()();\n(int, string, bool) propertyArg2 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()();\n(int Number, string Word, bool Flag) propertyArg3 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()();\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Parallelization with NotInParallel Attribute in C#\nDESCRIPTION: Demonstrates how to use the NotInParallel attribute to control test execution parallelization. Shows examples of using constraint keys to prevent specific tests from running in parallel with others that share the same constraint keys.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/not-in-parallel.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    private const string DatabaseTest = \"DatabaseTest\";\n    private const string RegistrationTest = \"RegistrationTest\";\n    private const string ParallelTest = \"ParallelTest\";\n\n    [Test]\n    [NotInParallel(DatabaseTest)]\n    public async Task MyTest()\n    {\n        \n    }\n\n    [Test]\n    [NotInParallel(DatabaseTest, RegistrationTest)]\n    public async Task MyTest2()\n    {\n        \n    }\n\n    [Test]\n    [NotInParallel(ParallelTest)]\n    public async Task MyTest3()\n    {\n        \n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering TUnit Test Source via Module Initializer in C#\nDESCRIPTION: This static method, annotated with `ModuleInitializer`, ensures that an instance of the auto-generated `MethodDataSourceDrivenWithCancellationTokenTests` class is registered with the TUnit `SourceRegistrar` when the module loads. This makes the tests defined within this source generator output discoverable by the TUnit test runner.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenWithCancellationTokenTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new MethodDataSourceDrivenWithCancellationTokenTests());\n\t}\n```\n\n----------------------------------------\n\nTITLE: Test Source Generator Class Definition - Part 2\nDESCRIPTION: Additional partial class implementation for CustomDisplayNameTests that handles test collection and initialization for PasswordTest. Includes data generation and test builder context setup.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/CustomDisplayNameTests.Test.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class CustomDisplayNameTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new CustomDisplayNameTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Test Information and Metadata for DataSource_Method_WithAction (C#)\nDESCRIPTION: This C# snippet initializes `SourceGeneratedMethodInformation` for a test method named `DataSource_Method_WithAction` which uses a `MethodDataSourceAttribute` referencing `SomeAction`. It retrieves the test argument by invoking `SomeAction`, sets up a `TestBuilderContext`, creates a `ResettableLazy` factory for the test class instance, and adds `TestMetadata` to a collection. It includes a try-catch block to handle potential exceptions during initialization, adding `FailedTestMetadata` if an error occurs.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n\t\t\t\tType = typeof(global::TUnit.TestProject.MethodDataSourceDrivenTests),\n\t\t\t\tName = \"DataSource_Method_WithAction\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"SomeAction\")\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Action>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"action\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.MethodDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.MethodDataSourceDrivenTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"MethodDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"MethodDataSourceDrivenTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"MethodDataSourceDrivenTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.MethodDataSourceDrivenTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tglobal::System.Action methodArg = global::TUnit.TestProject.MethodDataSourceDrivenTests.SomeAction()();\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.MethodDataSourceDrivenTests>(() => \n\t\t\t\tnew global::TUnit.TestProject.MethodDataSourceDrivenTests()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.MethodDataSourceDrivenTests.DataSource_Method_WithAction(void System.Action()):0\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_Method_WithAction(methodArg)),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 26,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.MethodDataSourceDrivenTests.DataSource_Method_WithAction(void System.Action()):0\",\n\t\t\t\t\tMethodName = $\"DataSource_Method_WithAction\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"MethodDataSourceDrivenTests.DataSource_Method_WithAction failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 26,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n\t}\n\n  \n```\n\n----------------------------------------\n\nTITLE: Implementing OrAssertionGroup for Combining Assertions with OR Logic\nDESCRIPTION: Class that represents a group of assertions combined with OR logic. It extends the base AssertionGroup class and implements the awaitable pattern, allowing for fluent assertion chaining.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_77\n\nLANGUAGE: C#\nCODE:\n```\npublic class OrAssertionGroup<TActual, TAssertionBuilder> : TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder>\n    where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder\n{\n    public override System.Runtime.CompilerServices.TaskAwaiter<TActual?> GetAwaiter() { }\n    public TUnit.Assertions.AssertionBuilders.Groups.OrAssertionGroup<TActual, TAssertionBuilder> Or(System.Func<TAssertionBuilder, TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TActual>> assert) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Tests Across Multiple Test Methods\nDESCRIPTION: Collects test metadata from multiple test methods and combines them into a single collection. Each test method is represented by a separate TestsN method that returns a list of test metadata.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests2083.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn\n\t[\n\t\t..Tests0(sessionId),\n\t\t..Tests1(sessionId),\n\t\t..Tests2(sessionId),\n\t\t..Tests3(sessionId),\n\t\t..Tests4(sessionId),\n\t\t..Tests5(sessionId),\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: TestContextExtensions for Test Registration\nDESCRIPTION: Provides an extension method to re-register a test with specific arguments and optional object bag. This allows for parameterized test execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class TestContextExtensions\n{\n    public static System.Threading.Tasks.Task ReregisterTestWithArguments(this TUnit.Core.TestContext testContext, object?[]? methodArguments, System.Collections.Generic.Dictionary<string, object?>? objectBag = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AssertionType Enum for Categorizing Assertions\nDESCRIPTION: Defines a flags enum that categorizes assertion types as either Value or Delegate, used for determining assertion behavior.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_65\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Flags]\npublic enum AssertionType\n{\n    Value = 1,\n    Delegate = 2,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining That Assertion for Task<TActual> in C#\nDESCRIPTION: This generic overload of the static `That` method accepts a `Task<TActual>` representing an asynchronous operation with a result. It returns an `AsyncValueDelegateAssertionBuilder<TActual>` allowing assertions on the task's result upon completion. The `CallerArgumentExpression` captures the source expression.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n        public static TUnit.Assertions.AssertionBuilders.AsyncValueDelegateAssertionBuilder<TActual> That<TActual>(System.Threading.Tasks.Task<TActual> value, [System.Runtime.CompilerServices.CallerArgumentExpression(\"value\")] string? doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Last Test in Assembly Adapter in C#\nDESCRIPTION: Defines the LastTestInAssemblyAdapter class which adapts the last test in an assembly event to the IExecutableHook interface.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_53\n\nLANGUAGE: C#\nCODE:\n```\npublic class LastTestInAssemblyAdapter : TUnit.Core.Hooks.IExecutableHook<TUnit.Core.AssemblyHookContext>\n{\n    public LastTestInAssemblyAdapter(TUnit.Core.Interfaces.ILastTestInAssemblyEventReceiver lastTestInAssemblyEventReceiver, TUnit.Core.TestContext testContext) { }\n    public TUnit.Core.SourceGeneratedMethodInformation MethodInfo { get; }\n    public string Name { get; }\n    public int Order { get; }\n    public bool Execute(TUnit.Core.AssemblyHookContext context, System.Threading.CancellationToken cancellationToken) { }\n    public System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.AssemblyHookContext context, System.Threading.CancellationToken cancellationToken) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Global Test Hooks for GlobalBase3 in C#\nDESCRIPTION: Defines a partial class Hooks_GlobalBase3 that implements ITestHookSource. It registers a before-test hook method 'BeforeEach3' from the GlobalBase3 class.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticBeforeEachTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_GlobalBase3 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_GlobalBase3();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.BeforeTests.GlobalBase3),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.GlobalBase3),\n\t\t\t\t\tName = \"BeforeEach3\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.GlobalBase3\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.GlobalBase3),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"GlobalStaticBeforeEachTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"GlobalStaticBeforeEachTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"GlobalBase3\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.BeforeTests.GlobalBase3)classInstance).BeforeEach3()),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for DataSource_Method in C#\nDESCRIPTION: This snippet defines test metadata for DataSource_Method, including method information, parameter details, and test execution factories. It handles test initialization and exception handling for the TUnit test framework.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ntry\n{\n\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t{\n\t\tType = typeof(global::TUnit.TestProject.MethodDataSourceDrivenTests),\n\t\tName = \"DataSource_Method\",\n\t\tGenericTypeCount = 0,\n\t\tReturnType = typeof(void),\n\t\tAttributes = \n\t\t[\n\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"SomeMethod\")\n\t\t],\n\t\tParameters = \n\t\t[\n\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t{\n\t\t\t\tName = \"value\",\n\t\t\t\tAttributes = [],\n\t\t\t},\n\t\t],\n\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.MethodDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.MethodDataSourceDrivenTests),\n\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"MethodDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t{\n\t\t\t\tName = \"MethodDataSourceDrivenTests\",\n\t\t\t\tAttributes = [],\n\t\t\t}),\n\t\t\tName = \"MethodDataSourceDrivenTests\",\n\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\tAttributes = [],\n\t\t\tParameters = [],\n\t\t\tProperties = [],\n\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.MethodDataSourceDrivenTests? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tclassInstanceArguments = [];\n\n\t\t\tint methodArg = global::TUnit.TestProject.MethodDataSourceDrivenTests.SomeMethod();\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.MethodDataSourceDrivenTests>(() => \n\t\t\tnew global::TUnit.TestProject.MethodDataSourceDrivenTests()\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.MethodDataSourceDrivenTests.DataSource_Method(int):0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_Method(methodArg)),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 12,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.MethodDataSourceDrivenTests.DataSource_Method(int):0\",\n\t\t\t\tMethodName = $\"DataSource_Method\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"MethodDataSourceDrivenTests.DataSource_Method failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 12,\n\t\t\t});\n```\n\n----------------------------------------\n\nTITLE: Processing Generated AutoData Test Instances\nDESCRIPTION: Processes each generated test data instance to create test metadata records for execution. This loop handles casting parameters to their correct types and creating resettable test class instances.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.NonTyped.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n\t\t\t\tforeach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\n\t\t\t\t{\n\t\t\t\t\ttestMethodDataIndex++;\n\t\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\t\tvar methodArgGeneratedData = methodArgGeneratedDataAccessor();\n\t\t\t\t\tstring methodArg = global::TUnit.Core.Helpers.CastHelper.Cast<string>(methodArgGeneratedData[0]);\n\t\t\t\t\tint methodArg1 = global::TUnit.Core.Helpers.CastHelper.Cast<int>(methodArgGeneratedData[1]);\n\t\t\t\t\tdouble methodArg2 = global::TUnit.Core.Helpers.CastHelper.Cast<double>(methodArgGeneratedData[2]);\n\t\t\t\t\tbool methodArg3 = global::TUnit.Core.Helpers.CastHelper.Cast<bool>(methodArgGeneratedData[3]);\n\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.AutoDataTests>(() => \n\t\t\t\t\tnew global::TUnit.TestProject.AutoDataTests()\n\t\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n```\n\n----------------------------------------\n\nTITLE: Registering AfterClass Hooks for Base2 using Source Generation in C#\nDESCRIPTION: This auto-generated C# snippet defines a partial class `Hooks_Base2` implementing `IClassHookSource` for TUnit. It registers itself using `ModuleInitializer`. The `CollectAfterClassHooks` method provides metadata for the static `AfterAll2` method in the `TUnit.TestProject.AfterTests.Base2` class, identified by the `[After(HookType.Class)]` attribute, to be executed after all tests in the class.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_Base2 : global::TUnit.Core.Interfaces.SourceGenerator.IClassHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_Base2();\n\t\tSourceRegistrar.RegisterClassHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.AfterClassHookMethod\n\t\t\t{\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.Base2),\n\t\t\t\t\tName = \"AfterAll2\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.Base2\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.Base2),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AfterTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"AfterTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"Base2\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.Base2.AfterAll2()),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tFilePath = @\"\",\n\t\t\t\t\tLineNumber = 20,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\tAssemblyAttributes = [],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing EnumDoesNotHaveFlagAssertCondition in C#\nDESCRIPTION: Assertion condition that checks if an enum value does not have a specific flag set. Used for bitwise enum assertions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_100\n\nLANGUAGE: C#\nCODE:\n```\n    public class EnumDoesNotHaveFlagAssertCondition<TEnum> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TEnum>\n        where TEnum : System.Enum\n    {\n        public EnumDoesNotHaveFlagAssertCondition(TEnum expected) { }\n        protected override string GetExpectation() { }\n        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TEnum? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Generating Matrix Test Metadata for Method3 Using MatrixDataSourceAttribute - C#\nDESCRIPTION: This snippet mirrors the structure of Method2, now targeting the Method3 method of MatrixTests and using a distinct method attribute (IntMethod) for its test parameter. It ensures that each data-driven variant for Method3 is collected with full context, supporting error handling and detailed test metadata output. It depends on TUnit.Core, uses the MatrixMethodAttribute, and expects the required data sources to be available through user-defined methods; returns a list of TestMetadata with proper initialization for each permutation.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MatrixTests.Test.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\\n{\\n\\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\\n\\tvar classDataIndex = 0;\\n\\tvar testMethodDataIndex = 0;\\n\\ttry\\n\\t{\\n\\t\\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\\n\\t\\t{\\n\\t\\t\\tType = typeof(global::TUnit.TestProject.MatrixTests),\\n\\t\\t\\tName = \"Method3\",\\n\\t\\t\\tGenericTypeCount = 0,\\n\\t\\t\\tReturnType = typeof(global::System.Threading.Tasks.Task),\\n\\t\\t\\tAttributes = \\n\\t\\t\\t[\\n\\t\\t\\t\\tnew global::TUnit.Core.TestAttribute(),\\n\\t\\t\\t\\tnew global::TUnit.Core.MatrixDataSourceAttribute()\\n\\t\\t\\t],\\n\\t\\t\\tParameters = \\n\\t\\t\\t[\\n\\t\\t\\t\\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tName = \"item\",\\n\\t\\t\\t\\t\\tAttributes = \\n\\t\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\t\\tnew global::TUnit.Core.MatrixMethodAttribute<global::TUnit.TestProject.MatrixTests>(\"IntMethod\")\\n\\t\\t\\t\\t\\t],\\n\\t\\t\\t\\t},\\n\\t\\t\\t],\\n\\t\\t\\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.MatrixTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\\n\\t\\t\\t{\\n\\t\\t\\t\\tType = typeof(global::TUnit.TestProject.MatrixTests),\\n\\t\\t\\t\\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"MatrixTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tName = \"MatrixTests\",\\n\\t\\t\\t\\t\\tAttributes = [],\\n\\t\\t\\t\\t}),\\n\\t\\t\\t\\tName = \"MatrixTests\",\\n\\t\\t\\t\\tNamespace = \"TUnit.TestProject\",\\n\\t\\t\\t\\tAttributes = [],\\n\\t\\t\\t\\tParameters = [],\\n\\t\\t\\t\\tProperties = [],\\n\\t\\t\\t}),\\n};\\n\\n\\t\\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\\n\\t\\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\\n\\t\\tglobal::TUnit.TestProject.MatrixTests? classInstance = null;\\n\\t\\tobject?[]? classInstanceArguments = null;\\n\\t\\tvar methodArgDataGeneratorMetadata = new DataGeneratorMetadata\\n\\t\\t{\\n\\t\\t\\tType = global::TUnit.Core.Enums.DataGeneratorType.TestParameters,\\n\\t\\t\\tTestBuilderContext = testBuilderContextAccessor,\\n\\t\\t\\tTestInformation = testInformation,\\n\\t\\t\\tMembersToGenerate = \\n\\t\\t\\t[\\n\\t\\t\\t\\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tName = \"item\",\\n\\t\\t\\t\\t\\tAttributes = \\n\\t\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\t\\tnew global::TUnit.Core.MatrixMethodAttribute<global::TUnit.TestProject.MatrixTests>(\"IntMethod\")\\n\\t\\t\\t\\t\\t],\\n\\t\\t\\t\\t},\\n\\t\\t\\t],\\n\\t\\t\\tTestSessionId = sessionId,\\n\\t\\t\\tTestClassInstance = classInstance,\\n\\t\\t\\tClassInstanceArguments = classInstanceArguments,\\n\\t\\t};\\n\\t\\tvar methodDataAttribute = new global::TUnit.Core.MatrixDataSourceAttribute();\\n\\n\\t\\ttestBuilderContext.DataAttributes.Add(methodDataAttribute);\\n\\n\\t\\tvar methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\\n\\n\\t\\tforeach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\\n\\t\\t{\\n\\t\\t\\ttestMethodDataIndex++;\\n\\t\\t\\tclassInstanceArguments = [];\\n\\n\\t\\t\\tvar methodArgGeneratedData = methodArgGeneratedDataAccessor();\\n\\t\\t\\tint methodArg = global::TUnit.Core.Helpers.CastHelper.Cast<int>(methodArgGeneratedData[0]);\\n\\t\\t\\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.MatrixTests>(() => \\n\\t\\t\\tnew global::TUnit.TestProject.MatrixTests()\\n\\t\\t\\t, sessionId, testBuilderContext);\n```\n\n----------------------------------------\n\nTITLE: Test Collection Methods for RepeatTests.Two Method with Repeat Attribute\nDESCRIPTION: The Tests1 and Tests2 methods that generate test metadata for the RepeatTests.Two test method with repeat attribute. Each method represents a different repeat attempt (1 and 2) of the same test.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/RepeatTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests1(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.RepeatTests),\n\t\t\tName = \"Two\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.RepeatAttribute(2)\n\t\t\t],\n\t\t\tParameters = [],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.RepeatTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.RepeatTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"RepeatTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"RepeatTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"RepeatTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.RepeatAttribute(3)\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.RepeatTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.RepeatTests>(() => \n\t\t\t\tnew global::TUnit.TestProject.RepeatTests()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.RepeatTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"TUnit.TestProject.RepeatTests.Two:1\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 1,\n\t\t\t\t\tRepeatLimit = 2,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Two()),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 13,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.RepeatTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"TUnit.TestProject.RepeatTests.Two:1\",\n\t\t\t\t\tMethodName = $\"Two\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"RepeatTests.Two failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 13,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing Instance Hook Method in C#\nDESCRIPTION: Defines the InstanceHookMethod class which represents an instance-level hook method. It implements IEquatable and IExecutableHook interfaces.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_52\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class InstanceHookMethod : System.IEquatable<TUnit.Core.Hooks.InstanceHookMethod>, TUnit.Core.Hooks.IExecutableHook<TUnit.Core.TestContext>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public InstanceHookMethod() { }\n    public System.Reflection.Assembly Assembly { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Attribute[] AssemblyAttributes { get; init; }\n    public System.Collections.Generic.IEnumerable<System.Attribute> Attributes { get; }\n    public System.Func<object, TUnit.Core.TestContext, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask>? Body { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Attribute[] ClassAttributes { get; init; }\n    [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods)]\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Type ClassType { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Core.Interfaces.IHookExecutor HookExecutor { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Attribute[] MethodAttributes { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Core.SourceGeneratedMethodInformation MethodInfo { get; init; }\n    public string Name { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public int Order { get; init; }\n    public System.TimeSpan? Timeout { get; }\n    public System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.TestContext context, System.Threading.CancellationToken cancellationToken) { }\n    public TAttribute? GetAttribute<TAttribute>()\n        where TAttribute : System.Attribute { }\n}\n```\n\n----------------------------------------\n\nTITLE: Test Execution with Resettable Class Factory in TUnit C#\nDESCRIPTION: This code segment uses TUnit to execute tests using a resettable class factory, allowing dynamic test instance creation. The factory ensures each test run has fresh instances. Key dependencies include TUnit.Core for test metadata manipulation and system namespaces for generic operations. It accepts test parameters and outputs test instances with specified method arguments. The resettable class factory allows for repeated test attempts.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ClassDataSourceDrivenTests>(() => \nnew global::TUnit.TestProject.ClassDataSourceDrivenTests()\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n```\n\n----------------------------------------\n\nTITLE: C# Test Source Generator Implementation\nDESCRIPTION: Implementation of a test source generator that creates test metadata from tuple data sources. Handles class initialization, property setting, and test method execution with tuple-based test data.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=NamedTupleMethod_testMethodName=TupleMethod.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class ClassTupleDataSourceDrivenTests : TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n    [global::System.Runtime.CompilerServices.ModuleInitializer]\n    public static void Initialise()\n    {\n        SourceRegistrar.Register(new ClassTupleDataSourceDrivenTests());\n    }\n    public global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n    {\n        return\n        [\n            ..Tests0(sessionId),\n            ..Tests1(sessionId),\n            ..Tests2(sessionId),\n            ..Tests3(sessionId),\n        ];\n    }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n    global::System.Collections.Generic.List<TestMetadata> nodes = [];\n    var classDataIndex = 0;\n    var testMethodDataIndex = 0;\n    try\n    {\n        var testClassType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests);\n        var methodInfo = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests).GetMethod(\"DataSource_TupleMethod\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]);\n\n        var testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n        var testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n        var classArgTuples = global::System.TupleExtensions.ToTuple<global::System.Int32, global::System.String, global::System.Boolean>(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()());\n        // ... rest of implementation\n    }\n    catch (global::System.Exception exception)\n    {\n        nodes.Add(new FailedInitializationTest\n        {\n            // ... error handling\n        });\n    }\n    return nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing After Assembly Hook Method in C#\nDESCRIPTION: Defines the AfterAssemblyHookMethod class which executes after an assembly is processed. It inherits from StaticHookMethod and implements IEquatable.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\npublic class AfterAssemblyHookMethod : TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.AssemblyHookContext>, System.IEquatable<TUnit.Core.Hooks.AfterAssemblyHookMethod>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public AfterAssemblyHookMethod() { }\n    public override System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.AssemblyHookContext context, System.Threading.CancellationToken cancellationToken) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SingleItemAssertionBuilderWrapper for Collection Item Testing\nDESCRIPTION: Assertion builder for checking properties of a single item in a collection. It implements the awaitable pattern to return the inner item when awaited.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_91\n\nLANGUAGE: C#\nCODE:\n```\npublic class SingleItemAssertionBuilderWrapper<TActual, TInner> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>\n    where TActual : System.Collections.Generic.IEnumerable<TInner>\n{\n    public new System.Runtime.CompilerServices.TaskAwaiter<TInner?> GetAwaiter() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DateOnly Assertions in C#\nDESCRIPTION: Extension methods for asserting DateOnly values, including checks for being after, before, equal to, and their inclusive variants.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_110\n\nLANGUAGE: C#\nCODE:\n```\npublic static class DateOnlyIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateOnly> IsAfter(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateOnly> valueSource, System.DateOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateOnly> IsAfterOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateOnly> valueSource, System.DateOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateOnly> IsBefore(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateOnly> valueSource, System.DateOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateOnly> IsBeforeOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateOnly> valueSource, System.DateOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.DateOnlyEqualToAssertionBuilderWrapper IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateOnly> valueSource, System.DateOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Test Context and Extracting Tuple Values in C#\nDESCRIPTION: This snippet extracts values from tuple data sources using TupleExtensions.ToTuple, initializes test context, and sets up values for class instantiation and property initialization. It retrieves both regular tuples and named tuples from the data source methods.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.ClassTupleDataSourceDrivenTests? classInstance = null;\nobject?[]? classInstanceArguments = null;\nvar classArgTuples = global::System.TupleExtensions.ToTuple<int, string, bool>(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()());\nint classArg = classArgTuples.Item1;\nstring classArg1 = classArgTuples.Item2;\nbool classArg2 = classArgTuples.Item3;\nclassInstanceArguments = [classArg, classArg1, classArg2];\n(int, string, bool) propertyArg = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()();\n(int Number, string Word, bool Flag) propertyArg1 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()();\n(int, string, bool) propertyArg2 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()();\n(int Number, string Word, bool Flag) propertyArg3 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()();\n\nvar methodArgTuples = global::System.TupleExtensions.ToTuple<int, string, bool>(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()());\nint methodArg = methodArgTuples.Item1;\nstring methodArg1 = methodArgTuples.Item2;\nbool methodArg2 = methodArgTuples.Item3;\n```\n\n----------------------------------------\n\nTITLE: Implementing Before Class Hook Method in C#\nDESCRIPTION: Defines the BeforeClassHookMethod class which executes before a class is processed. It inherits from StaticHookMethod and implements IEquatable.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_45\n\nLANGUAGE: C#\nCODE:\n```\npublic class BeforeClassHookMethod : TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.ClassHookContext>, System.IEquatable<TUnit.Core.Hooks.BeforeClassHookMethod>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public BeforeClassHookMethod() { }\n    public override System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.ClassHookContext context, System.Threading.CancellationToken cancellationToken) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DependsOnAttribute in C#\nDESCRIPTION: This C# attribute `DependsOnAttribute`, derived from `TUnitAttribute`, is used in the TUnit framework to specify dependencies between tests. It allows defining a dependency based on a test class, a test name within the same or another class, and optionally the parameter types of the depended-upon test method. The `ProceedOnFailure` property controls whether the dependent test runs if the dependency fails.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\n    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\n    public class DependsOnAttribute : TUnit.Core.TUnitAttribute\n    {\n        public DependsOnAttribute(System.Type testClass) { }\n        public DependsOnAttribute(string testName) { }\n        public DependsOnAttribute(System.Type testClass, string testName) { }\n        public DependsOnAttribute(string testName, System.Type[] parameterTypes) { }\n        public DependsOnAttribute(System.Type testClass, string testName, System.Type[] parameterTypes) { }\n        public System.Type[]? ParameterTypes { get; }\n        public bool ProceedOnFailure { get; set; }\n        public System.Type? TestClass { get; }\n        public string? TestName { get; }\n        public override string ToString() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing ModuleInitializer for TUnit Test Source Registration\nDESCRIPTION: Initializes the test system by registering the auto-generated AutoDataTests class with the TUnit framework source registrar. This method is automatically called during module initialization.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.NonTyped.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tglobal::TUnit.Core.SourceRegistrar.Register(new AutoDataTests());\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Adding Test Metadata to Collection\nDESCRIPTION: Creates TestMetadata objects for each generated test instance and adds them to the collection. This includes test ID, arguments, class factory, and method invocation information for test execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.NonTyped.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.AutoDataTests>\n\t\t\t\t\t{\n\t\t\t\t\t\tTestId = $\"global::TUnit.TestProject.Attributes.AutoDataAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.AutoDataTests.Test1(string,int,double,bool):0\",\n\t\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\t\tTestMethodArguments = [methodArg, methodArg1, methodArg2, methodArg3],\n\t\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Test1(methodArg, methodArg1, methodArg2, methodArg3)),\n\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\tTestLineNumber = 8,\n\t\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t\t});\n\t\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\t\ttestBuilderContext = new();\n\t\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t\t}\n```\n\n----------------------------------------\n\nTITLE: Defining TUnit Test Source Class and Initialization in C#\nDESCRIPTION: This auto-generated C# code defines a partial class `Inherited_InheritedPropertySetterTests` that implements the `ITestSource` interface from the TUnit framework. It includes necessary using directives and attributes for code generation and diagnostics. A `ModuleInitializer` static method `Initialise` is defined to register this test source with `TUnit.Core.SourceRegistrar` upon module load. The `CollectTests` method fulfills the `ITestSource` contract by calling the private `Tests0` method to gather all test metadata associated with this source for a given session ID.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/InheritedPropertySetterTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Inherited_InheritedPropertySetterTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new Inherited_InheritedPropertySetterTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing Class Hook Source for Base2\nDESCRIPTION: Auto-generated class implementing IClassHookSource interface for Base2 test class, handling class-level hooks including BeforeAll2 method registration\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeAllTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_Base2 : global::TUnit.Core.Interfaces.SourceGenerator.IClassHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_Base2();\n\t\tSourceRegistrar.RegisterClassHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing AfterClassHooks with Context Parameter\nDESCRIPTION: Auto-generated class implementing IClassHookSource for registering a class-level hook method that accepts a ClassHookContext parameter. This variant defines the 'AfterAllCleanUpWithContext' method that receives a context object containing test execution information.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterAllTests.Test.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_CleanupTests : global::TUnit.Core.Interfaces.SourceGenerator.IClassHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_CleanupTests();\n\t\tSourceRegistrar.RegisterClassHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.AfterClassHookMethod\n\t\t\t{\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.CleanupTests),\n\t\t\t\t\tName = \"AfterAllCleanUpWithContext\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.ClassHookContext>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"context\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.CleanupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.CleanupTests),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AfterAllTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"AfterAllTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"CleanupTests\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.CleanupTests.AfterAllCleanUpWithContext(context)),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tFilePath = @\"\",\n\t\t\t\t\tLineNumber = 56,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\tAssemblyAttributes = [],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: Initializing Test Metadata in TUnit Project\nDESCRIPTION: This C# snippet initializes test metadata within a TUnit test project, leveraging context objects and factory delegates for test class instances. It defines and processes test parameters, dynamically handles test instances, and integrates with asynchronous methods. Dependencies include the TUnit.Core library and a test-specific assembly. Parameters like `sessionId` are crucial for managing test sessions and method arguments, while outputs are captured as metadata nodes.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests2083.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.Bugs._2083.Tests? classInstance = null;\nobject?[]? classInstanceArguments = null;\nclassInstanceArguments = [];\n\nlong methodArg = 32767;\n\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._2083.Tests>(() => \nnew global::TUnit.TestProject.Bugs._2083.Tests()\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._2083.Tests>\n{\n    TestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS2:TUnit.TestProject.Bugs._2083.Tests.MyTest(long):0\",\n    TestClassArguments = [],\n    TestMethodArguments = [methodArg],\n    TestClassProperties = [],\n    CurrentRepeatAttempt = 0,\n    RepeatLimit = 0,\n    ResettableClassFactory = resettableClassFactory,\n    TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.MyTest(methodArg)),\n    TestFilePath = @\"\",\n    TestLineNumber = 5,\n    TestMethod = testInformation,\n    TestBuilderContext = testBuilderContext,\n});\nresettableClassFactory = resettableClassFactoryDelegate();\ntestBuilderContext = new();\ntestBuilderContextAccessor.Current = testBuilderContext;\n```\n\n----------------------------------------\n\nTITLE: Implementing Not In Parallel Constraint in C#\nDESCRIPTION: Defines a constraint for tests that should not run in parallel. It holds a list of constraint keys and implements IParallelConstraint to participate in parallel test scheduling.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\npublic class NotInParallelConstraint : System.IEquatable<TUnit.Core.NotInParallelConstraint>, TUnit.Core.Interfaces.IParallelConstraint\n{\n    public NotInParallelConstraint(System.Collections.Generic.IReadOnlyList<string> NotInParallelConstraintKeys) { }\n    public System.Collections.Generic.IReadOnlyList<string> NotInParallelConstraintKeys { get; init; }\n    public int Order { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for ULong Argument in C#\nDESCRIPTION: This snippet creates test metadata for a method with an unsigned long (ulong) argument. It follows the same pattern as the previous examples, setting up the test context and adding the metadata to the nodes list.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/NumberArgumentTests.TestDE.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nulong methodArg = 1UL;\n\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.NumberArgumentTests>(() => \nnew global::TUnit.TestProject.NumberArgumentTests()\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.NumberArgumentTests>\n{\n\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NumberArgumentTests.ULong(ulong):0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [methodArg],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.ULong(methodArg)),\n\tTestFilePath = @\"\",\n```\n\n----------------------------------------\n\nTITLE: Implementing AfterClassHooks with CancellationToken Parameter\nDESCRIPTION: Auto-generated class implementing IClassHookSource for registering a class-level hook with a CancellationToken parameter. This variant defines the 'AfterAllCleanUp' method that receives a cancellation token to support proper cancellation during test cleanup operations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterAllTests.Test.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_CleanupTests : global::TUnit.Core.Interfaces.SourceGenerator.IClassHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_CleanupTests();\n\t\tSourceRegistrar.RegisterClassHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.AfterClassHookMethod\n\t\t\t{\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.CleanupTests),\n\t\t\t\t\tName = \"AfterAllCleanUp\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.CleanupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.CleanupTests),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AfterAllTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"AfterAllTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"CleanupTests\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.CleanupTests.AfterAllCleanUp(cancellationToken)),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tFilePath = @\"\",\n\t\t\t\t\tLineNumber = 62,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\tAssemblyAttributes = [],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: Base Display Name Formatter Attribute in C#\nDESCRIPTION: Abstract base class for display name formatting with test discovery event handling capabilities\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method, Inherited=false)]\npublic abstract class DisplayNameFormatterAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver\n{\n    protected DisplayNameFormatterAttribute() { }\n    public int Order { get; }\n    protected abstract string FormatDisplayName(TUnit.Core.TestContext testContext);\n    public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering and Collecting Test Hooks with TUnit Source Generator - C#\nDESCRIPTION: This snippet demonstrates several auto-generated partial class implementations in C# that register themselves using a module initializer and provide collections of test lifecycle hooks to the TUnit framework. Each class implements the ITestHookSource interface to supply before/after-test hooks, returning them for consumption by the test runner. The code uses patterns including source-generated metadata, type reflection, dependency injection of contextual parameters, and registration via the SourceRegistrar singleton.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticAfterEachTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t];\n}\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t];\n}\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t];\n}\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t{\n\t\t\tClassType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),\n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),\n\t\t\t\tName = \"CleanUp\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.GlobalCleanUpTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"GlobalStaticAfterEachTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"GlobalStaticAfterEachTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"GlobalCleanUpTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.AfterTests.GlobalCleanUpTests)classInstance).CleanUp()),\n\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\tOrder = 0,\n\t\t\tMethodAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t],\n\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t},\n\t];\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_GlobalCleanUpTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_GlobalCleanUpTests();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),\n\t\t\t\t\tName = \"CleanUp\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test),\n\t\t\t\t\t\tnew global::TUnit.Core.TimeoutAttribute(30_000)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.GlobalCleanUpTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"GlobalStaticAfterEachTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"GlobalStaticAfterEachTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"GlobalCleanUpTests\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.AfterTests.GlobalCleanUpTests)classInstance).CleanUp(cancellationToken)),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test),\n\t\t\t\t\tnew global::TUnit.Core.TimeoutAttribute(30_000)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t},\n\t\t];\n\t}\n\n  \n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_GlobalCleanUpTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_GlobalCleanUpTests();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),\n\t\t\t\t\tName = \"CleanUpWithContext\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"testContext\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.GlobalCleanUpTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"GlobalStaticAfterEachTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"GlobalStaticAfterEachTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"GlobalCleanUpTests\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.AfterTests.GlobalCleanUpTests)classInstance).CleanUpWithContext(context)),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t},\n\t\t];\n\t}\n\n  \n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_GlobalCleanUpTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_GlobalCleanUpTests();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\n```\n\n----------------------------------------\n\nTITLE: Collecting and Registering Test Hooks - TUnit Source Generator - C#\nDESCRIPTION: This snippet defines a generated partial class that implements methods to collect test hooks to be executed before and after each test. It leverages TUnit.Core and its Hook system to return lists of static or instance hook methods. The snippet uses return type IReadOnlyList with typed hooks and relies on TUnit.Core dependencies. Parameters such as sessionId are used to scope the hooks per test execution context. Outputs are lists of metadata objects describing which hook methods to run, with the capability of specifying class types, method information, and invocation logic.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t];\n}\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t{\n\t\t\tClassType = typeof(global::TUnit.TestProject.BeforeTests.Base2),\n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.Base2),\n\t\t\t\tName = \"BeforeEach2\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.Base2\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.Base2),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"BeforeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"BeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"Base2\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.BeforeTests.Base2)classInstance).BeforeEach2()),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t},\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Filter String Conversion in C#\nDESCRIPTION: Static method for converting test execution filter to string representation\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic static string? StringifyFilter(Microsoft.Testing.Platform.Requests.ITestExecutionFilter filter) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing IAssemblyHookSource for AssemblyBase2 in C#\nDESCRIPTION: This snippet defines a partial class Hooks_AssemblyBase2 that implements IAssemblyHookSource. It registers assembly hooks and provides methods to collect different types of assembly hooks for AssemblyBase2.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyBeforeTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_AssemblyBase2 : global::TUnit.Core.Interfaces.SourceGenerator.IAssemblyHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_AssemblyBase2();\n\t\tSourceRegistrar.RegisterAssemblyHookSource(instance);\n\t}\n\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectBeforeAssemblyHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.BeforeAssemblyHookMethod\n\t\t\t{ \n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.AssemblyBase2),\n\t\t\t\tName = \"BeforeAll2\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Assembly)\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.AssemblyBase2\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.AssemblyBase2),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AssemblyBeforeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"AssemblyBeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"AssemblyBase2\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.BeforeTests.AssemblyBase2.BeforeAll2()),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tFilePath = @\"\",\n\t\t\t\tLineNumber = 20,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Assembly)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\tAssemblyAttributes = [],\n\t\t\t},\n\t\t];\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Abstract Formatter Class in TUnit\nDESCRIPTION: An abstract class for formatting values that includes methods to determine if a formatter can handle a value type and how to format the value.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_161\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Formatter\n{\n    protected Formatter() { }\n    public abstract bool CanHandle(object? value);\n    public abstract string FormatValue(object? value);\n    public static string Format(object? value) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating TUnit Test Metadata for Float Method in C#\nDESCRIPTION: This C# code snippet, likely auto-generated by TUnit, defines logic within a `Tests0` method (inside a generated partial class, not fully shown) to collect metadata for the `Float` test method in `TUnit.TestProject.NumberArgumentTests`. It initializes test context (`TestBuilderContext`), sets a specific `float` argument (1.1f), creates factories using `ResettableLazy` for lazy instantiation of the test class and a factory for test method execution, and populates a `TestMetadata` object. Error handling using a try-catch block is included to capture potential initialization failures and record them as `FailedTestMetadata`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/NumberArgumentTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.NumberArgumentTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"NumberArgumentTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"NumberArgumentTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"NumberArgumentTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.NumberArgumentTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tfloat methodArg = 1.1f;\n\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.NumberArgumentTests>(() => \n\t\t\t\tnew global::TUnit.TestProject.NumberArgumentTests()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.NumberArgumentTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NumberArgumentTests.Float(float):0\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Float(methodArg)),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 19,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.NumberArgumentTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NumberArgumentTests.Float(float):0\",\n\t\t\t\t\tMethodName = $\"Float\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"NumberArgumentTests.Float failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 19,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: Test Collection Implementation for Double Special Constants in C#\nDESCRIPTION: Auto-generated C# code that implements test collection for the Double_SpecialConsts test method. It registers test cases using matrix data sources with special double constants (NaN, PositiveInfinity, NegativeInfinity) and handles test initialization and execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests2085.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[  \n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Tests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new Tests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._2085.Tests),\n\t\t\t\tName = \"Double_SpecialConsts\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.MatrixDataSourceAttribute()\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<double>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"d\",\n\t\t\t\t\t\tAttributes = \n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tnew global::TUnit.Core.MatrixAttribute(double.NaN, double.PositiveInfinity, double.NegativeInfinity)\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._2085.Tests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._2085.Tests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Tests2085\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"Tests2085\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"Tests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._2085\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.Bugs._2085.Tests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tvar methodArgDataGeneratorMetadata = new DataGeneratorMetadata\n\t\t\t\t{\n\t\t\t\t\tType = global::TUnit.Core.Enums.DataGeneratorType.TestParameters,\n\t\t\t\t\tTestBuilderContext = testBuilderContextAccessor,\n\t\t\t\t\tTestInformation = testInformation,\n\t\t\t\t\tMembersToGenerate = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<double>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"d\",\n\t\t\t\t\t\t\tAttributes = \n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew global::TUnit.Core.MatrixAttribute(double.NaN, double.PositiveInfinity, double.NegativeInfinity)\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tTestSessionId = sessionId,\n\t\t\t\t\tTestClassInstance = classInstance,\n\t\t\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t\t\t};\n\t\t\t\tvar methodDataAttribute = new global::TUnit.Core.MatrixDataSourceAttribute();\n\n\t\t\t\ttestBuilderContext.DataAttributes.Add(methodDataAttribute);\n\n\t\t\t\tvar methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\n\n\t\t\t\tforeach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\n\t\t\t\t{\n\t\t\t\t\ttestMethodDataIndex++;\n\t\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\t\tvar methodArgGeneratedData = methodArgGeneratedDataAccessor();\n\t\t\t\t\tdouble methodArg = global::TUnit.Core.Helpers.CastHelper.Cast<double>(methodArgGeneratedData[0]);\n\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._2085.Tests>(() => \n\t\t\t\t\tnew global::TUnit.TestProject.Bugs._2085.Tests()\n\t\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._2085.Tests>\n\t\t\t\t\t{\n\t\t\t\t\t\tTestId = $\"global::TUnit.Core.MatrixDataSourceAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.Bugs._2085.Tests.Double_SpecialConsts(double):0\",\n\t\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Double_SpecialConsts(methodArg)),\n\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\tTestLineNumber = 8,\n\t\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t\t});\n\t\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\t\ttestBuilderContext = new();\n\t\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._2085.Tests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.MatrixDataSourceAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.Bugs._2085.Tests.Double_SpecialConsts(double):0\",\n\t\t\t\t\tMethodName = $\"Double_SpecialConsts\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"Tests.Double_SpecialConsts failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 8,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing Instance Hook Method Class\nDESCRIPTION: Defines an instance-based hook method class that implements IExecutableHook and IEquatable interfaces. It includes required members for method information, attributes, and execution context.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_61\n\nLANGUAGE: C#\nCODE:\n```\npublic class InstanceHookMethod : System.IEquatable<TUnit.Core.Hooks.InstanceHookMethod>, TUnit.Core.Hooks.IExecutableHook<TUnit.Core.TestContext>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public InstanceHookMethod() { }\n    public System.Reflection.Assembly Assembly { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Attribute[] AssemblyAttributes { get; init; }\n    public System.Collections.Generic.IEnumerable<System.Attribute> Attributes { get; }\n    public System.Func<object, TUnit.Core.TestContext, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask>? Body { get; init; }\n    // ... additional properties and methods\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Initialization Failures for TUnit Class Data Source Tests in C#\nDESCRIPTION: This C# catch block handles exceptions occurring during the initialization phase of a TUnit test driven by `ClassDataSourceAttribute`. If an exception occurs while setting up the test 'IsInitialized_With_3_ClassDataSources', it creates a `FailedTestMetadata` object containing details about the failure, including the test ID, method name, the original exception wrapped in a `TestFailedInitializationException`, file path, and line number. This ensures that initialization failures are reported correctly within the TUnit framework.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ClassDataSourceDrivenTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.InitializableClass, global::TUnit.TestProject.InitializableClass, global::TUnit.TestProject.InitializableClass>:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.ClassDataSourceDrivenTests.IsInitialized_With_3_ClassDataSources(TUnit.TestProject.InitializableClass,TUnit.TestProject.InitializableClass,TUnit.TestProject.InitializableClass):0\",\n\t\t\t\t\tMethodName = $\"IsInitialized_With_3_ClassDataSources\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ClassDataSourceDrivenTests.IsInitialized_With_3_ClassDataSources failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 39,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing FailedDynamicTest<TClassType> in C#\nDESCRIPTION: Defines a FailedDynamicTest<TClassType> class for representing failed dynamic tests. It includes properties for exception details and test information.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class FailedDynamicTest<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicParameterlessConstructor | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]  TClassType> : System.IEquatable<TUnit.Core.FailedDynamicTest<TClassType>>\n    where TClassType :  class\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public FailedDynamicTest() { }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Exception Exception { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string MethodName { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string TestFilePath { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string TestId { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public int TestLineNumber { get; init; }\n    public static TUnit.Core.DynamicTest<TClassType> op_Implicit(TUnit.Core.FailedDynamicTest<TClassType> failedTestMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Assertion Condition in C#\nDESCRIPTION: Defines an AssignableFromExpectedValueAssertCondition class for generic type assertions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_98\n\nLANGUAGE: C#\nCODE:\n```\npublic class AssignableFromExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n{\n    public AssignableFromExpectedValueAssertCondition(System.Type expectedType) { }\n    protected override string GetExpectation() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Failing Synchronous Assertion in TUnit Test - C#\nDESCRIPTION: Demonstrates an incorrect approach for writing a TUnit test where assertions are performed synchronously without using the async/await pattern. This method does not return a Task and omits awaiting the assertion chain, which will trigger an error due to TUnit's analyzer requirements. Inputs consist of integers and the Add function, with the expected output enforced by the IsEqualTo matcher using Assert.That. There are no asynchronous operations in this snippet, and the primary dependency is the TUnit test framework.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-assertions/awaiting.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n    [Test]\n    public void MyTest()\n    {\n        var result = Add(1, 2);\n\n        Assert.That(result).IsEqualTo(3);\n    }\n```\n\n----------------------------------------\n\nTITLE: Collecting Tests for ClassDataSourceDrivenTests2 in TUnit\nDESCRIPTION: This method collects all the tests defined in the ClassDataSourceDrivenTests2 class. It combines the results of multiple test collection methods (Tests0 and Tests1) into a single list of TestMetadata objects.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests2.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn\n\t[\n\t\t..Tests0(sessionId),\n\t\t..Tests1(sessionId),\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Test Class Information with Data Sources in C#\nDESCRIPTION: Generates class information for a test class including assembly details, namespace, attributes and parameters. Sets up data source attributes for test method execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceClassCombinedWithDataSourceMethodTests.Test.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n{\n    Type = typeof(global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod),\n    Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataSourceClassCombinedWithDataSourceMethodTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n    {\n        Name = \"DataSourceClassCombinedWithDataSourceMethodTests\",\n        Attributes = [],\n    }),\n    Name = \"DataSourceClassCombinedWithDataSourceMethod\",\n    Namespace = \"TUnit.TestProject\",\n    Attributes = \n    [\n        new global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"One\"),\n        new global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Two\"),\n        new global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Three\")\n    ],\n    Parameters = \n    [\n        new global::TUnit.Core.SourceGeneratedParameterInformation<int>\n        {\n            Name = \"i\",\n            Attributes = [],\n        },\n    ],\n    Properties = [],\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Skip Attribute in C#\nDESCRIPTION: Defines a SkipAttribute that can be applied to assemblies, classes or methods to skip test execution. Implements event receiver interfaces and provides skip condition evaluation.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_47\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\npublic class SkipAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestRegisteredEventReceiver\n{\n    public SkipAttribute(string reason) { }\n    public int Order { get; }\n    public string Reason { get; protected set; }\n    public System.Threading.Tasks.ValueTask OnTestRegistered(TUnit.Core.TestRegisteredContext context) { }\n    public virtual System.Threading.Tasks.Task<bool> ShouldSkip(TUnit.Core.BeforeTestContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Before Test Instance Hooks in C#\nDESCRIPTION: Method that returns a collection of instance hook methods to be executed before each test. This specifically registers Setup methods from BaseTests classes, including both the generic base class and its concrete implementation with MyFixture.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Hooks1589.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t{\n\t\t\tClassType = typeof(global::TUnit.TestProject.Bugs._1589.BaseTests<>),\n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1589.BaseTests<>),\n\t\t\t\tName = \"Setup\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._1589.BaseTests<>\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1589.BaseTests<>),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Hooks1589\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"Hooks1589\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"BaseTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._1589\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.ConvertObject(() => classInstance.GetType().GetMethod(\"Setup\", []).Invoke(classInstance, [])),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t},\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.Bugs._1589.BaseTests<global::TUnit.TestProject.Bugs._1589.MyFixture>),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1589.BaseTests<global::TUnit.TestProject.Bugs._1589.MyFixture>),\n\t\t\t\t\tName = \"Setup\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(void),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._1589.BaseTests<global::TUnit.TestProject.Bugs._1589.MyFixture>\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1589.BaseTests<global::TUnit.TestProject.Bugs._1589.MyFixture>),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Hooks1589\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"Hooks1589\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"BaseTests\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._1589\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = \n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.Bugs._1589.MyFixture>\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName = \"fixture\",\n\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t\tProperties = \n\t\t\t\t\t\t[\nnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1589.MyFixture),\n\t\t\t\t\t\t\t\tName = \"Fixture\",\n\t\t\t\t\t\t\t\tIsStatic = false,\n\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t},\nnew global::TUnit.Core.SourceGeneratedPropertyInformation\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tType = typeof(int),\n\t\t\t\t\t\t\t\tName = \"MyProp\",\n\t\t\t\t\t\t\t\tIsStatic = false,\n\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.Bugs._1589.BaseTests<global::TUnit.TestProject.Bugs._1589.MyFixture>)classInstance).Setup()),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing EquivalentToExpectedValueAssertCondition in C#\nDESCRIPTION: A class that implements a condition to check if a value is equivalent to an expected value, with options to ignore specific members and set equivalency kind. This is useful for comparing complex objects.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_115\n\nLANGUAGE: C#\nCODE:\n```\npublic class EquivalentToExpectedValueAssertCondition<TActual, TExpected> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TExpected>\n{\n    public EquivalentToExpectedValueAssertCondition(TExpected expected, string? expectedExpression) { }\n    public TUnit.Assertions.Enums.EquivalencyKind EquivalencyKind { get; set; }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TExpected? expectedValue) { }\n    public void IgnoringMember(string fieldName) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Test Initialization Error Handling in C#\nDESCRIPTION: Handles exceptions during test initialization by creating a FailedInitializationTest node with detailed error information including test ID, class type, and method details.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=TupleMethod_testMethodName=TupleMethod.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nnodes.Add(new FailedInitializationTest\n{\n\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS1:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.ClassTupleDataSourceDrivenTests(System.Int32,System.String,System.Boolean).DataSource_TupleMethod(System.Int32,System.String,System.Boolean):0\",\n\tTestClass = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests),\n\tReturnType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests).GetMethod(\"DataSource_TupleMethod\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]).ReturnType,\n\tParameterTypeFullNames = [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)],\n\tTestName = \"DataSource_TupleMethod\",\n\tTestFilePath = @\"\",\n\tTestLineNumber = 24,\n\tException = exception,\n});\n```\n\n----------------------------------------\n\nTITLE: Registering TUnit Test Hook Source (GlobalBase3) in C#\nDESCRIPTION: This snippet shows the beginning of an auto-generated partial class `Hooks_GlobalBase3` in C#. It implements the `ITestHookSource` interface for TUnit and includes a `ModuleInitializer` static method `Initialise` which creates an instance of the class and registers it with the `SourceRegistrar`. The subsequent methods (not fully shown) would define the collection logic for different test hook types associated with `GlobalBase3`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticAfterEachTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_GlobalBase3 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_GlobalBase3();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n```\n\n----------------------------------------\n\nTITLE: Collecting Tests for InheritedTestsFromDifferentProjectTests\nDESCRIPTION: This snippet defines a partial class that implements ITestSource to collect tests for the InheritedTestsFromDifferentProjectTests class. It includes methods for initialization, test collection, and handling test metadata.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/InheritedTestsFromDifferentProjectTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class InheritedTestsFromDifferentProjectTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new InheritedTestsFromDifferentProjectTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\t// ... (test collection logic)\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\t// ... (exception handling)\n\t\t}\n\t\treturn nodes;\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for ArrayFuncT Method Data Source in C#\nDESCRIPTION: Method that generates test metadata for tests using the ArrayFuncT data source. It invokes function-based data providers, configures test instances, and handles parameter passing for tests with cancellation token support.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenWithCancellationTokenTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests5(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests),\n\t\t\tName = \"MyTest\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"T\"),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"FuncT\"),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"EnumerableT\"),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"EnumerableFuncT\"),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"ArrayT\"),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"ArrayFuncT\")\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t{\n\t\t\t\t\tName = \"value\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t{\n\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"MethodDataSourceDrivenWithCancellationTokenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"MethodDataSourceDrivenWithCancellationTokenTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"MethodDataSourceDrivenWithCancellationTokenTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute(\"Usage\", \"TUnit0046:Return a `Func<T>` rather than a `<T>`\")\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tforeach (var methodDataAccessor in global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests.ArrayFuncT())\n\t\t\t\t{\n\t\t\t\t\ttestMethodDataIndex++;\n\t\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\t\tvar methodData = methodDataAccessor();\n\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests>(() => \n\t\t\t\t\tnew global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests()\n\t\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests>\n\t\t\t\t\t{\n\t\t\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS5:{testMethodDataIndex}:TUnit.TestProject.MethodDataSourceDrivenWithCancellationTokenTests.MyTest(int,System.Threading.CancellationToken):0\",\n\t\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\t\tTestMethodArguments = [methodData],\n\t\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n```\n\n----------------------------------------\n\nTITLE: Implementing Interface Method Collection\nDESCRIPTION: Interface method collection for test hook interactions, including assembly, class, test discovery and test session hooks.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_63\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IHookExecutor {\n    System.Threading.Tasks.ValueTask ExecuteAfterAssemblyHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.AssemblyHookContext context, System.Func<System.Threading.Tasks.ValueTask> action);\n    System.Threading.Tasks.ValueTask ExecuteAfterClassHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.ClassHookContext context, System.Func<System.Threading.Tasks.ValueTask> action);\n    // ... additional hook execution methods\n}\n```\n\n----------------------------------------\n\nTITLE: Using MethodDataSource with IEnumerable and Custom Record in TUnit (C#)\nDESCRIPTION: This C# example demonstrates generating multiple test invocations using `[MethodDataSource]`. The `AdditionTestData` static method returns an `IEnumerable<Func<AdditionTestData>>`, yielding multiple `Func` delegates. TUnit executes the `MyTest` method once for each yielded `Func`, passing the result of invoking the `Func` (a new `AdditionTestData` instance) as the argument. This allows parameterizing tests with multiple object instances, ensuring each test gets a fresh data object. Dependencies include TUnit.Core and TUnit.Assertions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/method-data-source.md#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nusing TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic record AdditionTestData(int Value1, int Value2, int ExpectedResult);\n\npublic static class MyTestDataSources\n{\n    public static IEnumerable<Func<AdditionTestData>> AdditionTestData()\n    {\n        yield return () => new AdditionTestData(1, 2, 3);\n        yield return () => new AdditionTestData(2, 2, 4);\n        yield return () => new AdditionTestData(5, 5, 10);\n    }\n}\n\npublic class MyTestClass\n{\n    [Test]\n    [MethodDataSource(typeof(MyTestDataSources), nameof(MyTestDataSources.AdditionTestData))]\n    public async Task MyTest(AdditionTestData additionTestData)\n    {\n        var result = Add(additionTestData.Value1, additionTestData.Value2);\n\n        await Assert.That(result).IsEqualTo(additionTestData.ExpectedResult);\n    }\n\n    private int Add(int x, int y)\n    {\n        return x + y;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Source Generated Class Information in C#\nDESCRIPTION: Abstract base class for source generated member information with required attributes and equality comparison. Includes properties for attributes, name and type with abstract implementation.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class SourceGeneratedMemberInformation : System.IEquatable<TUnit.Core.SourceGeneratedMemberInformation>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of your compiler.\", true)]\n    protected SourceGeneratedMemberInformation() { }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Attribute[] Attributes { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string Name { get; init; }\n    public abstract System.Type Type { get; init; }\n    public virtual bool Equals(TUnit.Core.SourceGeneratedMemberInformation? other) { }\n    public override int GetHashCode() { }\n    protected virtual bool PrintMembers(System.Text.StringBuilder stringBuilder) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Module Initialization and Hook Source Registration - TUnit Source Generator - C#\nDESCRIPTION: The static Initialise method is decorated as a ModuleInitializer and registers this partial class instance with the TUnit SourceRegistrar, enabling hook sources to be recognized and used in the test pipeline. It sets up the infrastructure required for TUnit to discover and utilize generated test hooks. Requires TUnit.Core and SourceRegistrar, runs automatically on assembly/module load without manual invocation.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticAfterEachTests.Test.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tvar instance = new Hooks_GlobalCleanUpTests();\n\tSourceRegistrar.RegisterTestHookSource(instance);\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Before Every Test Hooks in C#\nDESCRIPTION: Method that returns an empty collection of static hook methods to be executed before every test. This implements part of the ITestHookSource interface.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Hooks1589.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Stringifying Test Filters - Microsoft Testing Platform - C#\nDESCRIPTION: Provides a static method to convert an ITestExecutionFilter instance into a string representation. Requires a reference to the Microsoft.Testing.Platform.Requests namespace and operates by accepting a filter object and returning its stringified form, which may be used for logging or diagnostics. The output is a nullable string, and the method is intended for internal use when working with test filters.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\npublic static string? StringifyFilter(Microsoft.Testing.Platform.Requests.ITestExecutionFilter filter) { }\n```\n\n----------------------------------------\n\nTITLE: Setting Up Test Builder Context in C#\nDESCRIPTION: Initializes the test builder context and sets up property arguments and data attributes for various properties.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/InheritedPropertySetterTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.PropertySetterTests? classInstance = null;\nobject?[]? classInstanceArguments = null;\nclassInstanceArguments = [];\nstring propertyArg = \"1\";\n\nstring propertyArg1 = global::TUnit.TestProject.PropertySetterTests.MethodData();\nvar propertyDataAttribute2 = new global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.PropertySetterTests.InnerModel>();\ntestBuilderContext.DataAttributes.Add(propertyDataAttribute2);\n\n// ... (similar setup for other properties)\n```\n\n----------------------------------------\n\nTITLE: Implementing String Assertions with StringEqualsExpectedValueAssertCondition\nDESCRIPTION: Implements string comparison assertion conditions with options for customizing comparison behavior such as ignoring whitespace and trimming.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_66\n\nLANGUAGE: csharp\nCODE:\n```\npublic class StringEqualsExpectedValueAssertCondition : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<string, string>\n{\n    public StringEqualsExpectedValueAssertCondition(string expected, System.StringComparison stringComparison) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(string? actualValue, string? expectedValue) { }\n    public TUnit.Assertions.AssertConditions.String.StringEqualsExpectedValueAssertCondition IgnoringWhitespace() { }\n    public TUnit.Assertions.AssertConditions.String.StringEqualsExpectedValueAssertCondition WithNullAndEmptyEquality() { }\n    public TUnit.Assertions.AssertConditions.String.StringEqualsExpectedValueAssertCondition WithTrimming() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering and Collecting Class Hooks - TUnit Source Generator - C#\nDESCRIPTION: This code snippet, from a generated partial class, demonstrates how class-level setup hooks are defined and registered for the TUnit framework. It includes the module initializer for automatic registration and methods for collecting hooks that run before or after every class, as well as before or after individual test classes. The core dependencies are on TUnit.Core, its Hook infrastructure, and standard .NET reflection and collection APIs. Key inputs include sessionId for context, with outputs structured as hook metadata objects mapping to class setup methods.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_Base3 : global::TUnit.Core.Interfaces.SourceGenerator.IClassHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_Base3();\n\t\tSourceRegistrar.RegisterClassHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.BeforeClassHookMethod\n\t\t\t{\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.Base3),\n\t\t\t\t\tName = \"BeforeAll3\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.Base3\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.Base3),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"BeforeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"BeforeTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"Base3\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.BeforeTests.Base3.BeforeAll3()),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tFilePath = @\"\",\n\t\t\t\t\tLineNumber = 35,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\tAssemblyAttributes = [],\n\t\t\t},\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Adding Failed Test Metadata Node for Test Initialization Failure\nDESCRIPTION: Creates and adds a FailedTestMetadata node when test initialization fails, including exception details and test identification information.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\nnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>\n{\n    TestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS1:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.ClassTupleDataSourceDrivenTests(int,string,bool).DataSource_TupleMethod(int,string,bool):0\",\n    MethodName = $\"DataSource_TupleMethod\",\n    Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ClassTupleDataSourceDrivenTests.DataSource_TupleMethod failed to initialize\", exception),\n    TestFilePath = @\"\",\n    TestLineNumber = 24\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Matrix Instance Method Attribute in C#\nDESCRIPTION: Defines an attribute for generating test parameters from instance methods. It implements IAccessesInstanceData interface and requires a method name to be specified for data retrieval.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Parameter)]\npublic class MatrixInstanceMethodAttribute<TClass> : TUnit.Core.MatrixMethodAttribute<TClass>, TUnit.Core.IAccessesInstanceData\n    where TClass :  class\n{\n    public MatrixInstanceMethodAttribute(string methodName) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Test Initialization Exceptions in TUnit Framework\nDESCRIPTION: This snippet shows the exception handling mechanism when a test fails to initialize properly. It creates a FailedTestMetadata instance with detailed information about the test and the exception, then adds it to a collection of test nodes before returning the collection.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/CustomDisplayNameTests.Test.verified.txt#2025-04-22_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.CustomDisplayNameTests>\n\t{\n\t\tTestId = $\"TUnit.TestProject.CustomDisplayNameTests.NestedClassConstantTest:0\",\n\t\tMethodName = $\"NestedClassConstantTest\",\n\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"CustomDisplayNameTests.NestedClassConstantTest failed to initialize\", exception),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 65,\n\t});\n}\nreturn nodes;\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Hook Source Class in C#\nDESCRIPTION: Auto-generated partial class implementing ITestHookSource interface for TUnit test framework. Defines hook collection methods and handles test cleanup lifecycle.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterTests.Test.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_CleanupTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n    [global::System.Runtime.CompilerServices.ModuleInitializer]\n    public static void Initialise()\n    {\n        var instance = new Hooks_CleanupTests();\n        SourceRegistrar.RegisterTestHookSource(instance);\n    }\n    public global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n    {\n        return\n        [\n        ];\n    }\n    public global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n    {\n        return\n        [\n        ];\n    }\n    public global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n    {\n        return\n        [\n        ];\n    }\n    public global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n    {\n        return\n        [\n            new global::TUnit.Core.Hooks.InstanceHookMethod\n            {\n                ClassType = typeof(global::TUnit.TestProject.AfterTests.CleanupTests),\n                MethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n                {\n                    Type = typeof(global::TUnit.TestProject.AfterTests.CleanupTests),\n                    Name = \"CleanupWithContext\",\n                    GenericTypeCount = 0,\n                    ReturnType = typeof(global::System.Threading.Tasks.Task),\n                    Attributes = \n                    [\n                        new global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test)\n                    ],\n                    Parameters = \n                    [\n                        new global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext>\n                        {\n                            Name = \"testContext\",\n                            Attributes = [],\n                        },\n                    ]\n                }\n            }\n        ];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing PropertySetterTests Class in C#\nDESCRIPTION: Defines a partial class PropertySetterTests that implements ITestSource. It includes a module initializer and methods for collecting test metadata.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/InheritedPropertySetterTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class PropertySetterTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new PropertySetterTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\t// ... (rest of the method implementation)\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing Collection State Assertions in C#\nDESCRIPTION: Extension methods for checking collection state like emptiness\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_103\n\nLANGUAGE: C#\nCODE:\n```\npublic static class CollectionsIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsEmpty<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Exception Handling for Test Initialization in TUnit\nDESCRIPTION: This code implements error handling in the test initialization process. When initialization fails, it creates a FailedTestMetadata object with information about the exception and the test that failed to initialize.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/InheritedPropertySetterTests.Test.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.InheritedPropertySetterTests>\n\t{\n\t\tTestId = $\"TUnit.TestProject.InheritedPropertySetterTests.Test:0\",\n\t\tMethodName = $\"Test\",\n\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"InheritedPropertySetterTests.Test failed to initialize\", exception),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 70,\n\t});\n}\nreturn nodes;\n```\n\n----------------------------------------\n\nTITLE: Implementing Hook Collection Methods in C#\nDESCRIPTION: Implements collection methods for different types of class hooks. Each method returns a collection of StaticHookMethod objects that will be executed at specific points in the test lifecycle.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeTests.Test.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId)\n{\n\treturn\n\t[\n\t];\n}\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterEveryClassHooks(string sessionId)\n{\n\treturn\n\t[\n\t];\n}\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterClassHooks(string sessionId)\n{\n\treturn\n\t[\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Double Argument Test in TUnit (C#)\nDESCRIPTION: This snippet auto-generates metadata for registering and running a TUnit test method accepting a double argument. It constructs SourceGeneratedMethodInformation for the method, prepares instantiation logic and argument values (1.1), and manages context lifecycle. On failure, it adds failed test metadata. Requires TUnit.Core, auto-generated classes, and a sessionId parameter for context.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/NumberArgumentTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class NumberArgumentTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new NumberArgumentTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.NumberArgumentTests),\n\t\t\t\tName = \"Double\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(1.1)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<double>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"d\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.NumberArgumentTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.NumberArgumentTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"NumberArgumentTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"NumberArgumentTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"NumberArgumentTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.NumberArgumentTests? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tclassInstanceArguments = [];\n\n\t\t\tdouble methodArg = 1.1;\n\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.NumberArgumentTests>(() => \n\t\t\tnew global::TUnit.TestProject.NumberArgumentTests()\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.NumberArgumentTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NumberArgumentTests.Double(double):0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Double(methodArg)),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 12,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.NumberArgumentTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NumberArgumentTests.Double(double):0\",\n\t\t\t\tMethodName = $\"Double\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"NumberArgumentTests.Double failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 12,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Hooks for Base2\nDESCRIPTION: Source-generated partial class implementing ITestHookSource interface for Base2 test class. Defines test hook collection and registration methods.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_Base2 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_Base2();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Adding Test Metadata with Matrix Data Source in C#\nDESCRIPTION: Creates and adds a TestMetadata node for a parametrized test with cancellation token support. This configuration includes test identity, arguments, factory methods, and file information for the test runner.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/TimeoutCancellationTokenTests.Test.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nnodes.Add(new TestMetadata<global::TUnit.TestProject.TimeoutCancellationTokenTests>\n{\n\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS0:global::TUnit.Core.MatrixDataSourceAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.TimeoutCancellationTokenTests(int).MatrixTest(int,System.Threading.CancellationToken):0\",\n\tTestClassArguments = [classArg],\n\tTestMethodArguments = [methodArg],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.MatrixTest(methodArg, cancellationToken)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 54,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\nresettableClassFactory = resettableClassFactoryDelegate();\ntestBuilderContext = new();\ntestBuilderContextAccessor.Current = testBuilderContext;\n```\n\n----------------------------------------\n\nTITLE: Implementing GenericNotEqualToAssertionBuilderWrapper for Generic Inequality Testing\nDESCRIPTION: Generic assertion builder for inequality checking between values. This serves as a base implementation for type-specific inequality testing.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_86\n\nLANGUAGE: C#\nCODE:\n```\npublic class GenericNotEqualToAssertionBuilderWrapper<TActual> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> { }\n```\n\n----------------------------------------\n\nTITLE: Initializing TUnit Data Source Driven Test Metadata with Named Tuple Arguments - C#\nDESCRIPTION: This snippet creates test metadata for TUnit data-driven tests using arguments sourced primarily from a NamedTuple data source method. It configures properties and captures method info using reflection, supporting the instantiation of test classes with both tuple and named tuple arguments. Relies on TUnit, tuple extensions, and proper test context initialization. Accepts sessionId as input and outputs populated lists of TestMetadata for test discovery and execution; expects all data source methods to be present and compatible.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=TupleMethod_testMethodName=TupleMethod.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests3(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testClassType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests);\n\t\tvar methodInfo = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests).GetMethod(\"DataSource_TupleMethod\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]);\n\n\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\tvar classArgTuples = global::System.TupleExtensions.ToTuple<global::System.Int32, global::System.String, global::System.Boolean>(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()());\n\t\tglobal::System.Int32 classArg = classArgTuples.Item1;\n\t\tglobal::System.String classArg1 = classArgTuples.Item2;\n\t\tglobal::System.Boolean classArg2 = classArgTuples.Item3;\n\t\t(global::System.Int32, global::System.String, global::System.Boolean) propertyArg = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()();\n\t\t(global::System.Int32 Number, global::System.String Word, global::System.Boolean Flag) propertyArg1 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()();\n\t\t(global::System.Int32, global::System.String, global::System.Boolean) propertyArg2 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()();\n\t\t(global::System.Int32 Number, global::System.String Word, global::System.Boolean Flag) propertyArg3 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()();\n\n\t\tvar methodArgTuples = global::System.TupleExtensions.ToTuple<global::System.Int32, global::System.String, global::System.Boolean>(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()());\n\t\tglobal::System.Int32 methodArg = methodArgTuples.Item1;\n\t\tglobal::System.String methodArg1 = methodArgTuples.Item2;\n\t\tglobal::System.Boolean methodArg2 = methodArgTuples.Item3;\n\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>(() => \n\t\tnew global::TUnit.TestProject.ClassTupleDataSourceDrivenTests(classArg, classArg1, classArg2)\n\t\t{\n\t\t\tProperty1 = propertyArg,\n\t\t\tProperty2 = propertyArg1,\n\t\t\tProperty3 = propertyArg2,\n\t\t\tProperty4 = propertyArg3,\n\t\t}\n\t\t, sessionId, testBuilderContext);\n\n\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>\n\t\t{\n\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS1:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.ClassTupleDataSourceDrivenTests(System.Int32,System.String,System.Boolean).DataSource_TupleMethod(System.Int32,System.String,System.Boolean):0\",\n\t\t\tTestClassArguments = [classArg, classArg1, classArg2],\n\t\t\tTestMethodArguments = [methodArg, methodArg1, methodArg2],\n\t\t\tTestClassProperties = [propertyArg, propertyArg1, propertyArg2, propertyArg3],\n```\n\n----------------------------------------\n\nTITLE: Collecting After Assembly Hooks in C#\nDESCRIPTION: This method collects and returns a list of after-assembly hooks. It creates an AfterAssemblyHookMethod with detailed method information, including attributes, parameters, and execution context.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyAfterTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectAfterAssemblyHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.AfterAssemblyHookMethod\n\t\t{ \n\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),\n\t\t\tName = \"AfterAllCleanUp\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Assembly)\n\t\t\t],\n\t\t\tParameters = [],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.AssemblyCleanupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AssemblyAfterTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"AssemblyAfterTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"AssemblyCleanupTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n},\n\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.AssemblyCleanupTests.AfterAllCleanUp()),\n\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\tOrder = 0,\n\t\t\tFilePath = @\"\",\n\t\t\tLineNumber = 50,\n\t\t\tMethodAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Assembly)\n\t\t\t],\n\t\t\tClassAttributes = [],\n\t\t\tAssemblyAttributes = [],\n\t\t},\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for Base_Derived2 Method\nDESCRIPTION: Creates test metadata for the Base_Derived2 method, including handling class data sources and generating test instances. This method demonstrates the complex logic involved in setting up data-driven tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests2.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.ClassDataSourceDrivenTests2),\n\t\t\tName = \"Base_Derived2\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute()\n\t\t\t],\n\t\t\tParameters = [],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.ClassDataSourceDrivenTests2\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.ClassDataSourceDrivenTests2),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"ClassDataSourceDrivenTests2\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"ClassDataSourceDrivenTests2\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"ClassDataSourceDrivenTests2\",\n\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.ClassDataSourceDrivenTests2.Base>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"base\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\tglobal::TUnit.TestProject.ClassDataSourceDrivenTests2? classInstance = null;\n\t\tobject?[]? classInstanceArguments = null;\n\t\tvar classArgDataGeneratorMetadata = new DataGeneratorMetadata\n\t\t{\n\t\t\tType = global::TUnit.Core.Enums.DataGeneratorType.ClassParameters,\n\t\t\tTestBuilderContext = testBuilderContextAccessor,\n\t\t\tTestInformation = testInformation,\n\t\t\tMembersToGenerate = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.ClassDataSourceDrivenTests2.Base>\n\t\t\t\t{\n\t\t\t\t\tName = \"base\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tTestSessionId = sessionId,\n\t\t\tTestClassInstance = classInstance,\n\t\t\tClassInstanceArguments = classInstanceArguments,\n\t\t};\n\t\tvar classDataAttribute = new global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.ClassDataSourceDrivenTests2.Derived1>();\n\n\t\ttestBuilderContext.DataAttributes.Add(classDataAttribute);\n\n\t\tvar classArgGeneratedDataArray = classDataAttribute.GenerateDataSources(classArgDataGeneratorMetadata);\n\n\t\tforeach (var classArgGeneratedDataAccessor in classArgGeneratedDataArray)\n\t\t{\n\t\t\tclassDataIndex++;\n\t\t\tvar classArgGeneratedData = classArgGeneratedDataAccessor();\n\t\t\tclassInstanceArguments = [classArgGeneratedData];\n\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ClassDataSourceDrivenTests2>(() => \n\t\t\tnew global::TUnit.TestProject.ClassDataSourceDrivenTests2(classArgGeneratedData)\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.ClassDataSourceDrivenTests2>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.ClassDataSourceDrivenTests2.Derived1>:{classDataIndex}:CL-GAC0:TUnit.TestProject.ClassDataSourceDrivenTests2(TUnit.TestProject.ClassDataSourceDrivenTests2.Base).Base_Derived2:0\",\n\t\t\t\tTestClassArguments = [classArgGeneratedData],\n\t\t\t\tTestMethodArguments = [],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Base_Derived2()),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 15,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t}\n\tcatch (global::System.Exception exception)\n\t{\n\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ClassDataSourceDrivenTests2>\n\t\t{\n\t\t\tTestId = $\"global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.ClassDataSourceDrivenTests2.Derived1>:{classDataIndex}:CL-GAC0:TUnit.TestProject.ClassDataSourceDrivenTests2(TUnit.TestProject.ClassDataSourceDrivenTests2.Base).Base_Derived2:0\",\n\t\t\tMethodName = $\"Base_Derived2\",\n\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ClassDataSourceDrivenTests2.Base_Derived2 failed to initialize\", exception),\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 15,\n\t\t});\n\t}\n\treturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for DataSource_Method2 in C#\nDESCRIPTION: This snippet creates test metadata for DataSource_Method2, similar to the first method but with different method name and line number. It shows how TUnit handles multiple data-driven tests within the same class.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ntry\n{\n\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t{\n\t\tType = typeof(global::TUnit.TestProject.MethodDataSourceDrivenTests),\n\t\tName = \"DataSource_Method2\",\n\t\tGenericTypeCount = 0,\n\t\tReturnType = typeof(void),\n\t\tAttributes = \n\t\t[\n\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"SomeMethod\")\n\t\t],\n\t\tParameters = \n\t\t[\n\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t{\n\t\t\t\tName = \"value\",\n\t\t\t\tAttributes = [],\n\t\t\t},\n\t\t],\n\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.MethodDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.MethodDataSourceDrivenTests),\n\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"MethodDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t{\n\t\t\t\tName = \"MethodDataSourceDrivenTests\",\n\t\t\t\tAttributes = [],\n\t\t\t}),\n\t\t\tName = \"MethodDataSourceDrivenTests\",\n\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\tAttributes = [],\n\t\t\tParameters = [],\n\t\t\tProperties = [],\n\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.MethodDataSourceDrivenTests? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tclassInstanceArguments = [];\n\n\t\t\tint methodArg = global::TUnit.TestProject.MethodDataSourceDrivenTests.SomeMethod();\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.MethodDataSourceDrivenTests>(() => \n\t\t\tnew global::TUnit.TestProject.MethodDataSourceDrivenTests()\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.MethodDataSourceDrivenTests.DataSource_Method2(int):0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_Method2(methodArg)),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 19,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.MethodDataSourceDrivenTests.DataSource_Method2(int):0\",\n\t\t\t\tMethodName = $\"DataSource_Method2\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"MethodDataSourceDrivenTests.DataSource_Method2 failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 19,\n\t\t\t});\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for ClassAndMethodArgumentsTests in C#\nDESCRIPTION: This snippet creates test metadata for the IgnoreParameters method, including test IDs, arguments, and execution factories. It handles different combinations of class and method arguments.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassAndMethodArgumentsTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nnodes.Add(new TestMetadata<global::TUnit.TestProject.ClassAndMethodArgumentsTests>\n{\n\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{classDataIndex}:CL-ARGS0:global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.ClassAndMethodArgumentsTests(string).IgnoreParameters(string):0\",\n\tTestClassArguments = [classArg],\n\tTestMethodArguments = [methodArg],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.IgnoreParameters(methodArg)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 16,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Mappable Result Assertion Builder in Csharp\nDESCRIPTION: This snippet defines an extension method that facilitates assertions with asynchronous mapping capabilities in Csharp. It specifically targets collections and allows for the registration of assertion conditions, mapping the result to the found item. Key prerequisites include the IValueSource interface and a compatible assertion condition class.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-assertions/extensibility/returning-items-from-await.md#2025-04-22_snippet_1\n\nLANGUAGE: Csharp\nCODE:\n```\npublic static MappableResultAssertionBuilder<IEnumerable<TInner>, EnumerableContainsExpectedFuncAssertCondition<IEnumerable<TInner>, TInner>, TInner> Contains<TInner>(this IValueSource<IEnumerable<TInner>> valueSource, Func<TInner, bool> matcher, [CallerArgumentExpression(nameof(matcher))] string doNotPopulateThisValue = null)\n    {\n        var enumerableContainsExpectedFuncAssertCondition = new EnumerableContainsExpectedFuncAssertCondition<IEnumerable<TInner>, TInner>(matcher, doNotPopulateThisValue);\n\n        return new MappableResultAssertionBuilder<IEnumerable<TInner>,\n            EnumerableContainsExpectedFuncAssertCondition<IEnumerable<TInner>, TInner>, TInner>(\n            valueSource.RegisterAssertion(enumerableContainsExpectedFuncAssertCondition, [doNotPopulateThisValue]),\n            enumerableContainsExpectedFuncAssertCondition,\n            (_, assertCondition) => assertCondition.FoundItem\n        );\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Test Source Generation in C#\nDESCRIPTION: Auto-generated source code for handling asynchronous (Task-based) test method execution in TUnit. Includes test metadata collection, instance management, and error handling for the AsynchronousTest method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Dynamic/Basic.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class BasicTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new BasicTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BasicTests),\n\t\t\t\tName = \"AsynchronousTest\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute()\n\t\t\t\t],\n\t\t\t\tParameters = []\n\t\t\t}\n```\n\n----------------------------------------\n\nTITLE: Registering and Executing Before Test Hook with TUnit in C#\nDESCRIPTION: This code snippet registers and executes a `BeforeTest` hook for the STAThreadTest using the TUnit framework. It defines and initializes a new InstanceHookMethod that encapsulates method information and execution details, associated with a test executor class. Dependencies include TUnit.Core and related namespaces. This setup is included to ensure any necessary pre-test actions or preparations are handled.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/STAThreadHooksTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t{\n\t\t\tClassType = typeof(global::TUnit.TestProject.STAThreadTests),\n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.STAThreadTests),\n\t\t\t\tName = \"BeforeTest\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test),\n\t\t\t\t\tnew global::TUnit.Core.Executors.HookExecutorAttribute<global::TUnit.Core.STAThreadExecutor>()\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.STAThreadTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.STAThreadTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"STAThreadHooksTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"STAThreadHooksTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"STAThreadTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute(\"Interoperability\", \"CA1416:Validate platform compatibility\")\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.STAThreadTests)classInstance).BeforeTest()),\n\t\t\t\t\tHookExecutor = new global::TUnit.Core.STAThreadExecutor(),\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test),\n\t\t\t\t\t\tnew global::TUnit.Core.Executors.HookExecutorAttribute<global::TUnit.Core.STAThreadExecutor>()\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute(\"Interoperability\", \"CA1416:Validate platform compatibility\")\n\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic DynamicTest<TClass> in C#\nDESCRIPTION: Defines a generic DynamicTest<TClass> class that inherits from DynamicTest. It provides functionality for creating dynamic tests with specific class types.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class DynamicTest<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicParameterlessConstructor | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]  TClass> : TUnit.Core.DynamicTest, System.IEquatable<TUnit.Core.DynamicTest<TClass>>\n    where TClass :  class\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public DynamicTest() { }\n    [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicParameterlessConstructor | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]\n    public override System.Type TestClassType { get; }\n    public override string TestId { get; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Linq.Expressions.Expression<System.Action<TClass>> TestMethod { get; init; }\n    public override System.Collections.Generic.IEnumerable<TUnit.Core.TestMetadata> BuildTestMetadatas() { }\n    public class MethodBody : System.IEquatable<TUnit.Core.DynamicTest<TClass>.MethodBody>\n    {\n        public MethodBody() { }\n        public System.Action<TClass>? SynchronousBody { get; init; }\n        public System.Func<TClass, System.Threading.Tasks.Task>? TaskBody { get; init; }\n        public static TUnit.Core.DynamicTest<TClass>.MethodBody op_Implicit(System.Action<TClass> action) { }\n        public static TUnit.Core.DynamicTest<TClass>.MethodBody op_Implicit(System.Func<TClass, System.Threading.Tasks.Task> taskBody) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Providing Log Levels from Command-line Options - TUnit & Microsoft Testing Platform - C#\nDESCRIPTION: Implements a LogLevelProvider class to extract and represent the desired log level as defined by the user via command-line options. Depends on ICommandLineOptions from the Microsoft.Testing.Platform.CommandLine namespace to interpret arguments. Exposes a LogLevel property, helping consumers adjust logging verbosity dynamically based on user input.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\npublic class LogLevelProvider\n{\n    public LogLevelProvider(Microsoft.Testing.Platform.CommandLine.ICommandLineOptions commandLineOptions) { }\n    public TUnit.Core.Enums.LogLevel LogLevel { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting After Every Test Hooks in C#\nDESCRIPTION: Method that returns an empty collection of static hook methods to be executed after every test. This implements part of the ITestHookSource interface.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Hooks1589.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTimeEqualToAssertionBuilderWrapper for DateTime Comparisons\nDESCRIPTION: Specialized assertion builder for comparing DateTime values with tolerance options. It allows specifying a TimeSpan-based tolerance for datetime comparisons.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_82\n\nLANGUAGE: C#\nCODE:\n```\npublic class DateTimeEqualToAssertionBuilderWrapper : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTime>\n{\n    public TUnit.Assertions.AssertionBuilders.Wrappers.DateTimeEqualToAssertionBuilderWrapper Within(System.TimeSpan tolerance, [System.Runtime.CompilerServices.CallerArgumentExpression(\"tolerance\")] string doNotPopulateThis = \"\") { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Matrix Test Cases for AutoGenerateBools2 Method\nDESCRIPTION: This snippet generates test cases for the AutoGenerateBools2 method using matrix data sources. It creates TestMetadata objects for each combination of input parameters and handles test initialization.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MatrixTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nvar methodArgGeneratedData = methodArgGeneratedDataAccessor();\nstring methodArg = global::TUnit.Core.Helpers.CastHelper.Cast<string>(methodArgGeneratedData[0]);\nbool? methodArg1 = global::TUnit.Core.Helpers.CastHelper.Cast<bool?>(methodArgGeneratedData[1]);\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.MatrixTests>(() => \nnew global::TUnit.TestProject.MatrixTests()\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.MatrixTests>\n{\n\tTestId = $\"global::TUnit.Core.MatrixDataSourceAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.MatrixTests.AutoGenerateBools2(string,bool?):0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [methodArg, methodArg1],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.AutoGenerateBools2(methodArg, methodArg1)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 50,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Collecting and Handling Test Metadata in TUnit C#\nDESCRIPTION: This snippet exemplifies the setup and handling of test metadata for the ArgsAsArrayTests class using TUnit. It manages test identification, method arguments, class properties, and factory methods for test execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ArgsAsArrayTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nnodes.Add(new TestMetadata<global::TUnit.TestProject.ArgsAsArrayTests>\n{\n    TestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.ArgsAsArrayTests.ParamsEnumerable(System.Collections.Generic.IEnumerable<string>):0\",\n    TestClassArguments = [],\n    TestMethodArguments = [methodArg],\n    TestClassProperties = [],\n    CurrentRepeatAttempt = 0,\n    RepeatLimit = 0,\n    ResettableClassFactory = resettableClassFactory,\n    TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.ParamsEnumerable(methodArg)),\n    TestFilePath = @\"\",\n    TestLineNumber = 25,\n    TestMethod = testInformation,\n    TestBuilderContext = testBuilderContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Culture and Executor Attributes in C#\nDESCRIPTION: This snippet defines attributes for handling culture settings and test execution. It includes CultureAttribute for setting culture info, HookExecutorAttribute for defining hook executors, and STAThreadExecutorAttribute for STA thread execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_56\n\nLANGUAGE: C#\nCODE:\n```\nnamespace TUnit.Core.Executors\n{\n    [System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\n    public class CultureAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestRegisteredEventReceiver\n    {\n        public CultureAttribute(System.Globalization.CultureInfo cultureInfo) { }\n        public CultureAttribute(string cultureName) { }\n        public int Order { get; }\n        public System.Threading.Tasks.ValueTask OnTestRegistered(TUnit.Core.TestRegisteredContext context) { }\n    }\n    // ... other attribute classes ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Hooks for GlobalBase2 in C#\nDESCRIPTION: Source-generated partial class implementing ITestHookSource interface for GlobalBase2. Provides similar hook functionality as GlobalBase1 but implements AfterEach2 hook instead.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticAfterEachTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_GlobalBase2 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_GlobalBase2();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\t// ... rest of implementation\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting TUnit Test Hooks (Implicit Hooks_GlobalCleanUpTests) in C#\nDESCRIPTION: This snippet shows the implementation of hook collection methods within a class likely generated for `GlobalCleanUpTests`. It implements methods from `ITestHookSource` to provide lists of hooks. Notably, `CollectAfterTestHooks` returns an `InstanceHookMethod` representing the `CleanUpWithContext` method from `TUnit.TestProject.AfterTests.GlobalCleanUpTests`, including detailed metadata like parameters, attributes, and execution logic.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticAfterEachTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),\n\t\t\t\t\tName = \"CleanUpWithContext\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test),\n\t\t\t\t\t\tnew global::TUnit.Core.TimeoutAttribute(30_000)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"testContext\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.GlobalCleanUpTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"GlobalStaticAfterEachTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"GlobalStaticAfterEachTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"GlobalCleanUpTests\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.AfterTests.GlobalCleanUpTests)classInstance).CleanUpWithContext(context, cancellationToken)),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test),\n\t\t\t\t\t\tnew global::TUnit.Core.TimeoutAttribute(30_000)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Framework Interfaces in C#\nDESCRIPTION: Defines core interfaces for the test framework including initialization, class construction, configuration, and event handling functionality.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_60\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IAsyncInitializer\n{\n    System.Threading.Tasks.Task InitializeAsync();\n}\n\npublic interface IClassConstructor\n{\n    T Create<T>(TUnit.Core.ClassConstructorMetadata classConstructorMetadata)\n        where T : class;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing String Difference Comparison in C#\nDESCRIPTION: A class for comparing strings and identifying differences, with support for whitespace handling and custom comparison logic.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_82\n\nLANGUAGE: C#\nCODE:\n```\npublic class StringDifference\n{\n    public StringDifference(string? actualValue, string? expectedValue, System.Collections.Generic.IEqualityComparer<string>? comparer = null) { }\n    public int IgnoreWhiteSpace { get; set; }\n    public int? OverriddenIndex { get; set; }\n    public int IndexOfFirstMismatch() { }\n    public override string ToString() { }\n    public string ToString(string prefix) { }\n}\n```\n\n----------------------------------------\n\nTITLE: BrowserTest Class Definition in C#\nDESCRIPTION: A test class for browser-level testing that inherits from PlaywrightTest. Provides methods for browser setup/teardown and handles browser instance lifecycle management.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class BrowserTest : TUnit.Playwright.PlaywrightTest\n{\n    public BrowserTest() { }\n    public BrowserTest(Microsoft.Playwright.BrowserTypeLaunchOptions options) { }\n    public Microsoft.Playwright.IBrowser Browser { get; }\n    [TUnit.Core.Before(TUnit.Core.HookType.Test, \"\", 0)]\n    public System.Threading.Tasks.Task BrowserSetup() { }\n    [TUnit.Core.After(TUnit.Core.HookType.Test, \"\", 0)]\n    public System.Threading.Tasks.Task BrowserTearDown(TUnit.Core.TestContext testContext) { }\n    public System.Threading.Tasks.Task<Microsoft.Playwright.IBrowserContext> NewContext(Microsoft.Playwright.BrowserNewContextOptions options) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing SourceGeneratedAssemblyInformation Metadata - TUnit - C#\nDESCRIPTION: Initializes an object representing source-generated assembly metadata for the class 'ClassTupleDataSourceDrivenTests' using TUnit Core methods. Requires TUnit.Core library. Key properties set include the name of the assembly and an empty list of attributes. Expected input is the assembly name, and the output is a populated SourceGeneratedAssemblyInformation object. The pattern is foundational for subsequent class and method metadata declarations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"ClassTupleDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n{\n\tName = \"ClassTupleDataSourceDrivenTests\",\n\tAttributes = [],\n}),\n```\n\n----------------------------------------\n\nTITLE: Implementing Method Data Source Attributes in C#\nDESCRIPTION: Attributes for sourcing test data from methods with support for generic typing. Allows tests to use data generated by specified methods, with options for external class providers and argument passing.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method | System.AttributeTargets.Property, AllowMultiple=true)]\npublic class MethodDataSourceAttribute : TUnit.Core.TestDataAttribute\n{\n    public MethodDataSourceAttribute(string methodNameProvidingDataSource) { }\n    public MethodDataSourceAttribute(System.Type classProvidingDataSource, string methodNameProvidingDataSource) { }\n    public object?[] Arguments { get; set; }\n    public System.Type? ClassProvidingDataSource { get; }\n    public string MethodNameProvidingDataSource { get; }\n}\n\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method | System.AttributeTargets.Property, AllowMultiple=true)]\npublic class MethodDataSourceAttribute<T> : TUnit.Core.MethodDataSourceAttribute\n{\n    public MethodDataSourceAttribute(string methodNameProvidingDataSource) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating TestMetadata for Eight-Parameter Test Method in C#\nDESCRIPTION: Generates TestMetadata for a test method with eight parameters, extracting data from a method data source. The code handles parameters, class instantiation, and exception handling for the Eight_Args test method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1538.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1538.Tests),\n\t\t\tName = \"Eight_Args\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"EightItems\")\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t\t\t{\n\t\t\t\t\tName = \"expectedSuccess\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t{\n\t\t\t\t\tName = \"expectedError\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t{\n\t\t\t\t\tName = \"expectedT0\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t{\n\t\t\t\t\tName = \"expectedT1\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t{\n\t\t\t\t\tName = \"expectedT2\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t{\n\t\t\t\t\tName = \"expectedT3\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t{\n\t\t\t\t\tName = \"expectedT4\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t{\n\t\t\t\t\tName = \"expectedT5\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._1538.Tests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1538.Tests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Tests1538\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"Tests1538\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"Tests\",\n\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._1538\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.Bugs._1538.Tests? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tforeach (var methodDataAccessor in global::TUnit.TestProject.Bugs._1538.Tests.EightItems())\n\t\t\t{\n\t\t\t\ttestMethodDataIndex++;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tvar methodData = methodDataAccessor;\n\t\t\t\tvar methodArgTuples = global::System.TupleExtensions.ToTuple<bool, string, string, string, string, string, string, string>(methodData);\n\t\t\t\tbool methodArg = methodArgTuples.Item1;\n\t\t\t\tstring methodArg1 = methodArgTuples.Item2;\n\t\t\t\tstring methodArg2 = methodArgTuples.Item3;\n\t\t\t\tstring methodArg3 = methodArgTuples.Item4;\n\t\t\t\tstring methodArg4 = methodArgTuples.Item5;\n\t\t\t\tstring methodArg5 = methodArgTuples.Item6;\n\t\t\t\tstring methodArg6 = methodArgTuples.Item7;\n\t\t\t\tstring methodArg7 = methodArgTuples.Rest.Item1;\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._1538.Tests>(() => \n\t\t\t\tnew global::TUnit.TestProject.Bugs._1538.Tests()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._1538.Tests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS0:{testMethodDataIndex}:TUnit.TestProject.Bugs._1538.Tests.Eight_Args(bool,string,string,string,string,string,string,string):0\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [methodArg, methodArg1, methodArg2, methodArg3, methodArg4, methodArg5, methodArg6, methodArg7],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Eight_Args(methodArg, methodArg1, methodArg2, methodArg3, methodArg4, methodArg5, methodArg6, methodArg7)),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 5,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._1538.Tests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS0:{testMethodDataIndex}:TUnit.TestProject.Bugs._1538.Tests.Eight_Args(bool,string,string,string,string,string,string,string):0\",\n\t\t\t\tMethodName = $\"Eight_Args\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"Tests.Eight_Args failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 5,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n```\n\n----------------------------------------\n\nTITLE: Registering and Initializing High Priority Tests in TUnit C# (High_2)\nDESCRIPTION: This snippet defines a method to register and initialize a high priority test named 'High_2'. It sets up necessary test metadata and creates instances required for test execution within the TUnit framework. In case of exceptions during initialization, they are captured and handled properly. It depends on TUnit.Core and related namespaces.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/PriorityFilteringTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class PriorityFilteringTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new PriorityFilteringTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.PriorityFilteringTests),\n\t\t\t\tName = \"High_2\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.TestProject.PriorityAttribute(global::TUnit.TestProject.Enums.PriorityLevel.High)\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.PriorityFilteringTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.PriorityFilteringTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"PriorityFilteringTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"PriorityFilteringTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"PriorityFilteringTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.PriorityFilteringTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.PriorityFilteringTests>(() => \n\t\t\t\tnew global::TUnit.TestProject.PriorityFilteringTests()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.PriorityFilteringTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"TUnit.TestProject.PriorityFilteringTests.High_2:0\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.High_2()),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 18,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.PriorityFilteringTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"TUnit.TestProject.PriorityFilteringTests.High_2:0\",\n\t\t\t\t\tMethodName = $\"High_2\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"PriorityFilteringTests.High_2 failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 18,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n\t}\n\n```\n\n----------------------------------------\n\nTITLE: ImmutableArray Assertion Extensions in C#\nDESCRIPTION: Extension methods for asserting various conditions on ImmutableArray, including emptiness, equivalence, and ordering.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_73\n\nLANGUAGE: C#\nCODE:\n```\npublic static class ImmutableArrayIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsEmpty<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsEquivalentTo<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Immutable.ImmutableArray<TInner> expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsEquivalentTo<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Immutable.ImmutableArray<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsEquivalentTo<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Immutable.ImmutableArray<TInner> expected, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsEquivalentTo<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Immutable.ImmutableArray<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsInDescendingOrder<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsInDescendingOrder<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Generic.IComparer<TInner> comparer) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsInOrder<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsInOrder<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Generic.IComparer<TInner> comparer) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsOrderedBy<TInner, TComparisonItem>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Func<TInner, TComparisonItem> comparisonItemSelector, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparisonItemSelector\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsOrderedBy<TInner, TComparisonItem>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Func<TInner, TComparisonItem> comparisonItemSelector, System.Collections.Generic.IComparer<TComparisonItem> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparisonItemSelector\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparer\")] string doNotPopulateThisValue2 = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsOrderedByDescending<TInner, TComparisonItem>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Func<TInner, TComparisonItem> comparisonItemSelector, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparisonItemSelector\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsOrderedByDescending<TInner, TComparisonItem>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Func<TInner, TComparisonItem> comparisonItemSelector, System.Collections.Generic.IComparer<TComparisonItem> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparisonItemSelector\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparer\")] string doNotPopulateThisValue2 = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Global Test Hooks for GlobalBase2 in C#\nDESCRIPTION: Defines a partial class Hooks_GlobalBase2 that implements ITestHookSource. It registers a before-test hook method 'BeforeEach2' from the GlobalBase2 class.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticBeforeEachTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_GlobalBase2 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_GlobalBase2();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.BeforeTests.GlobalBase2),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.GlobalBase2),\n\t\t\t\t\tName = \"BeforeEach2\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.GlobalBase2\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.GlobalBase2),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"GlobalStaticBeforeEachTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"GlobalStaticBeforeEachTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"GlobalBase2\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.BeforeTests.GlobalBase2)classInstance).BeforeEach2()),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing TUnit Test Source Registration\nDESCRIPTION: Registers the ClassTupleDataSourceDrivenTests class as a test source for TUnit using a module initializer.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=TupleMethod_testMethodName=TupleMethod.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tSourceRegistrar.Register(new ClassTupleDataSourceDrivenTests());\n}\n```\n\n----------------------------------------\n\nTITLE: Registering CustomDisplayNameTests with TUnit Core via Source Generation in C#\nDESCRIPTION: This snippet demonstrates how the CustomDisplayNameTests class is registered with the TUnit Core test framework on module initialization. It uses C# module initializers to ensure the test class is automatically registered before any test discovery or execution. This is required for TUnit to discover, generate, and manage the test metadata for this source-generated test file.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/CustomDisplayNameTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tglobal::TUnit.Core.SourceRegistrar.Register(new CustomDisplayNameTests());\n}\n```\n\n----------------------------------------\n\nTITLE: Generating TestMetadata for Data-Driven Tests in C#\nDESCRIPTION: Creates TestMetadata objects for each test method (DataSource_Method and DataSource_Method2) using enumerable data sources. It handles test initialization, parameter passing, and exception handling for failed initializations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/EnumerableDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\t// ... (test information and initialization code)\n\n\t\tforeach (var methodDataAccessor in global::TUnit.TestProject.EnumerableDataSourceDrivenTests.SomeMethod())\n\t\t{\n\t\t\t// ... (test metadata generation code)\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.EnumerableDataSourceDrivenTests>\n\t\t\t{\n\t\t\t\t// ... (test metadata properties)\n\t\t\t});\n\t\t}\n\t}\n\tcatch (global::System.Exception exception)\n\t{\n\t\t// ... (exception handling code)\n\t}\n\treturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: TestJson Class for Test Case Serialization\nDESCRIPTION: Comprehensive JSON model class for representing individual test cases, including metadata, parameters, and results. This class captures all necessary information about a test for serialization and reporting.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class TestJson : System.IEquatable<TUnit.Engine.Json.TestJson>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public TestJson() { }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Collections.Generic.IReadOnlyList<string> Categories { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string? ClassType { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Collections.Generic.IReadOnlyDictionary<string, string> CustomProperties { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string DisplayName { get; set; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Collections.Generic.Dictionary<string, object?> ObjectBag { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Engine.Json.TestResultJson? Result { get; set; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public int RetryLimit { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string? ReturnType { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public object?[]? TestClassArguments { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string?[]? TestClassParameterTypes { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string TestFilePath { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string TestId { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public int TestLineNumber { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public object?[]? TestMethodArguments { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string?[]? TestMethodParameterTypes { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string TestName { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.TimeSpan? Timeout { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: TimeSpan Negative Assertion Extensions in TUnit\nDESCRIPTION: Extension methods for negative TimeSpan assertions, specifically for checking if a TimeSpan is not zero.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_159\n\nLANGUAGE: C#\nCODE:\n```\npublic static class TimeSpanIsNotExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.TimeSpan> IsNotZero(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.TimeSpan> valueSource) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating AutoFixture-Based Data Source Generators in C#\nDESCRIPTION: This snippet demonstrates how to implement a custom data source generator using AutoFixture. It extends the DataSourceGeneratorAttribute class to provide data for tests through the GenerateDataSources method, yielding generic tuples for test parameters. Dependencies include the TUnit framework and AutoFixture. This implementation supports dynamic data creation, reducing the risk of shared state issues in nested tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/data-source-generators.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class AutoFixtureGeneratorAttribute<T1, T2, T3> : DataSourceGeneratorAttribute<T1, T2, T3>\n{\n    public override IEnumerable<Func<(T1, T2, T3)>> GenerateDataSources(DataGeneratorMetadata dataGeneratorMetadata)\n    {\n        var fixture = new Fixture();\n        \n        yield return () => (fixture.Create<T1>(), fixture.Create<T2>(), fixture.Create<T3>());\n    }\n}\n\n[AutoFixtureGenerator<SomeClass1, SomeClass2, SomeClass3>]\npublic class MyTestClass(SomeClass1 someClass1, SomeClass2 someClass2, SomeClass3 someClass3)\n{\n    [Test]\n    [AutoFixtureGenerator<int, string, bool>]\n    public async Task Test((int value, string value2, bool value3))\n    {\n        // ...\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for StringArgumentTests.Normal Method in C#\nDESCRIPTION: This snippet creates test metadata for the Normal method of StringArgumentTests class. It handles various string arguments, including escaped characters and multi-line strings. The code sets up test information, creates a test builder context, and adds test metadata to a list of nodes.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/StringArgumentTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests5(string sessionId)\n{\n    global::System.Collections.Generic.List<TestMetadata> nodes = [];\n    var classDataIndex = 0;\n    var testMethodDataIndex = 0;\n    try\n    {\n        var testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n        {\n            Type = typeof(global::TUnit.TestProject.StringArgumentTests),\n            Name = \"Normal\",\n            GenericTypeCount = 0,\n            ReturnType = typeof(void),\n            Attributes = \n            [\n                new global::TUnit.Core.TestAttribute(),\n                new global::TUnit.Core.ArgumentsAttribute(\"\"),\n                new global::TUnit.Core.ArgumentsAttribute(@\"\\\"),\n                new global::TUnit.Core.ArgumentsAttribute(@\"\\t\"),\n                new global::TUnit.Core.ArgumentsAttribute(\"\\t\"),\n                new global::TUnit.Core.ArgumentsAttribute(\"\\\\t\"),\n                new global::TUnit.Core.ArgumentsAttribute(\"\\\\\\t\"),\n                new global::TUnit.Core.ArgumentsAttribute(\"\\\\\\\\t\"),\n                new global::TUnit.Core.ArgumentsAttribute(        \"\"\"\n        Hello\n        World\n        \"\"\"\n)\n            ],\n            Parameters = \n            [\n                new global::TUnit.Core.SourceGeneratedParameterInformation<string>\n                {\n                    Name = \"s\",\n                    Attributes = [],\n                },\n            ],\n            Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.StringArgumentTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n            {\n                Type = typeof(global::TUnit.TestProject.StringArgumentTests),\n                Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"StringArgumentTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n                {\n                    Name = \"StringArgumentTests\",\n                    Attributes = [],\n                }),\n                Name = \"StringArgumentTests\",\n                Namespace = \"TUnit.TestProject\",\n                Attributes = [],\n                Parameters = [],\n                Properties = [],\n            }),\n        };\n\n        var testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n        var testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n        global::TUnit.TestProject.StringArgumentTests? classInstance = null;\n        object?[]? classInstanceArguments = null;\n        classInstanceArguments = [];\n\n        string methodArg = \"\\\\\\t\";\n\n        var resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.StringArgumentTests>(() => \n        new global::TUnit.TestProject.StringArgumentTests()\n        , sessionId, testBuilderContext);\n        var resettableClassFactory = resettableClassFactoryDelegate();\n\n\n        nodes.Add(new TestMetadata<global::TUnit.TestProject.StringArgumentTests>\n        {\n            TestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS5:TUnit.TestProject.StringArgumentTests.Normal(string):0\",\n            TestClassArguments = [],\n            TestMethodArguments = [methodArg],\n            TestClassProperties = [],\n            CurrentRepeatAttempt = 0,\n            RepeatLimit = 0,\n            ResettableClassFactory = resettableClassFactory,\n            TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Normal(methodArg)),\n            TestFilePath = @\"\",\n            TestLineNumber = 5,\n            TestMethod = testInformation,\n            TestBuilderContext = testBuilderContext,\n        });\n        resettableClassFactory = resettableClassFactoryDelegate();\n        testBuilderContext = new();\n        testBuilderContextAccessor.Current = testBuilderContext;\n    }\n    catch (global::System.Exception exception)\n    {\n        nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.StringArgumentTests>\n        {\n            TestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS5:TUnit.TestProject.StringArgumentTests.Normal(string):0\",\n            MethodName = $\"Normal\",\n            Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"StringArgumentTests.Normal failed to initialize\", exception),\n            TestFilePath = @\"\",\n            TestLineNumber = 5,\n        });\n    }\n    return nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TUnit Source-Generated Test Hook Base Class in C#\nDESCRIPTION: This source-generated file defines a Hooks_BaseClass that implements ITestHookSource. It initializes test hooks, registers itself with the framework, and contains methods for collecting different types of hooks (before/after test hooks at both static and instance levels).\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1899.BaseClass.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[  \n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_BaseClass : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_BaseClass();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod\n\t\t\t{\n\t\t\t\tClassType = typeof(global::TUnit.TestProject.Library.Bugs._1899.BaseClass<>),\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.Library.Bugs._1899.BaseClass<>),\n\t\t\t\t\tName = \"Setup\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(void),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Library.Bugs._1899.BaseClass<>\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.Library.Bugs._1899.BaseClass<>),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Tests1899\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"Tests1899\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"BaseClass\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.Library.Bugs._1899\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.ConvertObject(() => classInstance.GetType().GetMethod(\"Setup\", []).Invoke(classInstance, [])),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\t\t\t\t\t\tAssemblyAttributes = \n[],\n\t\t\t\t},\n\t\t\t};\n\t\t]\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Display Name Attribute in C#\nDESCRIPTION: Custom attribute class for formatting test display names with inheritance from DisplayNameFormatterAttribute\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Method, Inherited=false)]\npublic sealed class DisplayNameAttribute : TUnit.Core.DisplayNameFormatterAttribute\n{\n    public DisplayNameAttribute(string displayName) { }\n    protected override string FormatDisplayName(TUnit.Core.TestContext testContext) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ITestHookSource for AssemblyBase2 in C#\nDESCRIPTION: This snippet defines a partial class Hooks_AssemblyBase2 that implements ITestHookSource. It registers test hooks for AssemblyBase2, although no specific hooks are implemented in this snippet.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyBeforeTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_AssemblyBase2 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_AssemblyBase2();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: TimeSpan Extension Methods\nDESCRIPTION: Fluent extensions for creating TimeSpan objects from integer values\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_133\n\nLANGUAGE: C#\nCODE:\n```\npublic static class TimeSpanExtensions\n{\n    public static System.TimeSpan Days(this int days) { }\n    public static System.TimeSpan Hours(this int hours) { }\n    public static System.TimeSpan Milliseconds(this int milliseconds) { }\n    public static System.TimeSpan Minutes(this int minutes) { }\n    public static System.TimeSpan Seconds(this int seconds) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Not Equivalent To Expected Value Assertion in C#\nDESCRIPTION: This class implements an assertion condition to check if two values are not equivalent. It extends the ExpectedValueAssertCondition class and includes methods for ignoring specific members during comparison.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_120\n\nLANGUAGE: C#\nCODE:\n```\npublic class NotEquivalentToExpectedValueAssertCondition<TActual, TExpected> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TExpected>\n{\n    public NotEquivalentToExpectedValueAssertCondition(TExpected expected, string? expectedExpression) { }\n    public TUnit.Assertions.Enums.EquivalencyKind EquivalencyKind { get; set; }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TExpected? expectedValue) { }\n    public void IgnoringMember(string fieldName) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Registering TestMetadata for Data-Driven Tests - TUnit - C#\nDESCRIPTION: This C# snippet generates metadata for a data-driven unit test method called 'NullValue' within a source-generated context for the TUnit framework. It creates a TestMetadata object tracking method, arguments, registration status, and initialization exceptions, adding each test to a list. It handles multiple test scenarios and captures error context for failed initialization. Dependencies include TUnit.Core, TUnit.TestProject, and .NET collections.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class DataDrivenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new DataDrivenTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\t// ...test setup context\n\t\t\t// Example for 'NullValue' test registration\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.DataDrivenTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.DataDrivenTests.NullValue(string):0\",\n\t\t\t\tMethodName = $\"NullValue\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"DataDrivenTests.NullValue failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 32,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing IClassHookSource for Base3 in C#\nDESCRIPTION: This snippet implements the IClassHookSource interface for the Base3 class, defining methods to collect before and after class hooks. It includes a BeforeAll3 method as a before class hook.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeAllTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeClassHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.BeforeClassHookMethod\n\t\t{\n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.Base3),\n\t\t\t\tName = \"BeforeAll3\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.Base3\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.Base3),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"BeforeAllTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"BeforeAllTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"Base3\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.BeforeTests.Base3.BeforeAll3()),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tFilePath = @\"\",\n\t\t\t\tLineNumber = 35,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\tAssemblyAttributes = [],\n\t\t\t},\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing StopExecutionCapability in C#\nDESCRIPTION: Defines a class for stopping test execution gracefully, implementing ICapability and IGracefulStopTestExecutionCapability interfaces.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class StopExecutionCapability : Microsoft.Testing.Platform.Capabilities.ICapability, Microsoft.Testing.Platform.Capabilities.TestFramework.IGracefulStopTestExecutionCapability, Microsoft.Testing.Platform.Capabilities.TestFramework.ITestFrameworkCapability\n{\n    public StopExecutionCapability() { }\n    public bool IsStopRequested { get; }\n    public TUnit.Core.AsyncEvent<System.EventArgs>? OnStopRequested { get; set; }\n    public System.Threading.Tasks.Task StopTestExecutionAsync(System.Threading.CancellationToken cancellationToken) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Before and After Test Hooks in TUnit C#\nDESCRIPTION: This C# snippet shows signature implementations of methods designed to collect hooks used before and after tests in the TUnit framework. It defines several `IReadOnlyList` implementations for both static and instance hook methods. Dependencies on `global::TUnit.Core.Hooks` and `System.Threading.Tasks.Task` are needed for asynchronous operations. The `sessionId` parameter is passed to collect context-specific hooks, but the returned lists are empty or predefined with static class types and methods.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticBeforeEachTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n{\n    return\n    [\n    ];\n}\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n{\n    return\n    [\n    ];\n}\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n{\n    return\n    [\n        new global::TUnit.Core.Hooks.InstanceHookMethod\n        {\n            ClassType = typeof(global::TUnit.TestProject.BeforeTests.GlobalSetUpTests),\n            MethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n            {\n                Type = typeof(global::TUnit.TestProject.BeforeTests.GlobalSetUpTests),\n                Name = \"SetUpWithContext\",\n                GenericTypeCount = 0,\n                ReturnType = typeof(global::System.Threading.Tasks.Task),\n                Attributes = \n                [\n                    new global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test),\n                    new global::TUnit.Core.TimeoutAttribute(30_000)\n                ],\n                Parameters = \n                [\n                    new global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext>\n                    {\n                        Name = \"testContext\",\n                        Attributes = [],\n                    },\n                    new global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n                    {\n                        Name = \"cancellationToken\",\n                        Attributes = [],\n                    },\n                ],\n                Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.GlobalSetUpTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n                {\n                    Type = typeof(global::TUnit.TestProject.BeforeTests.GlobalSetUpTests),\n                    Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"GlobalStaticBeforeEachTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n                    {\n                        Name = \"GlobalStaticBeforeEachTests\",\n                        Attributes = [],\n                    }),\n                    Name = \"GlobalSetUpTests\",\n                    Namespace = \"TUnit.TestProject.BeforeTests\",\n                    Attributes = [],\n                    Parameters = [],\n                    Properties = [],\n                }),\n},\n                Body = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.BeforeTests.GlobalSetUpTests)classInstance).SetUpWithContext(context, cancellationToken)),\n                HookExecutor = DefaultExecutor.Instance,\n                Order = 0,\n                MethodAttributes = \n                [\n                    new global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test),\n                    new global::TUnit.Core.TimeoutAttribute(30_000)\n                ],\n                ClassAttributes = [],\n                                    AssemblyAttributes = \n[],\n            },\n        ];\n}\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n{\n    return\n    [\n    ];\n}\n\n```\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_GlobalBase1 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n    [global::System.Runtime.CompilerServices.ModuleInitializer]\n    public static void Initialise()\n    {\n        var instance = new Hooks_GlobalBase1();\n        SourceRegistrar.RegisterTestHookSource(instance);\n    }\n    public global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n    {\n        return\n        [\n            new global::TUnit.Core.Hooks.BeforeTestHookMethod\n            { \n            MethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n            {\n                Type = typeof(global::TUnit.TestProject.BeforeTests.GlobalBase1),\n                Name = \"BeforeAll1\",\n                GenericTypeCount = 0,\n                ReturnType = typeof(global::System.Threading.Tasks.Task),\n                Attributes = \n                [\n                    new global::TUnit.Core.BeforeEveryAttribute(global::TUnit.Core.HookType.Test)\n                ],\n                Parameters = \n                [\n                    new global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext>\n                    {\n                        Name = \"context\",\n                        Attributes = [],\n                    },\n                ],\n                Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.GlobalBase1\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n                {\n                    Type = typeof(global::TUnit.TestProject.BeforeTests.GlobalBase1),\n                    Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"GlobalStaticBeforeEachTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n                    {\n                        Name = \"GlobalStaticBeforeEachTests\",\n                        Attributes = [],\n                    }),\n                    Name = \"GlobalBase1\",\n                    Namespace = \"TUnit.TestProject.BeforeTests\",\n                    Attributes = [],\n                    Parameters = [],\n                    Properties = [],\n                }),\n},\n                Body = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.BeforeTests.GlobalBase1.BeforeAll1(context)),\n                HookExecutor = DefaultExecutor.Instance,\n                Order = 0,\n                FilePath = \"\",\n                LineNumber = 5,\n                MethodAttributes = \n                [\n                    new global::TUnit.Core.BeforeEveryAttribute(global::TUnit.Core.HookType.Test)\n                ],\n                ClassAttributes = [],\n                AssemblyAttributes = [],\n            },\n        ];\n    }\n    public global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n    {\n        return\n        [\n        ];\n    }\n    public global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n    {\n        return\n        [\n        ];\n    }\n    public global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n    {\n        return\n        [\n        ];\n    }\n}\n\n```\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_GlobalBase2 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n    [global::System.Runtime.CompilerServices.ModuleInitializer]\n    public static void Initialise()\n    {\n        var instance = new Hooks_GlobalBase2();\n        SourceRegistrar.RegisterTestHookSource(instance);\n    }\n    public global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n    {\n        return\n        [\n            new global::TUnit.Core.Hooks.BeforeTestHookMethod\n            { \n            MethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n            {\n                Type = typeof(global::TUnit.TestProject.BeforeTests.GlobalBase2),\n                Name = \"BeforeAll2\",\n                GenericTypeCount = 0,\n                ReturnType = typeof(global::System.Threading.Tasks.Task),\n                Attributes = \n                [\n                    new global::TUnit.Core.BeforeEveryAttribute(global::TUnit.Core.HookType.Test)\n                ],\n                Parameters = \n                [\n                    new global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext>\n                    {\n                        Name = \"context\",\n                        Attributes = [],\n                    },\n                ],\n                Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.GlobalBase2\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n                {\n                    Type = typeof(global::TUnit.TestProject.BeforeTests.GlobalBase2),\n                    Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"GlobalStaticBeforeEachTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n                    {\n                        Name = \"GlobalStaticBeforeEachTests\",\n                        Attributes = [],\n                    }),\n                    Name = \"GlobalBase2\",\n                    Namespace = \"TUnit.TestProject.BeforeTests\",\n                    Attributes = [],\n                    Parameters = [],\n                    Properties = [],\n                }),\n},\n                Body = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.BeforeTests.GlobalBase2.BeforeAll2(context)),\n                HookExecutor = DefaultExecutor.Instance,\n                Order = 0,\n                FilePath = \"\",\n                LineNumber = 20,\n                MethodAttributes = \n                [\n                    new global::TUnit.Core.BeforeEveryAttribute(global::TUnit.Core.HookType.Test)\n                ],\n                ClassAttributes = [],\n                AssemblyAttributes = [],\n            },\n        ];\n    }\n    public global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n    {\n        return\n        [\n        ];\n    }\n    public global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n    {\n        return\n        [\n        ];\n    }\n    public global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n    {\n        return\n        [\n        ];\n    }\n}\n\n```\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_GlobalBase3 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n    [global::System.Runtime.CompilerServices.ModuleInitializer]\n    public static void Initialise()\n    {\n        var instance = new Hooks_GlobalBase3();\n        SourceRegistrar.RegisterTestHookSource(instance);\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Generating TestMetadata for ClassAndMethodArgumentsTests in C#\nDESCRIPTION: This method creates TestMetadata objects for the IgnoreParameters test method in the ClassAndMethodArgumentsTests class. It handles class and method arguments, test initialization, and exception handling.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassAndMethodArgumentsTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests3(string sessionId)\n{\n    global::System.Collections.Generic.List<TestMetadata> nodes = [];\n    var classDataIndex = 0;\n    var testMethodDataIndex = 0;\n    try\n    {\n        var testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n        {\n            Type = typeof(global::TUnit.TestProject.ClassAndMethodArgumentsTests),\n            Name = \"IgnoreParameters\",\n            GenericTypeCount = 0,\n            ReturnType = typeof(global::System.Threading.Tasks.Task),\n            Attributes = \n            [\n                new global::TUnit.Core.TestAttribute(),\n                new global::TUnit.Core.ArgumentsAttribute(\"3\"),\n                new global::TUnit.Core.ArgumentsAttribute(\"4\")\n            ],\n            Parameters = \n            [\n                new global::TUnit.Core.SourceGeneratedParameterInformation<string>\n                {\n                    Name = \"arg2\",\n                    Attributes = [],\n                },\n            ],\n            Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.ClassAndMethodArgumentsTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n            {\n                Type = typeof(global::TUnit.TestProject.ClassAndMethodArgumentsTests),\n                Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"ClassAndMethodArgumentsTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n                {\n                    Name = \"ClassAndMethodArgumentsTests\",\n                    Attributes = [],\n                }),\n                Name = \"ClassAndMethodArgumentsTests\",\n                Namespace = \"TUnit.TestProject\",\n                Attributes = \n                [\n                    new global::TUnit.Core.ArgumentsAttribute(\"1\"),\n                    new global::TUnit.Core.ArgumentsAttribute(\"2\")\n                ],\n                Parameters = \n                [\n                    new global::TUnit.Core.SourceGeneratedParameterInformation<string>\n                    {\n                        Name = \"arg1\",\n                        Attributes = [],\n                    },\n                ],\n                Properties = [],\n            }),\n        };\n\n        var testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n        var testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n        global::TUnit.TestProject.ClassAndMethodArgumentsTests? classInstance = null;\n        object?[]? classInstanceArguments = null;\n        string classArg = \"2\";\n\n        classInstanceArguments = [classArg];\n\n        string methodArg = \"4\";\n\n        var resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ClassAndMethodArgumentsTests>(() => \n        new global::TUnit.TestProject.ClassAndMethodArgumentsTests(classArg)\n        , sessionId, testBuilderContext);\n        var resettableClassFactory = resettableClassFactoryDelegate();\n\n\n        nodes.Add(new TestMetadata<global::TUnit.TestProject.ClassAndMethodArgumentsTests>\n        {\n            TestId = $\"global::TUnit.Core.ArgumentsAttribute:{classDataIndex}:CL-ARGS1:global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS1:TUnit.TestProject.ClassAndMethodArgumentsTests(string).IgnoreParameters(string):0\",\n            TestClassArguments = [classArg],\n            TestMethodArguments = [methodArg],\n            TestClassProperties = [],\n            CurrentRepeatAttempt = 0,\n            RepeatLimit = 0,\n            ResettableClassFactory = resettableClassFactory,\n            TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.IgnoreParameters(methodArg)),\n            TestFilePath = @\"\",\n            TestLineNumber = 16,\n            TestMethod = testInformation,\n            TestBuilderContext = testBuilderContext,\n        });\n        resettableClassFactory = resettableClassFactoryDelegate();\n        testBuilderContext = new();\n        testBuilderContextAccessor.Current = testBuilderContext;\n    }\n    catch (global::System.Exception exception)\n    {\n        nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ClassAndMethodArgumentsTests>\n        {\n            TestId = $\"global::TUnit.Core.ArgumentsAttribute:{classDataIndex}:CL-ARGS1:global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS1:TUnit.TestProject.ClassAndMethodArgumentsTests(string).IgnoreParameters(string):0\",\n            MethodName = $\"IgnoreParameters\",\n            Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ClassAndMethodArgumentsTests.IgnoreParameters failed to initialize\", exception),\n            TestFilePath = @\"\",\n            TestLineNumber = 16,\n        });\n    }\n    return nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Exception Handling and Failed Test Metadata Recording in TUnit - C#\nDESCRIPTION: This snippet demonstrates structured exception handling by catching initialization failures and adding a detailed 'FailedTestMetadata' object to the 'nodes' collection. It relies on the 'TUnit.Core.Exceptions.TestFailedInitializationException' and 'nodes' collection. Expected input is an exception during test setup; output is a populated metadata entry with diagnostics and traceability information, limited by required test data context.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests2085.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._2085.Tests>\n{\n    TestId = $\"global::TUnit.Core.MatrixDataSourceAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.Bugs._2085.Tests.Float_SpecialConsts(float):0\",\n    MethodName = $\"Float_SpecialConsts\",\n    Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"Tests.Float_SpecialConsts failed to initialize\", exception),\n    TestFilePath = @\"\",\n    TestLineNumber = 15,\n});\n```\n\n----------------------------------------\n\nTITLE: Exception Extension Methods Implementation in C#\nDESCRIPTION: Static class containing extension methods for exception handling and assertions. Provides methods for checking different types of exceptions and timing constraints.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\npublic static class ThrowsExtensions\n{\n    public static TUnit.Assertions.AssertConditions.Throws.ThrowsException<object?, TException> Throws<TException>(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource)\n        where TException : System.Exception { }\n    public static TUnit.Assertions.AssertConditions.Throws.ThrowsException<object?, TException> ThrowsExactly<TException>(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource)\n        where TException : System.Exception { }\n    public static TUnit.Assertions.AssertConditions.Throws.ThrowsException<object?, System.Exception> ThrowsException(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource) { }\n    public static TUnit.Assertions.AssertionBuilders.CastableResultAssertionBuilder<object?, object?> ThrowsNothing(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource) { }\n    public static TUnit.Assertions.AssertionBuilders.CastableResultAssertionBuilder<TActual, TActual> ThrowsNothing<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueDelegateSource<TActual> delegateSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableDelegateAssertionBuilder ThrowsWithin(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource, System.TimeSpan timeSpan, [System.Runtime.CompilerServices.CallerArgumentExpression(\"timeSpan\")] string? doNotPopulateThisValue = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing TUnit Tests with Custom Executors in C#\nDESCRIPTION: This C# example demonstrates defining a test class (`MyTestClass`) using the TUnit framework. It shows how to apply a custom `TestExecutor` (`STAThreadExecutor`) via the `[TestExecutor<STAThreadExecutor>]` attribute to force the `With_STA` test method to run within an STA thread. The second test, `Without_STA`, runs under the default MTA state. Both tests verify the thread's apartment state using TUnit assertions. This requires the `TUnit.Core` library and a defined `STAThreadExecutor` class implementing `ITestExecutor`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/executors.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    [TestExecutor<STAThreadExecutor>]\n    public async Task With_STA()\n    {\n        await Assert.That(Thread.CurrentThread.GetApartmentState()).IsEqualTo(ApartmentState.STA);\n    }\n    \n    [Test]\n    public async Task Without_STA()\n    {\n        await Assert.That(Thread.CurrentThread.GetApartmentState()).IsEqualTo(ApartmentState.MTA);\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Handling Initialization Exceptions for Alternate Parameterized TUnit Test Node in C#\nDESCRIPTION: For each argument variant, if initialization fails, a FailedTestMetadata entry is added to signal failure for the specific data-driven test case (in this case, using the next set of arguments). This maintains robust reporting and traceability for parameterized test failures during test discovery or setup.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/CustomDisplayNameTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.CustomDisplayNameTests>\n\t{\n\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS1:TUnit.TestProject.CustomDisplayNameTests.Test3(string,int,bool):0\",\n\t\tMethodName = $\"Test3\",\n\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"CustomDisplayNameTests.Test3 failed to initialize\", exception),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 26,\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: TimeOnly Assertion Extensions\nDESCRIPTION: Extension methods for asserting TimeOnly values including comparisons and equality checks\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_134\n\nLANGUAGE: C#\nCODE:\n```\npublic static class TimeOnlyIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.TimeOnly> IsAfter(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.TimeOnly> valueSource, System.TimeOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.TimeOnly> IsAfterOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.TimeOnly> valueSource, System.TimeOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.TimeOnly> IsBefore(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.TimeOnly> valueSource, System.TimeOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.TimeOnly> IsBeforeOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.TimeOnly> valueSource, System.TimeOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.TimeOnlyEqualToAssertionBuilderWrapper IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.TimeOnly> valueSource, System.TimeOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Source Collection for MatrixTests_One in TUnit Framework\nDESCRIPTION: Auto-generated code implementing ITestSource interface for collecting matrix-based tests. This file handles the MatrixTest_One method, generating test cases for all combinations of string, int, and boolean parameter values specified with MatrixAttribute.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MatrixTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tglobal::TUnit.Core.SourceRegistrar.Register(new MatrixTests());\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn Tests0(sessionId);\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.MatrixTests),\n\t\t\tName = \"MatrixTest_One\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.MatrixDataSourceAttribute()\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t{\n\t\t\t\t\tName = \"str\",\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.MatrixAttribute(\"A\", \"B\", \"C\", \"D\")\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t{\n\t\t\t\t\tName = \"i\",\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.MatrixAttribute(1, 2, 3)\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t\t\t{\n\t\t\t\t\tName = \"boolean\",\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.MatrixAttribute(true, false)\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.MatrixTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.MatrixTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"MatrixTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"MatrixTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"MatrixTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n```\n\nLANGUAGE: C#\nCODE:\n```\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.MatrixTests? classInstance = null;\nobject?[]? classInstanceArguments = null;\nvar methodArgDataGeneratorMetadata = new DataGeneratorMetadata\n{\n\tType = global::TUnit.Core.Enums.DataGeneratorType.TestParameters,\n\tTestBuilderContext = testBuilderContextAccessor,\n\tTestInformation = testInformation,\n\tMembersToGenerate = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"str\",\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.MatrixAttribute(\"A\", \"B\", \"C\", \"D\")\n\t\t\t],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t{\n\t\t\tName = \"i\",\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.MatrixAttribute(1, 2, 3)\n\t\t\t],\n\t\t},\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t{\n\t\t\tName = \"boolean\",\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.MatrixAttribute(true, false)\n\t\t\t],\n\t\t},\n\t],\n\tTestSessionId = sessionId,\n\tTestClassInstance = classInstance,\n\tClassInstanceArguments = classInstanceArguments,\n};\nvar methodDataAttribute = new global::TUnit.Core.MatrixDataSourceAttribute();\n\ntestBuilderContext.DataAttributes.Add(methodDataAttribute);\n\nvar methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\n```\n\nLANGUAGE: C#\nCODE:\n```\nforeach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\n{\n\ttestMethodDataIndex++;\n\tclassInstanceArguments = [];\n\n\tvar methodArgGeneratedData = methodArgGeneratedDataAccessor();\n\tstring methodArg = global::TUnit.Core.Helpers.CastHelper.Cast<string>(methodArgGeneratedData[0]);\n\tint methodArg1 = global::TUnit.Core.Helpers.CastHelper.Cast<int>(methodArgGeneratedData[1]);\n\tbool methodArg2 = global::TUnit.Core.Helpers.CastHelper.Cast<bool>(methodArgGeneratedData[2]);\n\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.MatrixTests>(() => \n\tnew global::TUnit.TestProject.MatrixTests()\n\t, sessionId, testBuilderContext);\n\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\tnodes.Add(new TestMetadata<global::TUnit.TestProject.MatrixTests>\n\t{\n\t\tTestId = $\"global::TUnit.Core.MatrixDataSourceAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.MatrixTests.MatrixTest_One(string,int,bool):0\",\n\t\tTestClassArguments = [],\n\t\tTestMethodArguments = [methodArg, methodArg1, methodArg2],\n\t\tTestClassProperties = [],\n\t\tCurrentRepeatAttempt = 0,\n\t\tRepeatLimit = 0,\n\t\tResettableClassFactory = resettableClassFactory,\n\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.MatrixTest_One(methodArg, methodArg1, methodArg2)),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 10,\n\t\tTestMethod = testInformation,\n\t\tTestBuilderContext = testBuilderContext,\n\t});\n\tresettableClassFactory = resettableClassFactoryDelegate();\n\ttestBuilderContext = new();\n\ttestBuilderContextAccessor.Current = testBuilderContext;\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.MatrixTests>\n\t{\n\t\tTestId = $\"global::TUnit.Core.MatrixDataSourceAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.MatrixTests.MatrixTest_One(string,int,bool):0\",\n\t\tMethodName = $\"MatrixTest_One\",\n\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"MatrixTests.MatrixTest_One failed to initialize\", exception),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 10,\n\t});\n}\nreturn nodes;\n```\n\n----------------------------------------\n\nTITLE: String Difference Analysis in TUnit\nDESCRIPTION: A class for analyzing differences between strings including finding the first point of mismatch and providing formatted output of the differences.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_162\n\nLANGUAGE: C#\nCODE:\n```\npublic class StringDifference\n{\n    public StringDifference(string? actualValue, string? expectedValue, System.Collections.Generic.IEqualityComparer<string>? comparer = null) { }\n    public int IgnoreWhiteSpace { get; set; }\n    public int? OverriddenIndex { get; set; }\n    public int IndexOfFirstMismatch() { }\n    public override string ToString() { }\n    public string ToString(string prefix) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Test Source Generator Class Definition - Part 3\nDESCRIPTION: Final partial class implementation for CustomDisplayNameTests that handles test collection and initialization for SameClassConstantTest. Includes display name attribute handling.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/CustomDisplayNameTests.Test.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class CustomDisplayNameTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new CustomDisplayNameTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ImmutableArray Equivalence Assertion Extensions in C#\nDESCRIPTION: Extension methods for asserting that ImmutableArray instances are not equivalent to expected collections. These methods provide different overloads for comparing with custom equality comparers and collection ordering specifications.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_75\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsNotEquivalentTo<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"comparer\")] string doNotPopulateThisValue2 = null) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsNotEquivalentTo<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"collectionOrdering\")] string doNotPopulateThisValue2 = null) { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsNotEquivalentTo<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"collectionOrdering\")] string doNotPopulateThisValue2 = null) { }\n```\n\n----------------------------------------\n\nTITLE: Initializing and Executing Test3 Method in C# with TUnit Framework\nDESCRIPTION: This snippet initializes and executes the Test3 method of the DerivedTest class. It creates test metadata, handles arguments, and manages test execution using a resettable class factory. The code also includes error handling for test initialization failures.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1889.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.Bugs._1889.DerivedTest? classInstance = null;\nobject?[]? classInstanceArguments = null;\nclassInstanceArguments = [];\n\nbool methodArg = false;\n\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._1889.DerivedTest>(() => \nnew global::TUnit.TestProject.Bugs._1889.DerivedTest()\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._1889.DerivedTest>\n{\n    TestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.Bugs._1889.DerivedTest.Test3(bool):0\",\n    TestClassArguments = [],\n    TestMethodArguments = [methodArg],\n    TestClassProperties = [],\n    CurrentRepeatAttempt = 0,\n    RepeatLimit = 0,\n    ResettableClassFactory = resettableClassFactory,\n    TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Test3(methodArg)),\n    TestLineNumber = 18,\n    TestMethod = testInformation,\n    TestBuilderContext = testBuilderContext,\n});\nresettableClassFactory = resettableClassFactoryDelegate();\ntestBuilderContext = new();\ntestBuilderContextAccessor.Current = testBuilderContext;\n```\n\n----------------------------------------\n\nTITLE: Implementing Enum Assertion Extensions in C#\nDESCRIPTION: Defines extension methods for enum-specific assertions, providing a fluent interface for various enum checks.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\npublic static class EnumHasExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TEnum> DoesNotHaveFlag<TEnum>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TEnum> valueSource, TEnum expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string? doNotPopulateThisValue1 = null)\n        where TEnum : System.Enum { }\n    \n    // Similar methods: DoesNotHaveSameNameAs, DoesNotHaveSameValueAs, HasFlag, HasSameNameAs, HasSameValueAs, IsDefined, IsNotDefined\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Test Hooks for AssemblyBase2 in TUnit\nDESCRIPTION: Auto-generated class implementing ITestHookSource to register test-level hooks for AssemblyBase2. It initializes and registers hooks with the SourceRegistrar and provides a method structure for collecting various types of test hooks.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyAfterTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_AssemblyBase2 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_AssemblyBase2();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\n```\n\n----------------------------------------\n\nTITLE: Combining Assertions Using Assert.That in TUnit (C#)\nDESCRIPTION: This snippet illustrates mixing `.And` and `.Or` methods within `Assert.That` to test a string value for the presence of specific characters. The code may not behave as intuitively expected, leading to logic such as `C && (D || A) && B` instead of the intended `(C && D) || (A && B)`. Dependencies include the TUnit test library. `value` is the input string. This approach may introduce logical errors and is generally discouraged for complex conditions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-assertions/assertion-groups.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar value = \"CD\";\n\nawait Assert.That(value)\n    .Contains('C').And.Contains('D')\n    .Or\n    .Contains('A').And.Contains('B');\n```\n\n----------------------------------------\n\nTITLE: Registering and Collecting Class Hooks for Base3 in C#\nDESCRIPTION: Auto-generated partial class `Hooks_Base3` implementing `IClassHookSource` for TUnit. It registers itself using a `ModuleInitializer` and `SourceRegistrar.RegisterClassHookSource`, and provides methods to collect class-level hooks (`BeforeEveryClass`, `AfterEveryClass`, `BeforeClass`, `AfterClass`). The `CollectAfterClassHooks` method specifically returns a `StaticHookMethod` for the static `AfterAll3` method in `TUnit.TestProject.AfterTests.Base3`, designed to run once after all tests in the class have finished.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterAllTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_Base3 : global::TUnit.Core.Interfaces.SourceGenerator.IClassHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_Base3();\n\t\tSourceRegistrar.RegisterClassHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterEveryClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectAfterClassHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.AfterClassHookMethod\n\t\t\t{\n\t\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.Base3),\n\t\t\t\t\tName = \"AfterAll3\",\n\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.Base3\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.Base3),\n\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AfterAllTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"AfterAllTests\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tName = \"Base3\",\n\t\t\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t}),\n},\n\t\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.Base3.AfterAll3()),\n\t\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\t\tOrder = 0,\n\t\t\t\t\tFilePath = @\"\",\n\t\t\t\t\tLineNumber = 35,\n\t\t\t\t\tMethodAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t\t],\n\t\t\t\t\tClassAttributes = [],\n\t\t\t\t\tAssemblyAttributes = [],\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing ITestSource for Inherited_ConcreteClass2 in C#\nDESCRIPTION: This snippet defines a partial class Inherited_ConcreteClass2 that implements ITestSource interface. It includes methods for initialization and test collection, focusing on the 'AssertClassName' method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ConcreteClassTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Inherited_ConcreteClass2 : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new Inherited_ConcreteClass2());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\t// ... (implementation details)\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Discovery Hook for Global IDs in TUnit (C#)\nDESCRIPTION: Defines an attribute `AssignTestIdentifiersAttribute` that implements `ITestDiscoveryEventReceiver`. It hooks into TUnit's test discovery phase via the `OnTestDiscovery` method to assign a unique, incrementing integer ID to each discovered test. The ID is stored in the test's `TestContext.ObjectBag` using a specific key (`TestIdObjectBagKey`) for later retrieval.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/examples/instrumenting_global_test_ids.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass AssignTestIdentifiersAttribute : Attribute, ITestDiscoveryEventReceiver\n{\n    public const string TestIdObjectBagKey = \"\\u0001TestId\";\n\n    public static int TestId { get; private set; } = 0;\n\n    public void OnTestDiscovery(DiscoveredTestContext discoveredTestContext)\n    {\n        discoveredTestContext.TestContext.ObjectBag[TestIdObjectBagKey] = TestId++;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring IOrAssertionBuilder Interface in C#\nDESCRIPTION: This interface represents an 'or' assertion builder. It is an empty interface used for type identification.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_59\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IOrAssertionBuilder { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Assembly Hook Collection in C#\nDESCRIPTION: Partial class implementation for collecting assembly-level hooks with test context and hook registration. Includes methods for handling before/after test scenarios and initialization.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyBeforeTests.Test.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_AssemblySetupTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n    [global::System.Runtime.CompilerServices.ModuleInitializer]\n    public static void Initialise()\n    {\n        var instance = new Hooks_AssemblySetupTests();\n        SourceRegistrar.RegisterTestHookSource(instance);\n    }\n    public global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n    {\n        return\n        [\n        ];\n    }\n    public global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n    {\n        return\n        [\n        ];\n    }\n    public global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n    {\n        return\n        [\n            new global::TUnit.Core.Hooks.InstanceHookMethod\n            {\n                ClassType = typeof(global::TUnit.TestProject.BeforeTests.AssemblySetupTests),\n                MethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n                {\n                    Type = typeof(global::TUnit.TestProject.BeforeTests.AssemblySetupTests),\n                    Name = \"Setup\",\n                    GenericTypeCount = 0,\n                    ReturnType = typeof(global::System.Threading.Tasks.Task),\n                    Attributes = [\n                        new global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n                    ],\n                    Parameters = [],\n                    Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.AssemblySetupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n                    {\n                        Type = typeof(global::TUnit.TestProject.BeforeTests.AssemblySetupTests),\n                        Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AssemblyBeforeTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n                        {\n                            Name = \"AssemblyBeforeTests\",\n                            Attributes = [],\n                        }),\n                        Name = \"AssemblySetupTests\",\n                        Namespace = \"TUnit.TestProject.BeforeTests\",\n                        Attributes = [],\n                        Parameters = [],\n                        Properties = [],\n                    }),\n                },\n                Body = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.BeforeTests.AssemblySetupTests)classInstance).Setup()),\n                HookExecutor = DefaultExecutor.Instance,\n                Order = 0\n            }\n        ];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTimeOffsetEqualToAssertionBuilderWrapper in C#\nDESCRIPTION: Wrapper for DateTimeOffset equality assertions that supports specifying a tolerance time span within which two DateTimeOffsets can be considered equal.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_86\n\nLANGUAGE: C#\nCODE:\n```\n    public class DateTimeOffsetEqualToAssertionBuilderWrapper : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTimeOffset>\n    {\n        public TUnit.Assertions.AssertionBuilders.Wrappers.DateTimeOffsetEqualToAssertionBuilderWrapper Within(System.TimeSpan tolerance, [System.Runtime.CompilerServices.CallerArgumentExpression(\"tolerance\")] string doNotPopulateThis = \"\") { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining Assertion Chain Type Enum in TUnit (C#)\nDESCRIPTION: This enum defines the logical operators used to chain multiple assertion conditions together within the TUnit framework, specifically `And` and `Or`. `None` likely indicates no chaining or the start of a chain.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_40\n\nLANGUAGE: csharp\nCODE:\n```\n    public enum ChainType\n    {\n        None = 0,\n        And = 1,\n        Or = 2,\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing GenericNotEqualToAssertionBuilderWrapper in C#\nDESCRIPTION: Generic wrapper for inequality assertions that can work with any type without additional configuration options.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_89\n\nLANGUAGE: C#\nCODE:\n```\n    public class GenericNotEqualToAssertionBuilderWrapper<TActual> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> { }\n```\n\n----------------------------------------\n\nTITLE: Initializing and Registering TUnit Test Source in C#\nDESCRIPTION: Module initializer that registers the test source implementation with the TUnit framework. This ensures the source-generated tests are discovered and executed by the test runner.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1538.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tglobal::TUnit.Core.SourceRegistrar.Register(new Tests());\n}\n```\n\n----------------------------------------\n\nTITLE: Building Test Metadata for String Arguments - TUnit Source Generator - C#\nDESCRIPTION: Constructs a TestMetadata instance for a generic unit test taking string parameters, following TUnit's source-generation conventions. The code initializes metadata for method and class, prepares a test context, sets string arguments, and adds the resulting test node. Required: Definitions of TUnit types and context classes. Parameters: input arguments, session id. Outputs: test node list with configured argument types.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests2136.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\\nglobal::TUnit.TestProject.Bugs._2136.Tests? classInstance = null;\\nobject?[]? classInstanceArguments = null;\\nclassInstanceArguments = [];\\n\\nglobal::System.String methodArg = \"hello\";\\nstring methodArg1 = \"hello\";\\n\\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._2136.Tests>(() => \\nnew global::TUnit.TestProject.Bugs._2136.Tests()\\n, sessionId, testBuilderContext);\\nvar resettableClassFactory = resettableClassFactoryDelegate();\\n\\nnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._2136.Tests>\\n{\\n    TestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS3:TUnit.TestProject.Bugs._2136.Tests.GenericArgumentsTest(T,string):0\",\\n    TestClassArguments = [],\\n    TestMethodArguments = [methodArg, methodArg1],\\n    TestClassProperties = [],\\n    CurrentRepeatAttempt = 0,\\n    RepeatLimit = 0,\\n    ResettableClassFactory = resettableClassFactory,\\n    TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.GenericArgumentsTest(methodArg, methodArg1)),\\n    TestFilePath = @\"\",\\n    TestLineNumber = 8,\\n    TestMethod = testInformation,\\n    TestBuilderContext = testBuilderContext,\\n});\\nresettableClassFactory = resettableClassFactoryDelegate();\\ntestBuilderContext = new();\\ntestBuilderContextAccessor.Current = testBuilderContext;\n```\n\n----------------------------------------\n\nTITLE: Implementing JSON Extension Methods in C#\nDESCRIPTION: Provides extension methods for converting various TUnit objects to their JSON model counterparts.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic static class JsonExtensions\n{\n    public static TUnit.Engine.Json.ExceptionJson ToJsonModel(this System.Exception exception) { }\n    public static TUnit.Engine.Json.TestAssemblyJson ToJsonModel(this TUnit.Core.AssemblyHookContext context) { }\n    public static TUnit.Engine.Json.TestClassJson ToJsonModel(this TUnit.Core.ClassHookContext context) { }\n    public static TUnit.Engine.Json.TestJson ToJsonModel(this TUnit.Core.TestContext context) { }\n    public static TUnit.Engine.Json.TestResultJson ToJsonModel(this TUnit.Core.TestResult result) { }\n    public static TUnit.Engine.Json.TestSessionJson ToJsonModel(this TUnit.Core.TestSessionContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ITestHookSource for GlobalSetUpTests with CancellationToken in C#\nDESCRIPTION: This code snippet defines a partial class that implements ITestHookSource interface for GlobalSetUpTests. It includes methods for collecting before and after test hooks, with the BeforeAllSetUp method now accepting a CancellationToken parameter.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticBeforeEachTests.Test.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_GlobalSetUpTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_GlobalSetUpTests();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\tnew global::TUnit.Core.Hooks.BeforeTestHookMethod\n\t\t\t{ \n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.GlobalSetUpTests),\n\t\t\t\tName = \"BeforeAllSetUp\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeEveryAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"context\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.GlobalSetUpTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.GlobalSetUpTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"GlobalStaticBeforeEachTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"GlobalStaticBeforeEachTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"GlobalSetUpTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n},\n\t\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.BeforeTests.GlobalSetUpTests.BeforeAllSetUp(context, cancellationToken)),\n\t\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\t\tOrder = 0,\n\t\t\t\tFilePath = @\"\",\n\t\t\t\tLineNumber = 56,\n\t\t\t\tMethodAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeEveryAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t\t],\n\t\t\t\tClassAttributes = [],\n\t\t\t\tAssemblyAttributes = [],\n\t\t\t},\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Test Initialization Failures in TUnit\nDESCRIPTION: Exception handling code that creates a FailedTestMetadata object when test initialization fails. This ensures test failures are properly reported rather than causing the test runner to crash.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.Typed.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.DataSourceGeneratorTests>\n\t{\n\t\tTestId = $\"global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<int, string, bool>:{classDataIndex}:CL-GAC0:global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.DataSourceGeneratorTests(int,string,bool).GeneratedData_Method3(int,string,bool):0\",\n\t\tMethodName = $\"GeneratedData_Method3\",\n\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"DataSourceGeneratorTests.GeneratedData_Method3 failed to initialize\", exception),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 25,\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Generating TestMetadata for ConcreteClass1.AssertClassName in C#\nDESCRIPTION: This C# method generates a list of `TestMetadata` objects for the `AssertClassName` test method within the `TUnit.TestProject.AbstractTests.ConcreteClass1` class. It initializes the test context (`TestBuilderContext`), sets up lazy, resettable class instantiation using `ResettableLazy`, and constructs `TestMetadata` with test identifiers, arguments, factory delegates for class and method execution, and source code location hints. It includes a try-catch block to handle potential exceptions during initialization, creating `FailedTestMetadata` if an error occurs.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ConcreteClassTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n\t\t\t\t\tNamespace = \"TUnit.TestProject.AbstractTests\",\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.InheritsTestsAttribute()\n\t\t\t\t\t],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.AbstractTests.ConcreteClass1? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.AbstractTests.ConcreteClass1>(() => \n\t\t\t\tnew global::TUnit.TestProject.AbstractTests.ConcreteClass1()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.AbstractTests.ConcreteClass1>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"TUnit.TestProject.AbstractTests.ConcreteClass1.AssertClassName:0\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.AssertClassName()),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 8,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.AbstractTests.ConcreteClass1>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"TUnit.TestProject.AbstractTests.ConcreteClass1.AssertClassName:0\",\n\t\t\t\t\tMethodName = $\"AssertClassName\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ConcreteClass1.AssertClassName failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 8,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n\t}\n\n]\n```\n\n----------------------------------------\n\nTITLE: Failing Test Conditions in C#\nDESCRIPTION: The 'Fail' class provides methods for triggering failures within test cases, either unconditionally or based on a specified condition. These methods support the simulation or validation of conditions leading to failure within unit tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic static class Fail { [System.Diagnostics.CodeAnalysis.DoesNotReturn] public static void Test(string reason) { } public static void Unless([System.Diagnostics.CodeAnalysis.DoesNotReturnIf(false)] bool condition, string reason) { } public static void When([System.Diagnostics.CodeAnalysis.DoesNotReturnIf(true)] bool condition, string reason) { } }\n```\n\n----------------------------------------\n\nTITLE: Adding the TUnit Package to a .NET Project - PowerShell\nDESCRIPTION: These commands add the TUnit testing library to an existing .NET project by navigating into the project directory and installing the package (optionally as a prerelease version). Dependencies include .NET SDK and network access for package retrieval. Parameters used: the project path and the package name (TUnit). The output is an updated project with TUnit referenced, ready for test development.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/installing.md#2025-04-22_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\ncd YourTestProjectNameHere\ndotnet add package TUnit --prerelease\n```\n\n----------------------------------------\n\nTITLE: Initializing and Registering ClassTupleDataSourceDrivenTests in C#\nDESCRIPTION: This snippet defines a partial class ClassTupleDataSourceDrivenTests that implements ITestSource. It contains a module initializer to register the class with TUnit's SourceRegistrar.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class ClassTupleDataSourceDrivenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new ClassTupleDataSourceDrivenTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\t..Tests0(sessionId),\n\t\t\t..Tests1(sessionId),\n\t\t\t..Tests2(sessionId),\n\t\t\t..Tests3(sessionId),\n\t\t];\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: AsyncConvert Static Methods in C#\nDESCRIPTION: A utility class that provides methods for converting different types of synchronous and asynchronous methods to ValueTask. Handles Action, Func<Task>, and Func<ValueTask> conversions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class AsyncConvert\n{\n    public static System.Threading.Tasks.ValueTask Convert(System.Action action) { }\n    public static System.Threading.Tasks.ValueTask Convert(System.Func<System.Threading.Tasks.Task> action) { }\n    public static System.Threading.Tasks.ValueTask Convert(System.Func<System.Threading.Tasks.ValueTask> action) { }\n    public static System.Threading.Tasks.ValueTask ConvertObject(object? invoke) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating TUnit Test Metadata with Multiple Data Sources - C#\nDESCRIPTION: This snippet constructs TUnit parameterized test metadata, configuring the test method context, method arguments, and associated data sources. It sets up the test execution environment using classes like TestBuilderContext and ResettableLazy, assigns test/class arguments, and defines how to instantiate and invoke target test methods. If initialization fails, it captures the exception as a FailedTestMetadata entry. Dependencies include TUnit.Core and specific user-defined classes such as DataSourceClassCombinedWithDataSourceMethod and CommonTestData. Key parameters are the sessionId, classArg, and methodArg, which define the test instance and method invocation. Inputs consist of test metadata and execution context; outputs are lists of TestMetadata or FailedTestMetadata as appropriate. Limitations: Expects proper type definitions and infrastructure for TUnit test contexts, and relies on correct data source configuration.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceClassCombinedWithDataSourceMethodTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSourceClassCombinedWithDataSourceMethodTest(methodArg)),\nTestFilePath = @\"\",\nTestLineNumber = 10,\nTestMethod = testInformation,\nTestBuilderContext = testBuilderContext,\n});\nresettableClassFactory = resettableClassFactoryDelegate();\ntestBuilderContext = new();\ntestBuilderContextAccessor.Current = testBuilderContext;\n}\ncatch (global::System.Exception exception)\n{\nnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod>\n{\nTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS1:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod(int).DataSourceClassCombinedWithDataSourceMethodTest(int):0\",\nMethodName = $\"DataSourceClassCombinedWithDataSourceMethodTest\",\nException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"DataSourceClassCombinedWithDataSourceMethod.DataSourceClassCombinedWithDataSourceMethodTest failed to initialize\", exception),\nTestFilePath = @\"\",\nTestLineNumber = 10,\n});\n}\nreturn nodes;\n```\n\nLANGUAGE: c#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests2(string sessionId)\n{\nglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\nvar classDataIndex = 0;\nvar testMethodDataIndex = 0;\ntry\n{\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\nType = typeof(global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod),\nName = \"DataSourceClassCombinedWithDataSourceMethodTest\",\nGenericTypeCount = 0,\nReturnType = typeof(void),\nAttributes = \n[\nnew global::TUnit.Core.TestAttribute(),\nnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"One\"),\nnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Two\"),\nnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Three\")\n],\nParameters = \n[\nnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n{\nName = \"i\",\nAttributes = [],\n},\n],\nClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n{\nType = typeof(global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod),\nAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataSourceClassCombinedWithDataSourceMethodTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n{\nName = \"DataSourceClassCombinedWithDataSourceMethodTests\",\nAttributes = [],\n}),\nName = \"DataSourceClassCombinedWithDataSourceMethod\",\nNamespace = \"TUnit.TestProject\",\nAttributes = \n[\nnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"One\"),\nnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Two\"),\nnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Three\")\n],\nParameters = \n[\nnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n{\nName = \"i\",\nAttributes = [],\n},\n],\nProperties = [],\n}),\n};\n\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod? classInstance = null;\nobject?[]? classInstanceArguments = null;\nint classArg = global::TUnit.TestProject.CommonTestData.Three();\nclassInstanceArguments = [classArg];\n\nint methodArg = global::TUnit.TestProject.CommonTestData.One();\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod>(() => \nnew global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod(classArg)\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod>\n{\nTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS2:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod(int).DataSourceClassCombinedWithDataSourceMethodTest(int):0\",\nTestClassArguments = [classArg],\nTestMethodArguments = [methodArg],\nTestClassProperties = [],\nCurrentRepeatAttempt = 0,\nRepeatLimit = 0,\nResettableClassFactory = resettableClassFactory,\nTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSourceClassCombinedWithDataSourceMethodTest(methodArg)),\nTestFilePath = @\"\",\nTestLineNumber = 10,\nTestMethod = testInformation,\nTestBuilderContext = testBuilderContext,\n});\nresettableClassFactory = resettableClassFactoryDelegate();\ntestBuilderContext = new();\ntestBuilderContextAccessor.Current = testBuilderContext;\n}\ncatch (global::System.Exception exception)\n{\nnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod>\n{\nTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS2:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod(int).DataSourceClassCombinedWithDataSourceMethodTest(int):0\",\nMethodName = $\"DataSourceClassCombinedWithDataSourceMethodTest\",\nException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"DataSourceClassCombinedWithDataSourceMethod.DataSourceClassCombinedWithDataSourceMethodTest failed to initialize\", exception),\nTestFilePath = @\"\",\nTestLineNumber = 10,\n});\n}\nreturn nodes;\n}\n```\n\nLANGUAGE: c#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests3(string sessionId)\n{\nglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\nvar classDataIndex = 0;\nvar testMethodDataIndex = 0;\ntry\n{\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\nType = typeof(global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod),\nName = \"DataSourceClassCombinedWithDataSourceMethodTest\",\nGenericTypeCount = 0,\nReturnType = typeof(void),\nAttributes = \n[\nnew global::TUnit.Core.TestAttribute(),\nnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"One\"),\nnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Two\"),\nnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Three\")\n],\nParameters = \n[\nnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n{\nName = \"i\",\nAttributes = [],\n},\n],\nClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n{\nType = typeof(global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod),\nAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataSourceClassCombinedWithDataSourceMethodTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n{\nName = \"DataSourceClassCombinedWithDataSourceMethodTests\",\nAttributes = [],\n}),\nName = \"DataSourceClassCombinedWithDataSourceMethod\",\nNamespace = \"TUnit.TestProject\",\nAttributes = \n[\nnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"One\"),\nnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Two\"),\nnew global::TUnit.Core.MethodDataSourceAttribute(typeof(global::TUnit.TestProject.CommonTestData), \"Three\")\n],\nParameters = \n[\nnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n{\nName = \"i\",\nAttributes = [],\n},\n],\nProperties = [],\n}),\n};\n\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod? classInstance = null;\nobject?[]? classInstanceArguments = null;\nint classArg = global::TUnit.TestProject.CommonTestData.One();\nclassInstanceArguments = [classArg];\n\nint methodArg = global::TUnit.TestProject.CommonTestData.Two();\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod>(() => \nnew global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod(classArg)\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Class Properties and Data Sources in C#\nDESCRIPTION: Sets up test class properties including data source attributes, method information, and test context. Includes configuration for tuple methods and named tuple methods with associated attributes.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=TupleMethod_testMethodName=TupleMethod.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nTestClassProperties = [propertyArg, propertyArg1, propertyArg2, propertyArg3],\nCurrentRepeatAttempt = 0,\nRepeatLimit = 0,\nMethodInfo = methodInfo,\nResettableClassFactory = resettableClassFactory,\nTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_TupleMethod(methodArg, methodArg1, methodArg2)),\nTestFilePath = @\"\",\nTestLineNumber = 24,\nTestAttributes = [ new global::TUnit.Core.TestAttribute()\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n{\n    \n} ],\nClassAttributes = [ new global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\")\n{\n    \n}, new global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n{\n    \n} ],\nAssemblyAttributes = [  ],\nDataAttributes = [  ],\nTestBuilderContext = testBuilderContext\n```\n\n----------------------------------------\n\nTITLE: Implementing STA Thread Executor in C#\nDESCRIPTION: Defines a thread executor that runs tests on a Single-Threaded Apartment (STA) thread. This is necessary for tests that interact with COM components or UI elements that require STA thread models.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\npublic class STAThreadExecutor : TUnit.Core.DedicatedThreadExecutor\n{\n    public STAThreadExecutor() { }\n    protected override void ConfigureThread(System.Threading.Thread thread) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTime Assertions in C#\nDESCRIPTION: Extension methods for asserting DateTime values, including checks for being after, before, equal to, and their inclusive variants.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_111\n\nLANGUAGE: C#\nCODE:\n```\npublic static class DateTimeIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTime> IsAfter(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTime> valueSource, System.DateTime expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTime> IsAfterOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTime> valueSource, System.DateTime expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTime> IsBefore(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTime> valueSource, System.DateTime expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTime> IsBeforeOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTime> valueSource, System.DateTime expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.DateTimeEqualToAssertionBuilderWrapper IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTime> valueSource, System.DateTime expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Double-Parameterized Tests - TUnit Source Generator - C#\nDESCRIPTION: Auto-generates the implementation for registering, discovering, and initializing TUnit tests with a double argument. This code sets up all relevant attributes, parameters, and test metadata for the method named 'Double' and hooks the generator into the TUnit test infrastructure. TUnit.Core and its source generation facilities are required. Inputs include a session ID for the current test run, and outputs are test metadata entries representing parameterized test cases. Should be considered internal and not user-maintained.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/NumberArgumentTests.TestDE.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\\n#pragma warning disable\\nusing global::System.Linq;\\nusing global::System.Reflection;\\nusing global::TUnit.Core;\\nusing global::TUnit.Core.Extensions;\\n\\nnamespace TUnit.SourceGenerated;\\n\\n[global::System.Diagnostics.StackTraceHidden]\\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\\nfile partial class NumberArgumentTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\\n{\\n\\t[global::System.Runtime.CompilerServices.ModuleInitializer]\\n\\tpublic static void Initialise()\\n\\t{\\n\\t\\tglobal::TUnit.Core.SourceRegistrar.Register(new NumberArgumentTests());\\n\\t}\\n\\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\\n\\t{\\n\\t\\treturn Tests0(sessionId);\\n\\t}\\n\\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\\n\\t{\\n\\t\\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\\n\\t\\tvar classDataIndex = 0;\\n\\t\\tvar testMethodDataIndex = 0;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\\n\\t\\t\\t{\\n\\t\\t\\t\\tType = typeof(global::TUnit.TestProject.NumberArgumentTests),\\n\\t\\t\\t\\tName = \"Double\",\\n\\t\\t\\t\\tGenericTypeCount = 0,\\n\\t\\t\\t\\tReturnType = typeof(void),\\n\\t\\t\\t\\tAttributes = \\n\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\tnew global::TUnit.Core.TestAttribute(),\\n\\t\\t\\t\\t\\tnew global::TUnit.Core.ArgumentsAttribute(1.1)\\n\\t\\t\\t\\t],\\n\\t\\t\\t\\tParameters = \\n\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\tnew global::TUnit.Core.SourceGeneratedParameterInformation<double>\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tName = \"d\",\\n\\t\\t\\t\\t\\t\\tAttributes = [],\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t],\\n\\t\\t\\t\\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.NumberArgumentTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tType = typeof(global::TUnit.TestProject.NumberArgumentTests),\\n\\t\\t\\t\\t\\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"NumberArgumentTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tName = \"NumberArgumentTests\",\\n\\t\\t\\t\\t\\t\\tAttributes = [],\\n\\t\\t\\t\\t\\t}),\\n\\t\\t\\t\\t\\tName = \"NumberArgumentTests\",\\n\\t\\t\\t\\t\\tNamespace = \"TUnit.TestProject\",\\n\\t\\t\\t\\t\\tAttributes = [],\\n\\t\\t\\t\\t\\tParameters = [],\\n\\t\\t\\t\\t\\tProperties = [],\\n\\t\\t\\t\\t}),\\n};\\n\\n\\t\\t\\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\\n\\t\\t\\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\\n\\t\\t\\tglobal::TUnit.TestProject.NumberArgumentTests? classInstance = null;\\n\\t\\t\\tobject?[]? classInstanceArguments = null;\\n\\t\\t\\tclassInstanceArguments = [];\\n\\n\\t\\t\\tdouble methodArg = 1.1;\\n\\n\\t\\t\\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.NumberArgumentTests>(() => \\n\\t\\t\\tnew global::TUnit.TestProject.NumberArgumentTests()\\n\\t\\t\\t, sessionId, testBuilderContext);\\n\\t\\t\\tvar resettableClassFactory = resettableClassFactoryDelegate();\\n\\n\\t\\t\\tnodes.Add(new TestMetadata<global::TUnit.TestProject.NumberArgumentTests>\\n\\t\\t\\t{\\n\\t\\t\\t\\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NumberArgumentTests.Double(double):0\",\\n\\t\\t\\t\\tTestClassArguments = [],\\n\\t\\t\\t\\tTestMethodArguments = [methodArg],\\n\\t\\t\\t\\tTestClassProperties = [],\\n\\t\\t\\t\\tCurrentRepeatAttempt = 0,\\n\\t\\t\\t\\tRepeatLimit = 0,\\n\\t\\t\\t\\tResettableClassFactory = resettableClassFactory,\\n\\t\\t\\t\\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Double(methodArg)),\\n\\t\\t\\t\\tTestFilePath = @\"\",\\n\\t\\t\\t\\tTestLineNumber = 12,\\n\\t\\t\\t\\tTestMethod = testInformation,\\n\\t\\t\\t\\tTestBuilderContext = testBuilderContext,\\n\\t\\t\\t});\\n\\t\\t\\tresettableClassFactory = resettableClassFactoryDelegate();\\n\\t\\t\\ttestBuilderContext = new();\\n\\t\\t\\ttestBuilderContextAccessor.Current = testBuilderContext;\\n\\t\\t}\\n\\t\\tcatch (global::System.Exception exception)\\n\\t\\t{\\n\\t\\t\\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.NumberArgumentTests>\\n\\t\\t\\t{\\n\\t\\t\\t\\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NumberArgumentTests.Double(double):0\",\\n\\t\\t\\t\\tMethodName = $\"Double\",\\n\\t\\t\\t\\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"NumberArgumentTests.Double failed to initialize\", exception),\\n\\t\\t\\t\\tTestFilePath = @\"\",\\n\\t\\t\\t\\tTestLineNumber = 12,\\n\\t\\t\\t});\\n\\t\\t}\\n\\t\\treturn nodes;\\n\\t}\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Chaining Assertions with And in TUnit (C#)\nDESCRIPTION: This snippet demonstrates how to use TUnit's fluent assertion chaining in a C# test. By leveraging the 'And' property between assertions, all conditions must independently pass for the test to succeed. The example assumes that TUnit and its dependencies are installed and available, and that 'Assert.That' returns a chainable assertion object. The method 'Add' is called with two integers, and the result is asserted to be non-null, positive, and equal to 3. This test is asynchronous, requiring an async-compatible test framework such as NUnit with TUnit extensions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-assertions/and-conditions.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n    [Test]\n    public async Task MyTest()\n    {\n        var result = Add(1, 2);\n        \n        await Assert.That(result)\n            .IsNotNull()\n            .And.IsPositive()\n            .And.IsEqualTo(3);\n    }\n```\n\n----------------------------------------\n\nTITLE: Expression Helper Methods in TUnit\nDESCRIPTION: Helper methods for working with expressions, particularly for extracting names from expression trees.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_160\n\nLANGUAGE: C#\nCODE:\n```\npublic static class ExpressionHelpers\n{\n    public static string GetName<T1, T2>(System.Linq.Expressions.Expression<System.Func<T1, T2>> exp) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing TUnit Test Source Registration\nDESCRIPTION: Static initializer method that registers the test source with TUnit's source registrar. This is called when the module loads.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ArgumentWithImplicitConverterTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tglobal::TUnit.Core.SourceRegistrar.Register(new ArgumentWithImplicitConverterTests());\n}\n```\n\n----------------------------------------\n\nTITLE: Evaluating Test Outcome Status with TestContext in TUnit (C#)\nDESCRIPTION: This snippet evaluates whether the current test's Result property indicates a failed status using the TestContext object in C#. It shows how to safely check if TestContext.Current.Result.Status equals Status.Failed, which is useful for conditionally executing cleanup or diagnostic code (e.g., taking a screenshot) in AfterEachTest hooks. Assumes usage of TUnit and that TestContext.Result is nullable and only available after test execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/test-context.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nif (TestContext.Current?.Result?.Status == Status.Failed)\n{\n    // Take a screenshot?\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Comparers for Value Assertions\nDESCRIPTION: Method to set a custom comparison function for value assertions, allowing for specialized comparison logic beyond the default equality comparison.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic void WithComparer(System.Func<TActual?, TUnit.Assertions.AssertionDecision> comparer) { }\n```\n\n----------------------------------------\n\nTITLE: Registering and Collecting TUnit Assembly Hooks for AssemblyCleanupTests in C#\nDESCRIPTION: This auto-generated C# partial class `Hooks_AssemblyCleanupTests` implements `IAssemblyHookSource` to manage assembly-level hooks, presumably for a class named `AssemblyCleanupTests`. It registers itself using `[ModuleInitializer]` and `SourceRegistrar`. The provided snippet shows methods for collecting various assembly hooks (`CollectBeforeEveryAssemblyHooks`, `CollectAfterEveryAssemblyHooks`, `CollectBeforeAssemblyHooks`), all of which currently return empty lists, indicating no such hooks were found or generated for this class.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyAfterTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::System.Runtime.CompilerServices;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Hooks;\nusing global::TUnit.Core.Interfaces;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_AssemblyCleanupTests : global::TUnit.Core.Interfaces.SourceGenerator.IAssemblyHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_AssemblyCleanupTests();\n\t\tSourceRegistrar.RegisterAssemblyHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectBeforeEveryAssemblyHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectAfterEveryAssemblyHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.AssemblyHookContext>> CollectBeforeAssemblyHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Defining Assertion-related Enums in C#\nDESCRIPTION: This snippet defines enums used in assertions, including CollectionOrdering, EquivalencyKind, and Order. These enums are used to specify behavior in various assertion conditions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_123\n\nLANGUAGE: C#\nCODE:\n```\npublic enum CollectionOrdering\n{\n    Matching = 0,\n    Any = 1,\n}\n\npublic enum EquivalencyKind\n{\n    Full = 0,\n    Partial = 1,\n}\n\npublic enum Order\n{\n    Ascending = 0,\n    Descending = 1,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AssemblyLoader_Guid Static Class in C#\nDESCRIPTION: This class contains a static Initialize method, likely used for assembly loading purposes.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic static class AssemblyLoader_Guid\n{\n    public static void Initialize() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ITestHookSource for GlobalBase3 Tests in C#\nDESCRIPTION: This code snippet defines a partial class that implements ITestHookSource interface. It collects and returns before and after test hooks, with a focus on the BeforeAll3 method from GlobalBase3 class.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticBeforeEachTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.BeforeTestHookMethod\n\t\t{ \n\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.GlobalBase3),\n\t\t\tName = \"BeforeAll3\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.BeforeEveryAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext>\n\t\t\t\t{\n\t\t\t\t\tName = \"context\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.GlobalBase3\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.GlobalBase3),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"GlobalStaticBeforeEachTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"GlobalStaticBeforeEachTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"GlobalBase3\",\n\t\t\t\tNamespace = \"TUnit.TestProject.BeforeTests\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n},\n\t\t\tBody = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.BeforeTests.GlobalBase3.BeforeAll3(context)),\n\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\tOrder = 0,\n\t\t\tFilePath = @\"\",\n\t\t\tLineNumber = 35,\n\t\t\tMethodAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.BeforeEveryAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t],\n\t\t\tClassAttributes = [],\n\t\t\tAssemblyAttributes = [],\n\t\t},\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Source-Generated Method Information for Tests in C#\nDESCRIPTION: This snippet creates a SourceGeneratedMethodInformation object containing details about the test method, including its attributes, parameters, and class information.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassAndMethodArgumentsTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.ClassAndMethodArgumentsTests),\n\tName = \"IgnoreParameters\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute(),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(\"3\"),\n\t\tnew global::TUnit.Core.ArgumentsAttribute(\"4\")\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"arg2\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.ClassAndMethodArgumentsTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t{\n\t\t// Class information details\n\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing TestContextExtensions in C#\nDESCRIPTION: Provides an extension method for re-registering a test with new arguments, marked as experimental.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic static class TestContextExtensions\n{\n    [System.Diagnostics.CodeAnalysis.Experimental(\"WIP\")]\n    [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode(\"Reflection\")]\n    public static System.Threading.Tasks.Task ReregisterTestWithArguments(this TUnit.Core.TestContext testContext, object?[]? methodArguments, System.Collections.Generic.Dictionary<string, object?>? objectBag = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Test Hook Registration in C#\nDESCRIPTION: A module initializer method that creates an instance of Hooks_BaseTests and registers it with the SourceRegistrar. This ensures the test hooks are available to the TUnit test runner.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Hooks1589.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tvar instance = new Hooks_BaseTests();\n\tSourceRegistrar.RegisterTestHookSource(instance);\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Test Initialization Failures\nDESCRIPTION: Captures and records test initialization failures by creating FailedTestMetadata objects. This allows the test framework to report initialization errors properly rather than losing them.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.NonTyped.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.AutoDataTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.TestProject.Attributes.AutoDataAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.AutoDataTests.Test1(string,int,double,bool):0\",\n\t\t\t\t\tMethodName = $\"Test1\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"AutoDataTests.Test1 failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 8,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing Helper Classes for TUnit Test Framework\nDESCRIPTION: Utility helper classes for the TUnit framework that provide functionality for type casting, counting, parallelism control, and method information retrieval. These helpers simplify common operations needed during test execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\npublic static class CastHelper\n    {\n        [System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessage(\"\", \"IL2072\")]\n        public static T? Cast<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods)]  T>(object? value) { }\n    }\n    [System.Diagnostics.DebuggerDisplay(\"Count = {CurrentCount}\")]\n    public class Counter\n    {\n        public System.EventHandler<int>? OnCountChanged;\n        public Counter() { }\n        public int CurrentCount { get; }\n        public int Decrement() { }\n        public int Increment() { }\n    }\n    public class DefaultParallelLimit : TUnit.Core.Interfaces.IParallelLimit\n    {\n        public DefaultParallelLimit() { }\n        public int Limit { get; }\n    }\n    public class MethodInfoRetriever\n    {\n        public MethodInfoRetriever() { }\n        public static System.Reflection.MethodInfo GetMethodInfo([System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicMethods)] System.Type type, string methodName, int genericParameterCount, System.Type[] parameterTypes) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Exception Throwing Assertion Conditions\nDESCRIPTION: Classes for handling exception-throwing assertions in tests. Includes conditions for checking any exception type and specific exception types with custom validation logic.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic class ThrowsAnyExceptionAssertCondition<TActual> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<TActual, System.Exception>\n{\n    public ThrowsAnyExceptionAssertCondition() { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Logger Interfaces in C#\nDESCRIPTION: Defines ILogger and ILogger<TCategoryName> interfaces for logging in TUnit. These interfaces declare methods for checking log level and logging messages.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_65\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ILogger\n{\n    bool IsEnabled(TUnit.Core.Logging.LogLevel logLevel);\n    void Log<TState>(TUnit.Core.Logging.LogLevel logLevel, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter);\n    System.Threading.Tasks.ValueTask LogAsync<TState>(TUnit.Core.Logging.LogLevel logLevel, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter);\n}\n\npublic interface ILogger<out TCategoryName> : TUnit.Core.Logging.ILogger { }\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata with Tuple Data Sources\nDESCRIPTION: Complex method that generates test metadata for tuple-based data source driven tests, including class instantiation, property setting, and error handling\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=TupleMethod_testMethodName=NamedTupleMethod.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testClassType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests);\n\t\tvar methodInfo = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests).GetMethod(\"DataSource_TupleMethod\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]);\n\n\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t// Additional implementation details omitted for brevity\n\t}\n\tcatch (global::System.Exception exception)\n\t{\n\t\t// Error handling code\n\t}\n\treturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Initialization Errors for TUnit Data-Driven Test Case (Set 1) in C#\nDESCRIPTION: This `catch` block is paired with the `try` block in the `Tests1` method. It captures any exceptions thrown during the setup of the second test case (`ArgumentsAttribute` set 1) for the `DataSource_Method`. Upon catching an exception, it generates a `FailedTestMetadata` record containing the specific test ID, method name, wrapped exception (`TestFailedInitializationException`), and location, adding this failure information to the `nodes` list.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n\t\t\t\tcatch (global::System.Exception exception)\n\t\t\t\t{\n\t\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.DataDrivenTests>\n\t\t\t\t\t{\n\t\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS1:TUnit.TestProject.DataDrivenTests.DataSource_Method(int,string):0\",\n\t\t\t\t\t\tMethodName = $\"DataSource_Method\",\n\t\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"DataDrivenTests.DataSource_Method failed to initialize\", exception),\n```\n\n----------------------------------------\n\nTITLE: Adding Test Metadata for UInt Test Method\nDESCRIPTION: This code adds metadata for the UInt test method to the nodes collection. It includes configuration for test arguments, factories for creating test class instances, and test execution details.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/NumberArgumentTests.TestDE.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.NumberArgumentTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NumberArgumentTests.UInt(uint):0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.UInt(methodArg)),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 40,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n```\n\n----------------------------------------\n\nTITLE: Implementing AssignableFromExpectedValueAssertCondition in C#\nDESCRIPTION: A class that implements a condition to check if a type is assignable from an expected type. This is part of the generic assertions functionality and allows for type compatibility testing.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_109\n\nLANGUAGE: C#\nCODE:\n```\npublic class AssignableFromExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n{\n    public AssignableFromExpectedValueAssertCondition(System.Type expectedType) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTimeOffsetEqualToAssertionBuilderWrapper for DateTimeOffset Comparisons\nDESCRIPTION: Specialized assertion builder for comparing DateTimeOffset values with tolerance options. It allows specifying a TimeSpan-based tolerance for comparing datetimes with offsets.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_83\n\nLANGUAGE: C#\nCODE:\n```\npublic class DateTimeOffsetEqualToAssertionBuilderWrapper : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTimeOffset>\n{\n    public TUnit.Assertions.AssertionBuilders.Wrappers.DateTimeOffsetEqualToAssertionBuilderWrapper Within(System.TimeSpan tolerance, [System.Runtime.CompilerServices.CallerArgumentExpression(\"tolerance\")] string doNotPopulateThis = \"\") { }\n}\n```\n\n----------------------------------------\n\nTITLE: Argument Formatting and Display Classes in C#\nDESCRIPTION: Defines classes for formatting test arguments for display, including the base ArgumentDisplayFormatter class and its attribute-based registration system. These are used to customize how test arguments are displayed in test reports.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class ArgumentDisplayFormatter\n{\n    protected ArgumentDisplayFormatter() { }\n    public abstract bool CanHandle(object? value);\n    public abstract string FormatValue(object? value);\n}\n\npublic abstract class ArgumentDisplayFormatterAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver\n{\n    protected ArgumentDisplayFormatterAttribute() { }\n    public abstract TUnit.Core.ArgumentDisplayFormatter Formatter { get; }\n    public virtual int Order { get; }\n    public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }\n}\n\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\npublic class ArgumentDisplayFormatterAttribute<T> : TUnit.Core.ArgumentDisplayFormatterAttribute\n    where T : TUnit.Core.ArgumentDisplayFormatter, new ()\n{\n    public ArgumentDisplayFormatterAttribute() { }\n    public override TUnit.Core.ArgumentDisplayFormatter Formatter { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Or Conditions in tunit C# Tests\nDESCRIPTION: This snippet demonstrates how to use the 'Or' property in C# tests to check multiple conditions using the tunit framework. It uses asynchronous test methods marked with the '[Test]' and '[Repeat]' attributes, where the test passes if any of the 'Or' conditions are satisfied. Dependencies include access to the tunit testing framework and a method 'Add' to sum integers. The test arrays are randomly populated and assertions are validated against expected results.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-assertions/or-conditions.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n    [Test]\n    [Repeat(100)]\n    public async Task MyTest()\n    {\n        int[] array = [1, 2];\n        var randomValue1 = Random.Shared.GetItems(array, 1).First();\n        var randomValue2 = Random.Shared.GetItems(array, 1).First();\n        \n        var result = Add(randomValue1, randomValue2);\n\n        await Assert.That(result)\n            .IsEqualTo(2)\n            .Or.IsEqualTo(3)\n            .Or.IsEqualTo(4);\n    }\n```\n\n----------------------------------------\n\nTITLE: Class and Method Factory Initialization with Error Handling in C#\nDESCRIPTION: This C# snippet initializes a test context for ValueTask asynchronous tests using factories for class and method setup. It captures exceptions in case of test initialization failure. The key functionality involves setting up a TUnit test environment and handling exceptions using a custom exception type.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BasicTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n\nTestId = $\"TUnit.TestProject.BasicTests.ValueTaskAsynchronousTest:0\",\nTestClassArguments = [],\nTestMethodArguments = [],\nTestClassProperties = [],\nCurrentRepeatAttempt = 0,\nRepeatLimit = 0,\nResettableClassFactory = resettableClassFactory,\nTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.ValueTaskAsynchronousTest()),\nTestFilePath = @\"\",\nTestLineNumber = 17,\nTestMethod = testInformation,\nTestBuilderContext = testBuilderContext,\n});\nresettableClassFactory = resettableClassFactoryDelegate();\ntestBuilderContext = new();\ntestBuilderContextAccessor.Current = testBuilderContext;\n}\ncatch (global::System.Exception exception)\n{\nnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.BasicTests>\n{\nTestId = $\"TUnit.TestProject.BasicTests.ValueTaskAsynchronousTest:0\",\nMethodName = $\"ValueTaskAsynchronousTest\",\nException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"BasicTests.ValueTaskAsynchronousTest failed to initialize\", exception),\nTestFilePath = @\"\",\nTestLineNumber = 17,\n});\n}\nreturn nodes;\n\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for Base_Derived1 Method with Derived2 Data Source\nDESCRIPTION: This method generates test metadata for the Base_Derived1 test method using Derived2 as the class data source. It follows a similar pattern to Tests0, but uses a different data source class.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassDataSourceDrivenTests2.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests1(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\t// ... (test setup code)\n\n\t\tvar classDataAttribute = new global::TUnit.Core.ClassDataSourceAttribute<global::TUnit.TestProject.ClassDataSourceDrivenTests2.Derived2>();\n\n\t\ttestBuilderContext.DataAttributes.Add(classDataAttribute);\n\n\t\tvar classArgGeneratedDataArray = classDataAttribute.GenerateDataSources(classArgDataGeneratorMetadata);\n\n\t\tforeach (var classArgGeneratedDataAccessor in classArgGeneratedDataArray)\n\t\t{\n\t\t\t// ... (test metadata generation code)\n\t\t}\n\t}\n\tcatch (global::System.Exception exception)\n\t{\n\t\t// ... (exception handling code)\n\t}\n\treturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing TUnit Templates and Creating a Project using .NET CLI\nDESCRIPTION: Commands for installing TUnit templates and creating a new TUnit test project. First installs the templates package, then creates a new test project with sample tests and tips.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/README_Template.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet new install TUnit.Templates\n```\n\nLANGUAGE: shell\nCODE:\n```\ndotnet new TUnit -n \"YourProjectName\"\n```\n\n----------------------------------------\n\nTITLE: Class Constructor Interface Reference in C#\nDESCRIPTION: Reference to the IClassConstructor interface that must be implemented by the type parameter T used in ClassConstructorAttribute. This interface defines the contract for custom class instantiation.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/class-constructors.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nIClassConstructor\n```\n\n----------------------------------------\n\nTITLE: Defining Method Information and Attributes for Concrete GrandParentTests with Fixture in C#\nDESCRIPTION: This code snippet constructs metadata for the SetupBase method of the concrete GrandParentTests class, parameterized with MyFixture. It registers method and property information including types, parameters, and assigns the BeforeAttribute to indicate this is a setup hook. Dependencies are the TUnit.Core library and correct type definitions for GrandParentTests and MyFixture.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Hooks1594.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nnew global::TUnit.Core.Hooks.InstanceHookMethod\n{\n    ClassType = typeof(global::TUnit.TestProject.Bugs._1594.GrandParentTests<global::TUnit.TestProject.Bugs._1594.MyFixture>),\n    MethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n    {\n        Type = typeof(global::TUnit.TestProject.Bugs._1594.GrandParentTests<global::TUnit.TestProject.Bugs._1594.MyFixture>),\n        Name = \"SetupBase\",\n        GenericTypeCount = 0,\n        ReturnType = typeof(void),\n        Attributes = [\n            new global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n        ],\n        Parameters = [],\n        Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._1594.GrandParentTests<global::TUnit.TestProject.Bugs._1594.MyFixture>\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n        {\n            Type = typeof(global::TUnit.TestProject.Bugs._1594.GrandParentTests<global::TUnit.TestProject.Bugs._1594.MyFixture>),\n            Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Hooks1594\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n            {\n                Name = \"Hooks1594\",\n                Attributes = [],\n            }),\n            Name = \"GrandParentTests\",\n            Namespace = \"TUnit.TestProject.Bugs._1594\",\n            Attributes = [],\n            Parameters = [\n                new global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.TestProject.Bugs._1594.MyFixture>\n                {\n                    Name = \"fixture\",\n                    Attributes = [],\n                },\n            ],\n            Properties = [\n                new global::TUnit.Core.SourceGeneratedPropertyInformation\n                {\n                    Type = typeof(global::TUnit.TestProject.Bugs._1594.MyFixture),\n                    Name = \"Fixture\",\n                    IsStatic = false,\n                    Attributes = [],\n                },\n            ],\n        }),\n    },\n```\n\n----------------------------------------\n\nTITLE: String Manipulation Utilities in C#\nDESCRIPTION: This snippet defines extension methods for string manipulation, including methods for handling null or empty strings, prepending articles, and replacing newlines.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_152\n\nLANGUAGE: C#\nCODE:\n```\npublic static class StringExtensions\n{\n    public static string GetStringOr(this string? value, string defaultValue) { }\n    public static string GetStringOrEmpty(this string? value) { }\n    public static string PrependAOrAn(this string value) { }\n    public static string ReplaceNewLines(this string value) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Deploying Docusaurus Site Using GitHub Username - Shell\nDESCRIPTION: Executes the deployment using GIT_USER environment variable to specify the GitHub username when pushing to the remote repository. Intended for use on GitHub Pages when not using SSH; may require additional authentication like a personal access token. Replaces USE_SSH with credential-based access using the given username.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/README.md#2025-04-22_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n```\n$ GIT_USER=<Your GitHub username> yarn deploy\n```\n```\n\n----------------------------------------\n\nTITLE: Exception Handling for Test Initialization in TUnit C#\nDESCRIPTION: Code that adds a FailedTestMetadata object to the nodes collection when a test initialization fails. It captures the exception details and includes metadata about the test method that failed to initialize.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ArgumentWithImplicitConverterTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ArgumentWithImplicitConverterTests>\n\t{\n\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS1:TUnit.TestProject.ArgumentWithImplicitConverterTests.Implicit(TUnit.TestProject.ImplicitInteger):0\",\n\t\tMethodName = $\"Implicit\",\n\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ArgumentWithImplicitConverterTests.Implicit failed to initialize\", exception),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 14,\n\t});\n}\nreturn nodes;\n```\n\n----------------------------------------\n\nTITLE: Collecting Empty Hook Lists in TUnit\nDESCRIPTION: Methods that collect empty lists of hooks for specific hook types. These methods return empty arrays when no hooks of the specified type are defined.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeTests.Test.verified.txt#2025-04-22_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t];\n}\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t];\n}\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: FilterParser for Test Filter Processing\nDESCRIPTION: A service for parsing and stringifying test filters, allowing test execution to be narrowed to specific tests based on filter criteria.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\npublic class FilterParser\n{\n    public FilterParser() { }\n    public string? GetTestFilter(Microsoft.Testing.Platform.Extensions.TestFramework.ExecuteRequestContext context) { }\n    public static string? StringifyFilter(Microsoft.Testing.Platform.Requests.ITestExecutionFilter filter) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Building Resettable Class and Test Factories for Tuple Parameterized Tests - TUnit - C#\nDESCRIPTION: Creates factory delegates that instantiate ClassTupleDataSourceDrivenTests with extracted tuple arguments and property assignments, then wires them to a test metadata node for TUnit. Assumes existence of ResettableLazy and AsyncConvert types. Inputs include arguments and context, output is a metadata node representing a runnable parameterized test. Used in test discovery for tuple-driven data source test scenarios.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>(() => \nnew global::TUnit.TestProject.ClassTupleDataSourceDrivenTests(classArg, classArg1, classArg2)\n{\n\tProperty1 = global::TUnit.Core.Helpers.CastHelper.Cast<(int, string, bool)>(propertyArg),\n\tProperty2 = global::TUnit.Core.Helpers.CastHelper.Cast<(int, string, bool)>(propertyArg1),\n\tProperty3 = global::TUnit.Core.Helpers.CastHelper.Cast<(int Number, string Word, bool Flag)>(propertyArg2),\n\tProperty4 = global::TUnit.Core.Helpers.CastHelper.Cast<(int Number, string Word, bool Flag)>(propertyArg3),\n}\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n```\n\n----------------------------------------\n\nTITLE: Creating Test Instance and Settings for Test Execution\nDESCRIPTION: This snippet prepares the test execution environment by setting up the test context, creating lazy-loaded class instances, and configuring test arguments for the NumberArgumentTests.UInt method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/NumberArgumentTests.TestDE.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.NumberArgumentTests? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tclassInstanceArguments = [];\n\n\t\t\tuint methodArg = 1U;\n\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.NumberArgumentTests>(() => \n\t\t\tnew global::TUnit.TestProject.NumberArgumentTests()\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n```\n\n----------------------------------------\n\nTITLE: Exception Message Assertion Classes\nDESCRIPTION: Classes for comparing exception messages with expected values using different comparison methods like equals, starts with, and pattern matching.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_48\n\nLANGUAGE: C#\nCODE:\n```\npublic class ExceptionMessageEqualsExpectedValueAssertCondition<TException> : ExpectedValueAssertCondition<TException, string>\n    where TException : System.Exception\n{\n    public ExceptionMessageEqualsExpectedValueAssertCondition(string expected, System.StringComparison stringComparison) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TException? actualValue, string? expectedValue) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Character Equality Assertion Extensions in TUnit\nDESCRIPTION: Extension methods for asserting character equality in tests. The class provides methods for both nullable and non-nullable character types with different parameter combinations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_127\n\nLANGUAGE: C#\nCODE:\n```\npublic static class CharIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<char> IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<char> valueSource, char expected) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<char?> IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<char?> valueSource, char expected) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<char?> IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<char?> valueSource, char? expected) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Test Initialization Failures\nDESCRIPTION: This code handles exceptions that might occur during test initialization by creating a FailedTestMetadata object. It captures the exception details and wraps it in a TestFailedInitializationException to provide meaningful error information.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceClassCombinedWithDataSourceMethodTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n    nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod>\n    {\n        TestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS2:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod(int).DataSourceClassCombinedWithDataSourceMethodTest(int):0\",\n        MethodName = $\"DataSourceClassCombinedWithDataSourceMethodTest\",\n        Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"DataSourceClassCombinedWithDataSourceMethod.DataSourceClassCombinedWithDataSourceMethodTest failed to initialize\", exception),\n        TestFilePath = @\"\",\n        TestLineNumber = 10,\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Tests with dotnet run in Powershell\nDESCRIPTION: Demonstrates how to run tests using dotnet run, a method suitable for simple test execution with optional command line flags. Ensure that you navigate to the test directory before executing the command.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/running-your-tests.md#2025-04-22_snippet_0\n\nLANGUAGE: Powershell\nCODE:\n```\ncd 'C:/Your/Test/Directory'\ndotnet run -c Release\n# or with flags\ndotnet run -c Release --report-trx --coverage\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata using NamedTuple/NamedTuple Sources (Tests3) in C#\nDESCRIPTION: This private C# method `Tests3` generates a list of `TestMetadata` for the `DataSource_TupleMethod` test within the `ClassTupleDataSourceDrivenTests` class. It differs from `Tests2` by fetching both class constructor arguments and method arguments from `NamedTupleMethod` using `MethodDataSourceAttribute`. It initializes the test class properties using both `TupleMethod` and `NamedTupleMethod`. A `ResettableLazy` factory handles test class instantiation per `sessionId` with a `TestBuilderContext`. Initialization errors are caught and logged as `FailedInitializationTest` instances.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=TupleMethod_testMethodName=NamedTupleMethod.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests3(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testClassType = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests);\n\t\t\tvar methodInfo = typeof(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests).GetMethod(\"DataSource_TupleMethod\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]);\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tvar classArgTuples = global::System.TupleExtensions.ToTuple<global::System.Int32, global::System.String, global::System.Boolean>(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()());\n\t\t\tglobal::System.Int32 classArg = classArgTuples.Item1;\n\t\t\tglobal::System.String classArg1 = classArgTuples.Item2;\n\t\t\tglobal::System.Boolean classArg2 = classArgTuples.Item3;\n\t\t\t(global::System.Int32, global::System.String, global::System.Boolean) propertyArg = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()();\n\t\t\t(global::System.Int32 Number, global::System.String Word, global::System.Boolean Flag) propertyArg1 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()();\n\t\t\t(global::System.Int32, global::System.String, global::System.Boolean) propertyArg2 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.TupleMethod()();\n\t\t\t(global::System.Int32 Number, global::System.String Word, global::System.Boolean Flag) propertyArg3 = global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()();\n\n\t\t\tvar methodArgTuples = global::System.TupleExtensions.ToTuple<global::System.Int32, global::System.String, global::System.Boolean>(global::TUnit.TestProject.ClassTupleDataSourceDrivenTests.NamedTupleMethod()());\n\t\t\tglobal::System.Int32 methodArg = methodArgTuples.Item1;\n\t\t\tglobal::System.String methodArg1 = methodArgTuples.Item2;\n\t\t\tglobal::System.Boolean methodArg2 = methodArgTuples.Item3;\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>(() => \n\t\t\tnew global::TUnit.TestProject.ClassTupleDataSourceDrivenTests(classArg, classArg1, classArg2)\n\t\t\t{\n\t\t\t\tProperty1 = propertyArg,\n\t\t\t\tProperty2 = propertyArg1,\n\t\t\t\tProperty3 = propertyArg2,\n\t\t\t\tProperty4 = propertyArg3,\n\t\t\t}\n\t\t\t, sessionId, testBuilderContext);\n\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.ClassTupleDataSourceDrivenTests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS1:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.ClassTupleDataSourceDrivenTests(System.Int32,System.String,System.Boolean).DataSource_TupleMethod(System.Int32,System.String,System.Boolean):0\",\n\t\t\t\tTestClassArguments = [classArg, classArg1, classArg2],\n\t\t\t\tTestMethodArguments = [methodArg, methodArg1, methodArg2],\n```\n\n----------------------------------------\n\nTITLE: Initializing Resettable Test Class Factory for InheritedPropertySetterTests in TUnit\nDESCRIPTION: This code creates a resettable lazy factory for the InheritedPropertySetterTests class with property initialization. It sets both instance properties and a static property on the test class to prepare it for test execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/InheritedPropertySetterTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.InheritedPropertySetterTests>(() => \nnew global::TUnit.TestProject.InheritedPropertySetterTests()\n{\n\tProperty1 = global::TUnit.Core.Helpers.CastHelper.Cast<string>(propertyArg),\n\tProperty2 = global::TUnit.Core.Helpers.CastHelper.Cast<string>(propertyArg1),\n\tProperty3 = global::TUnit.Core.Helpers.CastHelper.Cast<global::TUnit.TestProject.PropertySetterTests.InnerModel>(propertyArg2),\n\tProperty4 = global::TUnit.Core.Helpers.CastHelper.Cast<global::TUnit.TestProject.PropertySetterTests.InnerModel>(propertyArg3),\n\tProperty5 = global::TUnit.Core.Helpers.CastHelper.Cast<global::TUnit.TestProject.PropertySetterTests.InnerModel>(propertyArg4),\n\tProperty6 = global::TUnit.Core.Helpers.CastHelper.Cast<global::TUnit.TestProject.PropertySetterTests.InnerModel>(propertyArg5),\n}\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\nglobal::TUnit.TestProject.InheritedPropertySetterTests.StaticProperty = propertyArg6;\n```\n\n----------------------------------------\n\nTITLE: Implementing NotAssignableFromExpectedValueAssertCondition in C#\nDESCRIPTION: A class that implements a condition to check if a type is not assignable from an expected type. It complements AssignableFromExpectedValueAssertCondition with the inverse functionality.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_116\n\nLANGUAGE: C#\nCODE:\n```\npublic class NotAssignableFromExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>\n{\n    public NotAssignableFromExpectedValueAssertCondition(System.Type expectedType) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Structuring Exception Handling for Source-Generated Tests in TUnit - C#\nDESCRIPTION: This C# snippet captures and logs exceptions that occur during the initialization of a source-generated data-source-driven test. When a test fails to initialize, a FailedTestMetadata object is created with test IDs, method name, exception details, and file information. The approach ensures TUnit accurately reports initialization failures for debugging and reporting. It relies on the presence of the TUnit.Core.Exceptions namespace and complements test metadata creation routines.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MethodDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.MethodDataSourceDrivenTests>\n{\n\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.MethodDataSourceDrivenTests.DataSource_Method3(int):0\",\n\tMethodName = $\"DataSource_Method3\",\n\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"MethodDataSourceDrivenTests.DataSource_Method3 failed to initialize\", exception),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 33,\n});\n```\n\n----------------------------------------\n\nTITLE: Artifact Class for Test Output in C#\nDESCRIPTION: Defines the Artifact class that represents a file output from a test. Contains properties for file information, display name, and description. Used to track and display test-generated files.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class Artifact\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public Artifact() { }\n    public string? Description { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string DisplayName { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.IO.FileInfo File { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting OutputType in Project File\nDESCRIPTION: Project configuration required in csproj file to ensure test execution\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/faq.md#2025-04-22_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<OutputType>exe</OutputType>\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Argument Display Formatter\nDESCRIPTION: Implementation of a custom ArgumentDisplayFormatter class that handles formatting of SomeClass instances. Provides custom string representation for test explorer display.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/argument-formatters.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyFormatter : ArgumentDisplayFormatter\n{\n    public override bool CanHandle(object? value)\n    {\n        return value is SomeClass;\n    }\n\n    public override string FormatValue(object? value)\n    {\n        var someClass = (SomeClass)value;\n        return $\"One: {someClass.One} | Two: {someClass.Two}\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: String Assertion Extensions\nDESCRIPTION: Extension methods for string assertions in TUnit including equality, emptiness, and whitespace checks\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_132\n\nLANGUAGE: C#\nCODE:\n```\npublic static class StringIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> IsEmpty(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.StringEqualToAssertionBuilderWrapper IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null) { }\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.StringEqualToAssertionBuilderWrapper IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"stringComparison\")] string doNotPopulateThisValue2 = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> IsNullOrEmpty(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> IsNullOrWhitespace(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Source Registration in C#\nDESCRIPTION: This snippet shows the implementation of ITestSource interface with initialization and test collection methods. It registers the Tests class with the TUnit framework during module initialization.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests2112.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tglobal::TUnit.Core.SourceRegistrar.Register(new Tests());\n}\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn\n\t[\n\t\t..Tests0(sessionId),\n\t\t..Tests1(sessionId),\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GetOnlyDictionary Generic Class in C#\nDESCRIPTION: A generic dictionary implementation with limited mutability that provides only getter access to stored values. It supports operations for retrieving, adding, and removing key-value pairs while enforcing type constraints.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic class GetOnlyDictionary<TKey, TValue>\n        where TKey :  notnull\n    {\n        public GetOnlyDictionary() { }\n        public TValue this[TKey key] { get; }\n        public System.Collections.Generic.ICollection<TKey> Keys { get; }\n        public System.Collections.Generic.ICollection<TValue> Values { get; }\n        public TValue GetOrAdd(TKey key, System.Func<TKey, TValue> func) { }\n        public TValue GetOrAdd(TKey key, System.Func<TKey, TValue> func, out bool previouslyExisted) { }\n        public TValue? Remove(TKey key) { }\n        public bool TryGetValue(TKey key, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out TValue? value) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: TimeSpan Positive Assertion Extensions in TUnit\nDESCRIPTION: Extension methods for TimeSpan assertions checking for equality and zero value conditions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_158\n\nLANGUAGE: C#\nCODE:\n```\npublic static class TimeSpanIsExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.TimeSpanEqualToAssertionBuilderWrapper IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.TimeSpan> valueSource, System.TimeSpan expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.TimeSpan> IsZero(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.TimeSpan> valueSource) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Retry Attribute for Transient HTTP Failures with TUnit in C#\nDESCRIPTION: This snippet details how to implement a custom retry attribute in C# by extending TUnit's RetryAttribute. The new RetryTransientHttpAttribute selectively retries tests only for specific HTTP errors (e.g., BadGateway, TooManyRequests) by overriding the ShouldRetry method. This approach requires that TUnit.Core and reference types like HttpRequestException and HttpStatusCode are available. Used to avoid unnecessary retries for non-transient errors, this pattern enables fine-grained control over retry conditions in test suites.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/retrying.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class RetryTransientHttpAttribute : RetryAttribute\n{\n    public RetryTransientHttpAttribute(int times) : base(times)\n    {\n    }\n\n    public override Task<bool> ShouldRetry(TestInformation testInformation, Exception exception)\n    {\n        if (exception is HttpRequestException requestException)\n        {\n            return Task.FromResult(requestException.StatusCode is\n                HttpStatusCode.BadGateway\n                or HttpStatusCode.TooManyRequests\n                or HttpStatusCode.GatewayTimeout\n                or HttpStatusCode.RequestTimeout);\n        }\n\n        return Task.FromResult(false);\n    }\n}\n\npublic class MyTestClass\n{\n    [Test]\n    [RetryTransientHttp(3)]\n    public async Task MyTest()\n    {\n        \n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building Test Metadata for Parameterized Tests in C#\nDESCRIPTION: Creates test metadata for parameterized tests by setting up test information, arguments, and execution factories. This code handles the first set of test parameters for the Test method.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests2112.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.Bugs._2112.Tests),\n\t\t\tName = \"Test\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(void),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(0, 1L),\n\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(0, 1)\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t{\n\t\t\t\t\tName = \"a\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<long[]>\n\t\t\t\t{\n\t\t\t\t\tName = \"arr\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._2112.Tests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._2112.Tests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Tests2112\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"Tests2112\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"Tests\",\n\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._2112\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tglobal::TUnit.TestProject.Bugs._2112.Tests? classInstance = null;\n\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\tclassInstanceArguments = [];\n\n\t\t\tint methodArg = 0;\n\t\t\tlong[] methodArg1 = [1L];\n\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._2112.Tests>(() => \n\t\t\tnew global::TUnit.TestProject.Bugs._2112.Tests()\n\t\t\t, sessionId, testBuilderContext);\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._2112.Tests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.Bugs._2112.Tests.Test(int,long[]):0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [methodArg, methodArg1],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Test(methodArg, methodArg1)),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 5,\n\t\t\t\tTestMethod = testInformation,\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._2112.Tests>\n\t\t\t{\n\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.Bugs._2112.Tests.Test(int,long[]):0\",\n\t\t\t\tMethodName = $\"Test\",\n\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"Tests.Test failed to initialize\", exception),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 5,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n```\n\n----------------------------------------\n\nTITLE: Initializing TUnit Source Generator Tests in C#\nDESCRIPTION: This C# snippet defines the initialization and registration of TUnit tests using source generators. It registers the `EnumerableTupleDataSourceDrivenTests` class and collects tests using defined tuple methods. Dependencies include TUnit Core, TUnit Core Extensions, and necessary global system libraries. The core functionality lies in registering and initializing test data, and it requires tuple method implementations in test projects. The main inputs are the session ID and the expected outputs are read-only lists of test metadata.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/EnumerableTupleDataSourceDrivenTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class EnumerableTupleDataSourceDrivenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new EnumerableTupleDataSourceDrivenTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\t..Tests0(sessionId),\n\t\t\t..Tests1(sessionId),\n\t\t];\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.EnumerableTupleDataSourceDrivenTests),\n\t\t\t\tName = \"DataSource_TupleMethod\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\"),\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value2\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value3\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.EnumerableTupleDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.EnumerableTupleDataSourceDrivenTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"EnumerableTupleDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"EnumerableTupleDataSourceDrivenTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"EnumerableTupleDataSourceDrivenTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.EnumerableTupleDataSourceDrivenTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tforeach (var methodDataAccessor in global::TUnit.TestProject.EnumerableTupleDataSourceDrivenTests.TupleMethod())\n\t\t\t\t{\n\t\t\t\t\ttestMethodDataIndex++;\n\t\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\t\tvar methodData = methodDataAccessor;\n\t\t\t\t\tvar methodArgTuples = global::System.TupleExtensions.ToTuple<int, string, bool>(methodData);\n\t\t\t\t\tint methodArg = methodArgTuples.Item1;\n\t\t\t\t\tstring methodArg1 = methodArgTuples.Item2;\n\t\t\t\t\tbool methodArg2 = methodArgTuples.Item3;\n\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.EnumerableTupleDataSourceDrivenTests>(() => \n\t\t\t\t\tnew global::TUnit.TestProject.EnumerableTupleDataSourceDrivenTests()\n\t\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.EnumerableTupleDataSourceDrivenTests>\n\t\t\t\t\t{\n\t\t\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS0:{testMethodDataIndex}:TUnit.TestProject.EnumerableTupleDataSourceDrivenTests.DataSource_TupleMethod(int,string,bool):0\",\n\t\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\t\tTestMethodArguments = [methodArg, methodArg1, methodArg2],\n\t\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_TupleMethod(methodArg, methodArg1, methodArg2)),\n\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\tTestLineNumber = 5,\n\t\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t\t});\n\t\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\t\ttestBuilderContext = new();\n\t\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.EnumerableTupleDataSourceDrivenTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS0:{testMethodDataIndex}:TUnit.TestProject.EnumerableTupleDataSourceDrivenTests.DataSource_TupleMethod(int,string,bool):0\",\n\t\t\t\t\tMethodName = $\"DataSource_TupleMethod\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"EnumerableTupleDataSourceDrivenTests.DataSource_TupleMethod failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 5,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests1(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.EnumerableTupleDataSourceDrivenTests),\n\t\t\t\tName = \"DataSource_TupleMethod\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"TupleMethod\"),\n\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"NamedTupleMethod\")\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value2\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value3\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.EnumerableTupleDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.EnumerableTupleDataSourceDrivenTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"EnumerableTupleDataSourceDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"EnumerableTupleDataSourceDrivenTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"EnumerableTupleDataSourceDrivenTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.EnumerableTupleDataSourceDrivenTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tforeach (var methodDataAccessor in global::TUnit.TestProject.EnumerableTupleDataSourceDrivenTests.NamedTupleMethod())\n\t\t\t\t{\n\t\t\t\t\ttestMethodDataIndex++;\n\t\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\t\tvar methodData = methodDataAccessor;\n\t\t\t\t\tvar methodArgTuples = global::System.TupleExtensions.ToTuple<int, string, bool>(methodData);\n\t\t\t\t\tint methodArg = methodArgTuples.Item1;\n\t\t\t\t\tstring methodArg1 = methodArgTuples.Item2;\n\t\t\t\t\tbool methodArg2 = methodArgTuples.Item3;\n\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.EnumerableTupleDataSourceDrivenTests>(() => \n\t\t\t\t\tnew global::TUnit.TestProject.EnumerableTupleDataSourceDrivenTests()\n\t\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.EnumerableTupleDataSourceDrivenTests>\n\t\t\t\t\t{\n\t\t\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS1:{testMethodDataIndex}:TUnit.TestProject.EnumerableTupleDataSourceDrivenTests.DataSource_TupleMethod(int,string,bool):0\",\n\t\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\t\tTestMethodArguments = [methodArg, methodArg1, methodArg2],\n\t\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.DataSource_TupleMethod(methodArg, methodArg1, methodArg2)),\n\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\tTestLineNumber = 5,\n\t\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t\t});\n\t\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\t\ttestBuilderContext = new();\n\t\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.EnumerableTupleDataSourceDrivenTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-EMDS1:{testMethodDataIndex}:TUnit.TestProject.EnumerableTupleDataSourceDrivenTests.DataSource_TupleMethod(int,string,bool):0\",\n\t\t\t\t\tMethodName = $\"DataSource_TupleMethod\",\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Hook Source in C#\nDESCRIPTION: Defines a partial class implementing ITestHookSource interface with methods to collect and manage test hooks. Includes hook registration for before/after test scenarios with support for static and instance methods.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticBeforeEachTests.Test.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class Hooks_GlobalSetUpTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n    [global::System.Runtime.CompilerServices.ModuleInitializer]\n    public static void Initialise()\n    {\n        var instance = new Hooks_GlobalSetUpTests();\n        SourceRegistrar.RegisterTestHookSource(instance);\n    }\n\n    public global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n    {\n        return\n        [\n            new global::TUnit.Core.Hooks.BeforeTestHookMethod\n            { \n                MethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n                {\n                    Type = typeof(global::TUnit.TestProject.BeforeTests.GlobalSetUpTests),\n                    Name = \"BeforeAllSetUpWithContext\",\n                    GenericTypeCount = 0,\n                    ReturnType = typeof(global::System.Threading.Tasks.Task),\n                    Attributes = \n                    [\n                        new global::TUnit.Core.BeforeEveryAttribute(global::TUnit.Core.HookType.Test)\n                    ],\n                    Parameters = \n                    [\n                        new global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext>\n                        {\n                            Name = \"context\",\n                            Attributes = [],\n                        },\n                        new global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n                        {\n                            Name = \"cancellationToken\",\n                            Attributes = [],\n                        },\n                    ],\n                    Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.BeforeTests.GlobalSetUpTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n                    {\n                        Type = typeof(global::TUnit.TestProject.BeforeTests.GlobalSetUpTests),\n                        Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"GlobalStaticBeforeEachTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n                        {\n                            Name = \"GlobalStaticBeforeEachTests\",\n                            Attributes = [],\n                        }),\n                        Name = \"GlobalSetUpTests\",\n                        Namespace = \"TUnit.TestProject.BeforeTests\",\n                        Attributes = [],\n                        Parameters = [],\n                        Properties = [],\n                    }),\n                },\n                Body = (context, cancellationToken) => AsyncConvert.Convert(() => global::TUnit.TestProject.BeforeTests.GlobalSetUpTests.BeforeAllSetUpWithContext(context, cancellationToken)),\n                HookExecutor = DefaultExecutor.Instance,\n                Order = 0,\n                FilePath = @\"\",\n                LineNumber = 68,\n                MethodAttributes = \n                [\n                    new global::TUnit.Core.BeforeEveryAttribute(global::TUnit.Core.HookType.Test)\n                ],\n                ClassAttributes = [],\n                AssemblyAttributes = [],\n            },\n        ];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Integer Constant Argument Test Source Generation in C#\nDESCRIPTION: Auto-generated source code that implements test source generation for integer constant arguments. Handles test metadata creation and execution for integer parameter tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ConstantArgumentsTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class ConstantArgumentsTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new ConstantArgumentsTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.ConstantArgumentsTests),\n\t\t\t\tName = \"Int\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(123)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"dummy\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t]\n\t\t\t});\n```\n\n----------------------------------------\n\nTITLE: Implementing MappableResultAssertionBuilder in C#\nDESCRIPTION: Generic assertion builder class that supports mapping results and awaitable operations. Extends InvokableValueAssertionBuilder with support for expected value type mapping.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_79\n\nLANGUAGE: C#\nCODE:\n```\npublic class MappableResultAssertionBuilder<TActual, TExpected> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>\n{\n    public new System.Runtime.CompilerServices.TaskAwaiter<TExpected?> GetAwaiter() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Matrix Exclusion Attribute in C#\nDESCRIPTION: Defines an attribute that allows excluding specific combination patterns from matrix testing. It can be applied multiple times to classes or methods to exclude various test combinations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]\npublic class MatrixExclusionAttribute : TUnit.Core.TUnitAttribute\n{\n    public MatrixExclusionAttribute(params object?[]? objects) { }\n    public object?[] Objects { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StringContainsAssertionBuilderWrapper in C#\nDESCRIPTION: Wrapper for string contains assertions with options to ignore whitespace or trim strings before comparison.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_95\n\nLANGUAGE: C#\nCODE:\n```\n    public class StringContainsAssertionBuilderWrapper : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string>\n    {\n        public TUnit.Assertions.AssertionBuilders.Wrappers.StringContainsAssertionBuilderWrapper IgnoringWhitespace() { }\n        public TUnit.Assertions.AssertionBuilders.Wrappers.StringContainsAssertionBuilderWrapper WithTrimming() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: ImmutableArray Negative Assertion Extensions\nDESCRIPTION: Extension methods for negative assertions on ImmutableArray collections.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_126\n\nLANGUAGE: C#\nCODE:\n```\npublic static class ImmutableArrayIsNotExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsNotEmpty<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource) { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsNotEquivalentTo<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null) { }\n```\n\n----------------------------------------\n\nTITLE: Handling Test Initialization Failures in C#\nDESCRIPTION: This snippet adds a FailedTestMetadata object when an exception occurs during test initialization. It captures the exception and relevant test information for reporting purposes.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassAndMethodArgumentsTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.ClassAndMethodArgumentsTests>\n{\n\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{classDataIndex}:CL-ARGS0:global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.ClassAndMethodArgumentsTests(string).WithMethodLevel(string):0\",\n\tMethodName = $\"WithMethodLevel\",\n\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ClassAndMethodArgumentsTests.WithMethodLevel failed to initialize\", exception),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 11,\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing EnumDoesNotHaveSameNameAsCondition in C#\nDESCRIPTION: Assertion condition that checks if an enum value does not have the same name as a specified enum value, even from a different enum type.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_101\n\nLANGUAGE: C#\nCODE:\n```\n    public class EnumDoesNotHaveSameNameAsCondition<TEnum, TExpected> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TEnum>\n        where TEnum : System.Enum\n        where TExpected : System.Enum\n    {\n        public EnumDoesNotHaveSameNameAsCondition(TExpected expected) { }\n        protected override string GetExpectation() { }\n        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TEnum? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing TimeoutCancellationTokenTests Class for DataTest\nDESCRIPTION: Second part of the auto-generated partial class implementing test collection for DataTest method with timeout and cancellation token support. Includes test metadata generation with arguments and timeout configuration.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/TimeoutCancellationTokenTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class TimeoutCancellationTokenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new TimeoutCancellationTokenTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.TimeoutCancellationTokenTests),\n\t\t\t\tName = \"DataTest\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(1),\n\t\t\t\t\tnew global::TUnit.Core.TimeoutAttribute(5_000)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.TimeoutCancellationTokenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.TimeoutCancellationTokenTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"TimeoutCancellationTokenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"TimeoutCancellationTokenTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"TimeoutCancellationTokenTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.MethodDataSourceAttribute(\"DataSource\"),\n\t\t\t\t\t\tnew global::TUnit.Core.CategoryAttribute(\"Timeout Cancellation Token Tests\")\n\t\t\t\t\t],\n\t\t\t\t\tParameters = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: Deploying Docusaurus Site Using SSH - Shell\nDESCRIPTION: Runs the deploy step via Yarn with USE_SSH=true environment variable, instructing Docusaurus to use SSH-based git authentication for pushing to the remote repository. Useful for automated or secure deployments, especially for private repositories. Requires proper SSH keys to be set up and accessible. No other parameters are needed if SSH agent is configured.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/README.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n```\n$ USE_SSH=true yarn deploy\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Hook Source for Base2\nDESCRIPTION: Auto-generated class implementing ITestHookSource interface for Base2 test class, handling test-level hooks\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeAllTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_Base2 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_Base2();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing Negative Number Assertion Extensions in C#\nDESCRIPTION: Extension methods that provide negative assertion capabilities for numeric values. These methods assert that numeric values do not match specific criteria such as divisibility, evenness, or comparison operations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_77\n\nLANGUAGE: C#\nCODE:\n```\npublic static class NumberIsNotExtensions\n{\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotDivisibleBy<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.Numerics.INumber<TActual>, System.Numerics.IModulusOperators<TActual, TActual, TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotEven<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource)\n        where TActual : System.Numerics.INumber<TActual>, System.Numerics.IModulusOperators<TActual, int, int> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotGreaterThan<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.Numerics.INumber<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotGreaterThanOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.Numerics.INumber<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotLessThan<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.Numerics.INumber<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotLessThanOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n        where TActual : System.Numerics.INumber<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotNegative<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource)\n        where TActual : System.Numerics.INumber<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotOdd<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource)\n        where TActual : System.Numerics.INumber<TActual>, System.Numerics.IModulusOperators<TActual, int, int> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotPositive<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource)\n        where TActual : System.Numerics.INumber<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotZero<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource)\n        where TActual : System.Numerics.INumber<TActual> { }\n    public static TUnit.Assertions.AssertionBuilders.Wrappers.GenericNotEqualToAssertionBuilderWrapper<TActual> Within<TActual>(this TUnit.Assertions.AssertionBuilders.Wrappers.GenericNotEqualToAssertionBuilderWrapper<TActual> assertionBuilder, TActual tolerance, [System.Runtime.CompilerServices.CallerArgumentExpression(\"tolerance\")] string doNotPopulateThis = \"\")\n        where TActual : System.Numerics.INumber<TActual> { }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing TRX Test Reports Extension for TUnit\nDESCRIPTION: Commands to install and run the TRX test reporting extension via NuGet package Microsoft.Testing.Extensions.TrxReport.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/extensions/extensions.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndotnet add package Microsoft.Testing.Extensions.TrxReport\n```\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run --configuration Release --report-trx\n```\n\n----------------------------------------\n\nTITLE: Registering Before Test Setup Hook with TUnit in C#\nDESCRIPTION: This snippet demonstrates registering a setup hook (BeforeAttribute with HookType.Test) for a generic GrandParentTests<> type within the TUnit testing framework. It auto-generates and caches source information related to the type, its assembly, and properties using reflection, enabling integration with test pipelines. Required dependencies include TUnit.Core namespaces and proper definition of the referenced classes; inputs/outputs are managed via the framework's class information models.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Hooks1594.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Test)\n],\nParameters = [],\nClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._1594.GrandParentTests<>\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n{\n    Type = typeof(global::TUnit.TestProject.Bugs._1594.GrandParentTests<>),\n    Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Hooks1594\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n    {\n        Name = \"Hooks1594\",\n        Attributes = [],\n    }),\n    Name = \"GrandParentTests\",\n    Namespace = \"TUnit.TestProject.Bugs._1594\",\n    Attributes = [],\n    Parameters = [],\n    Properties = [],\n}),\n```\n\n----------------------------------------\n\nTITLE: Defining Auto-Generated TUnit Test Source Class StringArgumentTests in C#\nDESCRIPTION: This C# code defines the beginning of an auto-generated file for TUnit. It includes necessary `using` directives for System.Linq, System.Reflection, TUnit.Core, and TUnit.Core.Extensions. It defines a file-local partial class `StringArgumentTests` within the `TUnit.SourceGenerated` namespace, implementing the `ITestSource` interface. Attributes like `StackTraceHidden` and `ExcludeFromCodeCoverage` are applied. A `ModuleInitializer` named `Initialise` is defined to register this test source with `TUnit.Core.SourceRegistrar` upon module load.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/StringArgumentTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class StringArgumentTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new StringArgumentTests());\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Hooks for GlobalCleanUpTests in C#\nDESCRIPTION: Source-generated partial class implementing ITestHookSource interface for GlobalCleanUpTests. Provides basic initialization but contains no specific hook implementations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticAfterEachTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_GlobalCleanUpTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_GlobalCleanUpTests();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Type Test Source Generation\nDESCRIPTION: Auto-generated source code for handling Type parameter tests in the DataDrivenTests class. Includes test metadata collection, initialization, and error handling for type-based test methods.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class DataDrivenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new DataDrivenTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.DataDrivenTests),\n\t\t\t\tName = \"Type\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(typeof(object))\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Type>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.DataDrivenTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"DataDrivenTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"DataDrivenTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing NotNullStructAssertionBuilderWrapper for Value Types in C#\nDESCRIPTION: Wrapper for not-null assertions on value types (structs) that overrides GetAwaiter to allow for async/await pattern use with assertion results.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_93\n\nLANGUAGE: C#\nCODE:\n```\n    public class NotNullStructAssertionBuilderWrapper<TActual> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>\n        where TActual :  struct\n    {\n        public new System.Runtime.CompilerServices.TaskAwaiter<TActual> GetAwaiter() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Generating TUnit TestMetadata for StringArgumentTests.Normal (Multiline String Argument) in C#\nDESCRIPTION: This C# snippet, likely part of a generated method (e.g., `Tests7`), constructs `TestMetadata` for the `Normal` test method within `TUnit.TestProject.StringArgumentTests`. It specifically handles a test case where the argument is a multiline raw string literal. The code initializes test information, sets up a `TestBuilderContext`, creates a resettable factory for the test class instance, defines the method argument, and adds the metadata to a list. It includes a try-catch block to capture and report initialization exceptions as `FailedTestMetadata`.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/StringArgumentTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\t\t\t\t\t\t\t\tvar classDataIndex = 0;\n\t\t\t\t\t\t\t\t\tvar testMethodDataIndex = 0;\n\t\t\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.StringArgumentTests),\n\t\t\t\t\t\t\t\t\t\t\tName = \"Normal\",\n\t\t\t\t\t\t\t\t\t\t\tGenericTypeCount = 0,\n\t\t\t\t\t\t\t\t\t\t\tReturnType = typeof(void),\n\t\t\t\t\t\t\t\t\t\t\tAttributes = \n\t\t\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\t\t\t\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\"),\n\t\t\t\t\t\t\t\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(@\"\\\"),\n\t\t\t\t\t\t\t\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(@\"\\t\"),\n\t\t\t\t\t\t\t\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\\t\"),\n\t\t\t\t\t\t\t\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\\\\t\"),\n\t\t\t\t\t\t\t\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\\\\\\t\"),\n\t\t\t\t\t\t\t\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(\"\\\\\\\\t\"),\n\t\t\t\t\t\t\t\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(        \"\"\"\n        Hello\n        World\n        \"\"\"\n)\n\t\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\t\tParameters = \n\t\t\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tName = \"s\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.StringArgumentTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tType = typeof(global::TUnit.TestProject.StringArgumentTests),\n\t\t\t\t\t\t\t\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"StringArgumentTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tName = \"StringArgumentTests\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t\t\t\t\tName = \"StringArgumentTests\",\n\t\t\t\t\t\t\t\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\t\t\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t\t\t\t\t\t\t\tParameters = [],\n\t\t\t\t\t\t\t\t\t\t\t\tProperties = [],\n\t\t\t\t\t\t\t\t\t\t\t}),\n};\n\n\t\t\t\t\t\t\t\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\t\t\t\t\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\t\t\t\t\t\t\t\tglobal::TUnit.TestProject.StringArgumentTests? classInstance = null;\n\t\t\t\t\t\t\t\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\t\t\t\t\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\t\t\t\t\t\t\t\tstring methodArg = \"\"\"\n        Hello\n        World\n        \"\"\";\n\n\t\t\t\t\t\t\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.StringArgumentTests>(() => \n\t\t\t\t\t\t\t\t\t\t\tnew global::TUnit.TestProject.StringArgumentTests()\n\t\t\t\t\t\t\t\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\t\t\t\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\t\t\t\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.StringArgumentTests>\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS7:TUnit.TestProject.StringArgumentTests.Normal(string):0\",\n\t\t\t\t\t\t\t\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\t\t\t\t\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\t\t\t\t\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\t\t\t\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\t\t\t\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\t\t\t\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\t\t\t\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Normal(methodArg)),\n\t\t\t\t\t\t\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\t\t\t\t\t\t\tTestLineNumber = 5,\n\t\t\t\t\t\t\t\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\t\t\t\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\t\t\t\t\t\t\t\ttestBuilderContext = new();\n\t\t\t\t\t\t\t\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcatch (global::System.Exception exception)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.StringArgumentTests>\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS7:TUnit.TestProject.StringArgumentTests.Normal(string):0\",\n\t\t\t\t\t\t\t\t\t\t\tMethodName = $\"Normal\",\n\t\t\t\t\t\t\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"StringArgumentTests.Normal failed to initialize\", exception),\n\t\t\t\t\t\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\t\t\t\t\t\tTestLineNumber = 5,\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn nodes;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n```\n\n----------------------------------------\n\nTITLE: Creating FailedTestMetadata for exception handling in C#\nDESCRIPTION: This code adds a FailedTestMetadata object when test initialization fails. It captures the exception information and provides context about which test failed to initialize properly.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceClassCombinedWithDataSourceMethodTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod>\n{\n\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute:{classDataIndex}:CL-MDS0:global::TUnit.Core.MethodDataSourceAttribute:{testMethodDataIndex}:TL-MDS1:TUnit.TestProject.DataSourceClassCombinedWithDataSourceMethod(int).DataSourceClassCombinedWithDataSourceMethodTest(int):0\",\n\tMethodName = $\"DataSourceClassCombinedWithDataSourceMethodTest\",\n\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"DataSourceClassCombinedWithDataSourceMethod.DataSourceClassCombinedWithDataSourceMethodTest failed to initialize\", exception),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 10,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining GetOnlyDictionary Generic Class in C#\nDESCRIPTION: This class implements a dictionary-like structure with get-only access and additional methods for adding and removing items. It's part of the TUnit.Core.Data namespace.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_54\n\nLANGUAGE: C#\nCODE:\n```\npublic class GetOnlyDictionary<TKey, TValue>\n    where TKey :  notnull\n{\n    public GetOnlyDictionary() { }\n    public TValue this[TKey key] { get; }\n    public System.Collections.Generic.ICollection<TKey> Keys { get; }\n    public System.Collections.Generic.ICollection<TValue> Values { get; }\n    public TValue GetOrAdd(TKey key, System.Func<TKey, TValue> func) { }\n    public TValue GetOrAdd(TKey key, System.Func<TKey, TValue> func, out bool previouslyExisted) { }\n    public TValue? Remove(TKey key) { }\n    public bool TryGetValue(TKey key, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out TValue? value) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NotNullAssertionBuilderWrapper for Reference Types in C#\nDESCRIPTION: Wrapper for not-null assertions on reference types that overrides GetAwaiter to allow for async/await pattern use with assertion results.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_92\n\nLANGUAGE: C#\nCODE:\n```\n    public class NotNullAssertionBuilderWrapper<TActual> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>\n        where TActual :  class\n    {\n        public new System.Runtime.CompilerServices.TaskAwaiter<TActual> GetAwaiter() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Creating Failed TUnit Test Metadata on Initialization Error (Set 2) in C#\nDESCRIPTION: This snippet is part of a `catch` block within a test generation method (likely `Tests2`). If an exception occurs during the setup phase for the third set of arguments for the `DataDrivenTests.DataSource_Method` test, it creates a `FailedTestMetadata` object. This object captures the specific test ID, method name, the initialization exception, and source location (file path and line number) to report the failure accurately within the TUnit framework.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n\t\t\t\t\t}\n\t\t\t\t\tcatch (global::System.Exception exception)\n\t\t\t\t\t{\n\t\t\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.DataDrivenTests>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS2:TUnit.TestProject.DataDrivenTests.DataSource_Method(int):0\",\n\t\t\t\t\t\t\tMethodName = $\"DataSource_Method\",\n\t\t\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"DataDrivenTests.DataSource_Method failed to initialize\", exception),\n\t\t\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\t\t\tTestLineNumber = 5,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn nodes;\n\t\t\t\t}\n\t\t\t}\n```\n\n----------------------------------------\n\nTITLE: Registering Synchronous Tests using TUnit in C#\nDESCRIPTION: This code snippet initializes and registers synchronous tests within the TUnit framework. It uses a resettable class factory pattern to manage instances of test classes. Dependencies include TUnit.Core for core functionalities and TUnit.Core.Extensions for additional extensions. The function 'CollectTests' collects and returns metadata for the specified session ID.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/PolyfillTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class BasicTests : TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tSourceRegistrar.Register(new BasicTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testClassType = typeof(global::TUnit.TestProject.BasicTests);\n\t\t\tvar methodInfo = global::TUnit.Core.Helpers.MethodInfoRetriever.GetMethodInfo(typeof(global::TUnit.TestProject.BasicTests), \"SynchronousTest\", 0, []);\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\n\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.BasicTests>(() => \n\t\t\tnew global::TUnit.TestProject.BasicTests()\n\t\t\t, sessionId, testBuilderContext);\n\n\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.BasicTests>\n\t\t\t{\n\t\t\t\tTestId = $\"TUnit.TestProject.BasicTests.SynchronousTest:0\",\n\t\t\t\tTestClassArguments = [],\n\t\t\t\tTestMethodArguments = [],\n\t\t\t\tTestClassProperties = [],\n\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\tRepeatLimit = 0,\n\t\t\t\tMethodInfo = methodInfo,\n\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.SynchronousTest()),\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 5,\n\t\t\t\tTestAttributes = [ new global::TUnit.Core.TestAttribute()\n{\n    \n} ],\n\t\t\t\tClassAttributes = [  ],\n\t\t\t\tAssemblyAttributes = [  ],\n\t\t\t\tDataAttributes = [  ],\n\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t});\n\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\ttestBuilderContext = new();\n\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t}\n\t\tcatch (global::System.Exception exception)\n\t\t{\n\t\t\tnodes.Add(new FailedInitializationTest\n\t\t\t{\n\t\t\t\tTestId = $\"TUnit.TestProject.BasicTests.SynchronousTest:0\",\n\t\t\t\tTestClass = typeof(global::TUnit.TestProject.BasicTests),\n\t\t\t\tReturnType = global::TUnit.Core.Helpers.MethodInfoRetriever.GetMethodInfo(typeof(global::TUnit.TestProject.BasicTests), \"SynchronousTest\", 0, []).ReturnType,\n\t\t\t\tParameterTypeFullNames = [],\n\t\t\t\tTestName = \"SynchronousTest\",\n\t\t\t\tTestFilePath = @\"\",\n\t\t\t\tTestLineNumber = 5,\n\t\t\t\tException = exception,\n\t\t\t});\n\t\t}\n\t\treturn nodes;\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Worker Service Interface for Playwright Tests in C#\nDESCRIPTION: The `IWorkerService` interface defines a contract for services that operate within a TUnit test worker context. It requires implementing classes to provide asynchronous methods for disposal (`DisposeAsync`) and resetting state (`ResetAsync`), potentially used for managing shared resources across tests running in the same worker.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet2_0.Net4_7.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IWorkerService\n{\n    System.Threading.Tasks.Task DisposeAsync();\n    System.Threading.Tasks.Task ResetAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Nullable Byte Argument Tests\nDESCRIPTION: Defines the method to collect tests for NullableByteArgumentTests, generating a list of test metadata for execution. Inputs include a session ID, and outputs are lists of test metadata. Utilizes TUnit Core interfaces and methods.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/NullableByteArgumentTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n    return\n    [\n        ..Tests0(sessionId),\n        ..Tests1(sessionId),\n    ];\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Registering Tests with TUnit Framework in C#\nDESCRIPTION: Defines a partial class that implements ITestSource interface to register test cases with the TUnit framework. The Initialise() method is automatically called at module initialization to register the test source.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class DataDrivenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new DataDrivenTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing and Registering TUnit Class Hook Source\nDESCRIPTION: Static initializer method that creates an instance of the Hooks_CleanupTests class and registers it with the SourceRegistrar. This ensures the hook source is available to the TUnit framework when tests are executed.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AfterTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tvar instance = new Hooks_CleanupTests();\n\tSourceRegistrar.RegisterClassHookSource(instance);\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Exceptions in TUnit Test Generation in C#\nDESCRIPTION: This snippet shows exception handling during TUnit test data generation. It captures and logs initialization failures using a custom TestFailedInitializationException. This ensures that issues during setup are properly reported with relevant metadata.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.Typed.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n  nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.DataSourceGeneratorTests>\n  {\n    TestId = $\"global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute:{classDataIndex}:CL-GAC0:global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<int>:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.DataSourceGeneratorTests(int,string,bool).GeneratedData_Method(int):0\",\n    MethodName = $\"GeneratedData_Method\",\n    Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"DataSourceGeneratorTests.GeneratedData_Method failed to initialize\", exception),\n    TestFilePath = @\"\",\n    TestLineNumber = 9,\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Static Hook Method Base Class\nDESCRIPTION: Abstract base class for static hook methods with required members and attributes.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_64\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class StaticHookMethod : System.IEquatable<TUnit.Core.Hooks.StaticHookMethod> {\n    [System.Runtime.CompilerServices.RequiredMember]\n    public System.Attribute[] AssemblyAttributes { get; init; }\n    public System.Collections.Generic.IEnumerable<System.Attribute> Attributes { get; }\n    // ... additional properties\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Skip Attribute for Playwright Tests in C#\nDESCRIPTION: The `PlaywrightSkipAttribute` class inherits from `TUnit.Core.SkipAttribute` and allows tests to be skipped based on specific combinations of operating systems (Windows, Linux, OSX) and Playwright browsers (Chromium, Firefox, Webkit). It uses a `Targets` enum (with `[Flags]`) and overrides the `ShouldSkip` method to implement the conditional skipping logic based on the test context.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet2_0.Net4_7.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic class PlaywrightSkipAttribute : TUnit.Core.SkipAttribute\n{\n    public PlaywrightSkipAttribute(params TUnit.Playwright.PlaywrightSkipAttribute.Targets[] combinations) { }\n    public TUnit.Core.TestContext? TestContext { get; set; }\n    public override System.Threading.Tasks.Task<bool> ShouldSkip(TUnit.Core.BeforeTestContext context) { }\n    [System.Flags]\n    public enum Targets : short\n    {\n        Windows = 1,\n        Linux = 2,\n        OSX = 4,\n        Chromium = 8,\n        Firefox = 16,\n        Webkit = 32,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata in C# for TUnit Framework\nDESCRIPTION: Method that generates test metadata for TUnit test cases. It creates test information including class details, method parameters, attribute configurations, and handles test initialization failures. The code supports parameterized tests with various argument types and includes error handling.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests2083.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests5(string sessionId)\n{\n    global::System.Collections.Generic.List<TestMetadata> nodes = [];\n    var classDataIndex = 0;\n    var testMethodDataIndex = 0;\n    try\n    {\n        var testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n        {\n            Type = typeof(global::TUnit.TestProject.Bugs._2083.Tests),\n            Name = \"MyTest\",\n            GenericTypeCount = 0,\n            ReturnType = typeof(void),\n            Attributes = \n            [\n                new global::TUnit.Core.TestAttribute(),\n                new global::TUnit.Core.ArgumentsAttribute(0),\n                new global::TUnit.Core.ArgumentsAttribute(255),\n                new global::TUnit.Core.ArgumentsAttribute(32767),\n                new global::TUnit.Core.ArgumentsAttribute('\\uffff'),\n                new global::TUnit.Core.ArgumentsAttribute(2147483647),\n                new global::TUnit.Core.ArgumentsAttribute(9223372036854775807L)\n            ],\n            Parameters = \n            [\n                new global::TUnit.Core.SourceGeneratedParameterInformation<long>\n                {\n                    Name = \"value\",\n                    Attributes = [],\n                },\n            ],\n            Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._2083.Tests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n            {\n                Type = typeof(global::TUnit.TestProject.Bugs._2083.Tests),\n                Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Tests2083\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n                {\n                    Name = \"Tests2083\",\n                    Attributes = [],\n                }),\n                Name = \"Tests\",\n                Namespace = \"TUnit.TestProject.Bugs._2083\",\n                Attributes = [],\n                Parameters = [],\n                Properties = [],\n            }),\n};\n\n            var testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n            var testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n            global::TUnit.TestProject.Bugs._2083.Tests? classInstance = null;\n            object?[]? classInstanceArguments = null;\n            classInstanceArguments = [];\n\n            long methodArg = 9223372036854775807L;\n\n            var resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._2083.Tests>(() => \n            new global::TUnit.TestProject.Bugs._2083.Tests()\n            , sessionId, testBuilderContext);\n            var resettableClassFactory = resettableClassFactoryDelegate();\n\n\n            nodes.Add(new TestMetadata<global::TUnit.TestProject.Bugs._2083.Tests>\n            {\n                TestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS5:TUnit.TestProject.Bugs._2083.Tests.MyTest(long):0\",\n                TestClassArguments = [],\n                TestMethodArguments = [methodArg],\n                TestClassProperties = [],\n                CurrentRepeatAttempt = 0,\n                RepeatLimit = 0,\n                ResettableClassFactory = resettableClassFactory,\n                TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.MyTest(methodArg)),\n                TestFilePath = @\"\",\n                TestLineNumber = 5,\n                TestMethod = testInformation,\n                TestBuilderContext = testBuilderContext,\n            });\n            resettableClassFactory = resettableClassFactoryDelegate();\n            testBuilderContext = new();\n            testBuilderContextAccessor.Current = testBuilderContext;\n        }\n        catch (global::System.Exception exception)\n        {\n            nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._2083.Tests>\n            {\n                TestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS5:TUnit.TestProject.Bugs._2083.Tests.MyTest(long):0\",\n                MethodName = $\"MyTest\",\n                Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"Tests.MyTest failed to initialize\", exception),\n                TestFilePath = @\"\",\n                TestLineNumber = 5,\n            });\n        }\n        return nodes;\n    }\n```\n\n----------------------------------------\n\nTITLE: Source Generated Assembly Information Class\nDESCRIPTION: Represents metadata about a generated assembly including its attributes and name. Implements equality comparison and provides factory method for instance creation.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_48\n\nLANGUAGE: C#\nCODE:\n```\npublic class SourceGeneratedAssemblyInformation : System.IEquatable<TUnit.Core.SourceGeneratedAssemblyInformation>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of your compiler.\", true)]\n    public SourceGeneratedAssemblyInformation() { }\n    public System.Attribute[] Attributes { get; init; }\n    public string Name { get; init; }\n    public virtual bool Equals(TUnit.Core.SourceGeneratedAssemblyInformation? other) { }\n    public override int GetHashCode() { }\n    public static TUnit.Core.SourceGeneratedAssemblyInformation GetOrAdd(string name, System.Func<TUnit.Core.SourceGeneratedAssemblyInformation> factory) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BrowserTest Class with Playwright in C#\nDESCRIPTION: Defines the \"BrowserTest\" class, inheriting from \"PlaywrightTest\" in C#. It includes a constructor with launch options, browser setup and teardown tasks, and a method for creating a new browser context. It relies on the Microsoft.Playwright library and TUnit framework, and is used for managing browser-level tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nnamespace TUnit.Playwright\n{\n    public class BrowserTest : TUnit.Playwright.PlaywrightTest\n    {\n        public BrowserTest() { }\n        public BrowserTest(Microsoft.Playwright.BrowserTypeLaunchOptions options) { }\n        public Microsoft.Playwright.IBrowser Browser { get; }\n        [TUnit.Core.Before(TUnit.Core.HookType.Test, \"\", 0)]\n        public System.Threading.Tasks.Task BrowserSetup() { }\n        [TUnit.Core.After(TUnit.Core.HookType.Test, \"\", 0)]\n        public System.Threading.Tasks.Task BrowserTearDown(TUnit.Core.TestContext testContext) { }\n        public System.Threading.Tasks.Task<Microsoft.Playwright.IBrowserContext> NewContext(Microsoft.Playwright.BrowserNewContextOptions options) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Initializing and Collecting Matrix Tests for ImplicitConversion Method\nDESCRIPTION: This snippet defines a partial class for collecting matrix tests. It initializes the test source and generates test cases for the ImplicitConversion method using matrix data sources.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MatrixTests.Test.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tglobal::TUnit.Core.SourceRegistrar.Register(new MatrixTests());\n}\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn Tests0(sessionId);\n}\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.MatrixTests),\n\t\t\tName = \"ImplicitConversion\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.Core.MatrixDataSourceAttribute()\n\t\t\t],\n\t\t\tParameters = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<OneOf<global::TUnit.TestProject.TestEnum, TestEnum2>>\n\t\t\t\t{\n\t\t\t\t\tName = \"enum\",\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.MatrixAttribute(global::TUnit.TestProject.TestEnum.One, Two)\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<bool>\n\t\t\t\t{\n\t\t\t\t\tName = \"boolean\",\n\t\t\t\t\tAttributes = \n\t\t\t\t\t[\n\t\t\t\t\t\tnew global::TUnit.Core.MatrixAttribute()\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.MatrixTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.MatrixTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"MatrixTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"MatrixTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"MatrixTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: PageTest Class Definition in C#\nDESCRIPTION: A test class for page-level testing that inherits from ContextTest. Manages page instances and provides setup methods for Playwright page testing.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class PageTest : TUnit.Playwright.ContextTest\n{\n    public PageTest() { }\n    public Microsoft.Playwright.IPage Page { get; }\n    [TUnit.Core.Before(TUnit.Core.HookType.Test, \"\", 0)]\n    public System.Threading.Tasks.Task PageSetup() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting TUnit Test Metadata for StringArgumentTests in C#\nDESCRIPTION: This C# method `CollectTests` is part of the source-generated `StringArgumentTests` class. It implements the `ITestSource` interface method responsible for gathering all test metadata for the associated test class. It takes a `sessionId` string as input and returns a read-only list of `TestMetadata`. The implementation aggregates the results from multiple private helper methods (`Tests0`, `Tests1`, ..., `Tests7`), each responsible for generating metadata for a specific set of test arguments or configurations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/StringArgumentTests.Test.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\t..Tests0(sessionId),\n\t\t\t..Tests1(sessionId),\n\t\t\t..Tests2(sessionId),\n\t\t\t..Tests3(sessionId),\n\t\t\t..Tests4(sessionId),\n\t\t\t..Tests5(sessionId),\n\t\t\t..Tests6(sessionId),\n\t\t\t..Tests7(sessionId),\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Initializing MatrixTests Class for Source Generation\nDESCRIPTION: This snippet defines a partial class MatrixTests that implements ITestSource interface. It includes an Initialise method to register the class with TUnit.Core.SourceRegistrar.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/MatrixTests.Test.verified.txt#2025-04-22_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class MatrixTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new MatrixTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Assemblies with TUnit Core at Module Initialization\nDESCRIPTION: This static class uses the ModuleInitializer attribute to register multiple assemblies with TUnit.Core.SourceRegistrar at application startup. It loads assemblies like NUnit Framework, CodeAnalysis tools, and various TUnit components.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyLoaderTests.Test.Net4_7.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[  \n// <auto-generated/>\n#pragma warning disable\npublic static class AssemblyLoader_Guid\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialize()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"nunit.framework, Version=4.3.2.0, Culture=neutral, PublicKeyToken=2638cd05610744eb\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"nunit.engine.core, Version=3.18.1.0, Culture=neutral, PublicKeyToken=2638cd05610744eb\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"TUnit.Core.SourceGenerator.Tests, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"TUnit.Core.SourceGenerator, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"Microsoft.CodeAnalysis, Version=4.7.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"NuGet.Protocol, Version=6.13.2.1, Culture=neutral, PublicKeyToken=31bf3856ad364e35\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"Verify, Version=1.0.0.0, Culture=neutral, PublicKeyToken=c7a34512ecd69090\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"Microsoft.CodeAnalysis.Analyzer.Testing, Version=1.1.2.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"Microsoft.CodeAnalysis.CSharp, Version=4.7.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"TUnit.Assertions, Version=1.0.0.0, Culture=neutral, PublicKeyToken=b8d4030011dbd70c\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"TUnit.TestProject.Library, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"TUnit.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=b8d4030011dbd70c\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"Confluent.SchemaRegistry.Serdes.Protobuf, Version=2.10.0.0, Culture=neutral, PublicKeyToken=6f85e24b3ffa9bd0\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"WireMock.Net, Version=1.7.4.0, Culture=neutral, PublicKeyToken=c8d65537854e1f03\"));\n\t}\n}\n\n]\n```\n\n----------------------------------------\n\nTITLE: Source Generated TUnit Test Source Implementation in C#\nDESCRIPTION: This auto-generated C# code defines a partial class `DataSourceGeneratorTests` that implements `TUnit.Core.Interfaces.SourceGenerator.ITestSource`. It uses a `ModuleInitializer` to register itself with TUnit's `SourceRegistrar`. The `CollectTests` method aggregates test metadata generated by separate methods (e.g., `Tests0`, `Tests1`). The `Tests0` method specifically generates `TestMetadata` for the `GeneratedData_Method3` test, combining data from class-level and method-level `AutoFixtureGeneratorAttribute` instances, similar to the previous snippet.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataSourceGeneratorTests.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class DataSourceGeneratorTests : TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tSourceRegistrar.Register(new DataSourceGeneratorTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn\n\t\t[\n\t\t\t..Tests0(sessionId),\n\t\t\t..Tests1(sessionId),\n\t\t];\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testClassType = typeof(global::TUnit.TestProject.DataSourceGeneratorTests);\n\t\t\tvar methodInfo = global::TUnit.Core.Helpers.MethodInfoRetriever.GetMethodInfo(typeof(global::TUnit.TestProject.DataSourceGeneratorTests), \"GeneratedData_Method3\", 0, [typeof(global::System.Int32), typeof(global::System.String), typeof(global::System.Boolean)]);\n\n\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\tvar classArgDataGeneratorMetadata = new DataGeneratorMetadata\n{\n   Type = TUnit.Core.Enums.DataGeneratorType.Parameters,\n   TestClassType = testClassType,\n   ParameterInfos = typeof(global::TUnit.TestProject.DataSourceGeneratorTests).GetConstructors().First().GetParameters(),\n   PropertyInfo = null,\n   TestBuilderContext = testBuilderContextAccessor,\n   TestSessionId = sessionId,\n};\n\t\t\tvar classDataAttribute = new global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<global::System.Int32, global::System.String, global::System.Boolean>()\n{\n    \n};\n\n\t\t\tvar classArgGeneratedDataArray = classDataAttribute.GenerateDataSources(classArgDataGeneratorMetadata);\n\n\t\t\tforeach (var classArgGeneratedDataAccessor in classArgGeneratedDataArray)\n\t\t\t{\n\t\t\t\tclassDataIndex++;\n\t\t\t\tvar methodArgDataGeneratorMetadata = new DataGeneratorMetadata\n{\n   Type = TUnit.Core.Enums.DataGeneratorType.Parameters,\n   TestClassType = testClassType,\n   ParameterInfos = methodInfo.GetParameters(),\n   PropertyInfo = null,\n   TestBuilderContext = testBuilderContextAccessor,\n   TestSessionId = sessionId,\n};\n\t\t\t\tvar methodDataAttribute = new global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute()\n{\n    \n};\n\n\t\t\t\tvar methodArgGeneratedDataArray = methodDataAttribute.GenerateDataSources(methodArgDataGeneratorMetadata);\n\n\t\t\t\tforeach (var methodArgGeneratedDataAccessor in methodArgGeneratedDataArray)\n\t\t\t\t{\n\t\t\t\t\ttestMethodDataIndex++;\n\t\t\t\t\tvar classArgGeneratedData = classArgGeneratedDataAccessor();\n\t\t\t\t\tglobal::System.Int32 classArg = classArgGeneratedData.Item1;\n\t\t\t\t\tglobal::System.String classArg1 = classArgGeneratedData.Item2;\n\t\t\t\t\tglobal::System.Boolean classArg2 = classArgGeneratedData.Item3;\n\n\n\t\t\t\t\tvar methodArgGeneratedData = methodArgGeneratedDataAccessor();\n\t\t\t\t\tglobal::System.Int32 methodArg = methodArgGeneratedData.Item1;\n\t\t\t\t\tglobal::System.String methodArg1 = methodArgGeneratedData.Item2;\n\t\t\t\t\tglobal::System.Boolean methodArg2 = methodArgGeneratedData.Item3;\n\n\t\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.DataSourceGeneratorTests>(() => \n\t\t\t\t\tnew global::TUnit.TestProject.DataSourceGeneratorTests(classArg, classArg1, classArg2)\n\t\t\t\t\t, sessionId, testBuilderContext);\n\n\t\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\t\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.DataSourceGeneratorTests>\n\t\t\t\t\t{\n\t\t\t\t\t\tTestId = $\"global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute<global::System.Int32, global::System.String, global::System.Boolean>:{classDataIndex}:CL-GAC0:global::TUnit.TestProject.DataSourceGeneratorTests.AutoFixtureGeneratorAttribute:{testMethodDataIndex}:TL-GAC0:TUnit.TestProject.DataSourceGeneratorTests(System.Int32,System.String,System.Boolean).GeneratedData_Method3(System.Int32,System.String,System.Boolean):0\",\n\t\t\t\t\t\tTestClassArguments = [classArg, classArg1, classArg2],\n\t\t\t\t\t\tTestMethodArguments = [methodArg, methodArg1, methodArg2],\n```\n\n----------------------------------------\n\nTITLE: Test Hook Interfaces Implementation in C#\nDESCRIPTION: Definition of interfaces for test lifecycle hooks including class, test, and session level hooks. Each interface provides methods to collect different types of hooks using a session identifier.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_66\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IClassHookSource\n{\n    System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.ClassHookContext>> CollectAfterClassHooks(string sessionId);\n    System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.ClassHookContext>> CollectAfterEveryClassHooks(string sessionId);\n    System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.ClassHookContext>> CollectBeforeClassHooks(string sessionId);\n    System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring BeforeClass Hook with Both Context and CancellationToken Parameters in C#\nDESCRIPTION: Defines a BeforeClassHookMethod that calls the BeforeAllSetUpWithContext method with both ClassHookContext and CancellationToken parameters. This hook provides context information and supports cancellation for the setup operation.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/BeforeTests.Test.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.StaticHookMethod<global::TUnit.Core.ClassHookContext>> CollectBeforeClassHooks(string sessionId)\n{\n\treturn\n\t[\n\t\tnew global::TUnit.Core.Hooks.BeforeClassHookMethod\n\t\t{\n\t\t\tMethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.BeforeTests.SetupTests),\n\t\t\t\tName = \"BeforeAllSetUpWithContext\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.BeforeAttribute(global::TUnit.Core.HookType.Class)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.ClassHookContext>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"context\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::System.Threading.CancellationToken>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"cancellationToken\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}\n```\n\n----------------------------------------\n\nTITLE: Handling Initialization Exceptions in TUnit Tests\nDESCRIPTION: This code snippet captures exceptions that occur during the initialization of tests in a TUnit framework project. It records failed tests by storing relevant metadata, including the test ID, method details, and the exception encountered. It is dependent on the TUnit.Core and is designed to integrate seamlessly into the test-executing sequence, ensuring that test failures are properly documented and reported.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests2083.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n    nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.Bugs._2083.Tests>\n    {\n        TestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS2:TUnit.TestProject.Bugs._2083.Tests.MyTest(long):0\",\n        MethodName = $\"MyTest\",\n        Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"Tests.MyTest failed to initialize\", exception),\n        TestFilePath = @\"\",\n        TestLineNumber = 5,\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Equivalent To Equality Comparer in C#\nDESCRIPTION: This class implements an IEqualityComparer for equivalence comparisons. It includes methods for equality comparison and hash code generation, as well as properties for tracking comparison failures.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_124\n\nLANGUAGE: C#\nCODE:\n```\npublic class EquivalentToEqualityComparer<T> : System.Collections.Generic.IEqualityComparer<T>\n{\n    public EquivalentToEqualityComparer() { }\n    public EquivalentToEqualityComparer(TUnit.Assertions.CompareOptions compareOptions) { }\n    public TUnit.Assertions.ComparisonFailure[]? ComparisonFailures { get; }\n    public virtual int? EnumerableIndex { get; protected set; }\n    public virtual bool Equals(T? x, T? y) { }\n    public string GetFailureMessages() { }\n    public int GetHashCode([System.Diagnostics.CodeAnalysis.DisallowNull] T obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Default Parallel Limiter for Playwright Tests in C#\nDESCRIPTION: The `DefaultPlaywrightParallelLimiter` class implements the `TUnit.Core.Interfaces.IParallelLimit` interface. It provides a default mechanism to limit the number of Playwright tests that can run in parallel, likely based on available resources or Playwright's own recommendations.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet2_0.Net4_7.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class DefaultPlaywrightParallelLimiter : TUnit.Core.Interfaces.IParallelLimit\n{\n    public DefaultPlaywrightParallelLimiter() { }\n    public int Limit { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering TUnit Tests by Custom Property (Shell)\nDESCRIPTION: This command runs TUnit tests that are annotated with a custom property named `MyFilterName` where the property's value contains the substring `SomeValue`. The filter uses the `dotnet run` command, the `--treenode-filter` flag, and a pattern targeting tests based on a custom property attribute and partial value matching with wildcards.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/test-filters.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ndotnet run --treenode-filter /*/*/*/*[MyFilterName=*SomeValue*]\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for TUnit Priority Filtering Tests in C#\nDESCRIPTION: This snippet defines the Tests0 method that generates test metadata for priority filtering tests. It creates TestMetadata objects with test information, including class and method details, attributes, and execution delegates.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/PriorityFilteringTests.Test.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.PriorityFilteringTests),\n\t\t\tName = \"Low_1\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\tnew global::TUnit.TestProject.PriorityAttribute(global::TUnit.TestProject.Enums.PriorityLevel.Low)\n\t\t\t],\n\t\t\tParameters = [],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.PriorityFilteringTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.PriorityFilteringTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"PriorityFilteringTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"PriorityFilteringTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"PriorityFilteringTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\tglobal::TUnit.TestProject.PriorityFilteringTests? classInstance = null;\n\t\tobject?[]? classInstanceArguments = null;\n\t\tclassInstanceArguments = [];\n\n\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.PriorityFilteringTests>(() => \n\t\tnew global::TUnit.TestProject.PriorityFilteringTests()\n\t\t, sessionId, testBuilderContext);\n\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.PriorityFilteringTests>\n\t\t{\n\t\t\tTestId = $\"TUnit.TestProject.PriorityFilteringTests.Low_1:0\",\n\t\t\tTestClassArguments = [],\n\t\t\tTestMethodArguments = [],\n\t\t\tTestClassProperties = [],\n\t\t\tCurrentRepeatAttempt = 0,\n\t\t\tRepeatLimit = 0,\n\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Low_1()),\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 42,\n\t\t\tTestMethod = testInformation,\n\t\t\tTestBuilderContext = testBuilderContext,\n\t\t});\n\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\ttestBuilderContext = new();\n\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t}\n\tcatch (global::System.Exception exception)\n\t{\n\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.PriorityFilteringTests>\n\t\t{\n\t\t\tTestId = $\"TUnit.TestProject.PriorityFilteringTests.Low_1:0\",\n\t\t\tMethodName = $\"Low_1\",\n\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"PriorityFilteringTests.Low_1 failed to initialize\", exception),\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 42,\n\t\t});\n\t}\n\treturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata in C#\nDESCRIPTION: Creates test metadata including class information, properties, and test methods. It sets up various attributes and data sources for properties.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/InheritedPropertySetterTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.PropertySetterTests),\n\tName = \"Test\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute()\n\t],\n\tParameters = [],\n\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.PropertySetterTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t{\n\t\t// ... (class information details)\n\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: Registering Test Method: GenericMethodDataSource\nDESCRIPTION: This snippet demonstrates the registration of a test method 'GenericMethodDataSource' with a MethodDataSourceAttribute. It includes parameter information and handles data source initialization.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/InheritedTestsFromDifferentProjectTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n{\n\tType = typeof(global::TUnit.TestProject.InheritedTestsFromDifferentProjectTests),\n\tName = \"GenericMethodDataSource\",\n\tGenericTypeCount = 0,\n\tReturnType = typeof(void),\n\tAttributes = \n\t[\n\t\tnew global::TUnit.Core.TestAttribute(),\n\t\tnew global::TUnit.Core.MethodDataSourceAttribute<global::TUnit.TestProject.TestData>(\"Foo\")\n\t],\n\tParameters = \n\t[\n\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<string>\n\t\t{\n\t\t\tName = \"value\",\n\t\t\tAttributes = [],\n\t\t},\n\t],\n\t// ... (class information)\n};\n\n// ... (test metadata creation and registration)\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.InheritedTestsFromDifferentProjectTests>\n{\n\tTestId = $\"global::TUnit.Core.MethodDataSourceAttribute<global::TUnit.TestProject.TestData>:{testMethodDataIndex}:TL-MDS0:TUnit.TestProject.InheritedTestsFromDifferentProjectTests.GenericMethodDataSource(string):0\",\n\t// ... (other metadata properties)\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing GitHubReporter in C#\nDESCRIPTION: Defines a reporter class for GitHub, implementing various interfaces for test host extensions and data consumption.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class GitHubReporter : Microsoft.Testing.Platform.Extensions.IExtension, Microsoft.Testing.Platform.Extensions.TestHost.IDataConsumer, Microsoft.Testing.Platform.Extensions.TestHost.ITestApplicationLifecycleCallbacks, Microsoft.Testing.Platform.Extensions.TestHost.ITestHostExtension, TUnit.Engine.Framework.IFilterReceiver\n{\n    public GitHubReporter(Microsoft.Testing.Platform.Extensions.IExtension extension) { }\n    public System.Type[] DataTypesConsumed { get; }\n    public string Description { get; }\n    public string DisplayName { get; }\n    public string? Filter { get; set; }\n    public string Uid { get; }\n    public string Version { get; }\n    public System.Threading.Tasks.Task AfterRunAsync(int exitCode, System.Threading.CancellationToken cancellation) { }\n    public System.Threading.Tasks.Task BeforeRunAsync(System.Threading.CancellationToken cancellationToken) { }\n    public System.Threading.Tasks.Task ConsumeAsync(Microsoft.Testing.Platform.Extensions.Messages.IDataProducer dataProducer, Microsoft.Testing.Platform.Extensions.Messages.IData value, System.Threading.CancellationToken cancellationToken) { }\n    public System.Threading.Tasks.Task<bool> IsEnabledAsync() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting After Test Instance Hooks in C#\nDESCRIPTION: Method that returns an empty collection of instance hook methods to be executed after each test. This implements part of the ITestHookSource interface.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Hooks1589.Test.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId)\n{\n\treturn\n\t[\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Test Metadata\nDESCRIPTION: Method that aggregates test metadata from multiple test collections. Implements ITestSource interface requirement.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ArgumentWithImplicitConverterTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn\n\t[\n\t\t..Tests0(sessionId),\n\t\t..Tests1(sessionId),\n\t\t..Tests2(sessionId),\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Timing Class for Test Execution Measurement\nDESCRIPTION: A class for tracking execution time of test steps, containing properties for the step name, start time, end time, and calculated duration. This is used for performance monitoring and reporting in test execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_59\n\nLANGUAGE: C#\nCODE:\n```\npublic Timing(string StepName, System.DateTimeOffset Start, System.DateTimeOffset End) { }\npublic System.TimeSpan Duration { get; }\npublic System.DateTimeOffset End { get; init; }\npublic System.DateTimeOffset Start { get; init; }\npublic string StepName { get; init; }\n```\n\n----------------------------------------\n\nTITLE: Defining Core Test Framework Interfaces in C#\nDESCRIPTION: Collection of interfaces defining the contract for test execution, events, and hooks in the TUnit framework.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_57\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IHookExecutor\n{\n    System.Threading.Tasks.ValueTask ExecuteAfterAssemblyHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.AssemblyHookContext context, System.Func<System.Threading.Tasks.ValueTask> action);\n    System.Threading.Tasks.ValueTask ExecuteAfterClassHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.ClassHookContext context, System.Func<System.Threading.Tasks.ValueTask> action);\n    System.Threading.Tasks.ValueTask ExecuteAfterTestDiscoveryHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestDiscoveryContext context, System.Func<System.Threading.Tasks.ValueTask> action);\n    System.Threading.Tasks.ValueTask ExecuteAfterTestHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestContext context, System.Func<System.Threading.Tasks.ValueTask> action);\n    System.Threading.Tasks.ValueTask ExecuteAfterTestSessionHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestSessionContext context, System.Func<System.Threading.Tasks.ValueTask> action);\n    System.Threading.Tasks.ValueTask ExecuteBeforeAssemblyHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.AssemblyHookContext context, System.Func<System.Threading.Tasks.ValueTask> action);\n    System.Threading.Tasks.ValueTask ExecuteBeforeClassHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.ClassHookContext context, System.Func<System.Threading.Tasks.ValueTask> action);\n    System.Threading.Tasks.ValueTask ExecuteBeforeTestDiscoveryHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.BeforeTestDiscoveryContext context, System.Func<System.Threading.Tasks.ValueTask> action);\n    System.Threading.Tasks.ValueTask ExecuteBeforeTestHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestContext context, System.Func<System.Threading.Tasks.ValueTask> action);\n    System.Threading.Tasks.ValueTask ExecuteBeforeTestSessionHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestSessionContext context, System.Func<System.Threading.Tasks.ValueTask> action);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a New .NET Console Application Using dotnet CLI - PowerShell\nDESCRIPTION: This snippet demonstrates how to initialize a new .NET console project using the dotnet CLI in PowerShell. The command sets up the project structure required for adding TUnit and writing tests. The only required input is the desired project name. The output is a directory containing a basic .NET console application.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/installing.md#2025-04-22_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\ndotnet new console --name YourTestProjectNameHere\n```\n\n----------------------------------------\n\nTITLE: Handling Subsequent Test Repetitions in TUnit\nDESCRIPTION: This snippet shows the implementation for the second and third repetitions of the 'Three' test method. The code structure is identical to the first repetition, but with updated iteration counters and TestIds. This pattern demonstrates how TUnit manages state across multiple test executions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/RepeatTests.Test.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests2(string sessionId)\n{\n    global::System.Collections.Generic.List<TestMetadata> nodes = [];\n    var classDataIndex = 0;\n    var testMethodDataIndex = 0;\n    try\n    {\n        var testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n        {\n            Type = typeof(global::TUnit.TestProject.RepeatTests),\n            Name = \"Three\",\n            GenericTypeCount = 0,\n            ReturnType = typeof(void),\n            Attributes = \n            [\n                new global::TUnit.Core.TestAttribute()\n            ],\n            Parameters = [],\n            Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.RepeatTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n            {\n                Type = typeof(global::TUnit.TestProject.RepeatTests),\n                Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"RepeatTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n                {\n                    Name = \"RepeatTests\",\n                    Attributes = [],\n                }),\n                Name = \"RepeatTests\",\n                Namespace = \"TUnit.TestProject\",\n                Attributes = \n                [\n                    new global::TUnit.Core.RepeatAttribute(3)\n                ],\n                Parameters = [],\n                Properties = [],\n            }),\n};\n\n            var testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n            var testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n            global::TUnit.TestProject.RepeatTests? classInstance = null;\n            object?[]? classInstanceArguments = null;\n            classInstanceArguments = [];\n\n            var resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.RepeatTests>(() => \n            new global::TUnit.TestProject.RepeatTests()\n            , sessionId, testBuilderContext);\n            var resettableClassFactory = resettableClassFactoryDelegate();\n\n\n            nodes.Add(new TestMetadata<global::TUnit.TestProject.RepeatTests>\n            {\n                TestId = $\"TUnit.TestProject.RepeatTests.Three:2\",\n                TestClassArguments = [],\n                TestMethodArguments = [],\n                TestClassProperties = [],\n                CurrentRepeatAttempt = 2,\n                RepeatLimit = 3,\n                ResettableClassFactory = resettableClassFactory,\n                TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Three()),\n                TestFilePath = @\"\",\n                TestLineNumber = 20,\n                TestMethod = testInformation,\n                TestBuilderContext = testBuilderContext,\n            });\n            resettableClassFactory = resettableClassFactoryDelegate();\n            testBuilderContext = new();\n            testBuilderContextAccessor.Current = testBuilderContext;\n        }\n        catch (global::System.Exception exception)\n        {\n            nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.RepeatTests>\n            {\n                TestId = $\"TUnit.TestProject.RepeatTests.Three:2\",\n                MethodName = $\"Three\",\n                Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"RepeatTests.Three failed to initialize\", exception),\n                TestFilePath = @\"\",\n                TestLineNumber = 20,\n            });\n        }\n        return nodes;\n    }\n```\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests3(string sessionId)\n{\n    global::System.Collections.Generic.List<TestMetadata> nodes = [];\n    var classDataIndex = 0;\n    var testMethodDataIndex = 0;\n    try\n    {\n        var testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n        {\n            Type = typeof(global::TUnit.TestProject.RepeatTests),\n            Name = \"Three\",\n            GenericTypeCount = 0,\n            ReturnType = typeof(void),\n            Attributes = \n            [\n                new global::TUnit.Core.TestAttribute()\n            ],\n            Parameters = [],\n            Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.RepeatTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n            {\n                Type = typeof(global::TUnit.TestProject.RepeatTests),\n                Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"RepeatTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n                {\n                    Name = \"RepeatTests\",\n                    Attributes = [],\n                }),\n                Name = \"RepeatTests\",\n                Namespace = \"TUnit.TestProject\",\n                Attributes = \n                [\n                    new global::TUnit.Core.RepeatAttribute(3)\n                ],\n                Parameters = [],\n                Properties = [],\n            }),\n};\n\n            var testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n            var testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n            global::TUnit.TestProject.RepeatTests? classInstance = null;\n            object?[]? classInstanceArguments = null;\n            classInstanceArguments = [];\n\n            var resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.RepeatTests>(() => \n            new global::TUnit.TestProject.RepeatTests()\n            , sessionId, testBuilderContext);\n            var resettableClassFactory = resettableClassFactoryDelegate();\n\n\n            nodes.Add(new TestMetadata<global::TUnit.TestProject.RepeatTests>\n            {\n                TestId = $\"TUnit.TestProject.RepeatTests.Three:3\",\n                TestClassArguments = [],\n                TestMethodArguments = [],\n                TestClassProperties = [],\n                CurrentRepeatAttempt = 3,\n                RepeatLimit = 3,\n                ResettableClassFactory = resettableClassFactory,\n                TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Three()),\n                TestFilePath = @\"\",\n                TestLineNumber = 20,\n                TestMethod = testInformation,\n                TestBuilderContext = testBuilderContext,\n            });\n            resettableClassFactory = resettableClassFactoryDelegate();\n            testBuilderContext = new();\n            testBuilderContextAccessor.Current = testBuilderContext;\n        }\n        catch (global::System.Exception exception)\n        {\n            nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.RepeatTests>\n            {\n                TestId = $\"TUnit.TestProject.RepeatTests.Three:3\",\n                MethodName = $\"Three\",\n            });\n        }\n        return nodes;\n    }\n```\n\n----------------------------------------\n\nTITLE: Creating Test Metadata Using TUnit Framework - C#\nDESCRIPTION: This code snippet sets up test metadata for the TUnit framework. It initializes test builder contexts, creates a resettable class factory for tests, and captures test metadata. It requires the TUnit framework and relevant project classes. The test setup is encapsulated in a try-catch block to handle initialization exceptions.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AbstractTests.Concrete2.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n\nAttributes = \n[\n    new global::TUnit.Core.InheritsTestsAttribute()\n],\nParameters = [],\nProperties = [],\n}),\n};\n\nvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\nvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\nglobal::TUnit.TestProject.AbstractTests.ConcreteClass1? classInstance = null;\nobject?[]? classInstanceArguments = null;\nclassInstanceArguments = [];\n\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.AbstractTests.ConcreteClass1>(() => \n    new global::TUnit.TestProject.AbstractTests.ConcreteClass1()\n    , sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.AbstractTests.ConcreteClass1>\n{\n    TestId = $\"TUnit.TestProject.AbstractTests.ConcreteClass1.AssertClassName:0\",\n    TestClassArguments = [],\n    TestMethodArguments = [],\n    TestClassProperties = [],\n    CurrentRepeatAttempt = 0,\n    RepeatLimit = 0,\n    ResettableClassFactory = resettableClassFactory,\n    TestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.AssertClassName()),\n    TestFilePath = @\"\",\n    TestLineNumber = 8,\n    TestMethod = testInformation,\n    TestBuilderContext = testBuilderContext,\n});\nresettableClassFactory = resettableClassFactoryDelegate();\ntestBuilderContext = new();\ntestBuilderContextAccessor.Current = testBuilderContext;\ncatch (global::System.Exception exception)\n{\n    nodes.Add(new FailedTestMetadata<global::TUnit.TestProject.AbstractTests.ConcreteClass1>\n    {\n        TestId = $\"TUnit.TestProject.AbstractTests.ConcreteClass1.AssertClassName:0\",\n        MethodName = $\"AssertClassName\",\n        Exception = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ConcreteClass1.AssertClassName failed to initialize\", exception),\n        TestFilePath = @\"\",\n        TestLineNumber = 8,\n    });\n}\nreturn nodes;\n```\n\n----------------------------------------\n\nTITLE: Initializing Source Registered Tests in C#\nDESCRIPTION: This snippet represents a method for initializing test registrations using TUnit.Core. It employs a SourceRegistrar to register instance of tests. Dependencies include TUnit.Core and standard System libraries. No significant inputs or outputs, but registration of the RepeatTests class is conducted.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/RepeatTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic static void Initialise()\n {\n global::TUnit.Core.SourceRegistrar.Register(new RepeatTests());\n }\n```\n\n----------------------------------------\n\nTITLE: Generated Test Class for Casted Integer to Short Conversion\nDESCRIPTION: Auto-generated test class that handles test initialization and execution for the Casted_Integer_To_Short_Converts test method. Includes test metadata collection, argument handling, and error management.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1603.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Tests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new Tests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1603.Tests),\n\t\t\t\tName = \"Casted_Integer_To_Short_Converts\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute((short)-123)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<short>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"value\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._1603.Tests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.Bugs._1603.Tests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Tests1603\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"Tests1603\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"Tests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject.Bugs._1603\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Hook Message Publisher in C#\nDESCRIPTION: Class implementation for managing and publishing hook messages in the test execution pipeline. Implements multiple interfaces for extension support and message handling.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic class HookMessagePublisher : Microsoft.Testing.Platform.Extensions.IExtension, Microsoft.Testing.Platform.Extensions.Messages.IDataProducer, TUnit.Core.Hooks.IHookMessagePublisher\n{\n    public HookMessagePublisher(Microsoft.Testing.Platform.Extensions.IExtension extension, Microsoft.Testing.Platform.Messages.IMessageBus messageBus) { }\n    public System.Type[] DataTypesProduced { get; }\n    public string Description { get; }\n    public string DisplayName { get; }\n    public string Uid { get; }\n    public string Version { get; }\n    public System.Threading.Tasks.Task Discover(string sessionId, string displayName, TUnit.Core.Hooks.StaticHookMethod hookMethod) { }\n    public System.Threading.Tasks.Task<bool> IsEnabledAsync() { }\n    public System.Threading.Tasks.Task Push(string sessionId, string displayName, TUnit.Core.Hooks.StaticHookMethod hookMethod, System.Func<System.Threading.Tasks.Task> func) { }\n}\n```\n\n----------------------------------------\n\nTITLE: DefaultPlaywrightParallelLimiter Class in C#\nDESCRIPTION: A sealed class implementing IParallelLimit interface to control the default parallel execution limits for Playwright tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class DefaultPlaywrightParallelLimiter : TUnit.Core.Interfaces.IParallelLimit\n{\n    public DefaultPlaywrightParallelLimiter() { }\n    public int Limit { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ITestSource for Inherited_ConcreteClass1 in C#\nDESCRIPTION: This snippet defines a partial class Inherited_ConcreteClass1 that implements ITestSource interface. It includes methods for initialization and test collection, focusing on the 'AssertClassName' method for ConcreteClass1.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ConcreteClassTests.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Inherited_ConcreteClass1 : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new Inherited_ConcreteClass1());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\t// ... (implementation details)\n\t}\n```\n\n----------------------------------------\n\nTITLE: Defining IWorkerService Interface for Playwright Testing in C#\nDESCRIPTION: This interface defines methods for managing worker services in Playwright tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IWorkerService\n{\n    System.Threading.Tasks.Task DisposeAsync();\n    System.Threading.Tasks.Task ResetAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Empty Array\nDESCRIPTION: Defines an empty array using square bracket notation. This could serve as an initialization point for test data or results collection.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AbstractTests.AbstractClass.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n[]\n```\n\n----------------------------------------\n\nTITLE: Integer Array Test Source Generation\nDESCRIPTION: Auto-generated source code for handling integer array parameter tests in the DataDrivenTests class. Includes test metadata collection, initialization, and error handling for array-based test methods.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/DataDrivenTests.Test.verified.txt#2025-04-22_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class DataDrivenTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new DataDrivenTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.DataDrivenTests),\n\t\t\t\tName = \"IntegerArray\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(new[] { 1, 2, 3 })\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<int[]>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"values\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.DataDrivenTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"DataDrivenTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"DataDrivenTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"DataDrivenTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n```\n\n----------------------------------------\n\nTITLE: AssemblyLoader_Guid Class with Module Initializer in C#\nDESCRIPTION: Static class with a module initializer method that runs when the assembly is loaded. The method is empty but marked with the ModuleInitializer attribute.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic static class AssemblyLoader_Guid\n{\n    [System.Runtime.CompilerServices.ModuleInitializer]\n    public static void Initialize() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Test Class Instance with ResettableLazy in C#\nDESCRIPTION: Creates a resettable factory for test class instances, allowing tests to be reset between runs. The factory creates instances of the Tests class with appropriate arguments.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests1821.Test.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.Bugs._1821.Tests>(() => \nnew global::TUnit.TestProject.Bugs._1821.Tests(classArgGeneratedData)\n, sessionId, testBuilderContext);\nvar resettableClassFactory = resettableClassFactoryDelegate();\nclassInstance = resettableClassFactory.Value;\n```\n\n----------------------------------------\n\nTITLE: Defining Assembly Metadata and Target Framework in C#\nDESCRIPTION: These assembly-level attributes define metadata for the TUnit.Playwright library. The `AssemblyMetadata` attribute specifies the source code repository URL, and the `TargetFramework` attribute declares that the library targets .NET Standard 2.0.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet2_0.Net4_7.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadata(\"RepositoryUrl\", \"https://github.com/thomhurst/TUnit\")]\n[assembly: System.Runtime.Versioning.TargetFramework(\".NETStandard,Version=v2.0\", FrameworkDisplayName=\".NET Standard 2.0\")]\n```\n\n----------------------------------------\n\nTITLE: Initializing InstanceHooks for TUnit in C#\nDESCRIPTION: This snippet demonstrates how to collect instance hook methods to be executed after tests using the TUnit framework. Dependencies include the TUnit.Core.Hooks namespace. The method specifies parameters for test context and task return types. It returns an IReadOnlyList of InstanceHookMethod, intending to define the necessary actions after test execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyAfterTests.Test.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<global::TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId) {\n\t  return [\n\t\tnew global::TUnit.Core.Hooks.InstanceHookMethod {\n\t\t  ClassType = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),\n\t\t  MethodInfo = new global::TUnit.Core.SourceGeneratedMethodInformation {\n\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),\n\t\t\tName = \"CleanupWithContext\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\tAttributes = [\n\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test)\n\t\t\t],\n\t\t\tParameters = [\n\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<global::TUnit.Core.TestContext> {\n\t\t\t\t  Name = \"testContext\",\n\t\t\t\t  Attributes = [],\n\t\t\t\t},\n\t\t\t],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AfterTests.AssemblyCleanupTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation {\n\t\t\t\tType = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AssemblyAfterTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation {\n\t\t\t\t  Name = \"AssemblyAfterTests\",\n\t\t\t\t  Attributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"AssemblyCleanupTests\",\n\t\t\t\tNamespace = \"TUnit.TestProject.AfterTests\",\n\t\t\t\tAttributes = [],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n},\n\t\t\tBody = (classInstance, context, cancellationToken) => AsyncConvert.Convert(() => ((global::TUnit.TestProject.AfterTests.AssemblyCleanupTests)classInstance).CleanupWithContext(context)),\n\t\t\tHookExecutor = DefaultExecutor.Instance,\n\t\t\tOrder = 0,\n\t\t\tMethodAttributes = [\n\t\t\t\tnew global::TUnit.Core.AfterAttribute(global::TUnit.Core.HookType.Test),\n\t\t\t\tnew global::TUnit.Core.TimeoutAttribute(30_000)\n\t\t\t],\n\t\t\tClassAttributes = [],\n\t\t\tAssemblyAttributes = [],\n\t\t  },\n\t\t];\n\t}\n```\n\n----------------------------------------\n\nTITLE: Initializing Assembly Registration for TUnit Framework in C#\nDESCRIPTION: Auto-generated module initializer that registers required assemblies for TUnit framework operation. Uses the TUnit.Core.SourceRegistrar to dynamically load assemblies including testing frameworks, code analysis tools, and various dependencies.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyLoaderTests.Test.DotNet8_0.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic static class AssemblyLoader_Guid\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialize()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"Newtonsoft.Json, Version=13.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"NUnit3.TestAdapter, Version=4.6.0.0, Culture=neutral, PublicKeyToken=4cb40d35494691ac\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"nunit.engine.api, Version=3.0.0.0, Culture=neutral, PublicKeyToken=2638cd05610744eb\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"nunit.engine, Version=3.18.1.0, Culture=neutral, PublicKeyToken=2638cd05610744eb\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"nunit.engine.core, Version=3.18.1.0, Culture=neutral, PublicKeyToken=2638cd05610744eb\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"testcentric.engine.metadata, Version=2.0.0.0, Culture=neutral, PublicKeyToken=6fe0a02d2036aa1d\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"TUnit.Core.SourceGenerator.Tests, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"nunit.framework, Version=4.3.2.0, Culture=neutral, PublicKeyToken=2638cd05610744eb\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"TUnit.Core.SourceGenerator, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"Microsoft.CodeAnalysis, Version=4.7.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"NuGet.Protocol, Version=6.13.2.1, Culture=neutral, PublicKeyToken=31bf3856ad364e35\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"Verify, Version=1.0.0.0, Culture=neutral, PublicKeyToken=c7a34512ecd69090\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"Microsoft.CodeAnalysis.Analyzer.Testing, Version=1.1.2.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"Microsoft.CodeAnalysis.CSharp, Version=4.7.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"Verify.NUnit, Version=1.0.0.0, Culture=neutral, PublicKeyToken=c7a34512ecd69090\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"DiffEngine, Version=1.0.0.0, Culture=neutral, PublicKeyToken=c7a34512ecd69090\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"TUnit.Assertions, Version=1.0.0.0, Culture=neutral, PublicKeyToken=b8d4030011dbd70c\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"TUnit.TestProject.Library, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"TUnit.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=b8d4030011dbd70c\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"Confluent.SchemaRegistry.Serdes.Protobuf, Version=2.10.0.0, Culture=neutral, PublicKeyToken=6f85e24b3ffa9bd0\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"WireMock.Net, Version=1.7.4.0, Culture=neutral, PublicKeyToken=c8d65537854e1f03\"));\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Shared Type Enum in C#\nDESCRIPTION: Defines an enumeration for different scopes of shared test data. Options include per-class, per-assembly, per-test-session, and keyed sharing strategies.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\npublic enum SharedType\n{\n    None = 0,\n    PerClass = 1,\n    PerAssembly = 2,\n    PerTestSession = 3,\n    Keyed = 4,\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Metadata for TUnit in C#\nDESCRIPTION: This method generates test metadata for the ConcreteClass1 class. It creates a TestMetadata object with information about the test method, class, and execution context.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AbstractTests.Concrete1.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n{\n\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\tvar classDataIndex = 0;\n\tvar testMethodDataIndex = 0;\n\ttry\n\t{\n\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t{\n\t\t\tType = typeof(global::TUnit.TestProject.AbstractTests.ConcreteClass1),\n\t\t\tName = \"AssertClassName\",\n\t\t\tGenericTypeCount = 0,\n\t\t\tReturnType = typeof(global::System.Threading.Tasks.Task),\n\t\t\tAttributes = \n\t\t\t[\n\t\t\t\tnew global::TUnit.Core.TestAttribute()\n\t\t\t],\n\t\t\tParameters = [],\n\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.AbstractTests.ConcreteClass1\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.AbstractTests.ConcreteClass1),\n\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"AbstractTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t{\n\t\t\t\t\tName = \"AbstractTests\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t}),\n\t\t\t\tName = \"ConcreteClass1\",\n\t\t\t\tNamespace = \"TUnit.TestProject.AbstractTests\",\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.InheritsTestsAttribute()\n\t\t\t\t],\n\t\t\t\tParameters = [],\n\t\t\t\tProperties = [],\n\t\t\t}),\n};\n\n\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\tglobal::TUnit.TestProject.AbstractTests.ConcreteClass1? classInstance = null;\n\t\tobject?[]? classInstanceArguments = null;\n\t\tclassInstanceArguments = [];\n\n\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.AbstractTests.ConcreteClass1>(() => \n\t\tnew global::TUnit.TestProject.AbstractTests.ConcreteClass1()\n\t\t, sessionId, testBuilderContext);\n\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.AbstractTests.ConcreteClass1>\n\t\t{\n\t\t\tTestId = $\"TUnit.TestProject.AbstractTests.ConcreteClass1.AssertClassName:0\",\n\t\t\tTestClassArguments = [],\n\t\t\tTestMethodArguments = [],\n\t\t\tTestClassProperties = [],\n\t\t\tCurrentRepeatAttempt = 0,\n\t\t\tRepeatLimit = 0,\n\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.AssertClassName()),\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 8,\n\t\t\tTestMethod = testInformation,\n\t\t\tTestBuilderContext = testBuilderContext,\n\t\t});\n\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\ttestBuilderContext = new();\n\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t}\n\tcatch (global::System.Exception exception)\n\t{\n\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.AbstractTests.ConcreteClass1>\n\t\t{\n\t\t\tTestId = $\"TUnit.TestProject.AbstractTests.ConcreteClass1.AssertClassName:0\",\n\t\t\tMethodName = $\"AssertClassName\",\n\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"ConcreteClass1.AssertClassName failed to initialize\", exception),\n\t\t\tTestFilePath = @\"\",\n\t\t\tTestLineNumber = 8,\n\t\t});\n\t}\n\treturn nodes;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Test Metadata Collection for Method Two in C#\nDESCRIPTION: Defines the method 'Two' test metadata collection. Notably, this version adds a second repetition attribute when capturing method details. Inputs include session IDs and core attributes to process metadata, and it outputs structured TestMetadata. Utilizes TUnit and System core dependencies.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/RepeatTests.Test.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests1(string sessionId)\n {\n global::System.Collections.Generic.List<TestMetadata> nodes = [];\n // ... \n return nodes;\n }\n```\n\n----------------------------------------\n\nTITLE: Registering External Assemblies for TUnit Testing Framework in C#\nDESCRIPTION: This auto-generated class registers multiple external assemblies with TUnit.Core.SourceRegistrar. It uses a ModuleInitializer to ensure the method runs automatically when the module is loaded, registering test-related dependencies like NUnit, Verify, and other libraries needed for the TUnit testing framework.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AssemblyLoaderTests.Test.DotNet9_0.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[  \n// <auto-generated/>\n#pragma warning disable\npublic static class AssemblyLoader_Guid\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialize()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"Newtonsoft.Json, Version=13.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"NUnit3.TestAdapter, Version=4.6.0.0, Culture=neutral, PublicKeyToken=4cb40d35494691ac\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"nunit.engine.api, Version=3.0.0.0, Culture=neutral, PublicKeyToken=2638cd05610744eb\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"nunit.engine, Version=3.18.1.0, Culture=neutral, PublicKeyToken=2638cd05610744eb\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"nunit.engine.core, Version=3.18.1.0, Culture=neutral, PublicKeyToken=2638cd05610744eb\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"testcentric.engine.metadata, Version=2.0.0.0, Culture=neutral, PublicKeyToken=6fe0a02d2036aa1d\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"TUnit.Core.SourceGenerator.Tests, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"nunit.framework, Version=4.3.2.0, Culture=neutral, PublicKeyToken=2638cd05610744eb\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"TUnit.Core.SourceGenerator, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"Microsoft.CodeAnalysis, Version=4.7.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"NuGet.Protocol, Version=6.13.2.1, Culture=neutral, PublicKeyToken=31bf3856ad364e35\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"Verify, Version=1.0.0.0, Culture=neutral, PublicKeyToken=c7a34512ecd69090\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"Microsoft.CodeAnalysis.Analyzer.Testing, Version=1.1.2.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"Microsoft.CodeAnalysis.CSharp, Version=4.7.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"Verify.NUnit, Version=1.0.0.0, Culture=neutral, PublicKeyToken=c7a34512ecd69090\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"DiffEngine, Version=1.0.0.0, Culture=neutral, PublicKeyToken=c7a34512ecd69090\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"TUnit.Assertions, Version=1.0.0.0, Culture=neutral, PublicKeyToken=b8d4030011dbd70c\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"TUnit.TestProject.Library, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"TUnit.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=b8d4030011dbd70c\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"Confluent.SchemaRegistry.Serdes.Protobuf, Version=2.10.0.0, Culture=neutral, PublicKeyToken=6f85e24b3ffa9bd0\"));\n\t\tglobal::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"WireMock.Net, Version=1.7.4.0, Culture=neutral, PublicKeyToken=c8d65537854e1f03\"));\n\t}\n}\n\n]\n```\n\n----------------------------------------\n\nTITLE: Test Method Factory Generation in C#\nDESCRIPTION: Creates test method factory with argument initialization and class instance management. Handles test metadata creation and exception handling for test initialization failures.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/Tests2112.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nprivate global::System.Collections.Generic.List<TestMetadata> Tests1(string sessionId)\n{\n    global::System.Collections.Generic.List<TestMetadata> nodes = [];\n    var classDataIndex = 0;\n    var testMethodDataIndex = 0;\n    try\n    {\n        var testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n        {\n            Type = typeof(global::TUnit.TestProject.Bugs._2112.Tests),\n            Name = \"Test2\",\n            GenericTypeCount = 0,\n            ReturnType = typeof(void),\n            Attributes = \n            [\n                new global::TUnit.Core.TestAttribute(),\n                new global::TUnit.Core.ArgumentsAttribute(0, 1L, 2L, 3L),\n                new global::TUnit.Core.ArgumentsAttribute(0, 1, 2, 3)\n            ],\n            Parameters = \n            [\n                new global::TUnit.Core.SourceGeneratedParameterInformation<int>\n                {\n                    Name = \"a\",\n                    Attributes = [],\n                },\n                new global::TUnit.Core.SourceGeneratedParameterInformation<long[]>\n                {\n                    Name = \"arr\",\n                    Attributes = [],\n                },\n            ],\n            Class = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.Bugs._2112.Tests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n            {\n                Type = typeof(global::TUnit.TestProject.Bugs._2112.Tests),\n                Assembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"Tests2112\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n                {\n                    Name = \"Tests2112\",\n                    Attributes = [],\n                }),\n                Name = \"Tests\",\n                Namespace = \"TUnit.TestProject.Bugs._2112\",\n                Attributes = [],\n                Parameters = [],\n                Properties = [],\n            }),\n};\n```\n\n----------------------------------------\n\nTITLE: Asserting Exception Message Start in C#\nDESCRIPTION: Extension methods for asserting that an exception's message starts with a specific string. Includes overloads for different comparison options.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_71\n\nLANGUAGE: C#\nCODE:\n```\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> HasMessageStartingWith<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue = null)\n    where TActual : System.Exception { }\npublic static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> HasMessageStartingWith<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression(\"expected\")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression(\"stringComparison\")] string doNotPopulateThisValue2 = null)\n    where TActual : System.Exception { }\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Model Classes in C#\nDESCRIPTION: Declares several classes representing JSON models for various test-related objects, using required members and init-only setters.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.RequiredMember]\npublic class ExceptionJson : System.IEquatable<TUnit.Engine.Json.ExceptionJson>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of \" +\n        \"your compiler.\", true)]\n    public ExceptionJson() { }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public TUnit.Engine.Json.ExceptionJson? InnerException { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string Message { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string? Stacktrace { get; init; }\n    [System.Runtime.CompilerServices.RequiredMember]\n    public string? Type { get; init; }\n}\n\n// Similar classes: TestAssemblyJson, TestClassJson, TestJson, TestResultJson, TestSessionJson\n```\n\n----------------------------------------\n\nTITLE: Defining LogLevel Enum in C#\nDESCRIPTION: This enum defines various log levels for the TUnit logging system. It includes levels such as Trace and Debug, with more levels likely defined in the full enum.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_63\n\nLANGUAGE: C#\nCODE:\n```\npublic enum LogLevel\n{\n    Trace = 0,\n    Debug = 1,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ModuleInitializer for TUnit Test Registration\nDESCRIPTION: A static initialization method that registers the current instance of AttributeTests with TUnit's source registrar, allowing test discovery.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AttributeTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[global::System.Runtime.CompilerServices.ModuleInitializer]\npublic static void Initialise()\n{\n\tglobal::TUnit.Core.SourceRegistrar.Register(new AttributeTests());\n}\n```\n\n----------------------------------------\n\nTITLE: Creating TestMetadata for TUnit Test Method with Exception Handling in C#\nDESCRIPTION: Code snippet that creates TestMetadata objects for a test method, sets up test execution context, and handles potential initialization exceptions. The method configures resettable class factories, test arguments, and test execution factories.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ArgumentWithImplicitConverterTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\nnodes.Add(new TestMetadata<global::TUnit.TestProject.ArgumentWithImplicitConverterTests>\n{\n\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS1:TUnit.TestProject.ArgumentWithImplicitConverterTests.Implicit(TUnit.TestProject.ImplicitInteger):0\",\n\tTestClassArguments = [],\n\tTestMethodArguments = [methodArg],\n\tTestClassProperties = [],\n\tCurrentRepeatAttempt = 0,\n\tRepeatLimit = 0,\n\tResettableClassFactory = resettableClassFactory,\n\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.Implicit(methodArg)),\n\tTestFilePath = @\"\",\n\tTestLineNumber = 14,\n\tTestMethod = testInformation,\n\tTestBuilderContext = testBuilderContext,\n});\nresettableClassFactory = resettableClassFactoryDelegate();\ntestBuilderContext = new();\ntestBuilderContextAccessor.Current = testBuilderContext;\n```\n\n----------------------------------------\n\nTITLE: Defining Assembly-Level Attributes in C#\nDESCRIPTION: This snippet sets up assembly-level attributes for internal visibility and target framework specification.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@\"TUnit.Engine, PublicKey=0024000004800000940000000602000000240000525341310004000001000100698a70398fa0b2230c5a72e3bd9d56b48f809f6173e49a19fbb942d621be93ad48c5566b47b28faabc359b9ad3ff4e00bbdea88f5bdfa250f391fedd28182b2e37b55d429c0151a42a98ea7a5821818cd15a79fef9903e8607a88304cf3e0317bf86ec96e32e1381535a6582251e5a6eed40b5a3ed82bc444598b1269cce57a7\")]\n[assembly: System.Runtime.Versioning.TargetFramework(\".NETCoreApp,Version=v8.0\", FrameworkDisplayName=\".NET 8.0\")]\n```\n\n----------------------------------------\n\nTITLE: Assembly Visibility and Target Framework Declarations in C#\nDESCRIPTION: Defines the assembly visibility to the TUnit.Engine assembly and specifies the target framework as .NET 9.0.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@\"TUnit.Engine, PublicKey=0024000004800000940000000602000000240000525341310004000001000100698a70398fa0b2230c5a72e3bd9d56b48f809f6173e49a19fbb942d621be93ad48c5566b47b28faabc359b9ad3ff4e00bbdea88f5bdfa250f391fedd28182b2e37b55d429c0151a42a98ea7a5821818cd15a79fef9903e8607a88304cf3e0317bf86ec96e32e1381535a6582251e5a6eed40b5a3ed82bc444598b1269cce57a7\")]\n[assembly: System.Runtime.Versioning.TargetFramework(\".NETCoreApp,Version=v9.0\", FrameworkDisplayName=\".NET 9.0\")]\n```\n\n----------------------------------------\n\nTITLE: Defining MemberType Enum in C#\nDESCRIPTION: This enum defines different types of members that can be compared or asserted, including properties, fields, values, and enumerable items.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic enum MemberType\n{\n    Property = 0,\n    Field = 1,\n    Value = 2,\n    EnumerableItem = 3,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ITestSource for Inherited_ConcreteClass1 in C#\nDESCRIPTION: This code snippet defines a partial class Inherited_ConcreteClass1 that implements the ITestSource interface. It provides test collection and initialization functionality for yet another test class in the TUnit framework.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AbstractTests.Concrete2.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Inherited_ConcreteClass1 : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new Inherited_ConcreteClass1());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\t// ... (implementation details)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Rules Table Structure in Markdown\nDESCRIPTION: Markdown table structure defining columns for Rule ID, Category, Severity and Notes documentation\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Analyzers/AnalyzerReleases.Unshipped.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nRule ID | Category | Severity | Notes \n--------|----------|----------|-------\n```\n\n----------------------------------------\n\nTITLE: Initializing and Collecting Tests for NumberArgumentTests in C#\nDESCRIPTION: This snippet shows the auto-generated class implementation for NumberArgumentTests. It includes methods for initializing the class, collecting tests, and handling test metadata. The class is designed to work with the TUnit testing framework.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/NumberArgumentTests.Test.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n// <auto-generated/>\n#pragma warning disable\nusing global::System.Linq;\nusing global::System.Reflection;\nusing global::TUnit.Core;\nusing global::TUnit.Core.Extensions;\n\nnamespace TUnit.SourceGenerated;\n\n[global::System.Diagnostics.StackTraceHidden]\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\nfile partial class NumberArgumentTests : global::TUnit.Core.Interfaces.SourceGenerator.ITestSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tglobal::TUnit.Core.SourceRegistrar.Register(new NumberArgumentTests());\n\t}\n\tpublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n\t{\n\t\treturn Tests0(sessionId);\n\t}\n\tprivate global::System.Collections.Generic.List<TestMetadata> Tests0(string sessionId)\n\t{\n\t\tglobal::System.Collections.Generic.List<TestMetadata> nodes = [];\n\t\tvar classDataIndex = 0;\n\t\tvar testMethodDataIndex = 0;\n\t\ttry\n\t\t{\n\t\t\tvar testInformation = new global::TUnit.Core.SourceGeneratedMethodInformation\n\t\t\t{\n\t\t\t\tType = typeof(global::TUnit.TestProject.NumberArgumentTests),\n\t\t\t\tName = \"UInt\",\n\t\t\t\tGenericTypeCount = 0,\n\t\t\t\tReturnType = typeof(void),\n\t\t\t\tAttributes = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.TestAttribute(),\n\t\t\t\t\tnew global::TUnit.Core.ArgumentsAttribute(1U)\n\t\t\t\t],\n\t\t\t\tParameters = \n\t\t\t\t[\n\t\t\t\t\tnew global::TUnit.Core.SourceGeneratedParameterInformation<uint>\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"i\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tClass = global::TUnit.Core.SourceGeneratedClassInformation.GetOrAdd(\"global::TUnit.TestProject.NumberArgumentTests\", () => new global::TUnit.Core.SourceGeneratedClassInformation\n\t\t\t\t{\n\t\t\t\t\tType = typeof(global::TUnit.TestProject.NumberArgumentTests),\n\t\t\t\t\tAssembly = global::TUnit.Core.SourceGeneratedAssemblyInformation.GetOrAdd(\"NumberArgumentTests\", () => new global::TUnit.Core.SourceGeneratedAssemblyInformation\n\t\t\t\t\t{\n\t\t\t\t\t\tName = \"NumberArgumentTests\",\n\t\t\t\t\t\tAttributes = [],\n\t\t\t\t\t}),\n\t\t\t\t\tName = \"NumberArgumentTests\",\n\t\t\t\t\tNamespace = \"TUnit.TestProject\",\n\t\t\t\t\tAttributes = [],\n\t\t\t\t\tParameters = [],\n\t\t\t\t\tProperties = [],\n\t\t\t\t}),\n};\n\n\t\t\t\tvar testBuilderContext = new global::TUnit.Core.TestBuilderContext();\n\t\t\t\tvar testBuilderContextAccessor = new global::TUnit.Core.TestBuilderContextAccessor(testBuilderContext);\n\t\t\t\tglobal::TUnit.TestProject.NumberArgumentTests? classInstance = null;\n\t\t\t\tobject?[]? classInstanceArguments = null;\n\t\t\t\tclassInstanceArguments = [];\n\n\t\t\t\tuint methodArg = 1U;\n\n\t\t\t\tvar resettableClassFactoryDelegate = () => new ResettableLazy<global::TUnit.TestProject.NumberArgumentTests>(() => \n\t\t\t\tnew global::TUnit.TestProject.NumberArgumentTests()\n\t\t\t\t, sessionId, testBuilderContext);\n\t\t\t\tvar resettableClassFactory = resettableClassFactoryDelegate();\n\n\n\t\t\t\tnodes.Add(new TestMetadata<global::TUnit.TestProject.NumberArgumentTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NumberArgumentTests.UInt(uint):0\",\n\t\t\t\t\tTestClassArguments = [],\n\t\t\t\t\tTestMethodArguments = [methodArg],\n\t\t\t\t\tTestClassProperties = [],\n\t\t\t\t\tCurrentRepeatAttempt = 0,\n\t\t\t\t\tRepeatLimit = 0,\n\t\t\t\t\tResettableClassFactory = resettableClassFactory,\n\t\t\t\t\tTestMethodFactory = (classInstance, cancellationToken) => AsyncConvert.Convert(() => classInstance.UInt(methodArg)),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 40,\n\t\t\t\t\tTestMethod = testInformation,\n\t\t\t\t\tTestBuilderContext = testBuilderContext,\n\t\t\t\t});\n\t\t\t\tresettableClassFactory = resettableClassFactoryDelegate();\n\t\t\t\ttestBuilderContext = new();\n\t\t\t\ttestBuilderContextAccessor.Current = testBuilderContext;\n\t\t\t}\n\t\t\tcatch (global::System.Exception exception)\n\t\t\t{\n\t\t\t\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.NumberArgumentTests>\n\t\t\t\t{\n\t\t\t\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.NumberArgumentTests.UInt(uint):0\",\n\t\t\t\t\tMethodName = $\"UInt\",\n\t\t\t\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"NumberArgumentTests.UInt failed to initialize\", exception),\n\t\t\t\t\tTestFilePath = @\"\",\n\t\t\t\t\tTestLineNumber = 40,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn nodes;\n\t\t}\n\t}\n\n```\n\n----------------------------------------\n\nTITLE: Defining ModuleInitializerAttribute in C#\nDESCRIPTION: This snippet defines the `ModuleInitializerAttribute` class within the `System.Runtime.CompilerServices` namespace. It's a sealed attribute, inheriting from `System.Attribute`, and can only be applied to methods (`AttributeTargets.Method`). It's likely used to polyfill or provide custom module initialization behavior.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/PolyfillTests.Test_Without_BuildProperty_WithoutType.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Runtime.CompilerServices;\n\nusing System;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\n\n[AttributeUsage(AttributeTargets.Method, Inherited = false)]\nsealed class ModuleInitializerAttribute : Attribute;\n```\n\n----------------------------------------\n\nTITLE: String Extension Methods\nDESCRIPTION: Collection of utility methods for string manipulation including empty checks, truncation, and line handling\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_131\n\nLANGUAGE: C#\nCODE:\n```\npublic static class StringExtensions\n{\n    public static string GetStringOr(this string? value, string defaultValue) { }\n    public static string GetStringOrEmpty(this string? value) { }\n    public static string PrependAOrAn(this string value) { }\n    public static string ReplaceNewLines(this string value) { }\n    public static string ShowNewLines(this string value) { }\n    public static string TruncateWithEllipsis(this string value, int maxLength) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Initialization Exceptions for Parameterized TUnit Test Node in C#\nDESCRIPTION: If the registration or instantiation of the parameterized test fails, this snippet captures the exception and records a FailedTestMetadata node. The exception object wraps the original failure with a descriptive exception type and message for TUnit to report on failed test discovery or initialization.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/CustomDisplayNameTests.Test.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\ncatch (global::System.Exception exception)\n{\n\tnodes.Add(new FailedTestMetadata<global::TUnit.TestProject.CustomDisplayNameTests>\n\t{\n\t\tTestId = $\"global::TUnit.Core.ArgumentsAttribute:{testMethodDataIndex}:TL-ARGS0:TUnit.TestProject.CustomDisplayNameTests.Test3(string,int,bool):0\",\n\t\tMethodName = $\"Test3\",\n\t\tException = new TUnit.Core.Exceptions.TestFailedInitializationException(\"CustomDisplayNameTests.Test3 failed to initialize\", exception),\n\t\tTestFilePath = @\"\",\n\t\tTestLineNumber = 26,\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly Target Framework Declaration in C#\nDESCRIPTION: Declares the target framework for the assembly as .NET 9.0.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Playwright_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Runtime.Versioning.TargetFramework(\".NETCoreApp,Version=v9.0\", FrameworkDisplayName=\".NET 9.0\")]\n```\n\n----------------------------------------\n\nTITLE: Filtering TUnit Tests by Test Name (Shell)\nDESCRIPTION: This command executes all TUnit tests specifically named `AcceptCookiesTest` across any assembly, namespace, or class. It employs the `dotnet run` command along with the `--treenode-filter` flag, using a pattern with wildcards for assembly, namespace, and class, but specifying the exact test method name.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-advanced/test-filters.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ndotnet run --treenode-filter /*/*/*/AcceptCookiesTest\n```\n\n----------------------------------------\n\nTITLE: Implementing UnknownAssertionGroup for Initial Assertion Building\nDESCRIPTION: Class representing an initial assertion group before it has been combined with others. It provides methods to combine with other assertions using either AND or OR logic.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_79\n\nLANGUAGE: C#\nCODE:\n```\npublic class UnknownAssertionGroup<TActual, TAssertionBuilder>\n    where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder\n{\n    public TUnit.Assertions.AssertionBuilders.Groups.AndAssertionGroup<TActual, TAssertionBuilder> And(System.Func<TAssertionBuilder, TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TActual>> assert) { }\n    public TUnit.Assertions.AssertionBuilders.Groups.OrAssertionGroup<TActual, TAssertionBuilder> Or(System.Func<TAssertionBuilder, TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TActual>> assert) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with Yarn - Shell\nDESCRIPTION: This snippet runs the Yarn package manager to install all required JavaScript dependencies as defined in the project's package.json file. It is a prerequisite before running or building the Docusaurus website. No parameters are required; simply execute the command in the project directory. Outputs a node_modules folder with all installed packages.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n```\n$ yarn\n```\n```\n\n----------------------------------------\n\nTITLE: Logging System Implementation in C#\nDESCRIPTION: Implementation of a logging system with multiple log levels and async capabilities. Includes a default logger implementation and extension methods for different log levels.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet9_0.verified.txt#2025-04-22_snippet_67\n\nLANGUAGE: C#\nCODE:\n```\npublic class DefaultLogger : TUnit.Core.Logging.TUnitLogger\n{\n    public DefaultLogger(TUnit.Core.Context context) { }\n    public override void Log<TState>(TUnit.Core.Logging.LogLevel logLevel, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter) { }\n    public override System.Threading.Tasks.ValueTask LogAsync<TState>(TUnit.Core.Logging.LogLevel logLevel, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter) { }\n    public void PushProperties(System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<object>> dictionary) { }\n    public void PushProperty(string name, object? value) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel Limiter Attribute in C#\nDESCRIPTION: Defines a generic attribute for applying custom parallel execution limits. It uses a custom IParallelLimit implementation to control how many instances of a test can run simultaneously.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]\npublic sealed class ParallelLimiterAttribute<TParallelLimit> : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestRegisteredEventReceiver\n    where TParallelLimit : TUnit.Core.Interfaces.IParallelLimit, new ()\n{\n    public ParallelLimiterAttribute() { }\n    public int Order { get; }\n    public System.Threading.Tasks.ValueTask OnTestRegistered(TUnit.Core.TestRegisteredContext testRegisteredContext) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Hooks for GlobalBase1 in C#\nDESCRIPTION: Source-generated partial class implementing ITestHookSource interface for GlobalBase1. Handles test lifecycle hooks including initialization and after-test methods. Includes registration with SourceRegistrar and implements AfterEach1 hook.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/GlobalStaticAfterEachTests.Test.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile partial class Hooks_GlobalBase1 : global::TUnit.Core.Interfaces.SourceGenerator.ITestHookSource\n{\n\t[global::System.Runtime.CompilerServices.ModuleInitializer]\n\tpublic static void Initialise()\n\t{\n\t\tvar instance = new Hooks_GlobalBase1();\n\t\tSourceRegistrar.RegisterTestHookSource(instance);\n\t}\n\t// ... rest of implementation\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Equality Assertion Conditions in C#\nDESCRIPTION: Classes for equality comparison including Equals, NotEquals, and EquivalentTo conditions. These classes handle value comparison with support for custom equality comparers and equivalency rules.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\npublic class EqualsExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TActual>\n{\n    public EqualsExpectedValueAssertCondition(TActual expected) { }\n    public EqualsExpectedValueAssertCondition(TActual expected, System.Collections.Generic.IEqualityComparer<TActual> equalityComparer) { }\n    protected override string GetExpectation() { }\n    protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TActual? expectedValue) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Test Metadata for ClassTupleDataSourceDrivenTests in C#\nDESCRIPTION: This method collects test metadata by calling multiple test generation methods. It's part of implementing the ITestSource interface, allowing the test framework to discover and execute tests.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/ClassTupleDataSourceDrivenTests.Test_index=0_classMethodName=NamedTupleMethod_testMethodName=NamedTupleMethod.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn\n\t[\n\t\t..Tests0(sessionId),\n\t\t..Tests1(sessionId),\n\t\t..Tests2(sessionId),\n\t\t..Tests3(sessionId),\n\t];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic StaticHookMethod<T> Class in C#\nDESCRIPTION: Generic implementation of StaticHookMethod that adds type-specific execution capabilities with async support.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Core_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_56\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class StaticHookMethod<T> : TUnit.Core.Hooks.StaticHookMethod, System.IEquatable<TUnit.Core.Hooks.StaticHookMethod<T>>, TUnit.Core.Hooks.IExecutableHook<T>\n{\n    [System.Obsolete(\"Constructors of types with required members are not supported in this version of your compiler.\", true)]\n    protected StaticHookMethod() { }\n    public System.Func<T, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask>? Body { get; init; }\n    public abstract System.Threading.Tasks.ValueTask ExecuteAsync(T context, System.Threading.CancellationToken cancellationToken);\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Tests with dotnet test in Powershell\nDESCRIPTION: Illustrates running tests using dotnet test, a command that requires flags to be added as application arguments. Navigate to the appropriate directory and execute the command with or without flags.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/docs/tutorial-basics/running-your-tests.md#2025-04-22_snippet_1\n\nLANGUAGE: Powershell\nCODE:\n```\ncd 'C:/Your/Test/Directory'\ndotnet test -c Release\n# or with flags\ndotnet test -c Release -- --report-trx --coverage\n```\n\n----------------------------------------\n\nTITLE: Defining AssertionGroupBuilder Class in C#\nDESCRIPTION: This class is used to build assertion groups for a specific type. It allows adding assertions to the group using a delegate function.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Assertions_Library_Has_No_API_Changes.DotNet8_0.verified.txt#2025-04-22_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\npublic class AssertionGroupBuilder<TActual, TAssertionBuilder>\n    where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder\n{\n    public TUnit.Assertions.AssertionBuilders.Groups.UnknownAssertionGroup<TActual, TAssertionBuilder> WithAssertion(System.Func<TAssertionBuilder, TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TActual>> assert) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TestMetadata Collection Interface for TUnit\nDESCRIPTION: Implementation of ITestSource interface for collecting tests with a specific session ID. It delegates to a private method for actual test collection.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.Core.SourceGenerator.Tests/AttributeTests.Test.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic global::System.Collections.Generic.IReadOnlyList<TestMetadata> CollectTests(string sessionId)\n{\n\treturn Tests0(sessionId);\n}\n```\n\n----------------------------------------\n\nTITLE: IFilterReceiver Interface for Test Filtering\nDESCRIPTION: An interface that enables components to receive and apply test filters to narrow the scope of test execution.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/TUnit.PublicAPI/Tests.Engine_Library_Has_No_API_Changes.DotNet2_0.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IFilterReceiver\n{\n    string? Filter { set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Building Static Content with Docusaurus - Shell\nDESCRIPTION: Triggers the static site build process using Docusaurus via the Yarn build command. Compiles Markdown and assets into HTML/CSS/JS, storing results in the build directory for deployment. No parameters needed. Requires all dependencies to be installed beforehand. The resulting files can be served from any static hosting service.\nSOURCE: https://github.com/thomhurst/tunit/blob/main/docs/README.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n```\n$ yarn build\n```\n```"
  }
]