[
  {
    "owner": "pmndrs",
    "repo": "zustand",
    "content": "TITLE: Creating a Zustand Store\nDESCRIPTION: Example of creating a basic Zustand store with state and actions.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/README.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { create } from 'zustand'\n\nconst useBearStore = create((set) => ({\n  bears: 0,\n  increasePopulation: () => set((state) => ({ bears: state.bears + 1 })),\n  removeAllBears: () => set({ bears: 0 }),\n}))\n```\n\n----------------------------------------\n\nTITLE: Accessing Zustand Store Outside Components\nDESCRIPTION: Demonstrates how to access and manipulate Zustand store state outside of React components.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/README.md#2025-04-22_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst useDogStore = create(() => ({ paw: true, snout: true, fur: true }))\n\n// Getting non-reactive fresh state\nconst paw = useDogStore.getState().paw\n// Listening to all changes, fires synchronously on every change\nconst unsub1 = useDogStore.subscribe(console.log)\n// Updating state, will trigger listeners\nuseDogStore.setState({ paw: false })\n// Unsubscribe listeners\nunsub1()\n\n// You can of course use the hook as you always would\nfunction Component() {\n  const paw = useDogStore((state) => state.paw)\n  ...\n```\n\n----------------------------------------\n\nTITLE: Consuming a Zustand Store in React Components\nDESCRIPTION: Example of using a Zustand store in React components. Shows how to select specific state and actions from the store without needing providers.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/getting-started/introduction.md#2025-04-22_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nfunction BearCounter() {\n  const bears = useStore((state) => state.bears)\n  return <h1>{bears} bears around here...</h1>\n}\n\nfunction Controls() {\n  const increasePopulation = useStore((state) => state.increasePopulation)\n  return <button onClick={increasePopulation}>one up</button>\n}\n```\n\n----------------------------------------\n\nTITLE: Using Zustand Store in React Components\nDESCRIPTION: Demonstrates how to use the Zustand store within React components to access state and actions.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/README.md#2025-04-22_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nfunction BearCounter() {\n  const bears = useBearStore((state) => state.bears)\n  return <h1>{bears} around here ...</h1>\n}\n\nfunction Controls() {\n  const increasePopulation = useBearStore((state) => state.increasePopulation)\n  return <button onClick={increasePopulation}>one up</button>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Reducer Pattern with Zustand\nDESCRIPTION: Shows how to implement a Redux-like reducer pattern within Zustand. This approach uses a switch statement to handle different action types while maintaining the Zustand API.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/getting-started/comparison.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\n\ntype State = {\n  count: number\n}\n\ntype Actions = {\n  increment: (qty: number) => void\n  decrement: (qty: number) => void\n}\n\ntype Action = {\n  type: keyof Actions\n  qty: number\n}\n\nconst countReducer = (state: State, action: Action) => {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + action.qty }\n    case 'decrement':\n      return { count: state.count - action.qty }\n    default:\n      return state\n  }\n}\n\nconst useCountStore = create<State & Actions>((set) => ({\n  count: 0,\n  dispatch: (action: Action) => set((state) => countReducer(state, action)),\n}))\n```\n\n----------------------------------------\n\nTITLE: Updating State Based on Previous State in Zustand\nDESCRIPTION: Illustrates how to update state based on its previous value using updater functions in Zustand. It includes a complete example with a React component using the store.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create.md#2025-04-22_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { create } from 'zustand'\n\ntype AgeStoreState = { age: number }\n\ntype AgeStoreActions = {\n  setAge: (\n    nextAge:\n      | AgeStoreState['age']\n      | ((currentAge: AgeStoreState['age']) => AgeStoreState['age']),\n  ) => void\n}\n\ntype AgeStore = AgeStoreState & AgeStoreActions\n\nconst useAgeStore = create<AgeStore>()((set) => ({\n  age: 42,\n  setAge: (nextAge) => {\n    set((state) => ({\n      age: typeof nextAge === 'function' ? nextAge(state.age) : nextAge,\n    }))\n  },\n}))\n\nexport default function App() {\n  const age = useAgeStore((state) => state.age)\n  const setAge = useAgeStore((state) => state.setAge)\n\n  function increment() {\n    setAge((currentAge) => currentAge + 1)\n  }\n\n  return (\n    <>\n      <h1>Your age: {age}</h1>\n      <button\n        onClick={() => {\n          increment()\n          increment()\n          increment()\n        }}\n      >\n        +3\n      </button>\n      <button\n        onClick={() => {\n          increment()\n        }}\n      >\n        +1\n      </button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Zustand Store for Tic-Tac-Toe Game State\nDESCRIPTION: Setting up a Zustand store for a Tic-Tac-Toe game that tracks game history, current move, and whose turn is next. Includes state setter functions that handle both direct value updates and function-based updates.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_26\n\nLANGUAGE: javascript\nCODE:\n```\nconst useGameStore = create(\n  combine(\n    { history: [Array(9).fill(null)], currentMove: 0, xIsNext: true },\n    (set) => {\n      return {\n        setHistory: (nextHistory) => {\n          set((state) => ({\n            history:\n              typeof nextHistory === 'function'\n                ? nextHistory(state.history)\n                : nextHistory,\n          }))\n        },\n        setCurrentMove: (nextCurrentMove) => {\n          set((state) => ({\n            currentMove:\n              typeof nextCurrentMove === 'function'\n                ? nextCurrentMove(state.currentMove)\n                : nextCurrentMove,\n          }))\n        },\n        setXIsNext: (nextXIsNext) => {\n          set((state) => ({\n            xIsNext:\n              typeof nextXIsNext === 'function'\n                ? nextXIsNext(state.xIsNext)\n                : nextXIsNext,\n          }))\n        },\n      }\n    },\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Zustand Store\nDESCRIPTION: Example of creating a Zustand store with state and actions. The store contains a counter for bears with functions to increase, reset, and update the bear count.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/getting-started/introduction.md#2025-04-22_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport { create } from 'zustand'\n\nconst useStore = create((set) => ({\n  bears: 0,\n  increasePopulation: () => set((state) => ({ bears: state.bears + 1 })),\n  removeAllBears: () => set({ bears: 0 }),\n  updateBears: (newBears) => set({ bears: newBears }),\n}))\n```\n\n----------------------------------------\n\nTITLE: Creating a Typed Zustand Store in TypeScript\nDESCRIPTION: Demonstrates how to create a basic Zustand store with TypeScript, using type annotations for the state interface and store creation function.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\n\ninterface BearState {\n  bears: number\n  increase: (by: number) => void\n}\n\nconst useBearStore = create<BearState>()((set) => ({\n  bears: 0,\n  increase: (by) => set((state) => ({ bears: state.bears + by })),\n}))\n```\n\n----------------------------------------\n\nTITLE: Implementing the Slices Pattern with Zustand\nDESCRIPTION: Implementation of the slices pattern in Zustand allowing for modular state management. Each slice manages a specific part of the state while maintaining type safety and the ability to interact with other slices.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md#2025-04-22_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create, StateCreator } from 'zustand'\n\ninterface BearSlice {\n  bears: number\n  addBear: () => void\n  eatFish: () => void\n}\n\ninterface FishSlice {\n  fishes: number\n  addFish: () => void\n}\n\ninterface SharedSlice {\n  addBoth: () => void\n  getBoth: () => void\n}\n\nconst createBearSlice: StateCreator<\n  BearSlice & FishSlice,\n  [],\n  [],\n  BearSlice\n> = (set) => ({\n  bears: 0,\n  addBear: () => set((state) => ({ bears: state.bears + 1 })),\n  eatFish: () => set((state) => ({ fishes: state.fishes - 1 })),\n})\n\nconst createFishSlice: StateCreator<\n  BearSlice & FishSlice,\n  [],\n  [],\n  FishSlice\n> = (set) => ({\n  fishes: 0,\n  addFish: () => set((state) => ({ fishes: state.fishes + 1 })),\n})\n\nconst createSharedSlice: StateCreator<\n  BearSlice & FishSlice,\n  [],\n  [],\n  SharedSlice\n> = (set, get) => ({\n  addBoth: () => {\n    // you can reuse previous methods\n    get().addBear()\n    get().addFish()\n    // or do them from scratch\n    // set((state) => ({ bears: state.bears + 1, fishes: state.fishes + 1 })\n  },\n  getBoth: () => get().bears + get().fishes,\n})\n\nconst useBoundStore = create<BearSlice & FishSlice & SharedSlice>()((...a) => ({\n  ...createBearSlice(...a),\n  ...createFishSlice(...a),\n  ...createSharedSlice(...a),\n}))\n```\n\n----------------------------------------\n\nTITLE: Creating a Zustand Store with TypeScript\nDESCRIPTION: Demonstrates the basic syntax for creating a Zustand store using TypeScript. It shows the function signature and return type of the create function.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate<T>()(stateCreatorFn: StateCreator<T, [], []>): UseBoundStore<StoreApi<T>>\n```\n\n----------------------------------------\n\nTITLE: Combining Slices into Bounded Store in Zustand (JavaScript)\nDESCRIPTION: Demonstrates how to combine multiple slices into a single bounded store using Zustand's create function. This allows for modular state management.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/slices-pattern.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { create } from 'zustand'\nimport { createBearSlice } from './bearSlice'\nimport { createFishSlice } from './fishSlice'\n\nexport const useBoundStore = create((...a) => ({\n  ...createBearSlice(...a),\n  ...createFishSlice(...a),\n}))\n```\n\n----------------------------------------\n\nTITLE: Correct Form State Management Example\nDESCRIPTION: Shows the proper way to handle form state updates using Zustand by creating new state objects instead of mutating existing ones. Implements proper state immutability patterns.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create.md#2025-04-22_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport { create } from 'zustand'\n\ntype PersonStoreState = {\n  person: { firstName: string; lastName: string; email: string }\n}\n\ntype PersonStoreActions = {\n  setPerson: (nextPerson: PersonStoreState['person']) => void\n}\n\ntype PersonStore = PersonStoreState & PersonStoreActions\n\nconst usePersonStore = create<PersonStore>()((set) => ({\n  person: {\n    firstName: 'Barbara',\n    lastName: 'Hepworth',\n    email: 'bhepworth@sculpture.com',\n  },\n  setPerson: (nextPerson) => set(nextPerson),\n}))\n\nexport default function Form() {\n  const person = usePersonStore((state) => state.person)\n  const setPerson = usePersonStore((state) => state.setPerson)\n\n  function handleFirstNameChange(e: ChangeEvent<HTMLInputElement>) {\n    setPerson({ ...person, firstName: e.target.value })\n  }\n\n  function handleLastNameChange(e: ChangeEvent<HTMLInputElement>) {\n    setPerson({ ...person, lastName: e.target.value })\n  }\n\n  function handleEmailChange(e: ChangeEvent<HTMLInputElement>) {\n    setPerson({ ...person, email: e.target.value })\n  }\n\n  return (\n    <>\n      <label style={{ display: 'block' }}>\n        First name:\n        <input value={person.firstName} onChange={handleFirstNameChange} />\n      </label>\n      <label style={{ display: 'block' }}>\n        Last name:\n        <input value={person.lastName} onChange={handleLastNameChange} />\n      </label>\n      <label style={{ display: 'block' }}>\n        Email:\n        <input value={person.email} onChange={handleEmailChange} />\n      </label>\n      <p>\n        {person.firstName} {person.lastName} ({person.email})\n      </p>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Store with Zustand\nDESCRIPTION: Example of creating a basic counter store with Zustand. Demonstrates how to define state and actions in a Zustand store using the create function.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/getting-started/comparison.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\n\ntype State = {\n  count: number\n}\n\ntype Actions = {\n  increment: (qty: number) => void\n  decrement: (qty: number) => void\n}\n\nconst useCountStore = create<State & Actions>((set) => ({\n  count: 0,\n  increment: (qty: number) => set((state) => ({ count: state.count + qty })),\n  decrement: (qty: number) => set((state) => ({ count: state.count - qty })),\n}))\n```\n\n----------------------------------------\n\nTITLE: Creating a Zustand Store with createStore and Initial Props\nDESCRIPTION: Defines a configurable bear store using Zustand's createStore function that accepts optional initialization props. This pattern allows for dependency injection by overriding default values when creating the store instance.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/initialize-state-with-props.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'zustand'\n\ninterface BearProps {\n  bears: number\n}\n\ninterface BearState extends BearProps {\n  addBear: () => void\n}\n\ntype BearStore = ReturnType<typeof createBearStore>\n\nconst createBearStore = (initProps?: Partial<BearProps>) => {\n  const DEFAULT_PROPS: BearProps = {\n    bears: 0,\n  }\n  return createStore<BearState>()((set) => ({\n    ...DEFAULT_PROPS,\n    ...initProps,\n    addBear: () => set((state) => ({ bears: ++state.bears })),\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Example of Provider and Consumer Usage\nDESCRIPTION: Demonstrates a complete example of how to use the BearProvider with initial props and consume the store in a child component using the custom hook pattern.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/initialize-state-with-props.md#2025-04-22_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\n// Provider wrapper & custom hook consumer\nfunction App2() {\n  return (\n    <BearProvider bears={2}>\n      <HookConsumer />\n    </BearProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using Basic Middlewares with Zustand in TypeScript\nDESCRIPTION: Example of using devtools and persist middlewares with Zustand in TypeScript. The middlewares are applied directly inside the create function to ensure proper type inference.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\nimport { devtools, persist } from 'zustand/middleware'\n\ninterface BearState {\n  bears: number\n  increase: (by: number) => void\n}\n\nconst useBearStore = create<BearState>()(\n  devtools(\n    persist(\n      (set) => ({\n        bears: 0,\n        increase: (by) => set((state) => ({ bears: state.bears + by })),\n      }),\n      { name: 'bearStore' },\n    ),\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Redux-Style State Management\nDESCRIPTION: Implementation of Redux-like state management with action types and reducers in Zustand\nSOURCE: https://github.com/pmndrs/zustand/blob/main/README.md#2025-04-22_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\nconst types = { increase: 'INCREASE', decrease: 'DECREASE' }\n\nconst reducer = (state, { type, by = 1 }) => {\n  switch (type) {\n    case types.increase:\n      return { grumpiness: state.grumpiness + by }\n    case types.decrease:\n      return { grumpiness: state.grumpiness - by }\n  }\n}\n\nconst useGrumpyStore = create((set) => ({\n  grumpiness: 0,\n  dispatch: (args) => set((state) => reducer(state, args)),\n}))\n\nconst dispatch = useGrumpyStore((state) => state.dispatch)\ndispatch({ type: types.increase, by: 2 })\n```\n\n----------------------------------------\n\nTITLE: Colocating Store Actions in Zustand\nDESCRIPTION: Demonstrates how to structure a Zustand store with colocated actions directly within the store definition, unlike traditional Flux libraries that use dispatched actions and reducers.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/flux-inspired-practice.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst useBoundStore = create((set) => ({\n  storeSliceA: ...,\n  storeSliceB: ...,\n  storeSliceC: ...,\n  updateX: () => set(...),\n  updateY: () => set(...),\n}))\n```\n\n----------------------------------------\n\nTITLE: React Context Integration\nDESCRIPTION: Shows how to use Zustand with React Context for dependency injection\nSOURCE: https://github.com/pmndrs/zustand/blob/main/README.md#2025-04-22_snippet_18\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createContext, useContext } from 'react'\nimport { createStore, useStore } from 'zustand'\n\nconst store = createStore(...)\n\nconst StoreContext = createContext()\n\nconst App = () => (\n  <StoreContext.Provider value={store}>\n    ...\n  </StoreContext.Provider>\n)\n\nconst Component = () => {\n  const store = useContext(StoreContext)\n  const slice = useStore(store, selector)\n  ...\n```\n\n----------------------------------------\n\nTITLE: Complete Implementation of Dynamic Scoped Stores in React with Zustand\nDESCRIPTION: This snippet provides the full implementation of dynamic scoped stores using Zustand in a React application. It includes all necessary imports, type definitions, store creation, context setup, custom hooks, and components.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store-with-equality-fn.md#2025-04-22_snippet_20\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  type ReactNode,\n  useState,\n  useCallback,\n  useContext,\n  createContext,\n} from 'react'\nimport { createStore, useStore } from 'zustand'\n\ntype CounterState = {\n  count: number\n}\n\ntype CounterActions = { increment: () => void }\n\ntype CounterStore = CounterState & CounterActions\n\nconst createCounterStore = () => {\n  return createStore<CounterStore>()((set) => ({\n    count: 0,\n    increment: () => {\n      set((state) => ({ count: state.count + 1 }))\n    },\n  }))\n}\n\nconst createCounterStoreFactory = (\n  counterStores: Map<string, ReturnType<typeof createCounterStore>>,\n) => {\n  return (counterStoreKey: string) => {\n    if (!counterStores.has(counterStoreKey)) {\n      counterStores.set(counterStoreKey, createCounterStore())\n    }\n    return counterStores.get(counterStoreKey)!\n  }\n}\n\nconst CounterStoresContext = createContext<Map<\n  string,\n  ReturnType<typeof createCounterStore>\n> | null>(null)\n\nconst CounterStoresProvider = ({ children }: { children: ReactNode }) => {\n  const [stores] = useState(\n    () => new Map<string, ReturnType<typeof createCounterStore>>(),\n  )\n\n  return (\n    <CounterStoresContext.Provider value={stores}>\n      {children}\n    </CounterStoresContext.Provider>\n  )\n}\n\nconst useCounterStore = <U,>(\n  key: string,\n  selector: (state: CounterStore) => U,\n) => {\n  const stores = useContext(CounterStoresContext)\n\n  if (stores === undefined) {\n    throw new Error('useCounterStore must be used within CounterStoresProvider')\n  }\n\n  const getOrCreateCounterStoreByKey = useCallback(\n    (key: string) => createCounterStoreFactory(stores!)(key),\n    [stores],\n  )\n\n  return useStore(getOrCreateCounterStoreByKey(key), selector)\n}\n\nfunction Tabs() {\n  const [currentTabIndex, setCurrentTabIndex] = useState(0)\n  const counterState = useCounterStore(\n    `tab-${currentTabIndex}`,\n    (state) => state,\n  )\n\n  return (\n    <div style={{ fontFamily: 'monospace' }}>\n      <div\n        style={{\n          display: 'flex',\n          gap: '0.5rem',\n          borderBottom: '1px solid salmon',\n          paddingBottom: 4,\n        }}\n      >\n        <button\n          type=\"button\"\n          style={{\n            border: '1px solid salmon',\n            backgroundColor: '#fff',\n            cursor: 'pointer',\n          }}\n          onClick={() => setCurrentTabIndex(0)}\n        >\n          Tab 1\n        </button>\n        <button\n          type=\"button\"\n          style={{\n            border: '1px solid salmon',\n            backgroundColor: '#fff',\n            cursor: 'pointer',\n          }}\n          onClick={() => setCurrentTabIndex(1)}\n        >\n          Tab 2\n        </button>\n        <button\n          type=\"button\"\n          style={{\n            border: '1px solid salmon',\n            backgroundColor: '#fff',\n            cursor: 'pointer',\n          }}\n          onClick={() => setCurrentTabIndex(2)}\n        >\n          Tab 3\n        </button>\n      </div>\n      <div style={{ padding: 4 }}>\n        Content of Tab {currentTabIndex + 1}\n        <br /> <br />\n        <button type=\"button\" onClick={() => counterState.increment()}>\n          Count: {counterState.count}\n        </button>\n      </div>\n    </div>\n  )\n}\n\nexport default function App() {\n  return (\n    <CounterStoresProvider>\n      <Tabs />\n    </CounterStoresProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using Redux Middleware with Zustand\nDESCRIPTION: Demonstrates how to use Zustand's built-in redux middleware to wire up a main reducer, set initial state, and add dispatch functionality to the store, providing a more Redux-like experience.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/flux-inspired-practice.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { redux } from 'zustand/middleware'\n\nconst useReduxStore = create(redux(reducer, initialState))\n```\n\n----------------------------------------\n\nTITLE: Complete Redux Store Implementation Example\nDESCRIPTION: Full example of implementing a person store using Redux middleware in Zustand with TypeScript, including action types, reducer, and DOM manipulation\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/redux.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'zustand/vanilla'\nimport { redux } from 'zustand/middleware'\n\ntype PersonStoreState = {\n  firstName: string\n  lastName: string\n  email: string\n}\n\ntype PersonStoreAction =\n  | { type: 'person/setFirstName'; firstName: string }\n  | { type: 'person/setLastName'; lastName: string }\n  | { type: 'person/setEmail'; email: string }\n\ntype PersonStore = PersonStoreState & PersonStoreActions\n\nconst personStoreReducer = (\n  state: PersonStoreState,\n  action: PersonStoreAction,\n) => {\n  switch (action.type) {\n    case 'person/setFirstName': {\n      return { ...state, firstName: action.firstName }\n    }\n    case 'person/setLastName': {\n      return { ...state, lastName: action.lastName }\n    }\n    case 'person/setEmail': {\n      return { ...state, email: action.email }\n    }\n    default: {\n      return state\n    }\n  }\n}\n\nconst personStoreInitialState: PersonStoreState = {\n  firstName: 'Barbara',\n  lastName: 'Hepworth',\n  email: 'bhepworth@sculpture.com',\n}\n\nconst personStore = createStore<PersonStore>()(\n  redux(personStoreReducer, personStoreInitialState),\n)\n\nconst $firstNameInput = document.getElementById(\n  'first-name',\n) as HTMLInputElement\nconst $lastNameInput = document.getElementById('last-name') as HTMLInputElement\nconst $emailInput = document.getElementById('email') as HTMLInputElement\nconst $result = document.getElementById('result') as HTMLDivElement\n\nfunction handleFirstNameChange(event: Event) {\n  personStore.dispatch({\n    type: 'person/setFirstName',\n    firstName: (event.target as any).value,\n  })\n}\n\nfunction handleLastNameChange(event: Event) {\n  personStore.dispatch({\n    type: 'person/setLastName',\n    lastName: (event.target as any).value,\n  })\n}\n\nfunction handleEmailChange(event: Event) {\n  personStore.dispatch({\n    type: 'person/setEmail',\n    email: (event.target as any).value,\n  })\n}\n\n$firstNameInput.addEventListener('input', handleFirstNameChange)\n$lastNameInput.addEventListener('input', handleLastNameChange)\n$emailInput.addEventListener('input', handleEmailChange)\n\nconst render: Parameters<typeof personStore.subscribe>[0] = (person) => {\n  $firstNameInput.value = person.firstName\n  $lastNameInput.value = person.lastName\n  $emailInput.value = person.email\n\n  $result.innerHTML = `${person.firstName} ${person.lastName} (${person.email})`\n}\n\nrender(personStore.getInitialState(), personStore.getInitialState())\n\npersonStore.subscribe(render)\n```\n\n----------------------------------------\n\nTITLE: Accessing Store Values with Selectors in Zustand\nDESCRIPTION: Basic example of how to access values from a Zustand store using selectors. This pattern allows selecting specific parts of the store state.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/auto-generating-selectors.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst bears = useBearStore((state) => state.bears)\n```\n\n----------------------------------------\n\nTITLE: Colocating Actions and State within a Zustand Store\nDESCRIPTION: The recommended Zustand pattern where actions and state are defined together within the store creation. This creates a self-contained store with data and actions integrated in the same object.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/practice-with-no-store-actions.md#2025-04-22_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nexport const useBoundStore = create((set) => ({\n  count: 0,\n  text: 'hello',\n  inc: () => set((state) => ({ count: state.count + 1 })),\n  setText: (text) => set({ text }),\n}))\n```\n\n----------------------------------------\n\nTITLE: Using Vanilla Store with React Hook\nDESCRIPTION: Demonstrates how to use a vanilla Zustand store with the useStore React hook.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/README.md#2025-04-22_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useStore } from 'zustand'\nimport { vanillaStore } from './vanillaStore'\n\nconst useBoundStore = (selector) => useStore(vanillaStore, selector)\n```\n\n----------------------------------------\n\nTITLE: Simplified State Update in Zustand\nDESCRIPTION: This snippet demonstrates the simplified way to update state in Zustand, taking advantage of the built-in merging behavior of the 'set' function.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/immutable-state-and-merging.md#2025-04-22_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nset((state) => ({ count: state.count + 1 }))\n```\n\n----------------------------------------\n\nTITLE: Implementing Redux-like Reducers in Zustand\nDESCRIPTION: Shows how to implement Redux-like reducers in Zustand by defining a dispatch function at the root level of the store that uses a traditional reducer pattern with action types.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/flux-inspired-practice.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst types = { increase: 'INCREASE', decrease: 'DECREASE' }\n\nconst reducer = (state, { type, by = 1 }) => {\n  switch (type) {\n    case types.increase:\n      return { grumpiness: state.grumpiness + by }\n    case types.decrease:\n      return { grumpiness: state.grumpiness - by }\n  }\n}\n\nconst useGrumpyStore = create((set) => ({\n  grumpiness: 0,\n  dispatch: (args) => set((state) => reducer(state, args)),\n}))\n\nconst dispatch = useGrumpyStore((state) => state.dispatch)\ndispatch({ type: types.increase, by: 2 })\n```\n\n----------------------------------------\n\nTITLE: Using immer Middleware in Zustand for Simpler State Updates\nDESCRIPTION: Implementation of the same person store using the immer middleware, which allows for direct mutation of state in the updater functions while maintaining immutability under the hood.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/immer.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'zustand/vanilla'\nimport { immer } from 'zustand/middleware/immer'\n\ntype PersonStoreState = {\n  person: { firstName: string; lastName: string; email: string }\n}\n\ntype PersonStoreActions = {\n  setPerson: (\n    nextPerson: (\n      person: PersonStoreState['person'],\n    ) => PersonStoreState['person'] | PersonStoreState['person'],\n  ) => void\n}\n\ntype PersonStore = PersonStoreState & PersonStoreActions\n\nconst personStore = createStore<PersonStore>()(\n  immer((set) => ({\n    person: {\n      firstName: 'Barbara',\n      lastName: 'Hepworth',\n      email: 'bhepworth@sculpture.com',\n    },\n    setPerson: (nextPerson) =>\n      set((state) => {\n        state.person =\n          typeof nextPerson === 'function'\n            ? nextPerson(state.person)\n            : nextPerson\n      }),\n  })),\n)\n\nconst $firstNameInput = document.getElementById(\n  'first-name',\n) as HTMLInputElement\nconst $lastNameInput = document.getElementById('last-name') as HTMLInputElement\nconst $emailInput = document.getElementById('email') as HTMLInputElement\nconst $result = document.getElementById('result') as HTMLDivElement\n\nfunction handleFirstNameChange(event: Event) {\n  personStore.getState().setPerson((person) => {\n    person.firstName = (event.target as any).value\n  })\n}\n\nfunction handleLastNameChange(event: Event) {\n  personStore.getState().setPerson((person) => {\n    person.lastName = (event.target as any).value\n  })\n}\n\nfunction handleEmailChange(event: Event) {\n  personStore.getState().setPerson((person) => {\n    person.email = (event.target as any).value\n  })\n}\n\n$firstNameInput.addEventListener('input', handleFirstNameChange)\n$lastNameInput.addEventListener('input', handleLastNameChange)\n$emailInput.addEventListener('input', handleEmailChange)\n\nconst render: Parameters<typeof personStore.subscribe>[0] = (state) => {\n  $firstNameInput.value = state.person.firstName\n  $lastNameInput.value = state.person.lastName\n  $emailInput.value = state.person.email\n\n  $result.innerHTML = `${state.person.firstName} ${state.person.lastName} (${state.person.email})`\n}\n\nrender(personStore.getInitialState(), personStore.getInitialState())\n\npersonStore.subscribe(render)\n```\n\n----------------------------------------\n\nTITLE: Correct State Updates in Zustand Forms\nDESCRIPTION: Demonstrates the correct way to update form state in Zustand by creating new state objects instead of mutating existing ones.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-with-equality-fn.md#2025-04-22_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport { type ChangeEvent } from 'react'\nimport { createWithEqualityFn } from 'zustand/traditional'\nimport { shallow } from 'zustand/vanilla/shallow'\n\ntype PersonStoreState = {\n  person: { firstName: string; lastName: string; email: string }\n}\n\ntype PersonStoreActions = {\n  setPerson: (nextPerson: PersonStoreState['person']) => void\n}\n\ntype PersonStore = PersonStoreState & PersonStoreActions\n\nconst usePersonStore = createWithEqualityFn<PersonStore>()(\n  (set) => ({\n    person: {\n      firstName: 'Barbara',\n      lastName: 'Hepworth',\n      email: 'bhepworth@sculpture.com',\n    },\n    setPerson: (nextPerson) => set({ person: nextPerson }),\n  }),\n  shallow,\n)\n\nexport default function Form() {\n  const person = usePersonStore((state) => state.person)\n  const setPerson = usePersonStore((state) => state.setPerson)\n\n  function handleFirstNameChange(e: ChangeEvent<HTMLInputElement>) {\n    setPerson({ ...person, firstName: e.target.value })\n  }\n\n  function handleLastNameChange(e: ChangeEvent<HTMLInputElement>) {\n    setPerson({ ...person, lastName: e.target.value })\n  }\n\n  function handleEmailChange(e: ChangeEvent<HTMLInputElement>) {\n    setPerson({ ...person, email: e.target.value })\n  }\n\n  return (\n    <>\n      <label style={{ display: 'block' }}>\n        First name:\n        <input value={person.firstName} onChange={handleFirstNameChange} />\n      </label>\n      <label style={{ display: 'block' }}>\n        Last name:\n        <input value={person.lastName} onChange={handleLastNameChange} />\n      </label>\n      <label style={{ display: 'block' }}>\n        Email:\n        <input value={person.email} onChange={handleEmailChange} />\n      </label>\n      <p>\n        {person.firstName} {person.lastName} ({person.email})\n      </p>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Basic State Persistence Implementation\nDESCRIPTION: Demonstrates a complete implementation of a position tracker using Zustand's vanilla store with persist middleware to store position data in localStorage.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'zustand/vanilla'\nimport { persist } from 'zustand/middleware'\n\ntype PositionStoreState = { position: { x: number; y: number } }\n\ntype PositionStoreActions = {\n  setPosition: (nextPosition: PositionStoreState['position']) => void\n}\n\ntype PositionStore = PositionStoreState & PositionStoreActions\n\nconst positionStore = createStore<PositionStore>()(\n  persist(\n    (set) => ({\n      position: { x: 0, y: 0 },\n      setPosition: (position) => set({ position }),\n    }),\n    { name: 'position-storage' },\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Render Optimization with Zustand\nDESCRIPTION: Demonstrates how to implement render optimization in Zustand using selectors. Shows how to extract specific state properties and actions to prevent unnecessary re-renders.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/getting-started/comparison.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\n\ntype State = {\n  count: number\n}\n\ntype Actions = {\n  increment: (qty: number) => void\n  decrement: (qty: number) => void\n}\n\nconst useCountStore = create<State & Actions>((set) => ({\n  count: 0,\n  increment: (qty: number) => set((state) => ({ count: state.count + qty })),\n  decrement: (qty: number) => set((state) => ({ count: state.count - qty })),\n}))\n\nconst Component = () => {\n  const count = useCountStore((state) => state.count)\n  const increment = useCountStore((state) => state.increment)\n  const decrement = useCountStore((state) => state.decrement)\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Persistence in Zustand Store\nDESCRIPTION: A simple example demonstrating how to create a Zustand store with persistence functionality using sessionStorage. The store keeps track of a bear count with an increment function.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/integrations/persisting-store-data.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\nimport { persist, createJSONStorage } from 'zustand/middleware'\n\nexport const useBearStore = create()(\n  persist(\n    (set, get) => ({\n      bears: 0,\n      addABear: () => set({ bears: get().bears + 1 }),\n    }),\n    {\n      name: 'food-storage', // name of the item in the storage (must be unique)\n      storage: createJSONStorage(() => sessionStorage), // (optional) by default, 'localStorage' is used\n    },\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Type Definition for persist Middleware Mutator\nDESCRIPTION: TypeScript type definition for the mutator that persist middleware adds to the store.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n['zustand/persist', U]\n```\n\n----------------------------------------\n\nTITLE: Updating Complex States with Immer Middleware in Zustand\nDESCRIPTION: Shows how to manage complex nested state with Zustand and Immer middleware. This example demonstrates a todo list application with direct state mutations for toggling todo completion status.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/integrations/immer-middleware.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\nimport { immer } from 'zustand/middleware/immer'\n\ninterface Todo {\n  id: string\n  title: string\n  done: boolean\n}\n\ntype State = {\n  todos: Record<string, Todo>\n}\n\ntype Actions = {\n  toggleTodo: (todoId: string) => void\n}\n\nexport const useTodoStore = create<State & Actions>()(\n  immer((set) => ({\n    todos: {\n      '82471c5f-4207-4b1d-abcb-b98547e01a3e': {\n        id: '82471c5f-4207-4b1d-abcb-b98547e01a3e',\n        title: 'Learn Zustand',\n        done: false,\n      },\n      '354ee16c-bfdd-44d3-afa9-e93679bda367': {\n        id: '354ee16c-bfdd-44d3-afa9-e93679bda367',\n        title: 'Learn Jotai',\n        done: false,\n      },\n      '771c85c5-46ea-4a11-8fed-36cc2c7be344': {\n        id: '771c85c5-46ea-4a11-8fed-36cc2c7be344',\n        title: 'Learn Valtio',\n        done: false,\n      },\n      '363a4bac-083f-47f7-a0a2-aeeee153a99c': {\n        id: '363a4bac-083f-47f7-a0a2-aeeee153a99c',\n        title: 'Learn Signals',\n        done: false,\n      },\n    },\n    toggleTodo: (todoId: string) =>\n      set((state) => {\n        state.todos[todoId].done = !state.todos[todoId].done\n      }),\n  })),\n)\n```\n\n----------------------------------------\n\nTITLE: Using Immer with Zustand\nDESCRIPTION: Demonstrates how to use Immer to handle nested state updates in Zustand store with simplified mutations\nSOURCE: https://github.com/pmndrs/zustand/blob/main/README.md#2025-04-22_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\nimport { produce } from 'immer'\n\nconst useLushStore = create((set) => ({\n  lush: { forest: { contains: { a: 'bear' } } },\n  clearForest: () =>\n    set(\n      produce((state) => {\n        state.lush.forest.contains = null\n      }),\n    ),\n}))\n\nconst clearForest = useLushStore((state) => state.clearForest)\nclearForest()\n```\n\n----------------------------------------\n\nTITLE: Implementing Board and Game Components with React\nDESCRIPTION: Defines the Board component that handles rendering squares and game status, and introduces a new Game component that will serve as the top-level container. The Game component will eventually manage game history.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\nfunction Board() {\n  const xIsNext = useGameStore((state) => state.xIsNext)\n  const setXIsNext = useGameStore((state) => state.setXIsNext)\n  const squares = useGameStore((state) => state.squares)\n  const setSquares = useGameStore((state) => state.setSquares)\n  const winner = calculateWinner(squares)\n  const turns = calculateTurns(squares)\n  const player = xIsNext ? 'X' : 'O'\n  const status = calculateStatus(winner, turns, player)\n\n  function handleClick(i) {\n    if (squares[i] || winner) return\n    const nextSquares = squares.slice()\n    nextSquares[i] = player\n    setSquares(nextSquares)\n    setXIsNext(!xIsNext)\n  }\n\n  return (\n    <>\n      <div style={{ marginBottom: '0.5rem' }}>{status}</div>\n      <div\n        style={{\n          display: 'grid',\n          gridTemplateColumns: 'repeat(3, 1fr)',\n          gridTemplateRows: 'repeat(3, 1fr)',\n          width: 'calc(3 * 2.5rem)',\n          height: 'calc(3 * 2.5rem)',\n          border: '1px solid #999',\n        }}\n      >\n        {squares.map((square, squareIndex) => (\n          <Square\n            key={squareIndex}\n            value={square}\n            onSquareClick={() => handleClick(squareIndex)}\n          />\n        ))}\n      </div>\n    </>\n  )\n}\n\nexport default function Game() {\n  return (\n    <div\n      style={{\n        display: 'flex',\n        flexDirection: 'row',\n        fontFamily: 'monospace',\n      }}\n    >\n      <div>\n        <Board />\n      </div>\n      <div style={{ marginLeft: '1rem' }}>\n        <ol>{/* TODO */}</ol>\n      </div>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Bear Slice in Zustand (JavaScript)\nDESCRIPTION: Defines a slice for managing bear state in a Zustand store. It includes a state property for the number of bears, methods to add a bear and eat a fish.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/slices-pattern.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const createBearSlice = (set) => ({\n  bears: 0,\n  addBear: () => set((state) => ({ bears: state.bears + 1 })),\n  eatFish: () => set((state) => ({ fishes: state.fishes - 1 })),\n})\n```\n\n----------------------------------------\n\nTITLE: Reading State in Actions with get Function\nDESCRIPTION: Shows how to read the current state within actions using the get function.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/README.md#2025-04-22_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst useSoundStore = create((set, get) => ({\n  sound: 'grunt',\n  action: () => {\n    const sound = get().sound\n    ...\n\n```\n\n----------------------------------------\n\nTITLE: Basic persist Middleware Usage with StateCreator Function\nDESCRIPTION: Shows the basic function signature for using the persist middleware with a state creator function. The persist middleware wraps a state creator function and adds persistence capabilities.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst nextStateCreatorFn = persist(stateCreatorFn, persistOptions)\n```\n\n----------------------------------------\n\nTITLE: Creating a Zustand Store with Object State\nDESCRIPTION: Creates a basic Zustand store that holds meal data for three bears, then defines a component that extracts and displays their names using a selector.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/prevent-rerenders-with-use-shallow.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { create } from 'zustand'\n\nconst useMeals = create(() => ({\n  papaBear: 'large porridge-pot',\n  mamaBear: 'middle-size porridge pot',\n  littleBear: 'A little, small, wee pot',\n}))\n\nexport const BearNames = () => {\n  const names = useMeals((state) => Object.keys(state))\n\n  return <div>{names.join(', ')}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Persisting Zustand State with URL Query Parameters\nDESCRIPTION: Implements a StateStorage that conditionally uses URL query parameters or falls back to localStorage. This allows state to be shared and persisted via URL query parameters, enabling bookmarking and sharing application state.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/connect-to-state-with-url-hash.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\nimport { persist, StateStorage, createJSONStorage } from 'zustand/middleware'\n\nconst getUrlSearch = () => {\n  return window.location.search.slice(1)\n}\n\nconst persistentStorage: StateStorage = {\n  getItem: (key): string => {\n    // Check URL first\n    if (getUrlSearch()) {\n      const searchParams = new URLSearchParams(getUrlSearch())\n      const storedValue = searchParams.get(key)\n      return JSON.parse(storedValue as string)\n    } else {\n      // Otherwise, we should load from localstorage or alternative storage\n      return JSON.parse(localStorage.getItem(key) as string)\n    }\n  },\n  setItem: (key, newValue): void => {\n    // Check if query params exist at all, can remove check if always want to set URL\n    if (getUrlSearch()) {\n      const searchParams = new URLSearchParams(getUrlSearch())\n      searchParams.set(key, JSON.stringify(newValue))\n      window.history.replaceState(null, '', `?${searchParams.toString()}`)\n    }\n\n    localStorage.setItem(key, JSON.stringify(newValue))\n  },\n  removeItem: (key): void => {\n    const searchParams = new URLSearchParams(getUrlSearch())\n    searchParams.delete(key)\n    window.location.search = searchParams.toString()\n  },\n}\n\ntype LocalAndUrlStore = {\n  typesOfFish: string[]\n  addTypeOfFish: (fishType: string) => void\n  numberOfBears: number\n  setNumberOfBears: (newNumber: number) => void\n}\n\nconst storageOptions = {\n  name: 'fishAndBearsStore',\n  storage: createJSONStorage<LocalAndUrlStore>(() => persistentStorage),\n}\n\nconst useLocalAndUrlStore = create(\n  persist<LocalAndUrlStore>(\n    (set) => ({\n      typesOfFish: [],\n      addTypeOfFish: (fishType) =>\n        set((state) => ({ typesOfFish: [...state.typesOfFish, fishType] })),\n\n      numberOfBears: 0,\n      setNumberOfBears: (numberOfBears) => set(() => ({ numberOfBears })),\n    }),\n    storageOptions,\n  ),\n)\n\nexport default useLocalAndUrlStore\n```\n\n----------------------------------------\n\nTITLE: Implementing Position Tracking with Zustand State Subscription\nDESCRIPTION: Creates a moving dot component that updates its position using Zustand state management. Demonstrates state subscription pattern with cleanup handling and random position updates on mouse interaction.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create.md#2025-04-22_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useEffect } from 'react'\nimport { create } from 'zustand'\n\ntype PositionStoreState = { position: { x: number; y: number } }\n\ntype PositionStoreActions = {\n  setPosition: (nextPosition: PositionStoreState['position']) => void\n}\n\ntype PositionStore = PositionStoreState & PositionStoreActions\n\nconst usePositionStore = create<PositionStore>()((set) => ({\n  position: { x: 0, y: 0 },\n  setPosition: (nextPosition) => set(nextPosition),\n}))\n\nexport default function MovingDot() {\n  const position = usePositionStore((state) => state.position)\n  const setPosition = usePositionStore((state) => state.setPosition)\n\n  useEffect(() => {\n    const unsubscribePositionStore = usePositionStore.subscribe(\n      ({ position }) => {\n        console.log('new position', { position })\n      },\n    )\n\n    return () => {\n      unsubscribePositionStore()\n    }\n  }, [])\n\n  return (\n    <div\n      style={{\n        position: 'relative',\n        width: '100vw',\n        height: '100vh',\n      }}\n    >\n      <div\n        style={{\n          position: 'absolute',\n          backgroundColor: 'red',\n          borderRadius: '50%',\n          transform: `translate(${position.x}px, ${position.y}px)`,\n          left: -10,\n          top: -10,\n          width: 20,\n          height: 20,\n        }}\n        onMouseEnter={(event) => {\n          const parent = event.currentTarget.parentElement\n          const parentWidth = parent.clientWidth\n          const parentHeight = parent.clientHeight\n\n          setPosition({\n            x: Math.ceil(Math.random() * parentWidth),\n            y: Math.ceil(Math.random() * parentHeight),\n          })\n        }}\n      />\n    </div>\n  )\n```\n\n----------------------------------------\n\nTITLE: Creating Zustand Store for Tic-Tac-Toe State Management using JavaScript\nDESCRIPTION: This snippet sets up a Zustand store for managing the Tic-Tac-Toe game's state, including the squares and which player is next. It utilizes the combine function to link state modifications to the respective square states and the active player.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nconst useGameStore = create(\n  combine({ squares: Array(9).fill(null), xIsNext: true }, (set) => {\n    return {\n      setSquares: (nextSquares) => {\n        set((state) => ({\n          squares:\n            typeof nextSquares === 'function'\n              ? nextSquares(state.squares)\n              : nextSquares,\n        }))\n      },\n      setXIsNext: (nextXIsNext) => {\n        set((state) => ({\n          xIsNext:\n            typeof nextXIsNext === 'function'\n              ? nextXIsNext(state.xIsNext)\n              : nextXIsNext,\n        }))\n      },\n    }\n  }),\n)\n```\n\n----------------------------------------\n\nTITLE: Custom Storage Engine Implementation\nDESCRIPTION: Example of implementing a custom storage engine with IndexedDB integration\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/integrations/persisting-store-data.md#2025-04-22_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\nimport { persist, createJSONStorage, StateStorage } from 'zustand/middleware'\nimport { get, set, del } from 'idb-keyval'\n\nconst storage: StateStorage = {\n  getItem: async (name: string): Promise<string | null> => {\n    console.log(name, 'has been retrieved')\n    return (await get(name)) || null\n  },\n  setItem: async (name: string, value: string): Promise<void> => {\n    console.log(name, 'with value', value, 'has been saved')\n    await set(name, value)\n  },\n  removeItem: async (name: string): Promise<void> => {\n    console.log(name, 'has been deleted')\n    await del(name)\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Render Optimization with Zustand for Recoil Comparison\nDESCRIPTION: Demonstrates how to implement render optimization in Zustand when compared to Recoil. Shows selecting state and actions separately.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/getting-started/comparison.md#2025-04-22_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\n\ntype State = {\n  count: number\n}\n\ntype Actions = {\n  setCount: (countCallback: (count: State['count']) => State['count']) => void\n}\n\nconst useCountStore = create<State & Actions>((set) => ({\n  count: 0,\n  setCount: (countCallback) =>\n    set((state) => ({ count: countCallback(state.count) })),\n}))\n\nconst Component = () => {\n  const count = useCountStore((state) => state.count)\n  const setCount = useCountStore((state) => state.setCount)\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Zustand Store\nDESCRIPTION: Example of creating a basic Zustand store with state and actions. This store tracks the number of bears and provides methods to increase the count.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/auto-generating-selectors.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ninterface BearState {\n  bears: number\n  increase: (by: number) => void\n  increment: () => void\n}\n\nconst useBearStoreBase = create<BearState>()((set) => ({\n  bears: 0,\n  increase: (by) => set((state) => ({ bears: state.bears + by })),\n  increment: () => set((state) => ({ bears: state.bears + 1 })),\n}))\n```\n\n----------------------------------------\n\nTITLE: Render Optimization with Zustand and Selectors\nDESCRIPTION: Demonstrates manual render optimization in Zustand using selectors. Shows selecting both state and actions separately to minimize component re-renders.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/getting-started/comparison.md#2025-04-22_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\n\ntype State = {\n  count: number\n}\n\ntype Actions = {\n  updateCount: (\n    countCallback: (count: State['count']) => State['count'],\n  ) => void\n}\n\nconst useCountStore = create<State & Actions>((set) => ({\n  count: 0,\n  updateCount: (countCallback) =>\n    set((state) => ({ count: countCallback(state.count) })),\n}))\n\nconst Component = () => {\n  const count = useCountStore((state) => state.count)\n  const updateCount = useCountStore((state) => state.updateCount)\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized Implementation with useShallow\nDESCRIPTION: Complete implementation using useShallow for optimized rendering performance.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-shallow.md#2025-04-22_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useEffect } from 'react'\nimport { create } from 'zustand'\nimport { useShallow } from 'zustand/react/shallow'\n\ntype BearFamilyMealsStore = {\n  [key: string]: string\n}\n\nconst useBearFamilyMealsStore = create<BearFamilyMealsStore>()(() => ({\n  papaBear: 'large porridge-pot',\n  mamaBear: 'middle-size porridge pot',\n  babyBear: 'A little, small, wee pot',\n}))\n\nconst meals = [\n  'A tiny, little, wee bowl',\n  'A small, petite, tiny pot',\n  'A wee, itty-bitty, small bowl',\n  'A little, petite, tiny dish',\n  'A tiny, small, wee vessel',\n  'A small, little, wee cauldron',\n  'A little, tiny, small cup',\n  'A wee, small, little jar',\n  'A tiny, wee, small pan',\n  'A small, wee, little crock',\n]\n\nfunction UpdateBabyBearMeal() {\n  useEffect(() => {\n    const timer = setInterval(() => {\n      useBearFamilyMealsStore.setState({\n        babyBear: meals[Math.floor(Math.random() * (meals.length - 1))],\n      })\n    }, 1000)\n\n    return () => {\n      clearInterval(timer)\n    }\n  }, [])\n\n  return null\n}\n\nfunction BearNames() {\n  const names = useBearFamilyMealsStore(\n    useShallow((state) => Object.keys(state)),\n  )\n\n  return <div>{names.join(', ')}</div>\n}\n\nexport default function App() {\n  return (\n    <>\n      <UpdateBabyBearMeal />\n      <BearNames />\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Objects in Zustand State\nDESCRIPTION: Demonstrates how to update objects in Zustand state, treating them as immutable and creating new objects for updates. It explains shallow merging and complete state replacement.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create.md#2025-04-22_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { create } from 'zustand'\n\ntype PositionStoreState = { position: { x: number; y: number } }\n\ntype PositionStoreActions = {\n  setPosition: (nextPosition: PositionStoreState['position']) => void\n}\n\ntype PositionStore = PositionStoreState & PositionStoreActions\n\nconst usePositionStore = create<PositionStore>()((set) => ({\n  position: { x: 0, y: 0 },\n  setPosition: (nextPosition) => set(nextPosition),\n}))\n\nexport default function MovingDot() {\n  const position = usePositionStore((state) => state.position)\n  const setPosition = usePositionStore((state) => state.setPosition)\n\n  return (\n    <div\n      onPointerMove={(e) => {\n        setPosition({\n          x: e.clientX,\n          y: e.clientY,\n        })\n      }}\n      style={{\n        position: 'relative',\n        width: '100vw',\n        height: '100vh',\n      }}\n    >\n      <div\n        style={{\n          position: 'absolute',\n          backgroundColor: 'red',\n          borderRadius: '50%',\n          transform: `translate(${position.x}px, ${position.y}px)`,\n          left: -10,\n          top: -10,\n          width: 20,\n          height: 20,\n        }}\n      />\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Render Optimization with Zustand Selectors\nDESCRIPTION: Illustrates Zustand's approach to render optimization using selectors. Demonstrates selecting specific state properties to minimize re-renders.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/getting-started/comparison.md#2025-04-22_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\n\ntype State = {\n  count: number\n}\n\nconst useCountStore = create<State>(() => ({\n  count: 0,\n}))\n\nconst Component = () => {\n  const count = useCountStore((state) => state.count)\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Persist Middleware Implementation\nDESCRIPTION: Shows how to implement persistence in Zustand stores using storage middleware with customizable storage options\nSOURCE: https://github.com/pmndrs/zustand/blob/main/README.md#2025-04-22_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\nimport { create } from 'zustand'\nimport { persist, createJSONStorage } from 'zustand/middleware'\n\nconst useFishStore = create(\n  persist(\n    (set, get) => ({\n      fishes: 0,\n      addAFish: () => set({ fishes: get().fishes + 1 }),\n    }),\n    {\n      name: 'food-storage',\n      storage: createJSONStorage(() => sessionStorage),\n    },\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Counter Component with Direct Store Usage\nDESCRIPTION: React component that directly uses the Zustand counter store to display and update the count.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/testing.md#2025-04-22_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useCounterStore } from '../../stores/use-counter-store'\n\nexport function Counter() {\n  const { count, inc } = useCounterStore()\n\n  return (\n    <div>\n      <h2>Counter Store</h2>\n      <h4>{count}</h4>\n      <button onClick={inc}>One Up</button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Basic Zustand Store with TypeScript\nDESCRIPTION: Demonstrates how to create a basic Zustand store with state and actions, and how to consume it in a React component. Shows flat state updates using the set function.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/updating-state.md#2025-04-22_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { create } from 'zustand'\n\ntype State = {\n  firstName: string\n  lastName: string\n}\n\ntype Action = {\n  updateFirstName: (firstName: State['firstName']) => void\n  updateLastName: (lastName: State['lastName']) => void\n}\n\n// Create your store, which includes both state and (optionally) actions\nconst usePersonStore = create<State & Action>((set) => ({\n  firstName: '',\n  lastName: '',\n  updateFirstName: (firstName) => set(() => ({ firstName: firstName })),\n  updateLastName: (lastName) => set(() => ({ lastName: lastName })),\n}))\n\n// In consuming app\nfunction App() {\n  // \"select\" the needed state and actions, in this case, the firstName value\n  // and the action updateFirstName\n  const firstName = usePersonStore((state) => state.firstName)\n  const updateFirstName = usePersonStore((state) => state.updateFirstName)\n\n  return (\n    <main>\n      <label>\n        First name\n        <input\n          // Update the \"firstName\" state\n          onChange={(e) => updateFirstName(e.currentTarget.value)}\n          value={firstName}\n        />\n      </label>\n\n      <p>\n        Hello, <strong>{firstName}!</strong>\n      </p>\n    </main>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Vanilla Zustand Store\nDESCRIPTION: Example of creating a vanilla Zustand store using the createStore function. This store has the same structure and functionality as the React version.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/auto-generating-selectors.md#2025-04-22_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'zustand'\n\ninterface BearState {\n  bears: number\n  increase: (by: number) => void\n  increment: () => void\n}\n\nconst store = createStore<BearState>((set) => ({\n  bears: 0,\n  increase: (by) => set((state) => ({ bears: state.bears + by })),\n  increment: () => set((state) => ({ bears: state.bears + 1 })),\n}))\n```\n\n----------------------------------------\n\nTITLE: Updating Deeply Nested State with optics-ts\nDESCRIPTION: Demonstrates using the optics-ts library to update deeply nested state in Zustand with a more functional approach.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/updating-state.md#2025-04-22_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\n  opticsInc: () =>\n    set(O.modify(O.optic<State>().path(\"deep.nested.obj.count\"))((c) => c + 1)),\n```\n\n----------------------------------------\n\nTITLE: Implementing Map and Set Updates in Zustand Store\nDESCRIPTION: Shows how to create and update a Zustand store containing Map and Set objects. Demonstrates the proper way to trigger React re-renders by creating new instances when updating these collections.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/maps-and-sets-usage.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { create } from 'zustand'\n\nconst useFooBar = create(() => ({ foo: new Map(), bar: new Set() }))\n\nfunction doSomething() {\n  // doing something...\n\n  // If you want to update some React component that uses `useFooBar`, you have to call setState\n  // to let React know that an update happened.\n  // Following React's best practices, you should create a new Map/Set when updating them:\n  useFooBar.setState((prev) => ({\n    foo: new Map(prev.foo).set('newKey', 'newValue'),\n    bar: new Set(prev.bar).add('newKey'),\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Zustand Store with Immutable State Update\nDESCRIPTION: This snippet demonstrates how to create a simple Zustand store with a count state and an increment function. It shows the basic usage of the 'set' function for immutable state updates.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/immutable-state-and-merging.md#2025-04-22_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { create } from 'zustand'\n\nconst useCountStore = create((set) => ({\n  count: 0,\n  inc: () => set((state) => ({ count: state.count + 1 })),\n}))\n```\n\n----------------------------------------\n\nTITLE: Next.js Pages Implementation with Counter Store\nDESCRIPTION: Example implementation of Next.js pages using the counter store with both global and route-level store initialization.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/nextjs.md#2025-04-22_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n// src/components/pages/home-page.tsx\nimport { useCounterStore } from '@/providers/counter-store-provider.ts'\n\nexport const HomePage = () => {\n  const { count, incrementCount, decrementCount } = useCounterStore(\n    (state) => state,\n  )\n\n  return (\n    <div>\n      Count: {count}\n      <hr />\n      <button type=\"button\" onClick={incrementCount}>\n        Increment Count\n      </button>\n      <button type=\"button\" onClick={decrementCount}>\n        Decrement Count\n      </button>\n    </div>\n  )\n}\n```\n\nLANGUAGE: tsx\nCODE:\n```\n// src/_app.tsx\nimport type { AppProps } from 'next/app'\n\nimport { CounterStoreProvider } from '@/providers/counter-store-provider.tsx'\n\nexport default function App({ Component, pageProps }: AppProps) {\n  return (\n    <CounterStoreProvider>\n      <Component {...pageProps} />\n    </CounterStoreProvider>\n  )\n}\n```\n\nLANGUAGE: tsx\nCODE:\n```\n// src/pages/index.tsx\nimport { CounterStoreProvider } from '@/providers/counter-store-provider.tsx'\nimport { HomePage } from '@/components/pages/home-page.tsx'\n\nexport default function Home() {\n  return (\n    <CounterStoreProvider>\n      <HomePage />\n    </CounterStoreProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Version Migration in Zustand Persist\nDESCRIPTION: Example demonstrating how to handle version changes in persistent storage using the migrate function to transform data from previous versions to current format.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/integrations/persisting-store-data.md#2025-04-22_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport const useBoundStore = create(\n  persist(\n    (set, get) => ({\n      newField: 0, // let's say this field was named otherwise in version 0\n    }),\n    {\n      // ...\n      version: 1, // a migration will be triggered if the version in the storage mismatches this one\n      migrate: (persistedState, version) => {\n        if (version === 0) {\n          // if the stored value is in version 0, we rename the field to the new name\n          persistedState.newField = persistedState.oldField\n          delete persistedState.oldField\n        }\n\n        return persistedState\n      },\n    },\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Building Tabs Component with Independent Counters in React\nDESCRIPTION: This snippet creates a Tabs component that allows users to switch between tabs and increment each tab's counter independently. It uses the custom useCounterStore hook to manage state for each tab.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store-with-equality-fn.md#2025-04-22_snippet_18\n\nLANGUAGE: tsx\nCODE:\n```\nfunction Tabs() {\n  const [currentTabIndex, setCurrentTabIndex] = useState(0)\n  const counterState = useCounterStore(\n    `tab-${currentTabIndex}`,\n    (state) => state,\n  )\n\n  return (\n    <div style={{ fontFamily: 'monospace' }}>\n      <div\n        style={{\n          display: 'flex',\n          gap: '0.5rem',\n          borderBottom: '1px solid salmon',\n          paddingBottom: 4,\n        }}\n      >\n        <button\n          type=\"button\"\n          style={{\n            border: '1px solid salmon',\n            backgroundColor: '#fff',\n            cursor: 'pointer',\n          }}\n          onClick={() => setCurrentTabIndex(0)}\n        >\n          Tab 1\n        </button>\n        <button\n          type=\"button\"\n          style={{\n            border: '1px solid salmon',\n            backgroundColor: '#fff',\n            cursor: 'pointer',\n          }}\n          onClick={() => setCurrentTabIndex(1)}\n        >\n          Tab 2\n        </button>\n        <button\n          type=\"button\"\n          style={{\n            border: '1px solid salmon',\n            backgroundColor: '#fff',\n            cursor: 'pointer',\n          }}\n          onClick={() => setCurrentTabIndex(2)}\n        >\n          Tab 3\n        </button>\n      </div>\n      <div style={{ padding: 4 }}>\n        Content of Tab {currentTabIndex + 1}\n        <br /> <br />\n        <button type=\"button\" onClick={() => counterState.increment()}>\n          Count: {counterState.count}\n        </button>\n      </div>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript Implementation\nDESCRIPTION: Demonstrates TypeScript usage with Zustand including middleware and proper type definitions\nSOURCE: https://github.com/pmndrs/zustand/blob/main/README.md#2025-04-22_snippet_19\n\nLANGUAGE: ts\nCODE:\n```\nimport { create } from 'zustand'\nimport { devtools, persist } from 'zustand/middleware'\nimport type {} from '@redux-devtools/extension'\n\ninterface BearState {\n  bears: number\n  increase: (by: number) => void\n}\n\nconst useBearStore = create<BearState>()(\n  devtools(\n    persist(\n      (set) => ({\n        bears: 0,\n        increase: (by) => set((state) => ({ bears: state.bears + by })),\n      }),\n      {\n        name: 'bear-storage',\n      },\n    ),\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Game Store with Zustand\nDESCRIPTION: Creates a Zustand store to manage game state including move history and current move tracking. Uses the combine middleware to organize state and actions.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { create } from 'zustand'\nimport { combine } from 'zustand/middleware'\n\nconst useGameStore = create(\n  combine(\n    {\n      history: [Array(9).fill(null)],\n      currentMove: 0,\n    },\n    (set, get) => {\n      return {\n        setHistory: (nextHistory) => {\n          set((state) => ({\n            history:\n              typeof nextHistory === 'function'\n                ? nextHistory(state.history)\n                : nextHistory,\n          }))\n        },\n        setCurrentMove: (nextCurrentMove) => {\n          set((state) => ({\n            currentMove:\n              typeof nextCurrentMove === 'function'\n                ? nextCurrentMove(state.currentMove)\n                : nextCurrentMove,\n          }))\n        },\n      }\n    },\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Updating Simple States with Immer Middleware in Zustand\nDESCRIPTION: Demonstrates how to create a simple counter store using Zustand with Immer middleware. The example shows how to update state properties directly through mutation with Immer.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/integrations/immer-middleware.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\nimport { immer } from 'zustand/middleware/immer'\n\ntype State = {\n  count: number\n}\n\ntype Actions = {\n  increment: (qty: number) => void\n  decrement: (qty: number) => void\n}\n\nexport const useCountStore = create<State & Actions>()(\n  immer((set) => ({\n    count: 0,\n    increment: (qty: number) =>\n      set((state) => {\n        state.count += qty\n      }),\n    decrement: (qty: number) =>\n      set((state) => {\n        state.count -= qty\n      }),\n  })),\n)\n```\n\n----------------------------------------\n\nTITLE: Using Auto-Generated Selectors in Zustand\nDESCRIPTION: Examples of how to use the auto-generated selectors to access store properties and actions directly without writing selector functions manually.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/auto-generating-selectors.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// get the property\nconst bears = useBearStore.use.bears()\n\n// get the action\nconst increment = useBearStore.use.increment()\n```\n\n----------------------------------------\n\nTITLE: Updating Nested Objects in Zustand Store\nDESCRIPTION: This example shows how to update nested objects in a Zustand store. It demonstrates the need for explicit merging using the spread operator for nested properties.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/immutable-state-and-merging.md#2025-04-22_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { create } from 'zustand'\n\nconst useCountStore = create((set) => ({\n  nested: { count: 0 },\n  inc: () =>\n    set((state) => ({\n      nested: { ...state.nested, count: state.nested.count + 1 },\n    })),\n}))\n```\n\n----------------------------------------\n\nTITLE: Implementing a Multi-Store Reset Mechanism in Zustand with TypeScript\nDESCRIPTION: This code snippet shows how to create a mechanism for resetting multiple Zustand stores at once. It uses a Set to keep track of reset functions for each store and provides a custom 'create' function that automatically adds the reset capability to new stores.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/how-to-reset-state.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { StateCreator } from 'zustand'\nimport { create: actualCreate } from 'zustand'\n\nconst storeResetFns = new Set<() => void>()\n\nconst resetAllStores = () => {\n  storeResetFns.forEach((resetFn) => {\n    resetFn()\n  })\n}\n\nexport const create = (<T>() => {\n  return (stateCreator: StateCreator<T>) => {\n    const store = actualCreate(stateCreator)\n    const initialState = store.getInitialState()\n    storeResetFns.add(() => {\n      store.setState(initialState, true)\n    })\n    return store\n  }\n}) as typeof actualCreate\n```\n\n----------------------------------------\n\nTITLE: Updating State Based on Previous State with Updater Functions\nDESCRIPTION: Complete example showing how to implement updater functions in actions to update state based on its previous value. This pattern is useful for atomic state updates.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-store.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'zustand/vanilla'\n\ntype AgeStoreState = { age: number }\n\ntype AgeStoreActions = {\n  setAge: (\n    nextAge:\n      | AgeStoreState['age']\n      | ((currentAge: AgeStoreState['age']) => AgeStoreState['age']),\n  ) => void\n}\n\ntype AgeStore = AgeStoreState & AgeStoreActions\n\nconst ageStore = createStore<AgeStore>()((set) => ({\n  age: 42,\n  setAge: (nextAge) =>\n    set((state) => ({\n      age: typeof nextAge === 'function' ? nextAge(state.age) : nextAge,\n    })),\n}))\n\nfunction increment() {\n  ageStore.getState().setAge((currentAge) => currentAge + 1)\n}\n\nconst $yourAgeHeading = document.getElementById(\n  'your-age',\n) as HTMLHeadingElement\nconst $incrementBy3Button = document.getElementById(\n  'increment-by-3',\n) as HTMLButtonElement\nconst $incrementBy1Button = document.getElementById(\n  'increment-by-1',\n) as HTMLButtonElement\n\n$incrementBy3Button.addEventListener('click', () => {\n  increment()\n  increment()\n  increment()\n})\n\n$incrementBy1Button.addEventListener('click', () => {\n  increment()\n})\n\nconst render: Parameters<typeof ageStore.subscribe>[0] = (state) => {\n  $yourAgeHeading.innerHTML = `Your age: ${state.age}`\n}\n\nrender(ageStore.getInitialState(), ageStore.getInitialState())\n\nageStore.subscribe(render)\n```\n\n----------------------------------------\n\nTITLE: Custom Storage Implementation for Zustand\nDESCRIPTION: Implementation of a custom storage interface for Zustand using URL search parameters\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst searchParamsStorage = {\n  getItem: (key: string) => getSearchParam(key),\n  setItem: (key: string, value: string) => updateSearchParam(key, value),\n  removeItem: (key: string) => removeSearchParam(key),\n}\n```\n\n----------------------------------------\n\nTITLE: Using Zustand's Combine Middleware for Type Inference\nDESCRIPTION: Shows how to use Zustand's combine middleware to infer state types without explicit type annotations, simplifying the store creation process.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\nimport { combine } from 'zustand/middleware'\n\nconst useBearStore = create(\n  combine({ bears: 0 }, (set) => ({\n    increase: (by: number) => set((state) => ({ bears: state.bears + by })),\n  })),\n)\n```\n\n----------------------------------------\n\nTITLE: Using Zustand without React\nDESCRIPTION: Shows how to use Zustand's core functionality without React dependencies.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/README.md#2025-04-22_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore } from 'zustand/vanilla'\n\nconst store = createStore((set) => ...)\nconst { getState, setState, subscribe, getInitialState } = store\n\nexport default store\n```\n\n----------------------------------------\n\nTITLE: Redux DevTools Integration\nDESCRIPTION: Demonstrates integration with Redux DevTools for debugging Zustand stores\nSOURCE: https://github.com/pmndrs/zustand/blob/main/README.md#2025-04-22_snippet_17\n\nLANGUAGE: jsx\nCODE:\n```\nimport { devtools } from 'zustand/middleware'\n\nconst usePlainStore = create(devtools((set) => ...))\nconst useReduxStore = create(devtools(redux(reducer, initialState)))\n```\n\n----------------------------------------\n\nTITLE: Immutable State Model in Zustand\nDESCRIPTION: Demonstrates how Zustand uses an immutable state model. Shows updating nested objects by creating new objects rather than mutating existing ones.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/getting-started/comparison.md#2025-04-22_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\n\ntype State = {\n  obj: { count: number }\n}\n\nconst store = create<State>(() => ({ obj: { count: 0 } }))\n\nstore.setState((prev) => ({ obj: { count: prev.obj.count + 1 } }))\n```\n\n----------------------------------------\n\nTITLE: Custom Merge Strategy for Persisted State in Zustand\nDESCRIPTION: Example showing how to implement a custom merge function to handle deep merging of nested objects when hydrating persisted state with current state.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/integrations/persisting-store-data.md#2025-04-22_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport const useBoundStore = create(\n  persist(\n    (set, get) => ({\n      foo: {\n        bar: 0,\n        baz: 1,\n      },\n    }),\n    {\n      // ...\n      merge: (persistedState, currentState) =>\n        deepMerge(currentState, persistedState),\n    },\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Updating Arrays in Zustand State\nDESCRIPTION: Explains how to update arrays in Zustand state, treating them as immutable and using immutable operations. It highlights the importance of creating new arrays for updates.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create.md#2025-04-22_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { create } from 'zustand'\n\ntype PositionStore = [number, number]\n\nconst usePositionStore = create<PositionStore>()(() => [0, 0])\n\nexport default function MovingDot() {\n  const [x, y] = usePositionStore()\n  const setPosition: typeof usePositionStore.setState = (nextPosition) => {\n    usePositionStore.setState(nextPosition, true)\n  }\n  const position = { x, y }\n\n  return (\n    <div\n      onPointerMove={(e) => {\n        setPosition([e.clientX, e.clientY])\n      }}\n      style={{\n        position: 'relative',\n        width: '100vw',\n        height: '100vh',\n      }}\n    >\n      <div\n        style={{\n          position: 'absolute',\n          backgroundColor: 'red',\n          borderRadius: '50%',\n          transform: `translate(${position.x}px, ${position.y}px)`,\n          left: -10,\n          top: -10,\n          width: 20,\n          height: 20,\n        }}\n      />\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: MovingDot Component with useStoreWithEqualityFn\nDESCRIPTION: React component that uses useStoreWithEqualityFn to read and update position state from the Zustand store. The shallow equality function is used to optimize re-renders when the position object changes.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store-with-equality-fn.md#2025-04-22_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nfunction MovingDot() {\n  const position = useStoreWithEqualityFn(\n    positionStore,\n    (state) => state.position,\n    shallow,\n  )\n  const setPosition = useStoreWithEqualityFn(\n    positionStore,\n    (state) => state.setPosition,\n    shallow,\n  )\n\n  return (\n    <div\n      onPointerMove={(e) => {\n        setPosition({\n          x: e.clientX,\n          y: e.clientY,\n        })\n      }}\n      style={{\n        position: 'relative',\n        width: '100vw',\n        height: '100vh',\n      }}\n    >\n      <div\n        style={{\n          position: 'absolute',\n          backgroundColor: 'red',\n          borderRadius: '50%',\n          transform: `translate(${position.x}px, ${position.y}px)`,\n          left: -10,\n          top: -10,\n          width: 20,\n          height: 20,\n        }}\n      />\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating MovingDot Component\nDESCRIPTION: Creates the `MovingDot` component, which renders a dot that follows the mouse cursor within its container. It uses the `usePositionStore` hook to access the position state and the `setPosition` action. The `onPointerMove` event handler updates the position state based on the mouse coordinates.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store-with-equality-fn.md#2025-04-22_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nfunction MovingDot({ color }: { color: string }) {\n  const position = usePositionStore((state) => state.position)\n  const setPosition = usePositionStore((state) => state.setPosition)\n\n  return (\n    <div\n      onPointerMove={(e) => {\n        setPosition({\n          x:\n            e.clientX > e.currentTarget.clientWidth\n              ? e.clientX - e.currentTarget.clientWidth\n              : e.clientX,\n          y: e.clientY,\n        })\n      }}\n      style={{\n        position: 'relative',\n        width: '50vw',\n        height: '100vh',\n      }}\n    >\n      <div\n        style={{\n          position: 'absolute',\n          backgroundColor: color,\n          borderRadius: '50%',\n          transform: `translate(${position.x}px, ${position.y}px)`,\n          left: -10,\n          top: -10,\n          width: 20,\n          height: 20,\n        }}\n      />\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Deeply Nested State with Immer\nDESCRIPTION: Shows how to use Immer with Zustand to simplify updating deeply nested state objects with a more concise syntax.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/updating-state.md#2025-04-22_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\n  immerInc: () =>\n    set(produce((state: State) => { ++state.deep.nested.obj.count })),\n```\n\n----------------------------------------\n\nTITLE: Consuming the Zustand Store from Context in a Component\nDESCRIPTION: Demonstrates how a component can access and use the Zustand store from context. It retrieves both state and actions from the store using useStore hook with selectors.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/initialize-state-with-props.md#2025-04-22_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n// Consumer component\nimport { useContext } from 'react'\nimport { useStore } from 'zustand'\n\nfunction BasicConsumer() {\n  const store = useContext(BearContext)\n  if (!store) throw new Error('Missing BearContext.Provider in the tree')\n  const bears = useStore(store, (s) => s.bears)\n  const addBear = useStore(store, (s) => s.addBear)\n  return (\n    <>\n      <div>{bears} Bears.</div>\n      <button onClick={addBear}>Add bear</button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Persist Middleware to Bounded Store in Zustand (JavaScript)\nDESCRIPTION: Shows how to add the persist middleware to a bounded store in Zustand. This enables state persistence across sessions.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/slices-pattern.md#2025-04-22_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { create } from 'zustand'\nimport { createBearSlice } from './bearSlice'\nimport { createFishSlice } from './fishSlice'\nimport { persist } from 'zustand/middleware'\n\nexport const useBoundStore = create(\n  persist(\n    (...a) => ({\n      ...createBearSlice(...a),\n      ...createFishSlice(...a),\n    }),\n    { name: 'bound-store' },\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Enhanced Game History Management for Tic-Tac-Toe\nDESCRIPTION: Updated handlePlay function that properly manages game history when jumping back in time and then making new moves. It slices the history to keep only the moves up to the current point before adding the new move.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_28\n\nLANGUAGE: javascript\nCODE:\n```\nfunction handlePlay(nextSquares) {\n  const nextHistory = history.slice(0, currentMove + 1).concat([nextSquares])\n  setHistory(nextHistory)\n  setCurrentMove(nextHistory.length - 1)\n  setXIsNext(!xIsNext)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Counter Component with Zustand Store\nDESCRIPTION: A client-side React component that uses Zustand store to manage counter state with increment and decrement functionality.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/nextjs.md#2025-04-22_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\n\nimport { useCounterStore } from '@/providers/counter-store-provider'\n\nexport const HomePage = () => {\n  const { count, incrementCount, decrementCount } = useCounterStore(\n    (state) => state,\n  )\n\n  return (\n    <div>\n      Count: {count}\n      <hr />\n      <button type=\"button\" onClick={incrementCount}>\n        Increment Count\n      </button>\n      <button type=\"button\" onClick={decrementCount}>\n        Decrement Count\n      </button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Determining Game Status for Tic-Tac-Toe\nDESCRIPTION: Function that determines the current status of a Tic-Tac-Toe game based on whether there is a winner, if there are no turns left (draw), or whose turn is next. Returns an appropriate status message.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_24\n\nLANGUAGE: javascript\nCODE:\n```\nfunction calculateStatus(winner, turns, player) {\n  if (!winner && !turns) return 'Draw'\n  if (winner) return `Winner ${winner}`\n  return `Next player: ${player}`\n}\n```\n\n----------------------------------------\n\nTITLE: Updated Board Component with Turn Management\nDESCRIPTION: Final Board component implementation with alternating X and O moves, including turn management and updated click handling.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nexport default function Board() {\n  const xIsNext = useGameStore((state) => state.xIsNext)\n  const setXIsNext = useGameStore((state) => state.setXIsNext)\n  const squares = useGameStore((state) => state.squares)\n  const setSquares = useGameStore((state) => state.setSquares)\n  const player = xIsNext ? 'X' : 'O'\n\n  function handleClick(i) {\n    if (squares[i]) return\n    const nextSquares = squares.slice()\n    nextSquares[i] = player\n    setSquares(nextSquares)\n    setXIsNext(!xIsNext)\n  }\n\n  return (\n    <div\n      style={{\n        display: 'grid',\n        gridTemplateColumns: 'repeat(3, 1fr)',\n        gridTemplateRows: 'repeat(3, 1fr)',\n        width: 'calc(3 * 2.5rem)',\n        height: 'calc(3 * 2.5rem)',\n        border: '1px solid #999',\n      }}\n    >\n      {squares.map((square, squareIndex) => (\n        <Square\n          key={squareIndex}\n          value={square}\n          onSquareClick={() => handleClick(squareIndex)}\n        />\n      ))}\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using onRehydrateStorage Callback in Zustand Persist\nDESCRIPTION: Example showing how to implement the onRehydrateStorage option to track hydration events, with callbacks for both start and completion or error states.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/integrations/persisting-store-data.md#2025-04-22_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport const useBoundStore = create(\n  persist(\n    (set, get) => ({\n      // ...\n    }),\n    {\n      // ...\n      onRehydrateStorage: (state) => {\n        console.log('hydration starts')\n\n        // optional\n        return (state, error) => {\n          if (error) {\n            console.log('an error happened during hydration', error)\n          } else {\n            console.log('hydration finished')\n          }\n        }\n      },\n    },\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Async Actions in Zustand Store\nDESCRIPTION: Example of implementing asynchronous actions in a Zustand store.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/README.md#2025-04-22_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst useFishStore = create((set) => ({\n  fishies: {},\n  fetch: async (pond) => {\n    const response = await fetch(pond)\n    set({ fishies: await response.json() })\n  },\n}))\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Slices with Multi-Store Update in Zustand (JavaScript)\nDESCRIPTION: Demonstrates how to combine multiple slices, including a slice that updates multiple stores, into a single bounded store.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/slices-pattern.md#2025-04-22_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { create } from 'zustand'\nimport { createBearSlice } from './bearSlice'\nimport { createFishSlice } from './fishSlice'\nimport { createBearFishSlice } from './createBearFishSlice'\n\nexport const useBoundStore = create((...a) => ({\n  ...createBearSlice(...a),\n  ...createFishSlice(...a),\n  ...createBearFishSlice(...a),\n}))\n```\n\n----------------------------------------\n\nTITLE: Basic Store Debugging Setup\nDESCRIPTION: Example of implementing Redux DevTools debugging in a basic Zustand store with bears and fishes state.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/devtools.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create, StateCreator } from 'zustand'\nimport { devtools } from 'zustand/middleware'\n\ntype JungleStore = {\n  bears: number\n  addBear: () => void\n  fishes: number\n  addFish: () => void\n}\n\nconst useJungleStore = create<JungleStore>()(\n  devtools((set) => ({\n    bears: 0,\n    addBear: () =>\n      set((state) => ({ bears: state.bears + 1 }), undefined, 'jungle/addBear'),\n    fishes: 0,\n    addFish: () =>\n      set(\n        (state) => ({ fishes: state.fishes + 1 }),\n        undefined,\n        'jungle/addFish',\n      ),\n  })),\n)\n```\n\n----------------------------------------\n\nTITLE: Preventing Rerenders with useShallow in Zustand\nDESCRIPTION: Implements useShallow from Zustand to prevent unnecessary rerenders when the computed value (bear names) remains the same despite changes to individual meal values in the state.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/prevent-rerenders-with-use-shallow.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { create } from 'zustand'\nimport { useShallow } from 'zustand/react/shallow'\n\nconst useMeals = create(() => ({\n  papaBear: 'large porridge-pot',\n  mamaBear: 'middle-size porridge pot',\n  littleBear: 'A little, small, wee pot',\n}))\n\nexport const BearNames = () => {\n  const names = useMeals(useShallow((state) => Object.keys(state)))\n\n  return <div>{names.join(', ')}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Object Values in State\nDESCRIPTION: Example demonstrating immutable object updates in Zustand state. This shows how to update object properties while maintaining immutability patterns for reliable state updates.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-store.md#2025-04-22_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'zustand/vanilla'\n\ntype PositionStoreState = { position: { x: number; y: number } }\n\ntype PositionStoreActions = {\n  setPosition: (nextPosition: PositionStoreState['position']) => void\n}\n\ntype PositionStore = PositionStoreState & PositionStoreActions\n\nconst positionStore = createStore<PositionStore>()((set) => ({\n  position: { x: 0, y: 0 },\n  setPosition: (position) => set({ position }),\n}))\n\nconst $dotContainer = document.getElementById('dot-container') as HTMLDivElement\nconst $dot = document.getElementById('dot') as HTMLDivElement\n\n$dotContainer.addEventListener('pointermove', (event) => {\n  positionStore.getState().setPosition({\n    x: event.clientX,\n    y: event.clientY,\n  })\n})\n\nconst render: Parameters<typeof positionStore.subscribe>[0] = (state) => {\n  $dot.style.transform = `translate(${state.position.x}px, ${state.position.y}px)`\n}\n\nrender(positionStore.getInitialState(), positionStore.getInitialState())\n\npositionStore.subscribe(render)\n```\n\n----------------------------------------\n\nTITLE: Rendering State Changes with Subscription\nDESCRIPTION: Code showing how to subscribe to state changes and update the UI accordingly, reflecting persisted state.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst render: Parameters<typeof positionStore.subscribe>[0] = (state) => {\n  $dot.style.transform = `translate(${state.position.x}px, ${state.position.y}px)`\n}\n\nrender(positionStore.getState(), positionStore.getState())\n\npositionStore.subscribe(render)\n```\n\n----------------------------------------\n\nTITLE: Defining the Tic-Tac-Toe Board Component using React\nDESCRIPTION: This React component represents the Tic-Tac-Toe board, displaying squares and the game status. It manages the game state through Zustand and renders the squares dynamically based on their current values.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nexport default function Board() {\n  const xIsNext = useGameStore((state) => state.xIsNext)\n  const setXIsNext = useGameStore((state) => state.setXIsNext)\n  const squares = useGameStore((state) => state.squares)\n  const setSquares = useGameStore((state) => state.setSquares)\n  const winner = calculateWinner(squares)\n  const turns = calculateTurns(squares)\n  const player = xIsNext ? 'X' : 'O'\n  const status = calculateStatus(winner, turns, player)\n\n  function handleClick(i) {\n    if (squares[i] || winner) return\n    const nextSquares = squares.slice()\n    nextSquares[i] = player\n    setSquares(nextSquares)\n    setXIsNext(!xIsNext)\n  }\n\n  return (\n    <>\n      <div style={{ marginBottom: '0.5rem' }}>{status}</div>\n      <div\n        style={{\n          display: 'grid',\n          gridTemplateColumns: 'repeat(3, 1fr)',\n          gridTemplateRows: 'repeat(3, 1fr)',\n          width: 'calc(3 * 2.5rem)',\n          height: 'calc(3 * 2.5rem)',\n          border: '1px solid #999',\n        }}\n      >\n        {squares.map((square, squareIndex) => (\n          <Square\n            key={squareIndex}\n            value={square}\n            onSquareClick={() => handleClick(squareIndex)}\n          />\n        ))}\n      </div>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript Implementation of Persistent Zustand Store\nDESCRIPTION: An example of a Zustand store with persistence middleware that includes TypeScript type definitions. It creates a BearStore type interface for type safety.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/integrations/persisting-store-data.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\nimport { persist, createJSONStorage } from 'zustand/middleware'\n\ntype BearStore = {\n  bears: number\n  addABear: () => void\n}\n\nexport const useBearStore = create<BearStore>()(\n  persist(\n    (set, get) => ({\n      bears: 0,\n      addABear: () => set({ bears: get().bears + 1 }),\n    }),\n    {\n      name: 'food-storage', // name of the item in the storage (must be unique)\n      storage: createJSONStorage(() => sessionStorage), // (optional) by default, 'localStorage' is used\n    },\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Complete MovingDot Example with Zustand\nDESCRIPTION: Full implementation of the MovingDot example showing how to use a global vanilla store with React components to create an interactive dot that follows the pointer.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store.md#2025-04-22_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createStore, useStore } from 'zustand'\n\ntype PositionStoreState = { position: { x: number; y: number } }\n\ntype PositionStoreActions = {\n  setPosition: (nextPosition: PositionStoreState['position']) => void\n}\n\ntype PositionStore = PositionStoreState & PositionStoreActions\n\nconst positionStore = createStore<PositionStore>()((set) => ({\n  position: { x: 0, y: 0 },\n  setPosition: (position) => set({ position }),\n}))\n\nfunction MovingDot() {\n  const position = useStore(positionStore, (state) => state.position)\n  const setPosition = useStore(positionStore, (state) => state.setPosition)\n\n  return (\n    <div\n      onPointerMove={(e) => {\n        setPosition({\n          x: e.clientX,\n          y: e.clientY,\n        })\n      }}\n      style={{\n        position: 'relative',\n        width: '100vw',\n        height: '100vh',\n      }}\n    >\n      <div\n        style={{\n          position: 'absolute',\n          backgroundColor: 'red',\n          borderRadius: '50%',\n          transform: `translate(${position.x}px, ${position.y}px)`,\n          left: -10,\n          top: -10,\n          width: 20,\n          height: 20,\n        }}\n      />\n    </div>\n  )\n}\n\nexport default function App() {\n  return <MovingDot />\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Selector Generator Function for React Stores in Zustand\nDESCRIPTION: Implementation of a createSelectors function that auto-generates selectors for a Zustand React store. This utility creates a .use object with methods to access each store property.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/auto-generating-selectors.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { StoreApi, UseBoundStore } from 'zustand'\n\ntype WithSelectors<S> = S extends { getState: () => infer T }\n  ? S & { use: { [K in keyof T]: () => T[K] } }\n  : never\n\nconst createSelectors = <S extends UseBoundStore<StoreApi<object>>>(\n  _store: S,\n) => {\n  let store = _store as WithSelectors<typeof _store>\n  store.use = {}\n  for (let k of Object.keys(store.getState())) {\n    ;(store.use as any)[k] = () => store((s) => s[k as keyof typeof s])\n  }\n\n  return store\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting Zustand State with URL Hash\nDESCRIPTION: Implements a custom StateStorage for Zustand that persists state in the URL hash. This allows state to be shared via URLs and maintained across page reloads through the URL fragment identifier.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/connect-to-state-with-url-hash.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\nimport { persist, StateStorage, createJSONStorage } from 'zustand/middleware'\n\nconst hashStorage: StateStorage = {\n  getItem: (key): string => {\n    const searchParams = new URLSearchParams(location.hash.slice(1))\n    const storedValue = searchParams.get(key) ?? ''\n    return JSON.parse(storedValue)\n  },\n  setItem: (key, newValue): void => {\n    const searchParams = new URLSearchParams(location.hash.slice(1))\n    searchParams.set(key, JSON.stringify(newValue))\n    location.hash = searchParams.toString()\n  },\n  removeItem: (key): void => {\n    const searchParams = new URLSearchParams(location.hash.slice(1))\n    searchParams.delete(key)\n    location.hash = searchParams.toString()\n  },\n}\n\nexport const useBoundStore = create(\n  persist(\n    (set, get) => ({\n      fishes: 0,\n      addAFish: () => set({ fishes: get().fishes + 1 }),\n    }),\n    {\n      name: 'food-storage', // unique name\n      storage: createJSONStorage(() => hashStorage),\n    },\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a React Context for the Zustand Store\nDESCRIPTION: Creates a React context to hold the Zustand store instance. This allows the store to be passed down the component tree and accessed by any component that needs it.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/initialize-state-with-props.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createContext } from 'react'\n\nexport const BearContext = createContext<BearStore | null>(null)\n```\n\n----------------------------------------\n\nTITLE: Complete Application Implementation\nDESCRIPTION: Full implementation combining all the components and store logic into a working React application with TypeScript and Zustand integration.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store-with-equality-fn.md#2025-04-22_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react'\nimport { createStore } from 'zustand'\nimport { useStoreWithEqualityFn } from 'zustand/traditional'\nimport { shallow } from 'zustand/shallow'\n\ntype CounterState = {\n  count: number\n}\n\ntype CounterActions = { increment: () => void }\n\ntype CounterStore = CounterState & CounterActions\n\nconst createCounterStore = () => {\n  return createStore<CounterStore>()((set) => ({\n    count: 0,\n    increment: () => {\n      set((state) => ({ count: state.count + 1 }))\n    },\n  }))\n}\n\nconst defaultCounterStores = new Map<\n  string,\n  ReturnType<typeof createCounterStore>\n>()\n\nconst createCounterStoreFactory = (\n  counterStores: typeof defaultCounterStores,\n) => {\n  return (counterStoreKey: string) => {\n    if (!counterStores.has(counterStoreKey)) {\n      counterStores.set(counterStoreKey, createCounterStore())\n    }\n    return counterStores.get(counterStoreKey)!\n  }\n}\n\nconst getOrCreateCounterStoreByKey =\n  createCounterStoreFactory(defaultCounterStores)\n\nexport default function App() {\n  const [currentTabIndex, setCurrentTabIndex] = useState(0)\n  const counterState = useStoreWithEqualityFn(\n    getOrCreateCounterStoreByKey(`tab-${currentTabIndex}`),\n    (state) => state,\n    shallow,\n  )\n\n  return (\n    <div style={{ fontFamily: 'monospace' }}>\n      <div\n        style={{\n          display: 'flex',\n          gap: '0.5rem',\n          borderBottom: '1px solid salmon',\n          paddingBottom: 4,\n        }}\n      >\n        <button\n          type=\"button\"\n          style={{\n            border: '1px solid salmon',\n            backgroundColor: '#fff',\n            cursor: 'pointer',\n          }}\n          onClick={() => setCurrentTabIndex(0)}\n        >\n          Tab 1\n        </button>\n        <button\n          type=\"button\"\n          style={{\n            border: '1px solid salmon',\n            backgroundColor: '#fff',\n            cursor: 'pointer',\n          }}\n          onClick={() => setCurrentTabIndex(1)}\n        >\n          Tab 2\n        </button>\n        <button\n          type=\"button\"\n          style={{\n            border: '1px solid salmon',\n            backgroundColor: '#fff',\n            cursor: 'pointer',\n          }}\n          onClick={() => setCurrentTabIndex(2)}\n        >\n          Tab 3\n        </button>\n      </div>\n      <div style={{ padding: 4 }}>\n        Content of Tab {currentTabIndex + 1}\n        <br /> <br />\n        <button type=\"button\" onClick={() => counterState.increment()}>\n          Count: {counterState.count}\n        </button>\n      </div>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: MovingDot Component Using Position Store\nDESCRIPTION: React component that uses the position store to render and update a dot's position on the screen based on pointer movements.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store.md#2025-04-22_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nfunction MovingDot() {\n  const position = useStore(positionStore, (state) => state.position)\n  const setPosition = useStore(positionStore, (state) => state.setPosition)\n\n  return (\n    <div\n      onPointerMove={(e) => {\n        setPosition({\n          x: e.clientX,\n          y: e.clientY,\n        })\n      }}\n      style={{\n        position: 'relative',\n        width: '100vw',\n        height: '100vh',\n      }}\n    >\n      <div\n        style={{\n          position: 'absolute',\n          backgroundColor: 'red',\n          borderRadius: '50%',\n          transform: `translate(${position.x}px, ${position.y}px)`,\n          left: -10,\n          top: -10,\n          width: 20,\n          height: 20,\n        }}\n      />\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering State Properties for Persistence Using Partialize\nDESCRIPTION: Example showing how to exclude specific fields from being stored in persistent storage using the partialize option with Object.fromEntries and Object.entries filtering.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/integrations/persisting-store-data.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport const useBoundStore = create(\n  persist(\n    (set, get) => ({\n      foo: 0,\n      bar: 1,\n    }),\n    {\n      // ...\n      partialize: (state) =>\n        Object.fromEntries(\n          Object.entries(state).filter(([key]) => !['foo'].includes(key)),\n        ),\n    },\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Multi-Store Update Slice in Zustand (JavaScript)\nDESCRIPTION: Shows how to create a slice that updates multiple stores simultaneously. This slice adds both a bear and a fish in a single action.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/slices-pattern.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nexport const createBearFishSlice = (set, get) => ({\n  addBearAndFish: () => {\n    get().addBear()\n    get().addFish()\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Updating Primitive Values in Zustand State\nDESCRIPTION: Shows how to update primitive values in Zustand state, emphasizing the use of direct assignment and the 'replace' parameter for complete state replacement.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create.md#2025-04-22_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { create } from 'zustand'\n\ntype XStore = number\n\nconst useXStore = create<XStore>()(() => 0)\n\nexport default function MovingDot() {\n  const x = useXStore()\n  const setX = (nextX: number) => {\n    useXStore.setState(nextX, true)\n  }\n  const position = { y: 0, x }\n\n  return (\n    <div\n      onPointerMove={(e) => {\n        setX(e.clientX)\n      }}\n      style={{\n        position: 'relative',\n        width: '100vw',\n        height: '100vh',\n      }}\n    >\n      <div\n        style={{\n          position: 'absolute',\n          backgroundColor: 'red',\n          borderRadius: '50%',\n          transform: `translate(${position.x}px, ${position.y}px)`,\n          left: -10,\n          top: -10,\n          width: 20,\n          height: 20,\n        }}\n      />\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Basic createWithEqualityFn Usage in JavaScript\nDESCRIPTION: Basic example showing the core syntax for creating a store with createWithEqualityFn.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-with-equality-fn.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst useSomeStore = createWithEqualityFn(stateCreatorFn, equalityFn)\n```\n\n----------------------------------------\n\nTITLE: Creating a Bounded useStore Hook for Vanilla Zustand Stores\nDESCRIPTION: Implementation of a bounded useStore hook for vanilla Zustand stores, providing proper typing through function overloads. This allows for type-safe state access from vanilla stores.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md#2025-04-22_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useStore } from 'zustand'\nimport { createStore } from 'zustand/vanilla'\n\ninterface BearState {\n  bears: number\n  increase: (by: number) => void\n}\n\nconst bearStore = createStore<BearState>()((set) => ({\n  bears: 0,\n  increase: (by) => set((state) => ({ bears: state.bears + by })),\n}))\n\nfunction useBearStore(): BearState\nfunction useBearStore<T>(selector: (state: BearState) => T): T\nfunction useBearStore<T>(selector?: (state: BearState) => T) {\n  return useStore(bearStore, selector!)\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Code: Scoped Zustand Store in React\nDESCRIPTION: Complete example code, demonstrating how to create a scoped Zustand store within a React application using React Context.  It includes the creation of a vanilla store, a React context and provider, a custom hook for accessing the store, and a component that uses the store to manage its state.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store-with-equality-fn.md#2025-04-22_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\nimport { type ReactNode, useState, createContext, useContext } from 'react'\nimport { createStore } from 'zustand'\nimport { useStoreWithEqualityFn } from 'zustand/traditional'\nimport { shallow } from 'zustand/shallow'\n\ntype PositionStoreState = { position: { x: number; y: number } }\n\ntype PositionStoreActions = {\n  setPosition: (nextPosition: PositionStoreState['position']) => void\n}\n\ntype PositionStore = PositionStoreState & PositionStoreActions\n\nconst createPositionStore = () => {\n  return createStore<PositionStore>()((set) => ({\n    position: { x: 0, y: 0 },\n    setPosition: (position) => set({ position }),\n  }))\n}\n\nconst PositionStoreContext = createContext<ReturnType<\n  typeof createPositionStore\n> | null>(null)\n\nfunction PositionStoreProvider({ children }: { children: ReactNode }) {\n  const [positionStore] = useState(createPositionStore)\n\n  return (\n    <PositionStoreContext.Provider value={positionStore}>\n      {children}\n    </PositionStoreContext.Provider>\n  )\n}\n\nfunction usePositionStore<U>(selector: (state: PositionStore) => U) {\n  const store = useContext(PositionStoreContext)\n\n  if (store === null) {\n    throw new Error(\n      'usePositionStore must be used within PositionStoreProvider',\n    )\n  }\n\n  return useStoreWithEqualityFn(store, selector, shallow)\n}\n\nfunction MovingDot({ color }: { color: string }) {\n  const position = usePositionStore((state) => state.position)\n  const setPosition = usePositionStore((state) => state.setPosition)\n\n  return (\n    <div\n      onPointerMove={(e) => {\n        setPosition({\n          x:\n            e.clientX > e.currentTarget.clientWidth\n              ? e.clientX - e.currentTarget.clientWidth\n              : e.clientX,\n          y: e.clientY,\n        })\n      }}\n      style={{\n        position: 'relative',\n        width: '50vw',\n        height: '100vh',\n      }}\n    >\n      <div\n        style={{\n          position: 'absolute',\n          backgroundColor: color,\n          borderRadius: '50%',\n          transform: `translate(${position.x}px, ${position.y}px)`,\n          left: -10,\n          top: -10,\n          width: 20,\n          height: 20,\n        }}\n      />\n    </div>\n  )\n}\n\nexport default function App() {\n  return (\n    <div style={{ display: 'flex' }}>\n      <PositionStoreProvider>\n        <MovingDot color=\"red\" />\n      </PositionStoreProvider>\n      <PositionStoreProvider>\n        <MovingDot color=\"blue\" />\n      </PositionStoreProvider>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Partial State Persistence\nDESCRIPTION: Demonstrates how to persist only a specific part of the state using the partialize option in persist middleware.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'zustand/vanilla'\nimport { persist } from 'zustand/middleware'\n\ntype PositionStoreState = {\n  context: {\n    position: { x: number; y: number }\n  }\n}\n\ntype PositionStoreActions = {\n  actions: {\n    setPosition: (\n      nextPosition: PositionStoreState['context']['position'],\n    ) => void\n  }\n}\n\ntype PositionStore = PositionStoreState & PositionStoreActions\n\nconst positionStore = createStore<PositionStore>()(\n  persist(\n    (set) => ({\n      context: {\n        position: { x: 0, y: 0 },\n      },\n      actions: {\n        setPosition: (position) => set({ context: { position } }),\n      },\n    }),\n    {\n      name: 'position-storage',\n      partialize: (state) => ({ context: state.context }),\n    },\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Creating React Context and Provider\nDESCRIPTION: Creates a React context and a provider component to make the Zustand store available to the component tree. The `PositionStoreContext` is created to hold the store instance. The `PositionStoreProvider` initializes the store using `useState` and provides it to its children via the context provider.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store-with-equality-fn.md#2025-04-22_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nconst PositionStoreContext = createContext<ReturnType<\n  typeof createPositionStore\n> | null>(null)\n\nfunction PositionStoreProvider({ children }: { children: ReactNode }) {\n  const [positionStore] = useState(createPositionStore)\n\n  return (\n    <PositionStoreContext.Provider value={positionStore}>\n      {children}\n    </PositionStoreContext.Provider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Zustand Counter Store Type and Creator\nDESCRIPTION: Defines TypeScript types and creates a basic counter store with increment functionality using Zustand's StateCreator.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/testing.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type StateCreator } from 'zustand'\n\nexport type CounterStore = {\n  count: number\n  inc: () => void\n}\n\nexport const counterStoreCreator: StateCreator<CounterStore> = (set) => ({\n  count: 1,\n  inc: () => set((state) => ({ count: state.count + 1 })),\n})\n```\n\n----------------------------------------\n\nTITLE: Updating Zustand State without Store Actions\nDESCRIPTION: Shows how to update Zustand state without defining actions within the store. This approach allows for code splitting and doesn't require a hook to call an action.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create.md#2025-04-22_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { create } from 'zustand'\n\nconst usePositionStore = create<{\n  x: number\n  y: number\n}>()(() => ({ x: 0, y: 0 }))\n\nconst setPosition: typeof usePositionStore.setState = (nextPosition) => {\n  usePositionStore.setState(nextPosition)\n}\n\nexport default function MovingDot() {\n  const position = usePositionStore()\n\n  return (\n    <div\n      style={{\n        position: 'relative',\n        width: '100vw',\n        height: '100vh',\n      }}\n    >\n      <div\n        style={{\n          position: 'absolute',\n          backgroundColor: 'red',\n          borderRadius: '50%',\n          transform: `translate(${position.x}px, ${position.y}px)`,\n          left: -10,\n          top: -10,\n          width: 20,\n          height: 20,\n        }}\n        onMouseEnter={(event) => {\n          const parent = event.currentTarget.parentElement\n          const parentWidth = parent.clientWidth\n          const parentHeight = parent.clientHeight\n\n          setPosition({\n            x: Math.ceil(Math.random() * parentWidth),\n            y: Math.ceil(Math.random() * parentHeight),\n          })\n        }}\n      />\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Batching Zustand State Updates Outside React Event Handlers in JSX\nDESCRIPTION: This code demonstrates how to properly update Zustand state outside of React event handlers using unstable_batchedUpdates from react-dom or react-native. This approach prevents the zombie-child effect caused by synchronous state updates by ensuring updates are batched.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/event-handler-in-pre-react-18.md#2025-04-22_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { unstable_batchedUpdates } from 'react-dom' // or 'react-native'\n\nconst useFishStore = create((set) => ({\n  fishes: 0,\n  increaseFishes: () => set((prev) => ({ fishes: prev.fishes + 1 })),\n}))\n\nconst nonReactCallback = () => {\n  unstable_batchedUpdates(() => {\n    useFishStore.getState().increaseFishes()\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Storage in Zustand Persist Middleware\nDESCRIPTION: Example of setting up a Zustand store with persist middleware configured to use a custom storage solution (AsyncStorage), using the createJSONStorage helper.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/integrations/persisting-store-data.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { persist, createJSONStorage } from 'zustand/middleware'\n\nexport const useBoundStore = create(\n  persist(\n    (set, get) => ({\n      // ...\n    }),\n    {\n      // ...\n      storage: createJSONStorage(() => AsyncStorage),\n    },\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Provider for the Zustand Store\nDESCRIPTION: Shows how to set up a provider component that creates a store instance and makes it available to child components via React context. The store is created once using useRef to maintain the same instance across renders.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/initialize-state-with-props.md#2025-04-22_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// Provider implementation\nimport { useRef } from 'react'\n\nfunction App() {\n  const store = useRef(createBearStore()).current\n  return (\n    <BearContext.Provider value={store}>\n      <BasicConsumer />\n    </BearContext.Provider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Store State Updates\nDESCRIPTION: Example showing how to subscribe to state updates in a vanilla store. This demonstrates registering multiple callbacks for different purposes like UI updates and logging.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-store.md#2025-04-22_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'zustand/vanilla'\n\ntype PositionStoreState = { position: { x: number; y: number } }\n\ntype PositionStoreActions = {\n  setPosition: (nextPosition: PositionStoreState['position']) => void\n}\n\ntype PositionStore = PositionStoreState & PositionStoreActions\n\nconst positionStore = createStore<PositionStore>()((set) => ({\n  position: { x: 0, y: 0 },\n  setPosition: (position) => set({ position }),\n}))\n\nconst $dot = document.getElementById('dot') as HTMLDivElement\n\n$dot.addEventListener('mouseenter', (event) => {\n  const parent = event.currentTarget.parentElement\n  const parentWidth = parent.clientWidth\n  const parentHeight = parent.clientHeight\n\n  positionStore.getState().setPosition({\n    x: Math.ceil(Math.random() * parentWidth),\n    y: Math.ceil(Math.random() * parentHeight),\n  })\n})\n\nconst render: Parameters<typeof positionStore.subscribe>[0] = (state) => {\n  $dot.style.transform = `translate(${state.position.x}px, ${state.position.y}px)`\n}\n\nrender(positionStore.getInitialState(), positionStore.getInitialState())\n\npositionStore.subscribe(render)\n\nconst logger: Parameters<typeof positionStore.subscribe>[0] = (state) => {\n  console.log('new position', { position: state.position })\n}\n\npositionStore.subscribe(logger)\n```\n\n----------------------------------------\n\nTITLE: Partial State Updates Example - TypeScript\nDESCRIPTION: Complete example demonstrating how to use subscribeWithSelector for partial state updates with position tracking and DOM manipulation.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/subscribe-with-selector.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'zustand/vanilla'\nimport { subscribeWithSelector } from 'zustand/middleware'\n\ntype PositionStoreState = { position: { x: number; y: number } }\n\ntype PositionStoreActions = {\n  setPosition: (nextPosition: PositionStoreState['position']) => void\n}\n\ntype PositionStore = PositionStoreState & PositionStoreActions\n\nconst positionStore = createStore<PositionStore>()(\n  subscribeWithSelector((set) => ({\n    position: { x: 0, y: 0 },\n    setPosition: (position) => set({ position }),\n  })),\n)\n\nconst $dot = document.getElementById('dot') as HTMLDivElement\n\n$dot.addEventListener('mouseenter', (event) => {\n  const parent = event.currentTarget.parentElement\n  const parentWidth = parent.clientWidth\n  const parentHeight = parent.clientHeight\n\n  positionStore.getState().setPosition({\n    x: Math.ceil(Math.random() * parentWidth),\n    y: Math.ceil(Math.random() * parentHeight),\n  })\n})\n\nconst render: Parameters<typeof positionStore.subscribe>[0] = (state) => {\n  $dot.style.transform = `translate(${state.position.x}px, ${state.position.y}px)`\n}\n\nrender(positionStore.getInitialState(), positionStore.getInitialState())\n\npositionStore.subscribe((state) => state.position, render)\n\nconst logger: Parameters<typeof positionStore.subscribe>[0] = (x) => {\n  console.log('new x position', { x })\n}\n\npositionStore.subscribe((state) => state.position.x, logger)\n```\n\n----------------------------------------\n\nTITLE: Next.js Custom Store Hook Implementation\nDESCRIPTION: Custom hook implementation to handle hydration issues in Next.js with Zustand by delaying component updates\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/integrations/persisting-store-data.md#2025-04-22_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useState, useEffect } from 'react'\n\nconst useStore = <T, F>(\n  store: (callback: (state: T) => unknown) => unknown,\n  callback: (state: T) => F,\n) => {\n  const result = store(callback) as F\n  const [data, setData] = useState<F>()\n\n  useEffect(() => {\n    setData(result)\n  }, [result])\n\n  return data\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering a Square in the Tic-Tac-Toe Board using React\nDESCRIPTION: This React functional component represents each square in the Tic-Tac-Toe game. It handles the click events to trigger updates and displays the current value of the square, which can be empty, 'X', or 'O'.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Square({ value, onSquareClick }) {\n  return (\n    <button\n      style={{\n        display: 'inline-flex',\n        alignItems: 'center',\n        justifyContent: 'center',\n        padding: 0,\n        backgroundColor: '#fff',\n        border: '1px solid #999',\n        outline: 0,\n        borderRadius: 0,\n        fontSize: '1rem',\n        fontWeight: 'bold',\n      }}\n      onClick={onSquareClick}\n    >\n      {value}\n    </button>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Tic-Tac-Toe Implementation with Zustand\nDESCRIPTION: The complete implementation of the Tic-Tac-Toe game with Zustand state management, including the Square, Board, and Game components. This code demonstrates the final structure after lifting state to the Game component.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_21\n\nLANGUAGE: jsx\nCODE:\n```\nimport { create } from 'zustand'\nimport { combine } from 'zustand/middleware'\n\nconst useGameStore = create(\n  combine({ history: [Array(9).fill(null)], xIsNext: true }, (set) => {\n    return {\n      setHistory: (nextHistory) => {\n        set((state) => ({\n          history:\n            typeof nextHistory === 'function'\n              ? nextHistory(state.history)\n              : nextHistory,\n        }))\n      },\n      setXIsNext: (nextXIsNext) => {\n        set((state) => ({\n          xIsNext:\n            typeof nextXIsNext === 'function'\n              ? nextXIsNext(state.xIsNext)\n              : nextXIsNext,\n        }))\n      },\n    }\n  }),\n)\n\nfunction Square({ value, onSquareClick }) {\n  return (\n    <button\n      style={{\n        display: 'inline-flex',\n        alignItems: 'center',\n        justifyContent: 'center',\n        padding: 0,\n        backgroundColor: '#fff',\n        border: '1px solid #999',\n        outline: 0,\n        borderRadius: 0,\n        fontSize: '1rem',\n        fontWeight: 'bold',\n      }}\n      onClick={onSquareClick}\n    >\n      {value}\n    </button>\n  )\n}\n\nfunction Board({ xIsNext, squares, onPlay }) {\n  const winner = calculateWinner(squares)\n  const turns = calculateTurns(squares)\n  const player = xIsNext ? 'X' : 'O'\n  const status = calculateStatus(winner, turns, player)\n\n  function handleClick(i) {\n    if (squares[i] || winner) return\n    const nextSquares = squares.slice()\n    nextSquares[i] = player\n    onPlay(nextSquares)\n  }\n\n  return (\n    <>\n      <div style={{ marginBottom: '0.5rem' }}>{status}</div>\n      <div\n        style={{\n          display: 'grid',\n          gridTemplateColumns: 'repeat(3, 1fr)',\n          gridTemplateRows: 'repeat(3, 1fr)',\n          width: 'calc(3 * 2.5rem)',\n          height: 'calc(3 * 2.5rem)',\n          border: '1px solid #999',\n        }}\n      >\n        {squares.map((square, squareIndex) => (\n          <Square\n            key={squareIndex}\n            value={square}\n            onSquareClick={() => handleClick(squareIndex)}\n          />\n        ))}\n      </div>\n    </>\n  )\n}\n\nexport default function Game() {\n  const history = useGameStore((state) => state.history)\n  const setHistory = useGameStore((state) => state.setHistory)\n  const xIsNext = useGameStore((state) => state.xIsNext)\n  const setXIsNext = useGameStore((state) => state.setXIsNext)\n  const currentSquares = history[history.length - 1]\n\n  function handlePlay(nextSquares) {\n    setHistory(history.concat([nextSquares]))\n    setXIsNext(!xIsNext)\n  }\n\n  return (\n    <div\n      style={{\n        display: 'flex',\n        flexDirection: 'row',\n        fontFamily: 'monospace',\n      }}\n    >\n      <div>\n        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />\n      </div>\n```\n\n----------------------------------------\n\nTITLE: Creating Position Store with Zustand\nDESCRIPTION: Example of creating a vanilla store to track position coordinates. The store contains state for x and y coordinates and an action to update the position.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ntype PositionStoreState = { position: { x: number; y: number } }\n\ntype PositionStoreActions = {\n  setPosition: (nextPosition: PositionStoreState['position']) => void\n}\n\ntype PositionStore = PositionStoreState & PositionStoreActions\n\nconst positionStore = createStore<PositionStore>()((set) => ({\n  position: { x: 0, y: 0 },\n  setPosition: (position) => set({ position }),\n}))\n```\n\n----------------------------------------\n\nTITLE: Complete MovingDot Implementation with Zustand\nDESCRIPTION: Full implementation of the position tracking example using Zustand's vanilla store and the useStoreWithEqualityFn hook with shallow equality comparison for optimized rendering.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store-with-equality-fn.md#2025-04-22_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createStore } from 'zustand'\nimport { useStoreWithEqualityFn } from 'zustand/traditional'\nimport { shallow } from 'zustand/shallow'\n\ntype PositionStoreState = { position: { x: number; y: number } }\n\ntype PositionStoreActions = {\n  setPosition: (nextPosition: PositionStoreState['position']) => void\n}\n\ntype PositionStore = PositionStoreState & PositionStoreActions\n\nconst positionStore = createStore<PositionStore>()((set) => ({\n  position: { x: 0, y: 0 },\n  setPosition: (position) => set({ position }),\n}))\n\nfunction MovingDot() {\n  const position = useStoreWithEqualityFn(\n    positionStore,\n    (state) => state.position,\n    shallow,\n  )\n  const setPosition = useStoreWithEqualityFn(\n    positionStore,\n    (state) => state.setPosition,\n    shallow,\n  )\n\n  return (\n    <div\n      onPointerMove={(e) => {\n        setPosition({\n          x: e.clientX,\n          y: e.clientY,\n        })\n      }}\n      style={{\n        position: 'relative',\n        width: '100vw',\n        height: '100vh',\n      }}\n    >\n      <div\n        style={{\n          position: 'absolute',\n          backgroundColor: 'red',\n          borderRadius: '50%',\n          transform: `translate(${position.x}px, ${position.y}px)`,\n          left: -10,\n          top: -10,\n          width: 20,\n          height: 20,\n        }}\n      />\n    </div>\n  )\n}\n\nexport default function App() {\n  return <MovingDot />\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Selectors to a React Store in Zustand\nDESCRIPTION: Code to apply the createSelectors function to a Zustand React store, which enhances the store with auto-generated selectors.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/auto-generating-selectors.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst useBearStore = createSelectors(useBearStoreBase)\n```\n\n----------------------------------------\n\nTITLE: Generating Shareable URLs with Zustand State\nDESCRIPTION: Functions to build shareable URLs that contain Zustand state information. Creates a URL with query parameters containing the state to be shared, allowing users to share application state via URLs.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/connect-to-state-with-url-hash.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst buildURLSuffix = (params, version = 0) => {\n  const searchParams = new URLSearchParams()\n\n  const zustandStoreParams = {\n    state: {\n      typesOfFish: params.typesOfFish,\n      numberOfBears: params.numberOfBears,\n    },\n    version: version, // version is here because that is included with how Zustand sets the state\n  }\n\n  // The URL param key should match the name of the store, as specified as in storageOptions above\n  searchParams.set('fishAndBearsStore', JSON.stringify(zustandStoreParams))\n  return searchParams.toString()\n}\n\nexport const buildShareableUrl = (params, version) => {\n  return `${window.location.origin}?${buildURLSuffix(params, version)}`\n}\n```\n\n----------------------------------------\n\nTITLE: Using subscribeWithSelector Middleware\nDESCRIPTION: Example of using the subscribeWithSelector middleware to subscribe to specific state changes with advanced options.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/README.md#2025-04-22_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { subscribeWithSelector } from 'zustand/middleware'\nconst useDogStore = create(\n  subscribeWithSelector(() => ({ paw: true, snout: true, fur: true })),\n)\n\n// Listening to selected changes, in this case when \"paw\" changes\nconst unsub2 = useDogStore.subscribe((state) => state.paw, console.log)\n// Subscribe also exposes the previous value\nconst unsub3 = useDogStore.subscribe(\n  (state) => state.paw,\n  (paw, previousPaw) => console.log(paw, previousPaw),\n)\n// Subscribe also supports an optional equality function\nconst unsub4 = useDogStore.subscribe(\n  (state) => [state.paw, state.fur],\n  console.log,\n  { equalityFn: shallow },\n)\n// Subscribe and fire immediately\nconst unsub5 = useDogStore.subscribe((state) => state.paw, console.log, {\n  fireImmediately: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Complete Initial Implementation\nDESCRIPTION: Full implementation of the bear family meals application without useShallow optimization.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-shallow.md#2025-04-22_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useEffect } from 'react'\nimport { create } from 'zustand'\n\ntype BearFamilyMealsStore = {\n  [key: string]: string\n}\n\nconst useBearFamilyMealsStore = create<BearFamilyMealsStore>()(() => ({\n  papaBear: 'large porridge-pot',\n  mamaBear: 'middle-size porridge pot',\n  babyBear: 'A little, small, wee pot',\n}))\n\nconst meals = [\n  'A tiny, little, wee bowl',\n  'A small, petite, tiny pot',\n  'A wee, itty-bitty, small bowl',\n  'A little, petite, tiny dish',\n  'A tiny, small, wee vessel',\n  'A small, little, wee cauldron',\n  'A little, tiny, small cup',\n  'A wee, small, little jar',\n  'A tiny, wee, small pan',\n  'A small, wee, little crock',\n]\n\nfunction UpdateBabyBearMeal() {\n  useEffect(() => {\n    const timer = setInterval(() => {\n      useBearFamilyMealsStore.setState({\n        babyBear: meals[Math.floor(Math.random() * (meals.length - 1))],\n      })\n    }, 1000)\n\n    return () => {\n      clearInterval(timer)\n    }\n  }, [])\n\n  return null\n}\n\nfunction BearNames() {\n  const names = useBearFamilyMealsStore((state) => Object.keys(state))\n\n  return <div>{names.join(', ')}</div>\n}\n\nexport default function App() {\n  return (\n    <>\n      <UpdateBabyBearMeal />\n      <BearNames />\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating App Component\nDESCRIPTION: Creates the `App` component, which renders two `MovingDot` components, each with its own independent state. Each `MovingDot` component is wrapped with its own `PositionStoreProvider` to ensure each has its own zustand store instance. The component utilizes flexbox for layout.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store-with-equality-fn.md#2025-04-22_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\nexport default function App() {\n  return (\n    <div style={{ display: 'flex' }}>\n      <PositionStoreProvider>\n        <MovingDot color=\"red\" />\n      </PositionStoreProvider>\n      <PositionStoreProvider>\n        <MovingDot color=\"blue\" />\n      </PositionStoreProvider>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Counter Store Creator in TypeScript\nDESCRIPTION: Shared code for creating a basic counter store with TypeScript types. Includes count state and increment function.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/testing.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type StateCreator } from 'zustand'\n\nexport type CounterStore = {\n  count: number\n  inc: () => void\n}\n\nexport const counterStoreCreator: StateCreator<CounterStore> = (set) => ({\n  count: 1,\n  inc: () => set((state) => ({ count: state.count + 1 })),\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Zustand Store\nDESCRIPTION: Defines a Zustand store to manage the x and y coordinates of a position. The store holds the position state and a setPosition action for updating the position. The `createStore` function from Zustand is used to initialize the store with the initial state and action.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store-with-equality-fn.md#2025-04-22_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\ntype PositionStoreState = { position: { x: number; y: number } }\n\ntype PositionStoreActions = {\n  setPosition: (nextPosition: PositionStoreState['position']) => void\n}\n\ntype PositionStore = PositionStoreState & PositionStoreActions\n\nconst createPositionStore = () => {\n  return createStore<PositionStore>()((set) => ({\n    position: { x: 0, y: 0 },\n    setPosition: (position) => set({ position }),\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Fish Slice in Zustand (JavaScript)\nDESCRIPTION: Defines a slice for managing fish state in a Zustand store. It includes a state property for the number of fishes and a method to add a fish.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/slices-pattern.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nexport const createFishSlice = (set) => ({\n  fishes: 0,\n  addFish: () => set((state) => ({ fishes: state.fishes + 1 })),\n})\n```\n\n----------------------------------------\n\nTITLE: Updating Array Values in State\nDESCRIPTION: Example showing how to handle array updates in Zustand state. This demonstrates immutable array update patterns to ensure proper state management.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-store.md#2025-04-22_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'zustand/vanilla'\n\ntype PositionStore = [number, number]\n\nconst positionStore = createStore<PositionStore>()(() => [0, 0])\n\nconst $dotContainer = document.getElementById('dot-container') as HTMLDivElement\nconst $dot = document.getElementById('dot') as HTMLDivElement\n\n$dotContainer.addEventListener('pointermove', (event) => {\n  positionStore.setState([event.clientX, event.clientY], true)\n})\n\nconst render: Parameters<typeof positionStore.subscribe>[0] = ([x, y]) => {\n  $dot.style.transform = `translate(${x}px, ${y}px)`\n}\n\nrender(positionStore.getInitialState(), positionStore.getInitialState())\n\npositionStore.subscribe(render)\n```\n\n----------------------------------------\n\nTITLE: Ensuring Stable References in Zustand v5 Selectors\nDESCRIPTION: This snippet shows how to ensure stable references in Zustand v5 selectors to prevent infinite loops. It demonstrates the use of a fallback constant to maintain stability when selecting potentially undefined values.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v5.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// v5\n\nconst FALLBACK_ACTION = () => {}\n\nconst action = useMainStore((state) => {\n  return state.action ?? FALLBACK_ACTION\n})\n```\n\n----------------------------------------\n\nTITLE: Converting Board to a Controlled Component\nDESCRIPTION: Refactors the Board component to be fully controlled by props, accepting xIsNext, squares, and onPlay props. This allows the Game component to control the Board's state and behavior.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_19\n\nLANGUAGE: jsx\nCODE:\n```\nfunction Board({ xIsNext, squares, onPlay }) {\n  const winner = calculateWinner(squares)\n  const turns = calculateTurns(squares)\n  const player = xIsNext ? 'X' : 'O'\n  const status = calculateStatus(winner, turns, player)\n\n  function handleClick(i) {\n    if (squares[i] || winner) return\n    const nextSquares = squares.slice()\n    nextSquares[i] = player\n    onPlay(nextSquares)\n  }\n\n  return (\n    <>\n      <div style={{ marginBottom: '0.5rem' }}>{status}</div>\n      <div\n        style={{\n          display: 'grid',\n          gridTemplateColumns: 'repeat(3, 1fr)',\n          gridTemplateRows: 'repeat(3, 1fr)',\n          width: 'calc(3 * 2.5rem)',\n          height: 'calc(3 * 2.5rem)',\n          border: '1px solid #999',\n        }}\n      >\n        {squares.map((square, squareIndex) => (\n          <Square\n            key={squareIndex}\n            value={square}\n            onSquareClick={() => handleClick(squareIndex)}\n          />\n        ))}\n      </div>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Counter Component\nDESCRIPTION: Unit tests for the Counter component using React Testing Library, testing initial render and increment functionality.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/testing.md#2025-04-22_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport { act, render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\n\nimport { Counter } from './counter'\n\ndescribe('Counter', () => {\n  test('should render with initial state of 1', async () => {\n    renderCounter()\n\n    expect(await screen.findByText(/^1$/)).toBeInTheDocument()\n    expect(\n      await screen.findByRole('button', { name: /one up/i }),\n    ).toBeInTheDocument()\n  })\n\n  test('should increase count by clicking a button', async () => {\n    const user = userEvent.setup()\n\n    renderCounter()\n\n    expect(await screen.findByText(/^1$/)).toBeInTheDocument()\n\n    await act(async () => {\n      await user.click(await screen.findByRole('button', { name: /one up/i }))\n    })\n\n    expect(await screen.findByText(/^2$/)).toBeInTheDocument()\n  })\n})\n\nconst renderCounter = () => {\n  return render(<Counter />)\n}\n```\n\n----------------------------------------\n\nTITLE: Hydration Status Check Implementation\nDESCRIPTION: Implementation of hydration status checking using onRehydrateStorage listener\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/integrations/persisting-store-data.md#2025-04-22_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst useBoundStore = create(\n  persist(\n    (set, get) => ({\n      _hasHydrated: false,\n      setHasHydrated: (state) => {\n        set({\n          _hasHydrated: state\n        });\n      }\n    }),\n    {\n      onRehydrateStorage: (state) => {\n        return () => state.setHasHydrated(true)\n      }\n    }\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Basic createStore Usage in JavaScript\nDESCRIPTION: Basic example of createStore usage to create a vanilla store instance. This demonstrates the fundamental syntax for creating a store.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-store.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst someStore = createStore(stateCreatorFn)\n```\n\n----------------------------------------\n\nTITLE: Creating a Position Tracker Store with Zustand Combine\nDESCRIPTION: A complete example of creating a store with combine middleware to track mouse position. The types are automatically inferred without explicit type definitions.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/combine.md#2025-04-22_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { createStore } from 'zustand/vanilla'\nimport { combine } from 'zustand/middleware'\n\nconst positionStore = createStore(\n  combine({ position: { x: 0, y: 0 } }, (set) => ({\n    setPosition: (position) => set({ position }),\n  }))),\n)\n\nconst $dotContainer = document.getElementById('dot-container') as HTMLDivElement\nconst $dot = document.getElementById('dot') as HTMLDivElement\n\n$dotContainer.addEventListener('pointermove', (event) => {\n  positionStore.getState().setPosition({\n    x: event.clientX,\n    y: event.clientY,\n  })\n})\n\nconst render: Parameters<typeof positionStore.subscribe>[0] = (state) => {\n  $dot.style.transform = `translate(${state.position.x}px, ${state.position.y}px)`\n}\n\nrender(positionStore.getInitialState(), positionStore.getInitialState())\n\npositionStore.subscribe(render)\n```\n\n----------------------------------------\n\nTITLE: Creating a Store with Zustand for Recoil Comparison\nDESCRIPTION: Shows how to create a counter store in Zustand with a setter function. Demonstrates Zustand's approach when compared to Recoil.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/getting-started/comparison.md#2025-04-22_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\n\ntype State = {\n  count: number\n}\n\ntype Actions = {\n  setCount: (countCallback: (count: State['count']) => State['count']) => void\n}\n\nconst useCountStore = create<State & Actions>((set) => ({\n  count: 0,\n  setCount: (countCallback) =>\n    set((state) => ({ count: countCallback(state.count) })),\n}))\n```\n\n----------------------------------------\n\nTITLE: Calculating Winner in Tic-Tac-Toe Game with JavaScript\nDESCRIPTION: Function that determines if there is a winner in a Tic-Tac-Toe game by checking all possible winning combinations of three squares in a row, column, or diagonal. Returns the winning player ('X' or 'O') or null if there is no winner.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\nfunction calculateWinner(squares) {\n  const lines = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [2, 4, 6],\n  ]\n\n  for (let i = 0; i < lines.length; i++) {\n    const [a, b, c] = lines[i]\n    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\n      return squares[a]\n    }\n  }\n\n  return null\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Counter Store with Zustand - TypeScript\nDESCRIPTION: Defines a factory function to create a counter store using Zustand. The store manages a 'count' state and provides an 'increment' method to update the count.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store.md#2025-04-22_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'zustand'\n\ntype CounterState = {\n  count: number\n}\n\ntype CounterActions = { increment: () => void }\n\ntype CounterStore = CounterState & CounterActions\n\nconst createCounterStore = () => {\n  return createStore<CounterStore>()((set) => ({\n    count: 0,\n    increment: () => {\n      set((state) => ({ count: state.count + 1 }))\n    },\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Adding handlePlay Function to Game Component\nDESCRIPTION: Creates a handlePlay function in the Game component and passes it along with state to the Board component. This function will handle updating the game history when a player makes a move.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_18\n\nLANGUAGE: jsx\nCODE:\n```\nexport default function Game() {\n  const history = useGameStore((state) => state.history)\n  const setHistory = useGameStore((state) => state.setHistory)\n  const currentMove = useGameStore((state) => state.currentMove)\n  const setCurrentMove = useGameStore((state) => state.setCurrentMove)\n  const currentSquares = history[history.length - 1]\n\n  function handlePlay(nextSquares) {\n    // TODO\n  }\n\n  return (\n    <div\n      style={{\n        display: 'flex',\n        flexDirection: 'row',\n        fontFamily: 'monospace',\n      }}\n    >\n      <div>\n        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />\n      </div>\n      <div style={{ marginLeft: '1rem' }}>\n        <ol>{/*TODO*/}</ol>\n      </div>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Redux Middleware Signature in JavaScript\nDESCRIPTION: Shows the basic function signature for creating a redux middleware store in Zustand\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/redux.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst nextStateCreatorFn = redux(reducerFn, initialState)\n```\n\n----------------------------------------\n\nTITLE: Redux Middleware TypeScript Definition\nDESCRIPTION: TypeScript type definition showing the complete signature of the redux middleware function\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/redux.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nredux<T, A>(reducerFn: (state: T, action: A) => T, initialState: T): StateCreator<T & { dispatch: (action: A) => A }, [['zustand/redux', A]], []>\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Storage for Persisting Zustand State in TypeScript\nDESCRIPTION: This code snippet showcases how to implement a custom storage engine that allows persisting Zustand state objects containing Map types. The implementation involves defining getItem and setItem methods, which manage serialization and deserialization of the state while converting transactions from a Map to an Array for storage and back.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/integrations/persisting-store-data.md#2025-04-22_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\ninterface BearState {\n  .\n  .\n  .\n  transactions: Map<any>\n}\n\n  storage: {\n    getItem: (name) => {\n      const str = localStorage.getItem(name);\n      if (!str) return null;\n      const existingValue = JSON.parse(str);\n      return {\n        ...existingValue,\n        state: {\n          ...existingValue.state,\n          transactions: new Map(existingValue.state.transactions),\n        }\n      }\n    },\n    setItem: (name, newValue: StorageValue<BearState>) => {\n      // functions cannot be JSON encoded\n      const str = JSON.stringify({\n        ...newValue,\n        state: {\n          ...newValue.state,\n          transactions: Array.from(newValue.state.transactions.entries()),\n        },\n      })\n      localStorage.setItem(name, str)\n    },\n    removeItem: (name) => localStorage.removeItem(name),\n  },\n```\n\n----------------------------------------\n\nTITLE: Creating Position Store with Zustand\nDESCRIPTION: Defines types and creates a Zustand store for managing x/y coordinates of a dot position. Includes state type definitions and a store creation function.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store.md#2025-04-22_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\ntype PositionStoreState = { position: { x: number; y: number } }\n\ntype PositionStoreActions = {\n  setPosition: (nextPosition: PositionStoreState['position']) => void\n}\n\ntype PositionStore = PositionStoreState & PositionStoreActions\n\nconst createPositionStore = () => {\n  return createStore<PositionStore>()((set) => ({\n    position: { x: 0, y: 0 },\n    setPosition: (position) => set({ position }),\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: useStoreWithEqualityFn Hook Signature in TypeScript\nDESCRIPTION: The TypeScript signature for the useStoreWithEqualityFn hook, showing its parameters and return type. It accepts a store API, a selector function, and an optional equality function to control component re-rendering.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store-with-equality-fn.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nuseStoreWithEqualityFn<T, U = T>(store: StoreApi<T>, selectorFn: (state: T) => U, equalityFn?: (a: T, b: T) => boolean): U\n```\n\n----------------------------------------\n\nTITLE: Selecting Multiple State Slices with useShallow\nDESCRIPTION: Example of using useShallow to select multiple state slices efficiently and prevent unnecessary rerenders.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/README.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { create } from 'zustand'\nimport { useShallow } from 'zustand/react/shallow'\n\nconst useBearStore = create((set) => ({\n  nuts: 0,\n  honey: 0,\n  treats: {},\n  // ...\n}))\n\n// Object pick, re-renders the component when either state.nuts or state.honey change\nconst { nuts, honey } = useBearStore(\n  useShallow((state) => ({ nuts: state.nuts, honey: state.honey })),\n)\n\n// Array pick, re-renders the component when either state.nuts or state.honey change\nconst [nuts, honey] = useBearStore(\n  useShallow((state) => [state.nuts, state.honey]),\n)\n\n// Mapped picks, re-renders the component when state.treats changes in order, count or keys\nconst treats = useBearStore(useShallow((state) => Object.keys(state.treats)))\n```\n\n----------------------------------------\n\nTITLE: Creating Counter Store with Zustand\nDESCRIPTION: Defines a factory function that generates a Zustand store for managing counter state with TypeScript types. The store includes a count value and an increment action.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store-with-equality-fn.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'zustand'\n\ntype CounterState = {\n  count: number\n}\n\ntype CounterActions = { increment: () => void }\n\ntype CounterStore = CounterState & CounterActions\n\nconst createCounterStore = () => {\n  return createStore<CounterStore>()((set) => ({\n    count: 0,\n    increment: () => {\n      set((state) => ({ count: state.count + 1 }))\n    },\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Slices Pattern with DevTools\nDESCRIPTION: Implementation of Redux DevTools with Zustand using the slices pattern for better code organization.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/devtools.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create, StateCreator } from 'zustand'\nimport { devtools } from 'zustand/middleware'\n\ntype BearSlice = {\n  bears: number\n  addBear: () => void\n}\n\ntype FishSlice = {\n  fishes: number\n  addFish: () => void\n}\n\ntype JungleStore = BearSlice & FishSlice\n\nconst createBearSlice: StateCreator<\n  JungleStore,\n  [['zustand/devtools', never]],\n  [],\n  BearSlice\n> = (set) => ({\n  bears: 0,\n  addBear: () =>\n    set(\n      (state) => ({ bears: state.bears + 1 }),\n      undefined,\n      'jungle:bear/addBear',\n    ),\n})\n\nconst createFishSlice: StateCreator<\n  JungleStore,\n  [['zustand/devtools', never]],\n  [],\n  FishSlice\n> = (set) => ({\n  fishes: 0,\n  addFish: () =>\n    set(\n      (state) => ({ fishes: state.fishes + 1 }),\n      undefined,\n      'jungle:fish/addFish',\n    ),\n})\n\nconst useJungleStore = create<JungleStore>()(\n  devtools((...args) => ({\n    ...createBearSlice(...args),\n    ...createFishSlice(...args),\n  })),\n)\n```\n\n----------------------------------------\n\nTITLE: Successful Comparison of Objects with Primitive Properties Only\nDESCRIPTION: Demonstrates how shallow correctly identifies equality between objects that contain only primitive values as properties, without nested objects.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/shallow.md#2025-04-22_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst objectLeft = {\n  firstName: 'John',\n  lastName: 'Doe',\n  age: 30,\n}\nconst objectRight = {\n  firstName: 'John',\n  lastName: 'Doe',\n  age: 30,\n}\n\nObject.is(objectLeft, objectRight) // -> false\nshallow(objectLeft, objectRight) // -> true\n```\n\n----------------------------------------\n\nTITLE: Comparing Maps with Shallow and Object.is\nDESCRIPTION: Shows how shallow and Object.is compare Maps with identical key-value pairs. Shallow correctly identifies Maps with the same entries as equal.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/shallow.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst mapLeft = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n])\nconst mapRight = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n])\n\nObject.is(mapLeft, mapRight) // -> false\nshallow(mapLeft, mapRight) // -> true\n```\n\n----------------------------------------\n\nTITLE: Initializing immer Middleware in Zustand\nDESCRIPTION: Basic signature for using the immer middleware with a state creator function. This pattern enables immutable updates with more concise code.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/immer.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst nextStateCreatorFn = immer(stateCreatorFn)\n```\n\n----------------------------------------\n\nTITLE: Transient Updates for Performance Optimization\nDESCRIPTION: Example of using transient updates to optimize performance for frequently changing state.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/README.md#2025-04-22_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nconst useScratchStore = create((set) => ({ scratches: 0, ... }))\n\nconst Component = () => {\n  // Fetch initial state\n  const scratchRef = useRef(useScratchStore.getState().scratches)\n  // Connect to the store on mount, disconnect on unmount, catch state-changes in a reference\n  useEffect(() => useScratchStore.subscribe(\n    state => (scratchRef.current = state.scratches)\n  ), [])\n  ...\n```\n\n----------------------------------------\n\nTITLE: Single Store in Zustand\nDESCRIPTION: Demonstrates Zustand's approach of using a single store with state and actions. Shows how to create a store with update functions.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/getting-started/comparison.md#2025-04-22_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\n\ntype State = {\n  count: number\n}\n\ntype Actions = {\n  updateCount: (\n    countCallback: (count: State['count']) => State['count'],\n  ) => void\n}\n\nconst useCountStore = create<State & Actions>((set) => ({\n  count: 0,\n  updateCount: (countCallback) =>\n    set((state) => ({ count: countCallback(state.count) })),\n}))\n```\n\n----------------------------------------\n\nTITLE: Using ExtractState for External State Type Inference in Zustand\nDESCRIPTION: Demonstrates how to use the ExtractState type helper to infer the state type outside of the store declaration, useful for type annotations in other parts of the codebase.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create, ExtractState } from 'zustand'\nimport { combine } from 'zustand/middleware'\n\ntype BearState = ExtractState<typeof useBearStore>\n\nconst useBearStore = create(\n  combine({ bears: 0 }, (set) => ({\n    increase: (by: number) => set((state) => ({ bears: state.bears + by })),\n  })),\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing handlePlay Function\nDESCRIPTION: Implements the handlePlay function in the Game component to update game history when a move is made. It adds the new board state to history and toggles the active player.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_20\n\nLANGUAGE: js\nCODE:\n```\nfunction handlePlay(nextSquares) {\n  setHistory(history.concat([nextSquares]))\n  setXIsNext(!xIsNext)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Persistent Zustand Store with Deep Merge\nDESCRIPTION: Configures a Zustand store with persistence middleware, deep merging, and type-safe position state management\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst positionStore = createStore<PositionStore>()(\n  persist(\n    (set) => ({\n      position: { x: 0, y: 0 },\n      setPosition: (position) => set({ position }),\n    }),\n    {\n      name: 'position-storage',\n      merge: (persisted, current) => deepMerge(current, persisted) as never,\n    },\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: HTML Structure for Primitive State Example\nDESCRIPTION: HTML markup for the dot container example used with primitive state. This defines a container and a dot element that will be positioned based on state updates.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-store.md#2025-04-22_snippet_5\n\nLANGUAGE: html\nCODE:\n```\n<div\n  id=\"dot-container\"\n  style=\"position: relative; width: 100vw; height: 100vh;\"\n>\n  <div\n    id=\"dot\"\n    style=\"position: absolute; background-color: red; border-radius: 50%; left: -10px; top: -10px; width: 20px; height: 20px;\"\n  ></div>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Configuring Vitest Setup\nDESCRIPTION: Vitest configuration setup including global types, test environment and Zustand mocking.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/testing.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n/// <reference types=\"vite/client\" />\n/// <reference types=\"vitest/globals\" />\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport '@testing-library/jest-dom'\n\nvi.mock('zustand')\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig, mergeConfig } from 'vitest/config'\nimport viteConfig from './vite.config'\n\nexport default defineConfig((configEnv) =>\n  mergeConfig(\n    viteConfig(configEnv),\n    defineConfig({\n      test: {\n        globals: true,\n        environment: 'jsdom',\n        setupFiles: ['./setup-vitest.ts'],\n      },\n    }),\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Optimized Game Component with Derived State in React\nDESCRIPTION: Improved Game component that derives the xIsNext state from currentMove instead of storing it separately. This eliminates potential state synchronization issues and simplifies the code by removing redundant state.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_29\n\nLANGUAGE: jsx\nCODE:\n```\nexport default function Game() {\n  const history = useGameStore((state) => state.history)\n  const setHistory = useGameStore((state) => state.setHistory)\n  const currentMove = useGameStore((state) => state.currentMove)\n  const setCurrentMove = useGameStore((state) => state.setCurrentMove)\n  const xIsNext = currentMove % 2 === 0\n  const currentSquares = history[currentMove]\n\n  function handlePlay(nextSquares) {\n    const nextHistory = history.slice(0, currentMove + 1).concat([nextSquares])\n    setHistory(nextHistory)\n    setCurrentMove(nextHistory.length - 1)\n  }\n\n  function jumpTo(nextMove) {\n    setCurrentMove(nextMove)\n  }\n\n  return (\n    <div\n      style={{\n        display: 'flex',\n        flexDirection: 'row',\n        fontFamily: 'monospace',\n      }}\n    >\n      <div>\n        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />\n      </div>\n      <div style={{ marginLeft: '1rem' }}>\n        <ol>\n          {history.map((_, historyIndex) => {\n            const description =\n              historyIndex > 0\n                ? `Go to move #${historyIndex}`\n                : 'Go to game start'\n\n            return (\n              <li key={historyIndex}>\n                <button onClick={() => jumpTo(historyIndex)}>\n                  {description}\n                </button>\n              </li>\n            )\n          })}\n        </ol>\n      </div>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using Bounded Store in React Component (JSX)\nDESCRIPTION: Illustrates how to use the bounded store in a React component. It shows accessing state and methods from different slices within the component.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/slices-pattern.md#2025-04-22_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useBoundStore } from './stores/useBoundStore'\n\nfunction App() {\n  const bears = useBoundStore((state) => state.bears)\n  const fishes = useBoundStore((state) => state.fishes)\n  const addBear = useBoundStore((state) => state.addBear)\n  return (\n    <div>\n      <h2>Number of bears: {bears}</h2>\n      <h2>Number of fishes: {fishes}</h2>\n      <button onClick={() => addBear()}>Add a bear</button>\n    </div>\n  )\n}\n\nexport default App\n```\n\n----------------------------------------\n\nTITLE: Object State Updates Example\nDESCRIPTION: Shows how to properly update object state while maintaining immutability principles using shallow merging.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-with-equality-fn.md#2025-04-22_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createWithEqualityFn } from 'zustand/traditional'\nimport { shallow } from 'zustand/vanilla/shallow'\n\ntype PositionStoreState = { position: { x: number; y: number } }\n\ntype PositionStoreActions = {\n  setPosition: (nextPosition: PositionStoreState['position']) => void\n}\n\ntype PositionStore = PositionStoreState & PositionStoreActions\n\nconst usePositionStore = createWithEqualityFn<PositionStore>()(\n  (set) => ({\n    position: { x: 0, y: 0 },\n    setPosition: (position) => set({ position }),\n  }),\n  shallow,\n)\n\nexport default function MovingDot() {\n  const position = usePositionStore((state) => state.position)\n  const setPosition = usePositionStore((state) => state.setPosition)\n\n  return (\n    <div\n      onPointerMove={(e) => {\n        setPosition({\n          x: e.clientX,\n          y: e.clientY,\n        })\n      }}\n      style={{\n        position: 'relative',\n        width: '100vw',\n        height: '100vh',\n      }}\n    >\n      <div\n        style={{\n          position: 'absolute',\n          backgroundColor: 'red',\n          borderRadius: '50%',\n          transform: `translate(${position.x}px, ${position.y}px)`,\n          left: -10,\n          top: -10,\n          width: 20,\n          height: 20,\n        }}\n      />\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Custom Hook in a Consumer Component\nDESCRIPTION: Shows how a component can use the custom hook to access store state and actions. This approach simplifies the component code by abstracting away the context and store access logic.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/initialize-state-with-props.md#2025-04-22_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n// Consumer usage of the custom hook\nfunction CommonConsumer() {\n  const bears = useBearContext((s) => s.bears)\n  const addBear = useBearContext((s) => s.addBear)\n  return (\n    <>\n      <div>{bears} Bears.</div>\n      <button onClick={addBear}>Add bear</button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using createWithEqualityFn for Custom Equality Functions in Zustand v5\nDESCRIPTION: This snippet demonstrates how to migrate from using 'create' with a custom equality function in v4 to using 'createWithEqualityFn' in v5. It includes the necessary import changes and shows how to maintain the same functionality.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v5.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install use-sync-external-store\n```\n\nLANGUAGE: javascript\nCODE:\n```\n// v5\nimport { createWithEqualityFn as create } from 'zustand/traditional'\n\n// The rest is the same as v4\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Zustand State Updates\nDESCRIPTION: Shows how to subscribe to state changes in Zustand using the subscribe method. Implements a MovingDot component with position tracking.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-with-equality-fn.md#2025-04-22_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useEffect } from 'react'\nimport { createWithEqualityFn } from 'zustand/traditional'\nimport { shallow } from 'zustand/vanilla/shallow'\n\ntype PositionStoreState = { position: { x: number; y: number } }\n\ntype PositionStoreActions = {\n  setPosition: (nextPosition: PositionStoreState['position']) => void\n}\n\ntype PositionStore = PositionStoreState & PositionStoreActions\n\nconst usePositionStore = createWithEqualityFn<PositionStore>()(\n  (set) => ({\n    position: { x: 0, y: 0 },\n    setPosition: (nextPosition) => set(nextPosition),\n  }),\n  shallow,\n)\n\nexport default function MovingDot() {\n  const position = usePositionStore((state) => state.position)\n  const setPosition = usePositionStore((state) => state.setPosition)\n\n  useEffect(() => {\n    const unsubscribePositionStore = usePositionStore.subscribe(\n      ({ position }) => {\n        console.log('new position', { position })\n      },\n    )\n\n    return () => {\n      unsubscribePositionStore()\n    }\n  }, [])\n\n  return (\n    <div\n      style={{\n        position: 'relative',\n        width: '100vw',\n        height: '100vh',\n      }}\n    >\n      <div\n        style={{\n          position: 'absolute',\n          backgroundColor: 'red',\n          borderRadius: '50%',\n          transform: `translate(${position.x}px, ${position.y}px)`,\n          left: -10,\n          top: -10,\n          width: 20,\n          height: 20,\n        }}\n        onMouseEnter={(event) => {\n          const parent = event.currentTarget.parentElement\n          const parentWidth = parent.clientWidth\n          const parentHeight = parent.clientHeight\n\n          setPosition({\n            x: Math.ceil(Math.random() * parentWidth),\n            y: Math.ceil(Math.random() * parentHeight),\n          })\n        }}\n      />\n    </div>\n  )\n```\n\n----------------------------------------\n\nTITLE: HTML Form for Person Store Example\nDESCRIPTION: HTML markup for the form inputs used in the zustand store examples. Contains fields for first name, last name, and email.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/immer.md#2025-04-22_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<label style=\"display: block\">\n  First name:\n  <input id=\"first-name\" />\n</label>\n<label style=\"display: block\">\n  Last name:\n  <input id=\"last-name\" />\n</label>\n<label style=\"display: block\">\n  Email:\n  <input id=\"email\" />\n</label>\n<p id=\"result\"></p>\n```\n\n----------------------------------------\n\nTITLE: Defining Actions at Module Level in Zustand\nDESCRIPTION: An alternative Zustand pattern where actions are defined externally at the module level instead of within the store. This approach doesn't require hooks to call actions and facilitates code splitting.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/practice-with-no-store-actions.md#2025-04-22_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nexport const useBoundStore = create(() => ({\n  count: 0,\n  text: 'hello',\n}))\n\nexport const inc = () =>\n  useBoundStore.setState((state) => ({ count: state.count + 1 }))\n\nexport const setText = (text) => useBoundStore.setState({ text })\n```\n\n----------------------------------------\n\nTITLE: Creating a Position Store with Zustand\nDESCRIPTION: Example of creating a vanilla store using Zustand's createStore function to track and update the position of a dot on the screen. The store includes state for x and y coordinates and an action to update the position.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store-with-equality-fn.md#2025-04-22_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createStore, useStore } from 'zustand'\n\ntype PositionStoreState = { position: { x: number; y: number } }\n\ntype PositionStoreActions = {\n  setPosition: (nextPosition: PositionStoreState['position']) => void\n}\n\ntype PositionStore = PositionStoreState & PositionStoreActions\n\nconst positionStore = createStore<PositionStore>()((set) => ({\n  position: { x: 0, y: 0 },\n  setPosition: (position) => set({ position }),\n}))\n```\n\n----------------------------------------\n\nTITLE: Primitive State Updates Example\nDESCRIPTION: Demonstrates how to handle primitive value updates in a store using complete state replacement.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-with-equality-fn.md#2025-04-22_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createWithEqualityFn } from 'zustand/traditional'\nimport { shallow } from 'zustand/vanilla/shallow'\n\ntype XStore = number\n\nconst useXStore = createWithEqualityFn<XStore>()(() => 0, shallow)\n\nexport default function MovingDot() {\n  const x = useXStore()\n  const setX = (nextX: number) => {\n    useXStore.setState(nextX, true)\n  }\n  const position = { y: 0, x }\n\n  return (\n    <div\n      onPointerMove={(e) => {\n        setX(e.clientX)\n      }}\n      style={{\n        position: 'relative',\n        width: '100vw',\n        height: '100vh',\n      }}\n    >\n      <div\n        style={{\n          position: 'absolute',\n          backgroundColor: 'red',\n          borderRadius: '50%',\n          transform: `translate(${position.x}px, ${position.y}px)`,\n          left: -10,\n          top: -10,\n          width: 20,\n          height: 20,\n        }}\n      />\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic Store Management with Map\nDESCRIPTION: Implementation of a factory function that manages the creation and retrieval of counter stores using a Map. This allows creating and retrieving stores on demand with unique keys.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store.md#2025-04-22_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst defaultCounterStores = new Map<\n  string,\n  ReturnType<typeof createCounterStore>\n>()\n\nconst createCounterStoreFactory = (\n  counterStores: typeof defaultCounterStores,\n) => {\n  return (counterStoreKey: string) => {\n    if (!counterStores.has(counterStoreKey)) {\n      counterStores.set(counterStoreKey, createCounterStore())\n    }\n    return counterStores.get(counterStoreKey)!\n  }\n}\n\nconst getOrCreateCounterStoreByKey =\n  createCounterStoreFactory(defaultCounterStores)\n```\n\n----------------------------------------\n\nTITLE: Manual Hydration of Persisted Store in React Component\nDESCRIPTION: Example of manually triggering hydration in a React component using the rehydrate method from the persist API, typically used in conjunction with skipHydration option.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/integrations/persisting-store-data.md#2025-04-22_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useBoundStore } from './path-to-store';\n\nexport function StoreConsumer() {\n  // hydrate persisted store after on mount\n  useEffect(() => {\n    useBoundStore.persist.rehydrate();\n  }, [])\n\n  return (\n    //...\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Age Store Implementation with Previous State Updates\nDESCRIPTION: Example showing how to implement a store with updater functions that can reference previous state values. Uses shallow comparison for equality checks.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-with-equality-fn.md#2025-04-22_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createWithEqualityFn } from 'zustand/traditional'\nimport { shallow } from 'zustand/vanilla/shallow'\n\ntype AgeStoreState = { age: number }\n\ntype AgeStoreActions = {\n  setAge: (\n    nextAge:\n      | AgeStoreState['age']\n      | ((currentAge: AgeStoreState['age']) => AgeStoreState['age']),\n  ) => void\n}\n\ntype AgeStore = AgeStoreState & AgeStoreActions\n\nconst useAgeStore = createWithEqualityFn<AgeStore>()(\n  (set) => ({\n    age: 42,\n    setAge: (nextAge) =>\n      set((state) => ({\n        age: typeof nextAge === 'function' ? nextAge(state.age) : nextAge,\n      })),\n  }),\n  shallow,\n)\n\nexport default function App() {\n  const age = useAgeStore((state) => state.age)\n  const setAge = useAgeStore((state) => state.setAge)\n\n  function increment() {\n    setAge((currentAge) => currentAge + 1)\n  }\n\n  return (\n    <>\n      <h1>Your age: {age}</h1>\n      <button\n        type=\"button\"\n        onClick={() => {\n          increment()\n          increment()\n          increment()\n        }}\n      >\n        +3\n      </button>\n      <button\n        type=\"button\"\n        onClick={() => {\n          increment()\n        }}\n      >\n        +1\n      </button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Counter Store Factory with Zustand\nDESCRIPTION: Implementation of a counter store factory function using Zustand's vanilla store creator with TypeScript types.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/nextjs.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'zustand/vanilla'\n\nexport type CounterState = {\n  count: number\n}\n\nexport type CounterActions = {\n  decrementCount: () => void\n  incrementCount: () => void\n}\n\nexport type CounterStore = CounterState & CounterActions\n\nexport const defaultInitState: CounterState = {\n  count: 0,\n}\n\nexport const createCounterStore = (\n  initState: CounterState = defaultInitState,\n) => {\n  return createStore<CounterStore>()((set) => ({\n    ...initState,\n    decrementCount: () => set((state) => ({ count: state.count - 1 })),\n    incrementCount: () => set((state) => ({ count: state.count + 1 })),\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Render Optimization with Recoil\nDESCRIPTION: Shows how Recoil handles render optimization through atom dependency. Demonstrates using useRecoilState to get and update atom values.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/getting-started/comparison.md#2025-04-22_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom, useRecoilState } from 'recoil'\n\nconst countAtom = atom({\n  key: 'count',\n  default: 0,\n})\n\nconst Component = () => {\n  const [count, setCount] = useRecoilState(countAtom)\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Logger Middleware that Preserves Store Type\nDESCRIPTION: Implementation of a logger middleware that doesn't change the store type. This example shows how to properly type a middleware that wraps the set function but doesn't add new properties to the store.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md#2025-04-22_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create, StateCreator, StoreMutatorIdentifier } from 'zustand'\n\ntype Logger = <\n  T,\n  Mps extends [StoreMutatorIdentifier, unknown][] = [],\n  Mcs extends [StoreMutatorIdentifier, unknown][] = [],\n>(\n  f: StateCreator<T, Mps, Mcs>,\n  name?: string,\n) => StateCreator<T, Mps, Mcs>\n\ntype LoggerImpl = <T>(\n  f: StateCreator<T, [], []>,\n  name?: string,\n) => StateCreator<T, [], []>\n\nconst loggerImpl: LoggerImpl = (f, name) => (set, get, store) => {\n  const loggedSet: typeof set = (...a) => {\n    set(...(a as Parameters<typeof set>))\n    console.log(...(name ? [`${name}:`] : []), get())\n  }\n  const setState = store.setState\n  store.setState = (...a) => {\n    setState(...(a as Parameters<typeof setState>))\n    console.log(...(name ? [`${name}:`] : []), store.getState())\n  }\n\n  return f(loggedSet, get, store)\n}\n\nexport const logger = loggerImpl as unknown as Logger\n\n// ---\n\nconst useBearStore = create<BearState>()(\n  logger(\n    (set) => ({\n      bears: 0,\n      increase: (by) => set((state) => ({ bears: state.bears + by })),\n    }),\n    'bear-store',\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Store With Named Actions\nDESCRIPTION: Corrected implementation with properly named actions for better debugging experience.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/devtools.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create, StateCreator } from 'zustand'\n\ntype BearSlice = {\n  bears: number\n  addBear: () => void\n}\n\ntype FishSlice = {\n  fishes: number\n  addFish: () => void\n}\n\ntype JungleStore = BearSlice & FishSlice\n\nconst createBearSlice: StateCreator<\n  JungleStore,\n  [['zustand/devtools', never]],\n  [],\n  BearSlice\n> = (set) => ({\n  bears: 0,\n  addBear: () =>\n    set((state) => ({ bears: state.bears + 1 }), undefined, 'bear/addBear'),\n})\n\nconst createFishSlice: StateCreator<\n  JungleStore,\n  [['zustand/devtools', never]],\n  [],\n  FishSlice\n> = (set) => ({\n  fishes: 0,\n  addFish: () =>\n    set((state) => ({ fishes: state.fishes + 1 }), undefined, 'fish/addFish'),\n})\n\nconst useJungleStore = create<JungleStore>()(\n  devtools((...args) => ({\n    ...createBearSlice(...args),\n    ...createFishSlice(...args),\n  })),\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Zustand Mock for Jest\nDESCRIPTION: Jest mock implementation for Zustand that enables store reset between tests. Includes support for both create and createStore functions with TypeScript types.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/testing.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { act } from '@testing-library/react'\nimport type * as ZustandExportedTypes from 'zustand'\nexport * from 'zustand'\n\nconst { create: actualCreate, createStore: actualCreateStore } =\n  jest.requireActual<typeof ZustandExportedTypes>('zustand')\n\nexport const storeResetFns = new Set<() => void>()\n\nconst createUncurried = <T>(\n  stateCreator: ZustandExportedTypes.StateCreator<T>,\n) => {\n  const store = actualCreate(stateCreator)\n  const initialState = store.getInitialState()\n  storeResetFns.add(() => {\n    store.setState(initialState, true)\n  })\n  return store\n}\n\nexport const create = (<T>(\n  stateCreator: ZustandExportedTypes.StateCreator<T>,\n) => {\n  console.log('zustand create mock')\n\n  return typeof stateCreator === 'function'\n    ? createUncurried(stateCreator)\n    : createUncurried\n}) as typeof ZustandExportedTypes.create\n\nconst createStoreUncurried = <T>(\n  stateCreator: ZustandExportedTypes.StateCreator<T>,\n) => {\n  const store = actualCreateStore(stateCreator)\n  const initialState = store.getInitialState()\n  storeResetFns.add(() => {\n    store.setState(initialState, true)\n  })\n  return store\n}\n\nexport const createStore = (<T>(\n  stateCreator: ZustandExportedTypes.StateCreator<T>,\n) => {\n  console.log('zustand createStore mock')\n\n  return typeof stateCreator === 'function'\n    ? createStoreUncurried(stateCreator)\n    : createStoreUncurried\n}) as typeof ZustandExportedTypes.createStore\n\nafterEach(() => {\n  act(() => {\n    storeResetFns.forEach((resetFn) => {\n      resetFn()\n    })\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Counter Store Provider Component\nDESCRIPTION: React provider component setup for the counter store with context and custom hook implementation.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/nextjs.md#2025-04-22_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\n\nimport { type ReactNode, createContext, useRef, useContext } from 'react'\nimport { useStore } from 'zustand'\n\nimport { type CounterStore, createCounterStore } from '@/stores/counter-store'\n\nexport type CounterStoreApi = ReturnType<typeof createCounterStore>\n\nexport const CounterStoreContext = createContext<CounterStoreApi | undefined>(\n  undefined,\n)\n\nexport interface CounterStoreProviderProps {\n  children: ReactNode\n}\n\nexport const CounterStoreProvider = ({\n  children,\n}: CounterStoreProviderProps) => {\n  const storeRef = useRef<CounterStoreApi | null>(null)\n  if (storeRef.current === null) {\n    storeRef.current = createCounterStore()\n  }\n\n  return (\n    <CounterStoreContext.Provider value={storeRef.current}>\n      {children}\n    </CounterStoreContext.Provider>\n  )\n}\n\nexport const useCounterStore = <T,>(\n  selector: (store: CounterStore) => T,\n): T => {\n  const counterStoreContext = useContext(CounterStoreContext)\n\n  if (!counterStoreContext) {\n    throw new Error(`useCounterStore must be used within CounterStoreProvider`)\n  }\n\n  return useStore(counterStoreContext, selector)\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Middleware Wrapper with Zustand in TypeScript\nDESCRIPTION: Example showing a custom middleware wrapper function that applies both devtools and persist. This approach requires more advanced types to properly maintain type inference.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\nimport { devtools, persist } from 'zustand/middleware'\n\nconst myMiddlewares = (f) => devtools(persist(f, { name: 'bearStore' }))\n\ninterface BearState {\n  bears: number\n  increase: (by: number) => void\n}\n\nconst useBearStore = create<BearState>()(\n  myMiddlewares((set) => ({\n    bears: 0,\n    increase: (by) => set((state) => ({ bears: state.bears + by })),\n  })),\n)\n```\n\n----------------------------------------\n\nTITLE: Complete Tabs Example with Dynamic Stores\nDESCRIPTION: Full implementation of a tabs component using dynamic Zustand stores. Each tab has its own independent counter store, demonstrating how to use dynamic store creation in a React application.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store.md#2025-04-22_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react'\nimport { createStore, useStore } from 'zustand'\n\ntype CounterState = {\n  count: number\n}\n\ntype CounterActions = { increment: () => void }\n\ntype CounterStore = CounterState & CounterActions\n\nconst createCounterStore = () => {\n  return createStore<CounterStore>()((set) => ({\n    count: 0,\n    increment: () => {\n      set((state) => ({ count: state.count + 1 }))\n    },\n  }))\n}\n\nconst defaultCounterStores = new Map<\n  string,\n  ReturnType<typeof createCounterStore>\n>()\n\nconst createCounterStoreFactory = (\n  counterStores: typeof defaultCounterStores,\n) => {\n  return (counterStoreKey: string) => {\n    if (!counterStores.has(counterStoreKey)) {\n      counterStores.set(counterStoreKey, createCounterStore())\n    }\n    return counterStores.get(counterStoreKey)!\n  }\n}\n\nconst getOrCreateCounterStoreByKey =\n  createCounterStoreFactory(defaultCounterStores)\n\nexport default function App() {\n  const [currentTabIndex, setCurrentTabIndex] = useState(0)\n  const counterState = useStore(\n    getOrCreateCounterStoreByKey(`tab-${currentTabIndex}`),\n  )\n\n  return (\n    <div style={{ fontFamily: 'monospace' }}>\n      <div\n        style={{\n          display: 'flex',\n          gap: '0.5rem',\n          borderBottom: '1px solid salmon',\n          paddingBottom: 4,\n        }}\n      >\n        <button\n          type=\"button\"\n          style={{\n            border: '1px solid salmon',\n            backgroundColor: '#fff',\n            cursor: 'pointer',\n          }}\n          onClick={() => setCurrentTabIndex(0)}\n        >\n          Tab 1\n        </button>\n        <button\n          type=\"button\"\n          style={{\n            border: '1px solid salmon',\n            backgroundColor: '#fff',\n            cursor: 'pointer',\n          }}\n          onClick={() => setCurrentTabIndex(1)}\n        >\n          Tab 2\n        </button>\n        <button\n          type=\"button\"\n          style={{\n            border: '1px solid salmon',\n            backgroundColor: '#fff',\n            cursor: 'pointer',\n          }}\n          onClick={() => setCurrentTabIndex(2)}\n        >\n          Tab 3\n        </button>\n      </div>\n      <div style={{ padding: 4 }}>\n        Content of Tab {currentTabIndex + 1}\n        <br /> <br />\n        <button type=\"button\" onClick={() => counterState.increment()}>\n          Count: {counterState.count}\n        </button>\n      </div>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Atoms with Recoil\nDESCRIPTION: Demonstrates how to create an atom in Recoil with a key and default value. Shows Recoil's approach of using string keys to identify atoms.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/getting-started/comparison.md#2025-04-22_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from 'recoil'\n\nconst count = atom({\n  key: 'count',\n  default: 0,\n})\n```\n\n----------------------------------------\n\nTITLE: Immer Middleware Usage\nDESCRIPTION: Demonstrates using Immer as middleware for simplified state mutations in Zustand\nSOURCE: https://github.com/pmndrs/zustand/blob/main/README.md#2025-04-22_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\nimport { create } from 'zustand'\nimport { immer } from 'zustand/middleware/immer'\n\nconst useBeeStore = create(\n  immer((set) => ({\n    bees: 0,\n    addBees: (by) =>\n      set((state) => {\n        state.bees += by\n      }),\n  })),\n)\n```\n\n----------------------------------------\n\nTITLE: Handling Input Changes for Zustand State Updates\nDESCRIPTION: This snippet registers event listeners for input fields and updates the Zustand store when inputs change. The state is updated properly by using a spread operator to merge new values with existing state data.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-store.md#2025-04-22_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nfunction handleFirstNameChange(event: Event) {\n  personStore.getState().setPerson({\n    ...personStore.getState().person,\n    firstName: (event.target as any).value,\n  })\n}\n\nfunction handleLastNameChange(event: Event) {\n  personStore.getState().setPerson({\n    ...personStore.getState().person,\n    lastName: (event.target as any).value,\n  })\n}\n\nfunction handleEmailChange(event: Event) {\n  personStore.getState().setPerson({\n    ...personStore.getState().person,\n    email: (event.target as any).value,\n  })\n}\n\n$firstNameInput.addEventListener('input', handleFirstNameChange)\n$lastNameInput.addEventListener('input', handleLastNameChange)\n$emailInput.addEventListener('input', handleEmailChange)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Middleware that Changes Store Type\nDESCRIPTION: Implementation of a middleware that changes the store type by adding a new property. This shows how to properly handle type mutations in Zustand middleware with TypeScript.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md#2025-04-22_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  create,\n  StateCreator,\n  StoreMutatorIdentifier,\n  Mutate,\n  StoreApi,\n} from 'zustand'\n\ntype Foo = <\n  T,\n  A,\n  Mps extends [StoreMutatorIdentifier, unknown][] = [],\n  Mcs extends [StoreMutatorIdentifier, unknown][] = [],\n>(\n  f: StateCreator<T, [...Mps, ['foo', A]], Mcs>,\n  bar: A,\n) => StateCreator<T, Mps, [['foo', A], ...Mcs]>\n\ndeclare module 'zustand' {\n  interface StoreMutators<S, A> {\n    foo: Write<Cast<S, object>, { foo: A }>\n  }\n}\n\ntype FooImpl = <T, A>(\n  f: StateCreator<T, [], []>,\n  bar: A,\n) => StateCreator<T, [], []>\n\nconst fooImpl: FooImpl = (f, bar) => (set, get, _store) => {\n  type T = ReturnType<typeof f>\n  type A = typeof bar\n\n  const store = _store as Mutate<StoreApi<T>, [['foo', A]]>\n  store.foo = bar\n  return f(set, get, _store)\n}\n\nexport const foo = fooImpl as unknown as Foo\n\ntype Write<T extends object, U extends object> = Omit<T, keyof U> & U\n\ntype Cast<T, U> = T extends U ? T : U\n\n// ---\n\nconst useBearStore = create(foo(() => ({ bears: 0 }), 'hello'))\nconsole.log(useBearStore.foo.toUpperCase())\n```\n\n----------------------------------------\n\nTITLE: Render Optimization with Valtio Snapshots\nDESCRIPTION: Shows how Valtio handles render optimization through property access on snapshots. Demonstrates Valtio's approach of tracking accessed properties to optimize renders.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/getting-started/comparison.md#2025-04-22_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { proxy, useSnapshot } from 'valtio'\n\nconst state = proxy({\n  count: 0,\n})\n\nconst Component = () => {\n  const { count } = useSnapshot(state)\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Counter Store Factory Implementation\nDESCRIPTION: Creates a factory function that manages the creation and retrieval of counter stores using a Map. This ensures each tab has its own independent counter store instance.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store-with-equality-fn.md#2025-04-22_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst defaultCounterStores = new Map<\n  string,\n  ReturnType<typeof createCounterStore>\n>()\n\nconst createCounterStoreFactory = (\n  counterStores: typeof defaultCounterStores,\n) => {\n  return (counterStoreKey: string) => {\n    if (!counterStores.has(counterStoreKey)) {\n      counterStores.set(counterStoreKey, createCounterStore())\n    }\n    return counterStores.get(counterStoreKey)!\n  }\n}\n\nconst getOrCreateCounterStoreByKey =\n  createCounterStoreFactory(defaultCounterStores)\n```\n\n----------------------------------------\n\nTITLE: Creating Context for Counter Stores - TSX\nDESCRIPTION: Defines a React context for managing the lifecycle of counter stores. This context is used to provide and access the stores throughout the React component tree.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store.md#2025-04-22_snippet_16\n\nLANGUAGE: tsx\nCODE:\n```\nconst CounterStoresContext = createContext(null)\n\nconst CounterStoresProvider = ({ children }) => {\n  const [stores] = useState(\n    () => new Map<string, ReturnType<typeof createCounterStore>>(),\n  )\n\n  return (\n    <CounterStoresContext.Provider value={stores}>\n      {children}\n    </CounterStoresContext.Provider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Click Events in Tic-Tac-Toe Board Component using JavaScript\nDESCRIPTION: This function handles user interactions with the squares in the Tic-Tac-Toe board. It prevents actions if the clicked square is already filled or if the game has a winner, updates the squares and toggles the active player accordingly.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nfunction handleClick(i) {\n  if (squares[i] || winner) return\n  const nextSquares = squares.slice()\n  nextSquares[i] = player\n  setSquares(nextSquares)\n  setXIsNext(!xIsNext)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Reusable Function for Bounded useStore Hooks\nDESCRIPTION: Abstract implementation for creating bounded useStore hooks from vanilla Zustand stores. This approach DRYs up code by providing a reusable function for creating type-safe store hooks.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md#2025-04-22_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useStore, StoreApi } from 'zustand'\nimport { createStore } from 'zustand/vanilla'\n\ninterface BearState {\n  bears: number\n  increase: (by: number) => void\n}\n\nconst bearStore = createStore<BearState>()((set) => ({\n  bears: 0,\n  increase: (by) => set((state) => ({ bears: state.bears + by })),\n}))\n\nconst createBoundedUseStore = ((store) => (selector) =>\n  useStore(store, selector)) as <S extends StoreApi<unknown>>(\n  store: S,\n) => {\n  (): ExtractState<S>\n  <T>(selector: (state: ExtractState<S>) => T): T\n}\n\ntype ExtractState<S> = S extends { getState: () => infer X } ? X : never\n\nconst useBearStore = createBoundedUseStore(bearStore)\n```\n\n----------------------------------------\n\nTITLE: Selecting Specific Properties for Persistence in Zustand\nDESCRIPTION: Example demonstrating how to persist only specific fields from the state using the partialize option, in this case only preserving the 'foo' property.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/integrations/persisting-store-data.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport const useBoundStore = create(\n  persist(\n    (set, get) => ({\n      foo: 0,\n      bar: 1,\n    }),\n    {\n      // ...\n      partialize: (state) => ({ foo: state.foo }),\n    },\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Rendering User Input Values from Zustand Store\nDESCRIPTION: This snippet contains the rendering function that updates the input fields and result paragraph based on the latest state from the Zustand store. It ensures the UI reflects the current state whenever the store is updated.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-store.md#2025-04-22_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst render: Parameters<typeof personStore.subscribe>[0] = (state) => {\n  $firstNameInput.value = state.person.firstName\n  $lastNameInput.value = state.person.lastName\n  $emailInput.value = state.person.email\n\n  $result.innerHTML = `${state.person.firstName} ${state.person.lastName} (${state.person.email})`\n}\n\nrender(personStore.getInitialState(), personStore.getInitialState())\n\npersonStore.subscribe(render)\n```\n\n----------------------------------------\n\nTITLE: Custom Hook for Position Store Access\nDESCRIPTION: Creates a custom hook to safely access the position store from components. Includes error handling for usage outside provider context.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store.md#2025-04-22_snippet_11\n\nLANGUAGE: ts\nCODE:\n```\nfunction usePositionStore<U>(selector: (state: PositionStore) => U) {\n  const store = useContext(PositionStoreContext)\n\n  if (store === null) {\n    throw new Error(\n      'usePositionStore must be used within PositionStoreProvider',\n    )\n  }\n\n  return useStore(store, selector)\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Dynamic replace Flag in Zustand v5 setState\nDESCRIPTION: This TypeScript snippet demonstrates how to handle a dynamic 'replace' flag when using setState in Zustand v5. It shows how to properly type the arguments to avoid TypeScript errors when the replace flag is determined at runtime.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v5.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst replaceFlag = Math.random() > 0.5\nconst args = [{ bears: 5 }, replaceFlag] as Parameters<\n  typeof useBearStore.setState\n>\nstore.setState(...args)\n```\n\n----------------------------------------\n\nTITLE: Using Conventional Commit Format for Zustand Project\nDESCRIPTION: Examples of how to format commit messages using the conventional commit specification. Shows basic format with type and message, as well as how to specify a scope.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/CONTRIBUTING.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nfeat: add a 'foo' type support\n```\n\nLANGUAGE: bash\nCODE:\n```\nfix(react): change the 'bar' parameter type\n```\n\n----------------------------------------\n\nTITLE: Updating Deeply Nested State with Standard Approach\nDESCRIPTION: Demonstrates the traditional way of updating deeply nested state by manually copying each level with the spread operator.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/updating-state.md#2025-04-22_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\n  normalInc: () =>\n    set((state) => ({\n      deep: {\n        ...state.deep,\n        nested: {\n          ...state.deep.nested,\n          obj: {\n            ...state.deep.nested.obj,\n            count: state.deep.nested.obj.count + 1\n          }\n        }\n      }\n    })),\n```\n\n----------------------------------------\n\nTITLE: Counter Store Factory for Dynamic Stores\nDESCRIPTION: Factory function that creates individual counter stores with increment functionality. Used for creating dynamic stores per tab in a UI.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store.md#2025-04-22_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ntype CounterState = {\n  count: number\n}\n\ntype CounterActions = { increment: () => void }\n\ntype CounterStore = CounterState & CounterActions\n\nconst createCounterStore = () => {\n  return createStore<CounterStore>()((set) => ({\n    count: 0,\n    increment: () => {\n      set((state) => ({ count: state.count + 1 }))\n    },\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Counter Store Factory in TypeScript\nDESCRIPTION: This snippet defines types for the counter state and actions, and creates a factory function to generate a Zustand store for managing counter state. It also includes a function to create or retrieve counter stores based on a key.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store-with-equality-fn.md#2025-04-22_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\ntype CounterState = {\n  count: number\n}\n\ntype CounterActions = { increment: () => void }\n\ntype CounterStore = CounterState & CounterActions\n\nconst createCounterStore = () => {\n  return createStore<CounterStore>()((set) => ({\n    count: 0,\n    increment: () => {\n      set((state) => ({ count: state.count + 1 }))\n    },\n  }))\n}\n\nconst createCounterStoreFactory = (\n  counterStores: Map<string, ReturnType<typeof createCounterStore>>,\n) => {\n  return (counterStoreKey: string) => {\n    if (!counterStores.has(counterStoreKey)) {\n      counterStores.set(counterStoreKey, createCounterStore())\n    }\n    return counterStores.get(counterStoreKey)!\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic subscribeWithSelector Implementation - JavaScript\nDESCRIPTION: Shows the basic implementation of subscribeWithSelector middleware with a state creator function.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/subscribe-with-selector.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst nextStateCreatorFn = subscribeWithSelector(stateCreatorFn)\n```\n\n----------------------------------------\n\nTITLE: Defining a Deeply Nested State Type in TypeScript\nDESCRIPTION: Shows how to define a TypeScript type for a deeply nested state object in Zustand.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/updating-state.md#2025-04-22_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\ntype State = {\n  deep: {\n    nested: {\n      obj: { count: number }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Position Store Context and Provider\nDESCRIPTION: Implements React Context and Provider components to enable scoped store instances throughout the component tree. Uses useState to maintain store instance.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store.md#2025-04-22_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nconst PositionStoreContext = createContext<ReturnType<\n  typeof createPositionStore\n> | null>(null)\n\nfunction PositionStoreProvider({ children }: { children: ReactNode }) {\n  const [positionStore] = useState(createPositionStore)\n\n  return (\n    <PositionStoreContext.Provider value={positionStore}>\n      {children}\n    </PositionStoreContext.Provider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Counter Component with Context\nDESCRIPTION: Unit tests for the CounterWithContext component using React Testing Library, testing initial render and increment functionality.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/testing.md#2025-04-22_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nimport { act, render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\n\nimport { CounterWithContext } from './counter-with-context'\n\ndescribe('CounterWithContext', () => {\n  test('should render with initial state of 1', async () => {\n    renderCounterWithContext()\n\n    expect(await screen.findByText(/^1$/)).toBeInTheDocument()\n    expect(\n      await screen.findByRole('button', { name: /one up/i }),\n    ).toBeInTheDocument()\n  })\n\n  test('should increase count by clicking a button', async () => {\n    const user = userEvent.setup()\n\n    renderCounterWithContext()\n\n    expect(await screen.findByText(/^1$/)).toBeInTheDocument()\n\n    await act(async () => {\n      await user.click(await screen.findByRole('button', { name: /one up/i }))\n    })\n\n    expect(await screen.findByText(/^2$/)).toBeInTheDocument()\n  })\n})\n\nconst renderCounterWithContext = () => {\n  return render(<CounterWithContext />)\n}\n```\n\n----------------------------------------\n\nTITLE: Store Without Action Types\nDESCRIPTION: Example showing a store implementation without action type names, leading to 'anonymous' actions in DevTools.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/devtools.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create, StateCreator } from 'zustand'\nimport { devtools } from 'zustand/middleware'\n\ntype BearSlice = {\n  bears: number\n  addBear: () => void\n}\n\ntype FishSlice = {\n  fishes: number\n  addFish: () => void\n}\n\ntype JungleStore = BearSlice & FishSlice\n\nconst createBearSlice: StateCreator<\n  JungleStore,\n  [['zustand/devtools', never]],\n  [],\n  BearSlice\n> = (set) => ({\n  bears: 0,\n  addBear: () => set((state) => ({ bears: state.bears + 1 })),\n  eatFish: () => set((state) => ({ fishes: state.fishes - 1 })),\n})\n\nconst createFishSlice: StateCreator<\n  JungleStore,\n  [['zustand/devtools', never]],\n  [],\n  FishSlice\n> = (set) => ({\n  fishes: 0,\n  addFish: () => set((state) => ({ fishes: state.fishes + 1 })),\n})\n\nconst useJungleStore = create<JungleStore>()(\n  devtools((...args) => ({\n    ...createBearSlice(...args),\n    ...createFishSlice(...args),\n  })),\n)\n```\n\n----------------------------------------\n\nTITLE: Enhanced Game Store with Turn Tracking\nDESCRIPTION: Extended Zustand store implementation that includes turn tracking with xIsNext state and corresponding setter function.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nconst useGameStore = create(\n  combine({ squares: Array(9).fill(null), xIsNext: true }, (set) => {\n    return {\n      setSquares: (nextSquares) => {\n        set((state) => ({\n          squares:\n            typeof nextSquares === 'function'\n              ? nextSquares(state.squares)\n              : nextSquares,\n        }))\n      },\n      setXIsNext: (nextXIsNext) => {\n        set((state) => ({\n          xIsNext:\n            typeof nextXIsNext === 'function'\n              ? nextXIsNext(state.xIsNext)\n              : nextXIsNext,\n        }))\n      },\n    }\n  }),\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Selector Generator for Vanilla Zustand Store\nDESCRIPTION: Implementation of createSelectors function specifically for vanilla Zustand stores (non-React). This utility works with the StoreApi interface and the useStore hook.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/auto-generating-selectors.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { StoreApi, useStore } from 'zustand'\n\ntype WithSelectors<S> = S extends { getState: () => infer T }\n  ? S & { use: { [K in keyof T]: () => T[K] } }\n  : never\n\nconst createSelectors = <S extends StoreApi<object>>(_store: S) => {\n  const store = _store as WithSelectors<typeof _store>\n  store.use = {}\n  for (const k of Object.keys(store.getState())) {\n    ;(store.use as any)[k] = () =>\n      useStore(_store, (s) => s[k as keyof typeof s])\n  }\n\n  return store\n}\n```\n\n----------------------------------------\n\nTITLE: Using Auto-Generated Selectors with a Vanilla Store in Zustand\nDESCRIPTION: Examples of how to use the auto-generated selectors with a vanilla Zustand store, accessing properties and actions directly.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/auto-generating-selectors.md#2025-04-22_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// get the property\nconst bears = useBearStore.use.bears()\n\n// get the action\nconst increment = useBearStore.use.increment()\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Hook for Accessing the Store\nDESCRIPTION: Defines a custom hook that encapsulates the context access logic and mimics the API of Zustand's create function. This hook accepts a selector function to extract specific parts of the store state.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/initialize-state-with-props.md#2025-04-22_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n// Mimic the hook returned by `create`\nimport { useContext } from 'react'\nimport { useStore } from 'zustand'\n\nfunction useBearContext<T>(selector: (state: BearState) => T): T {\n  const store = useContext(BearContext)\n  if (!store) throw new Error('Missing BearContext.Provider in the tree')\n  return useStore(store, selector)\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying StateCreator Type in Zustand TypeScript\nDESCRIPTION: Illustrates the changes in the 'StateCreator' type definition from Zustand v3 to v4.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v4.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n- type StateCreator\n-   < State\n-   , StoreSetState = StoreApi<State>[\"set\"]\n-   , StoreGetState = StoreApi<State>[\"get\"]\n-   , Store = StoreApi<State>\n-   > =\n-     ...\n+ type StateCreator\n+   < State\n+   , InMutators extends [StoreMutatorIdentifier, unknown][] = []\n+   , OutMutators extends [StoreMutatorIdentifier, unknown][] = []\n+   , Return = State\n+   > =\n+     ...\n```\n\n----------------------------------------\n\nTITLE: Initializing Game Store with Squares State\nDESCRIPTION: Creates a Zustand store for managing the game board state with an array of 9 squares. Includes a setSquares function to update the board state.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { create } from 'zustand'\nimport { combine } from 'zustand/middleware'\n\nconst useGameStore = create(\n  combine({ squares: Array(9).fill(null) }, (set) => {\n    return {\n      setSquares: (nextSquares) => {\n        set((state) => ({\n          squares:\n            typeof nextSquares === 'function'\n              ? nextSquares(state.squares)\n              : nextSquares,\n        }))\n      },\n    }\n  }),\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Store with Delayed Hydration\nDESCRIPTION: Configures a Zustand store with persistence and manual rehydration after a specified delay\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nconst positionStore = createStore<PositionStore>()(\n  persist(\n    (set) => ({\n      position: { x: 0, y: 0 },\n      setPosition: (position) => set({ position }),\n    }),\n    {\n      name: 'position-storage',\n      skipHydration: true,\n    },\n  ),\n)\n\nsetTimeout(() => {\n  positionStore.persist.rehydrate()\n}, 2000)\n```\n\n----------------------------------------\n\nTITLE: Zustand Store with Persistence Configuration\nDESCRIPTION: Example of creating a Zustand store with persistence middleware configuration\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/integrations/persisting-store-data.md#2025-04-22_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\nimport { persist } from 'zustand/middleware'\n\nexport const useBearStore = create(\n  persist(\n    (set, get) => ({\n      bears: 0,\n      addABear: () => set({ bears: get().bears + 1 }),\n    }),\n    {\n      name: 'food-storage',\n    },\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Enhancing the Custom Hook with Equality Function Support\nDESCRIPTION: Extends the custom hook to support custom equality functions for more efficient rerenders. It uses useStoreWithEqualityFn instead of useStore to allow specifying how selected state should be compared.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/initialize-state-with-props.md#2025-04-22_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\n// Allow custom equality function by using useStoreWithEqualityFn instead of useStore\nimport { useContext } from 'react'\nimport { useStoreWithEqualityFn } from 'zustand/traditional'\n\nfunction useBearContext<T>(\n  selector: (state: BearState) => T,\n  equalityFn?: (left: T, right: T) => boolean,\n): T {\n  const store = useContext(BearContext)\n  if (!store) throw new Error('Missing BearContext.Provider in the tree')\n  return useStoreWithEqualityFn(store, selector, equalityFn)\n}\n```\n\n----------------------------------------\n\nTITLE: React Tabs Component Implementation\nDESCRIPTION: Implements a tabbed interface with independent counters using the Zustand stores. Each tab maintains its own counter state through the store factory.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store-with-equality-fn.md#2025-04-22_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nconst [currentTabIndex, setCurrentTabIndex] = useState(0)\nconst counterState = useStoreWithEqualityFn(\n  getOrCreateCounterStoreByKey(`tab-${currentTabIndex}`),\n  (state) => state,\n  shallow,\n)\n\nreturn (\n  <div style={{ fontFamily: 'monospace' }}>\n    <div\n      style={{\n        display: 'flex',\n        gap: '0.5rem',\n        borderBottom: '1px solid salmon',\n        paddingBottom: 4,\n      }}\n    >\n      <button\n        type=\"button\"\n        style={{\n          border: '1px solid salmon',\n          backgroundColor: '#fff',\n          cursor: 'pointer',\n        }}\n        onClick={() => setCurrentTabIndex(0)}\n      >\n        Tab 1\n      </button>\n      <button\n        type=\"button\"\n        style={{\n          border: '1px solid salmon',\n          backgroundColor: '#fff',\n          cursor: 'pointer',\n        }}\n        onClick={() => setCurrentTabIndex(1)}\n      >\n        Tab 2\n      </button>\n      <button\n        type=\"button\"\n        style={{\n          border: '1px solid salmon',\n          backgroundColor: '#fff',\n          cursor: 'pointer',\n        }}\n        onClick={() => setCurrentTabIndex(2)}\n      >\n        Tab 3\n      </button>\n    </div>\n    <div style={{ padding: 4 }}>\n      Content of Tab {currentTabIndex + 1}\n      <br /> <br />\n      <button type=\"button\" onClick={() => counterState.increment()}>\n        Count: {counterState.count}\n      </button>\n    </div>\n  </div>\n)\n```\n\n----------------------------------------\n\nTITLE: App Component with Multiple Dot Instances\nDESCRIPTION: Demonstrates usage of multiple MovingDot components with independent states using separate PositionStoreProvider instances.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store.md#2025-04-22_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\nexport default function App() {\n  return (\n    <div style={{ display: 'flex' }}>\n      <PositionStoreProvider>\n        <MovingDot color=\"red\" />\n      </PositionStoreProvider>\n      <PositionStoreProvider>\n        <MovingDot color=\"blue\" />\n      </PositionStoreProvider>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying persist Middleware Signature in TypeScript\nDESCRIPTION: Illustrates the changes in the type signature of the 'persist' middleware from Zustand v3 to v4.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v4.md#2025-04-22_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n- persist:\n-   <T, U = Partial<T>>(...) => ...\n+ persist:\n+   <T, Mps, Mcs, U = T>(...) => ...\n```\n\n----------------------------------------\n\nTITLE: Modifying redux Middleware Signature in TypeScript\nDESCRIPTION: Shows the changes in the type signature of the 'redux' middleware from Zustand v3 to v4.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v4.md#2025-04-22_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\n- redux:\n-   <T, A>(...) => ...\n+ redux:\n+   <T, A, Mps, Mcs>(...) => ...\n```\n\n----------------------------------------\n\nTITLE: Using useShallow Hook for Shallow Equality in Zustand v5\nDESCRIPTION: This snippet shows an alternative approach to using shallow equality in Zustand v5 by utilizing the 'useShallow' hook. It demonstrates the import changes and how to apply the hook in a component.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v5.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// v5\nimport { create } from 'zustand'\nimport { useShallow } from 'zustand/shallow'\n\nconst useCountStore = create((set) => ({\n  count: 0,\n  text: 'hello',\n  // ...\n}))\n\nconst Component = () => {\n  const { count, text } = useCountStore(\n    useShallow((state) => ({\n      count: state.count,\n      text: state.text,\n    })),\n  )\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Counter Store Context Provider\nDESCRIPTION: Creates a React context provider for the counter store with TypeScript support and custom hooks for accessing store data.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/testing.md#2025-04-22_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { type ReactNode, createContext, useContext, useRef } from 'react'\nimport { createStore } from 'zustand'\nimport { useStoreWithEqualityFn } from 'zustand/traditional'\nimport { shallow } from 'zustand/shallow'\n\nimport {\n  type CounterStore,\n  counterStoreCreator,\n} from '../shared/counter-store-creator'\n\nexport const createCounterStore = () => {\n  return createStore<CounterStore>(counterStoreCreator)\n}\n\nexport type CounterStoreApi = ReturnType<typeof createCounterStore>\n\nexport const CounterStoreContext = createContext<CounterStoreApi | undefined>(\n  undefined,\n)\n\nexport interface CounterStoreProviderProps {\n  children: ReactNode\n}\n\nexport const CounterStoreProvider = ({\n  children,\n}: CounterStoreProviderProps) => {\n  const counterStoreRef = useRef<CounterStoreApi>(null)\n  if (!counterStoreRef.current) {\n    counterStoreRef.current = createCounterStore()\n  }\n\n  return (\n    <CounterStoreContext.Provider value={counterStoreRef.current}>\n      {children}\n    </CounterStoreContext.Provider>\n  )\n}\n\nexport type UseCounterStoreContextSelector<T> = (store: CounterStore) => T\n\nexport const useCounterStoreContext = <T,>(\n  selector: UseCounterStoreContextSelector<T>,\n): T => {\n  const counterStoreContext = useContext(CounterStoreContext)\n\n  if (counterStoreContext === undefined) {\n    throw new Error(\n      'useCounterStoreContext must be used within CounterStoreProvider',\n    )\n  }\n\n  return useStoreWithEqualityFn(counterStoreContext, selector, shallow)\n}\n```\n\n----------------------------------------\n\nTITLE: createStore TypeScript Signature\nDESCRIPTION: TypeScript signature for the createStore function, showing its type definition. This describes the function's parameters and return type for proper typing.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-store.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ncreateStore<T>()(stateCreatorFn: StateCreator<T, [], []>): StoreApi<T>\n```\n\n----------------------------------------\n\nTITLE: Basic Combine Middleware Usage in JavaScript\nDESCRIPTION: Shows the basic usage pattern of the combine middleware function that merges an initial state with additional state creator functions.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/combine.md#2025-04-22_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst nextStateCreatorFn = combine(initialState, additionalStateCreatorFn)\n```\n\n----------------------------------------\n\nTITLE: Disabling Merging Behavior in Zustand\nDESCRIPTION: This snippet demonstrates how to disable the default merging behavior in Zustand by using the 'replace' flag in the 'set' function.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/immutable-state-and-merging.md#2025-04-22_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nset((state) => newState, true)\n```\n\n----------------------------------------\n\nTITLE: Render Optimization with Redux\nDESCRIPTION: Shows how to implement render optimization in Redux using useSelector and useDispatch hooks. Demonstrates the standard Redux approach for components.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/getting-started/comparison.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'redux'\nimport { useSelector, useDispatch } from 'react-redux'\n\ntype State = {\n  count: number\n}\n\ntype Action = {\n  type: 'increment' | 'decrement'\n  qty: number\n}\n\nconst countReducer = (state: State, action: Action) => {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + action.qty }\n    case 'decrement':\n      return { count: state.count - action.qty }\n    default:\n      return state\n  }\n}\n\nconst countStore = createStore(countReducer)\n\nconst Component = () => {\n  const count = useSelector((state) => state.count)\n  const dispatch = useDispatch()\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Importing UseBoundStore Type in TypeScript\nDESCRIPTION: Displays the import statements for the 'UseBoundStore' type from Zustand and Zustand/react.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v4.md#2025-04-22_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { UseBoundStore } from 'zustand'\nimport type { UseBoundStore } from 'zustand/react'\n```\n\n----------------------------------------\n\nTITLE: Tabs Component Implementation - TSX\nDESCRIPTION: Implements a Tabs component that allows users to switch between different tabs, each maintaining its independent counter. It uses the `useCounterStore` hook to manage state.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store.md#2025-04-22_snippet_18\n\nLANGUAGE: tsx\nCODE:\n```\nfunction Tabs() {\n  const [currentTabIndex, setCurrentTabIndex] = useState(0)\n  const counterState = useCounterStore(\n    `tab-${currentTabIndex}`,\n    (state) => state,\n  )\n\n  return (\n    <div style={{ fontFamily: 'monospace' }}>\n      <div\n        style={{\n          display: 'flex',\n          gap: '0.5rem',\n          borderBottom: '1px solid salmon',\n          paddingBottom: 4,\n        }}\n      >\n        <button\n          type=\"button\"\n          style={{\n            border: '1px solid salmon',\n            backgroundColor: '#fff',\n            cursor: 'pointer',\n          }}\n          onClick={() => setCurrentTabIndex(0)}\n        >\n          Tab 1\n        </button>\n        <button\n          type=\"button\"\n          style={{\n            border: '1px solid salmon',\n            backgroundColor: '#fff',\n            cursor: 'pointer',\n          }}\n          onClick={() => setCurrentTabIndex(1)}\n        >\n          Tab 2\n        </button>\n        <button\n          type=\"button\"\n          style={{\n            border: '1px solid salmon',\n            backgroundColor: '#fff',\n            cursor: 'pointer',\n          }}\n          onClick={() => setCurrentTabIndex(2)}\n        >\n          Tab 3\n        </button>\n      </div>\n      <div style={{ padding: 4 }}>\n        Content of Tab {currentTabIndex + 1}\n        <br /> <br />\n        <button type=\"button\" onClick={() => counterState.increment()}>\n          Count: {counterState.count}\n        </button>\n      </div>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Infinite Loops with useShallow in Zustand v5\nDESCRIPTION: This snippet demonstrates how to fix potential infinite loops caused by unstable selector outputs in Zustand v5. It shows the use of the 'useShallow' hook to ensure stable references when selecting multiple values from the store.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v5.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// v5\nimport { useShallow } from 'zustand/shallow'\n\nconst [searchValue, setSearchValue] = useStore(\n  useShallow((state) => [state.searchValue, state.setSearchValue]),\n)\n```\n\n----------------------------------------\n\nTITLE: useStore Type Signature in TypeScript\nDESCRIPTION: TypeScript type definition for the useStore hook, specifying the function signature including store API and optional selector function parameters.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nuseStore<StoreApi<T>, U = T>(store: StoreApi<T>, selectorFn?: (state: T) => U) => UseBoundStore<StoreApi<T>>\n```\n\n----------------------------------------\n\nTITLE: Explicit State Merging in Zustand\nDESCRIPTION: This snippet shows how to explicitly merge state in Zustand using the spread operator. However, this is not necessary for top-level properties due to Zustand's built-in merging behavior.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/immutable-state-and-merging.md#2025-04-22_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nset((state) => ({ ...state, count: state.count + 1 }))\n```\n\n----------------------------------------\n\nTITLE: Assembling App Component with Counter Stores Provider in React\nDESCRIPTION: This snippet creates the main App component that wraps the Tabs component with the CounterStoresProvider. This setup allows for independent counter state management for each tab.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store-with-equality-fn.md#2025-04-22_snippet_19\n\nLANGUAGE: tsx\nCODE:\n```\nexport default function App() {\n  return (\n    <CounterStoresProvider>\n      <Tabs />\n    </CounterStoresProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing URL Search Parameter Storage in TypeScript\nDESCRIPTION: Functions to manipulate URL search parameters for state storage, including getting, setting, and removing parameters\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst getSearchParams = () => {\n  return new URL(location.href).searchParams\n}\n\nconst updateSearchParams = (searchParams: URLSearchParams) => {\n  window.history.replaceState(\n    {},\n    '',\n    `${location.pathname}?${searchParams.toString()}`,\n  )\n}\n\nconst getSearchParam = (key: string) => {\n  const searchParams = getSearchParams()\n  return searchParams.get(key)\n}\n\nconst updateSearchParam = (key: string, value: string) => {\n  const searchParams = getSearchParams()\n  searchParams.set(key, value)\n\n  updateSearchParams(searchParams)\n}\n\nconst removeSearchParam = (key: string) => {\n  const searchParams = getSearchParams()\n  searchParams.delete(key)\n\n  updateSearchParams(searchParams)\n}\n```\n\n----------------------------------------\n\nTITLE: Importing UseContextStore Type in TypeScript\nDESCRIPTION: Shows the import statement for the 'UseContextStore' type from Zustand/context.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v4.md#2025-04-22_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { UseContextStore } from 'zustand/context'\n```\n\n----------------------------------------\n\nTITLE: Implementing Jump To Previous Game State in Tic-Tac-Toe\nDESCRIPTION: Implementation of the jumpTo function that allows players to navigate to previous game states. Updates the current move state and sets the correct player's turn based on the move number.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_27\n\nLANGUAGE: javascript\nCODE:\n```\nfunction jumpTo(nextMove) {\n  setCurrentMove(nextMove)\n  setXIsNext(currentMove % 2 === 0)\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Game Status for Tic-Tac-Toe using JavaScript\nDESCRIPTION: This function generates the current status of the Tic-Tac-Toe game based on the game's winner, number of remaining turns, and the current player. It returns a string message indicating whether the game is a draw, a win, or which player's turn is next.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nfunction calculateStatus(winner, turns, player) {\n  if (!winner && !turns) return 'Draw'\n  if (winner) return `Winner ${winner}`\n  return `Next player: ${player}`\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Winner in Tic-Tac-Toe Game using JavaScript\nDESCRIPTION: This function evaluates an array representing Tic-Tac-Toe squares and returns the winning player ('X' or 'O'), or null if no winner exists. It checks all possible winning combinations based on the current game state.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nfunction calculateWinner(squares) {\n  const lines = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [2, 4, 6],\n  ]\n\n  for (let i = 0; i < lines.length; i++) {\n    const [a, b, c] = lines[i]\n    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\n      return squares[a]\n    }\n  }\n\n  return null\n}\n```\n\n----------------------------------------\n\nTITLE: Hypothetical Custom Middleware Implementation\nDESCRIPTION: Example of a custom middleware that mutates the store by adding a foo property. This demonstrates the challenge of typing store mutations.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\n\nconst foo = (f, bar) => (set, get, store) => {\n  store.foo = bar\n  return f(set, get, store)\n}\n\nconst useBearStore = create(foo(() => ({ bears: 0 }), 'hello'))\nconsole.log(useBearStore.foo.toUpperCase())\n```\n\n----------------------------------------\n\nTITLE: External State Updates with Zustand\nDESCRIPTION: Demonstrates how to update Zustand state externally without store actions. Uses a MovingDot component that randomly repositions on mouse enter.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-with-equality-fn.md#2025-04-22_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createWithEqualityFn } from 'zustand/traditional'\nimport { shallow } from 'zustand/vanilla/shallow'\n\nconst usePositionStore = createWithEqualityFn<{\n  x: number\n  y: number\n}>()(() => ({ x: 0, y: 0 }), shallow)\n\nconst setPosition: typeof usePositionStore.setState = (nextPosition) => {\n  usePositionStore.setState(nextPosition)\n}\n\nexport default function MovingDot() {\n  const position = usePositionStore()\n\n  return (\n    <div\n      style={{\n        position: 'relative',\n        width: '100vw',\n        height: '100vh',\n      }}\n    >\n      <div\n        style={{\n          position: 'absolute',\n          backgroundColor: 'red',\n          borderRadius: '50%',\n          transform: `translate(${position.x}px, ${position.y}px)`,\n          left: -10,\n          top: -10,\n          width: 20,\n          height: 20,\n        }}\n        onMouseEnter={(event) => {\n          const parent = event.currentTarget.parentElement\n          const parentWidth = parent.clientWidth\n          const parentHeight = parent.clientHeight\n\n          setPosition({\n            x: Math.ceil(Math.random() * parentWidth),\n            y: Math.ceil(Math.random() * parentHeight),\n          })\n        }}\n      />\n    </div>\n  )\n```\n\n----------------------------------------\n\nTITLE: useStore Basic Syntax with Zustand\nDESCRIPTION: Basic syntax for the useStore hook in Zustand that allows you to use vanilla stores in React components.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst someState = useStore(store, selectorFn)\n```\n\n----------------------------------------\n\nTITLE: Building and Running the SSR Application\nDESCRIPTION: Commands to compile the TypeScript code and start the server for the SSR application.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/ssr-and-hydration.md#2025-04-22_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ntsc --build\n```\n\nLANGUAGE: sh\nCODE:\n```\nnode server.js\n```\n\n----------------------------------------\n\nTITLE: Complete Position Tracker with State Persistence\nDESCRIPTION: Full implementation of a position tracker using Zustand's vanilla store with persist middleware, including event handling and UI updates.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'zustand/vanilla'\nimport { persist } from 'zustand/middleware'\n\ntype PositionStoreState = { position: { x: number; y: number } }\n\ntype PositionStoreActions = {\n  setPosition: (nextPosition: PositionStoreState['position']) => void\n}\n\ntype PositionStore = PositionStoreState & PositionStoreActions\n\nconst positionStore = createStore<PositionStore>()(\n  persist(\n    (set) => ({\n      position: { x: 0, y: 0 },\n      setPosition: (position) => set({ position }),\n    }),\n    { name: 'position-storage' },\n  ),\n)\n\nconst $dotContainer = document.getElementById('dot-container') as HTMLDivElement\nconst $dot = document.getElementById('dot') as HTMLDivElement\n\n$dotContainer.addEventListener('pointermove', (event) => {\n  positionStore.getState().setPosition({\n    x: event.clientX,\n    y: event.clientY,\n  })\n})\n\nconst render: Parameters<typeof positionStore.subscribe>[0] = (state) => {\n  $dot.style.transform = `translate(${state.position.x}px, ${state.position.y}px)`\n}\n\nrender(positionStore.getState(), positionStore.getState())\n\npositionStore.subscribe(render)\n```\n\n----------------------------------------\n\nTITLE: Atomic Model in Jotai\nDESCRIPTION: Shows Jotai's approach using primitive atoms that can be composed together. Demonstrates creating a basic counter atom.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/getting-started/comparison.md#2025-04-22_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from 'jotai'\n\nconst countAtom = atom<number>(0)\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Hook\nDESCRIPTION: Creates a custom React hook `usePositionStore` for accessing the Zustand store. The hook retrieves the store from the React context and allows selecting specific parts of the state using a selector function. It throws an error if used outside of the `PositionStoreProvider`.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store-with-equality-fn.md#2025-04-22_snippet_11\n\nLANGUAGE: ts\nCODE:\n```\nfunction usePositionStore<U>(selector: (state: PositionStore) => U) {\n  const store = useContext(PositionStoreContext)\n\n  if (store === null) {\n    throw new Error(\n      'usePositionStore must be used within PositionStoreProvider',\n    )\n  }\n\n  return useStoreWithEqualityFn(store, selector, shallow)\n}\n```\n\n----------------------------------------\n\nTITLE: Traditional Immutable Updates in Zustand Without immer\nDESCRIPTION: Example of a Zustand store using traditional immutable updates with object spread syntax. This approach requires manual copying of nested objects for updates.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/immer.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'zustand/vanilla'\n\ntype PersonStoreState = {\n  person: { firstName: string; lastName: string; email: string }\n}\n\ntype PersonStoreActions = {\n  setPerson: (\n    nextPerson: (\n      person: PersonStoreState['person'],\n    ) => PersonStoreState['person'] | PersonStoreState['person'],\n  ) => void\n}\n\ntype PersonStore = PersonStoreState & PersonStoreActions\n\nconst personStore = createStore<PersonStore>()((set) => ({\n  person: {\n    firstName: 'Barbara',\n    lastName: 'Hepworth',\n    email: 'bhepworth@sculpture.com',\n  },\n  setPerson: (nextPerson) =>\n    set((state) => ({\n      person:\n        typeof nextPerson === 'function'\n          ? nextPerson(state.person)\n          : nextPerson,\n    })),\n}))\n\nconst $firstNameInput = document.getElementById(\n  'first-name',\n) as HTMLInputElement\nconst $lastNameInput = document.getElementById('last-name') as HTMLInputElement\nconst $emailInput = document.getElementById('email') as HTMLInputElement\nconst $result = document.getElementById('result') as HTMLDivElement\n\nfunction handleFirstNameChange(event: Event) {\n  personStore.getState().setPerson((person) => ({\n    ...person,\n    firstName: (event.target as any).value,\n  }))\n}\n\nfunction handleLastNameChange(event: Event) {\n  personStore.getState().setPerson((person) => ({\n    ...person,\n    lastName: (event.target as any).value,\n  }))\n}\n\nfunction handleEmailChange(event: Event) {\n  personStore.getState().setPerson((person) => ({\n    ...person,\n    email: (event.target as any).value,\n  }))\n}\n\n$firstNameInput.addEventListener('input', handleFirstNameChange)\n$lastNameInput.addEventListener('input', handleLastNameChange)\n$emailInput.addEventListener('input', handleEmailChange)\n\nconst render: Parameters<typeof personStore.subscribe>[0] = (state) => {\n  $firstNameInput.value = state.person.firstName\n  $lastNameInput.value = state.person.lastName\n  $emailInput.value = state.person.email\n\n  $result.innerHTML = `${state.person.firstName} ${state.person.lastName} (${state.person.email})`\n}\n\nrender(personStore.getInitialState(), personStore.getInitialState())\n\npersonStore.subscribe(render)\n```\n\n----------------------------------------\n\nTITLE: Updating Deeply Nested State with Ramda\nDESCRIPTION: Shows how to use Ramda's functional utilities to update deeply nested state in Zustand.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/updating-state.md#2025-04-22_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\n  ramdaInc: () =>\n    set(R.modifyPath([\"deep\", \"nested\", \"obj\", \"count\"], (c) => c + 1)),\n```\n\n----------------------------------------\n\nTITLE: Mouse Movement Event Handling and Store Update\nDESCRIPTION: Tracks mouse movements within a container and updates the Zustand store with current x and y coordinates\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n$dotContainer.addEventListener('pointermove', (event) => {\n  positionStore.getState().setPosition({\n    x: event.clientX,\n    y: event.clientY,\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Complete Position Tracker with Partial State Persistence\nDESCRIPTION: Full implementation of a position tracker using partial state persistence, which only persists the context part of the state.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'zustand/vanilla'\nimport { persist } from 'zustand/middleware'\n\ntype PositionStoreState = {\n  context: {\n    position: { x: number; y: number }\n  }\n}\n\ntype PositionStoreActions = {\n  actions: {\n    setPosition: (\n      nextPosition: PositionStoreState['context']['position'],\n    ) => void\n  }\n}\n\ntype PositionStore = PositionStoreState & PositionStoreActions\n\nconst positionStore = createStore<PositionStore>()(\n  persist(\n    (set) => ({\n      context: {\n        position: { x: 0, y: 0 },\n      },\n      actions: {\n        setPosition: (position) => set({ context: { position } }),\n      },\n    }),\n    {\n      name: 'position-storage',\n      partialize: (state) => ({ context: state.context }),\n    },\n  ),\n)\n\nconst $dotContainer = document.getElementById('dot-container') as HTMLDivElement\nconst $dot = document.getElementById('dot') as HTMLDivElement\n\n$dotContainer.addEventListener('pointermove', (event) => {\n  positionStore.getState().actions.setPosition({\n    x: event.clientX,\n    y: event.clientY,\n  })\n})\n\nconst render: Parameters<typeof positionStore.subscribe>[0] = (state) => {\n  $dot.style.transform = `translate(${state.context.position.x}px, ${state.context.position.y}px)`\n}\n\nrender(positionStore.getState(), positionStore.getState())\n\npositionStore.subscribe(render)\n```\n\n----------------------------------------\n\nTITLE: Comparing Objects with Shallow and Object.is\nDESCRIPTION: Shows how shallow and Object.is differ when comparing objects with identical properties. Object.is compares references while shallow compares top-level property values.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/shallow.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst objectLeft = {\n  firstName: 'John',\n  lastName: 'Doe',\n  age: 30,\n}\nconst objectRight = {\n  firstName: 'John',\n  lastName: 'Doe',\n  age: 30,\n}\n\nObject.is(objectLeft, objectRight) // -> false\nshallow(objectLeft, objectRight) // -> true\n```\n\n----------------------------------------\n\nTITLE: Comparing Sets with Shallow and Object.is\nDESCRIPTION: Demonstrates how shallow and Object.is behave when comparing Sets with the same elements. Shallow recognizes the equality of Sets with identical elements.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/shallow.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst setLeft = new Set([1, 2, 3])\nconst setRight = new Set([1, 2, 3])\n\nObject.is(setLeft, setRight) // -> false\nshallow(setLeft, setRight) // -> true\n```\n\n----------------------------------------\n\nTITLE: Handling Dynamic Replace Flag with Zustand setState\nDESCRIPTION: Workaround for handling dynamic replace flags with Zustand's setState function using TypeScript's Parameters utility type to ensure type safety.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md#2025-04-22_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\n\ninterface BearState {\n  bears: number\n  increase: (by: number) => void\n}\n\nconst useBearStore = create<BearState>()((set) => ({\n  bears: 0,\n  increase: (by) => set((state) => ({ bears: state.bears + by })),\n}))\n\nconst replaceFlag = Math.random() > 0.5\nconst args = [{ bears: 5 }, replaceFlag] as Parameters<\n  typeof useBearStore.setState\n>\nuseBearStore.setState(...args) // Using the workaround\n```\n\n----------------------------------------\n\nTITLE: Creating a Factory for Counter Stores - TypeScript\nDESCRIPTION: Implements a factory function to manage counter stores for various tabs. This function ensures each tab has its own instance of the counter store by utilizing a Map.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store.md#2025-04-22_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst createCounterStoreFactory = (\n  counterStores: Map<string, ReturnType<typeof createCounterStore>>, \n) => {\n  return (counterStoreKey: string) => {\n    if (!counterStores.has(counterStoreKey)) {\n      counterStores.set(counterStoreKey, createCounterStore())\n    }\n    return counterStores.get(counterStoreKey)!\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Component Implementation\nDESCRIPTION: Simple React component showing basic state selection without optimization.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-shallow.md#2025-04-22_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nfunction BearNames() {\n  const names = useBearFamilyMealsStore((state) => Object.keys(state))\n\n  return <div>{names.join(', ')}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Zustand Store in TypeScript\nDESCRIPTION: This snippet initializes a Zustand store to manage the state of a person object with fields for first name, last name, and email. The store provides a method for updating the person’s data while maintaining the existing state for other fields.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-store.md#2025-04-22_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'zustand/vanilla'\n\ntype PersonStoreState = {\n  person: { firstName: string; lastName: string; email: string }\n}\n\ntype PersonStoreActions = {\n  setPerson: (nextPerson: PersonStoreState['person']) => void\n}\n\ntype PersonStore = PersonStoreState & PersonStoreActions\n\nconst personStore = createStore<PersonStore>()((set) => ({\n  person: {\n    firstName: 'Barbara',\n    lastName: 'Hepworth',\n    email: 'bhepworth@sculpture.com',\n  },\n  setPerson: (person) => set({ person }),\n}))\n\nconst $firstNameInput = document.getElementById(\n  'first-name',\n) as HTMLInputElement\nconst $lastNameInput = document.getElementById('last-name') as HTMLInputElement\nconst $emailInput = document.getElementById('email') as HTMLInputElement\nconst $result = document.getElementById('result') as HTMLDivElement\n```\n\n----------------------------------------\n\nTITLE: App Component with MovingDot\nDESCRIPTION: Simple App component that renders the MovingDot component, which uses the Zustand position store.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store.md#2025-04-22_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nexport default function App() {\n  return <MovingDot />\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Zustand Store to Track Game History\nDESCRIPTION: Enhances the Zustand store to track game history by adding a history state that contains arrays of squares for each move. Implements a setHistory function to update the history state.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_16\n\nLANGUAGE: js\nCODE:\n```\nconst useGameStore = create(\n  combine({ history: [Array(9).fill(null)], xIsNext: true }, (set) => {\n    return {\n      setHistory: (nextHistory) => {\n        set((state) => ({\n          history:\n            typeof nextHistory === 'function'\n              ? nextHistory(state.history)\n              : nextHistory,\n        }))\n      },\n      setXIsNext: (nextXIsNext) => {\n        set((state) => ({\n          xIsNext:\n            typeof nextXIsNext === 'function'\n              ? nextXIsNext(state.xIsNext)\n              : nextXIsNext,\n        }))\n      },\n    }\n  }),\n)\n```\n\n----------------------------------------\n\nTITLE: Updating State in Zustand Store\nDESCRIPTION: Updates the state of the Zustand store by changing the meal for papaBear, which will cause a rerender in components subscribed to the state.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/prevent-rerenders-with-use-shallow.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nuseMeals.setState({\n  papaBear: 'a large pizza',\n})\n```\n\n----------------------------------------\n\nTITLE: Basic Store Creation Example\nDESCRIPTION: Implementation of a basic Zustand store for managing bear family meals.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-shallow.md#2025-04-22_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { create } from 'zustand'\n\ntype BearFamilyMealsStore = {\n  [key: string]: string\n}\n\nconst useBearFamilyMealsStore = create<BearFamilyMealsStore>()(() => ({\n  papaBear: 'large porridge-pot',\n  mamaBear: 'middle-size porridge pot',\n  babyBear: 'A little, small, wee pot',\n}))\n```\n\n----------------------------------------\n\nTITLE: Incorrect Form State Management Example\nDESCRIPTION: Demonstrates incorrect form state management by directly mutating state values. This anti-pattern shows what not to do when handling form inputs with Zustand.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create.md#2025-04-22_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { create } from 'zustand'\n\ntype PersonStoreState = {\n  firstName: string\n  lastName: string\n  email: string\n}\n\ntype PersonStoreActions = {\n  setPerson: (nextPerson: Partial<PersonStoreState>) => void\n}\n\ntype PersonStore = PersonStoreState & PersonStoreActions\n\nconst usePersonStore = create<PersonStore>()((set) => ({\n  firstName: 'Barbara',\n  lastName: 'Hepworth',\n  email: 'bhepworth@sculpture.com',\n  setPerson: (nextPerson) => set(nextPerson),\n}))\n\nexport default function Form() {\n  const person = usePersonStore((state) => state)\n  const setPerson = usePersonStore((state) => state.setPerson)\n\n  function handleFirstNameChange(e: ChangeEvent<HTMLInputElement>) {\n    person.firstName = e.target.value\n  }\n\n  function handleLastNameChange(e: ChangeEvent<HTMLInputElement>) {\n    person.lastName = e.target.value\n  }\n\n  function handleEmailChange(e: ChangeEvent<HTMLInputElement>) {\n    person.email = e.target.value\n  }\n\n  return (\n    <>\n      <label style={{ display: 'block' }}>\n        First name:\n        <input value={person.firstName} onChange={handleFirstNameChange} />\n      </label>\n      <label style={{ display: 'block' }}>\n        Last name:\n        <input value={person.lastName} onChange={handleLastNameChange} />\n      </label>\n      <label style={{ display: 'block' }}>\n        Email:\n        <input value={person.email} onChange={handleEmailChange} />\n      </label>\n      <p>\n        {person.firstName} {person.lastName} ({person.email})\n      </p>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Game History in Game Component\nDESCRIPTION: Updates the Game component to access history from the Zustand store and calculate the current squares to display. This prepares for implementing time travel functionality where players can review previous game states.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_17\n\nLANGUAGE: jsx\nCODE:\n```\nexport default function Game() {\n  const history = useGameStore((state) => state.history)\n  const setHistory = useGameStore((state) => state.setHistory)\n  const xIsNext = useGameStore((state) => state.xIsNext)\n  const setXIsNext = useGameStore((state) => state.setXIsNext)\n  const currentSquares = history[history.length - 1]\n\n  return (\n    <div\n      style={{\n        display: 'flex',\n        flexDirection: 'row',\n        fontFamily: 'monospace',\n      }}\n    >\n      <div>\n        <Board />\n      </div>\n      <div style={{ marginLeft: '1rem' }}>\n        <ol>{/*TODO*/}</ol>\n      </div>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Persist Middleware Behavior in Zustand v5\nDESCRIPTION: This snippet illustrates the change in persist middleware behavior in Zustand v5. It shows how to explicitly set the initial state after store creation, as the middleware no longer automatically stores the initial state during creation.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v5.md#2025-04-22_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// v5\nimport { create } from 'zustand'\nimport { persist } from 'zustand/middleware'\n\nconst useCountStore = create(\n  persist(\n    () => ({\n      count: 0,\n    }),\n    {\n      name: 'count',\n    },\n  ),\n)\nuseCountStore.setState({\n  count: Math.floor(Math.random() * 1000),\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Custom JSON Storage in Zustand\nDESCRIPTION: Demonstrates how to create a custom JSON storage implementation with serialization options for dates using createJSONStorage helper\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/integrations/persisting-store-data.md#2025-04-22_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createJSONStorage } from 'zustand/middleware'\n\nconst storage = createJSONStorage(() => sessionStorage, {\n  reviver: (key, value) => {\n    if (value && value.type === 'date') {\n      return new Date(value)\n    }\n    return value\n  },\n  replacer: (key, value) => {\n    if (value instanceof Date) {\n      return { type: 'date', value: value.toISOString() }\n    }\n    return value\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Applying Selectors to a Vanilla Store in Zustand\nDESCRIPTION: Code to apply the createSelectors function to a vanilla Zustand store, enhancing it with auto-generated selectors.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/auto-generating-selectors.md#2025-04-22_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst useBearStore = createSelectors(store)\n```\n\n----------------------------------------\n\nTITLE: Creating a Store with Redux\nDESCRIPTION: Example of creating a counter store using classic Redux with createStore. Shows the traditional Redux approach with a reducer function and action types.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/getting-started/comparison.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'redux'\nimport { useSelector, useDispatch } from 'react-redux'\n\ntype State = {\n  count: number\n}\n\ntype Action = {\n  type: 'increment' | 'decrement'\n  qty: number\n}\n\nconst countReducer = (state: State, action: Action) => {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + action.qty }\n    case 'decrement':\n      return { count: state.count - action.qty }\n    default:\n      return state\n  }\n}\n\nconst countStore = createStore(countReducer)\n```\n\n----------------------------------------\n\nTITLE: Event Handling for Position Tracking\nDESCRIPTION: Code to track mouse movements within a container and update the persisted store with new position data.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst $dotContainer = document.getElementById('dot-container') as HTMLDivElement\nconst $dot = document.getElementById('dot') as HTMLDivElement\n\n$dotContainer.addEventListener('pointermove', (event) => {\n  positionStore.getState().setPosition({\n    x: event.clientX,\n    y: event.clientY,\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Array State Updates Example\nDESCRIPTION: Demonstrates how to handle array state updates while maintaining immutability using complete state replacement.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-with-equality-fn.md#2025-04-22_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createWithEqualityFn } from 'zustand/traditional'\nimport { shallow } from 'zustand/vanilla/shallow'\n\ntype PositionStore = [number, number]\n\nconst usePositionStore = createWithEqualityFn<PositionStore>()(\n  () => [0, 0],\n  shallow,\n)\n\nexport default function MovingDot() {\n  const [x, y] = usePositionStore()\n  const position = { x, y }\n  const setPosition: typeof usePositionStore.setState = (nextPosition) => {\n    usePositionStore.setState(nextPosition, true)\n  }\n\n  return (\n    <div\n      onPointerMove={(e) => {\n        setPosition([e.clientX, e.clientY])\n      }}\n      style={{\n        position: 'relative',\n        width: '100vw',\n        height: '100vh',\n      }}\n    >\n      <div\n        style={{\n          position: 'absolute',\n          backgroundColor: 'red',\n          borderRadius: '50%',\n          transform: `translate(${position.x}px, ${position.y}px)`,\n          left: -10,\n          top: -10,\n          width: 20,\n          height: 20,\n        }}\n      />\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Redux Middleware Integration\nDESCRIPTION: Shows how to use Redux middleware with Zustand for traditional Redux functionality\nSOURCE: https://github.com/pmndrs/zustand/blob/main/README.md#2025-04-22_snippet_16\n\nLANGUAGE: jsx\nCODE:\n```\nimport { redux } from 'zustand/middleware'\n\nconst useGrumpyStore = create(redux(reducer, initialState))\n```\n\n----------------------------------------\n\nTITLE: MovingDot Component Implementation\nDESCRIPTION: Implements a component that renders a colored dot following mouse movement. Uses the position store to track and update coordinates.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store.md#2025-04-22_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nfunction MovingDot({ color }: { color: string }) {\n  const position = usePositionStore((state) => state.position)\n  const setPosition = usePositionStore((state) => state.setPosition)\n\n  return (\n    <div\n      onPointerMove={(e) => {\n        setPosition({\n          x:\n            e.clientX > e.currentTarget.clientWidth\n              ? e.clientX - e.currentTarget.clientWidth\n              : e.clientX,\n          y: e.clientY,\n        })\n      }}\n      style={{\n        position: 'relative',\n        width: '50vw',\n        height: '100vh',\n      }}\n    >\n      <div\n        style={{\n          position: 'absolute',\n          backgroundColor: color,\n          borderRadius: '50%',\n          transform: `translate(${position.x}px, ${position.y}px)`,\n          left: -10,\n          top: -10,\n          width: 20,\n          height: 20,\n        }}\n      />\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Reusable Provider Wrapper Component\nDESCRIPTION: Implements a dedicated provider component that accepts initial props for the store. It lazily initializes the store once using useRef and passes it down through context to child components.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/initialize-state-with-props.md#2025-04-22_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n// Provider wrapper\nimport { useRef } from 'react'\n\ntype BearProviderProps = React.PropsWithChildren<BearProps>\n\nfunction BearProvider({ children, ...props }: BearProviderProps) {\n  const storeRef = useRef<BearStore>()\n  if (!storeRef.current) {\n    storeRef.current = createBearStore(props)\n  }\n  return (\n    <BearContext.Provider value={storeRef.current}>\n      {children}\n    </BearContext.Provider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect State Mutation in Zustand\nDESCRIPTION: Example of incorrect state mutation in a form component that directly modifies state objects instead of creating new ones.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-with-equality-fn.md#2025-04-22_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createWithEqualityFn } from 'zustand/traditional'\nimport { shallow } from 'zustand/vanilla/shallow'\n\ntype PersonStoreState = {\n  person: { firstName: string; lastName: string; email: string }\n}\n\ntype PersonStoreActions = {\n  setPerson: (nextPerson: PersonStoreState['person']) => void\n}\n\ntype PersonStore = PersonStoreState & PersonStoreActions\n\nconst usePersonStore = createWithEqualityFn<PersonStore>()(\n  (set) => ({\n    person: {\n      firstName: 'Barbara',\n      lastName: 'Hepworth',\n      email: 'bhepworth@sculpture.com',\n    },\n    setPerson: (person) => set({ person }),\n  }),\n  shallow,\n)\n\nexport default function Form() {\n  const person = usePersonStore((state) => state.person)\n  const setPerson = usePersonStore((state) => state.setPerson)\n\n  function handleFirstNameChange(e: ChangeEvent<HTMLInputElement>) {\n    person.firstName = e.target.value\n  }\n\n  function handleLastNameChange(e: ChangeEvent<HTMLInputElement>) {\n    person.lastName = e.target.value\n  }\n\n  function handleEmailChange(e: ChangeEvent<HTMLInputElement>) {\n    person.email = e.target.value\n  }\n\n  return (\n    <>\n      <label style={{ display: 'block' }}>\n        First name:\n        <input value={person.firstName} onChange={handleFirstNameChange} />\n      </label>\n      <label style={{ display: 'block' }}>\n        Last name:\n        <input value={person.lastName} onChange={handleLastNameChange} />\n      </label>\n      <label style={{ display: 'block' }}>\n        Email:\n        <input value={person.email} onChange={handleEmailChange} />\n      </label>\n      <p>\n        {person.firstName} {person.lastName} ({person.email})\n      </p>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Position Rendering Logic\nDESCRIPTION: Implementation of render function to update DOM based on position state changes\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst render: Parameters<typeof positionStore.subscribe>[0] = (state) => {\n  $dot.style.transform = `translate(${state.position.x}px, ${state.position.y}px)`\n}\n\nrender(positionStore.getState(), positionStore.getState())\n\npositionStore.subscribe(render)\n```\n\n----------------------------------------\n\nTITLE: Creating a Store with Redux Toolkit\nDESCRIPTION: Shows how to create a counter store using Redux Toolkit with createSlice and configureStore. Demonstrates the simplified Redux approach with reducer functions.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/getting-started/comparison.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSlice, configureStore } from '@reduxjs/toolkit'\n\nconst countSlice = createSlice({\n  name: 'count',\n  initialState: { value: 0 },\n  reducers: {\n    incremented: (state, qty: number) => {\n      // Redux Toolkit does not mutate the state, it uses the Immer library\n      // behind scenes, allowing us to have something called \"draft state\".\n      state.value += qty\n    },\n    decremented: (state, qty: number) => {\n      state.value -= qty\n    },\n  },\n})\n\nconst countStore = configureStore({ reducer: countSlice.reducer })\n```\n\n----------------------------------------\n\nTITLE: Configuring Root Layout with Store Provider\nDESCRIPTION: Root layout configuration for Next.js app with Zustand store provider wrapper and metadata setup.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/nextjs.md#2025-04-22_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { Metadata } from 'next'\nimport { Inter } from 'next/font/google'\nimport './globals.css'\n\nimport { CounterStoreProvider } from '@/providers/counter-store-provider'\n\nconst inter = Inter({ subsets: ['latin'] })\n\nexport const metadata: Metadata = {\n  title: 'Create Next App',\n  description: 'Generated by create next app',\n}\n\nexport default function RootLayout({\n  children,\n}: Readonly<{\n  children: React.ReactNode\n}>) {\n  return (\n    <html lang=\"en\">\n      <body className={inter.className}>\n        <CounterStoreProvider>{children}</CounterStoreProvider>\n      </body>\n    </html>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Board Component with Click Handler\nDESCRIPTION: Board component implementation with click handling logic for placing X's on the game board. Includes square rendering and state updates.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nexport default function Board() {\n  const squares = useGameStore((state) => state.squares)\n  const setSquares = useGameStore((state) => state.setSquares)\n\n  function handleClick(i) {\n    if (squares[i]) return\n    const nextSquares = squares.slice()\n    nextSquares[i] = 'X'\n    setSquares(nextSquares)\n  }\n\n  return (\n    <div\n      style={{\n        display: 'grid',\n        gridTemplateColumns: 'repeat(3, 1fr)',\n        gridTemplateRows: 'repeat(3, 1fr)',\n        width: 'calc(3 * 2.5rem)',\n        height: 'calc(3 * 2.5rem)',\n        border: '1px solid #999',\n      }}\n    >\n      {squares.map((square, squareIndex) => (\n        <Square\n          key={squareIndex}\n          value={square}\n          onSquareClick={() => handleClick(squareIndex)}\n        />\n      ))}\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Primitive Values in State\nDESCRIPTION: Example showing how to update primitive values in store state. It demonstrates directly assigning new values and using the replace parameter for state replacement.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-store.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'zustand/vanilla'\n\ntype XStore = number\n\nconst xStore = createStore<XStore>()(() => 0)\n\nconst $dotContainer = document.getElementById('dot-container') as HTMLDivElement\nconst $dot = document.getElementById('dot') as HTMLDivElement\n\n$dotContainer.addEventListener('pointermove', (event) => {\n  xStore.setState(event.clientX, true)\n})\n\nconst render: Parameters<typeof xStore.subscribe>[0] = (x) => {\n  $dot.style.transform = `translate(${x}px, 0)`\n}\n\nrender(xStore.getInitialState(), xStore.getInitialState())\n\nxStore.subscribe(render)\n```\n\n----------------------------------------\n\nTITLE: Comparing Primitive Values with Shallow and Object.is\nDESCRIPTION: Demonstrates how both shallow and Object.is behave identically when comparing primitive values like strings, numbers, booleans, and BigInts.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/shallow.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringLeft = 'John Doe'\nconst stringRight = 'John Doe'\n\nObject.is(stringLeft, stringRight) // -> true\nshallow(stringLeft, stringRight) // -> true\n\nconst numberLeft = 10\nconst numberRight = 10\n\nObject.is(numberLeft, numberRight) // -> true\nshallow(numberLeft, numberRight) // -> true\n\nconst booleanLeft = true\nconst booleanRight = true\n\nObject.is(booleanLeft, booleanRight) // -> true\nshallow(booleanLeft, booleanRight) // -> true\n\nconst bigIntLeft = 1n\nconst bigIntRight = 1n\n\nObject.is(bigIntLeft, bigIntRight) // -> true\nshallow(bigIntLeft, bigIntRight) // -> true\n```\n\n----------------------------------------\n\nTITLE: Modifying Zustand Middleware Function Signatures in TypeScript\nDESCRIPTION: Demonstrates the changes in the type signatures of various Zustand middleware functions from v3 to v4.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v4.md#2025-04-22_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n- combine:\n-   <T, U>(...) => ...\n+ combine:\n+   <T, U, Mps, Mcs>(...) => ...\n\n- devtools:\n-   <T>(...) => ...\n+ devtools:\n+   <T, Mps, Mcs>(...) => ...\n\n- subscribeWithSelector:\n-   <T>(...) => ...\n+ subscribeWithSelector:\n+   <T, Mps, Mcs>(...) => ...\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for useShallow\nDESCRIPTION: Type definition showing the function signature for the useShallow hook.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-shallow.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nuseShallow<T, U = T>(selectorFn: (state: T) => U): (state: T) => U\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of Shallow Comparison in JavaScript\nDESCRIPTION: Basic syntax for using the shallow comparison function to check equality between two values.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/shallow.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst equal = shallow(a, b)\n```\n\n----------------------------------------\n\nTITLE: Implementing Counter Stores Context Provider in React\nDESCRIPTION: This snippet creates a React context for managing counter stores and a provider component to wrap the application. It uses useState to initialize a Map for storing the counter instances.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store-with-equality-fn.md#2025-04-22_snippet_16\n\nLANGUAGE: tsx\nCODE:\n```\nconst CounterStoresContext = createContext(null)\n\nconst CounterStoresProvider = ({ children }) => {\n  const [stores] = useState(\n    () => new Map<string, ReturnType<typeof createCounterStore>>(),\n  )\n\n  return (\n    <CounterStoresContext.Provider value={stores}>\n      {children}\n    </CounterStoresContext.Provider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Redux Middleware Mutator Type\nDESCRIPTION: Type definition for the redux middleware mutator\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/redux.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n['zustand/redux', A]\n```\n\n----------------------------------------\n\nTITLE: HTML Structure for Object State Example\nDESCRIPTION: HTML markup for the position tracking dot example. This creates a container and a dot that will be positioned based on object state updates.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-store.md#2025-04-22_snippet_7\n\nLANGUAGE: html\nCODE:\n```\n<div\n  id=\"dot-container\"\n  style=\"position: relative; width: 100vw; height: 100vh;\"\n>\n  <div\n    id=\"dot\"\n    style=\"position: absolute; background-color: red; border-radius: 50%; left: -10px; top: -10px; width: 20px; height: 20px;\"\n  ></div>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Modifying createContext Function Signature in TypeScript\nDESCRIPTION: Illustrates the changes in the type signature of the 'createContext' function from Zustand v3 to v4.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v4.md#2025-04-22_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n  createContext:\n-   <State, Store = StoreApi<State>>() => ...\n+   <Store>() => ...\n```\n\n----------------------------------------\n\nTITLE: Calculating Remaining Turns in Tic-Tac-Toe Game using JavaScript\nDESCRIPTION: This function computes the number of remaining turns in the Tic-Tac-Toe game by filtering out filled squares and counting the null items in the squares array. The result indicates how many moves can still be made.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nfunction calculateTurns(squares) {\n  return squares.filter((square) => !square).length\n}\n```\n\n----------------------------------------\n\nTITLE: Route-Level Store Provider Implementation\nDESCRIPTION: Alternative implementation showing how to create a store per route by wrapping the HomePage component with CounterStoreProvider at the page level.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/nextjs.md#2025-04-22_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { CounterStoreProvider } from '@/providers/counter-store-provider'\nimport { HomePage } from '@/components/pages/home-page'\n\nexport default function Home() {\n  return (\n    <CounterStoreProvider>\n      <HomePage />\n    </CounterStoreProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Hook for Accessing Counter Store - TSX\nDESCRIPTION: Creates a custom hook, `useCounterStore`, for accessing the appropriate counter store based on the current tab index. It ensures that the store is created or retrieved from the context correctly.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store.md#2025-04-22_snippet_17\n\nLANGUAGE: tsx\nCODE:\n```\nconst useCounterStore = <U>(\n  currentTabIndex: number,\n  selector: (state: CounterStore) => U,\n) => {\n  const stores = useContext(CounterStoresContext)\n\n  if (stores === undefined) {\n    throw new Error('useCounterStore must be used within CounterStoresProvider')\n  }\n\n  const getOrCreateCounterStoreByKey = useCallback(\n    () => createCounterStoreFactory(stores),\n    [stores],\n  )\n\n  return useStore(getOrCreateCounterStoreByKey(`tab-${currentTabIndex}`))\n}\n```\n\n----------------------------------------\n\nTITLE: Troubleshooting Nested Object Comparison with Shallow\nDESCRIPTION: Explains why shallow returns false when comparing objects with nested structures, as it only compares top-level property references and not their contents.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/shallow.md#2025-04-22_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst objectLeft = {\n  firstName: 'John',\n  lastName: 'Doe',\n  age: 30,\n  address: {\n    street: 'Kulas Light',\n    suite: 'Apt. 556',\n    city: 'Gwenborough',\n    zipcode: '92998-3874',\n    geo: {\n      lat: '-37.3159',\n      lng: '81.1496',\n    },\n  },\n}\nconst objectRight = {\n  firstName: 'John',\n  lastName: 'Doe',\n  age: 30,\n  address: {\n    street: 'Kulas Light',\n    suite: 'Apt. 556',\n    city: 'Gwenborough',\n    zipcode: '92998-3874',\n    geo: {\n      lat: '-37.3159',\n      lng: '81.1496',\n    },\n  },\n}\n\nObject.is(objectLeft, objectRight) // -> false\nshallow(objectLeft, objectRight) // -> false\n```\n\n----------------------------------------\n\nTITLE: HTML Structure for Input Fields\nDESCRIPTION: This snippet presents the HTML structure that defines form input fields for first name, last name, and email. The fields are linked to the TypeScript logic for state management.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-store.md#2025-04-22_snippet_15\n\nLANGUAGE: html\nCODE:\n```\n<label style=\"display: block\">\n  First name:\n  <input id=\"first-name\" />\n</label>\n<label style=\"display: block\">\n  Last name:\n  <input id=\"last-name\" />\n</label>\n<label style=\"display: block\">\n  Email:\n  <input id=\"email\" />\n</label>\n<p id=\"result\"></p>\n```\n\n----------------------------------------\n\nTITLE: HTML Structure for Array State Example\nDESCRIPTION: HTML markup for the position tracking example using array state. This creates a container and dot element for demonstrating array-based state updates.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-store.md#2025-04-22_snippet_9\n\nLANGUAGE: html\nCODE:\n```\n<div\n  id=\"dot-container\"\n  style=\"position: relative; width: 100vw; height: 100vh;\"\n>\n  <div\n    id=\"dot\"\n    style=\"position: absolute; background-color: red; border-radius: 50%; left: -10px; top: -10px; width: 20px; height: 20px;\"\n  ></div>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Implementing a Server with Hydration Support\nDESCRIPTION: Enhanced server implementation that includes bootstrap scripts to hydrate the application on the client, enabling interactive features after initial server rendering.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/ssr-and-hydration.md#2025-04-22_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n// server.tsx\nimport express from 'express'\nimport React from 'react'\nimport ReactDOMServer from 'react-dom/server'\n\nimport { App } from './app.tsx'\n\nconst port = Number.parseInt(process.env.PORT || '3000', 10)\nconst app = express()\n\napp.use('/', (_, res) => {\n  const { pipe } = ReactDOMServer.renderToPipeableStream(<App />, {\n    bootstrapScripts: ['/main.js'],\n    onShellReady() {\n      res.setHeader('content-type', 'text/html')\n      pipe(res)\n    },\n  })\n})\n\napp.listen(port, () => {\n  console.log(`Server is listening at ${port}`)\n})\n```\n\n----------------------------------------\n\nTITLE: Installing and Running Zustand Starter Project\nDESCRIPTION: Commands to clone the Zustand repository, install project dependencies, build the library, and start the development server. The process includes moving into the starter example directory and setting up its dependencies.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/examples/starter/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/pmndrs/zustand\n\n# install project dependencies & build the library\ncd zustand && pnpm install\n\n# move to the examples folder & install dependencies\ncd examples/starter && pnpm install\n\n# start the dev server\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Mutator Type for immer Middleware\nDESCRIPTION: TypeScript type definition for the immer mutator, used to mark a state creator as using the immer middleware.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/immer.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n['zustand/immer', never]\n```\n\n----------------------------------------\n\nTITLE: Render Optimization with Redux Toolkit\nDESCRIPTION: Demonstrates how to implement render optimization in Redux Toolkit using typed hooks. Shows creating type-safe selectors and dispatch functions.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/getting-started/comparison.md#2025-04-22_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useSelector } from 'react-redux'\nimport type { TypedUseSelectorHook } from 'react-redux'\nimport { createSlice, configureStore } from '@reduxjs/toolkit'\n\nconst countSlice = createSlice({\n  name: 'count',\n  initialState: { value: 0 },\n  reducers: {\n    incremented: (state, qty: number) => {\n      // Redux Toolkit does not mutate the state, it uses the Immer library\n      // behind scenes, allowing us to have something called \"draft state\".\n      state.value += qty\n    },\n    decremented: (state, qty: number) => {\n      state.value -= qty\n    },\n  },\n})\n\nconst countStore = configureStore({ reducer: countSlice.reducer })\n\nconst useAppSelector: TypedUseSelectorHook<typeof countStore.getState> =\n  useSelector\n\nconst useAppDispatch: () => typeof countStore.dispatch = useDispatch\n\nconst Component = () => {\n  const count = useAppSelector((state) => state.count.value)\n  const dispatch = useAppDispatch()\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Position State Updates\nDESCRIPTION: Subscribes to store changes and updates DOM element position based on current state\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nconst render: Parameters<typeof positionStore.subscribe>[0] = (state) => {\n  $dot.style.transform = `translate(${state.position.x}px, ${state.position.y}px)`\n}\n\nrender(positionStore.getState(), positionStore.getState())\n\npositionStore.subscribe(render)\n```\n\n----------------------------------------\n\nTITLE: Installing Zustand via NPM\nDESCRIPTION: Instructions for installing the Zustand package using NPM or any other package manager of choice.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/getting-started/introduction.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# NPM\nnpm install zustand\n# Or, use any package manager of your choice.\n```\n\n----------------------------------------\n\nTITLE: Position Store Configuration with Zustand\nDESCRIPTION: Creation of a Zustand store for position tracking with persistence middleware\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'zustand/vanilla'\nimport { persist, createJSONStorage } from 'zustand/middleware'\n\ntype PositionStoreState = { position: { x: number; y: number } }\n\ntype PositionStoreActions = {\n  setPosition: (nextPosition: PositionStoreState['position']) => void\n}\n\ntype PositionStore = PositionStoreState & PositionStoreActions\n\nconst positionStore = createStore<PositionStore>()(\n  persist(\n    (set) => ({\n      position: { x: 0, y: 0 },\n      setPosition: (position) => set({ position }),\n    }),\n    {\n      name: 'position-storage',\n      storage: createJSONStorage(() => searchParamsStorage),\n    },\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for Shallow Comparison\nDESCRIPTION: Type definition showing the signature of the shallow function, which takes two values of the same type and returns a boolean indicating equality.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/shallow.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nshallow<T>(a: T, b: T): boolean\n```\n\n----------------------------------------\n\nTITLE: App Component Rendering the MovingDot\nDESCRIPTION: Simple React component that renders the MovingDot component, completing the implementation of the position tracking example.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store-with-equality-fn.md#2025-04-22_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nexport default function App() {\n  return <MovingDot />\n}\n```\n\n----------------------------------------\n\nTITLE: Overwriting State in Zustand Store\nDESCRIPTION: Demonstrates how to overwrite state in a Zustand store using the set function's second argument.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/README.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport omit from 'lodash-es/omit'\n\nconst useFishStore = create((set) => ({\n  salmon: 1,\n  tuna: 2,\n  deleteEverything: () => set({}, true), // clears the entire store, actions included\n  deleteTuna: () => set((state) => omit(state, ['tuna']), true),\n}))\n```\n\n----------------------------------------\n\nTITLE: Mouse Movement Event Handler\nDESCRIPTION: Event listener setup for tracking mouse position and updating store state\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst $dotContainer = document.getElementById('dot-container') as HTMLDivElement\nconst $dot = document.getElementById('dot') as HTMLDivElement\n\n$dotContainer.addEventListener('pointermove', (event) => {\n  positionStore.getState().setPosition({\n    x: event.clientX,\n    y: event.clientY,\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Importing Zustand Middleware Functions in TypeScript\nDESCRIPTION: Shows the import statements for various Zustand middleware functions.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v4.md#2025-04-22_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { combine } from 'zustand/middleware'\nimport { devtools } from 'zustand/middleware'\nimport { subscribeWithSelector } from 'zustand/middleware'\n```\n\n----------------------------------------\n\nTITLE: Initializing Zustand Counter Store Instance\nDESCRIPTION: Creates and exports a Zustand store instance using the counter store creator.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/testing.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\n\nimport {\n  type CounterStore,\n  counterStoreCreator,\n} from '../shared/counter-store-creator'\n\nexport const useCounterStore = create<CounterStore>()(counterStoreCreator)\n```\n\n----------------------------------------\n\nTITLE: Non-Curried Create Function with Middleware Types\nDESCRIPTION: Example of using create without the curried pattern by explicitly providing type parameters. This approach is not recommended as it can act as an assertion instead of an annotation in some cases.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md#2025-04-22_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from \"zustand\"\n\ninterface BearState {\n  bears: number\n  increase: (by: number) => void\n}\n\nconst useBearStore = create<\n  BearState,\n  [\n    ['zustand/persist', BearState],\n    ['zustand/devtools', never]\n  ]\n>(devtools(persist((set) => ({\n  bears: 0,\n  increase: (by) => set((state) => ({ bears: state.bears + by })),\n}), { name: 'bearStore' })))\n```\n\n----------------------------------------\n\nTITLE: Mutable State Model in Valtio\nDESCRIPTION: Demonstrates how Valtio uses a mutable state model in contrast to Zustand. Shows updating nested state through direct mutation using the proxy object.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/getting-started/comparison.md#2025-04-22_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { proxy } from 'valtio'\n\nconst state = proxy({ obj: { count: 0 } })\n\nstate.obj.count += 1\n```\n\n----------------------------------------\n\nTITLE: Importing useStore Function in TypeScript\nDESCRIPTION: Shows the import statements for the 'useStore' function from Zustand and Zustand/react.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v4.md#2025-04-22_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useStore } from 'zustand'\nimport { useStore } from 'zustand/react'\n```\n\n----------------------------------------\n\nTITLE: HTML Structure for Position Tracker\nDESCRIPTION: HTML code defining the container and dot elements used in the position tracker example.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_7\n\nLANGUAGE: html\nCODE:\n```\n<div\n  id=\"dot-container\"\n  style=\"position: relative; width: 100vw; height: 100vh;\"\n>\n  <div\n    id=\"dot\"\n    style=\"position: absolute; background-color: red; border-radius: 50%; left: -10px; top: -10px; width: 20px; height: 20px;\"\n  ></div>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Importing persist Middleware in TypeScript\nDESCRIPTION: Shows the import statement for the 'persist' middleware from Zustand.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v4.md#2025-04-22_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { persist } from 'zustand/middleware'\n```\n\n----------------------------------------\n\nTITLE: Creating Square Component\nDESCRIPTION: Implements a reusable Square component that represents each cell in the Tic-Tac-Toe grid. Takes value and click handler as props with styled button implementation.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nfunction Square({ value, onSquareClick }) {\n  return (\n    <button\n      style={{\n        display: 'inline-flex',\n        alignItems: 'center',\n        justifyContent: 'center',\n        padding: 0,\n        backgroundColor: '#fff',\n        border: '1px solid #999',\n        outline: 0,\n        borderRadius: 0,\n        fontSize: '1rem',\n        fontWeight: 'bold',\n      }}\n      onClick={onSquareClick}\n    >\n      {value}\n    </button>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Client-side Entry Point for Hydration\nDESCRIPTION: Client-side entry point that hydrates the server-rendered markup to create an interactive application using React DOM Client.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/ssr-and-hydration.md#2025-04-22_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n// main.tsx\nimport ReactDOMClient from 'react-dom/client'\n\nimport { App } from './app.tsx'\n\nReactDOMClient.hydrateRoot(document, <App />)\n```\n\n----------------------------------------\n\nTITLE: Implementing Counter Component with Context\nDESCRIPTION: React component that uses the counter store through Context API instead of direct store usage.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/testing.md#2025-04-22_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  CounterStoreProvider,\n  useCounterStoreContext,\n} from '../../contexts/use-counter-store-context'\n\nconst Counter = () => {\n  const { count, inc } = useCounterStoreContext((state) => state)\n\n  return (\n    <div>\n      <h2>Counter Store Context</h2>\n      <h4>{count}</h4>\n      <button onClick={inc}>One Up</button>\n    </div>\n  )\n}\n\nexport const CounterWithContext = () => {\n  return (\n    <CounterStoreProvider>\n      <Counter />\n    </CounterStoreProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature Definition\nDESCRIPTION: Type definition showing the complete signature of createWithEqualityFn including generic types and parameters.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-with-equality-fn.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ncreateWithEqualityFn<T>()(stateCreatorFn: StateCreator<T, [], []>, equalityFn?: (a: T, b: T) => boolean): UseBoundStore<StoreApi<T>>\n```\n\n----------------------------------------\n\nTITLE: Type Definition for persist Middleware Signature\nDESCRIPTION: TypeScript type definition for the persist middleware function signature, showing the generic parameters and return type.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\npersist<T, U>(stateCreatorFn: StateCreator<T, [], []>, persistOptions?: PersistOptions<T, U>): StateCreator<T, [['zustand/persist', U]], []>\n```\n\n----------------------------------------\n\nTITLE: subscribeWithSelector Mutator Type - TypeScript\nDESCRIPTION: Type definition for the subscribeWithSelector mutator tuple.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/subscribe-with-selector.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n['zustand/subscribeWithSelector', never]\n```\n\n----------------------------------------\n\nTITLE: Type Definition for immer Middleware\nDESCRIPTION: TypeScript type signature for the immer middleware function, showing its parameters and return type.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/immer.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimmer<T>(stateCreatorFn: StateCreator<T, [], []>): StateCreator<T, [['zustand/immer', never]], []>\n```\n\n----------------------------------------\n\nTITLE: Modifying Zustand Create Function Signature in TypeScript\nDESCRIPTION: Demonstrates the changes in the type signature of the 'create' function from Zustand v3 to v4.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v4.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n- create:\n-   < State\n-   , StoreSetState = StoreApi<State>[\"set\"]\n-   , StoreGetState = StoreApi<State>[\"get\"]\n-   , Store = StoreApi<State>\n-   >\n-     (f: ...) => ...\n+ create:\n+   { <State>(): (f: ...) => ...\n+   , <State, Mutators>(f: ...) => ...\n+   }\n```\n\n----------------------------------------\n\nTITLE: Calculating Remaining Turns in Tic-Tac-Toe Game\nDESCRIPTION: Function that calculates the number of remaining turns in a Tic-Tac-Toe game by counting the number of empty squares on the board. It filters the squares array and returns the count of squares that have no value.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_23\n\nLANGUAGE: javascript\nCODE:\n```\nfunction calculateTurns(squares) {\n  return squares.filter((square) => !square).length\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeScript for Next.js and Zustand\nDESCRIPTION: TypeScript configuration file setup with necessary compiler options for Next.js and Zustand integration.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/nextjs.md#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"allowJs\": true,\n    \"skipLibCheck\": true,\n    \"strict\": true,\n    \"noEmit\": true,\n    \"esModuleInterop\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"bundler\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"jsx\": \"preserve\",\n    \"incremental\": true,\n    \"plugins\": [\n      {\n        \"name\": \"next\"\n      }\n    ],\n    \"paths\": {\n      \"@/*\": [\"./src/*\"]\n    }\n  },\n  \"include\": [\"next-env.d.ts\", \"**/*.ts\", \"**/*.tsx\", \".next/types/**/*.ts\"],\n  \"exclude\": [\"node_modules\"]\n}\n```\n\n----------------------------------------\n\nTITLE: HTML Structure for Position Tracking Dot Example\nDESCRIPTION: The HTML markup required for the position tracking example, setting up a container and a dot element that follows mouse movements.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/combine.md#2025-04-22_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<div\n  id=\"dot-container\"\n  style=\"position: relative; width: 100vw; height: 100vh;\"\n>\n  <div\n    id=\"dot\"\n    style=\"position: absolute; background-color: red; border-radius: 50%; left: -10px; top: -10px; width: 20px; height: 20px;\"\n  ></div>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Basic Home Page Component\nDESCRIPTION: Simple Next.js page component that renders the HomePage component.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/nextjs.md#2025-04-22_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { HomePage } from '@/components/pages/home-page'\n\nexport default function Home() {\n  return <HomePage />\n}\n```\n\n----------------------------------------\n\nTITLE: Event Handling for Partially Persisted Store\nDESCRIPTION: Event handling code for updating a partially persisted store with new position data.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst $dotContainer = document.getElementById('dot-container') as HTMLDivElement\nconst $dot = document.getElementById('dot') as HTMLDivElement\n\n$dotContainer.addEventListener('pointermove', (event) => {\n  positionStore.getState().actions.setPosition({\n    x: event.clientX,\n    y: event.clientY,\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring exactOptionalPropertyTypes in TypeScript\nDESCRIPTION: Demonstrates how to enable 'exactOptionalPropertyTypes' in tsconfig.json for Zustand v4 migration.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v4.md#2025-04-22_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"exactOptionalPropertyTypes\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Main App Component - TSX\nDESCRIPTION: This is the main App component that provides the context and renders the Tabs component, encapsulating the entire application structure.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store.md#2025-04-22_snippet_19\n\nLANGUAGE: tsx\nCODE:\n```\nexport default function App() {\n  return (\n    <CounterStoresProvider>\n      <Tabs />\n    </CounterStoresProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Skipping Automatic Hydration in Zustand Persist\nDESCRIPTION: Example of configuring a store to skip automatic hydration, useful for server-rendered applications where manual control over hydration timing is needed.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/integrations/persisting-store-data.md#2025-04-22_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport const useBoundStore = create(\n  persist(\n    () => ({\n      count: 0,\n      // ...\n    }),\n    {\n      // ...\n      skipHydration: true,\n    },\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Importing redux Middleware in TypeScript\nDESCRIPTION: Displays the import statement for the 'redux' middleware from Zustand.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v4.md#2025-04-22_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { redux } from 'zustand/middleware'\n```\n\n----------------------------------------\n\nTITLE: Basic DevTools Function Signature\nDESCRIPTION: TypeScript signature for the devtools middleware function showing its parameters and return type.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/devtools.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndevtools<T>(stateCreatorFn: StateCreator<T, [], []>, devtoolsOptions?: DevtoolsOptions): StateCreator<T, [['zustand/devtools', never]], []>\n```\n\n----------------------------------------\n\nTITLE: Implementing a Stateless SSR Server with Express and React\nDESCRIPTION: Server implementation using Express and React DOM Server to render React components as HTML on the server for a stateless application, with pipeline streaming for efficient delivery.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/ssr-and-hydration.md#2025-04-22_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// server.tsx\nimport express from 'express'\nimport React from 'react'\nimport ReactDOMServer from 'react-dom/server'\n\nimport { App } from './app.tsx'\n\nconst port = Number.parseInt(process.env.PORT || '3000', 10)\nconst app = express()\n\napp.get('/', (_, res) => {\n  const { pipe } = ReactDOMServer.renderToPipeableStream(<App />, {\n    onShellReady() {\n      res.setHeader('content-type', 'text/html')\n      pipe(res)\n    },\n  })\n})\n\napp.listen(port, () => {\n  console.log(`Server is listening at ${port}`)\n})\n```\n\n----------------------------------------\n\nTITLE: Importing PartialState Type in TypeScript\nDESCRIPTION: Displays the import statements for the 'PartialState' type from Zustand and Zustand/vanilla.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v4.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { PartialState } from 'zustand'\nimport type { PartialState } from 'zustand/vanilla'\n```\n\n----------------------------------------\n\nTITLE: Implementing Time Travel in React Tic-Tac-Toe Game\nDESCRIPTION: React component code that implements the time travel feature for a Tic-Tac-Toe game. It maps over the game history to create a list of buttons that allow players to jump to previous game states, with each button showing the corresponding move number.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_25\n\nLANGUAGE: jsx\nCODE:\n```\nexport default function Game() {\n  const history = useGameStore((state) => state.history)\n  const setHistory = useGameStore((state) => state.setHistory)\n  const xIsNext = useGameStore((state) => state.xIsNext)\n  const setXIsNext = useGameStore((state) => state.setXIsNext)\n  const currentSquares = history[history.length - 1]\n\n  function handlePlay(nextSquares) {\n    setHistory(history.concat([nextSquares]))\n    setXIsNext(!xIsNext)\n  }\n\n  function jumpTo(nextMove) {\n    // TODO\n  }\n\n  return (\n    <div\n      style={{\n        display: 'flex',\n        flexDirection: 'row',\n        fontFamily: 'monospace',\n      }}\n    >\n      <div>\n        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />\n      </div>\n      <div style={{ marginLeft: '1rem' }}>\n        <ol>\n          {history.map((_, historyIndex) => {\n            const description =\n              historyIndex > 0\n                ? `Go to move #${historyIndex}`\n                : 'Go to game start'\n\n            return (\n              <li key={historyIndex}>\n                <button onClick={() => jumpTo(historyIndex)}>\n                  {description}\n                </button>\n              </li>\n            )\n          })}\n        </ol>\n      </div>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying useStore Function Signature in TypeScript\nDESCRIPTION: Illustrates the changes in the type signature of the 'useStore' function from Zustand v3 to v4.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v4.md#2025-04-22_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n- useStore:\n-   { <State>(store: StoreApi<State>): State\n-   , <State, StateSlice>\n-       ( store: StoreApi<State>\n-       , selector: StateSelector<State, StateSlice>,\n-       , equals?: EqualityChecker<StateSlice>\n-       ): StateSlice\n-   }\n+ useStore:\n+   <Store, StateSlice = ExtractState<Store>>\n+     ( store: Store\n+     , selector?: StateSelector<State, StateSlice>,\n+     , equals?: EqualityChecker<StateSlice>\n+     )\n+       => StateSlice\n```\n\n----------------------------------------\n\nTITLE: Importing StateCreator Type in TypeScript\nDESCRIPTION: Shows the import statements for the 'StateCreator' type from Zustand and Zustand/vanilla.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v4.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { StateCreator } from 'zustand'\nimport type { StateCreator } from 'zustand/vanilla'\n```\n\n----------------------------------------\n\nTITLE: Render Optimization with Jotai Atoms\nDESCRIPTION: Shows how Jotai achieves render optimization through atom dependency. Demonstrates using useAtom to get and update atom values.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/getting-started/comparison.md#2025-04-22_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom, useAtom } from 'jotai'\n\nconst countAtom = atom<number>(0)\n\nconst Component = () => {\n  const [count, updateCount] = useAtom(countAtom)\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Importing createContext Function in TypeScript\nDESCRIPTION: Displays the import statement for the 'createContext' function from Zustand/context.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v4.md#2025-04-22_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport createContext from 'zustand/context'\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic React Component for SSR\nDESCRIPTION: A simple React component that defines the HTML structure to be rendered on the server, including head metadata and a basic body content.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/ssr-and-hydration.md#2025-04-22_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// app.tsx\nexport const App = () => {\n  return (\n    <html>\n      <head>\n        <meta charSet=\"utf-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n        <title>Static Server-side-rendered App</title>\n      </head>\n      <body>\n        <div>Hello World!</div>\n      </body>\n    </html>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: HTML Structure for Position Demo\nDESCRIPTION: HTML markup required for the position tracking demo, including a container and a dot element with styling.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/subscribe-with-selector.md#2025-04-22_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<div\n  id=\"dot-container\"\n  style=\"position: relative; width: 100vw; height: 100vh;\"\n>\n  <div\n    id=\"dot\"\n    style=\"position: absolute; background-color: red; border-radius: 50%; left: -10px; top: -10px; width: 20px; height: 20px;\"\n  ></div>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Modifying PartialState Type in Zustand TypeScript\nDESCRIPTION: Shows the changes in the 'PartialState' type definition from Zustand v3 to v4.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v4.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n- type PartialState\n-   < T extends State\n-   , K1 extends keyof T = keyof T\n-   , K2 extends keyof T = K1\n-   , K3 extends keyof T = K2\n-   , K4 extends keyof T = K3\n-   > =\n-   | (Pick<T, K1> | Pick<T, K2> | Pick<T, K3> | Pick<T, K4> | T)\n-   | ((state: T) => Pick<T, K1> | Pick<T, K2> | Pick<T, K3> | Pick<T, K4> | T)\n+ type PartialState<T> =\n+   | Partial<T>\n+   | ((state: T) => Partial<T>)\n```\n\n----------------------------------------\n\nTITLE: Modifying UseBoundStore Type in Zustand TypeScript\nDESCRIPTION: Shows the changes in the 'UseBoundStore' type definition from Zustand v3 to v4.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v4.md#2025-04-22_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n- type UseBoundStore<\n-   State,\n-   Store = StoreApi<State>\n- > =\n-   & { (): T\n-     , <StateSlice>\n-         ( selector: StateSelector<State, StateSlice>\n-         , equals?: EqualityChecker<StateSlice>\n-         ): U\n-     }\n-   & Store\n+ type UseBoundStore<Store> =\n+   & (<StateSlice = ExtractState<S>>\n+       ( selector?: (state: ExtractState<S>) => StateSlice\n+       , equals?: (a: StateSlice, b: StateSlice) => boolean\n+       ) => StateSlice\n+     )\n+   & S\n```\n\n----------------------------------------\n\nTITLE: Implementing Board Component\nDESCRIPTION: Creates the game board layout using CSS Grid with a 3x3 structure. Renders nine Square components in a grid format with basic styling.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nexport default function Board() {\n  return (\n    <div\n      style={{\n        display: 'grid',\n        gridTemplateColumns: 'repeat(3, 1fr)',\n        gridTemplateRows: 'repeat(3, 1fr)',\n        width: 'calc(3 * 2.5rem)',\n        height: 'calc(3 * 2.5rem)',\n        border: '1px solid #999',\n      }}\n    >\n      <Square value=\"1\" />\n      <Square value=\"2\" />\n      <Square value=\"3\" />\n      <Square value=\"4\" />\n      <Square value=\"5\" />\n      <Square value=\"6\" />\n      <Square value=\"7\" />\n      <Square value=\"8\" />\n      <Square value=\"9\" />\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: HTML Dot Container Template\nDESCRIPTION: HTML markup for creating a full-screen container with a movable dot element\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_24\n\nLANGUAGE: html\nCODE:\n```\n<div\n  id=\"dot-container\"\n  style=\"position: relative; width: 100vw; height: 100vh;\"\n>\n  <div\n    id=\"dot\"\n    style=\"position: absolute; background-color: red; border-radius: 50%; left: -10px; top: -10px; width: 20px; height: 20px;\"\n  ></div>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Configuring Jest Setup\nDESCRIPTION: Jest configuration setup including test environment and TypeScript support.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/testing.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport '@testing-library/jest-dom'\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { JestConfigWithTsJest } from 'ts-jest'\n\nconst config: JestConfigWithTsJest = {\n  preset: 'ts-jest',\n  testEnvironment: 'jsdom',\n  setupFilesAfterEnv: ['./setup-jest.ts'],\n}\n\nexport default config\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature of Combine Middleware\nDESCRIPTION: The TypeScript type definition for the combine middleware function, showing parameter types and return type.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/combine.md#2025-04-22_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\ncombine<T, U>(initialState: T, additionalStateCreatorFn: StateCreator<T, [], [], U>): StateCreator<Omit<T, keyof U> & U, [], []>\n```\n\n----------------------------------------\n\nTITLE: subscribeWithSelector Type Definition - TypeScript\nDESCRIPTION: TypeScript type definition for the subscribeWithSelector middleware function showing its signature and return type.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/subscribe-with-selector.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nsubscribeWithSelector<T>(stateCreatorFn: StateCreator<T, [], []>): StateCreator<T, [['zustand/subscribeWithSelector', never]], []>\n```\n\n----------------------------------------\n\nTITLE: HTML Structure for Partial Persistence Example\nDESCRIPTION: HTML code for the container and dot elements used in the partial state persistence example.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_12\n\nLANGUAGE: html\nCODE:\n```\n<div\n  id=\"dot-container\"\n  style=\"position: relative; width: 100vw; height: 100vh;\"\n>\n  <div\n    id=\"dot\"\n    style=\"position: absolute; background-color: red; border-radius: 50%; left: -10px; top: -10px; width: 20px; height: 20px;\"\n  ></div>\n</div>\n```\n\n----------------------------------------\n\nTITLE: HTML Form Implementation\nDESCRIPTION: HTML markup for the form inputs used in the Redux store example\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/redux.md#2025-04-22_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<label style=\"display: block\">\n  First name:\n  <input id=\"first-name\" />\n</label>\n<label style=\"display: block\">\n  Last name:\n  <input id=\"last-name\" />\n</label>\n<label style=\"display: block\">\n  Email:\n  <input id=\"email\" />\n</label>\n<p id=\"result\"></p>\n```\n\n----------------------------------------\n\nTITLE: Configuring Web Crawler Access Rules in robots.txt\nDESCRIPTION: Defines the access rules for web crawlers using the standard robots.txt format. This configuration allows full access to all web crawlers by not specifying any disallow rules.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/examples/demo/public/robots.txt#2025-04-22_snippet_0\n\nLANGUAGE: robotstxt\nCODE:\n```\nUser-agent: *\nDisallow:\n```\n\n----------------------------------------\n\nTITLE: HTML Structure for Position Tracking Demo\nDESCRIPTION: HTML markup for the position tracking demonstration with styled container and dot elements\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_18\n\nLANGUAGE: html\nCODE:\n```\n<div\n  id=\"dot-container\"\n  style=\"position: relative; width: 100vw; height: 100vh;\"\n>\n  <div\n    id=\"dot\"\n    style=\"position: absolute; background-color: red; border-radius: 50%; left: -10px; top: -10px; width: 20px; height: 20px;\"\n  ></div>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Installing Zustand via npm\nDESCRIPTION: Command to install Zustand using npm package manager.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install zustand\n```\n\n----------------------------------------\n\nTITLE: Installing Immer for Zustand Middleware\nDESCRIPTION: Shows how to install Immer as a dependency to use with Zustand middleware.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/integrations/immer-middleware.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install immer\n```\n\n----------------------------------------\n\nTITLE: HTML Structure for Subscription Example\nDESCRIPTION: HTML markup for the dot movement example that demonstrates state subscriptions. This creates a container and dot element used to show subscription-based UI updates.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-store.md#2025-04-22_snippet_11\n\nLANGUAGE: html\nCODE:\n```\n<div\n  id=\"dot-container\"\n  style=\"position: relative; width: 100vw; height: 100vh;\"\n>\n  <div\n    id=\"dot\"\n    style=\"position: absolute; background-color: red; border-radius: 50%; left: -10px; top: -10px; width: 20px; height: 20px;\"\n  ></div>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Counter Component Barrel Export\nDESCRIPTION: Exports the Counter component through a barrel file for cleaner imports.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/testing.md#2025-04-22_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport * from './counter'\n```\n\n----------------------------------------\n\nTITLE: Importing StateStorage Type from Zustand Middleware\nDESCRIPTION: Code snippet showing how to import the StateStorage type from Zustand's middleware module, which is used for implementing custom storage solutions.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/integrations/persisting-store-data.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { StateStorage } from 'zustand/middleware'\n```\n\n----------------------------------------\n\nTITLE: Rendering with Partially Persisted State\nDESCRIPTION: Code for rendering UI based on changes to partially persisted state data.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst render: Parameters<typeof positionStore.subscribe>[0] = (state) => {\n  $dot.style.transform = `translate(${state.context.position.x}px, ${state.context.position.y}px)`\n}\n\nrender(positionStore.getState(), positionStore.getState())\n\npositionStore.subscribe(render)\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeScript for SSR with tsconfig.json\nDESCRIPTION: TypeScript configuration for SSR applications, specifying compiler options including target ES version, source maps, and error handling.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/ssr-and-hydration.md#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"noImplicitAny\": false,\n    \"noEmitOnError\": true,\n    \"removeComments\": false,\n    \"sourceMap\": true,\n    \"target\": \"esnext\"\n  },\n  \"include\": [\"**/*\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Example Game Board State Array\nDESCRIPTION: Shows an example of how the squares array is structured during gameplay, with X's, O's and null values representing empty squares.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/tutorial-tic-tac-toe.md#2025-04-22_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nconst squares = ['O', null, 'X', 'X', 'X', 'O', 'O', null, null]\n```\n\n----------------------------------------\n\nTITLE: HTML Structure for Age Increment Example\nDESCRIPTION: HTML markup required for the age increment example. This defines the DOM elements that the JavaScript code interacts with.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/apis/create-store.md#2025-04-22_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<h1 id=\"your-age\"></h1>\n<button id=\"increment-by-3\" type=\"button\">+3</button>\n<button id=\"increment-by-1\" type=\"button\">+1</button>\n```\n\n----------------------------------------\n\nTITLE: Importing Zustand Create Function in TypeScript\nDESCRIPTION: Shows the import statements for the 'create' function from Zustand and Zustand/vanilla.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v4.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport create from 'zustand'\nimport create from 'zustand/vanilla'\n```\n\n----------------------------------------\n\nTITLE: Initializing LocalStorage with Position Data\nDESCRIPTION: Sets up initial localStorage state with a partial position object, simulating a scenario with missing fields\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/middlewares/persist.md#2025-04-22_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nif (!localStorage.getItem('position-storage')) {\n  localStorage.setItem(\n    'position-storage',\n    JSON.stringify({\n      state: { position: { y: 100 } }, // missing `x` field\n      version: 0,\n    }),\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Counter with Context Barrel Export\nDESCRIPTION: Exports the CounterWithContext component through a barrel file for cleaner imports.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/testing.md#2025-04-22_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport * from './counter-with-context'\n```\n\n----------------------------------------\n\nTITLE: Creating a Zustand Store with Reset Functionality in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a Zustand store with a reset function that returns the state to its initial values. It includes type definitions for state and actions, and implements methods for adding salmon and tuna quantities.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/guides/how-to-reset-state.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from 'zustand'\n\n// define types for state values and actions separately\ntype State = {\n  salmon: number\n  tuna: number\n}\n\ntype Actions = {\n  addSalmon: (qty: number) => void\n  addTuna: (qty: number) => void\n  reset: () => void\n}\n\n// define the initial state\nconst initialState: State = {\n  salmon: 0,\n  tuna: 0,\n}\n\n// create store\nconst useSlice = create<State & Actions>()((set, get) => ({\n  ...initialState,\n  addSalmon: (qty: number) => {\n    set({ salmon: get().salmon + qty })\n  },\n  addTuna: (qty: number) => {\n    set({ tuna: get().tuna + qty })\n  },\n  reset: () => {\n    set(initialState)\n  },\n}))\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Hook for Accessing Counter Stores in React\nDESCRIPTION: This snippet defines a custom hook 'useCounterStore' that allows access to the correct store for a given tab. It uses the React context to retrieve stores and creates a new store if it doesn't exist.\nSOURCE: https://github.com/pmndrs/zustand/blob/main/docs/hooks/use-store-with-equality-fn.md#2025-04-22_snippet_17\n\nLANGUAGE: tsx\nCODE:\n```\nconst useCounterStore = <U,>(\n  currentTabIndex: number,\n  selector: (state: CounterStore) => U,\n) => {\n  const stores = useContext(CounterStoresContext)\n\n  if (stores === undefined) {\n    throw new Error('useCounterStore must be used within CounterStoresProvider')\n  }\n\n  const getOrCreateCounterStoreByKey = useCallback(\n    () => createCounterStoreFactory(stores),\n    [stores],\n  )\n\n  return useStoreWithEqualityFn(\n    getOrCreateCounterStoreByKey(`tab-${currentTabIndex}`),\n    selector,\n    shallow,\n  )\n}\n```"
  }
]