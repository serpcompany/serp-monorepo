[
  {
    "owner": "sciml",
    "repo": "diffeqdocs.jl",
    "content": "TITLE: Defining an ODE Problem with DifferentialEquations.jl in Julia\nDESCRIPTION: Demonstrates how to create an ODEProblem instance using the DifferentialEquations.jl package in Julia, specifying the system function, initial condition, time span, and optionally parameters. The 'f' argument is the derivative function, 'u0' is the initial state, 'tspan' defines the integration interval, and 'p' allows for parameterization. Types for these components can be customized for high flexibility, supporting many numeric types (e.g., Rational, BigFloat, Complex). The output, 'prob', is an ODEProblem object ready to be solved by the package's solvers.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/overview.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nprob = ODEProblem(f, u0, tspan)\nprob = ODEProblem(f, u0, tspan, p)\n```\n\n----------------------------------------\n\nTITLE: Defining an ODE Problem in Julia using DifferentialEquations.jl\nDESCRIPTION: This snippet demonstrates the first step in solving an ODE: defining the problem. It imports the DifferentialEquations.jl library, defines the differential equation function `f(u, p, t)`, specifies the initial condition `u0`, and the time span `tspan`. These components are then used to construct an `ODEProblem` object named `prob`. The data types of `u0` and `tspan` determine the precision used for solving.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/getting_started.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\nf(u, p, t) = 1.01 * u\nu0 = 1 / 2\ntspan = (0.0, 1.0)\nprob = ODEProblem(f, u0, tspan)\n```\n\n----------------------------------------\n\nTITLE: Stiff Solvers QNDF/FBDF for Large/Expensive Systems in Julia\nDESCRIPTION: `QNDF` or `FBDF` (implicit multi-step methods) are recommended for stiff problems at high tolerances, especially for very large systems or when the function `f` is expensive to evaluate. They perform well on smooth solutions but can be less robust than Rosenbrock/TRBDF2.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\nQNDF\n```\n\nLANGUAGE: julia\nCODE:\n```\nFBDF\n```\n\n----------------------------------------\n\nTITLE: Solving an ODE Problem with DifferentialEquations.jl in Julia\nDESCRIPTION: Shows how to solve an ODE problem in Julia using the DifferentialEquations.jl 'solve' function. Takes a defined problem, 'prob', and optionally an algorithm 'alg' and additional solver keyword arguments. 'solve' dispatches to the appropriate solver, returning a 'sol' object containing results, which can be analyzed or visualized. The interface supports customization through keyword arguments and algorithm selection.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/overview.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, alg; kwargs)\n```\n\n----------------------------------------\n\nTITLE: Solving the Lorenz ODE Problem and Plotting Phase Space - DifferentialEquations.jl - Julia\nDESCRIPTION: Initializes the Lorenz ODE with initial conditions and time span, solves the problem, and demonstrates different plot usages via Plots.jl. Requires DifferentialEquations.jl and Plots.jl. `u0`: initial state, `tspan`: simulation interval, `prob`: ODEProblem definition with `lorenz!`, `sol`: solution object. Shows 3D phase-space plotting and extraction of specific variables or time-series components.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/getting_started.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\nu0 = [1.0; 0.0; 0.0]\ntspan = (0.0, 100.0)\nprob = ODEProblem(lorenz!, u0, tspan)\nsol = solve(prob)\n```\n\nLANGUAGE: julia\nCODE:\n```\nusing Plots\nplot(sol, idxs = (1, 2, 3))\n```\n\nLANGUAGE: julia\nCODE:\n```\nplot(sol, idxs = (0, 2))\n```\n\n----------------------------------------\n\nTITLE: Complete Example: Defining, Solving, and Plotting a Scalar ODE in Julia\nDESCRIPTION: This snippet provides a complete workflow for solving the scalar ODE du/dt = 1.01*u with initial condition u0=0.5 over the time span [0,1]. It defines the ODE function `f`, sets up the `ODEProblem`, solves it using the `Tsit5` algorithm with specified tolerances, and then plots the numerical solution against the analytical solution using the Plots.jl package.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/getting_started.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\nf(u, p, t) = 1.01 * u\nu0 = 1 / 2\ntspan = (0.0, 1.0)\nprob = ODEProblem(f, u0, tspan)\nsol = solve(prob, Tsit5(), reltol = 1e-8, abstol = 1e-8)\n\nusing Plots\nplot(sol, linewidth = 5, title = \"Solution to the linear ODE with a thick line\",\n    xaxis = \"Time (t)\", yaxis = \"u(t) (in Î¼m)\", label = \"My Thick Line!\") # legend=false\nplot!(sol.t, t -> 0.5 * exp(1.01t), lw = 3, ls = :dash, label = \"True Solution!\")\n```\n\n----------------------------------------\n\nTITLE: Defining Hodgkin-Huxley Neuron Model and Rate Functions with DifferentialEquations.jl in Julia\nDESCRIPTION: Implements the full Hodgkin-Huxley ODE system including supporting potassium and sodium channel rate functions. Functions like `alpha_n`, `beta_n`, etc., represent voltage-dependent rate constants for gating variables, required by the main ODE function `HH!`. HH! computes derivatives for membrane potential and gating variables, compatible with DifferentialEquations.jl's API. Requires all model parameters and initial states to be provided as inputs.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\nusing Plots\n\n# Potassium ion-channel rate functions\nalpha_n(v) = (0.02 * (v - 25.0)) / (1.0 - exp((-1.0 * (v - 25.0)) / 9.0))\nbeta_n(v) = (-0.002 * (v - 25.0)) / (1.0 - exp((v - 25.0) / 9.0))\n\n# Sodium ion-channel rate functions\nalpha_m(v) = (0.182 * (v + 35.0)) / (1.0 - exp((-1.0 * (v + 35.0)) / 9.0))\nbeta_m(v) = (-0.124 * (v + 35.0)) / (1.0 - exp((v + 35.0) / 9.0))\n\nalpha_h(v) = 0.25 * exp((-1.0 * (v + 90.0)) / 12.0)\nbeta_h(v) = (0.25 * exp((v + 62.0) / 6.0)) / exp((v + 90.0) / 12.0)\n\nfunction HH!(du, u, p, t)\n    gK, gNa, gL, EK, ENa, EL, C, I = p\n    v, n, m, h = u\n\n    du[1] = (-(gK * (n^4.0) * (v - EK)) - (gNa * (m^3.0) * h * (v - ENa)) -\n             (gL * (v - EL)) + I) / C\n    du[2] = (alpha_n(v) * (1.0 - n)) - (beta_n(v) * n)\n    du[3] = (alpha_m(v) * (1.0 - m)) - (beta_m(v) * m)\n    du[4] = (alpha_h(v) * (1.0 - h)) - (beta_h(v) * h)\nend\n```\n\n----------------------------------------\n\nTITLE: Defining an In-Place Lorenz System for Non-Allocating ODEs in Julia\nDESCRIPTION: Defines the Lorenz ODEs in-place, mutating the du output array to avoid allocations. This is the preferred form for DifferentialEquations.jl for performance. Input: du (output derivative), u (state), p (parameters), t (time); no return value (returns nothing). All allocations for derivatives are avoided, resulting in significant performance gains. No extra dependencies.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nfunction lorenz!(du, u, p, t)\n    du[1] = 10.0 * (u[2] - u[1])\n    du[2] = u[1] * (28.0 - u[3]) - u[2]\n    du[3] = u[1] * u[2] - (8 / 3) * u[3]\n    nothing\nend\n```\n\n----------------------------------------\n\nTITLE: Invoking Differential Equation Solvers with SciMLBase in Julia\nDESCRIPTION: Demonstrates the usage of the solve function from SciMLBase to solve differential equation problems, supporting arbitrary positional and keyword arguments. Dependencies include SciMLBase and an appropriate DEProblem instance. Key parameters: `prob` (the differential equation problem), `args...` (any additional arguments such as initial values or methods), and `kwargs...` (keyword arguments for configuring solver behaviors like tolerances or algorithms). Input is a SciMLBase.DEProblem instance, and outputs the solution object. Some options may depend on specific solver or problem types.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/common_solver_opts.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nsolve(prob::SciMLBase.DEProblem,args...;kwargs...)\n```\n\n----------------------------------------\n\nTITLE: Terminating ODE Integration Precisely with ContinuousCallback in Julia\nDESCRIPTION: Shows how to terminate an ODE integration exactly when a condition is met using a `ContinuousCallback`. The condition `u[2] == 0` detects the moment velocity crosses zero. The `affect!` function calls `terminate!(integrator)` to stop the simulation at the root-found time. The solution is plotted.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_39\n\nLANGUAGE: julia\nCODE:\n```\ncondition(u, t, integrator) = u[2]\naffect!(integrator) = terminate!(integrator)\ncb = ContinuousCallback(condition, affect!)\nsol = solve(prob, Tsit5(), callback = cb)\nusing Plots;\nplot(sol);\n```\n\n----------------------------------------\n\nTITLE: Parametric Construction of ODE Problem with Functional Initial Conditions and Time Span - DifferentialEquations.jl - Julia\nDESCRIPTION: This example shows how to construct an ODEProblem where both the initial condition and time span are defined as functions of parameters. It imports DifferentialEquations.jl, then creates an ODEProblem where the right-hand side, initial condition, and time span adapt to the problem's parameters. Key parameters: `p` is a tuple or array containing problem-specific values. The design allows programmatic or batch construction of families of problems where initial conditions and time windows change according to user input or outer simulation contexts. Inputs are the function, initial condition function, time span function, and a tuple of parameters; output is an ODEProblem struct.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/problem.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\nprob = ODEProblem((u, p, t) -> u, (p, t0) -> p[1], (p) -> (0.0, p[2]), (2.0, 1.0))\n```\n\n----------------------------------------\n\nTITLE: Solving SDEs with Algorithm Selection - DifferentialEquations.jl - Julia\nDESCRIPTION: This code demonstrates how to solve a stochastic differential equation (SDE) problem using the DifferentialEquations.jl library. By invoking the solve function with an algorithm such as SRIW1, users can select the appropriate method based on properties of their SDE (e.g., stiffness, noise type) as documented above. Required dependencies include DifferentialEquations.jl and a problem definition (prob). The main parameter, prob, should be an SDEProblem object, and SRIW1() selects the solver algorithm with strong order 1.5 and weak order 2.0 for diagonal/scalar Ito SDEs. The solution object, sol, contains the computed solution trajectory. This usage presumes proper problem setup and installation of the relevant package.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/sde_solve.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, SRIW1())\n```\n\n----------------------------------------\n\nTITLE: Defining and Randomizing ODE Problems - DifferentialEquations.jl - Julia\nDESCRIPTION: Defines a linear first-order ODEProblem with initial value 0.5 and a custom problem randomization function. The prob_func introduces stochasticity by modifying the initial condition for ensemble solves. Assumes DifferentialEquations.jl is loaded and ODEProblem/remake are in scope. Returns a randomized problem on each call, with initial state sampled from uniform random scaling of the original u0.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_27\n\nLANGUAGE: julia\nCODE:\n```\n# Linear ODE which starts at 0.5 and solves from t=0.0 to t=1.0\nprob = ODEProblem((u, p, t) -> 1.01u, 0.5, (0.0, 1.0))\n\nfunction prob_func(prob, i, repeat)\n    remake(prob, u0 = rand() * prob.u0)\nend\n```\n\n----------------------------------------\n\nTITLE: Terminating ODE Integration on Downcrossing Event using ContinuousCallback (Julia)\nDESCRIPTION: Configures a `ContinuousCallback` to terminate the integration only when the condition function (`u[2]`) crosses zero from positive to negative (a downcrossing). This is achieved by providing the `terminate!` affect only for the second argument (`affect_neg!`) of `ContinuousCallback`, leaving the upcrossing affect (`affect_pos!`) as `nothing`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_42\n\nLANGUAGE: julia\nCODE:\n```\ncondition(u, t, integrator) = u[2]\naffect!(integrator) = terminate!(integrator)\ncb = ContinuousCallback(condition, nothing, affect!)\nsol = solve(prob, Tsit5(), callback = cb)\nplot(sol)\n```\n\n----------------------------------------\n\nTITLE: Stiff Solvers Rosenbrock23/TRBDF2 for High Tolerances in Julia\nDESCRIPTION: `Rosenbrock23` or `TRBDF2` are recommended for stiff problems at high tolerances (>1e-2). `Rosenbrock23` is efficient for small systems, while `TRBDF2` is better for larger systems.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\nRosenbrock23\n```\n\nLANGUAGE: julia\nCODE:\n```\nTRBDF2\n```\n\n----------------------------------------\n\nTITLE: Translating MATLAB/Python/R ODE Solvers to Julia Equivalents\nDESCRIPTION: Provides a mapping from common ODE solvers found in MATLAB, Python (SciPy), and R to their counterparts or recommended alternatives in Julia's DifferentialEquations.jl. Often suggests more efficient Julia-native methods.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_25\n\nLANGUAGE: text\nCODE:\n```\nMATLAB/Python/R  --> Julia (DifferentialEquations.jl)\n-------------------------------------------------------------\node23              --> BS3()\node45/dopri5       --> DP5() (or Tsit5() - often more efficient)\node23s             --> Rosenbrock23() (or Rodas5P() - often more efficient)\node113            --> VCABM() (or Vern7() - often more efficient)\ndop853             --> DP8() (or Vern7() - often more efficient)\node15s/vode        --> QNDF() / FBDF() (or Rodas5P(), KenCarp4(), TRBDF2(), RadauIIA5() - often more efficient)\node23t             --> Trapezoid()\node23tb            --> TRBDF2()\nlsoda              --> lsoda() (or AutoTsit5(Rosenbrock23()), AutoVern7(Rodas5()) - potentially more efficient)\node15i (DAE)      --> IDA() / DFBDF() (or Rodas5P() - if applicable and often more efficient)\n```\n\n----------------------------------------\n\nTITLE: Defining and Solving the Stiff Robertson System In-Place with Plotting (Julia)\nDESCRIPTION: Defines the stiff Robertson ODEs in in-place form, specifying reaction rates parameters. Sets up the ODEProblem, solves it, and plots the solution (log scale x-axis). Inputs: rober! (mutates du), initial condition, tspan, parameter vector. Dependencies: DifferentialEquations.jl, Plots.jl. Output: solution plot. Demonstrates proper stiff ODE handling.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\nusing Plots\nfunction rober!(du, u, p, t)\n    y\\u2081, y\\u2082, y\\u2083 = u\n    k\\u2081, k\\u2082, k\\u2083 = p\n    du[1] = -k\\u2081 * y\\u2081 + k\\u2083 * y\\u2082 * y\\u2083\n    du[2] = k\\u2081 * y\\u2081 - k\\u2082 * y\\u2082^2 - k\\u2083 * y\\u2082 * y\\u2083\n    du[3] = k\\u2082 * y\\u2082^2\n    nothing\nend\nprob = ODEProblem(rober!, [1.0, 0.0, 0.0], (0.0, 1e5), [0.04, 3e7, 1e4])\nsol = solve(prob)\nplot(sol, tspan = (1e-2, 1e5), xscale = :log10)\n```\n\n----------------------------------------\n\nTITLE: Defining an In-Place ODE Function for Lorenz System - DifferentialEquations.jl - Julia\nDESCRIPTION: Defines the Lorenz system as an in-place function, updating the result vector directly to optimize performance by reducing memory allocation. No explicit dependencies, but intended for use with DifferentialEquations.jl ODE solvers. Accepts the derivative array `du`, state vector `u`, ignored parameters `p`, and time `t` (unused here). Updates `du` with the Lorenz system derivatives for three coupled variables. Inputs: `du` (output array), `u` (state), `p` (unused), `t` (unused). No constraints apart from correct array sizes.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/getting_started.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nfunction lorenz!(du, u, p, t)\n    du[1] = 10.0 * (u[2] - u[1])\n    du[2] = u[1] * (28.0 - u[3]) - u[2]\n    du[3] = u[1] * u[2] - (8 / 3) * u[3]\nend\n```\n\n----------------------------------------\n\nTITLE: Defining and Solving a Nonhomogeneous ODE (Pendulum with External Torque) - DifferentialEquations.jl - Julia\nDESCRIPTION: Implements a driven pendulum ODE with time-varying torque as a parameter. Uses DifferentialEquations.jl and Plots.jl. Defines pendulum constants (`l`, `m`, `g`), an in-place function `pendulum!`, initial conditions (`Î¸â`, `Ïâ`, `uâ`), a time-varying torque `M`, and ODEProblem setup and solution. Demonstrates plotting both positional and velocity components using subplot layout. Required dependencies: DifferentialEquations, Plots.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/getting_started.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\nusing Plots\n\nl = 1.0                             # length [m]\nm = 1.0                             # mass [kg]\ng = 9.81                            # gravitational acceleration [m/sÂ²]\n\nfunction pendulum!(du, u, p, t)\n    du[1] = u[2]                    # Î¸'(t) = Ï(t)\n    du[2] = -3g / (2l) * sin(u[1]) + 3 / (m * l^2) * p(t) # Ï'(t) = -3g/(2l) sin Î¸(t) + 3/(ml^2)M(t)\nend\n\nÎ¸â = 0.01                           # initial angular deflection [rad]\nÏâ = 0.0                            # initial angular velocity [rad/s]\nuâ = [Î¸â, Ïâ]                       # initial state vector\ntspan = (0.0, 10.0)                  # time interval\n\nM = t -> 0.1sin(t)                    # external torque [Nm]\n\nprob = ODEProblem(pendulum!, uâ, tspan, M)\nsol = solve(prob)\n\nplot(sol, linewidth = 2, xaxis = \"t\", label = [\"Î¸ [rad]\" \"Ï [rad/s]\"], layout = (2, 1))\n```\n\n----------------------------------------\n\nTITLE: Accessing and Interpolating ODE Solution Data in Julia\nDESCRIPTION: These snippets show how to interact with the solution object (`sol`) returned by `solve`. You can access the solution value at a specific saved step using index notation (`sol[5]`), get the time point of a specific step (`sol.t[8]`), iterate over solution tuples (`tuples(sol)` or `zip(sol.u, sol.t)`), and evaluate the continuous solution at an arbitrary time `t` using interpolation (`sol(0.45)`).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/getting_started.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nsol[5]\n```\n\nLANGUAGE: julia\nCODE:\n```\nsol.t[8]\n```\n\nLANGUAGE: julia\nCODE:\n```\n[t + u for (u, t) in tuples(sol)]\n```\n\nLANGUAGE: julia\nCODE:\n```\n[t + 2u for (u, t) in zip(sol.u, sol.t)]\n```\n\nLANGUAGE: julia\nCODE:\n```\nsol(0.45) # The value of the solution at t=0.45\n```\n\n----------------------------------------\n\nTITLE: Defining and Solving a Mass-Matrix DAE with DifferentialEquations.jl in Julia\nDESCRIPTION: This snippet sets up and solves the Robertson equation as a mass-matrix differential algebraic equation using DifferentialEquations.jl. It defines the right-hand side function, the singular mass matrix, constructs the ODEProblem, and solves it with a DAE-compatible solver (Rodas5). Required dependencies are DifferentialEquations.jl and Plots.jl; parameters include initial values, time span, and reaction rate constants. The output is a solution object suitable for plotting, and the system assumes singular mass matrix setup.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/dae_example.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\nusing Plots\nfunction rober(du, u, p, t)\n    yâ, yâ, yâ = u\n    kâ, kâ, kâ = p\n    du[1] = -kâ * yâ + kâ * yâ * yâ\n    du[2] = kâ * yâ - kâ * yâ * yâ - kâ * yâ^2\n    du[3] = yâ + yâ + yâ - 1\n    nothing\nend\nM = [1.0 0 0\n     0 1.0 0\n     0 0 0]\nf = ODEFunction(rober, mass_matrix = M)\nprob_mm = ODEProblem(f, [1.0, 0.0, 0.0], (0.0, 1e5), (0.04, 3e7, 1e4))\nsol = solve(prob_mm, Rodas5(), reltol = 1e-8, abstol = 1e-8)\n\nplot(sol, xscale = :log10, tspan = (1e-6, 1e5), layout = (3, 1))\n```\n\n----------------------------------------\n\nTITLE: General Syntax for Remaking DifferentialEquations.jl Problems - Julia\nDESCRIPTION: This snippet provides the canonical syntax for remaking or modifying immutable problem structs in DifferentialEquations.jl. The `remake` function is used to create a copy of an existing problem with specified fields replaced. It supports any number of keyword arguments, each mapping a field name to a new value. Dependencies: DifferentialEquations.jl. Inputs: base problem and arbitrary keyword arguments; output: a new problem with updated field values. Useful for scripting repetitive modifications or batch processing variants of a problem.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/problem.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nmodified_problem = remake(original_problem;\n    field_1 = value_1,\n    field_2 = value_2,\n    ...)\n```\n\n----------------------------------------\n\nTITLE: Setting Up the ODEProblem with Initial Conditions and Parameters in Julia\nDESCRIPTION: Initializes the state vector `u0 = [10.0; 10.0]`, the initial parameter value `p = 0.0`, and constructs the `ODEProblem` for the control example. It bundles the ODE function `f`, the initial state `u0`, the simulation time span `(0.0, 10.0)`, and the initial parameter `p`. This `prob` object encapsulates the entire problem definition needed by the solver. Requires `DifferentialEquations`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\n```@example callback2\nu0 = [10.0; 10.0]\np = 0.0\nprob = ODEProblem(f, u0, (0.0, 10.0), p)\n```\n```\n\n----------------------------------------\n\nTITLE: Solving Radioactive Decay ODE with OrdinaryDiffEq.jl in Julia\nDESCRIPTION: This Julia code snippet demonstrates how to solve the first-order linear ODE representing Carbon-14 radioactive decay using `OrdinaryDiffEq.jl`. It sets up the problem with the half-life, defines the differential equation `radioactivedecay`, solves it using the `Tsit5` algorithm via `ODEProblem` and `solve`, and plots the numerical result against the known analytical solution using `Plots.jl`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/classical_physics.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nusing OrdinaryDiffEq, Plots\ngr()\n\n#Half-life of Carbon-14 is 5,730 years.\ntÂ½ = 5.730\n\n#Setup\nuâ = 1.0\ntspan = (0.0, 30.0)\n\n#Define the problem\nradioactivedecay(u, p, t) = -log(2) / tÂ½ * u\n\n#Pass to solver\nprob = ODEProblem(radioactivedecay, uâ, tspan)\nsol = solve(prob, Tsit5())\n\n#Plot\nplot(sol, linewidth = 2, title = \"Carbon-14 half-life\",\n    xaxis = \"Time in thousands of years\", yaxis = \"Ratio left\",\n    label = \"Numerical Solution\")\nplot!(sol.t, t -> 2^(-t / tÂ½), lw = 3, ls = :dash, label = \"Analytical Solution\")\n```\n\n----------------------------------------\n\nTITLE: Fast Non-Stiff Solvers BS3/OwrenZen3 for High Tolerances in Julia\nDESCRIPTION: `BS3` is recommended for fast solving of non-stiff problems at higher tolerances. `OwrenZen3` is an alternative if the interpolation error is important.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nBS3\n```\n\nLANGUAGE: julia\nCODE:\n```\nOwrenZen3\n```\n\n----------------------------------------\n\nTITLE: Defining ODE for Bouncing Ball (Julia)\nDESCRIPTION: This Julia function `f` defines the system of ordinary differential equations for a bouncing ball. `du[1]` represents the change in height (which is the velocity `u[2]`), and `du[2]` represents the change in velocity (which is the constant acceleration due to gravity `-p`).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_25\n\nLANGUAGE: julia\nCODE:\n```\nfunction f(du, u, p, t)\n    du[1] = u[2]\n    du[2] = -p\nend\n```\n\n----------------------------------------\n\nTITLE: Comparing Numerical and Analytical Solutions with SDEFunction in Julia\nDESCRIPTION: This snippet shows how to define an analytical solution for a scalar SDE, wrap it in an SDEFunction for comparison, and build the associated problem. It demonstrates the analytic keyword for SDEFunction and redefines the problem so the solver can access the analytic result. Dependencies include DifferentialEquations.jl. Inputs are analytic, drift, and diffusion functions along with initial data and time span. Output is a configured SDEProblem.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/sde_example.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nu_analytic(uâ, p, t, W) = uâ * exp((Î± - (Î²^2) / 2) * t + Î² * W)\nff = SDEFunction(f, g, analytic = u_analytic)\nprob = SDEProblem(ff, uâ, (0.0, 1.0))\n```\n\n----------------------------------------\n\nTITLE: Interpolated Solution for a Single Component - SciMLBase - Julia\nDESCRIPTION: Extracts the interpolated value for a single component at a specified time by passing a single index to the 'idxs' keyword, returning a Number instead of an array. Useful for efficient retrieval of a specific component's value.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/solution.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nsol(t, idxs = 1)\n```\n\n----------------------------------------\n\nTITLE: Declaring a Sparse Jacobian in ODEFunction Using jac_prototype in DifferentialEquations.jl (Julia)\nDESCRIPTION: This code shows how to instantiate an ODEFunction with a user-supplied sparse Jacobian structure by passing a jac_prototype matrix obtained from automatic sparsity detection. Utilizing float.(jac_sparsity) ensures type compatibility. The resulting ODEFunction can be supplied to ODEProblem for improved solver performance. Dependencies are DifferentialEquations.jl and a compatible jac_sparsity matrix.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/advanced_ode_example.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nf = ODEFunction(brusselator_2d_loop; jac_prototype = float.(jac_sparsity))\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Parameterized ODE System in Julia\nDESCRIPTION: Defines a parameterized ordinary differential equation (ODE) system `f` in Julia for a control problem example. The system depends on the state vector `u`, time `t`, and a parameter `p`. The equations `du[1] = -0.5 * u[1] + p` and `du[2] = -0.5 * u[2]` describe the rates of change for two state variables, where the first equation is influenced by the parameter `p`. Requires `DifferentialEquations`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\n```@example callback2\nfunction f(du, u, p, t)\n    du[1] = -0.5 * u[1] + p\n    du[2] = -0.5 * u[2]\nend\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring and Solving ODEs with ExtrapolationMidpointDeuflhard in Julia (OrdinaryDiffEq.jl)\nDESCRIPTION: This snippet demonstrates how to construct and configure the ExtrapolationMidpointDeuflhard algorithm with custom extrapolation order, initialization order, sequence, and threading control parameters, and then solve an ODE problem using these settings. It requires the `OrdinaryDiffEq.jl` package and a defined `prob` ODEProblem. The main parameters are `max_order`, `min_order`, `init_order`, `sequence`, and `threading`, impacting step adaptivity, computational cost, and parallelism. Input is an ODE problem, and the output is the computed solution; limitations include the requirement that function `f` in the problem be thread safe if parallel evaluation is desired.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_31\n\nLANGUAGE: julia\nCODE:\n```\nalg = ExtrapolationMidpointDeuflhard(max_order = 7, min_order = 4, init_order = 4,\\n    sequence = :bulirsch, threading = false)\\nsolve(prob, alg)\\n\n```\n\n----------------------------------------\n\nTITLE: Simplified Non-Stiff Solvers for Small ODEs in Julia\nDESCRIPTION: `SimpleATsit5()`, `GPUVern7()`, or `GPUVern9()` are simplified implementations (available in the `SimpleDiffEq` package) recommended for very small non-stiff ODEs to reduce overhead. `GPUVern7/9` are suitable for GPU execution.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nSimpleATsit5()\n```\n\nLANGUAGE: julia\nCODE:\n```\nGPUVern7()\n```\n\nLANGUAGE: julia\nCODE:\n```\nGPUVern9()\n```\n\n----------------------------------------\n\nTITLE: Defining Right-Hand Side (RHS) Function for Explicit Terms in Julia\nDESCRIPTION: Defines the `rhs!` function required by the `SplitODEProblem` solver. This function calculates the explicit part of the time derivative `dT/dt`, which includes the volumetric source term `S(z)` evaluated at face coordinates `zf` and the pre-calculated boundary source terms `AT_b` for the interior domain (indices `1` to `n`). It modifies the `dT` vector in place. Depends on function `S`, variables `zf`, `AT_b`, and parameter `n` passed via `params`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/diffusion_implicit_heat_equation.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\nfunction rhs!(dT, T, params, t)\n    n = params.n\n    i = 1:n # interior domain\n    dT[i] .= S.(zf[i]) .+ AT_b[i]\n    return dT\nend;\n```\n\n----------------------------------------\n\nTITLE: Defining Double Pendulum ODE Problem in Julia\nDESCRIPTION: Sets up the Ordinary Differential Equation (ODE) problem for a double pendulum using its Hamiltonian formulation. It defines initial conditions, the time span, and the differential equation function `double_pendulum_hamiltonian`. Finally, it constructs an `ODEProblem` object using `OrdinaryDiffEq.jl`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/min_and_max.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n#Constants and setup\nusing OrdinaryDiffEq\ninitial = [0.01, 0.01, 0.01, 0.01]\ntspan = (0.0, 100.0)\n\n#Define the problem\nfunction double_pendulum_hamiltonian(udot, u, p, t)\n    Î± = u[1]\n    lÎ± = u[2]\n    Î² = u[3]\n    lÎ² = u[4]\n    udot .= [2(lÎ± - (1 + cos(Î²))lÎ²) / (3 - cos(2Î²)),\n        -2sin(Î±) - sin(Î± + Î²),\n        2(-(1 + cos(Î²))lÎ± + (3 + 2cos(Î²))lÎ²) / (3 - cos(2Î²)),\n        -sin(Î± + Î²) - 2sin(Î²) * (((lÎ± - lÎ²)lÎ²) / (3 - cos(2Î²))) +\n        2sin(2Î²) * ((lÎ±^2 - 2(1 + cos(Î²))lÎ± * lÎ² + (3 + 2cos(Î²))lÎ²^2) / (3 - cos(2Î²))^2)]\nend\n\n#Pass to solvers\npoincare = ODEProblem(double_pendulum_hamiltonian, initial, tspan)\n```\n\n----------------------------------------\n\nTITLE: Referencing DiscreteCallback Documentation in Julia Docs\nDESCRIPTION: Uses the `@docs` macro within Julia's documentation system (Documenter.jl) to automatically insert the documentation for the `DiscreteCallback` type from DifferentialEquations.jl at this location in the generated documentation.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nDiscreteCallback\n```\n```\n\n----------------------------------------\n\nTITLE: Solving an ODE Problem with Various Options in Julia\nDESCRIPTION: These snippets illustrate different ways to call the `solve` function on a pre-defined `ODEProblem` (`prob`). Examples include using the default solver, specifying relative tolerance (`reltol`), controlling output saving frequency (`saveat`) or disabling intermediate saving (`save_everystep=false`), providing algorithm hints (`alg_hints`), and explicitly choosing a solver algorithm like `Tsit5()`. Options can be combined.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/getting_started.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob)\n```\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, reltol = 1e-6)\n```\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, reltol = 1e-6, saveat = 0.1)\n```\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, reltol = 1e-6, save_everystep = false)\n```\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, alg_hints = [:stiff], reltol = 1e-8, abstol = 1e-8)\n```\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, Tsit5())\n```\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, Tsit5(), reltol = 1e-8, abstol = 1e-8)\n```\n\n----------------------------------------\n\nTITLE: Customizing Plot Backend and Title in Plots.jl in Julia\nDESCRIPTION: This snippet shows how to switch the plotting backend to GR and set a custom title for the plot in Plots.jl. Dependencies: Plots.jl, GR (optional, auto-installed with Plots.jl). Inputs: a solution object. Outputs: a plot rendered using GR with a customized title. The gr() command switches the backend, and keyword arguments allow further customization.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/plot.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\ngr()\nplot(sol, title = \"I Love DiffEqs!\")\n```\n\n----------------------------------------\n\nTITLE: Controlling Lazy Interpolation with Vern7 Solver in Julia\nDESCRIPTION: Illustrates how to use the `Vern7` solver, which features a lazy interpolant. The first example shows the default usage (lazy interpolation enabled). The second example explicitly disables lazy interpolation using `lazy = false`, which is necessary if parameters might change between solving and interpolation, for example, within callbacks.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_28\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nsolve(prob, Vern7()) # lazy by default\nsolve(prob, Vern7(lazy = false))\n```\n```\n\n----------------------------------------\n\nTITLE: Specifying Custom Tableau Runge-Kutta Methods in Julia\nDESCRIPTION: Shows how to instantiate and use an ExplicitRK solver with a specified Runge-Kutta tableau, such as Dormand-Prince, for general-purpose ODE solving in Julia. Requires DifferentialEquations.jl and access to supplied tableau constructors (e.g., `constructDormandPrince`). The main parameter is the `tableau` setting, which allows for flexibility in choosing the integrator structure. Expects an ODE problem and produces solution objects compatible with the standard SciML solver interface.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_34\n\nLANGUAGE: julia\nCODE:\n```\nalg = ExplicitRK(tableau = constructDormandPrince())\nsolve(prob, alg)\n```\n\n----------------------------------------\n\nTITLE: Importing the Full DifferentialEquations.jl Package in Julia\nDESCRIPTION: Demonstrates the standard way to import the entire DifferentialEquations.jl suite of tools. This brings in all solvers, callbacks, and utilities provided by the umbrella package.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/low_dep.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\n```\n\n----------------------------------------\n\nTITLE: Loading Full Solution Object using BSON.jl in Julia\nDESCRIPTION: Demonstrates the necessary setup for loading a DifferentialEquations.jl solution object saved with BSON.jl. Similar to JLD2, relevant packages like `OrdinaryDiffEq` must be loaded first. The example notes a known issue (`https://github.com/JuliaIO/BSON.jl/issues/109`) preventing successful loading at the time of writing. Requires `OrdinaryDiffEq` and `BSON`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/io.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\n# New session\nusing OrdinaryDiffEq\nusing BSON\n# BSON.load(\"test.bson\") # currently broken: https://github.com/JuliaIO/BSON.jl/issues/109\n```\n\n----------------------------------------\n\nTITLE: Generating Phase Space Plot for Simple Pendulum in Julia\nDESCRIPTION: This Julia snippet demonstrates generating a phase space plot (angular position vs. angular velocity) for the simple pendulum using `Plots.jl` and `OrdinaryDiffEq.jl`. It first plots the trajectory for a single initial condition, then defines a helper function `phase_plot` to solve the ODE for various initial states using the `Vern9` solver and overlay these trajectories onto the initial plot, creating a comprehensive phase portrait.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/classical_physics.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\np = plot(sol, vars = (1, 2), xlims = (-9, 9), title = \"Phase Space Plot\",\n    xaxis = \"Angular position\", yaxis = \"Angular velocity\", leg = false)\nfunction phase_plot(prob, u0, p, tspan = 2pi)\n    _prob = ODEProblem(prob.f, u0, (0.0, tspan))\n    sol = solve(_prob, Vern9()) # Use Vern9 solver for higher accuracy\n    plot!(p, sol, idxs = (1, 2), xlims = nothing, ylims = nothing)\nend\nfor i in (-4pi):(pi / 2):(4Ï)\n    for j in (-4pi):(pi / 2):(4Ï)\n        phase_plot(prob, [j, i], p)\n    end\nend\nplot(p, xlims = (-9, 9))\n```\n\n----------------------------------------\n\nTITLE: Plotting the Lorenz System Solution and Projections with Plots.jl in Julia\nDESCRIPTION: This example builds and solves the Lorenz system using DifferentialEquations.jl, generating solution plots of the full trajectory and various projections (xy, xz, yz, xyz) with a high plot density. It finishes by assembling a multi-panel plot layout. Dependencies: DifferentialEquations.jl, Plots.jl. Inputs: problem definition, parameter set, dense plot settings, idxs for projections. Outputs: multiple customized plots and combined layouts.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/plot.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations, Plots\nfunction lorenz(du, u, p, t)\n    du[1] = p[1] * (u[2] - u[1])\n    du[2] = u[1] * (p[2] - u[3]) - u[2]\n    du[3] = u[1] * u[2] - p[3] * u[3]\nend\n\nu0 = [1.0, 5.0, 10.0]\ntspan = (0.0, 100.0)\np = (10.0, 28.0, 8 / 3)\nprob = ODEProblem(lorenz, u0, tspan, p)\nsol = solve(prob)\nxyzt = plot(sol, plotdensity = 10000, lw = 1.5)\nxy = plot(sol, plotdensity = 10000, idxs = (1, 2))\nxz = plot(sol, plotdensity = 10000, idxs = (1, 3))\nyz = plot(sol, plotdensity = 10000, idxs = (2, 3))\nxyz = plot(sol, plotdensity = 10000, idxs = (1, 2, 3))\nplot(plot(xyzt, xyz), plot(xy, xz, yz, layout = (1, 3), w = 1), layout = (2, 1))\n```\n\n----------------------------------------\n\nTITLE: Advancing Integrator Step Using step! in SciMLBase (Julia)\nDESCRIPTION: Performs a single successful integration step with the initialized integrator. Invokes the step! method, which mutates the integrator's current state. Requires an integrator previously initialized with init().\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/integrator.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nstep!(integrator)\n```\n\n----------------------------------------\n\nTITLE: Solving a Parameterized ODE with Multiple Callbacks and tstops in Julia\nDESCRIPTION: Solves the parameterized `ODEProblem` (`prob`) for the control example using the `Tsit5()` solver. It passes the combined `CallbackSet` (`cbs`) using the `callback` argument to handle parameter changes. Crucially, it provides `tstops = [5.0; 8.0]` to ensure the solver steps exactly at the times when the callbacks should trigger. The solution trajectory, showing the effect of the parameter changes, is then plotted using `Plots`. Requires `DifferentialEquations` and `Plots`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_17\n\nLANGUAGE: julia\nCODE:\n```\n```@example callback2\nconst tstop = [5.0; 8.0]\nsol = solve(prob, Tsit5(), callback = cbs, tstops = tstop)\nusing Plots;\nplot(sol);\n```\n```\n\n----------------------------------------\n\nTITLE: Declaring an In-Place ODE Problem - DifferentialEquations.jl - Julia\nDESCRIPTION: This snippet demonstrates how to explicitly create an Ordinary Differential Equation (ODE) problem marked as \"in-place\" using DifferentialEquations.jl. By specifying ODEProblem{true}, the user signals that the provided function mutates its first argument instead of returning a new value. This is important for performance and compatibility, especially for mutable arrays. Dependencies: DifferentialEquations.jl. Parameters include the right-hand side function (`f`), the initial condition (`u0`), the time span (`tspan`), and parameters (`p`). The construct allows fine control over function call semantics.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/problem.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nODEProblem{true}(f, u0, tspan, p)\n```\n\n----------------------------------------\n\nTITLE: Defining the LIF Model Differential Equation in Julia\nDESCRIPTION: Defines the `lif` function representing the core differential equation for the Leaky Integrate-and-Fire neuron model. It calculates the rate of change of membrane potential (`u`) based on leak conductance (`gL`), equilibrium potential (`EL`), membrane capacitance (`C`), and input current (`I`). Designed for use with DifferentialEquations.jl solvers, taking state `u`, parameters `p`, and time `t` as input. Requires `DifferentialEquations`, `ComponentArrays`, and `Plots` to be imported.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\nusing ComponentArrays\nusing Plots\ngr()\n\nfunction lif(u, p, t)\n    gL, EL, C, Vth, I = p\n    (-gL * (u - EL) + I) / C\nend\n```\n\n----------------------------------------\n\nTITLE: Solving Simple Harmonic Oscillator with SecondOrderODEProblem in Julia\nDESCRIPTION: This Julia code snippet illustrates solving the second-order linear ODE for a simple harmonic oscillator using `OrdinaryDiffEq.jl`. It defines parameters, initial conditions, and the second-order ODE function `harmonicoscillator`. It utilizes `SecondOrderODEProblem` and solves it with the `DPRKN6` method, plotting both displacement and velocity alongside their analytical counterparts using `Plots.jl`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/classical_physics.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n# Simple Harmonic Oscillator Problem\nusing OrdinaryDiffEq, Plots\n\n#Parameters\nÏ = 1\n\n#Initial Conditions\nxâ = [0.0]\ndxâ = [Ï / 2]\ntspan = (0.0, 2Ï)\n\nÏ = atan((dxâ[1] / Ï) / xâ[1])\nA = â(xâ[1]^2 + dxâ[1]^2)\n\n#Define the problem\nfunction harmonicoscillator(ddu, du, u, Ï, t)\n    ddu .= -Ï^2 * u\nend\n\n#Pass to solvers\nprob = SecondOrderODEProblem(harmonicoscillator, dxâ, xâ, tspan, Ï)\nsol = solve(prob, DPRKN6())\n\n#Plot\nplot(sol, idxs = [2, 1], linewidth = 2, title = \"Simple Harmonic Oscillator\",\n    xaxis = \"Time\", yaxis = \"Elongation\", label = [\"x\" \"dx\"])\nplot!(t -> A * cos(Ï * t - Ï), lw = 3, ls = :dash, label = \"Analytical Solution x\")\nplot!(t -> -A * Ï * sin(Ï * t - Ï), lw = 3, ls = :dash, label = \"Analytical Solution dx\")\n```\n\n----------------------------------------\n\nTITLE: Solving the ODE Problem with GPU-Accelerated Model in Julia\nDESCRIPTION: This example demonstrates how to initialize and solve an ODEProblem using the custom BeelerReuterGpu model with GPU acceleration, and Sundials' CVODE_BDF for time integration. It uses Julia's DifferentialEquations and Sundials libraries to create the problem, set initial conditions, and solve, timing the computation for benchmarking. Prerequisites include properly defined u0 and GPU/kernel setup. Outputs the computed solution object sol. Key parameters include the linear_solver (here :GMRES) used internally by Sundials.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/beeler_reuter.md#_snippet_18\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations, Sundials\n\nderiv_gpu = BeelerReuterGpu(u0, 1.0);\nprob = ODEProblem(deriv_gpu, u0, (0.0, 50.0));\n@time sol = solve(prob, CVODE_BDF(linear_solver = :GMRES), saveat = 100.0);\n```\n\n----------------------------------------\n\nTITLE: Accessing Solution Time by Index - SciMLBase - Julia\nDESCRIPTION: Shows how to obtain the time value corresponding to a specific index in the solution object. 'sol.t' is an array of timesteps, and this expression returns the j-th time value. Requires only that the solution object supports the 't' field.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/solution.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nsol.t[j]\n```\n\n----------------------------------------\n\nTITLE: Configuring and Running Ensemble Problems with Batch Reduction - DifferentialEquations.jl - Julia\nDESCRIPTION: Shows setting up an EnsembleProblem with custom problem and output functions, and a reduction for batching. Uses Tsit5() as ODE solver, with 10,000 trajectories and batch_size=20. Solutions are processed in batches for performance, checking convergence every batch. Demonstrates interaction between problem definition, ensemble setup, reduction logic, and large-scale simulation.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_29\n\nLANGUAGE: julia\nCODE:\n```\nprob2 = EnsembleProblem(prob, prob_func = prob_func, output_func = output_func,\n    reduction = reduction, u_init = Vector{Float64}())\nsim = solve(prob2, Tsit5(), trajectories = 10000, batch_size = 20)\n```\n\n----------------------------------------\n\nTITLE: ODE Problem with StaticArrays for Stack Allocation - DifferentialEquations.jl - Julia\nDESCRIPTION: Uses `StaticArrays.jl` to define system matrices and initial conditions as statically-sized arrays, improving performance for small and fixed-dimension systems by stack-allocating memory. Shows setup, problem definition, solution, and plotting, leveraging the same function structure as dense arrays. Requires StaticArrays, DifferentialEquations, and Plots.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/getting_started.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\nusing StaticArrays\nA = @SMatrix [1.0 0.0 0.0 -5.0\n              4.0 -2.0 4.0 -3.0\n              -4.0 0.0 0.0 1.0\n              5.0 -2.0 2.0 3.0]\nu0 = @SMatrix rand(4, 2)\ntspan = (0.0, 1.0)\nf2(u, p, t) = A * u\nprob = ODEProblem(f2, u0, tspan)\nsol = solve(prob)\nplot(sol)\n```\n\n----------------------------------------\n\nTITLE: Auto-Switching Solver for Unknown Stiffness (Default Tolerances) in Julia\nDESCRIPTION: Recommended auto-switching algorithm `AutoTsit5(Rosenbrock23())` for problems with unknown stiffness at default tolerances. It combines the non-stiff Tsit5 method with the stiff Rosenbrock23 method, allowing efficient solution for either case with minimal overhead.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nAutoTsit5(Rosenbrock23())\n```\n\n----------------------------------------\n\nTITLE: Generating Sparse Jacobian with ModelingToolkit for Sundials in Julia\nDESCRIPTION: This snippet utilizes `ModelingToolkit.jl` to automatically generate a sparse Jacobian function for the Brusselator ODE problem (`prob_ode_brusselator_2d_sparse`). The `modelingtoolkitize` function converts the `ODEProblem`, and `jac=true` and `sparse=true` flags are set to enable sparse Jacobian generation. This prepared problem (`prob_ode_brusselator_2d_mtk`) is suitable for efficient use with Sundials solvers that support sparse Jacobians (like `:KLU`, though the solve call is commented out). Requires `ModelingToolkit.jl` and `DifferentialEquations.jl`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/advanced_ode_example.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nusing ModelingToolkit\nprob_ode_brusselator_2d_mtk = ODEProblem(\n    complete(modelingtoolkitize(prob_ode_brusselator_2d_sparse)),\n    [], (0.0, 11.5), jac = true, sparse = true);\n# @btime solve(prob_ode_brusselator_2d_mtk,CVODE_BDF(linear_solver=:KLU),save_everystep=false); # compiles very slowly\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Defining an Out-of-Place Lorenz System with StaticArrays (Julia)\nDESCRIPTION: Defines the Lorenz system returning a StaticArray (SA[...] macro), enabling statically-allocated, allocation-free derivatives for small systems. Dependency: StaticArrays.jl. Inputs: same as previous, but output is an SVector. Used for fast, heap-free solutions with DifferentialEquations.jl when initial condition is a StaticArray.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nfunction lorenz_static(u, p, t)\n    dx = 10.0 * (u[2] - u[1])\n    dy = u[1] * (28.0 - u[3]) - u[2]\n    dz = u[1] * u[2] - (8 / 3) * u[3]\n    SA[dx, dy, dz]\nend\n```\n\n----------------------------------------\n\nTITLE: Accessing Solution Data by Time Index - SciMLBase - Julia\nDESCRIPTION: Demonstrates how to access the solution value at a specific timestep using array-like syntax. Assumes a solution object (e.g., from an ODE solve) is available. Input is the solution object and the timestep index; output is the saved value at that timestep. No additional dependencies required other than SciMLBase. This is subject to whether the timeseries is saved.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/solution.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nsol[j]\n```\n\n----------------------------------------\n\nTITLE: Defining Dynamical, Hamiltonian, and Second Order ODE Problems in OrdinaryDiffEq.jl (Julia)\nDESCRIPTION: These Julia type constructors specify problems for specialized solvers of structured ODEs. 'DynamicalODEProblem' splits motion equations for velocity and position; 'SecondOrderODEProblem' is for ODEs defined via acceleration; 'HamiltonianProblem' encodes Hamiltonian dynamics. The functions require correct signatures for in-place or out-of-place operations. Inputs include system functions, initial conditions, time span, parameters, and keyword arguments. These are fundamental for leveraging specialized integrators for efficiency and accuracy and must be used in conjunction with the OrdinaryDiffEq.jl package.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/dynamical_solve.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nDynamicalODEProblem{isinplace}(f1, f2, v0, u0, tspan, p = NullParameters(); kwargs...)\nSecondOrderODEProblem{isinplace}(f, du0, u0, tspan, p = NullParameters(); kwargs...)\nHamiltonianProblem{T}(H, p0, q0, tspan, p = NullParameters(); kwargs...)\n```\n\n----------------------------------------\n\nTITLE: Accessing Solution with Multiple Indices - SciMLBase - Julia\nDESCRIPTION: Demonstrates extracting the value at a multi-indexed component and timestep for higher-dimensional systems, where 'sol[i, k, j]' gives the [i, k] component at the j-th timestep. Input is the solution object and indices; output is the solution value at those indices.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/solution.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nsol[i, k, j]\n```\n\n----------------------------------------\n\nTITLE: Retrieving Local Minimum Location in Julia\nDESCRIPTION: Prints the time `t` at which the local minimum was found by the optimization process. This value is stored in the `u` field of the optimization result object `opt`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/min_and_max.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\nprintln(opt.u)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Distributed Parallelism for DifferentialEquations.jl (Julia)\nDESCRIPTION: Initializes distributed parallelism in Julia using `addprocs()` from the `Distributed` package and ensures the `DifferentialEquations` package is loaded on all worker processes using the `@everywhere` macro. This setup prepares the environment for running ensemble simulations in parallel across multiple processes.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\nusing Distributed\nusing DifferentialEquations\nusing Plots\n\naddprocs()\n@everywhere using DifferentialEquations\n```\n\n----------------------------------------\n\nTITLE: Defining and Solving Scalar SDEs with Euler-Maruyama in Julia\nDESCRIPTION: This snippet demonstrates defining a scalar stochastic differential equation via SDEProblem by specifying drift and diffusion functions, initial condition, and time span, and then solving it using the Euler-Maruyama (EM) method. Dependencies include the DifferentialEquations.jl package. Parameters include the drift (f) and diffusion (g) functions, initial value (uâ), time span (tspan), and time step (dt). The output is a numerical solution object which can be plotted. Assumes basic familiarity with Julia syntax.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/sde_example.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\nÎ± = 1\nÎ² = 1\nuâ = 1 / 2\nf(u, p, t) = Î± * u\ng(u, p, t) = Î² * u\ndt = 1 // 2^(4)\ntspan = (0.0, 1.0)\nprob = SDEProblem(f, g, uâ, tspan)\n```\n\n----------------------------------------\n\nTITLE: Solving a Simple Pendulum BVP with General Conditions using MIRK4 in Julia\nDESCRIPTION: This snippet defines a boundary condition function `bc1!` that sets residuals based on the solution `u` at specific times (`pi/4` and `pi/2`). It then constructs a `BVProblem` using the `simplependulum!` ODE, the `bc1!` boundary conditions, an initial guess `[pi/2, pi/2]`, and the time span. Finally, it solves the BVP using the `MIRK4` collocation method with a fixed time step `dt=0.05` and plots the resulting solution.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/bvp_example.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nfunction bc1!(residual, u, p, t)\n    residual[1] = u(pi / 4)[1] + pi / 2 # the solution at the middle of the time span should be -pi/2\n    residual[2] = u(pi / 2)[1] - pi / 2 # the solution at the end of the time span should be pi/2\nend\nbvp1 = BVProblem(simplependulum!, bc1!, [pi / 2, pi / 2], tspan)\nsol1 = solve(bvp1, MIRK4(), dt = 0.05)\nplot(sol1)\n```\n\n----------------------------------------\n\nTITLE: Defining prob_func for Pre-Determined Initial Conditions in Julia\nDESCRIPTION: Defines a Julia function `prob_func` for an `EnsembleProblem` where initial conditions are pre-determined and stored in an array `initial_conditions`. The function uses the trajectory index `i` to select the appropriate initial condition from the array and applies it to the base problem `prob` using `remake` from DifferentialEquations.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_18\n\nLANGUAGE: julia\nCODE:\n```\ninitial_conditions = range(0, stop = 1, length = 100)\nfunction prob_func(prob, i, repeat)\n    remake(prob, u0 = initial_conditions[i])\nend\n```\n\n----------------------------------------\n\nTITLE: Solving HÃ©non-Heiles with DPRKN6 (NystrÃ¶m Method) and Analyzing Energy in Julia\nDESCRIPTION: This snippet solves the `SecondOrderODEProblem` for the HÃ©non-Heiles system using the `DPRKN6` Runge-Kutta-NystrÃ¶m solver, which is specialized for second-order ODEs but not necessarily symplectic. It then calculates the energy drift (`ÎE`) using the previously defined `E` function (adjusting indices for `sol3.u`), displays the drift, sets the plotting backend to `gr()`, and plots the change in energy over time. It demonstrates that specialized non-symplectic methods can still offer good energy conservation, potentially better than high-order general-purpose solvers at default tolerances.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/classical_physics.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\nsol3 = solve(prob, DPRKN6());\nenergy = map(x -> E(x[3], x[4], x[1], x[2]), sol3.u)\n@show ÎE = energy[1] - energy[end]\ngr()\nplot(sol3.t, energy .- energy[1], title = \"Change in Energy over Time\",\n    xaxis = \"Time in iterations\", yaxis = \"Change in Energy\")\n```\n\n----------------------------------------\n\nTITLE: Calculating Cardiac Ion Currents on GPU with CUDA Math Functions in Julia\nDESCRIPTION: These functions implement the computation of various ionic currents (inward-rectifier potassium iK1, background potassium ix1, sodium iNa, and calcium iCa) for a cardiac cell model, adapted for GPU execution by consistently using CUDAnative math routines. Each function receives membrane potential and associated gating variables/concentrations, and returns the calculated current. Required dependencies are CUDA.jl and constants for physical parameters such as conductances and reversal potentials. These routines are meant to be part of GPU kernels or called on CuArrays within a CUDA-aware simulation loop.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/beeler_reuter.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\n# iK1 is the inward-rectifying potassium current\nfunction calc_iK1(v)\n    ea = CUDAnative.exp(0.04f0 * (v + 85.0f0))\n    eb = CUDAnative.exp(0.08f0 * (v + 53.0f0))\n    ec = CUDAnative.exp(0.04f0 * (v + 53.0f0))\n    ed = CUDAnative.exp(-0.04f0 * (v + 23.0f0))\n    return 0.35f0 * (4.0f0 * (ea - 1.0f0) / (eb + ec)\n            +\n            0.2f0 * (isapprox(v, -23.0f0) ? 25.0f0 : (v + 23.0f0) / (1.0f0 - ed)))\nend\n\n# ix1 is the time-independent background potassium current\nfunction calc_ix1(v, xi)\n    ea = CUDAnative.exp(0.04f0 * (v + 77.0f0))\n    eb = CUDAnative.exp(0.04f0 * (v + 35.0f0))\n    return xi * 0.8f0 * (ea - 1.0f0) / eb\nend\n\n# iNa is the sodium current (similar to the classic Hodgkin-Huxley model)\nfunction calc_iNa(v, m, h, j)\n    return C_Na * (g_Na * m^3 * h * j + g_NaC) * (v - ENa)\nend\n\n# iCa is the calcium current\nfunction calc_iCa(v, d, f, c)\n    ECa = D_Ca - 82.3f0 - 13.0278f0 * CUDAnative.log(c)    # ECa is the calcium reversal potential\n    return C_s * g_s * d * f * (v - ECa)\nend\n```\n\n----------------------------------------\n\nTITLE: Indexed History Function with Keyword Argument for DDEs in Julia\nDESCRIPTION: Defines a history function that supports indexed access with the idxs keyword for efficiency. Returns scalar 1.0 if idxs is a Number, otherwise a vector of ones. Used for efficient interpolation in DDEs.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/dde_example.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nh(p, t; idxs = nothing) = typeof(idxs) <: Number ? 1.0 : ones(3)\n```\n\n----------------------------------------\n\nTITLE: Defining the Drift Function for a Lotka-Volterra SDE (Julia)\nDESCRIPTION: Defines the deterministic drift component (`f`) for a Lotka-Volterra system intended for use in an SDEProblem in DifferentialEquations.jl. The function calculates the rates of change for two state variables `u[1]` and `u[2]` based on parameters `p[1]` and `p[2]`, modifying `du` in-place.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_19\n\nLANGUAGE: julia\nCODE:\n```\nfunction f(du, u, p, t)\n    du[1] = p[1] * u[1] - p[2] * u[1] * u[2]\n    du[2] = -3 * u[2] + u[1] * u[2]\nend\n```\n\n----------------------------------------\n\nTITLE: Switching ODE Dynamics with Parameterization - Julia\nDESCRIPTION: Defines an in-place ODE function whose behavior switches dynamically based on the parameter p, enabling mid-integration changes of dynamics. Inputs: du (output array), u (state array), p (integer parameter), t (time). The function performs different updates to du[1] based on the value of p, and always updates du[2]. May be used in conjunction with callbacks to update p during integration. Requires Julia and follows in-place problem definitions for differential equations.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_24\n\nLANGUAGE: julia\nCODE:\n```\nfunction f(du, u, p, t)\n    if p == 0\n        du[1] = 2u[1]\n    else\n        du[1] = -2u[1]\n    end\n    du[2] = -u[2]\nend\n```\n\n----------------------------------------\n\nTITLE: Defining the ODE System for a Bouncing Ball in Julia\nDESCRIPTION: This snippet defines the function `f` representing the system of ordinary differential equations for a 2D bouncing ball. `du` is the derivative vector, `u` is the state vector ([y, vy, x, vx]), `p` represents parameters (gravity), and `t` is time. It sets the rate of change for position based on velocity and the rate of change for y-velocity based on gravity, with x-velocity remaining constant.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_50\n\nLANGUAGE: julia\nCODE:\n```\nfunction f(du, u, p, t)\n    du[1] = u[2]\n    du[2] = -p\n    du[3] = u[4]\n    du[4] = 0.0\nend\n```\n\n----------------------------------------\n\nTITLE: Listing Timeseries Statistics Functions (Per Point) in DifferentialEquations.jl (Julia)\nDESCRIPTION: Provides a list of Julia functions available in DifferentialEquations.jl for computing statistical measures (mean, median, quantile, variance, covariance, correlation) across ensemble simulation trajectories at user-specified time points `ts`. These functions require interpolation capabilities and operate on the ensemble simulation result object `sim`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\ntimeseries_point_mean(sim, ts) # Computes the mean at each time point in ts\ntimeseries_point_median(sim, ts) # Computes the median at each time point in ts\ntimeseries_point_quantile(sim, q, ts) # Computes the quantile q at each time point in ts\ntimeseries_point_meanvar(sim, ts) # Computes the mean and variance at each time point in ts\ntimeseries_point_meancov(sim, ts) # Computes the covariance matrix and means at each time point in ts\ntimeseries_point_meancor(sim, ts) # Computes the correlation matrix and means at each time point in ts\ntimeseries_point_weighted_meancov(sim, ts) # Computes the weighted covariance matrix and means at each time point in ts\n```\n\n----------------------------------------\n\nTITLE: Solving ODEs with Rosenbrock Methods in Julia\nDESCRIPTION: Demonstrates using the Rosenbrock23 solver from OrdinaryDiffEq.jl to solve ODE problems with various automatic differentiation and numerical Jacobian options. Required dependencies: DifferentialEquations.jl (for `solve`, `Rosenbrock23`, etc.) and optionally ForwardDiff.jl for autodiff control with chunk sizing. Key parameters include `autodiff` for enabling autodifferentiation or finite differencing, and `chunksize` for customizing dual number chunking. Inputs are a standard ODE problem and algorithm options; outputs are solution objects conforming to DifferentialEquations.jl standards.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_33\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, Rosenbrock23()) # Standard, uses autodiff\n```\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, Rosenbrock23(autodiff = AutoForwardDiff(chunksize = 10))) # Autodiff with chunksize of 10\n```\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, Rosenbrock23(autodiff = AutoFiniteDiff())) # Numerical differentiation with central differencing\n```\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, Rosenbrock23(autodiff = AutoFiniteDiff(fdtype = Val{:forward}))) # Numerical differentiation with forward differencing\n```\n\n----------------------------------------\n\nTITLE: Measuring Allocations in Differential Equation Functions - Julia\nDESCRIPTION: Demonstrates how to check that an ODE right-hand side function is allocation-free by using the @time macro in Julia on an in-place call with preallocated output. Dependencies: Julia's base language and REPL macros. Inputs are du (output array), u0 (state), p (parameters), and t (time); the function used should conform to the signature f(du, u0, p, t). Output is timing and allocation report to ensure efficient code.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_22\n\nLANGUAGE: julia\nCODE:\n```\ndu = similar(u0)\n@time f(du, u0, p, t)\n```\n\n----------------------------------------\n\nTITLE: Solving State-Dependent Delay DDE with Dependent Lags in Julia\nDESCRIPTION: Shows setting up and solving a DDEProblem where the delay is state-dependent via dependent_lags. The lag function is provided as a tuple of functions and passed to DDEProblem. Uses MethodOfSteps(Tsit5()) for efficient numerical integration. p, u0, h, tspan must be defined.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/dde_example.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\nprob = DDEProblem(bc_model, u0, h, tspan; dependent_lags = ((u, p, t) -> tau,))\nalg = MethodOfSteps(Tsit5())\nsol = solve(prob, alg)\n```\n\n----------------------------------------\n\nTITLE: Plotting Ensemble Simulation Results using Plots.jl (Julia)\nDESCRIPTION: Utilizes the built-in plot recipe for DifferentialEquations.jl ensemble simulation results (`sim`) with the Plots.jl package. This command plots all 10 trajectories from the simulation, setting the line alpha transparency to 0.4.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\nplot(sim, linealpha = 0.4)\n```\n\n----------------------------------------\n\nTITLE: Defining HamiltonianProblem Constructors Using DiffEqPhysics.jl (Julia)\nDESCRIPTION: Shows the constructor signature for creating HamiltonianProblem objects in DiffEqPhysics.jl. The function takes a Hamiltonian function H(p, q, params), initial momentum p0, initial positions q0, a tspan, and optionally parameters/keywords; automatic differentiation is used to convert H into system equations. Required dependencies include DiffEqPhysics.jl and ForwardDiff.jl; parameters H, p0, q0, and tspan must be specified while param is optional. Returned objects are HamiltonianProblem instances, used for modeling and solving Hamiltonian dynamical systems.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/dynamical_types.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nHamiltonianProblem{T}(H, p0, q0, tspan, param = nothing; kwargs...)\n```\n```\n\n----------------------------------------\n\nTITLE: Assembling the Beeler-Reuter ODE System for IMEX Integration (Julia)\nDESCRIPTION: Defines the main `deriv` function (as a callable BeelerReuterCpu struct method) for use as an ODE right-hand-side in the reaction-diffusion solver. Integrates explicit gating variable updates at each discontinuous time step, computes the Laplacian (diffusion) of u, applies the reaction via `update_du_cpu`, and finally adds the spatial diffusion component. Relies on previously defined update routines and expects initialized fields for gating variables and coefficients in the struct. Designed to integrate with DiffEq ecosystem solvers and efficient IMEX methods. Input parameters: du (output), u (current state), p (parameters), t (current time). Output: In-place update of du for solver consumption.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/beeler_reuter.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nfunction (f::BeelerReuterCpu)(du, u, p, t)\n    Ît = t - f.t\n\n    if Ît != 0 || t == 0\n        update_gates_cpu(u, f.XI, f.M, f.H, f.J, f.D, f.F, f.C, Ît)\n        f.t = t\n    end\n\n    laplacian(f.Îu, u)\n\n    # calculate the reaction portion\n    update_du_cpu(du, u, f.XI, f.M, f.H, f.J, f.D, f.F, f.C)\n\n    # ...add the diffusion portion\n    du .+= f.diff_coef .* f.Îu\nend\n```\n\n----------------------------------------\n\nTITLE: Animating Differential Equation Solutions with Plots.jl in Julia\nDESCRIPTION: This code demonstrates creating and saving an animation of the solution using Plots.jl's animate function. Dependencies: Plots.jl, ImageMagick.jl (optional for animation support). Inputs: solution object, keyword arguments (line width and frame skipping). Outputs: animation file or displayed animation. Provides options for customizing animation behavior and format.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/plot.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\n#]add ImageMagick # You may need to install ImageMagick.jl before your first time using it!\n#using ImageMagick # Some installations require using ImageMagick for good animations\nanimate(sol, lw = 3, every = 4)\n```\n\n----------------------------------------\n\nTITLE: Defining and Solving Kepler Problem with Symplectic Integrator in Julia\nDESCRIPTION: Defines the Hamiltonian (H) and Angular Momentum (L) functions for the Kepler problem. Sets up the `DynamicalODEProblem` using derivatives `pdot` and `qdot` calculated with `ForwardDiff.gradient!`. Specifies initial position and velocity, calculates initial first integrals, defines the time span, and solves the problem using the `KahanLi6` symplectic integrator with a fixed time step (dt = 1/10). Requires `OrdinaryDiffEq`, `LinearAlgebra`, `ForwardDiff`, `NonlinearSolve` (for ManifoldProjection later), and `Plots` libraries.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/kepler_problem.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nusing OrdinaryDiffEq, LinearAlgebra, ForwardDiff, NonlinearSolve, Plots\nH(q, p) = norm(p)^2 / 2 - inv(norm(q))\nL(q, p) = q[1] * p[2] - p[1] * q[2]\n\npdot(dp, p, q, params, t) = ForwardDiff.gradient!(dp, q -> -H(q, p), q)\nqdot(dq, p, q, params, t) = ForwardDiff.gradient!(dq, p -> H(q, p), p)\n\ninitial_position = [0.4, 0]\ninitial_velocity = [0.0, 2.0]\ninitial_cond = (initial_position, initial_velocity)\ninitial_first_integrals = (H(initial_cond...), L(initial_cond...))\ntspan = (0, 20.0)\nprob = DynamicalODEProblem(pdot, qdot, initial_velocity, initial_position, tspan)\nsol = solve(prob, KahanLi6(), dt = 1 // 10);\n```\n\n----------------------------------------\n\nTITLE: Callback Condition and Parameter Update for ODE Integration - Julia\nDESCRIPTION: Provides an example of two functions: one for specifying an event condition (when u[2] < 0.5) and another for updating the problem parameter p upon the event. These are used as callback components in DifferentialEquations.jl to dynamically modify system parameters during simulation. Inputs: state (u), time (t), and the integrator object. Output: parameter update in the ODE solver; dependencies: DifferentialEquations.jl's callback system.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_25\n\nLANGUAGE: julia\nCODE:\n```\ncondition(t, u, integrator) = u[2] - 0.5\naffect!(integrator) = integrator.p = 1\n```\n\n----------------------------------------\n\nTITLE: ODE with Cached Temporary Arrays and Dual Number Pitfall - OrdinaryDiffEq.jl - Julia\nDESCRIPTION: Demonstrates a common pitfall using cached arrays for temporary variables in ODEs that causes incompatibility with autodifferentiation when matrices contain Dual numbers. Uses LinearAlgebra and OrdinaryDiffEq.jl to define and solve an ODEProblem where the right-hand side performs in-place matrix multiplication and addition. May throw errors if Dual number types do not match the pre-allocated array element types.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_31\n\nLANGUAGE: julia\nCODE:\n```\nusing LinearAlgebra, OrdinaryDiffEq\nfunction foo(du, u, (A, tmp), t)\n    mul!(tmp, A, u)\n    @. du = u + tmp\n    nothing\nend\nprob = ODEProblem(foo, ones(5, 5), (0.0, 1.0), (ones(5, 5), zeros(5, 5)))\nsolve(prob, Rosenbrock23())\n```\n\n----------------------------------------\n\nTITLE: Optimizing ODE Function with Views and Broadcast Fusion in Julia\nDESCRIPTION: Defines a Julia function `gm2!` for an ODE system, optimized to avoid slicing allocations by using `@view` for array subsets (`u`, `v`, `du`, `dv`). It also uses broadcast fusion (`@.`) for element-wise operations to improve performance. The snippet then sets up an `ODEProblem` using this function and benchmarks its solution time with `Tsit5()` solver.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_25\n\nLANGUAGE: julia\nCODE:\n```\nfunction gm2!(dr, r, p, t)\n    a, Î±, ubar, Î², D1, D2 = p\n    u = @view r[:, :, 1]\n    v = @view r[:, :, 2]\n    du = @view dr[:, :, 1]\n    dv = @view dr[:, :, 2]\n    Du = D1 * (Ay * u + u * Ax)\n    Dv = D2 * (Ay * v + v * Ax)\n    @. du = Du + a .* u .* u ./ v + ubar - Î± * u\n    @. dv = Dv + a .* u .* u - Î² * v\nend\nprob = ODEProblem(gm2!, r0, (0.0, 0.1), p)\n@btime solve(prob, Tsit5());\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Plotting Gating Variables in Hodgkin-Huxley Model (Julia)\nDESCRIPTION: Plots gating variables n, m, and h (state variables 2, 3, and 4) from the HH model solution within an explicit time window. Highlights channel dynamics following stimulation, providing insight into ionic mechanisms underlying spiking. Requires 'sol' as an ODE solution and appropriate time range.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\nplot(sol, vars = [2, 3, 4], tspan = (105.0, 130.0))\n```\n\n----------------------------------------\n\nTITLE: Initializing Correlated Wiener Process for Heston SDE in Julia\nDESCRIPTION: Initializes a correlated Wiener process (heston_noise) starting at zero for use in the SDE solver. Uses the previously defined correlation matrix (Î) and the initial time. Requires the function CorrelatedWienerProcess! and Julia's array utilities. Inputs: Î (correlation matrix), tspan[1] (start time), and zero vectors for initial conditions. Output: heston_noise object for noise parameter in SDEProblem. Requires SDE solver packages such as DifferentialEquations.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/sde_example.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\ntspan = (0.0, 1.0)\nheston_noise = CorrelatedWienerProcess!(Î, tspan[1], zeros(2), zeros(2))\n```\n\n----------------------------------------\n\nTITLE: Installing and Using ODEInterfaceDiffEq Algorithms in Julia\nDESCRIPTION: This snippet demonstrates how to install and import the ODEInterfaceDiffEq.jl package, which provides access to classic Fortran-based ODE solvers as wrappers in Julia. Required dependencies include the Pkg standard library for managing packages and the ODEInterfaceDiffEq package for the solver algorithms. The primary purpose is to enable various high-performance stiff and non-stiff solvers, especially for Float64 arrays, and these must be explicitly installed as they are not included in DifferentialEquations.jl by default.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_38\n\nLANGUAGE: julia\nCODE:\n```\nusing Pkg\nPkg.add(\"ODEInterfaceDiffEq\")\nusing ODEInterfaceDiffEq\n\n```\n\n----------------------------------------\n\nTITLE: Configuring and Invoking ImplicitDeuflhardExtrapolation in Julia\nDESCRIPTION: This Julia snippet demonstrates how to instantiate an ImplicitDeuflhardExtrapolation algorithm for solving differential equations, specifying maximum, minimum, and initial extrapolation orders, as well as the sequence type for subdivision, via named keyword arguments. Dependencies include a defined problem (prob) and the DifferentialEquations.jl library. Inputs are algorithm configuration; outputs are the solver result after passing the configured method to the solve function. Limitations: method is adaptive in order and step, works best for large ODE systems, and sequence values must be from the supported set (e.g., :bulirsch).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_32\n\nLANGUAGE: julia\nCODE:\n```\nalg = ImplicitDeuflhardExtrapolation(max_order = 7, min_order = 4, init_order = 4,\\n    sequence = :bulirsch)\\nsolve(prob, alg)\\n\n```\n\n----------------------------------------\n\nTITLE: Custom Output Function for Ensemble Simulations - SciML - Julia\nDESCRIPTION: Defines an `output_func` that extracts only the final value of the second dependent variable from each trajectory solution. Used to customize ensemble results, this pattern reduces stored data to a scalar per simulation (e.g., for statistical summaries). The function signature expects a solution object and trajectory index, returning a tuple of the reduced value and a rerun flag. Prerequisite: the solution supports array-like indexing with `sol[end, 2]`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\noutput_func(sol, i) = (sol[end, 2], false)\n```\n\n----------------------------------------\n\nTITLE: Specifying Mass Matrix Form of SDAE Problem - Math\nDESCRIPTION: Expresses the mathematical form of a stochastic differential-algebraic equation (SDAE) using mass matrices, where \\(M\\) is the mass matrix, \\(f\\) is the drift (forcing) function, and \\(g\\) is the noise function. The equation format represents the core structure that later Julia implementations must conform to. This snippet is intended for readers to relate the code definitions to the standard mathematical formulation.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/sdae_types.md#_snippet_0\n\nLANGUAGE: math\nCODE:\n```\nM du = f(u,p,t)dt + \\Sigma g_i(u,p,t)dW^i\n```\n\n----------------------------------------\n\nTITLE: Setting up and Simulating Izhikevich Model ODE Problem in Julia\nDESCRIPTION: Establishes the initial conditions, parameters, and problem definition for the Izhikevich neuron simulation using ODEProblem in Julia. The code sets up the state vector and timespan, and attaches the defined callback set for proper spike handling. Expects prior definition of the ODE function (`izh!`) and callback variables; suitable for direct passing to DifferentialEquations.jl solvers.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\np = [0.02, 0.2, -50, 2, 0]\nu0 = [-65, p[2] * -65]\ntspan = (0.0, 300)\n\nprob = ODEProblem(izh!, u0, tspan, p, callback = cb)\n```\n\n----------------------------------------\n\nTITLE: Solving the ODE Problem in Julia\nDESCRIPTION: Solves the previously defined double pendulum `ODEProblem` named `poincare` using the `Tsit5()` solver from `OrdinaryDiffEq.jl`. The result is stored in the `sol` variable, which contains the numerical solution.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/min_and_max.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(poincare, Tsit5())\n```\n\n----------------------------------------\n\nTITLE: In-Place Matrix ODE using LinearAlgebra's mul! - DifferentialEquations.jl - Julia\nDESCRIPTION: Implements efficient in-place multiplication for matrix-valued state by directly updating the derivative array using `mul!`. Requires LinearAlgebra. Signature and usage follow DifferentialEquations.jl conventions. Inputs: `du` (output), `u` (state), `p`, `t` (parameters, time). Key for large or performance-critical simulations.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/getting_started.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\nusing LinearAlgebra\nf(du, u, p, t) = mul!(du, A, u)\n```\n\n----------------------------------------\n\nTITLE: Defining In-Place Breast Cancer DDE Model with DifferentialEquations.jl in Julia\nDESCRIPTION: Defines the in-place delay differential equation function for the breast cancer growth kinetics model. This function uses both current and delayed state values via the supplied history function. Requires DifferentialEquations.jl and consistent parameter order; inputs are current and delayed states, parameters, and current time. Outputs are written in-place to du, with delayed values accessed by h(p, t-tau)[3].\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/dde_example.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\nfunction bc_model(du, u, h, p, t)\n    p0, q0, v0, d0, p1, q1, v1, d1, d2, beta0, beta1, tau = p\n    hist3 = h(p, t - tau)[3]\n    du[1] = (v0 / (1 + beta0 * (hist3^2))) * (p0 - q0) * u[1] - d0 * u[1]\n    du[2] = (v0 / (1 + beta0 * (hist3^2))) * (1 - p0 + q0) * u[1] +\n            (v1 / (1 + beta1 * (hist3^2))) * (p1 - q1) * u[2] - d1 * u[2]\n    du[3] = (v1 / (1 + beta1 * (hist3^2))) * (1 - p1 + q1) * u[2] - d2 * u[3]\nend\n```\n\n----------------------------------------\n\nTITLE: Symbolic Jacobian Generation with ModelingToolkit.jl - Julia\nDESCRIPTION: Utilizes ModelingToolkit.jl to convert a numerically defined ODE problem to a symbolic representation and generates a symbolic Jacobian function. Inputs are a DifferentialEquations.jl ODEProblem (`prob`); `complete` and `modelingtoolkitize` are used to enable the conversion and symbolic enhancements. Output is the symbolic ODE system. Dependencies: ModelingToolkit.jl for transformation and Jacobian generation.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\nusing ModelingToolkit\nde = complete(modelingtoolkitize(prob))\n```\n\n----------------------------------------\n\nTITLE: Checking ODE Solution Success Status in Julia SciML\nDESCRIPTION: Demonstrates how to check if an ODE solution (`sol`) completed successfully using `SciMLBase.successful_retcode`. This is crucial in parameter estimation loops to detect failed solves (e.g., due to instability) and assign an infinite cost, guiding the optimizer away from problematic parameter regions.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nSciMLBase.successful_retcode(sol.retcode)\n```\n\n----------------------------------------\n\nTITLE: Defining a Discrete Callback for Multiple Preset Dose Times in Julia\nDESCRIPTION: Creates a `DiscreteCallback` for administering doses at multiple specified times defined in the `dosetimes` array (`[4.0, 8.0]`). The `condition` function checks if the current time `t` is present in the `dosetimes` array using `t â dosetimes`. The `affect!` function increases the state `integrator.u[1]` by 10. The ODE is then solved using `Tsit5()`, ensuring these times are hit by passing `dosetimes` to the `tstops` argument. The result is plotted. Requires `DifferentialEquations` and `Plots`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\n```@example callback1\ndosetimes = [4.0, 8.0]\ncondition(u, t, integrator) = t â dosetimes\naffect!(integrator) = integrator.u[1] += 10\ncb = DiscreteCallback(condition, affect!)\nsol = solve(prob, Tsit5(), callback = cb, tstops = dosetimes)\nplot(sol)\n```\n```\n\n----------------------------------------\n\nTITLE: Solving an ODEProblem in Julia\nDESCRIPTION: Function signature for solving an Ordinary Differential Equation problem (`ODEProblem`) using a specified algorithm (`alg`) in the DifferentialEquations.jl package. Additional solver options can be passed as keyword arguments (`kwargs`). If `alg` is omitted, a default algorithm is chosen.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nsolve(prob::ODEProblem,alg;kwargs)\n```\n\n----------------------------------------\n\nTITLE: Computing Correlation Between Variables - SciMLBase - Julia\nDESCRIPTION: Calls 'cov(sol, 2)' to compute the covariance (correlation) between variables (rows) in the solution object. Assumes the solution type is array-like. Input is the solution; output is a covariance matrix across variables.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/solution.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\ncov(sol, 2)\n```\n\n----------------------------------------\n\nTITLE: Switching to Intel MKL BLAS in Julia\nDESCRIPTION: This code imports MKL.jl, which swaps Julia's underlying BLAS implementation to Intel's MKL for potentially improved linear algebra performance. The only dependency is the MKL.jl package, which must be installed. No parameters are requiredâexecuting `using MKL` reconfigures the backend in the running Julia session. There is no direct output; performance should be verified via benchmarks.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_21\n\nLANGUAGE: julia\nCODE:\n```\nusing MKL\n```\n\n----------------------------------------\n\nTITLE: Creating an ArrayPartition from Heterogeneous Arrays - Julia\nDESCRIPTION: This snippet shows the construction of an ArrayPartition from two arbitrary arrays y and z using RecursiveArrayTools.jl. It preserves direct access to the constituent arrays as A.x[1] and A.x[2], while allowing for linear indexing and efficient broadcasting. There are no hard dependencies other than RecursiveArrayTools.jl, and the snippet demonstrates the basic creation and storage semantics.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/diffeq_arrays.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nusing RecursiveArrayTools\nA = ArrayPartition(y, z)\n```\n\n----------------------------------------\n\nTITLE: Implementing Collision Detection and Response with VectorContinuousCallback in Julia\nDESCRIPTION: This snippet defines the `condition` and `affect!` functions required for a `VectorContinuousCallback` in DifferentialEquations.jl. The `condition` function checks for collision events: `out[1]` is zero when the ball hits the ground (y=0), and `out[2]` is zero when the ball hits the vertical walls (x=0 or x=10). The `affect!` function modifies the integrator's state (`integrator.u`) upon event detection (`idx`), reversing the appropriate velocity component (vy for ground collision, vx for wall collision) and applying a coefficient of restitution (0.9). Finally, it imports `DifferentialEquations` and constructs the `VectorContinuousCallback`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_51\n\nLANGUAGE: julia\nCODE:\n```\nfunction condition(out, u, t, integrator) # Event when condition(out,u,t,integrator) == 0\n    out[1] = u[1]\n    out[2] = (u[3] - 10.0)u[3]\nend\n\nfunction affect!(integrator, idx)\n    if idx == 1\n        integrator.u[2] = -0.9integrator.u[2]\n    elseif idx == 2\n        integrator.u[4] = -0.9integrator.u[4]\n    end\nend\nusing DifferentialEquations\ncb = VectorContinuousCallback(condition, affect!, 2)\n```\n\n----------------------------------------\n\nTITLE: Accessing Solution Time Points in Julia SciML\nDESCRIPTION: Shows how to access the array of time points (`sol.t`) at which the ODE solution (`sol`) was computed and saved. This is useful for checking the step sizes taken by the integrator, especially when investigating `maxiters` issues.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\nsol.t\n```\n\n----------------------------------------\n\nTITLE: Solving and Plotting Membrane Potential of Hodgkin-Huxley Model in Julia\nDESCRIPTION: Computes the time evolution of the HH neuron state vector and plots the first state variable (membrane potential) over time using Plots.jl. Expects ODEProblem 'prob' and produces a voltage trace matching experimental spike patterns. Demonstrates standard simulation output workflow in DifferentialEquations.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob);\nplot(sol, vars = 1)\n```\n\n----------------------------------------\n\nTITLE: Solving Lorenz System with Progress Bar using ProgressLogging.jl in Julia\nDESCRIPTION: This snippet demonstrates how to solve the Lorenz ODE system using DifferentialEquations.jl with a progress bar enabled within VS Code via ProgressLogging.jl. Required dependencies are OrdinaryDiffEq (for ODE solving) and ProgressLogging (for progress bar integration). Key parameters include the Lorenz system definition (via lorenz!), initial values u0, the time span tspan, and solution via solve(). Setting progress=true enables periodic progress bar updates in the IDE. Inputs are the ODE function, initial conditions, and ODE parameters; output is the solved trajectory. It assumes a compatible VS Code environment with the proper extension.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/progress_bar.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nusing OrdinaryDiffEq, ProgressLogging\nfunction lorenz!(du, u, p, t)\n    du[1] = 10.0(u[2] - u[1])\n    du[2] = u[1] * (28.0 - u[3]) - u[2]\n    du[3] = u[1] * u[2] - (8 / 3) * u[3]\nend\nu0 = [1.0; 0.0; 0.0]\ntspan = (0.0, 1000000.0)\nprob = ODEProblem(lorenz!, u0, tspan)\nsol = solve(prob, Tsit5(), progress = true)\n\n```\n\n----------------------------------------\n\nTITLE: Simulating Bouncing Ball with Friction using ContinuousCallback in Julia\nDESCRIPTION: Defines and solves an ODE problem representing a bouncing ball with friction using DifferentialEquations.jl. A `ContinuousCallback` detects when the ball hits the floor (condition `u[1] == 0`) and applies an affect (`floor_aff!`) that reduces the velocity (`u[2]`) by half and increments counters for bounce count (`p[1]`) and records the time (`p[2]`). The solution is then plotted.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_34\n\nLANGUAGE: julia\nCODE:\n```\nfunction dynamics!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = -9.8\nend\nfunction floor_aff!(int)\n    int.u[2] *= -0.5\n    int.p[1] += 1\n    int.p[2] = int.t\nend\nfloor_event = ContinuousCallback(condition, floor_aff!)\nu0 = [1.0, 0.0]\np = [0.0, 0.0]\nprob = ODEProblem{true}(dynamics!, u0, (0.0, 2.0), p)\nsol = solve(prob, Tsit5(), callback = floor_event)\nplot(sol)\n```\n\n----------------------------------------\n\nTITLE: Symmetric/Symplectic Stiff Integrator ImplicitMidpoint in Julia\nDESCRIPTION: `ImplicitMidpoint` is a symmetric and symplectic implicit integrator suitable for stiff problems where these properties are desired.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_19\n\nLANGUAGE: julia\nCODE:\n```\nImplicitMidpoint\n```\n\n----------------------------------------\n\nTITLE: Viewing Solution Value Tuples During Integration with tuples Iterator (Julia)\nDESCRIPTION: Iterates over the integrator using the tuples iterator, yielding solution and time pairs (u, t) at each step. Useful for real-time monitoring or displaying of computed state and time points. Requires initialized integrator and supports use of @show for display.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/integrator.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nfor (u, t) in tuples(integrator)\n    @show u, t\nend\n```\n\n----------------------------------------\n\nTITLE: Defining output_func for Ensemble Reduction (Julia)\nDESCRIPTION: Defines an `output_func` for use with `EnsembleProblem` in DifferentialEquations.jl. This function takes a single trajectory solution (`sol`) and its index (`i`), and returns only the final state (`last(sol)`) along with `false` to indicate the reduction should continue. This is useful for reducing memory usage when only endpoint statistics are needed.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_25\n\nLANGUAGE: julia\nCODE:\n```\nfunction output_func(sol, i)\n    last(sol), false\nend\n```\n\n----------------------------------------\n\nTITLE: Robust Non-Stiff Solver BS5 in Julia\nDESCRIPTION: `BS5` is recommended for non-stiff problems where more robust error control is needed compared to `Tsit5`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nBS5\n```\n\n----------------------------------------\n\nTITLE: Setting Number of BLAS Threads with Julia LinearAlgebra\nDESCRIPTION: This snippet sets the number of BLAS threads used by Julia's LinearAlgebra module to a user-defined integer, optimizing computational throughput on multicore architectures. The code depends on the LinearAlgebra standard library, and the set_num_threads(4) function call specifies usage of 4 threads. Adjust the parameter to best match your system's physical cores. No output is produced unless queried separately.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_20\n\nLANGUAGE: julia\nCODE:\n```\nusing LinearAlgebra\nLinearAlgebra.BLAS.set_num_threads(4)\n```\n\n----------------------------------------\n\nTITLE: Creating and Solving EnsembleProblem with Distributed Parallelism (Julia)\nDESCRIPTION: Constructs an `EnsembleProblem` using a base ODE problem (`prob`) and a function (`prob_func`) to modify it for each trajectory. It then solves this ensemble problem using the `Tsit5` solver and distributed parallelism (`EnsembleDistributed`) for 10 trajectories via DifferentialEquations.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\nensemble_prob = EnsembleProblem(prob, prob_func = prob_func)\nsim = solve(ensemble_prob, Tsit5(), EnsembleDistributed(), trajectories = 10)\n```\n\n----------------------------------------\n\nTITLE: Remaking and Modifying an Existing ODE Problem - DifferentialEquations.jl - Julia\nDESCRIPTION: This example demonstrates how to use the `remake` function to modify fields in an existing ODEProblem struct without mutating the original, preserving immutability. The standard use case is to extend simulation timespans or alter parameters post-hoc. Using DifferentialEquations.jl, the first line constructs an initial problem; the second line uses `remake` with an updated tspan. Inputs: existing problem struct, keyword arguments for desired changes. Output: new ODEProblem reflecting modifications.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/problem.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nprob1 = ODEProblem((u, p, t) -> u / 2, 1.0, (0.0, 1.0))\nprob2 = remake(prob1; tspan = (0.0, 2.0))\n```\n\n----------------------------------------\n\nTITLE: Solving ODE with Conditional Dosing Callback in Julia\nDESCRIPTION: Solves the ODE problem again using `Tsit5()`, but this time incorporates the conditional dosing logic defined in the `DiscreteCallback` (`cb`). The `tstops=[4.0]` argument is crucial, ensuring the solver stops precisely at t=4 to evaluate the `condition` function accurately. The resulting solution, which includes the added dose if the condition was met, is then plotted using Plots.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/conditional_dosing.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, Tsit5(), tstops = [4.0], callback = cb)\nusing Plots;\ngr();\nplot(sol)\n```\n\n----------------------------------------\n\nTITLE: Including Documentation for SciMLBase.NonlinearSolution in Julia\nDESCRIPTION: This Julia `@docs` directive is used to embed the documentation for the `SciMLBase.NonlinearSolution` type. This type structure typically holds the results, status, and potentially statistics obtained after solving a nonlinear system, which is the common outcome when finding steady states.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/steady_state_types.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nSciMLBase.NonlinearSolution\n```\n```\n\n----------------------------------------\n\nTITLE: Solving a Simple Pendulum BVP using TwoPointBVProblem in Julia\nDESCRIPTION: This snippet demonstrates the `TwoPointBVProblem` type, specialized for BVPs where conditions are only specified at the start and end times. It defines separate boundary condition functions `bc2a!` (for start time) and `bc2b!` (for end time). A `TwoPointBVProblem` is constructed, requiring a `bcresid_prototype` to specify the size of the residual vectors for each boundary. The problem is solved using `MIRK4` and the solution is plotted.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/bvp_example.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nfunction bc2a!(resid_a, u_a, p) # u_a is at the beginning of the time span\n    resid_a[1] = u_a[1] + pi / 2 # the solution at the beginning of the time span should be -pi/2\nend\nfunction bc2b!(resid_b, u_b, p) # u_b is at the ending of the time span\n    resid_b[1] = u_b[1] - pi / 2 # the solution at the end of the time span should be pi/2\nend\nbvp2 = TwoPointBVProblem(simplependulum!, (bc2a!, bc2b!), [pi / 2, pi / 2], tspan;\n    bcresid_prototype = (zeros(1), zeros(1)))\nsol2 = solve(bvp2, MIRK4(), dt = 0.05)\nplot(sol2)\n```\n\n----------------------------------------\n\nTITLE: Alternative Stiff Solvers for Large Systems (Low Oscillations) in Julia\nDESCRIPTION: For asymptotically large stiff systems (`N>1000`) with costly `f` and minimal complex eigenvalues (low oscillations), `QNDF`, `FBDF`, `CVODE_BDF`, and `lsoda` are options to consider. `QNDF`/`FBDF` handle smooth solutions well but may struggle with high stiffness or low accuracy.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_18\n\nLANGUAGE: julia\nCODE:\n```\nQNDF\n```\n\nLANGUAGE: julia\nCODE:\n```\nFBDF\n```\n\nLANGUAGE: julia\nCODE:\n```\nCVODE_BDF\n```\n\nLANGUAGE: julia\nCODE:\n```\nlsoda\n```\n\n----------------------------------------\n\nTITLE: Using PresetTimeCallback for Simplified Fixed-Time Events in Julia\nDESCRIPTION: Shows how to use the built-in `PresetTimeCallback` from DifferentialEquations.jl's Callback Library as a convenient alternative for events occurring at predetermined times (`dosetimes`). An `affect!` function defining the action (adding 10 to `u[1]`) is provided along with the `dosetimes`. `PresetTimeCallback` automatically handles setting the necessary `tstops` for the solver. The ODE is solved using `Tsit5()` and the result plotted. Requires `DifferentialEquations` and `Plots`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\n```@example callback1\ndosetimes = [4.0, 8.0]\naffect!(integrator) = integrator.u[1] += 10\ncb = PresetTimeCallback(dosetimes, affect!)\nsol = solve(prob, Tsit5(), callback = cb)\nplot(sol)\n```\n```\n\n----------------------------------------\n\nTITLE: Defining and Solving SDAE with a Mass Matrix in Julia\nDESCRIPTION: Defines a 3-variable system using a nonsingular mass matrix and corresponding in-place drift and noise functions for constructing a SDEProblem. Relies on DifferentialEquations.jl (specifically SDEProblem and SDEFunction), and requires Julia plus relevant SciML libraries. Key parameters include the mass matrix (mm_A), state vector (u), parameter vector (p), and time (t). The example illustrates the required in-place signatures, general mass matrix handling, and shows how to instantiate an SDAE problem in practice.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/sdae_types.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nconst mm_A = [-2.0 1 4\n              4 -2 1\n              0 0 0]\nfunction f!(du, u, p, t)\n    du[1] = u[1]\n    du[2] = u[2]\n    du[3] = u[1] + u[2] + u[3] - 1\nend\n\nfunction g!(du, u, p, t)\n    @. du = 0.1\nend\n\nprob = SDEProblem(SDEFunction(f!, g!; mass_matrix = mm_A),\n    ones(3), (0.0, 1.0))\n```\n\n----------------------------------------\n\nTITLE: Installing and Using Sundials.jl Package in Julia\nDESCRIPTION: Demonstrates how to install and load the Sundials.jl package using Julia's built-in package manager Pkg. This is a prerequisite for using Sundials-based DAE solvers like IDA within the DifferentialEquations.jl ecosystem.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/dae_solve.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nusing Pkg\nPkg.add(\"Sundials\")\nusing Sundials\n```\n\n----------------------------------------\n\nTITLE: Implementing Analytic Steady-State Solution for Heat Equation in Julia\nDESCRIPTION: Defines a Julia function `T_analytic(z)` that calculates the derived analytic steady-state solution for the temperature `T` at a given spatial coordinate `z`, based on the problem's parameters (`a`, `b`, `\\u03b1`, `\\u03b2`, `\\u03b3`, `\\u2207T_bottom`, `T_top`) and boundary conditions. It computes the integration constants `c1` and `c2` internally.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/diffusion_implicit_heat_equation.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nfunction T_analytic(z) # Analytic steady state solution\n    c1 = \\u2207T_bottom - \\u03b2 * cos(\\u03b3 * a) / (\\u03b3 * \\u03b1)\n    c2 = T_top - (\\u03b2 * sin(\\u03b3 * b) / (\\u03b3^2 * \\u03b1) + c1 * b)\n    return \\u03b2 * sin(\\u03b3 * z) / (\\u03b3^2 * \\u03b1) + c1 * z + c2\nend\n```\n\n----------------------------------------\n\nTITLE: Applying Manifold Projection for Energy and Angular Momentum in Julia\nDESCRIPTION: Demonstrates applying manifold projection to enforce conservation of both energy and angular momentum using `DiffEqCallbacks.ManifoldProjection`. Defines the `first_integrals_manifold` function, which calculates the residual (difference from the initial conserved quantities) for both H and L. Creates a `ManifoldProjection` callback (`cb`) using this function and automatic differentiation (`AutoForwardDiff`). Solves the first-order ODE problem (`prob2`) with `RK4` (fixed step) and this callback enabled, then plots the results (`analysis_plot2`) showing improved conservation. Requires `OrdinaryDiffEq`, `DiffEqCallbacks`, `Plots`, `NonlinearSolve`, and definitions from previous snippets (`prob2`, `H`, `L`, `initial_first_integrals`, `analysis_plot2`).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/kepler_problem.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nfunction first_integrals_manifold(residual, u, p, t)\n    residual[1:2] .= initial_first_integrals[1] - H(u[1:2], u[3:4])\n    residual[3:4] .= initial_first_integrals[2] - L(u[1:2], u[3:4])\nend\n\ncb = ManifoldProjection(first_integrals_manifold, autodiff = AutoForwardDiff())\nsol5 = solve(prob2, RK4(), dt = 1 // 5, adaptive = false, callback = cb)\nanalysis_plot2(sol5, H, L)\n```\n\n----------------------------------------\n\nTITLE: Embedding SciMLBase Docstrings for Split ODEs in Julia\nDESCRIPTION: This snippet uses the `@docs` macro, commonly used with Julia's Documenter.jl package, to automatically insert the documentation strings for `SciMLBase.SplitODEProblem` and `SciMLBase.SplitFunction` into the generated documentation page. This allows users to view the official docstrings directly within the context of the Split ODE problem description.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/split_ode_types.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```julia\n@docs\nSciMLBase.SplitODEProblem\nSciMLBase.SplitFunction\n```\n```\n\n----------------------------------------\n\nTITLE: Listing DDETST Problem Categories\nDESCRIPTION: This markdown code block lists the names of various DDE test problems categorized by their characteristics, such as time-dependent delays, vanishing delays, state-dependent delays, and neutral DDEs. These identifiers correspond to specific problem definitions within the `DDEProblemLibrary` used for testing DDE solvers.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/dde_types.md#_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n```\n# DDEs with time dependent delays\nprob_dde_DDETST_A1, prob_dde_DDETST_A2,\n# DDEs with vanishing time dependent delays\nprob_dde_DDETST_B1, prob_dde_DDETST_B2,\n# DDEs with state dependent delays\nprob_dde_DDETST_C1, prob_dde_DDETST_C2, prob_dde_DDETST_C3, prob_dde_DDETST_C4,\n# DDEs with vanishing state dependent delays\nprob_dde_DDETST_D1, prob_dde_DDETST_D2,\n# neutral DDEs with time dependent delays\nprob_dde_DDETST_E1, prob_dde_DDETST_E2,\n# neutral DDEs with vanishing time dependent delays\nprob_dde_DDETST_F1, prob_dde_DDETST_F2, prob_dde_DDETST_F3, prob_dde_DDETST_F4, prob_dde_DDETST_F5,\n# neutral DDEs with state dependent delays\nprob_dde_DDETST_G1, prob_dde_DDETST_G2,\n# neutral DDEs with vanishing state dependent delays\nprob_dde_DDETST_H1, prob_dde_DDETST_H2, prob_dde_DDETST_H3, prob_dde_DDETST_H4\n```\n```\n\n----------------------------------------\n\nTITLE: Listing Timeseries Statistics Functions (Per Step) in DifferentialEquations.jl (Julia)\nDESCRIPTION: Provides a list of Julia functions available in DifferentialEquations.jl for computing statistical measures (mean, median, quantile, variance, covariance, correlation) across ensemble simulation trajectories at each time step taken by the solver. These functions operate on the ensemble simulation result object `sim`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\ntimeseries_steps_mean(sim) # Computes the mean at each time step\ntimeseries_steps_median(sim) # Computes the median at each time step\ntimeseries_steps_quantile(sim, q) # Computes the quantile q at each time step\ntimeseries_steps_meanvar(sim) # Computes the mean and variance at each time step\ntimeseries_steps_meancov(sim) # Computes the covariance matrix and means at each time step\ntimeseries_steps_meancor(sim) # Computes the correlation matrix and means at each time step\ntimeseries_steps_weighted_meancov(sim) # Computes the weighted covariance matrix and means at each time step\n```\n\n----------------------------------------\n\nTITLE: Referencing SciMLBase ODE Alias Specifier Documentation\nDESCRIPTION: This snippet utilizes the Documenter.jl `@docs` directive to include documentation for the `ODEAliasSpecifier` type from the SciMLBase package.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/ode_types.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nSciMLBase.ODEAliasSpecifier\n```\n```\n\n----------------------------------------\n\nTITLE: Extracting Components at Given Time Step or Time Point - SciML - Julia\nDESCRIPTION: Provides a set of analysis utility functions for fetching solution data across the ensemble, for a specified time step (by index) or time point (by value). Outputs are iterators or vectors over the simulations, collecting either complete outputs or componentwise vectors, facilitating custom analysis or plotting. Inputs are the ensemble simulation, step or timepoint, and options for component selection; outputs are object(s) aggregating the requested data.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\nget_timestep(sim, i) # Returns an iterator of each simulation at time step i\nget_timepoint(sim, t) # Returns an iterator of each simulation at time point t\ncomponentwise_vectors_timestep(sim, i) # Returns a vector of each simulation at time step i\ncomponentwise_vectors_timepoint(sim, t) # Returns a vector of each simulation at time point t\n```\n\n----------------------------------------\n\nTITLE: Solving Discrete Problems with Algorithms in Julia\nDESCRIPTION: This Julia function call is the standard way to solve a discrete mapping problem using a specified algorithm. If the algorithm argument is omitted, a default is chosen based on the problem type. The function supports additional keyword arguments for customizing the solver's behavior (e.g., tolerances, callbacks, saving options). Expected inputs are a DiscreteProblem object and an algorithm constructor. The solution object contains results of all discrete steps. No non-Julia external dependencies are required, but the relevant packages (such as OrdinaryDiffEq.jl or SimpleDiffEq.jl) must be installed.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/discrete_solve.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nsolve(prob::DiscreteProblem,alg;kwargs)\n```\n\n----------------------------------------\n\nTITLE: Performing Local Minimization using Optimization.jl and NLopt in Julia\nDESCRIPTION: Sets up and solves a local minimization problem to find the time `t` corresponding to a local minimum of the 4th state variable around `t=18`. It uses `Optimization.jl` with `ForwardDiff` for automatic differentiation and the `NLopt.LD_LBFGS` algorithm. The search is bounded between `t=0.0` and `t=100.0`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/min_and_max.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nusing Optimization, OptimizationNLopt, ForwardDiff\noptf = OptimizationFunction(f, Optimization.AutoForwardDiff())\nmin_guess = 18.0\noptprob = OptimizationProblem(optf, [min_guess], lb = [0.0], ub = [100.0])\nopt = solve(optprob, NLopt.LD_LBFGS())\n```\n\n----------------------------------------\n\nTITLE: Building a Sparse ODEProblem for the 2D Brusselator in DifferentialEquations.jl (Julia)\nDESCRIPTION: This snippet constructs an ODEProblem using the previously defined ODEFunction with Jacobian sparsity structure for the discretized Brusselator PDE. The approach is identical to building a standard ODEProblem but uses the sparse-aware function, improving the efficiency of stiff solvers. Dependencies are the correctly constructed ODEFunction (f), initial conditions (u0), and parameters.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/advanced_ode_example.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nprob_ode_brusselator_2d_sparse = ODEProblem(f, u0, (0.0, 11.5), p)\n\n```\n\n----------------------------------------\n\nTITLE: Benchmarking ODE Solution with StaticArray Initial Condition (Julia)\nDESCRIPTION: Benchmarks the Lorenz system where the initial condition (u0) is a StaticArray, ensuring static allocation in the solver internals. Demonstrates high performance for small ODEs without heap allocation. Dependencies: StaticArrays.jl, DifferentialEquations.jl, BenchmarkTools.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nu0 = SA[1.0, 0.0, 0.0]\ntspan = (0.0, 100.0)\nprob = ODEProblem(lorenz_static, u0, tspan)\n@btime solve(prob, Tsit5());\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Installing and Using deSolveDiffEq.jl (R deSolve Wrappers) in Julia\nDESCRIPTION: This snippet details how to set up the deSolveDiffEq.jl package, a Julia wrapper for R's deSolve ODE suite. Installation requires adding the package from its GitHub repository using Julia's Pkg module and importing it with 'using'. Intended primarily for benchmarking or users transitioning from R, this approach results in significantly slower integration compared to native Julia codes due to R interop overhead.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_45\n\nLANGUAGE: julia\nCODE:\n```\nusing Pkg\nPkg.add(url = \"https://github.com/SciML/deSolveDiffEq.jl\")\nusing deSolveDiffEq\n\n```\n\n----------------------------------------\n\nTITLE: Generating Basic Solution Plots with Plots.jl in Julia\nDESCRIPTION: This snippet demonstrates the standard approach for plotting a solution object using Plots.jl's built-in recipes. The user first installs and imports Plots.jl, and simply calls plot(sol) to visualize the solution. Dependencies: Plots.jl must be installed and imported. Inputs: a solution object (e.g., ODESolution). Output: a default plot for the solution. This relies on the DiffEq system's recipes for appropriate visualizations.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/plot.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n#]add Plots # You need to install Plots.jl before your first time using it!\nusing Plots\nplot(sol) # Plots the solution\n```\n\n----------------------------------------\n\nTITLE: Defining StaticArray-Based System for Small ODEs - Julia\nDESCRIPTION: Illustrates the setup of a small ODE problem using StaticArrays for improved performance. Implements an out-of-place non-mutating function for the ROBER system, constructs initial conditions and parameters as SA vectors, and solves the problem using Rosenbrock23. Inputs: state `u` (SA), parameters `p` (SA), time `t`; output: next state as SA. Requires: StaticArrays.jl, DifferentialEquations.jl. Suitable for <20 ODEs for efficient, allocation-free computation.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_20\n\nLANGUAGE: julia\nCODE:\n```\nusing StaticArrays\nfunction rober_static(u, p, t)\n    yâ, yâ, yâ = u\n    kâ, kâ, kâ = p\n    du1 = -kâ * yâ + kâ * yâ * yâ\n    du2 = kâ * yâ - kâ * yâ^2 - kâ * yâ * yâ\n    du3 = kâ * yâ^2\n    SA[du1, du2, du3]\nend\nprob = ODEProblem(rober_static, SA[1.0, 0.0, 0.0], (0.0, 1e5), SA[0.04, 3e7, 1e4])\nsol = solve(prob, Rosenbrock23())\n```\n\n----------------------------------------\n\nTITLE: Running Ensemble Simulation with Multithreading in Julia\nDESCRIPTION: Demonstrates how to set up and solve an ODE ensemble problem using multithreading in Julia with DifferentialEquations.jl. It defines the ODE problem, the `prob_func` to randomize initial conditions (without `@everywhere`), creates the `EnsembleProblem`, and solves it using `EnsembleThreads()`. Assumes `JULIA_NUM_THREADS` environment variable is set. Finally, it plots the results.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_17\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\nprob = ODEProblem((u, p, t) -> 1.01u, 0.5, (0.0, 1.0))\nfunction prob_func(prob, i, repeat)\n    remake(prob, u0 = rand() * prob.u0)\nend\nensemble_prob = EnsembleProblem(prob, prob_func = prob_func)\nsim = solve(ensemble_prob, Tsit5(), EnsembleThreads(), trajectories = 10)\nusing Plots;\nplot(sim);\n```\n\n----------------------------------------\n\nTITLE: Default Non-Stiff Solver Tsit5 in Julia\nDESCRIPTION: `Tsit5` is the recommended algorithm for most non-stiff ODE problems in OrdinaryDiffEq.jl due to its efficiency.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nTsit5\n```\n\n----------------------------------------\n\nTITLE: Solving and Plotting Scalar SDEs using EM Algorithm in Julia\nDESCRIPTION: This snippet solves the previously defined scalar SDE problem with the Euler-Maruyama (EM) method and plots the resulting stochastic solution trajectory. It requires DifferentialEquations.jl and Plots.jl. Parameters are the SDEProblem, chosen algorithm (EM()), and time step dt. The solution is a time series object suitable for visualization.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/sde_example.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, EM(), dt = dt)\nusing Plots\nplot(sol)\n```\n\n----------------------------------------\n\nTITLE: Solving Steady State Problems with DifferentialEquations.jl (Julia)\nDESCRIPTION: These examples demonstrate the process of solving a steady state problem using DifferentialEquations.jl's 'solve' function with various algorithms, including SSRootfind and DynamicSS with Tsit5 and CVODE_BDF ODE solvers. Dependencies include Julia programming environment and packages such as DifferentialEquations.jl, SteadyStateDiffEq.jl, and Sundials.jl (for CVODE_BDF). Key parameters shown include problem definition ('prob'), solver algorithm selection, and additional keyword arguments like 'dt' (for initial step size) when using specific solvers like CVODE_BDF. The inputs are a steady state problem object and an algorithm instance, while the output is the computed steady state solution; users can customize behavior through algorithm choice and tolerances.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/steady_state_solve.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, SSRootfind())\nsol = solve(prob, DynamicSS(Tsit5()))\nusing Sundials\nsol = solve(prob, DynamicSS(CVODE_BDF()), dt = 1.0)\n```\n\n----------------------------------------\n\nTITLE: Defining and Solving an Ensemble ODE Problem with Callbacks in Julia\nDESCRIPTION: Defines the FitzHugh-Nagumo ODE system, sets up an `ODEProblem`, creates an `EnsembleProblem` to run multiple trajectories, defines a `ProbIntsUncertainty` callback from DiffEqCallbacks.jl, and solves the ensemble using the `Euler` method from OrdinaryDiffEq.jl. This example uses the full `DifferentialEquations.jl` package.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/low_dep.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\nfunction fitz(du, u, p, t)\n    V, R = u\n    a, b, c = p\n    du[1] = c * (V - V^3 / 3 + R)\n    du[2] = -(1 / c) * (V - a - b * R)\nend\nu0 = [-1.0; 1.0]\ntspan = (0.0, 20.0)\np = (0.2, 0.2, 3.0)\nprob = ODEProblem(fitz, u0, tspan, p)\ncb = ProbIntsUncertainty(0.2, 1)\nensemble_prob = EnsembleProblem(prob)\nsim = solve(ensemble_prob, Euler(), trajectories = 100, callback = cb, dt = 1 / 10)\n```\n\n----------------------------------------\n\nTITLE: Installing and Using IRKGaussLegendre.jl Symplectic Integrator in Julia\nDESCRIPTION: This snippet illustrates the installation and import process for the IRKGaussLegendre.jl package, which provides the IRKGL16 16th order symplectic Gauss-Legendre integrator specialized for Hamiltonian ODEs. Prerequisites are the Pkg and IRKGaussLegendre packages. The user must manually install the package, and options for integrator behavior are controlled through keyword arguments when constructing IRKGL16.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_40\n\nLANGUAGE: julia\nCODE:\n```\nusing Pkg\nPkg.add(\"IRKGaussLegendre\")\nusing IRKGaussLegendre\n\n```\n\n----------------------------------------\n\nTITLE: Including Docstrings for DiscreteProblem and DiscreteFunction in Julia Documentation\nDESCRIPTION: This snippet uses the `@docs` directive, commonly employed in Julia's Documenter.jl package within Markdown files, to automatically embed the documentation strings (docstrings) for `SciMLBase.DiscreteProblem` and `SciMLBase.DiscreteFunction` into the generated documentation page. This directive pulls documentation directly from the source code, assuming these types are defined and have associated docstrings within the SciMLBase module.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/discrete_types.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```@docs\nSciMLBase.DiscreteProblem\nSciMLBase.DiscreteFunction\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Condition for Bouncing Ball Event (Julia)\nDESCRIPTION: This Julia function `condition` defines the event trigger for the bouncing ball simulation. The event occurs when this function equals zero. It returns the height of the ball (`u[1]`), so the event triggers when the ball hits the ground (height is zero).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_26\n\nLANGUAGE: julia\nCODE:\n```\nfunction condition(u, t, integrator) # Event when condition(u,t,integrator) == 0\n    u[1]\nend\n```\n\n----------------------------------------\n\nTITLE: Adding and Using the LSODA.jl Package in Julia\nDESCRIPTION: Julia Pkg REPL command to add the `LSODA.jl` package dependency and the corresponding `using` statement to load it into the current Julia session. This is required to use the `lsoda()` solver.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_26\n\nLANGUAGE: julia-repl\nCODE:\n```\n]add LSODA; using LSODA\n```\n\n----------------------------------------\n\nTITLE: Symmetric Stiff Integrator Trapezoid in Julia\nDESCRIPTION: `Trapezoid` is a symmetric (almost symplectic) implicit integrator with adaptive timestepping, suitable for stiff problems.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_20\n\nLANGUAGE: julia\nCODE:\n```\nTrapezoid\n```\n\n----------------------------------------\n\nTITLE: Solving ODE with AutoAbstol Callback (Julia)\nDESCRIPTION: This Julia code sets up a simple ODE problem (`g`) and initializes an integrator (`BS3` method) with the previously created `AutoAbstol` callback (`cb`). It then performs one integration step (`step!(integrator)`) and compares the absolute tolerance before and after the step to demonstrate the callback's effect.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_23\n\nLANGUAGE: julia\nCODE:\n```\nfunction g(u, p, t)\n    -u[1]\nend\nu0 = 10.0\nconst V = 1\nprob = ODEProblem(g, u0, (0.0, 10.0))\nintegrator = init(prob, BS3(), callback = cb)\nat1 = integrator.opts.abstol\nstep!(integrator)\nat2 = integrator.opts.abstol\nat1 <= at2\n```\n\n----------------------------------------\n\nTITLE: Defining an ODE Right-Hand Side Function Using ArrayPartition - Julia\nDESCRIPTION: This snippet defines an ODE derivative function that operates on and modifies ArrayPartition data structures, capturing the logic for a two-part system (such as position and velocity). The function expects arguments for the derivative dy (ArrayPartition), current state y (ArrayPartition), parameter Î¼ (universal gravitational parameter), and time t. It demonstrates accessing subarrays via .x indexing and using broadcasting for efficient assignments. Works in conjunction with Julia packages like RecursiveArrayTools.jl and supports integration into ODEProblem definitions.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/diffeq_arrays.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nfunction f(dy, y, Î¼, t)\n    r = norm(y.x[1])\n    dy.x[1] .= y.x[2]\n    dy.x[2] .= -Î¼ .* y.x[1] / r^3\nend\n```\n\n----------------------------------------\n\nTITLE: Solving ODE with Callback (No tstops) in Julia\nDESCRIPTION: Demonstrates solving the previously defined ODE problem (`prob`) using the `Tsit5()` solver and the defined `DiscreteCallback` (`cb`). Crucially, `tstops` is not specified, meaning the callback condition `t==4` might be missed if the solver doesn't happen to step exactly at t=4. The result is plotted using `Plots`. Requires `DifferentialEquations` and `Plots`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\n```@example callback1\nsol = solve(prob, Tsit5(), callback = cb)\nplot(sol)\n```\n```\n\n----------------------------------------\n\nTITLE: Visualizing Planetary Orbits with Plots.jl (Julia)\nDESCRIPTION: Generates a 3D plot of planet orbits over the simulated time by iterating over each body in the solution and plotting its trajectory. Needs Plots.jl module, solution object from previous ODE solve, and the planet labels. For visualization only; does not affect simulation data. Output is a 3D plot labeled by planet, ready for display or export.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/outer_solar_system.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nplt = plot()\nfor i in 1:N\n    plot!(plt, sol, idxs = (u[:, i]...,), lab = planets[i])\nend\nplot!(plt; xlab = \"x\", ylab = \"y\", zlab = \"z\", title = \"Outer solar system\")\n```\n\n----------------------------------------\n\nTITLE: Solving a Scalar RODE with Default Wiener Process in Julia\nDESCRIPTION: Defines a scalar RODE function `f3(u, p, t, W) = 2u * sin(W)`, sets up an `RODEProblem` with an initial condition `u0=1.0` and time span `(0.0, 5.0)`. It solves the problem using the `RandomEM` method (Euler-Maruyama for random equations) with a fixed time step `dt = 1/100`. The solution trajectory is then plotted. Requires `DifferentialEquations.jl` and `Plots.jl`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/rode_example.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\nusing Plots\nfunction f3(u, p, t, W)\n    2u * sin(W)\nend\nu0 = 1.00\ntspan = (0.0, 5.0)\nprob = RODEProblem(f3, u0, tspan)\nsol = solve(prob, RandomEM(), dt = 1 / 100)\nplot(sol)\n```\n\n----------------------------------------\n\nTITLE: Iterating to Completion Using for Loop Over Integrator in SciMLBase (Julia)\nDESCRIPTION: Performs integration steps automatically in a for loop using the integrator itself as an iterator. Continues until the end condition is met, typically at the last tstop. No need to manually manage step counts; requires initialized integrator.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/integrator.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nfor i in integrator\nend\n```\n\n----------------------------------------\n\nTITLE: Installing and Using SciPyDiffEq.jl SciPy ODE Solvers in Julia\nDESCRIPTION: This snippet explains how to install and import SciPyDiffEq.jl, a package wrapping SciPy's C-based ODE solvers for use in Julia. Users must use the Pkg module to add SciPyDiffEq.jl via a GitHub URL. Although this wrapper facilitates easy transition and benchmarking for those familiar with SciPy, it is considerably slower compared to native Julia solvers. The code is for users wishing to reproduce SciPy results in Julia.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_44\n\nLANGUAGE: julia\nCODE:\n```\nusing Pkg\nPkg.add(url = \"https://github.com/SciML/SciPyDiffEq.jl\")\nusing SciPyDiffEq\n\n```\n\n----------------------------------------\n\nTITLE: Stiff Solver radau for Low Tolerances (Float64) in Julia\nDESCRIPTION: `radau` is recommended for stiff problems requiring low tolerances (<1e-9) when using `Vector{Float64}`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_17\n\nLANGUAGE: julia\nCODE:\n```\nradau\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Julia System Image with PackageCompiler.jl (Julia)\nDESCRIPTION: Demonstrates how to create a Julia system image with specific packages (DifferentialEquations, Plots) precompiled to reduce application startup time. Requires the PackageCompiler.jl package and appropriate permissions to alter the default system image. Key parameters: the list of package symbols to include in the system image, and 'replace_default' to make the new image the default. This approach speeds up package loading at the cost of requiring manual updates for new versions.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/index.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nusing PackageCompiler\nPackageCompiler.create_sysimage([:DifferentialEquations, :Plots]; replace_default = true)\n```\n\n----------------------------------------\n\nTITLE: Initializing and Solving an ODEProblem Using ArrayPartition Initial Condition - Julia\nDESCRIPTION: This snippet shows the canonical usage of DifferentialEquations.jl to set up and solve an ODEProblem using a custom ArrayPartition initial state and the previously defined ODE function. Dependencies include DifferentialEquations.jl, RecursiveArrayTools.jl, and Unitful.jl. It expects f (ODE function), rv0 (ArrayPartition initial state), a simulation time span, and parameter Î¼ as inputs, and outputs an ODESolution object via solve. This approach enables seamless multi-variable, units-aware, and type-stable integration with advanced DiffEq solvers (e.g., Vern8).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/diffeq_arrays.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nprob = ODEProblem(f, rv0, (0.0u\"s\", Ît), Î¼)\nsol = solve(prob, Vern8())\n```\n\n----------------------------------------\n\nTITLE: Setting up Parameterized Lorenz ODE Problem - DifferentialEquations.jl - Julia\nDESCRIPTION: Shows initialization of initial conditions, time span, parameters, and ODEProblem definition using a parameterized ODE function. Requires DifferentialEquations.jl. `u0` specifies initial state, `tspan` the interval, `p` the parameters for the Lorenz system, and `prob` is the problem packaged for solution.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/getting_started.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nu0 = [1.0, 0.0, 0.0]\ntspan = (0.0, 1.0)\np = [10.0, 28.0, 8 / 3]\nprob = ODEProblem(parameterized_lorenz!, u0, tspan, p)\n```\n\n----------------------------------------\n\nTITLE: Solving Systems of SDEs with Scalar Noise using Noise Process in Julia\nDESCRIPTION: This example illustrates solving a vector-valued SDE system subjected to a scalar WienerProcess, using the Noise Process interface. It sets up vector drift and diffusion, samples initial values, defines a custom Wiener process, and specifies a high-order solver (SRIW1). The output is a multivariate time-series solution. Dependencies: DifferentialEquations.jl and Plots.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/sde_example.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\nusing Plots\nf(du, u, p, t) = (du .= u)\ng(du, u, p, t) = (du .= u)\nu0 = rand(4, 2)\n\nW = WienerProcess(0.0, 0.0, 0.0)\nprob = SDEProblem(f, g, u0, (0.0, 1.0), noise = W)\nsol = solve(prob, SRIW1())\nplot(sol)\n```\n\n----------------------------------------\n\nTITLE: Solving a System of RODEs with Custom Noise Dimension in Julia\nDESCRIPTION: Illustrates solving a system of two RODEs where the driving Wiener noise process `W` has a different dimension (3) than the state vector `u` (2). This is achieved by passing `rand_prototype = zeros(3)` to the `RODEProblem` constructor, explicitly setting the noise dimension. The problem is solved using `RandomEM` with `dt=1/100`. Requires `DifferentialEquations.jl` and `Plots.jl`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/rode_example.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\nusing Plots\nfunction f(du, u, p, t, W)\n    du[1] = -2W[3] * u[1] * sin(W[1] - W[2])\n    du[2] = -2u[2] * cos(W[1] + W[2])\nend\nu0 = [1.00; 1.00]\ntspan = (0.0, 5.0)\nprob = RODEProblem(f, u0, tspan, rand_prototype = zeros(3))\nsol = solve(prob, RandomEM(), dt = 1 / 100)\nplot(sol)\n```\n\n----------------------------------------\n\nTITLE: Defining Objective Function for Optimization in Julia\nDESCRIPTION: Defines an objective function `f` for optimization. This function takes a time vector `t` (expected to have one element) and returns the value of the 4th state variable (`idxs=4`) from the ODE solution `sol` at that specific time `first(t)`. This function will be minimized to find local minima.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/min_and_max.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nf(t, _) = sol(first(t), idxs = 4)\n```\n\n----------------------------------------\n\nTITLE: Summarizing and Plotting Ensemble Statistics with EnsembleSummary in Julia\nDESCRIPTION: These snippets show how to compute and visualize summarizing statistics across an ensemble of SDE solutions using EnsembleSummary. It generates time-indexed means and quantiles, which are then plotted with error bars or shaded regions for uncertainty. Dependencies: DifferentialEquations.EnsembleAnalysis and Plots. Key parameters include the timepoints and quantiles for statistics.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/sde_example.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations.EnsembleAnalysis\nsumm = EnsembleSummary(sol, 0:0.01:1)\nplot(summ, labels = \"Middle 95%\")\nsumm = EnsembleSummary(sol, 0:0.01:1; quantiles = [0.25, 0.75])\nplot!(summ, labels = \"Middle 50%\", legend = true)\n```\n\n----------------------------------------\n\nTITLE: Mathematical Form of an Affine ODE\nDESCRIPTION: Presents the mathematical equation for an affine ODE, `u' = A(u,p,t)u + g(u,p,t)`, which includes an additive term `g`. The surrounding text notes that such equations can be converted into the standard linear form by augmenting the system.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/nonautonomous_linear_ode.md#_snippet_3\n\nLANGUAGE: math\nCODE:\n```\nu^\\prime = A(u,p,t)u + g(u,p,t)\n```\n\n----------------------------------------\n\nTITLE: Plotting and Animating Integrator Progress with Plots.jl (Julia)\nDESCRIPTION: Demonstrates advanced use by initializing a linear ODE problem, stepping the integrator, updating plots at each step using Plots.jl, and saving the final plot to a PNG. Integrates iteratively, displaying solution progress, and changes visualized indices as specified. Needs DifferentialEquations, DiffEqProblemLibrary, and Plots.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/integrator.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations, DiffEqProblemLibrary, Plots\n\n# Linear ODE which starts at 0.5 and solves from t=0.0 to t=1.0\nprob = ODEProblem((u, p, t) -> 1.01u, 0.5, (0.0, 1.0))\n\nusing Plots\nintegrator = init(prob, Tsit5(); dt = 1 // 2^(4), tstops = [0.5])\npyplot(show = true)\nplot(integrator)\nfor i in integrator\n    display(plot!(integrator, idxs = (0, 1), legend = false))\nend\nstep!(integrator);\nplot!(integrator, idxs = (0, 1), legend = false);\nsavefig(\"iteratorplot.png\")\n```\n\n----------------------------------------\n\nTITLE: Defining a Trivial Always-True Callback Condition in Julia\nDESCRIPTION: Defines a `condition` function for a `DiscreteCallback` that unconditionally returns `true`. This ensures that the associated `affect!` function will be executed after every successful time step taken by the ODE solver. This pattern is used in the AutoAbstol example where the absolute tolerance needs to be potentially updated at each step based on the solution's progress.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_18\n\nLANGUAGE: julia\nCODE:\n```\n```@example callback3\ncondition = function (u, t, integrator)\n    true\nend\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Base ODEProblem in DifferentialEquations.jl (Julia)\nDESCRIPTION: Defines a simple linear Ordinary Differential Equation (ODE) problem using `ODEProblem` from DifferentialEquations.jl. The equation is `du/dt = 1.01u`, with an initial condition `u0 = 0.5` and a time span `tspan = (0.0, 1.0)`. This serves as the base problem for an ensemble simulation.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\n# Linear ODE which starts at 0.5 and solves from t=0.0 to t=1.0\nprob = ODEProblem((u, p, t) -> 1.01u, 0.5, (0.0, 1.0))\n```\n\n----------------------------------------\n\nTITLE: Defining the N-body Gravitational Potential using ModelingToolkit.jl (Julia)\nDESCRIPTION: Symbolically constructs the N-body gravitational potential function using ModelingToolkit variables and Julia's broadcasting. Sets up constants, symbolic variables for positions, and the nested sum required for all unique pairs. Requires ModelingToolkit.jl and initialized mass/position arrays. Produces a potential energy symbolic term, which is later used to define system equations. Assumes prior initialization of masses (M) and planet count (N).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/outer_solar_system.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nconst â = sum\nconst N = 6\n@variables t u(t)[1:3, 1:N]\nu = collect(u)\nD = Differential(t)\npotential = -G *\n            â(\n    i -> â(j -> (M[i] * M[j]) / â(â(k -> (u[k, i] - u[k, j])^2, 1:3)), 1:(i - 1)),\n    2:N)\n```\n\n----------------------------------------\n\nTITLE: Constructing EnsembleSummary Objects in DifferentialEquations.jl (Julia)\nDESCRIPTION: Shows the constructors for the `EnsembleSummary` type in Julia's DifferentialEquations.jl. The first constructor calculates mean and variance at each simulation time step (assuming consistent steps across trajectories). The second calculates these statistics at specified time points `ts` using interpolation. Both allow specifying quantiles (defaulting to 5% and 95%) for confidence intervals.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nEnsembleSummary(sim; quantiles = [0.05, 0.95])\nEnsembleSummary(sim, ts; quantiles = [0.05, 0.95])\n```\n\n----------------------------------------\n\nTITLE: Solving Linear ODEs with LinearExponential in Julia\nDESCRIPTION: This Julia snippet demonstrates how to solve a non-autonomous linear ODE with a constant operator using DifferentialEquations.jl's LinearExponential algorithm. Required dependencies are DifferentialEquations and SciMLOperators, and the problem is set up to use a 2x2 matrix as a constant operator. Inputs include the operator matrix (_A), initial conditions, and the time span, with the output being the solution object. This approach is exact for the operator, and the code illustrates both setup and invocation of the solver.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/nonautonomous_linear_ode.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations, SciMLOperators\n_A = [2 -1; -3 -5] / 5\nA = SciMLOperators.MatrixOperator(_A)\nprob = ODEProblem(A, [1.0, -1.0], (1.0, 6.0))\nsol = solve(prob, LinearExponential())\n```\n\n----------------------------------------\n\nTITLE: Specifying Initial Conditions for an Implicit DAE in Julia\nDESCRIPTION: This snippet initializes the state and derivative vectors along with the time span for solving the implicit form of the Robertson DAE in Julia. These initial conditions are necessary when constructing a DAEProblem with consistent starting values. The snippet is dependency-free but intended for use as arguments to DAEProblem; key variables include the initial state (uâ), its derivative (duâ), and the time interval (tspan).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/dae_example.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nuâ = [1.0, 0, 0]\nduâ = [-0.04, 0.04, 0.0]\ntspan = (0.0, 100000.0)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Tolerance Increase with AutoAbstol (Julia)\nDESCRIPTION: This snippet continues the previous example by taking another integration step (`step!(integrator)`) and comparing the absolute tolerance (`at3`) with the previous step's tolerance (`at2`). This further illustrates that the `AutoAbstol` callback is increasing the absolute tolerance as the solution evolves.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_24\n\nLANGUAGE: julia\nCODE:\n```\nstep!(integrator)\nat3 = integrator.opts.abstol\nat2 <= at3\n```\n\n----------------------------------------\n\nTITLE: Installing and Using SimpleDiffEq.jl Simplified ODE Solvers in Julia\nDESCRIPTION: This code demonstrates installing and importing SimpleDiffEq.jl, a package offering simplified experimental ODE solvers for Julia users. Dependencies are the Pkg utility and SimpleDiffEq package. Suitable for experimentation with quick compile times, these solvers are limited in feature set and performance compared to the standard OrdinaryDiffEq.jl, and are accessed after explicit installation.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_41\n\nLANGUAGE: julia\nCODE:\n```\nusing Pkg\nPkg.add(\"SimpleDiffEq\")\nusing SimpleDiffEq\n\n```\n\n----------------------------------------\n\nTITLE: Defining and Using an IncompleteLU Preconditioner with KenCarp47 in Julia\nDESCRIPTION: This snippet defines a function `incompletelu` that creates an Incomplete LU (ILU) preconditioner using `IncompleteLU.ilu`. It updates the preconditioner only when `newW` is true or `nothing`. It then demonstrates solving a sparse Brusselator ODE problem (`prob_ode_brusselator_2d_sparse`) using the `KenCarp47` method with `KrylovJL_GMRES` as the linear solver and the defined `incompletelu` function as the preconditioner. The `concrete_jac = true` option ensures the sparse Jacobian is computed. A workaround for a Krylov.jl bug is included by defining `Base.eltype` for the ILU factorization type. Dependencies include `IncompleteLU.jl` and `DifferentialEquations.jl` (implied by `solve`).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/advanced_ode_example.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\nusing IncompleteLU\nfunction incompletelu(W, du, u, p, t, newW, Plprev, Prprev, solverdata)\n    if newW === nothing || newW\n        Pl = ilu(convert(AbstractMatrix, W), Ï = 50.0)\n    else\n        Pl = Plprev\n    end\n    Pl, nothing\nend\n\n# Required due to a bug in Krylov.jl: https://github.com/JuliaSmoothOptimizers/Krylov.jl/pull/477\nBase.eltype(::IncompleteLU.ILUFactorization{Tv, Ti}) where {Tv, Ti} = Tv\n\n@btime solve(prob_ode_brusselator_2d_sparse,\n    KenCarp47(linsolve = KrylovJL_GMRES(), precs = incompletelu,\n        concrete_jac = true), save_everystep = false);\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Constructing a Time-Dependent Non-autonomous Linear ODE in Julia\nDESCRIPTION: Demonstrates how to define and construct a non-autonomous linear ODE problem in Julia where the operator `A` depends only on time (`A(t)`). It uses `MatrixOperator` from SciMLOperators.jl with an `update_func` to modify the matrix `A` at each time step, and then creates an `ODEProblem` suitable for DifferentialEquations.jl solvers.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/nonautonomous_linear_ode.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nfunction update_func(A, u, p, t)\n    A[1, 1] = cos(t)\n    A[2, 1] = sin(t)\n    A[1, 2] = -sin(t)\n    A[2, 2] = cos(t)\nend\n\nusing SciMLOperators\nA = MatrixOperator(ones(2, 2), update_func = update_func)\nprob = ODEProblem(A, ones(2), (10, 50.0))\n```\n\n----------------------------------------\n\nTITLE: Defining Alpha Synapse and Hodgkin-Huxley Model in Julia\nDESCRIPTION: Defines the synaptic conductance function 'gSyn' and the main Hodgkin-Huxley (HH) neuron ODE system. The conductance rises instantaneously at event onset (tf) and decays exponentially with time constant 'tau'. Dependencies are Julia base math (exp) and auxiliary rate functions (alpha_n, beta_n, etc.), assumed to be defined elsewhere. Parameters include synaptic and membrane properties; input 'du' is updated in-place, and 'ISyn' models the synaptic current for ODE integration.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\nfunction gSyn(max_gsyn, tau, tf, t)\n    if t - tf >= 0\n        return max_gsyn * exp(-(t - tf) / tau)\n    else\n        return 0.0\n    end\nend\nfunction HH!(du, u, p, t)\n    gK, gNa, gL, EK, ENa, EL, C, I, max_gSyn, ESyn, tau, tf = p\n    v, n, m, h = u\n\n    ISyn = gSyn(max_gSyn, tau, tf, t) * (v - ESyn)\n\n    du[1] = (-(gK * (n^4.0) * (v - EK)) - (gNa * (m^3.0) * h * (v - ENa)) -\n             (gL * (v - EL)) + I - ISyn) / C\n    du[2] = (alpha_n(v) * (1.0 - n)) - (beta_n(v) * n)\n    du[3] = (alpha_m(v) * (1.0 - m)) - (beta_m(v) * m)\n    du[4] = (alpha_h(v) * (1.0 - h)) - (beta_h(v) * h)\nend\n```\n\n----------------------------------------\n\nTITLE: Installing DifferentialEquations.jl with Julia Package Manager - Julia\nDESCRIPTION: This Julia snippet demonstrates installation of the DifferentialEquations.jl package using the standard Julia package manager (Pkg). First, it imports the Pkg module, and then it invokes the add command to install the package and all dependencies. Input: none. Output: DifferentialEquations.jl available for use. Requires Julia and an active internet connection.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/index.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nusing Pkg\\nPkg.add(\\\"DifferentialEquations\\\")\n```\n\n----------------------------------------\n\nTITLE: Computing Ensemble Summary Statistics by Time Step - SciML - Julia\nDESCRIPTION: Groups useful functions to compute the mean, median, quantile, variance, covariance, and correlation of simulation results at a given time step index. Each takes in an `EnsembleSimulation` and relevant parameters (index, quantile, weights), returning aggregate statistics. Prerequisites include an ensemble simulation object and optional data arrays for weighting or cross-step statistics.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\ntimestep_mean(sim, i) # Computes the mean of each component at time step i\ntimestep_median(sim, i) # Computes the median of each component at time step i\ntimestep_quantile(sim, q, i) # Computes the quantile q of each component at time step i\ntimestep_meanvar(sim, i)  # Computes the mean and variance of each component at time step i\ntimestep_meancov(sim, i, j) # Computes the mean at i and j, and the covariance, for each component\ntimestep_meancor(sim, i, j) # Computes the mean at i and j, and the correlation, for each component\ntimestep_weighted_meancov(sim, W, i, j) # Computes the mean at i and j, and the weighted covariance W, for each component\n```\n\n----------------------------------------\n\nTITLE: Specifying Absolute and Relative Tolerances for ODE Solver - Julia\nDESCRIPTION: Illustrates how to increase the accuracy of an ODE solution by passing strict absolute and relative tolerances to the solve function. Inputs: problem definition (prob), algorithm (alg), keyword arguments abstol and reltol. Output: more accurate solution at potentially higher computational cost. Dependencies: DifferentialEquations.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_27\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, alg, abstol = 1e-10, reltol = 1e-10)\n```\n\n----------------------------------------\n\nTITLE: Solving a Semi-Explicit Boundary Value DAE (BVDAE) in Julia\nDESCRIPTION: This snippet demonstrates solving a semi-explicit Boundary Value Differential-Algebraic Equation (BVDAE). It defines the DAE system function `f!` and the boundary condition function `bc!`. Crucially, it wraps these into a `BVPFunction`, specifying the `mass_matrix` to indicate the algebraic constraints (where the matrix has zero rows). The `BVProblem` is then constructed and solved using an appropriate method for BVDAEs, `Ascher4`, again using automatic differentiation for the Jacobian.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/bvp_example.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\nfunction f!(du, u, p, t)\n    e = 2.7\n    du[1] = (1 + u[2] - sin(t)) * u[4] + cos(t)\n    du[2] = cos(t)\n    du[3] = u[4]\n    du[4] = (u[1] - sin(t)) * (u[4] - e^t)\nend\nfunction bc!(res, u, p, t)\n    res[1] = u[1]\n    res[2] = u[3] - 1\n    res[3] = u[2] - sin(1.0)\nend\nu0 = [0.0, 0.0, 0.0, 0.0]\ntspan = (0.0, 1.0)\nfun = BVPFunction(f!, bc!, mass_matrix = [1 0 0 0; 0 1 0 0; 0 0 1 0; 0 0 0 0])\nprob = BVProblem(fun, u0, tspan)\nsol = solve(prob,\n    Ascher4(zeta = [0.0, 0.0, 1.0], jac_alg = BVPJacobianAlgorithm(AutoForwardDiff())),\n    dt = 0.01)\n```\n\n----------------------------------------\n\nTITLE: Indexing Solutions from ODE sol - DifferentialEquations.jl - Julia\nDESCRIPTION: Illustrates extracting solution data points and timeseries from the solution object returned by DifferentialEquations.jl solvers. Examples show retrieving the full state at a given time (by timestep index), specific components, or the time-evolution for a single array entry. These operations help analyze and visualize computed solution trajectories. No external dependencies beyond DifferentialEquations.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/getting_started.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\nsol[4]\n```\n\nLANGUAGE: julia\nCODE:\n```\nsol[5, 3]\n```\n\nLANGUAGE: julia\nCODE:\n```\nsol[2, 1, :]\n```\n\n----------------------------------------\n\nTITLE: Creating and Typing StaticArrays for Fast Small ODEs in Julia\nDESCRIPTION: Demonstrates usage of StaticArrays.jl to construct a statically-allocated SVector (size known at compile-time). Shows how to declare, create, and inspect a StaticArray for non-allocating performance. Dependencies: StaticArrays.jl package. Limitations: Only use for small systems (\\u224820 variables), as larger ones can slow compilation and be forced to heap.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nusing StaticArrays\nA = SA[2.0, 3.0, 5.0]\ntypeof(A) # SVector{3, Float64} (alias for SArray{Tuple{3}, Float64, 1, 3})\n```\n\n----------------------------------------\n\nTITLE: Defining Discrete Diffusion Operator Matrix using Tridiagonal in Julia\nDESCRIPTION: Initializes a Tridiagonal matrix `\\u2207\\u00b2` representing the discrete Laplacian operator for the interior domain using the predefined stencil `\\u2207\\u00b2_op`. It then modifies the first and last rows/elements to incorporate the Neumann (bottom, index 1) and Dirichlet (top, index n+1) boundary conditions, respectively, ensuring `\\u2202_t T = 0` at the top boundary face. Finally, it scales the operator by the thermal diffusivity `\\u03b1` to create the diffusion operator `D`. Depends on parameters `n`, `FT`, `\\u2207\\u00b2_op`, `\\u0394z\\u00b2`, `\\u03b1`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/diffusion_implicit_heat_equation.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\n# Initialize interior and boundary stencils:\n\\u2207\\u00b2 = Tridiagonal(ones(FT, n) .* \\u2207\\u00b2_op[1],\n    ones(FT, n + 1) .* \\u2207\\u00b2_op[2],\n    ones(FT, n) .* \\u2207\\u00b2_op[3]);\n\n# Modify boundary stencil to account for BCs\n\n\\u2207\\u00b2.d[1] = -2 / \\u0394z\\u00b2\n\\u2207\\u00b2.du[1] = +2 / \\u0394z\\u00b2\n\n# Modify boundary stencil to account for BCs\n\\u2207\\u00b2.du[n] = 0  # modified stencil\n\\u2207\\u00b2.d[n + 1] = 0 # to ensure `\\u2202_t T = 0` at `z=zmax`\n\\u2207\\u00b2.dl[n] = 0  # to ensure `\\u2202_t T = 0` at `z=zmax`\nD = \\u03b1 .* \\u2207\\u00b2\n```\n\n----------------------------------------\n\nTITLE: Auto-Switching Solvers for Unknown Stiffness (Low Tolerances) in Julia\nDESCRIPTION: Recommended auto-switching algorithms for problems with unknown stiffness at lower tolerances. Combinations like `AutoVern7` or `AutoVern9` paired with stiff solvers such as `Rodas4`, `KenCarp4`, or `Rodas5P` are suggested depending on the specific problem.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nAutoVern7\n```\n\nLANGUAGE: julia\nCODE:\n```\nAutoVern9\n```\n\nLANGUAGE: julia\nCODE:\n```\nRodas4\n```\n\nLANGUAGE: julia\nCODE:\n```\nKenCarp4\n```\n\nLANGUAGE: julia\nCODE:\n```\nRodas5P\n```\n\n----------------------------------------\n\nTITLE: Visualizing Underlying State Variables in Short-Term Depression Scenario in Julia\nDESCRIPTION: Plots u and R (variables 5 and 6) for the model configured to display short-term depression, using results generated previously. Useful for comparing underlying state trajectories between depression and facilitation scenarios.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_24\n\nLANGUAGE: julia\nCODE:\n```\nplot(sol, vars = [5, 6])\n```\n\n----------------------------------------\n\nTITLE: Defining a Base SDEProblem for Lotka-Volterra System (Julia)\nDESCRIPTION: Constructs a Stochastic Differential Equation (SDE) problem for a Lotka-Volterra system using `SDEProblem` from DifferentialEquations.jl. It takes the previously defined drift (`f`) and diffusion (`g`) functions, initial state `[1.0, 1.0]`, time span `(0.0, 10.0)`, and parameter vector `p = [1.5, 1.0, 0.1, 0.1]`. This serves as the base problem for an ensemble study.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_21\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\np = [1.5, 1.0, 0.1, 0.1]\nprob = SDEProblem(f, g, [1.0, 1.0], (0.0, 10.0), p)\n```\n\n----------------------------------------\n\nTITLE: Solving Kepler Problem with Adaptive RKN Solver (DPRKN6) in Julia\nDESCRIPTION: Solves the Kepler `DynamicalODEProblem` using the `DPRKN6` adaptive Runge-Kutta-NystrÃ¶m integrator. Unlike the fixed-step symplectic integrator, `dt` is not required as the solver adapts its step size. It prints the number of steps taken by the adaptive solver using `@show sol2.u |> length` and then calls `analysis_plot` to visualize the orbit and first integral variations for this solver. Requires `OrdinaryDiffEq`, `Plots`, and the problem definition (`prob`, `H`, `L`) from previous snippets.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/kepler_problem.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nsol2 = solve(prob, DPRKN6())  # dt is not necessary, because unlike symplectic\n# integrators DPRKN6 is adaptive\n@show sol2.u |> length\nanalysis_plot(sol2, H, L)\n```\n\n----------------------------------------\n\nTITLE: Function Map Update with Scaling by Time (Mathematical Notation)\nDESCRIPTION: This LaTeX math formula describes the update rule when the scale_by_time option is true. The update adds the evaluated function times the time step dt to the current state. This is equivalent to the forward Euler method for ODEs but applied in a discrete context with piecewise constant interpolation.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/discrete_solve.md#_snippet_3\n\nLANGUAGE: math\nCODE:\n```\nu_{n+1} = u_n + dtf(t_{n+1},u_n).\n```\n\n----------------------------------------\n\nTITLE: Defining a State-Dependent Linear Operator Update Function in Julia\nDESCRIPTION: Provides an example `update_func` for a `MatrixOperator` where the operator `A`'s components depend on the current state vector `u`. This function would be used within the SciMLOperators framework to define a state-dependent linear ODE `u' = A(u,p,t)u`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/nonautonomous_linear_ode.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nfunction update_func(A, u, p, t)\n    A[1, 1] = 0\n    A[2, 1] = 1\n    A[1, 2] = -2 * (1 - cos(u[2]) - u[2] * sin(u[2]))\n    A[2, 2] = 0\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Condition for Cell Division Event in Julia\nDESCRIPTION: Defines the `condition` function for a `ContinuousCallback`. The event triggers (function equals zero) when the maximum protein concentration among all cells (`maximum(u)`) reaches 1.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_44\n\nLANGUAGE: julia\nCODE:\n```\nfunction condition(u, t, integrator) # Event when condition(u,t,integrator) == 0\n    1 - maximum(u)\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Parameterized ODE Problem for AD - DifferentialEquations.jl - Julia\nDESCRIPTION: Defines a parameterized ODE system (Lotka-Volterra), suitable for automatic differentiation by ensuring that initial conditions and timespans are typed according to the parameter array. Requires DifferentialEquations.jl. The function f(p) sets up and solves the ODE, returning the endpoint solution for the parameter set p. Parameters, tspan, and initial conditions are all potentially Dual numbers for AD compatibility.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_28\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\nfunction func(du, u, p, t)\n    du[1] = p[1] * u[1] - p[2] * u[1] * u[2]\n    du[2] = -3 * u[2] + u[1] * u[2]\nend\nfunction f(p)\n    prob = ODEProblem(func, eltype(p).([1.0, 1.0]), (0.0, 10.0), p)\n    # Lower tolerances to show the methods converge to the same value\n    solve(prob, Tsit5(), save_everystep = false, abstol = 1e-12, reltol = 1e-12)[end]\nend\n```\n\n----------------------------------------\n\nTITLE: Defining and Discretizing the 2D Brusselator PDE as an ODEProblem in DifferentialEquations.jl (Julia)\nDESCRIPTION: This snippet defines a 2D Brusselator PDE on a periodic unit square, discretizes it using finite differences, and constructs an ODEProblem suitable for stiff solver benchmarks. It sets up grid generation, nonlinear and Laplacian terms, implements initial conditions, and packs the solution fields into a 3D array. Key dependencies are DifferentialEquations, LinearAlgebra, and SparseArrays. Parameters include grid size N, timestep dx, and field initialization; outputs are ready-to-solve problem instances for stiff ODE solvers.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/advanced_ode_example.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations, LinearAlgebra, SparseArrays\n\nconst N = 32\nconst xyd_brusselator = range(0, stop = 1, length = N)\nbrusselator_f(x, y, t) = (((x - 0.3)^2 + (y - 0.6)^2) <= 0.1^2) * (t >= 1.1) * 5.0\nlimit(a, N) = a == N + 1 ? 1 : a == 0 ? N : a\nfunction brusselator_2d_loop(du, u, p, t)\n    A, B, alpha, dx = p\n    alpha = alpha / dx^2\n    @inbounds for I in CartesianIndices((N, N))\n        i, j = Tuple(I)\n        x, y = xyd_brusselator[I[1]], xyd_brusselator[I[2]]\n        ip1, im1, jp1, jm1 = limit(i + 1, N), limit(i - 1, N), limit(j + 1, N),\n        limit(j - 1, N)\n        du[i, j, 1] = alpha * (u[im1, j, 1] + u[ip1, j, 1] + u[i, jp1, 1] + u[i, jm1, 1] -\n                       4u[i, j, 1]) +\n                      B + u[i, j, 1]^2 * u[i, j, 2] - (A + 1) * u[i, j, 1] +\n                      brusselator_f(x, y, t)\n        du[i, j, 2] = alpha * (u[im1, j, 2] + u[ip1, j, 2] + u[i, jp1, 2] + u[i, jm1, 2] -\n                       4u[i, j, 2]) +\n                      A * u[i, j, 1] - u[i, j, 1]^2 * u[i, j, 2]\n    end\nend\np = (3.4, 1.0, 10.0, step(xyd_brusselator))\n\nfunction init_brusselator_2d(xyd)\n    N = length(xyd)\n    u = zeros(N, N, 2)\n    for I in CartesianIndices((N, N))\n        x = xyd[I[1]]\n        y = xyd[I[2]]\n        u[I, 1] = 22 * (y * (1 - y))^(3 / 2)\n        u[I, 2] = 27 * (x * (1 - x))^(3 / 2)\n    end\n    u\nend\nu0 = init_brusselator_2d(xyd_brusselator)\nprob_ode_brusselator_2d = ODEProblem(brusselator_2d_loop, u0, (0.0, 11.5), p)\n\n```\n\n----------------------------------------\n\nTITLE: Installing and Using DiffEqDevTools for ODE Tableau Utilities in Julia\nDESCRIPTION: This snippet guides adding DiffEqDevTools.jl from the registry and importing it, unlocking access to numerous ODE tableaus and stability region plot recipes. Dependencies: Julia. Use for benchmarking, comparing, or constructing ODE solver tableaus. Input/Output: None, just module loaded.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_51\n\nLANGUAGE: julia\nCODE:\n```\nusing Pkg\nPkg.add(\"DiffEqDevTools\")\nusing DiffEqDevTools\n```\n\n----------------------------------------\n\nTITLE: Setting up and Solving HÃ©non-Heiles ODE with Vern9 in Julia\nDESCRIPTION: This snippet sets up the HÃ©non-Heiles system as a first-order ODE problem in Julia. It defines the potential energy (V) and total energy (E) functions, specifies the system's differential equations in the `HÃ©non_Heiles` function, defines initial conditions and timespan, creates an `ODEProblem`, and solves it using the `Vern9` integrator with high precision tolerances. Requires `OrdinaryDiffEq` and `Plots` packages.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/classical_physics.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nusing OrdinaryDiffEq, Plots\n\n#Setup\ninitial = [0.0, 0.1, 0.5, 0]\ntspan = (0, 100.0)\n\n#Remember, V is the potential of the system and T is the Total Kinetic Energy, thus E will\n#the total energy of the system.\nV(x, y) = 1 // 2 * (x^2 + y^2 + 2x^2 * y - 2 // 3 * y^3)\nE(x, y, dx, dy) = V(x, y) + 1 // 2 * (dx^2 + dy^2);\n\n#Define the function\nfunction HÃ©non_Heiles(du, u, p, t)\n    x = u[1]\n    y = u[2]\n    dx = u[3]\n    dy = u[4]\n    du[1] = dx\n    du[2] = dy\n    du[3] = -x - 2x * y\n    du[4] = y^2 - y - x^2\nend\n\n#Pass to solvers\nprob = ODEProblem(HÃ©non_Heiles, initial, tspan)\nsol = solve(prob, Vern9(), abstol = 1e-16, reltol = 1e-16);\n```\n\n----------------------------------------\n\nTITLE: Example Implicit/Stiff Solvers in Julia SciML\nDESCRIPTION: Provides a list of solvers generally suitable for stiff ODEs, including `Rodas5()`, `Rosenbrock23()`, `TRBDF2()`, `KenCarp4()`, and `QNDF()`. Switching to one of these is recommended if `maxiters` is frequently exceeded with explicit methods.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_18\n\nLANGUAGE: julia\nCODE:\n```\nRodas5(), Rosenbrock23(), TRBDF2(), KenCarp4(), QNDF()\n```\n\n----------------------------------------\n\nTITLE: Plotting HÃ©non-Heiles Phase Space and Checking Solver Return Code (Vern9 Solution) in Julia\nDESCRIPTION: This snippet first displays the return code (`retcode`) of the `Vern9` solver to check for success or issues. It then uses the `Plots` package in Julia to visualize the phase space of the HÃ©non-Heiles system. It plots position ('x', index 1) vs. velocity ('dx', index 3) and overlays position ('y', index 2) vs. velocity ('dy', index 4) from the `sol` object.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/classical_physics.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\n#Optional Sanity check - what do you think this returns and why?\n@show sol.retcode\n\n#Plot -\nplot(sol, idxs = (1, 3), title = \"Phase space for the HÃ©non-Heiles system\",\n    xaxis = \"Position\", yaxis = \"Velocity\")\nplot!(sol, idxs = (2, 4), leg = false)\n```\n\n----------------------------------------\n\nTITLE: Accessing Solution Component and Timestep - SciMLBase - Julia\nDESCRIPTION: Shows how to access a specific component at a particular timestep of the solution using two indices. For multidimensional solutions, 'sol[i, j]' returns the i-th component at the j-th timestep. Assumes a compatible solution type from a SciMLBase solver.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/solution.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nsol[i, j]\n```\n\n----------------------------------------\n\nTITLE: Modifying Absolute Tolerance for Integration Steps in SciMLBase (Julia)\nDESCRIPTION: Directly modifies the absolute tolerance option for future time steps by changing the abstol field inside the integrator's opts structure. Affects subsequent step behavior by increasing solution accuracy or computational cost. Only valid after integrator initialization and if the solver algorithm supports run-time option mutation.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/integrator.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nintegrator.opts.abstol = 1e-9\n```\n\n----------------------------------------\n\nTITLE: Setting up and Solving HÃ©non-Heiles as Second-Order ODE with Symplectic Integrator (KahanLi8) in Julia\nDESCRIPTION: This snippet demonstrates solving the HÃ©non-Heiles system using a symplectic integrator, which is often preferred for Hamiltonian systems to conserve energy better. It defines the acceleration function `HH_acceleration!` directly, sets up a `SecondOrderODEProblem` with initial positions and velocities, and solves it using the `KahanLi8` symplectic integrator with a fixed time step `dt`. Requires the `OrdinaryDiffEq` package.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/classical_physics.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\nfunction HH_acceleration!(dv, v, u, p, t)\n    x, y = u\n    dx, dy = dv\n    dv[1] = -x - 2x * y\n    dv[2] = y^2 - y - x^2\nend\ninitial_positions = [0.0, 0.1]\ninitial_velocities = [0.5, 0.0]\nprob = SecondOrderODEProblem(HH_acceleration!, initial_velocities, initial_positions, tspan)\nsol2 = solve(prob, KahanLi8(), dt = 1 / 10);\n```\n\n----------------------------------------\n\nTITLE: Constructing MethodOfSteps DDE Algorithm in Julia\nDESCRIPTION: This Julia code demonstrates how to instantiate the MethodOfSteps algorithm for DDEs, wrapping an ODE solver such as those provided by OrdinaryDiffEq.jl. The function allows configuration of lag handling, fixed-point solver details, and whether the solver should use constrained timestepping to manage stability. Parameters include 'alg' for algorithm selection, 'constrained' to restrict step sizes, and customized fixed-point solvers with options such as max_iter. It requires DifferentialEquations.jl and OrdinaryDiffEq.jl installed, and outputs an algorithm instance suitable for passing to 'solve' with a defined DDE problem.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/dde_solve.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nMethodOfSteps(alg; constrained = false, fpsolve = NLFunctional(; max_iter = 10))\n```\n\n----------------------------------------\n\nTITLE: Compute Timestep Mean and Variance on Ensemble Simulations - DifferentialEquations.EnsembleAnalysis.jl - Julia\nDESCRIPTION: Uses timestep_meanvar to obtain mean and variance for the third timestep across ensemble simulations. DifferentialEquations.EnsembleAnalysis is required. Inputs: ensemble solution, timestep index. Outputs: mean and variance for the given step. Useful for evaluating statistics at discretized time points.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_33\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations.EnsembleAnalysis\nm, v = timestep_meanvar(sim, 3)\n```\n\n----------------------------------------\n\nTITLE: Plotting the LIF Neuron Simulation Results in Julia\nDESCRIPTION: Visualizes the simulation results stored in the `sol` object (output of `solve(prob)`) using the `plot` function. This generates a plot showing the membrane potential of the LIF neuron model over the simulated time span, illustrating its resting state, response to input current steps, and spiking behavior. Requires the `Plots` package and a solution object `sol` from `DifferentialEquations.jl`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nplot(sol)\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for Two Constant Delay DDE Problems\nDESCRIPTION: Similar to the single delay block, this Documenter.jl `@docs` directive generates documentation for pre-defined DDE problems from `DDEProblemLibrary` that feature two constant delays. It includes in-place (`_ip`), out-of-place (`_oop`), scalar versions, and longer time span (`_long`) variants.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/dde_types.md#_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n```@docs\nprob_dde_constant_2delays_ip\nprob_dde_constant_2delays_oop\nprob_dde_constant_2delays_scalar\nprob_dde_constant_2delays_long_ip\nprob_dde_constant_2delays_long_oop\nprob_dde_constant_2delays_long_scalar\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom AbstractController - Julia\nDESCRIPTION: Shows how to define a custom controller for adaptive timestepping by creating a new struct subtype of AbstractController. Requires the base AbstractController type from the host package. No fields or methods by default; users are expected to extend relevant functions.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/extras/timestepping.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nstruct CustomController <: AbstractController\nend\n```\n```\n\n----------------------------------------\n\nTITLE: Accessing Indexed Delays in DDEs with idxs Keyword in Julia\nDESCRIPTION: Shows a DDE function that efficiently accesses only the required delayed component using the idxs keyword argument when calling the history function. Inputs are as usual for a DDE but now h(p, t - tau; idxs=3) retrieves only the third component. Reduces unnecessary memory allocations. Assumes history function supports idxs.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/dde_example.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nfunction bc_model(du, u, h, p, t)\n    u3_past_sq = h(p, t - tau; idxs = 3)^2\n    du[1] = (v0 / (1 + beta0 * (u3_past_sq))) * (p0 - q0) * u[1] - d0 * u[1]\n    du[2] = (v0 / (1 + beta0 * (u3_past_sq))) * (1 - p0 + q0) * u[1] +\n            (v1 / (1 + beta1 * (u3_past_sq))) * (p1 - q1) * u[2] - d1 * u[2]\n    du[3] = (v1 / (1 + beta1 * (u3_past_sq))) * (1 - p1 + q1) * u[2] - d2 * u[3]\nend\n```\n\n----------------------------------------\n\nTITLE: Illustrating Finite-Time Undefined Solution in an ODE\nDESCRIPTION: Shows an example ODE, `u' = -sqrt(u)` with `u(0)=1`, which demonstrates that a solution can reach a point (u=0) in finite time where its derivative is defined, but the solution itself becomes undefined (non-real) beyond that point. This highlights potential pitfalls in assuming solution behavior based on derivative values alone.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nu' = -sqrt(u)\n```\n\n----------------------------------------\n\nTITLE: Including SciMLBase SDDE Problem and Function Documentation (Julia)\nDESCRIPTION: This code uses the `@docs` macro within a Julia documentation file (likely using Documenter.jl) to automatically insert the docstrings for the `SciMLBase.SDDEProblem` and `SciMLBase.SDDEFunction` types. These types are fundamental for defining Stochastic Delay Differential Equation problems within the SciML ecosystem.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/sdde_types.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n@docs\nSciMLBase.SDDEProblem\nSciMLBase.SDDEFunction\n```\n\n----------------------------------------\n\nTITLE: Installing and Using MATLABDiffEq.jl MATLAB ODE Solvers in Julia\nDESCRIPTION: This snippet provides the installation and import instructions for MATLABDiffEq.jl, which enables Julia access to MATLAB's suite of ODE solvers (such as ode23, ode45) through a wrapper. It requires a licensed MATLAB installation, the use of Julia's Pkg standard module, and installation from a specific GitHub URL. The purpose is to provide interoperability with MATLAB algorithms for users bridging between the ecosystems.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_43\n\nLANGUAGE: julia\nCODE:\n```\nusing Pkg\nPkg.add(url = \"https://github.com/SciML/MATLABDiffEq.jl\")\nusing MATLABDiffEq\n\n```\n\n----------------------------------------\n\nTITLE: Installing and Using NeuralPDE Neural Network ODE Solvers in Julia\nDESCRIPTION: This snippet explains installing NeuralPDE.jl (registered package) and importing it for neural network-based ODE solving with Flux.jl. Prerequisites: Julia, Flux.jl for custom chains, and optionally Zygote.jl. Inputs: None; Output: NeuralPDE module loaded to define nnode solvers.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_50\n\nLANGUAGE: julia\nCODE:\n```\nusing Pkg\nPkg.add(\"NeuralPDE\")\nusing NeuralPDE\n```\n\n----------------------------------------\n\nTITLE: Declaring Explicit Jacobian Function for ODEs - Julia\nDESCRIPTION: Defines and assigns a custom Jacobian function (`rober_jac!`) for an ODE problem, then constructs the ODEFunction and ODEProblem using this Jacobian. Inputs are mutable Jacobian array J, states u, parameters p, and time t. Requires DifferentialEquations.jl for ODEFunction/ODEProblem and proper Jacobian structure. This enables more efficient, analytical Jacobian handling during integration, improving solver speed and accuracy for stiff problems.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\nfunction rober_jac!(J, u, p, t)\n    yâ, yâ, yâ = u\n    kâ, kâ, kâ = p\n    J[1, 1] = kâ * -1\n    J[2, 1] = kâ\n    J[3, 1] = 0\n    J[1, 2] = yâ * kâ\n    J[2, 2] = yâ * kâ * -2 + yâ * kâ * -1\n    J[3, 2] = yâ * 2 * kâ\n    J[1, 3] = kâ * yâ\n    J[2, 3] = kâ * yâ * -1\n    J[3, 3] = 0\n    nothing\nend\nf! = ODEFunction(rober!, jac = rober_jac!)\nprob_jac = ODEProblem(f!, [1.0, 0.0, 0.0], (0.0, 1e5), (0.04, 3e7, 1e4))\n```\n\n----------------------------------------\n\nTITLE: Performing Global Optimization using Optimization.jl and NLopt in Julia\nDESCRIPTION: Finds the global minimum and maximum of the 4th state variable over the entire time span by solving the previously defined optimization problems (`optprob` for minimum, `optprob2` for maximum) using a global optimization algorithm, `NLopt.GN_ORIG_DIRECT_L`, from the NLopt suite via Optimization.jl. The locations of the global extrema are displayed.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/min_and_max.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\ngopt = solve(optprob, NLopt.GN_ORIG_DIRECT_L())\ngopt2 = solve(optprob2, NLopt.GN_ORIG_DIRECT_L())\n\n@show gopt.u, gopt2.u\n```\n\n----------------------------------------\n\nTITLE: Installing diffeqr Package from CRAN in R - R\nDESCRIPTION: This R snippet demonstrates how to install the diffeqr R package from CRAN, enabling R programs to interface with DifferentialEquations.jl through Julia. Execute this line inside an R session; internet connection required. Output: diffeqr package installed.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/index.md#_snippet_6\n\nLANGUAGE: R\nCODE:\n```\ninstall.packages(\"diffeqr\")\n```\n\n----------------------------------------\n\nTITLE: Solving ODE and Converting Solution to DataFrame in Julia\nDESCRIPTION: Demonstrates solving a 2x2 system of ordinary differential equations (ODEs) using OrdinaryDiffEq.jl's Euler method and converting the resulting solution object (`sol`) into a tabular format using DataFrames.jl. Requires `OrdinaryDiffEq` for solving and `DataFrames` for the conversion.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/io.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nusing OrdinaryDiffEq, DataFrames\nf_2dlinear = (du, u, p, t) -> du .= 1.01u;\ntspan = (0.0, 1.0)\nprob = ODEProblem(f_2dlinear, rand(2, 2), tspan);\nsol = solve(prob, Euler(); dt = 1 // 2^(4));\ndf = DataFrame(sol)\n```\n\n----------------------------------------\n\nTITLE: Installing and Using TaylorIntegration Adaptive Taylor Series Solvers in Julia\nDESCRIPTION: This snippet demonstrates installing TaylorIntegration.jl and importing it for high-accuracy adaptive-tolerance ODE solving in Julia. Requires Julia and the ability to add registered Julia packages. Key input: None; Output: TaylorIntegration module ready for use. For optimal performance, use @taylorize on your derivative functions.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_48\n\nLANGUAGE: julia\nCODE:\n```\nusing Pkg\nPkg.add(\"TaylorIntegration\")\nusing TaylorIntegration\n```\n\n----------------------------------------\n\nTITLE: Setting Up and Solving the Bouncing Ball ODE Problem in Julia\nDESCRIPTION: This snippet sets up the initial conditions (`u0`), time span (`tspan`), and parameters (`p` for gravity) for the bouncing ball simulation. It then defines the `ODEProblem` using the ODE function `f` and the defined parameters. The problem is solved using the `Tsit5()` solver, incorporating the previously defined `VectorContinuousCallback` (`cb`) for collision handling. A fixed time step `dt` is used, disabling adaptive step sizing. Finally, it uses the `Plots` package to visualize the trajectory of the ball (y vs. x).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_52\n\nLANGUAGE: julia\nCODE:\n```\nu0 = [50.0, 0.0, 0.0, 2.0]\ntspan = (0.0, 15.0)\np = 9.8\nprob = ODEProblem(f, u0, tspan, p)\nsol = solve(prob, Tsit5(), callback = cb, dt = 1e-3, adaptive = false)\nusing Plots;\nplot(sol, idxs = (1, 3));\n```\n\n----------------------------------------\n\nTITLE: Updating Cardiac Gating and Calcium Variables Using Rush-Larsen (Julia)\nDESCRIPTION: Provides individual update functions (`update_M_cpu`, `update_H_cpu`, `update_J_cpu`, `update_D_cpu`, `update_F_cpu`, `update_XI_cpu`) for each cardiac gating variable using the Rush-Larsen explicit integration. Each function computes reaction rates (Î±, Î²) as prescribed by the Beeler-Reuter model and applies `rush_larsen`. Also includes an explicit update for intracellular calcium with similar exponential integration logic, using physical parameters and ion concentrations. Dependencies: all require the `rush_larsen` function and relevant coefficients/constants such as Î³, D_Ca, C_s, g_s. Inputs: current value (g), membrane potential (v), and optionally auxiliary variables. Outputs: next-step value for each gating or calcium variable. These functions modularize state updates and handle corner cases, such as avoiding NaN with special conditions.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/beeler_reuter.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nfunction update_M_cpu(g, v, Ît)\n    # the condition is needed here to prevent NaN when v == 47.0\n    Î± = isapprox(v, 47.0f0) ? 10.0f0 : -(v + 47.0f0) / (exp(-0.1f0 * (v + 47.0f0)) - 1.0f0)\n    Î² = (40.0f0 * exp(-0.056f0 * (v + 72.0f0)))\n    return rush_larsen(g, Î±, Î², Ît)\nend\n\nfunction update_H_cpu(g, v, Ît)\n    Î± = 0.126f0 * exp(-0.25f0 * (v + 77.0f0))\n    Î² = 1.7f0 / (exp(-0.082f0 * (v + 22.5f0)) + 1.0f0)\n    return rush_larsen(g, Î±, Î², Ît)\nend\n\nfunction update_J_cpu(g, v, Ît)\n    Î± = (0.55f0 * exp(-0.25f0 * (v + 78.0f0))) / (exp(-0.2f0 * (v + 78.0f0)) + 1.0f0)\n    Î² = 0.3f0 / (exp(-0.1f0 * (v + 32.0f0)) + 1.0f0)\n    return rush_larsen(g, Î±, Î², Ît)\nend\n\nfunction update_D_cpu(g, v, Ît)\n    Î± = Î³ * (0.095f0 * exp(-0.01f0 * (v - 5.0f0))) / (exp(-0.072f0 * (v - 5.0f0)) + 1.0f0)\n    Î² = Î³ * (0.07f0 * exp(-0.017f0 * (v + 44.0f0))) / (exp(0.05f0 * (v + 44.0f0)) + 1.0f0)\n    return rush_larsen(g, Î±, Î², Ît)\nend\n\nfunction update_F_cpu(g, v, Ît)\n    Î± = Î³ * (0.012f0 * exp(-0.008f0 * (v + 28.0f0))) / (exp(0.15f0 * (v + 28.0f0)) + 1.0f0)\n    Î² = Î³ * (0.0065f0 * exp(-0.02f0 * (v + 30.0f0))) / (exp(-0.2f0 * (v + 30.0f0)) + 1.0f0)\n    return rush_larsen(g, Î±, Î², Ît)\nend\n\nfunction update_XI_cpu(g, v, Ît)\n    Î± = (0.0005f0 * exp(0.083f0 * (v + 50.0f0))) / (exp(0.057f0 * (v + 50.0f0)) + 1.0f0)\n    Î² = (0.0013f0 * exp(-0.06f0 * (v + 20.0f0))) / (exp(-0.04f0 * (v + 20.0f0)) + 1.0f0)\n    return rush_larsen(g, Î±, Î², Ît)\nend\n```\n\nLANGUAGE: julia\nCODE:\n```\nfunction update_C_cpu(g, d, f, v, Ît)\n    ECa = D_Ca - 82.3f0 - 13.0278f0 * log(g)\n    kCa = C_s * g_s * d * f\n    iCa = kCa * (v - ECa)\n    inf = 1.0f-7 * (0.07f0 - g)\n    Ï = 1.0f0 / 0.07f0\n    return g + (g - inf) * expm1(-Ît / Ï)\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a DAEProblem with Differential Variables in Julia\nDESCRIPTION: This code sets up a DAEProblem object using a previously defined residual function, state and derivative initializations, and a logical array to distinguish differential from algebraic variables. 'differential_vars' indicates for each variable whether it is differential (true) or algebraic (false), which is crucial for DAE solvers to determine consistent initial conditions. Dependencies are DifferentialEquations.jl and a consistent residual function; the output is a ready-to-solve DAEProblem.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/dae_example.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\ndifferential_vars = [true, true, false]\nprob = DAEProblem(f2, duâ, uâ, tspan, differential_vars = differential_vars)\n```\n\n----------------------------------------\n\nTITLE: Diagnosing Type Instabilities with @code_warntype - Julia\nDESCRIPTION: Utilizes the Julia macro @code_warntype to print type inference information for an ODE right-hand side function, helping to detect type instabilities that can degrade performance. Inputs are as for the usual in-place ODE function (du, u, p, t). Output is printed type analysis; dependencies: Julia REPL and the code_warntype macro.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_23\n\nLANGUAGE: julia\nCODE:\n```\n@code_warntype f(du, u, p, t)\n```\n\n----------------------------------------\n\nTITLE: Native Stiff Solvers for Medium Tolerances in Julia\nDESCRIPTION: `Rodas5P`, `Rodas4P`, `Kvaerno5`, or `KenCarp4` are recommended native Julia solvers for stiff problems at medium tolerances (>1e-8). They support various Julia numeric types. `Rodas5P` is often more efficient, while `Rodas4P` may be more reliable.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\nRodas5P\n```\n\nLANGUAGE: julia\nCODE:\n```\nRodas4P\n```\n\nLANGUAGE: julia\nCODE:\n```\nKvaerno5\n```\n\nLANGUAGE: julia\nCODE:\n```\nKenCarp4\n```\n\n----------------------------------------\n\nTITLE: Solving a Simple Pendulum BVP using the Shooting Method in Julia\nDESCRIPTION: This snippet demonstrates solving the simple pendulum BVP using the Shooting method. It defines boundary conditions `bc3!` that operate on the solution object `sol`, allowing interpolation. An initial guess vector `uâ_2` is provided. A `BVProblem` is constructed and solved using `Shooting` combined with the `Vern7` ODE solver from `OrdinaryDiffEq.jl`. This approach is useful when boundary conditions depend on the solution across the interval.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/bvp_example.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nusing OrdinaryDiffEq\nuâ_2 = [-1.6, -1.7] # the initial guess\nfunction bc3!(residual, sol, p, t)\n    residual[1] = sol(pi / 4)[1] + pi / 2 # use the interpolation here, since indexing will be wrong for adaptive methods\n    residual[2] = sol(pi / 2)[1] - pi / 2\nend\nbvp3 = BVProblem(simplependulum!, bc3!, uâ_2, tspan)\nsol3 = solve(bvp3, Shooting(Vern7()))\n```\n\n----------------------------------------\n\nTITLE: Solving and Plotting SDE Ensemble Phase Space (Julia)\nDESCRIPTION: Constructs an `EnsembleProblem` for the Lotka-Volterra SDE with varying noise parameters, solves it for 10 trajectories using the `SRIW1` solver via DifferentialEquations.jl. It then uses Plots.jl to generate a phase space plot showing trajectories projected onto different planes (time vs u1 in blue, time vs u2 in red).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_23\n\nLANGUAGE: julia\nCODE:\n```\nensemble_prob = EnsembleProblem(prob, prob_func = prob_func)\nsim = solve(ensemble_prob, SRIW1(), trajectories = 10)\nusing Plots;\nplot(sim, linealpha = 0.6, color = :blue, idxs = (0, 1), title = \"Phase Space Plot\");\nplot!(sim, linealpha = 0.6, color = :red, idxs = (0, 2), title = \"Phase Space Plot\")\n```\n\n----------------------------------------\n\nTITLE: Analyzing Energy Conservation for HÃ©non-Heiles (Vern9 Solution) in Julia\nDESCRIPTION: This snippet analyzes the energy conservation of the `Vern9` solver for the HÃ©non-Heiles system simulation. It calculates the total energy `E` at each time step using the previously defined function `E`, computes the total energy drift (`ÎE`) over the simulation, displays this drift, and plots the change in energy relative to the initial energy over time using the `Plots` package.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/classical_physics.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\n#We map the Total energies during the time intervals of the solution (sol.u here) to a new vector\n#pass it to the plotter a bit more conveniently\nenergy = map(x -> E(x...), sol.u)\n\n#We use @show here to easily spot erratic behavior in our system by seeing if the loss in energy was too great.\n@show ÎE = energy[1] - energy[end]\n\n#Plot\nplot(sol.t, energy .- energy[1], title = \"Change in Energy over Time\",\n    xaxis = \"Time in iterations\", yaxis = \"Change in Energy\")\n```\n\n----------------------------------------\n\nTITLE: Solving ODE for Growing Cell Population with Callback in Julia\nDESCRIPTION: Sets up and solves the ODE problem for the growing cell population. It initializes the system with one cell (`u0 = [0.2]`), defines the time span, creates the `ODEProblem`, and uses `solve` with the `ContinuousCallback` defined previously to handle cell divisions.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_46\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\ncallback = ContinuousCallback(condition, affect!)\nu0 = [0.2]\ntspan = (0.0, 10.0)\nprob = ODEProblem(f, u0, tspan)\nsol = solve(prob, callback = callback)\n```\n\n----------------------------------------\n\nTITLE: Stepping Integrator with Custom Time Increment in SciMLBase (Julia)\nDESCRIPTION: Invokes step! on the integrator to move forward by at least a specified increment dt. The third argument dictates whether the step ends exactly at integrator.t+dt (true) or just passes it (false). This pattern requires a valid integrator and customizes precise step advancement.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/integrator.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nstep!(integrator, dt, false)\n```\n\n----------------------------------------\n\nTITLE: Benchmarking In-Place ODE Solution Over Longer Span (Julia, DifferentialEquations.jl)\nDESCRIPTION: Benchmarks the in-place Lorenz system over a longer timespan to demonstrate that setup allocations do not scale with simulation length. Re-creates tspan/prob with 5x previous span; inputs: lorenz!, u0, tspan. Output is only for benchmarking purposes and does not save solution at every step. Dependencies: DifferentialEquations.jl, BenchmarkTools.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\ntspan = (0.0, 500.0) # 5x longer than before\nprob = ODEProblem(lorenz!, u0, tspan)\n@btime solve(prob, Tsit5(), save_everystep = false);\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Plotting Analytic and EM Solution of Scalar SDE in Julia\nDESCRIPTION: This snippet solves the SDE using the Euler-Maruyama (EM) method and overlays the analytic solution for direct visual comparison, utilizing the plot_analytic argument. Requires the SDEProblem with an analytic function, DifferentialEquations.jl, and Plots.jl. The plot shows both the computed and analytic solution.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/sde_example.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, EM(), dt = dt)\nplot(sol, plot_analytic = true)\n```\n\n----------------------------------------\n\nTITLE: Constructing the SDEProblem for the Heston Model with Custom Noise in Julia\nDESCRIPTION: Creates an SDEProblem instance specifying the system (f, g), initial state (ones(2)), time span, and the correlated noise object. Requires drift and diffusion functions, initial conditions, time bounds, and the correlated Wiener process. Inputs: functions f and g, initial state, tspan, and heston_noise. Outputs: a fully-defined SDEProblem for use with Julia's solver infrastructure. Assumes all previous variables and dependencies are in scope.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/sde_example.md#_snippet_17\n\nLANGUAGE: julia\nCODE:\n```\nSDEProblem(f, g, ones(2), tspan, noise = heston_noise)\n```\n\n----------------------------------------\n\nTITLE: Installing and Using GeometricIntegratorsDiffEq.jl for Geometric ODE Methods in Julia\nDESCRIPTION: This code shows the installation and import steps for GeometricIntegratorsDiffEq.jl, a package providing geometric integration algorithms (fixed timestep methods) for ODEs in Julia. The package is added via its GitHub URL using Pkg, and made available through a 'using' statement. These methods require users to specify a timestep dt and are not included by default in the standard DifferentialEquations.jl distribution.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_46\n\nLANGUAGE: julia\nCODE:\n```\nusing Pkg\nPkg.add(url = \"https://github.com/SciML/GeometricIntegratorsDiffEq.jl\")\nusing GeometricIntegratorsDiffEq\n\n```\n\n----------------------------------------\n\nTITLE: Installing and Using ODE.jl Classic ODE Solvers in Julia\nDESCRIPTION: This snippet provides instructions for installing and importing ODE.jl, which contains classic ODE solver algorithms by Shampine and others for Julia. Dependencies include the Pkg standard library and ODE.jl, both of which must be installed manually. The solvers cover a range of Runge-Kutta, BDF, and Adams-Bashforth-Moulton algorithms, and are particularly noted for classic method implementations.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_42\n\nLANGUAGE: julia\nCODE:\n```\nusing Pkg\nPkg.add(\"ODE\")\nusing ODE\n\n```\n\n----------------------------------------\n\nTITLE: Defining Parameterized In-Place Lorenz Function - DifferentialEquations.jl - Julia\nDESCRIPTION: Provides a parameterized version of the Lorenz equation to facilitate parameter estimation and sensitivity analysis. Dependencies are identical to the non-parameterized version. The parameters `p[1]`, `p[2]`, and `p[3]` control the system's coefficients. Inputs: `du` (result array), `u` (state), `p` (parameter vector), `t` (unused here). Accepts any compatible parameter type.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/getting_started.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nfunction parameterized_lorenz!(du, u, p, t)\n    du[1] = p[1] * (u[2] - u[1])\n    du[2] = u[1] * (p[2] - u[3]) - u[2]\n    du[3] = u[1] * u[2] - p[3] * u[3]\nend\n```\n\n----------------------------------------\n\nTITLE: Declaring Current Module Metadata - Julia\nDESCRIPTION: Declares the current module being documented as OrdinaryDiffEqCore using Documenter.jl macro syntax. This helps in generating documentation that refers to the right scope/module for the described symbols. Does not affect runtime, only for documentation processing; requires Documenter.jl as a dependency.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/extras/timestepping.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@meta\nCurrentModule = OrdinaryDiffEqCore\n```\n```\n\n----------------------------------------\n\nTITLE: Attempting to Save Solution Object using Deprecated JLD.jl in Julia (Discouraged)\nDESCRIPTION: Shows an attempt to save a DifferentialEquations.jl solution object using the older, deprecated JLD.jl package. The surrounding text explicitly advises against this method because JLD.jl cannot handle saving Julia types that contain functions, which includes solution objects. Requires the `JLD` package and an existing `sol` object.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/io.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nusing JLD\nJLD.save(\"out.jld\", \"sol\", sol)\n```\n\n----------------------------------------\n\nTITLE: Installing and Using BridgeDiffEq Fixed Timestep Solvers in Julia\nDESCRIPTION: This snippet shows how to add and use BridgeDiffEq.jl from a GitHub URL for fixed timestep ODE algorithms within Julia. Dependencies include Julia's Pkg and BridgeDiffEq. Run this to access methods like BridgeR3 and BridgeBS3 for out-of-place static vector ODE problems. Inputs: None; Output: BridgeDiffEq module loaded.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_47\n\nLANGUAGE: julia\nCODE:\n```\nusing Pkg\nPkg.add(url = \"https://github.com/SciML/BridgeDiffEq.jl\")\nusing BridgeDiffEq\n```\n\n----------------------------------------\n\nTITLE: Defining the Residual Function for an Implicit DAE in Julia\nDESCRIPTION: This code defines an in-place residual function representing the Robertson equation as an implicit DAE for use with DAESolvers in DifferentialEquations.jl. The function computes the residuals for the system, combining time derivatives and algebraic constraints. There are no external dependencies for this function, but contextually it requires the DAEProblem framework. Key parameters are the arrays for current state, derivative, parameters, and time; outputs are written to the 'out' array.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/dae_example.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nfunction f2(out, du, u, p, t)\n    out[1] = -0.04u[1] + 1e4 * u[2] * u[3] - du[1]\n    out[2] = +0.04u[1] - 3e7 * u[2]^2 - 1e4 * u[2] * u[3] - du[2]\n    out[3] = u[1] + u[2] + u[3] - 1.0\nend\n```\n\n----------------------------------------\n\nTITLE: Very High Accuracy Non-Stiff Solver Vern9 in Julia\nDESCRIPTION: `Vern9` is recommended for high accuracy non-stiff solving, especially with `BigFloat` types and tolerances <1e-12. It is Order 9 and provides an Order 9 interpolant.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nVern9\n```\n\n----------------------------------------\n\nTITLE: Non-Stiff Solver OwrenZen5 for Interpolation Accuracy in Julia\nDESCRIPTION: `OwrenZen5` is recommended for non-stiff problems at moderate tolerances when the interpolation error is particularly important.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\nOwrenZen5\n```\n\n----------------------------------------\n\nTITLE: Compute Mean Series at Chosen Time Points - DifferentialEquations.EnsembleAnalysis.jl - Julia\nDESCRIPTION: Defines a vector of time points and computes the mean of the ensemble solution at each specified t using timeseries_point_mean. Supports non-uniform sampling and interpolation between solved points. Output can be directly plotted. Useful for user-specified time grid analyses.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_36\n\nLANGUAGE: julia\nCODE:\n```\nts = 0:0.1:1\nm_series = timeseries_point_mean(sim, ts)\n```\n\n----------------------------------------\n\nTITLE: Configuring TRBDF2 Linear Solver with KLUFactorization (DifferentialEquations.jl, Julia)\nDESCRIPTION: This snippet demonstrates how to configure the TRBDF2 solver in DifferentialEquations.jl to use the KLUFactorization algorithm from KLU.jl for solving linear systems. No additional dependencies are required beyond DifferentialEquations.jl and KLU.jl. The parameter 'linsolve' is set to KLUFactorization() to specify the solver, and this approach can be adapted to any supported LinearSolve.jl algorithm. The input consists of the ordinary differential equation problem and solver options, and the output is a configured solver instance prepared to use the specified linear solver.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/linear_nonlinear.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nTRBDF2(linsolve = KLUFactorization())\n```\n\n----------------------------------------\n\nTITLE: Composing ODE Solver Algorithms via CompositeAlgorithm in Julia\nDESCRIPTION: Illustrates the creation and use of a CompositeAlgorithm to dynamically switch between different ODE solving algorithms (here, Tsit5 and Vern7) based on custom logic for step size (`dt`). This requires DifferentialEquations.jl and an understanding of the integrator interface for writing selection functions. Inputs are tuples of algorithm instances and a choice function; outputs are solver objects capable of adaptive, context-sensitive method selection. Limitations: the choice function must be deterministic and compatible with the integrator API.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_35\n\nLANGUAGE: julia\nCODE:\n```\nchoice_function(integrator) = (Int(integrator.dt < 0.001) + 1)\nalg_switch = CompositeAlgorithm((Tsit5(), Vern7()), choice_function)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Array Views in Julia\nDESCRIPTION: This snippet shows how to create a view of a Julia array using `@view`. It demonstrates that modifying the view (`B`) also modifies the original array (`A`) because views share memory with the original array, unlike slices which create copies.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_24\n\nLANGUAGE: julia\nCODE:\n```\nA = rand(4)\n@show A\nB = @view A[1:3]\nB[2] = 2\n@show A\n```\n\n----------------------------------------\n\nTITLE: Parameter and Callback Setup for Hodgkin-Huxley Model Simulation in Julia\nDESCRIPTION: Defines a PresetTimeCallback to initiate input current and computes steady-state gating values for the Hodgkin-Huxley model. Initializes the parameter vector and state variable vector, and constructs the ODE problem instance 'prob'. Requires prior definition of all rate functions, gating steady-state functions, and the HH! ODE function. Designed for straightforward integration with DifferentialEquations.jl solvers.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\ncurrent_step = PresetTimeCallback(100, integrator -> integrator.p[8] += 1)\n\n# n, m & h steady-states\nn_inf(v) = alpha_n(v) / (alpha_n(v) + beta_n(v))\nm_inf(v) = alpha_m(v) / (alpha_m(v) + beta_m(v))\nh_inf(v) = alpha_h(v) / (alpha_h(v) + beta_h(v))\n\np = [35.0, 40.0, 0.3, -77.0, 55.0, -65.0, 1, 0]\nu0 = [-60, n_inf(-60), m_inf(-60), h_inf(-60)]\ntspan = (0.0, 1000)\n\nprob = ODEProblem(HH!, u0, tspan, p, callback = current_step)\n```\n\n----------------------------------------\n\nTITLE: Compute Timepoint Mean and Variance for Ensemble Results - DifferentialEquations.EnsembleAnalysis.jl - Julia\nDESCRIPTION: Computes the mean and variance at an explicit time point (e.g., t=0.5) across ensemble runs using timepoint_meanvar. Inputs: ensemble simulation object and time value. Requires DifferentialEquations.EnsembleAnalysis. Useful for extracting statistics at arbitrary times, including via interpolation.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_34\n\nLANGUAGE: julia\nCODE:\n```\nm, v = timepoint_meanvar(sim, 0.5)\n```\n\n----------------------------------------\n\nTITLE: Defining Callback Effects (affect!) for Modifying Integrator Parameters in Julia\nDESCRIPTION: Defines two `affect!` functions (`affect!` and `affect2!`) to be used with `DiscreteCallback`s in a control problem. These functions directly modify the parameter `p` stored within the `integrator` object provided by the solver. `affect!` sets `integrator.p` to 1.5, intended to be triggered at `t=5.0`. `affect2!` sets `integrator.p` to -1.5, intended for `t=8.0`. Requires `DifferentialEquations`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\n```@example callback2\nfunction affect!(integrator)\n    integrator.p = 1.5\nend\n\nfunction affect2!(integrator)\n    integrator.p = -1.5\nend\n```\n```\n\n----------------------------------------\n\nTITLE: Solving and Plotting Bouncing Ball ODE (Julia)\nDESCRIPTION: This Julia code sets up the ODE problem for the bouncing ball using the defined ODE function `f`, initial conditions `u0`, time span `tspan`, and gravity parameter `p`. It then solves the problem using the `Tsit5` solver and the created `ContinuousCallback` (`cb`). Finally, it plots the solution using the `Plots` package.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_29\n\nLANGUAGE: julia\nCODE:\n```\nu0 = [50.0, 0.0]\ntspan = (0.0, 15.0)\np = 9.8\nprob = ODEProblem(f, u0, tspan, p)\nsol = solve(prob, Tsit5(), callback = cb)\nusing Plots;\nplot(sol);\n```\n\n----------------------------------------\n\nTITLE: Defining Conditional Dosing Callback in Julia\nDESCRIPTION: Sets up the logic for a conditional dose using a `DiscreteCallback`. The `condition` function checks if the simulation time `t` is exactly 4 AND the drug concentration `u[1]/V` is less than 4. If both are true, the `affect!` function is triggered, modifying the state by adding 10 units to the drug amount `integrator.u[1]`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/conditional_dosing.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\ncondition(u, t, integrator) = t == 4 && u[1] / V < 4\naffect!(integrator) = integrator.u[1] += 10\ncb = DiscreteCallback(condition, affect!)\n```\n\n----------------------------------------\n\nTITLE: Documenting Solver Options Compatibility - Markdown - English\nDESCRIPTION: This Markdown snippet constructs a detailed compatibility table comparing features across multiple ODE solver packages in Julia's ecosystem. It lists solvers in columns and features in rows, with cells using symbolic text markers ('x', 'p', 'n', '0', etc.) to represent each solver's status with respect to each feature. The Markdown also includes explanatory legend text clarifying the meaning of each symbol and footnotes for special cases. The expected input is Markdown parsers and human readers; the output is formatted documentation and quick-reference tables, with some limitations in terms of dynamic content and enforcement of feature status updates.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/compatibility_chart.md#_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n# Solver Compatibility Chart\n\nThis chart is for documenting the compatibility of the component solver packages\nto the common interface. An `x` means that the option is implemented or the\nadd-on functionality will work with the given solver. A blank means that\nthe option has not been implemented, or that a given add-on has not been tested\nwith a given package. If there are any errors in this chart, please file an\nissue or submit a pull-request.\n\n| Option                                 | OrdinaryDiffEq.jl | Sundials.jl | ODE.jl | ODEInterface.jl | LSODA.jl | StochasticDiffEq.jl | DelayDiffEq.jl | DASKR.jl | DASSL.jl |\n|:-------------------------------------- |:----------------- |:----------- |:------ |:--------------- |:-------- |:------------------- |:-------------- |:-------- |:-------- |\n| Nonlinear Dense (continuous) output    | x                 | x           |        |                 |          | x                   | x              | x        |          |\n| Tolerance control                      | x                 | x           | x      | x               | x        | x                   | x              | x        | x        |\n| Advanced stepsize control              | x                 | 0           |        | x               | 0        | x                   | x              | 0        |          |\n| Mass Matrices^                         | x                 | 0           |        | x               | 0        | x                   | x              | 0        |          |\n| Analytical Jacobians^â                  | x                 | x           |        | x               |          | x                   | x              | x        |          |\n| General Performance Overloads^â         | x                 | 0           |        | 0               | 0        | x                   | x              | 0        |          |\n| internalnorm                           | x                 | 0           | x      | 0               | 0        | x                   | x              | 0        |          |\n| Initial dt                             | x                 | x           | x      | x               |          | x                   | x              | x        |          |\n| save_everystep                         | x                 | x           | x      | x               | x        | x                   | x              | x        |          |\n| saveat                                 | x                 | x           | x      | x               | x        | x                   | x              | x        |          |\n| tstops                                 | x                 | x           |        | 0               |          | x                   | x              | x        |          |\n| d_discontinuities                      | x                 |             |        | 0               |          | x                   | x              |          |          |\n| isoutofdomain                          | x                 |             | x      |                 |          | x                   | x              |          |          |\n| Allows reverse time direction          | x                 | x           | x      | x               | x        | x                   | x              |          |          |\n| Unitful numbers                        | x                 | 0           |        | 0               | 0        |                     | x              | 0        |          |\n| Arbitrary dimension arrays             | x                 | x           | x      | x               | x        | x                   | x              | x        | x        |\n| Complex numbers                        | p                 |             |        |                 |          | x                   | p              |          |          |\n| Arbitrary precision                    | x                 | 0           | x      | 0               | 0        | x                   | x              | 0        | x        |\n| ApproxFun types                        | x                 | 0           |        | 0               | 0        |                     | x              | 0        |          |\n| Progress monitoring                    | x                 |             |        |                 |          | x                   | x              |          |          |\n| Integrator interface                   | x                 | x           |        | 0               |          | x                   | x              |          |          |\n| Resizability                           | x                 | 0           |        | 0               | 0        | x                   | x              | 0        |          |\n| Cache iterator                         | x                 | 0           |        | 0               | 0        | x                   | x              | 0        |          |\n| Can choose linear solvers              | x                 | s           |        |                 |          | x                   | x              | s        | x        |\n| Can choose nonlinear solvers           | x                 | 0           |        | 0               | 0        | x                   | x              | 0        | x        |\n| Can use out of place natively          | x                 | 0           | x      | 0               | 0        | x                   | x              | 0        | x        |\n| Can use inplace natively               | x                 | x           |        | x               | x        | x                   | x              | x        |          |\n| Compatible with DiffEqDevTools         | x                 | x           | x      | x               | x        | x                   | x              | x        |          |\n| Compatible with ParameterizedFunctions | x                 | x           | x      | x               | x        | x                   | x              | x        |          |\n| Continuous Callbacks                   | x                 | x           |        | x               |          | x                   | x              |          | x        |\n| Discrete Callbacks                     | x                 | x           |        | x               |          | x                   | x              |          |          |\n| Monte Carlo Simulations                | x                 | x           | x      | x               | x        | x                   | x              | x        |          |\n| Parameter Estimation                   | x                 | n           | n      | n               | n        | x                   | x              | n        | x        |\n| Parameter Sensitivity Analysis         | x                 | x           | x      | x               | x        |                     | x              |          |          |\n| Plotting and solution handling         | x                 | x           | x      | x               | x        | x                   | x              | x        | x        |\n\n  - x: Full compatibility\n  - p: Partial compatibility, only in nonstiff methods, unless the Jacobian is provided.\n  - n: General compatibility, but not compatible with routines which\n    require being able to autodifferentiate through the entire solver.\n  - 0: Not possible. This is generally due to underlying inflexibility in a wrapped\n    library.\n  - s: Special, Sundials has its own linear solver choices.\n  - ^: Only stiff (implicit) methods.\n  - â¡: For packages with compatibility, no warning is given when a specific algorithm\n    does not need to use this feature.\n\nAll blank spaces are possible future additions.\n```\n\n----------------------------------------\n\nTITLE: Solving Simple Pendulum ODE System with OrdinaryDiffEq.jl in Julia\nDESCRIPTION: This Julia code solves the non-linear second-order ODE for a simple pendulum by first converting it into a system of two first-order ODEs using `OrdinaryDiffEq.jl`. It defines physical constants, initial conditions for angle and angular velocity, the ODE system function `simplependulum`, creates an `ODEProblem`, solves it using `Tsit5`, and plots the results with `Plots.jl`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/classical_physics.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n# Simple Pendulum Problem\nusing OrdinaryDiffEq, Plots\n\n#Constants\nconst g = 9.81\nL = 1.0\n\n#Initial Conditions\nuâ = [0, Ï / 2]\ntspan = (0.0, 6.3)\n\n#Define the problem\nfunction simplependulum(du, u, p, t)\n    Î¸ = u[1]\n    dÎ¸ = u[2]\n    du[1] = dÎ¸\n    du[2] = -(g / L) * sin(Î¸)\nend\n\n#Pass to solvers\nprob = ODEProblem(simplependulum, uâ, tspan)\nsol = solve(prob, Tsit5())\n\n#Plot\nplot(sol, linewidth = 2, title = \"Simple Pendulum Problem\", xaxis = \"Time\",\n    yaxis = \"Height\", label = [\"\\\\theta\" \"d\\\\theta\"])\n```\n\n----------------------------------------\n\nTITLE: Defining and Solving a Simple ODE for Exponential Decay in Julia\nDESCRIPTION: Defines an ordinary differential equation (ODE) system `f` representing exponential decay (`du[1] = -u[1]`). It initializes the state `u0`, sets up the `ODEProblem`, solves it using the `Tsit5()` solver from DifferentialEquations.jl, and plots the resulting solution using the `Plots` library. Requires `DifferentialEquations` and `Plots`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\n```@example callback1\nusing DifferentialEquations\nfunction f(du, u, p, t)\n    du[1] = -u[1]\nend\nu0 = [10.0]\nconst V = 1\nprob = ODEProblem(f, u0, (0.0, 10.0))\nsol = solve(prob, Tsit5())\nusing Plots;\nplot(sol);\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Parameters and Instantiating DDEProblem in Julia\nDESCRIPTION: Defines all model parameters, time span, and initial conditions for the DDE, then creates a DDEProblem instance for simulation. Parameters are grouped in a tuple p and provided to the problem setup. Requires DifferentialEquations.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/dde_example.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\np0 = 0.2;\nq0 = 0.3;\nv0 = 1;\nd0 = 5;\np1 = 0.2;\nq1 = 0.3;\nv1 = 1;\nd1 = 1;\nd2 = 1;\nbeta0 = 1;\nbeta1 = 1;\np = (p0, q0, v0, d0, p1, q1, v1, d1, d2, beta0, beta1, tau)\ntspan = (0.0, 10.0)\nu0 = [1.0, 1.0, 1.0]\n\nprob = DDEProblem(bc_model, u0, h, tspan, p; constant_lags = lags)\n```\n\n----------------------------------------\n\nTITLE: Initializing an Integrator with SciMLBase in Julia\nDESCRIPTION: Initializes an integrator object for solving a differential equation using given problem definition and algorithm, with optional keyword arguments forwarding solver options. The returned integrator supports interactive methods for stepping and monitoring. Dependencies include a defined problem (prob) and algorithm (alg) compatible with SciMLBase.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/integrator.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nintegrator = init(prob, alg; kwargs...)\n```\n\n----------------------------------------\n\nTITLE: Non-Stiff Solver RK4 with Defect Control in Julia\nDESCRIPTION: `RK4` is suggested for medium accuracy non-stiff calculations where strict error bounds are needed, utilizing defect control for better error estimation over the interval.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\nRK4\n```\n\n----------------------------------------\n\nTITLE: Problem Assignment by Index for Ensemble Runs - SciML - Julia\nDESCRIPTION: Shows a `prob_func` implementation that sets the initial condition `u0` for each simulation to a specific vector from the `u0_arr` array, enabling heterogenous initialization across ensemble members. The approach is essential for parameter sweeps or prescribed starting values. It requires a pre-defined `u0_arr` and a mutable or broadcast-assignable problem object. Arguments are the problem, index, and repeat count; returns a problem customized for the given ensemble member.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nfunction prob_func(prob, i, repeat)\n    @. prob.u0 = u0_arr[i]\n    prob\nend\n```\n\n----------------------------------------\n\nTITLE: Installing and Using ProbNumDiffEq Probabilistic ODE Solvers in Julia\nDESCRIPTION: This snippet shows how to install and import ProbNumDiffEq.jl for Bayesian inference-based probabilistic ODE solvers. Requires Julia, and optionally scientific computing dependencies for dense output and statistical methods. Inputs: None; Output: ProbNumDiffEq module available for adaptive ODE solving.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_52\n\nLANGUAGE: julia\nCODE:\n```\nusing Pkg\nPkg.add(\"ProbNumDiffEq\")\nusing ProbNumDiffEq\n```\n\n----------------------------------------\n\nTITLE: Constructing LawsonEuler with Krylov Subspace Option - Julia\nDESCRIPTION: This Julia snippet demonstrates how to construct a Lawson-Euler method instance with a Krylov-based matrix exponential computation and a customizable subspace size (m = 50). The constructor's parameters 'krylov' and 'm' control algorithmic behavior for large systems, allowing efficient computation of exp(dt*A) * v. Requires OrdinaryDiffEq.jl and SciMLOperators.jl as dependencies. The expected input is the method options; the output is a solver method suitable for use with DifferentialEquations.jl ODE integrators. The limitation is that this setup presumes familiarity with large sparse systems and Krylov techniques.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/split_ode_solve.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nLawsonEuler(krylov = true, m = 50)\n```\n\n----------------------------------------\n\nTITLE: Defining Dynamics for Growing Cell Population Model in Julia\nDESCRIPTION: Defines the ODE dynamics function `f` for a cell population model. Each cell's protein concentration `u[i]` increases linearly over time with rate `Î±`. The function iterates through the current state vector `u`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_43\n\nLANGUAGE: julia\nCODE:\n```\nconst Î± = 0.3\nfunction f(du, u, p, t)\n    for i in 1:length(u)\n        du[i] = Î± * u[i]\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Simulating Sticky Bouncing Ball with Parameter Change (Julia)\nDESCRIPTION: This Julia code defines dynamics (`dynamics!`) where gravity can be turned off via a parameter `p[1]`. The `floor_aff!` function, triggered by the `condition` (height=0), sets the gravity parameter `p[1]` and velocity `u[2]` to zero upon impact, making the ball stick. It sets up and solves the ODE problem, demonstrating how callbacks can modify parameters and state, and plots the result.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_31\n\nLANGUAGE: julia\nCODE:\n```\nfunction dynamics!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = p[1] * -9.8\nend\nfunction floor_aff!(int)\n    int.p[1] = 0\n    int.u[2] = 0\n    @show int.u[1], int.t\nend\nfloor_event = ContinuousCallback(condition, floor_aff!)\nu0 = [1.0, 0.0]\np = [1.0]\nprob = ODEProblem{true}(dynamics!, u0, (0.0, 1.75), p)\nsol = solve(prob, Tsit5(), callback = floor_event)\nplot(sol)\n```\n\n----------------------------------------\n\nTITLE: Solving Lorenz System with Progress Bar using TerminalLoggers.jl in Julia\nDESCRIPTION: This snippet solves the Lorenz ODE system with terminal-based progress logging using OrdinaryDiffEq and TerminalLoggers.jl. Dependencies include OrdinaryDiffEq for ODE solving and TerminalLoggers for progress bar visualization in the terminal. The code establishes the Lorenz system function, initial state, and time span, and enables the progress bar with progress=true. Inputs are function/system properties and outputs are the numerical solution with real-time terminal progress updates; proper TerminalLoggers setup is required.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/progress_bar.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nusing OrdinaryDiffEq, TerminalLoggers\nfunction lorenz!(du, u, p, t)\n    du[1] = 10.0(u[2] - u[1])\n    du[2] = u[1] * (28.0 - u[3]) - u[2]\n    du[3] = u[1] * u[2] - (8 / 3) * u[3]\nend\nu0 = [1.0; 0.0; 0.0]\ntspan = (0.0, 1000000.0)\nprob = ODEProblem(lorenz!, u0, tspan)\nsol = solve(prob, Tsit5(), progress = true)\n\n```\n\n----------------------------------------\n\nTITLE: Setting up diffeqpy in Python - PyCon\nDESCRIPTION: This interactive Python console session shows importing diffeqpy and running its install method to set up required Julia packages. The install method ensures Julia and the needed Julia packages are accessible to Python. Input: none. Output: diffeqpy and Julia-side dependencies are installed and configured. Requires prior installation of diffeqpy and a working Julia installation in PATH.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/index.md#_snippet_4\n\nLANGUAGE: pycon\nCODE:\n```\n>>> import diffeqpy\\n>>> diffeqpy.install()\n```\n\n----------------------------------------\n\nTITLE: Accessing Termination Time from ODE Solution in Julia\nDESCRIPTION: Retrieves the final time point from the ODE solution object (`sol`). This time represents when the `ContinuousCallback` triggered the termination.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_40\n\nLANGUAGE: julia\nCODE:\n```\nsol.t[end] # 3.1415902502224307\n```\n\n----------------------------------------\n\nTITLE: Importing Ensemble Analysis Tools - SciML - Julia\nDESCRIPTION: Shows how to import the `DifferentialEquations.EnsembleAnalysis` Julia module, making available analysis utilities for ensemble results (such as statistical summaries and plotting). Prerequisite is the DifferentialEquations or SciMLBase package. This line should be executed prior to using specialized summary/stat functions for `EnsembleSimulation` output.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations.EnsembleAnalysis\n```\n\n----------------------------------------\n\nTITLE: Defining the Diffusion Function for a Lotka-Volterra SDE (Julia)\nDESCRIPTION: Defines the stochastic diffusion component (`g`) for a Lotka-Volterra system with multiplicative noise, intended for use in an SDEProblem in DifferentialEquations.jl. The function calculates the magnitude of the noise terms for two state variables `u[1]` and `u[2]` based on parameters `p[3]` and `p[4]`, modifying `du` in-place.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_20\n\nLANGUAGE: julia\nCODE:\n```\nfunction g(du, u, p, t)\n    du[1] = p[3] * u[1]\n    du[2] = p[4] * u[2]\nend\n```\n\n----------------------------------------\n\nTITLE: Handling Accumulation Points in Bouncing Ball Simulation (Julia)\nDESCRIPTION: Improves the bouncing ball simulation to handle accumulation points more accurately. The `affect!` function (`floor_aff!`) now checks the time step `int.dt`. If `int.dt` is large enough, it proposes a smaller `dt` using `set_proposed_dt!` to increase accuracy near the accumulation point. If `int.dt` is below a tolerance (1e-12), it assumes the accumulation point is reached and sets position and velocity to zero, also stopping gravity by setting `p[1]=0`. It increments the bounce count (`p[2]`) and records the time (`p[3]`).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_35\n\nLANGUAGE: julia\nCODE:\n```\nfunction dynamics!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = p[1] * -9.8\nend\nfunction floor_aff!(int)\n    int.u[2] *= -0.5\n    if int.dt > 1e-12\n        set_proposed_dt!(int, (int.t - int.tprev) / 100)\n    else\n        int.u[1] = 0\n        int.u[2] = 0\n        int.p[1] = 0\n    end\n    int.p[2] += 1\n    int.p[3] = int.t\nend\nfloor_event = ContinuousCallback(condition, floor_aff!)\nu0 = [1.0, 0.0]\np = [1.0, 0.0, 0.0]\nprob = ODEProblem{true}(dynamics!, u0, (0.0, 2.0), p)\nsol = solve(prob, Tsit5(), callback = floor_event)\nplot(sol)\n```\n\n----------------------------------------\n\nTITLE: Defining a Semilinear ODE Split - Math\nDESCRIPTION: This LaTeX snippet describes the standard semilinear ODE form used for a SplitODEProblem, where A is a linear operator on u and f(t, u) is a nonlinear term. This structure informs the selection of exponential integrator methods and demonstrates the problem structure handled by specific Julia algorithms. Parameters involve a linear operator (A), the state (u), and the nonlinear function (f). This snippet is strictly mathematical and intended for theoretical exposition.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/split_ode_solve.md#_snippet_1\n\nLANGUAGE: math\nCODE:\n```\n\\frac{du}{dt} =  Au + f(t,u)\n```\n\n----------------------------------------\n\nTITLE: Documenting Example SDE Problems from SDEProblemLibrary in Julia\nDESCRIPTION: This documentation macro block references and exposes multiple predefined SDE problem examples (such as prob_sde_linear, prob_sde_lorenz, prob_sde_bistable, etc.) from SDEProblemLibrary. These documented examples serve as ready-to-use benchmarking or illustrative problems for users. The macro is processed by Documenter.jl; the examples require the DiffEqProblemLibrary package, and users typically work with these problems to test or demonstrate solver capabilities. No direct parameters or return values as this is a documentation facility.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/sde_types.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nprob_sde_linear\nprob_sde_2Dlinear\nprob_sde_wave\nprob_sde_lorenz\nprob_sde_cubic\nprob_sde_additive\nprob_sde_additivesystem\nprob_sde_nltest\noval2ModelExample\nprob_sde_stiffquadstrat\nprob_sde_stiffquadito\ngenerate_stiff_stoch_heat\nprob_sde_bistable\nprob_sde_bruss\nprob_sde_oscilreact\n```\n```\n\n----------------------------------------\n\nTITLE: Initializing N-body Data Structures with Julia\nDESCRIPTION: Defines gravitational constant, planetary masses, labels, positions, velocities, and the time span for simulation in Julia. Requires Julia language, Plots.jl, OrdinaryDiffEq.jl, and ModelingToolkit.jl. Inputs include hardcoded planetary data; outputs are arrays and variables used for downstream simulation. Must run before setting up equations. Adjustments to planetary data or time span may alter solution coverage.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/outer_solar_system.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nusing Plots, OrdinaryDiffEq, ModelingToolkit\ngr()\n\nG = 2.95912208286e-4\nM = [\n    1.00000597682,\n    0.000954786104043,\n    0.000285583733151,\n    0.0000437273164546,\n    0.0000517759138449,\n    1 / 1.3e8\n]\nplanets = [\"Sun\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Pluto\"]\n\npos = [0.0 -3.5023653 9.0755314 8.310142 11.4707666 -15.5387357\n       0.0 -3.8169847 -3.0458353 -16.2901086 -25.7294829 -25.2225594\n       0.0 -1.5507963 -1.6483708 -7.2521278 -10.8169456 -3.1902382]\nvel = [0.0 0.00565429 0.00168318 0.00354178 0.0028893 0.00276725\n       0.0 -0.0041249 0.00483525 0.00137102 0.00114527 -0.00170702\n       0.0 -0.00190589 0.00192462 0.00055029 0.00039677 -0.00136504]\ntspan = (0.0, 200_000.0)\n```\n\n----------------------------------------\n\nTITLE: Non-Diagonal Noise System SDEs with Matrix-Valued Diffusion in Julia\nDESCRIPTION: This example defines and sets up a system SDE problem where the diffusion term g is a matrix, enabling non-diagonal mixing of multiple Wiener processes into multiple variables. It sets matrix entries for different random effects and uses noise_rate_prototype to specify the matrix shape. The problem can then be solved with appropriate solvers. Dependencies: DifferentialEquations.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/sde_example.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\nf(du, u, p, t) = du .= 1.01u\nfunction g(du, u, p, t)\n    du[1, 1] = 0.3u[1]\n    du[1, 2] = 0.6u[1]\n    du[1, 3] = 0.9u[1]\n    du[1, 4] = 0.12u[1]\n    du[2, 1] = 1.2u[2]\n    du[2, 2] = 0.2u[2]\n    du[2, 3] = 0.3u[2]\n    du[2, 4] = 1.8u[2]\nend\nprob = SDEProblem(f, g, ones(2), (0.0, 1.0), noise_rate_prototype = zeros(2, 4))\n```\n\n----------------------------------------\n\nTITLE: Solving a DDEProblem and Plotting Solution with Julia and Plots.jl\nDESCRIPTION: Solves the DDEProblem with the chosen algorithm and visualizes the solution. Uses solve to numerically integrate the DDE and Plots.jl to plot the solution. Requires Plots.jl and DifferentialEquations.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/dde_example.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, alg)\n\nusing Plots\nplot(sol)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Root Finding Behavior (RightRootFind) (Julia)\nDESCRIPTION: This Julia snippet demonstrates the effect of specifying `rootfind = SciMLBase.RightRootFind` in the `ContinuousCallback`. It shows that due to floating-point limitations, the event might be triggered at a time `t` where the condition (`u[1]`) is slightly negative after the event if `RightRootFind` is used, as there might be no floating-point number where the condition is exactly zero.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_32\n\nLANGUAGE: julia\nCODE:\n```\nfloor_event = ContinuousCallback(condition, floor_aff!, rootfind = SciMLBase.RightRootFind)\nu0 = [1.0, 0.0]\np = [1.0]\nprob = ODEProblem{true}(dynamics!, u0, (0.0, 1.75), p)\nsol = solve(prob, Tsit5(), callback = floor_event)\nsol[end] # [-1.2647055847076505e-15, 0.0]\n```\n\n----------------------------------------\n\nTITLE: Optimizing ODE Function with Localized Cache Variables in Julia\nDESCRIPTION: Defines a Julia function `gm4!` which improves upon `gm3!` by localizing the cache variables. Instead of being global, the cache arrays (`Ayu`, `uAx`, `Du`, etc.) are included in the parameter tuple `p`. This helps the compiler with type stability and potentially improves performance. The snippet redefines `p` to include these caches and benchmarks the corresponding `ODEProblem`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_27\n\nLANGUAGE: julia\nCODE:\n```\np = (1.0, 1.0, 1.0, 10.0, 0.001, 100.0, Ayu, uAx, Du, Ayv, vAx, Dv) # a,Î±,ubar,Î²,D1,D2\nfunction gm4!(dr, r, p, t)\n    a, Î±, ubar, Î², D1, D2, Ayu, uAx, Du, Ayv, vAx, Dv = p\n    u = @view r[:, :, 1]\n    v = @view r[:, :, 2]\n    du = @view dr[:, :, 1]\n    dv = @view dr[:, :, 2]\n    mul!(Ayu, Ay, u)\n    mul!(uAx, u, Ax)\n    mul!(Ayv, Ay, v)\n    mul!(vAx, v, Ax)\n    @. Du = D1 * (Ayu + uAx)\n    @. Dv = D2 * (Ayv + vAx)\n    @. du = Du + a * u * u ./ v + ubar - Î± * u\n    @. dv = Dv + a * u * u - Î² * v\nend\nprob = ODEProblem(gm4!, r0, (0.0, 0.1), p)\n@btime solve(prob, Tsit5());\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Plotting Zoomed Views of Bouncing Ball Accumulation Point (Julia)\nDESCRIPTION: Uses the `Plots.jl` package to create multiple plots showing zoomed-in views of the bouncing ball's position (`idxs = 1`) near the accumulation point. This visualizes the Zeno-like behavior where bounces occur increasingly frequently.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_36\n\nLANGUAGE: julia\nCODE:\n```\np1 = plot(sol, idxs = 1, tspan = (1.25, 1.40))\np2 = plot(sol, idxs = 1, tspan = (1.35, 1.36))\np3 = plot(sol, idxs = 1, tspan = (1.354, 1.35526))\np4 = plot(sol, idxs = 1, tspan = (1.35526, 1.35526185))\nplot(p1, p2, p3, p4)\n```\n\n----------------------------------------\n\nTITLE: Constructor for AutoAbstol Discrete Callback (Julia)\nDESCRIPTION: This Julia function `AutoAbstol` serves as a constructor to create a `DiscreteCallback`. It initializes the `AutoAbstolAffect` struct, defines a condition function that always returns `true` (meaning the affect function runs at every step), and bundles them into a `DiscreteCallback`, allowing control over saving behavior.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_21\n\nLANGUAGE: julia\nCODE:\n```\nfunction AutoAbstol(save = true; init_curmax = 1e-6)\n    affect! = AutoAbstolAffect(init_curmax)\n    condition = (u, t, integrator) -> true\n    save_positions = (save, false)\n    DiscreteCallback(condition, affect!, save_positions = save_positions)\nend\n```\n\n----------------------------------------\n\nTITLE: Plotting Cell Count Over Time from Dynamic ODE Solution (Julia)\nDESCRIPTION: Extracts the number of cells (length of the state vector `u`) at each saved time point from the solution object `sol`. It then uses `Plots.jl` to plot the cell count against time.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_47\n\nLANGUAGE: julia\nCODE:\n```\nusing Plots\nplot(sol.t, map((x) -> length(x), sol[:]), lw = 3,\n    ylabel = \"Number of Cells\", xlabel = \"Time\")\n```\n\n----------------------------------------\n\nTITLE: Solving an SDE with a Custom Controller - Julia\nDESCRIPTION: Shows how to invoke the solve function with a custom controller and the Euler-Maruyama algorithm. Inputs are a problem definition (prob), the EM algorithm, timestep dt, and the controller instance. This approach enables use of user-defined step size adaptation strategies in the SDE solver infrastructure.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/extras/timestepping.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nsol = solve(prob, EM(), dt = dt, adaptive = true, controller = CustomController())\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Temperature Distribution in Julia\nDESCRIPTION: Initializes the temperature vector `T` of size `n + 1` with zeros and then sets all elements to `1.0` as an initial guess. It explicitly enforces the Dirichlet boundary condition at the top by setting the last element `T[n + 1]` to the specified `T_top`. Depends on parameters `FT`, `n`, `T_top`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/diffusion_implicit_heat_equation.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nT = zeros(FT, n + 1);\nT .= 1;\nT[n + 1] = T_top; # set top BC\n```\n\n----------------------------------------\n\nTITLE: Disabling Williamson Condition for CarpenterKennedy2N54 in Julia\nDESCRIPTION: This code snippet shows how to instantiate the CarpenterKennedy2N54 low-storage Runge-Kutta algorithm in Julia with the williamson_condition set to false. Doing so lifts the limitation requiring du assignments to be only on the left-hand side, allowing more flexible function definitions at the cost of increased memory usage (3 registers). Dependencies: DifferentialEquations.jl; Key parameter: williamson_condition (boolean). Input: Algorithm options; Output: Algorithm instance configured for relaxed aliasing. Limitation: Higher memory consumption.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_30\n\nLANGUAGE: julia\nCODE:\n```\nalg = CarpenterKennedy2N54(; williamson_condition = false)\n```\n\n----------------------------------------\n\nTITLE: Citing DifferentialEquations.jl in BibTeX - BibTeX\nDESCRIPTION: This BibTeX snippet provides a standard citation format for DifferentialEquations.jl when used in academic settings. It includes metadata such as authors, journal, year, and publisher, which should be referenced in publications that make use of the package. There are no additional dependencies or parameters required; the snippet is to be inserted into a BibTeX file for citation management.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/index.md#_snippet_0\n\nLANGUAGE: bibtex\nCODE:\n```\n@article{rackauckas2017differentialequations,\\n  title={Differential{E}quations.jl--a performant and feature-rich ecosystem for solving differential equations in {J}ulia},\\n  author={Rackauckas, Christopher and Nie, Qing},\\n  journal={Journal of Open Research Software},\\n  volume={5},\\n  number={1},\\n  year={2017},\\n  publisher={Ubiquity Press}\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Affect Function for Bouncing Ball Collision (Julia)\nDESCRIPTION: This Julia function `affect!` defines the action to take when the bouncing ball hits the ground (the condition is met). It reverses the direction of the velocity by negating `integrator.u[2]`, simulating a perfectly elastic bounce.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_27\n\nLANGUAGE: julia\nCODE:\n```\nfunction affect!(integrator)\n    integrator.u[2] = -integrator.u[2]\nend\n```\n\n----------------------------------------\n\nTITLE: Dense Output at Arbitrary Times - SciMLBase - Julia\nDESCRIPTION: Retrieves an interpolated solution value at a specific time t using callable solution objects, which requires dense output to be enabled in the solver. Input is the solution object and desired time(s); output is the interpolated value(s). Relies on SciMLBase's interpolation interface.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/solution.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nsol(t)\n```\n\n----------------------------------------\n\nTITLE: Solving ODE with Symbols and Converting to DataFrame in Julia\nDESCRIPTION: Illustrates solving an ODE where variable names are specified using the `syms` keyword argument in `ODEFunction`. These symbols are then used as column headers when the solution is converted to a DataFrame. Requires `OrdinaryDiffEq` and `DataFrames`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/io.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nf = ODEFunction(f_2dlinear, syms = [:a, :b, :c, :d])\nprob = ODEProblem(f, rand(2, 2), (0.0, 1.0));\nsol = solve(prob, Euler(); dt = 1 // 2^(4));\ndf = DataFrame(sol)\n```\n\n----------------------------------------\n\nTITLE: Defining AMG Preconditioner Setup Function for Sundials in Julia\nDESCRIPTION: This code defines the `psetupamg` function for setting up an Algebraic Multigrid (AMG) preconditioner for Sundials. Similar to the ILU setup, it computes the Jacobian, calculates `W = I - gamma*J`, and then builds the AMG preconditioner using `AlgebraicMultigrid.aspreconditioner` with `ruge_stuben` and Jacobi smoothers. The preconditioner is stored in `preccache2`. It requires `LinearAlgebra`, `AlgebraicMultigrid.jl`, pre-allocated `jaccache` and `W`, and access to `prob_ode_brusselator_2d_mtk`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/advanced_ode_example.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\nprectmp2 = aspreconditioner(ruge_stuben(W,\n    presmoother = AlgebraicMultigrid.Jacobi(rand(size(W,\n        1))),\n    postsmoother = AlgebraicMultigrid.Jacobi(rand(size(W,\n        1)))))\nconst preccache2 = Ref(prectmp2)\nfunction psetupamg(p, t, u, du, jok, jcurPtr, gamma)\n    if jok\n        prob_ode_brusselator_2d_mtk.f.jac(jaccache, u, p, t)\n        jcurPtr[] = true\n\n        # W = I - gamma*J\n        @. W = -gamma * jaccache\n        idxs = diagind(W)\n        @. @view(W[idxs]) = @view(W[idxs]) + 1\n\n        # Build preconditioner on W\n        preccache2[] = aspreconditioner(ruge_stuben(W,\n            presmoother = AlgebraicMultigrid.Jacobi(rand(size(W,\n                1))),\n            postsmoother = AlgebraicMultigrid.Jacobi(rand(size(W,\n                1)))))\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining and Solving System SDEs with Diagonal Noise (Lorenz Example) in Julia\nDESCRIPTION: This example demonstrates how to formulate and solve a system of SDEs (stochastic Lorenz system) with additive diagonal noise, using in-place functions for drift and diffusion, and solve/plot the results. Requires DifferentialEquations.jl and Plots.jl. Parameters specified are state vector, drift and diffusion in-place update functions, time interval. Returns a solution object representing sample paths of the noisy system.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/sde_example.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\nusing Plots\nfunction lorenz!(du, u, p, t)\n    du[1] = 10.0 * (u[2] - u[1])\n    du[2] = u[1] * (28.0 - u[3]) - u[2]\n    du[3] = u[1] * u[2] - (8 / 3) * u[3]\nend\n\nfunction Ï_lorenz!(du, u, p, t)\n    du[1] = 3.0\n    du[2] = 3.0\n    du[3] = 3.0\nend\n\nprob_sde_lorenz = SDEProblem(lorenz!, Ï_lorenz!, [1.0, 0.0, 0.0], (0.0, 10.0))\nsol = solve(prob_sde_lorenz)\nplot(sol, idxs = (1, 2, 3))\n```\n\n----------------------------------------\n\nTITLE: Creating and Plotting EnsembleSummary for SDE Results (Julia)\nDESCRIPTION: Calculates summary statistics (mean and default 5%/95% quantiles) for the SDE ensemble simulation result (`sim`) at time points `0:0.1:10` using `EnsembleSummary` from DifferentialEquations.jl. It then plots the summary statistics using the default ribbon style via the Plots.jl recipe, showing the mean trajectory and the quantile confidence interval.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_24\n\nLANGUAGE: julia\nCODE:\n```\nsumm = EnsembleSummary(sim, 0:0.1:10)\nplot(summ, fillalpha = 0.5)\n```\n\n----------------------------------------\n\nTITLE: Rosenbrock Solvers for Parabolic PDEs (Rodas5/5P) in Julia\nDESCRIPTION: Compares `Rodas5` and `Rodas5P`. Similar to the Rodas4/4P case, `Rodas5P` may be preferred over `Rodas5` for certain problem types like nonlinear parabolic PDEs.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_23\n\nLANGUAGE: julia\nCODE:\n```\nRodas5\n```\n\nLANGUAGE: julia\nCODE:\n```\nRodas5P\n```\n\n----------------------------------------\n\nTITLE: Inplace Interpolated Output - SciMLBase - Julia\nDESCRIPTION: Performs interpolation and writes the result into a pre-allocated output array, reducing allocations for performance. Input is the output array, time(s), and optional interpolation options. Requires dense output and supports large systems where performance benefits from avoiding allocations.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/solution.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nsol(out, t, deriv = Val{0}; idxs = nothing, continuity = :left)\n```\n\n----------------------------------------\n\nTITLE: Solving with Jacobian-Free Newton-Krylov (GMRES) via KrylovJL_GMRES in DifferentialEquations.jl (Julia)\nDESCRIPTION: This snippet benchmarks the use of a Krylov subspace-based linear solver (GMRES via KrylovJL) for stiff ODE integration of the Brusselator-based system, setting linsolve in the solver algorithm to KrylovJL_GMRES. This approach avoids explicit Jacobians by operating in Jacobian-free mode, reducing memory consumption. Requires KrylovJL and BenchmarkTools, as well as previously defined ODE problems.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/advanced_ode_example.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\n@btime solve(prob_ode_brusselator_2d, KenCarp47(linsolve = KrylovJL_GMRES()),\n    save_everystep = false);\nnothing # hide\n\n```\n\n----------------------------------------\n\nTITLE: Specifying Initial Condition for an ODE\nDESCRIPTION: Defines the initial condition `u(0)=1` for the differential equation example `u' = -sqrt(u)`. Initial conditions are essential for obtaining a unique solution to an ODE.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\nu(0)=1\n```\n\n----------------------------------------\n\nTITLE: Initializing and Visualizing Cardiac Domain and Solution with Plots.jl (Julia)\nDESCRIPTION: Shows how to set up the initial membrane potential array (u0) as a 2D region with a central square at activation potential, then visualize this configuration. Later visualizes the solution at the end of integration using heatmaps. Dependencies: Plots.jl. Inputs: domain size (N), active/inactive potential values (v0, v1). Output: 2D heatmap plots of initial and integrated potential distribution. Intended for quick diagnostic visualization of cardiac activation patterns.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/beeler_reuter.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nconst N = 192;\nu0 = fill(v0, (N, N));\nu0[90:102, 90:102] .= v1;   # a small square in the middle of the domain\n```\n\nLANGUAGE: julia\nCODE:\n```\nusing Plots\nheatmap(u0)\n```\n\nLANGUAGE: julia\nCODE:\n```\nheatmap(sol.u[end])\n```\n\n----------------------------------------\n\nTITLE: Determining the Jacobian Sparsity Pattern with ADTypes.jl and SparseConnectivityTracer.jl (Julia)\nDESCRIPTION: This snippet demonstrates how to use SparseConnectivityTracer.jl's TracerSparsityDetector with ADTypes.jl's jacobian_sparsity to automatically infer the sparsity pattern of the Jacobian for a discretized ODE system. It prepares example du and u arguments, obtains the sparse pattern for efficiency, and supports interoperability with other detectors like Symbolics.jl. Dependencies include SparseConnectivityTracer, ADTypes, and a compatible problem and function definition. The key output is a sparse matrix jac_sparsity for use as a jac_prototype.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/advanced_ode_example.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nusing SparseConnectivityTracer, ADTypes\ndetector = TracerSparsityDetector()\ndu0 = copy(u0)\njac_sparsity = ADTypes.jacobian_sparsity(\n    (du, u) -> brusselator_2d_loop(du, u, p, 0.0), du0, u0, detector)\n\n```\n\n----------------------------------------\n\nTITLE: Modifying Parameters to Generate Regularly Spiking Izhikevich Neuron in Julia\nDESCRIPTION: Reassigns the parameter vector and initial conditions to demonstrate spike frequency adaptation in the Izhikevich model. Sets up a new ODE problem with adjusted parameters and visually compares output by solving and plotting the voltage trace. Assumes reuse of previously defined ODE function and callbacks. Demonstrates flexibility of the model in producing a range of spiking dynamics.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\np = [0.02, 0.2, -65, 8, 0]\nu0 = [-65, p[2] * -65]\ntspan = (0.0, 300)\n\nprob = ODEProblem(izh!, u0, tspan, p, callback = cb)\nsol = solve(prob);\nplot(sol, vars = 1)\n```\n\n----------------------------------------\n\nTITLE: Solving ODE with Sundials Using Different Linear Solvers in Julia\nDESCRIPTION: This snippet demonstrates solving the Brusselator ODE problem (`prob_ode_brusselator_2d`) using the Sundials `CVODE_BDF` solver. It benchmarks the default solver, then explicitly specifies `:LapackDense` and `:GMRES` as the `linear_solver` option. Notably, using `:GMRES` with Sundials defaults to a Jacobian-Free Newton Krylov method and doesn't require a user-defined JacVecOperator. Requires `Sundials.jl` and `DifferentialEquations.jl`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/advanced_ode_example.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nusing Sundials\n@btime solve(prob_ode_brusselator_2d, CVODE_BDF(), save_everystep = false);\n# Simplest speedup: use :LapackDense\n@btime solve(prob_ode_brusselator_2d, CVODE_BDF(linear_solver = :LapackDense),\n    save_everystep = false);\n# GMRES Version: Doesn't require any extra stuff!\n@btime solve(prob_ode_brusselator_2d, CVODE_BDF(linear_solver = :GMRES),\n    save_everystep = false);\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Adding Tutorial Footer Metadata in Julia Notebooks\nDESCRIPTION: This snippet adds a tutorial footer in a Julia notebook, usually for documentation or attribution purposes, using the SciMLTutorials package. It calls 'tutorial_footer' with parameters indicating the current folder and file, sourced from WEAVE_ARGS. This requires SciMLTutorials and properly defined WEAVE_ARGS. There is no output except for modifying the notebook/UI content.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/beeler_reuter.md#_snippet_20\n\nLANGUAGE: julia\nCODE:\n```\nusing SciMLTutorials\nSciMLTutorials.tutorial_footer(WEAVE_ARGS[:folder], WEAVE_ARGS[:file])\n```\n\n----------------------------------------\n\nTITLE: Automatic Stiffness-Switching Solvers (AutoSwitch and AutoTsit5) in Julia\nDESCRIPTION: Demonstrates configuration and use of automatic method-switching solvers for stiffness detection (`AutoTsit5`) that switch between non-stiff and stiff solvers as needed. Dependencies include DifferentialEquations.jl, and the example emphasizes automatic parameter-based switching, with customizable tolerances and algorithm choices, such as between `Tsit5` and `Rodas5`. Inputs are instantiated AutoTsit5 algorithms; outputs are solution objects. Key options affect stiffness detection sensitivity and step size adaptation.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_36\n\nLANGUAGE: julia\nCODE:\n```\ntsidas_alg = AutoTsit5(Rodas5())\nsol = solve(prob, tsidas_alg)\n```\n\nLANGUAGE: julia\nCODE:\n```\ntsidas_alg = AutoTsit5(Rodas5(), nonstifftol = 11 / 10)\n```\n\n----------------------------------------\n\nTITLE: Solving RODEs with RandomEM in Julia\nDESCRIPTION: This Julia code snippet demonstrates how to solve a Random Ordinary Differential Equation (RODE) problem (`prob`) using the `RandomEM` method provided by the `StochasticDiffEq.jl` package. It assumes `prob` is a defined RODE problem object and requires specifying the solver (`RandomEM()`) and a fixed time step (`dt`). The result `sol` contains the numerical solution to the RODE.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/rode_solve.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nsol = solve(prob, RandomEM(), dt = 1 / 100)\n```\n```\n\n----------------------------------------\n\nTITLE: Saving DataFrame Solution Data to CSV in Julia\nDESCRIPTION: Shows how to save a DataFrame, previously created from a DifferentialEquations.jl solution object, to a CSV file using the CSV.jl package. Requires an existing DataFrame variable `df` and the `CSV` package.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/io.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nusing CSV\nCSV.write(\"out.csv\", df)\n```\n\n----------------------------------------\n\nTITLE: Documenting SDE Problem and Function Types Using SciMLBase in Julia\nDESCRIPTION: This documentation macro block references and generates documentation for the SDEProblem and SDEFunction types within the SciMLBase package. These types define the abstraction and interface for constructing stochastic differential equation (SDE) problems and their associated functions in SciML workflows. Requires SciMLBase.jl; usage expects users to access the generated documentation via Documenter.jl or similar documentation interfaces. No input parameters hereâthis is a docstring generation pattern.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/sde_types.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nSciMLBase.SDEProblem\nSciMLBase.SDEFunction\n```\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Tsit5 Solver Usage for ODEProblem (DifferentialEquations.jl, Julia)\nDESCRIPTION: This snippet benchmarks the Tsit5 Runge-Kutta ODE solver on a problem instance using Julia's DifferentialEquations.jl framework. The code initializes the ODEProblem with given function, initial state, time span, and parameters, then applies the Tsit5 solver and uses @btime (from BenchmarkTools.jl) for performance timing. Key parameters are the ODE function (fast_gm!), initial value (r0), integration interval, and system parameters (p). The output is a performance evaluation of Tsit5's efficiency on the test problem; no files are saved. Dependencies: DifferentialEquations.jl, BenchmarkTools.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_30\n\nLANGUAGE: julia\nCODE:\n```\nprob = ODEProblem(fast_gm!, r0, (0.0, 10.0), p)\n@btime solve(prob, Tsit5());\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Adaptive Stiff Integrator ImplicitEuler in Julia\nDESCRIPTION: `ImplicitEuler` is an adaptive timestepping extension of the standard Implicit Euler method. It features efficient Jacobian reuse and is fully strong-stability preserving (SSP), making it suitable for hyperbolic PDEs.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_21\n\nLANGUAGE: julia\nCODE:\n```\nImplicitEuler\n```\n\n----------------------------------------\n\nTITLE: Defining prob_func for Random Initial Conditions (Distributed) in Julia\nDESCRIPTION: Defines a Julia function `prob_func` intended for use with `EnsembleProblem` in distributed mode (indicated by `@everywhere`). This function takes a base problem `prob`, an index `i`, and a repeat number `repeat`, and returns a new problem created by modifying the initial condition (`u0`) of the base problem with a random factor. It uses `remake` from DifferentialEquations.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\n@everywhere function prob_func(prob, i, repeat)\n    remake(prob, u0 = rand() * prob.u0)\nend\n```\n\n----------------------------------------\n\nTITLE: Solving and Plotting Slower Drug Decay ODE in Julia\nDESCRIPTION: Solves the modified ODE problem (representing slower decay) using the `Tsit5()` algorithm from DifferentialEquations.jl. It then visualizes the solution using the Plots.jl library, showing the drug amount profile over time for this different decay rate, without any conditional events applied.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/conditional_dosing.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, Tsit5())\nusing Plots;\ngr();\nplot(sol)\n```\n\n----------------------------------------\n\nTITLE: Benchmarking CVODE_BDF with GMRES Linear Solver (Sundials.jl, Julia)\nDESCRIPTION: This example demonstrates benchmarking the Sundials.jl CVODE_BDF implicit ODE solver configured to use a sparse Newton-Krylov (GMRES) linear solver for a stiff ODEProblem. The problem setup remains the same as in the Tsit5 example, but the solver is tailored for stiff, large-bandwidth systems. The code leverages Sundials.jl and BenchmarkTools.jl for competitive runtime profiling, enabling a direct performance comparison to explicit methods. Dependencies: Sundials.jl, BenchmarkTools.jl, DifferentialEquations.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_31\n\nLANGUAGE: julia\nCODE:\n```\nusing Sundials\n@btime solve(prob, CVODE_BDF(linear_solver = :GMRES));\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Benchmarking an In-Place ODE Function Solution With DifferentialEquations.jl (Julia)\nDESCRIPTION: Benchmarks the in-place ODEProblem using BenchmarkTools.jl, showing performance improvements over the out-of-place version. Inputs: previously defined lorenz! function, with u0 and tspan. Demonstrates lower allocation and runtime for non-allocating ODE definitions. Dependencies: DifferentialEquations.jl, BenchmarkTools.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nu0 = [1.0; 0.0; 0.0]\ntspan = (0.0, 100.0)\nprob = ODEProblem(lorenz!, u0, tspan)\n@btime solve(prob, Tsit5());\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Benchmarking In-Place ODE Solution Without Saving Every Step (Julia)\nDESCRIPTION: Benchmarks solving the in-place Lorenz ODE but disables saving at every timestep. Compares performance and allocation for the non-allocating version and demonstrates improved efficiency. Inherits context from previously defined prob variable. Uses BenchmarkTools.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\n@btime solve(prob, Tsit5(), save_everystep = false);\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Plotting Ensemble Summaries with Index Selection - Plots.jl/DifferentialEquations.jl - Julia\nDESCRIPTION: Shows how to visualize ensemble solution summaries using Plots.jl. Allows plotting a single component, multiple components with error bars, or means only. Makes use of :bars and :none for different error visualization styles. Assumes Plots.jl and DifferentialEquations.jl are available and combined with previous EnsembleSummary computation.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_39\n\nLANGUAGE: julia\nCODE:\n```\nusing Plots;\nplot(summ; idxs = 3);\n\nplot(summ; idxs = (3, 5), error_style = :bars)\n\nplot(summ; error_style = :none)\n```\n\n----------------------------------------\n\nTITLE: Benchmarking the Robertson System ODE Solution (Julia, DifferentialEquations.jl)\nDESCRIPTION: Benchmarks the solution of the stiff Robertson system using BenchmarkTools.jl. Shows performance characteristics relevant to highly stiff ODEs in Julia's DifferentialEquations.jl. Dependencies: BenchmarkTools.jl. Inputs: prob object set up as above.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\nusing BenchmarkTools\n@btime solve(prob);\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Improving Termination Accuracy with Solver Tolerances in Julia\nDESCRIPTION: Re-solves the ODE problem using the `Vern8` solver and tighter relative (`reltol`) and absolute (`abstol`) tolerances (1e-12). This demonstrates how solver accuracy impacts the precision of the event time found by the `ContinuousCallback`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_41\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, Vern8(), callback = cb, reltol = 1e-12, abstol = 1e-12)\n#Ï = 3.141592653589703...\nsol.t[end] # 3.1415926535896035\n```\n\n----------------------------------------\n\nTITLE: Referencing ContinuousCallback Documentation in Julia Docs\nDESCRIPTION: Uses the `@docs` macro within Julia's documentation system (Documenter.jl) to automatically insert the documentation for the `ContinuousCallback` type from DifferentialEquations.jl at this location in the generated documentation.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nContinuousCallback\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Up and Solving the Split ODE Problem with IMEXEuler in Julia\nDESCRIPTION: Packages the necessary parameter `n` into a `params` tuple. Defines the time span `tspan` for the simulation. Creates a `SplitODEProblem` using the implicitly treated diffusion operator `D` (wrapped in `SciMLOperators.MatrixOperator`) and the explicit `rhs!` function, with the initial condition `T`. Selects the `IMEXEuler` algorithm and solves the problem using `solve` from `OrdinaryDiffEq`, specifying the time step `dt`, save points using `range`, and enabling progress reporting. Depends on `D`, `rhs!`, `T`, `n`, `FT`, `N_t`, `\\u0394t`, `SciMLOperators`, `OrdinaryDiffEq`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/diffusion_implicit_heat_equation.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nparams = (; n)\n\ntspan = (FT(0), N_t * FT(\\u0394t))\n\nprob = SplitODEProblem(SciMLOperators.MatrixOperator(D),\n    rhs!,\n    T,\n    tspan,\n    params)\nalg = IMEXEuler()\nprintln(\"Solving...\")\nsol = solve(prob,\n    alg,\n    dt = \\u0394t,\n    saveat = range(FT(0), N_t * FT(\\u0394t), length = 5),\n    progress = true,\n    progress_message = (dt, u, p, t) -> t);\n```\n\n----------------------------------------\n\nTITLE: Plotting Protein Concentration of a Single Cell Over Time (Julia)\nDESCRIPTION: Demonstrates how to use the solution object's interpolation capabilities (`sol.(ts)`) even when the system size changes. It plots the protein concentration of the first cell (`x[1]`) over a range of time points `ts`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_48\n\nLANGUAGE: julia\nCODE:\n```\nts = range(0, stop = 10, length = 100)\nplot(ts, map((x) -> x[1], sol.(ts)), lw = 3,\n    ylabel = \"Amount of X in Cell 1\", xlabel = \"Time\")\n```\n\n----------------------------------------\n\nTITLE: Defining Simulation Parameters for 1D Heat Equation in Julia\nDESCRIPTION: Sets up global parameters for the heat equation simulation, including domain boundaries (`a`, `b`), number of cells (`n`), unit vectors (`n\\u0302_min`, `n\\u0302_max`), thermal diffusivity (`\\u03b1`), source term coefficients (`\\u03b2`, `\\u03b3`), time step (`\\u0394t`), number of steps (`N_t`), float type (`FT`), grid spacing (`\\u0394z`, `\\u0394z\\u00b2`), interior Laplacian operator stencil (`\\u2207\\u00b2_op`), boundary conditions (`\\u2207T_bottom`, `T_top`), source term function (`S`), and face coordinates (`zf`).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/diffusion_implicit_heat_equation.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\na, b, n = 0, 1, 10               # zmin, zmax, number of cells\nn\\u0302_min, n\\u0302_max = -1, 1            # Outward facing unit vectors\n\\u03b1 = 100;                        # thermal diffusivity, larger means more stiff\n\\u03b2, \\u03b3 = 10000, \\u03c0;                # source term coefficients\n\\u0394t = 1000;                      # timestep size\nN_t = 10;                       # number of timesteps to take\nFT = Float64;                   # float type\n\\u0394z = FT(b - a) / FT(n)\n\\u0394z\\u00b2 = \\u0394z^2;\n\\u2207\\u00b2_op = [1 / \\u0394z\\u00b2, -2 / \\u0394z\\u00b2, 1 / \\u0394z\\u00b2]; # interior Laplacian operator\n\\u2207T_bottom = 10;                 # Temperature gradient at the top\nT_top = 1;                      # Temperature at the bottom\nS(z) = \\u03b2 * sin(\\u03b3 * z)               # source term, (sin for easy integration)\nzf = range(a, b, length = n + 1);   # coordinates on cell faces\n```\n\n----------------------------------------\n\nTITLE: Simulating Frequency-Dependent Tsodyks-Markram Synapse Dynamics in Julia\nDESCRIPTION: Sets up and runs a Tsodyks-Markram synapse model with widely spaced input events to demonstrate the absence of facilitation at low frequency. Modifies the event callback timing, redefines problem parameters, and plots the resulting synaptic conductance. Requires ODEProblem, preset callback, and plotting libraries.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_21\n\nLANGUAGE: julia\nCODE:\n```\nepsp_ts = PresetTimeCallback(100:1000:5100, epsp!)\n\np = [35.0, 40.0, 0.3, -77.0, 55.0, -65.0, 1, 0, 30, 500, 50, 0.5, 0.005, 0]\nu0 = [-60, n_inf(-60), m_inf(-60), h_inf(-60), 0.0, 1.0, 0.0]\ntspan = (0.0, 5300)\nprob = ODEProblem(HH!, u0, tspan, p, callback = epsp_ts)\nsol = solve(prob);\nplot(sol, vars = 7)\n```\n\n----------------------------------------\n\nTITLE: Plotting Dynamic State Variables of Tsodyks-Markram Synapse in Julia\nDESCRIPTION: Plots both the fifth and sixth variables (usually u and R, underlying synaptic state variables) from the solution of the Tsodyks-Markram ODE system. This enables the visualization of short-term dynamics behind synaptic facilitation or depression. Requires 'sol' from a prior simulation.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_20\n\nLANGUAGE: julia\nCODE:\n```\nplot(sol, vars = [5, 6])\n```\n\n----------------------------------------\n\nTITLE: Plotting ODE Solution with Local Extrema in Julia\nDESCRIPTION: Visualizes the 4th state variable of the ODE solution over time and overlays the identified local minimum and maximum points found using optimization. It uses `Plots.jl` to plot the solution curve and `scatter!` to mark the extrema obtained from `opt` and `opt2` results.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/min_and_max.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nplot(sol, vars = (0, 4), plotdensity = 10000)\nscatter!([opt.u], [opt.minimum], label = \"Local Min\")\nscatter!([opt2.u], [-opt2.minimum], label = \"Local Max\")\n```\n\n----------------------------------------\n\nTITLE: Defining Beeler-Reuter Model Constants in Julia\nDESCRIPTION: Defines various physical and model constants required for the Beeler-Reuter simulation. Note that most constants are defined as `Float32` for potential GPU performance benefits, anticipating later acceleration, while ensuring compatibility with libraries like Sundials which might require `Float64` for certain variables like the transmembrane potential.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/beeler_reuter.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nconst v0 = -84.624\nconst v1 = 10.0\nconst C_K1 = 1.0f0\nconst C_x1 = 1.0f0\nconst C_Na = 1.0f0\nconst C_s = 1.0f0\nconst D_Ca = 0.0f0\nconst D_Na = 0.0f0\nconst g_s = 0.09f0\nconst g_Na = 4.0f0\nconst g_NaC = 0.005f0\nconst ENa = 50.0f0 + D_Na\nconst Î³ = 0.5f0\nconst C_m = 1.0f0\n```\n\n----------------------------------------\n\nTITLE: Benchmarking ODE with Analytical Jacobian - Julia\nDESCRIPTION: Uses the `@btime` benchmarking macro to measure the runtime of solving an ODE problem featuring a user-defined analytical Jacobian (`prob_jac`). Depends on BenchmarkTools.jl and DifferentialEquations.jl. The interface expects a pre-constructed ODEProblem with a Jacobian; the output is the elapsed execution time; `nothing # hide` suppresses result display in rendered docs.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\n@btime solve(prob_jac, Rosenbrock23());\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Modeling Short-Term Depression by Adjusting Tsodyks-Markram Time Constants in Julia\nDESCRIPTION: Sets time constants for the TMS to demonstrate short-term depression instead of facilitation by modifying tau_u and tau_R. Runs ODEProblem with callback for synaptic events and plots the synaptic conductance (variable 7). Shows dynamic diversity in response to parameter changes.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_23\n\nLANGUAGE: julia\nCODE:\n```\nepsp_ts = PresetTimeCallback(100:100:500, epsp!)\n\np = [35.0, 40.0, 0.3, -77.0, 55.0, -65.0, 1, 0, 30, 100, 1000, 0.5, 0.005, 0]\nu0 = [-60, n_inf(-60), m_inf(-60), h_inf(-60), 0.0, 1.0, 0.0]\ntspan = (0.0, 700)\nprob = ODEProblem(HH!, u0, tspan, p, callback = epsp_ts)\nsol = solve(prob);\nplot(sol, vars = 7)\n```\n\n----------------------------------------\n\nTITLE: Optimizing ODE Function with Devectorization and Stencil Computations in Julia\nDESCRIPTION: Defines a highly optimized Julia function `fast_gm!` for the ODE system by devectorizing the stencil computations. It uses explicit nested loops with `@inbounds` for performance, calculating derivatives directly for interior points, boundary edges, and corners, thus avoiding matrix multiplications entirely. The parameters `p` are updated, and the corresponding `ODEProblem` is benchmarked.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_28\n\nLANGUAGE: julia\nCODE:\n```\np = (1.0, 1.0, 1.0, 10.0, 0.001, 100.0, N)\nfunction fast_gm!(du, u, p, t)\n    a, Î±, ubar, Î², D1, D2, N = p\n\n    @inbounds for j in 2:(N - 1), i in 2:(N - 1)\n        du[i, j, 1] = D1 *\n                      (u[i - 1, j, 1] + u[i + 1, j, 1] + u[i, j + 1, 1] + u[i, j - 1, 1] -\n                       4u[i, j, 1]) +\n                      a * u[i, j, 1]^2 / u[i, j, 2] + ubar - Î± * u[i, j, 1]\n    end\n\n    @inbounds for j in 2:(N - 1), i in 2:(N - 1)\n        du[i, j, 2] = D2 *\n                      (u[i - 1, j, 2] + u[i + 1, j, 2] + u[i, j + 1, 2] + u[i, j - 1, 2] -\n                       4u[i, j, 2]) +\n                      a * u[i, j, 1]^2 - Î² * u[i, j, 2]\n    end\n\n    @inbounds for j in 2:(N - 1)\n        i = 1\n        du[1, j, 1] = D1 *\n                      (2u[i + 1, j, 1] + u[i, j + 1, 1] + u[i, j - 1, 1] - 4u[i, j, 1]) +\n                      a * u[i, j, 1]^2 / u[i, j, 2] + ubar - Î± * u[i, j, 1]\n    end\n    @inbounds for j in 2:(N - 1)\n        i = 1\n        du[1, j, 2] = D2 *\n                      (2u[i + 1, j, 2] + u[i, j + 1, 2] + u[i, j - 1, 2] - 4u[i, j, 2]) +\n                      a * u[i, j, 1]^2 - Î² * u[i, j, 2]\n    end\n    @inbounds for j in 2:(N - 1)\n        i = N\n        du[end, j, 1] = D1 *\n                        (2u[i - 1, j, 1] + u[i, j + 1, 1] + u[i, j - 1, 1] - 4u[i, j, 1]) +\n                        a * u[i, j, 1]^2 / u[i, j, 2] + ubar - Î± * u[i, j, 1]\n    end\n    @inbounds for j in 2:(N - 1)\n        i = N\n        du[end, j, 2] = D2 *\n                        (2u[i - 1, j, 2] + u[i, j + 1, 2] + u[i, j - 1, 2] - 4u[i, j, 2]) +\n                        a * u[i, j, 1]^2 - Î² * u[i, j, 2]\n    end\n\n    @inbounds for i in 2:(N - 1)\n        j = 1\n        du[i, 1, 1] = D1 *\n                      (u[i - 1, j, 1] + u[i + 1, j, 1] + 2u[i, j + 1, 1] - 4u[i, j, 1]) +\n                      a * u[i, j, 1]^2 / u[i, j, 2] + ubar - Î± * u[i, j, 1]\n    end\n    @inbounds for i in 2:(N - 1)\n        j = 1\n        du[i, 1, 2] = D2 *\n                      (u[i - 1, j, 2] + u[i + 1, j, 2] + 2u[i, j + 1, 2] - 4u[i, j, 2]) +\n                      a * u[i, j, 1]^2 - Î² * u[i, j, 2]\n    end\n    @inbounds for i in 2:(N - 1)\n        j = N\n        du[i, end, 1] = D1 *\n                        (u[i - 1, j, 1] + u[i + 1, j, 1] + 2u[i, j - 1, 1] - 4u[i, j, 1]) +\n                        a * u[i, j, 1]^2 / u[i, j, 2] + ubar - Î± * u[i, j, 1]\n    end\n    @inbounds for i in 2:(N - 1)\n        j = N\n        du[i, end, 2] = D2 *\n                        (u[i - 1, j, 2] + u[i + 1, j, 2] + 2u[i, j - 1, 2] - 4u[i, j, 2]) +\n                        a * u[i, j, 1]^2 - Î² * u[i, j, 2]\n    end\n\n    @inbounds begin\n        i = 1\n        j = 1\n        du[1, 1, 1] = D1 * (2u[i + 1, j, 1] + 2u[i, j + 1, 1] - 4u[i, j, 1]) +\n                      a * u[i, j, 1]^2 / u[i, j, 2] + ubar - Î± * u[i, j, 1]\n        du[1, 1, 2] = D2 * (2u[i + 1, j, 2] + 2u[i, j + 1, 2] - 4u[i, j, 2]) +\n                      a * u[i, j, 1]^2 - Î² * u[i, j, 2]\n\n        i = 1\n        j = N\n        du[1, N, 1] = D1 * (2u[i + 1, j, 1] + 2u[i, j - 1, 1] - 4u[i, j, 1]) +\n                      a * u[i, j, 1]^2 / u[i, j, 2] + ubar - Î± * u[i, j, 1]\n        du[1, N, 2] = D2 * (2u[i + 1, j, 2] + 2u[i, j - 1, 2] - 4u[i, j, 2]) +\n                      a * u[i, j, 1]^2 - Î² * u[i, j, 2]\n\n        i = N\n        j = 1\n        du[N, 1, 1] = D1 * (2u[i - 1, j, 1] + 2u[i, j + 1, 1] - 4u[i, j, 1]) +\n                      a * u[i, j, 1]^2 / u[i, j, 2] + ubar - Î± * u[i, j, 1]\n        du[N, 1, 2] = D2 * (2u[i - 1, j, 2] + 2u[i, j + 1, 2] - 4u[i, j, 2]) +\n                      a * u[i, j, 1]^2 - Î² * u[i, j, 2]\n\n        i = N\n        j = N\n        du[end, end, 1] = D1 * (2u[i - 1, j, 1] + 2u[i, j - 1, 1] - 4u[i, j, 1]) +\n                          a * u[i, j, 1]^2 / u[i, j, 2] + ubar - Î± * u[i, j, 1]\n        du[end, end, 2] = D2 * (2u[i - 1, j, 2] + 2u[i, j - 1, 2] - 4u[i, j, 2]) +\n                          a * u[i, j, 1]^2 - Î² * u[i, j, 2]\n    end\nend\nprob = ODEProblem(fast_gm!, r0, (0.0, 0.1), p)\n@btime solve(prob, Tsit5());\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Plotting ODE Solutions in Julia using Plots.jl\nDESCRIPTION: These snippets demonstrate how to plot the ODE solution object using the Plots.jl package, leveraging its integration with DifferentialEquations.jl. A basic plot is generated with `plot(sol)`. Plot attributes like `linewidth`, `title`, `xaxis`, `yaxis`, and `label` can be customized. Additional plot elements, like the analytical solution for comparison, can be added using `plot!`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/getting_started.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\n#]add Plots # You need to install Plots.jl before your first time using it!\nusing Plots\n#plotly() # You can optionally choose a plotting backend\nplot(sol)\n```\n\nLANGUAGE: julia\nCODE:\n```\nplot(sol, linewidth = 5, title = \"Solution to the linear ODE with a thick line\",\n    xaxis = \"Time (t)\", yaxis = \"u(t) (in Î¼m)\", label = \"My Thick Line!\") # legend=false\n```\n\nLANGUAGE: julia\nCODE:\n```\nplot!(sol.t, t -> 0.5 * exp(1.01t), lw = 3, ls = :dash, label = \"True Solution!\")\n```\n\n----------------------------------------\n\nTITLE: Using Tsit5 Solver in Julia\nDESCRIPTION: Demonstrates the basic usage pattern for selecting and applying an explicit Runge-Kutta solver (`Tsit5`) to a differential equation problem (`prob`). It initializes the `Tsit5` algorithm and then passes it to the `solve` function along with the problem definition.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_27\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nalg = Tsit5()\nsolve(prob, alg)\n```\n```\n\n----------------------------------------\n\nTITLE: Controlling Plot Density in Plots.jl in Julia\nDESCRIPTION: These code snippets show how to control the density of plotted points for solution objects with dense solution functions. Setting denseplot=false plots only the solver's chosen timepoints, while specifying plotdensity sets the number of evenly spaced points used for dense plotting. Dependencies: Plots.jl, a solution computed with dense=true. Inputs: solution object, keyword arguments. Outputs: plots with customized point selection.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/plot.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nplot(sol, denseplot = false)\n```\n\nLANGUAGE: julia\nCODE:\n```\nplot(sol, plotdensity = 1000)\n```\n\n----------------------------------------\n\nTITLE: Solving an EnsembleProblem with Parallelism and Custom Trajectory Count - SciML - Julia\nDESCRIPTION: Demonstrates calling the `solve` function for an ensemble problem, explicitly choosing multithreading via `EnsembleThreads()` and setting the number of independent trajectories. Additional solver and problem arguments can be passed as needed. Assumes the `ensembleprob` and `alg` objects are prepared appropriately via earlier steps, and the environment supports the required parallel ensemble algorithm. Returns a simulation result holding all solutions.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nsolve(ensembleprob, alg, EnsembleThreads(); trajectories = 1000)\n```\n\n----------------------------------------\n\nTITLE: Passing a Callback to the ODE Solver in Julia\nDESCRIPTION: Shows the syntax for providing a callback object (`cb`) to the `solve` function in DifferentialEquations.jl using the `callback` keyword argument. This integrates the defined event handling logic (which could be a single callback or a `CallbackSet`) into the ODE solving process.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nsol = solve(prob, alg, callback = cb)\n```\n```\n\n----------------------------------------\n\nTITLE: Plotting ODE Solution Variables vs Time in Julia\nDESCRIPTION: Generates a plot showing the time evolution of the 3rd and 4th state variables of the double pendulum ODE solution. It uses the `Plots.jl` library with the `gr()` backend. The `vars` argument specifies which variables to plot against time (index 0), and `plotdensity` increases the resolution.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/min_and_max.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nusing Plots;\ngr();\nplot(sol, vars = [(0, 3), (0, 4)], leg = false, plotdensity = 10000)\n```\n\n----------------------------------------\n\nTITLE: Accessing Timeseries for a Component - SciMLBase - Julia\nDESCRIPTION: Illustrates how to use the colon operator to retrieve the timeseries for the i-th component. Returns all saved values for the given component across time. Relies on Julia's array slicing interface as implemented in the solution object.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/solution.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nsol[i, :]\n```\n\n----------------------------------------\n\nTITLE: Replotting Synaptic State Variable Dynamics with New Event Frequency in Julia\nDESCRIPTION: Plots the fifth and sixth state variables for the solution with low-frequency synaptic events, revealing state trajectories under changed event timing. Requires the most recent 'sol', and visualizes dynamic variables behind facilitation/depression.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_22\n\nLANGUAGE: julia\nCODE:\n```\nplot(sol, vars = [5, 6])\n```\n\n----------------------------------------\n\nTITLE: Importing Required Julia Packages for Heat Equation Solver\nDESCRIPTION: Imports necessary libraries: `Plots` for visualization, `LinearAlgebra` for basic operations, `DiffEqBase` and `OrdinaryDiffEq` for solving differential equations (specifically using `SplitODEProblem` and `IMEXEuler`), and `SciMLBase`/`SciMLOperators` for defining operators.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/diffusion_implicit_heat_equation.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nimport Plots\nusing LinearAlgebra\nusing DiffEqBase\nusing OrdinaryDiffEq: SplitODEProblem, solve, IMEXEuler\nimport SciMLBase, SciMLOperators\n```\n\n----------------------------------------\n\nTITLE: Comprehension with Additional Solution Fields - SciMLBase - Julia\nDESCRIPTION: Shows comprehending over multiple fields (such as time, solution value, and derivative) using 'zip' on 'sol.t', 'sol.u', and 'sol.du'. For each timepoint, computes 't + 3u - du'. This requires the solution to have a 'du' field and demonstrates flexible, parallel iterations over internal data.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/solution.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\n[t + 3u - du for (t, u, du) in zip(sol.t, sol.u, sol.du)]\n```\n\n----------------------------------------\n\nTITLE: Optimizing ODE Function with In-Place Matrix Multiplication in Julia\nDESCRIPTION: Defines a Julia function `gm3!` that further optimizes the ODE calculation by using in-place matrix multiplication (`mul!`) to avoid allocations from intermediate results in the `Du` and `Dv` calculations. It requires pre-allocating cache arrays (`Ayu`, `uAx`, `Du`, etc.) globally, which are used as destinations for `mul!`. The snippet benchmarks the `ODEProblem` using this improved function.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_26\n\nLANGUAGE: julia\nCODE:\n```\nAyu = zeros(N, N)\nuAx = zeros(N, N)\nDu = zeros(N, N)\nAyv = zeros(N, N)\nvAx = zeros(N, N)\nDv = zeros(N, N)\nfunction gm3!(dr, r, p, t)\n    a, Î±, ubar, Î², D1, D2 = p\n    u = @view r[:, :, 1]\n    v = @view r[:, :, 2]\n    du = @view dr[:, :, 1]\n    dv = @view dr[:, :, 2]\n    mul!(Ayu, Ay, u)\n    mul!(uAx, u, Ax)\n    mul!(Ayv, Ay, v)\n    mul!(vAx, v, Ax)\n    @. Du = D1 * (Ayu + uAx)\n    @. Dv = D2 * (Ayv + vAx)\n    @. du = Du + a * u * u ./ v + ubar - Î± * u\n    @. dv = Dv + a * u * u - Î² * v\nend\nprob = ODEProblem(gm3!, r0, (0.0, 0.1), p)\n@btime solve(prob, Tsit5());\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Solving an Implicit DAE Using Sundials IDA Solver in Julia\nDESCRIPTION: This snippet demonstrates solving a DAEProblem (representing an implicit DAE) using the IDA solver from Sundials in Julia. The solution object is obtained by passing the problem and solver to the solve function. Dependency includes the Sundials.jl package. Outputs are a solution object suitable for further analysis or plotting; the input problem must be compatible with IDA and initialized with consistent state and derivatives.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/dae_example.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nusing Sundials\nsol = solve(prob, IDA())\n```\n\n----------------------------------------\n\nTITLE: Defining a Discrete Callback for Fixed-Time Dosing in Julia\nDESCRIPTION: Defines a `DiscreteCallback` in Julia using `DifferentialEquations.jl`. The `condition` function checks if the current time `t` provided by the integrator is exactly 4. The `affect!` function modifies the integrator's state `integrator.u[1]` by adding 10 when the condition is met. This callback represents a single dose administration at a specific time.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\n```@example callback1\ncondition(u, t, integrator) = t == 4\naffect!(integrator) = integrator.u[1] += 10\ncb = DiscreteCallback(condition, affect!)\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Noise Commutativity Condition - LaTeX/Math\nDESCRIPTION: Presents the formal mathematical criterion for commutative noise, which is important for selecting optimally efficient SDE solvers. The condition compares partial derivatives of diffusion coefficients across indices and forms the basis for algorithmic decisions in the library. No dependencies; the input is a set of functions g indexed over noise components and their partial derivatives; the output is a boolean indicating commutativity suitability.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/sde_solve.md#_snippet_0\n\nLANGUAGE: math\nCODE:\n```\n\\sum_{i=1}^d g_{i,j_1}(t,x) \\frac{\\partial g_{k,j_2}(t,x)}{\\partial x_i} = \\sum_{i=1}^d g_{i,j_2}(t,x) \\frac{\\partial g_{k,j_1}(t,x)}{\\partial x_i}\n```\n\n----------------------------------------\n\nTITLE: Defining Plotting Functions for Kepler Problem Analysis in Julia\nDESCRIPTION: Defines helper functions to visualize the results of the Kepler problem simulation. `plot_orbit` plots the trajectory (q coordinates, specifically `sol[3]` vs `sol[4]` corresponding to `q1` and `q2`). `plot_first_integrals` plots the deviation of energy (H) and angular momentum (L) from their initial values over time. `analysis_plot` combines these two plots into a single figure. Requires the `Plots` library and a solution object (`sol`) from `OrdinaryDiffEq`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/kepler_problem.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nplot_orbit(sol) = plot(sol, idxs = (3, 4), lab = \"Orbit\", title = \"Kepler Problem Solution\")\n\nfunction plot_first_integrals(sol, H, L)\n    plot(initial_first_integrals[1] .- map(u -> H(u.x[2], u.x[1]), sol.u),\n        lab = \"Energy variation\", title = \"First Integrals\")\n    plot!(initial_first_integrals[2] .- map(u -> L(u.x[2], u.x[1]), sol.u),\n        lab = \"Angular momentum variation\")\nend\nanalysis_plot(sol, H, L) = plot(plot_orbit(sol), plot_first_integrals(sol, H, L))\n```\n\n----------------------------------------\n\nTITLE: Solving ODE with Custom Linear Solver and Sparse Jacobian Handling - Rodas4/LinearSolve.jl - Julia\nDESCRIPTION: Solves an ODE problem with Rodas4 method, using a custom linear solver with KLUFactorization and disables symbolic factorization reuse to prevent errors due to dynamic sparsity changes. Dependencies: DifferentialEquations.jl, LinearSolve.jl. Useful when Jacobian sparsity structure may change, avoiding errors related to matrix pattern mismatches.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_34\n\nLANGUAGE: julia\nCODE:\n```\nsolve(prob, Rodas4(linsolve = KLUFactorization(; reuse_symbolic = false)))\n```\n\n----------------------------------------\n\nTITLE: Setting Up and Solving PDE Semi-Discretization ODEProblem - Julia\nDESCRIPTION: Demonstrates efficient definition and setup of a right-hand side function for a semi-discretized PDE (reaction-diffusion system). Uses LinearAlgebra, BenchmarkTools, and DifferentialEquations.jl. Constructs tridiagonal matrices for spatial discretization, defines physical parameters, initializes a 3D state array, and creates a corresponding ODEProblem. Inputs: initial data (r0), discretization matrices (Ax, Ay), and parameter tuple (p). Targets scalable PDE simulation and optimization in Julia scientific computing contexts.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_22\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations, LinearAlgebra, BenchmarkTools\n# Generate the constants\np = (1.0, 1.0, 1.0, 10.0, 0.001, 100.0) # a,Î±,ubar,Î²,D1,D2\nN = 100\nAx = Array(Tridiagonal([1.0 for i in 1:(N - 1)], [-2.0 for i in 1:N],\n    [1.0 for i in 1:(N - 1)]))\nAy = copy(Ax)\nAx[2, 1] = 2.0\nAx[end - 1, end] = 2.0\nAy[1, 2] = 2.0\nAy[end, end - 1] = 2.0\n\nfunction basic_version!(dr, r, p, t)\n    a, Î±, ubar, Î², D1, D2 = p\n    u = r[:, :, 1]\n    v = r[:, :, 2]\n    Du = D1 * (Ay * u + u * Ax)\n    Dv = D2 * (Ay * v + v * Ax)\n    dr[:, :, 1] = Du .+ a .* u .* u ./ v .+ ubar .- Î± * u\n    dr[:, :, 2] = Dv .+ a .* u .* u .- Î² * v\nend\n\na, Î±, ubar, Î², D1, D2 = p\nuss = (ubar + Î²) / Î±\nvss = (a / Î²) * uss^2\nr0 = zeros(100, 100, 2)\nr0[:, :, 1] .= uss .+ 0.1 .* rand.()\nr0[:, :, 2] .= vss\n\nprob = ODEProblem(basic_version!, r0, (0.0, 0.1), p)\n```\n\n----------------------------------------\n\nTITLE: Defining Affect for Cell Division and System Resizing in Julia\nDESCRIPTION: Defines the `affect!` function triggered by the cell division condition. It finds the cell with the maximum protein concentration (`maxidx`), increases the size of the integrator's state vector and caches by one using `resize!`, and then sets the protein concentrations of the original cell (`u[maxidx]`) and the new cell (`u[end]`) based on a random split (`Î`).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_45\n\nLANGUAGE: julia\nCODE:\n```\nfunction affect!(integrator)\n    u = integrator.u\n    maxidx = findmax(u)[2]\n    resize!(integrator, length(u) + 1)\n    Î = rand()\n    u[maxidx] = Î\n    u[end] = 1 - Î\n    nothing\nend\n```\n\n----------------------------------------\n\nTITLE: Using Analytical Jacobian in ODEProblem with ModelingToolkit.jl - Julia\nDESCRIPTION: Creates a new ODEProblem using a ModelingToolkit symbolic system with analytical Jacobian computation enabled (`jac = true`). Inputs are the ModelingToolkit ODESystem (`de`), empty initial values, the time span, and `jac = true`. Output is an optimized ODEProblem intended for high efficiency solutions. Requires ModelingToolkit.jl and DifferentialEquations.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_18\n\nLANGUAGE: julia\nCODE:\n```\nprob_jac2 = ODEProblem(de, [], (0.0, 1e5), jac = true)\n```\n\n----------------------------------------\n\nTITLE: Defining Initial ODE Model for Drug Decay in Julia\nDESCRIPTION: Defines an in-place ordinary differential equation `f` representing simple drug decay (`du[1] = -u[1]`), sets an initial condition `u0`, a volume constant `V`, and creates an `ODEProblem` using DifferentialEquations.jl for the time interval (0.0, 10.0). This sets up the basic pharmacokinetic model before introducing events.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/conditional_dosing.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\nfunction f(du, u, p, t)\n    du[1] = -u[1]\nend\nu0 = [10.0]\nconst V = 1\nprob = ODEProblem(f, u0, (0.0, 10.0))\n```\n\n----------------------------------------\n\nTITLE: Querying OpenBLAS Thread Count in Julia\nDESCRIPTION: This snippet demonstrates how to use Julia's ccall interface to query the number of BLAS threads configured by the OpenBLAS library. It has no dependencies beyond the Julia standard library and does not require any input parameters. The output is an integer reflecting the current BLAS thread count. This is useful for performance diagnostics and fine-tuning on multicore systems.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_19\n\nLANGUAGE: julia\nCODE:\n```\nccall((:openblas_get_num_threads64_, Base.libblas_name), Cint, ())\n```\n\n----------------------------------------\n\nTITLE: Solving Kepler Problem with Adaptive RK Solver (Tsit5) in Julia\nDESCRIPTION: Demonstrates solving the `DynamicalODEProblem` using a standard adaptive Runge-Kutta method, `Tsit5`. The `DynamicalODEProblem` interface implicitly handles the conversion of the second-order ODE system to a first-order system suitable for `Tsit5`. It prints the number of steps taken using `@show sol4.u |> length` and calls `analysis_plot` to visualize the orbit and first integral conservation. Requires `OrdinaryDiffEq`, `Plots`, and the problem definition (`prob`, `H`, `L`).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/kepler_problem.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nsol4 = solve(prob, Tsit5())\n@show sol4.u |> length\nanalysis_plot(sol4, H, L)\n```\n\n----------------------------------------\n\nTITLE: Defining the ggprime Index-Based Formula - math\nDESCRIPTION: Provides the analytic derivative formula for the ggprime function required by some SDE solver algorithms. The formula represents component-wise summations and partial derivatives for use in SDE integration, assuming differentiable noise terms. Inputs are g_{i,j}(t,x) and the equation must be implemented in compatible solvers (e.g., PCEuler). Outputs are higher-order derivative values for advanced SDE solvers. Knowledge of calculus and matrix differentiation is required.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/sde_solve.md#_snippet_3\n\nLANGUAGE: math\nCODE:\n```\n\\text{ggprime}^k(t,x) = \\sum_{j=1}^m \\sum_{i=1}^d g_{i,j}(t,x) \\frac{\\partial g_{k,j}(t,x)}{\\partial x_i}.\n```\n\n----------------------------------------\n\nTITLE: Setting Current Module for Documenter.jl\nDESCRIPTION: This is a meta directive for Julia's Documenter.jl system. It sets the context module to `ODEProblemLibrary`, ensuring that subsequent `@docs` directives resolve symbols relative to this module.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/ode_types.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\n```@meta\nCurrentModule = ODEProblemLibrary\n```\n```\n\n----------------------------------------\n\nTITLE: Solving Slower Decay ODE with Unmet Conditional Callback in Julia\nDESCRIPTION: Solves the modified ODE problem (slower decay) using `Tsit5()`, applying the *same* conditional dosing callback `cb` and `tstops=[4.0]` as in the first scenario. Because the drug concentration remains above the threshold (u[1]/V >= 4) at t=4 due to the slower decay, the condition is not met, the `affect!` function is not triggered, and no dose is added. The plot shows a smooth decay curve without the jump seen previously.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/conditional_dosing.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, Tsit5(), tstops = [4.0], callback = cb)\nusing Plots;\ngr();\nplot(sol)\n```\n\n----------------------------------------\n\nTITLE: Applying Manifold Projection for Angular Momentum Only in Julia\nDESCRIPTION: Shows the effect of projecting the solution onto the angular momentum conservation manifold only. Defines the `angular_manifold` function, which calculates the residual only for the angular momentum (L) and sets the residual components for energy (H) to zero. Creates a `ManifoldProjection` callback (`angular_cb`). Solves the first-order ODE problem (`prob2`) with `RK4` (fixed step) using this callback and plots the results (`analysis_plot2`), illustrating good angular momentum conservation but drift in energy. Requires previous definitions and libraries.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/kepler_problem.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nfunction angular_manifold(residual, u, p, t)\n    residual[1:2] .= initial_first_integrals[2] - L(u[1:2], u[3:4])\n    residual[3:4] .= 0\nend\nangular_cb = ManifoldProjection(angular_manifold, autodiff = AutoForwardDiff())\nsol7 = solve(prob2, RK4(), dt = 1 // 5, adaptive = false, callback = angular_cb)\nanalysis_plot2(sol7, H, L)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Solution Array with Heatmap in Julia\nDESCRIPTION: This snippet displays the final solution array 'sol.u[end]' as a heatmap, allowing visualization of the computed 2D field after integration. Uses a plotting library such as Plots.jl or Makie.jl that supports the 'heatmap' function. Input is the last entry of the solution vector from DifferentialEquations.jl. Output is a 2D heatmap plot. The code assumes a compatible plotting backend is loaded.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/beeler_reuter.md#_snippet_19\n\nLANGUAGE: julia\nCODE:\n```\nheatmap(sol.u[end])\n```\n\n----------------------------------------\n\nTITLE: Defining ODE Problem for Termination Example in Julia\nDESCRIPTION: Sets up an ODE problem representing simple harmonic motion (cosine and -sine solutions). `u[1]` is position, `u[2]` is velocity. Uses `DifferentialEquations.jl` to define the dynamics function `fun2`, initial conditions `u0`, and time span `tspan`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_37\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\nu0 = [1.0, 0.0]\nfunction fun2(du, u, p, t)\n    du[2] = -u[1]\n    du[1] = u[2]\nend\ntspan = (0.0, 10.0)\nprob = ODEProblem(fun2, u0, tspan)\n```\n\n----------------------------------------\n\nTITLE: Performing Local Maximization using Optimization.jl and NLopt in Julia\nDESCRIPTION: Sets up and solves a local maximization problem by minimizing the negative of the objective function (`fminus`). It seeks a local maximum of the 4th state variable around `t=22`. Similar to the minimization, it uses `Optimization.jl`, `ForwardDiff`, and `NLopt.LD_LBFGS` within the defined time bounds.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/min_and_max.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nfminus(t, _) = -sol(first(t), idxs = 4)\n\noptf = OptimizationFunction(fminus, Optimization.AutoForwardDiff())\nmin_guess = 22.0\noptprob2 = OptimizationProblem(optf, [min_guess], lb = [0.0], ub = [100.0])\nopt2 = solve(optprob2, NLopt.LD_LBFGS())\n```\n\n----------------------------------------\n\nTITLE: Defining Callback Conditions for Parameter Switching at Specific Times in Julia\nDESCRIPTION: Defines two separate `condition` functions (`condition` and `condition2`) for use in `DiscreteCallback`s within a control problem. `condition` checks if the simulation time `t` is exactly 5.0 (by checking membership in `tstop1 = [5.0]`). `condition2` checks if `t` is exactly 8.0 (using `tstop2 = [8.0]`). These conditions trigger parameter changes at specific points in time. Requires `DifferentialEquations`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\n```@example callback2\nconst tstop1 = [5.0]\nconst tstop2 = [8.0]\n\nfunction condition(u, t, integrator)\n    t in tstop1\nend\n\nfunction condition2(u, t, integrator)\n    t in tstop2\nend\n```\n```\n\n----------------------------------------\n\nTITLE: Defining the ggprime Vector Matrix Formula - math\nDESCRIPTION: This alternate expression for ggprime expresses the calculation of the noise Jacobian interaction as vector/matrix operations, useful for implementing derivative-based SDE solvers. It presumes that the user has vector-valued functions for noise channels and can compute Jacobians. The formula facilities the implementation of SDE methods that require analytic derivatives of the noise term (e.g., in PCEuler). Proper vectorization and matrix calculus support are prerequisites.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/sde_solve.md#_snippet_4\n\nLANGUAGE: math\nCODE:\n```\n\\text{ggprime}(t,x) = \\sum_{j=1}^m \\bar{\\mathcal{J}}[\\vec g^{(j)}(t,x)] \\vec g^{(j)}(t,x).\n```\n\n----------------------------------------\n\nTITLE: Benchmarking StaticArray ODE Solver - Julia\nDESCRIPTION: Benchmarks the static array-based ODE solver to demonstrate significant reductions in execution time and memory allocations. Uses BenchmarkTools.jl `@btime` with a StaticArrays.jl-based ODEProblem and Rosenbrock23. Inputs: ODEProblem with static arrays; output: solve time; `nothing # hide` prevents test output in documentation. Dependencies: DifferentialEquations.jl, StaticArrays.jl, BenchmarkTools.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_21\n\nLANGUAGE: julia\nCODE:\n```\n@btime sol = solve(prob, Rosenbrock23());\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation Link for Sundials DAE Solver in Julia\nDESCRIPTION: This snippet uses the `@docs` macro, likely from Documenter.jl, to create a documentation link for the `IDA` solver provided by Sundials.jl. `IDA` is a specific algorithm designed for solving Differential Algebraic Equation (DAE) problems, made available in Julia through the Sundials.jl wrapper package.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/api/sundials.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nIDA\n```\n```\n\n----------------------------------------\n\nTITLE: Solving ODE with Sundials using GMRES and Custom AMG Preconditioner in Julia\nDESCRIPTION: This code solves the sparse Brusselator ODE using Sundials `CVODE_BDF` with `:GMRES` as the linear solver. It utilizes the custom Algebraic Multigrid (AMG) preconditioner defined by the `precamg` (action) and `psetupamg` (setup) functions. `prec_side = 1` specifies it as a left preconditioner. Requires `Sundials.jl`, `DifferentialEquations.jl`, and the previously defined `precamg` and `psetupamg` functions.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/advanced_ode_example.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\n@btime solve(prob_ode_brusselator_2d_sparse,\n    CVODE_BDF(linear_solver = :GMRES, prec = precamg, psetup = psetupamg,\n        prec_side = 1), save_everystep = false);\n```\n\n----------------------------------------\n\nTITLE: Importing Only OrdinaryDiffEq.jl for ODE Solving in Julia\nDESCRIPTION: Shows how to import only the `OrdinaryDiffEq.jl` package as a lighter alternative to `DifferentialEquations.jl` when only ODE solvers are needed. This reduces the dependency size and potentially compile time. It requires the `OrdinaryDiffEq` package to be added to the project environment first.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/low_dep.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n#Add the OrdinaryDiffEq Package first!\n#using Pkg; Pkg.add(\"OrdinaryDiffEq\")\nusing OrdinaryDiffEq\n```\n\n----------------------------------------\n\nTITLE: Defining EnsembleProblem with Custom Functions - SciML - Julia\nDESCRIPTION: Defines the `EnsembleProblem` constructor with customizable functions for output preparation, problem modification, data reduction, and initialization. These extension points allow users to control how input problems are altered and how result data is processed and stored during ensemble simulations. All parameters (such as output_func, prob_func, reduction, u_init, and safetycopy) are explained; users can swap in custom logic as needed. The snippet assumes that types like `DEProblem` are available from SciML packages. Inputs are a problem object and optional keyword functions; output is an ensemble-ready problem for parallel solving.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nEnsembleProblem(prob::DEProblem;\n    output_func = (sol, i) -> (sol, false),\n    prob_func = (prob, i, repeat) -> (prob),\n    reduction = (u, data, I) -> (append!(u, data), false),\n    u_init = [], safetycopy = prob_func !== DEFAULT_PROB_FUNC)\n```\n\n----------------------------------------\n\nTITLE: Ensemble Simulations of SDEs with EnsembleProblem and Parallelization in Julia\nDESCRIPTION: These snippets illustrate the creation of an ensemble SDE problem and running large numbers of independent trajectories in parallel using the EnsembleProblem construct and EnsembleThreads ensemble algorithm. Parameters include the original SDEProblem, number of trajectories, and solver configuration. Parallel execution depends on Julia's parallelism/multithreading. The returned solution ensemble is used for statistical analysis.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/sde_example.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nensembleprob = EnsembleProblem(prob)\n```\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(ensembleprob, EnsembleThreads(), trajectories = 1000)\n```\n\n----------------------------------------\n\nTITLE: Loading Full Solution Object using JLD2.jl in Julia\nDESCRIPTION: Shows how to load a previously saved DifferentialEquations.jl solution object from a JLD2 file. It emphasizes the need to bring the required packages (like `OrdinaryDiffEq`) into the scope of the new session before loading to ensure the full functionality (e.g., interpolation, plotting) of the solution object is restored. Requires `JLD2` and the relevant solver/SciML packages.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/io.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\n# New session\nusing JLD2\nusing OrdinaryDiffEq\nJLD2.@load \"out.jld2\" sol\n```\n\n----------------------------------------\n\nTITLE: Declaring an In-Place ODE Function with Jacobian - DifferentialEquations.jl - Julia\nDESCRIPTION: This snippet illustrates creation of an in-place ODEFunction object, including an explicit Jacobian. ODEFunction{true} declares the function as mutating, and the jac keyword allows providing a custom Jacobian for advanced solver routines or performance enhancements. To use this snippet, DifferentialEquations.jl must be available. Required parameters include an in-place right-hand side function `f` and the `jac` Jacobian function (`myjac`). This approach enables customized low-level integration with solvers that benefit from knowing whether the function mutates its arguments.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/problem.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nODEFunction{true}(f, jac = myjac)\n```\n\n----------------------------------------\n\nTITLE: Plotting DAE Solutions with Logarithmic X-Axis in Julia\nDESCRIPTION: This code plots the solution of a DAE using Plots.jl, formatting the time (x-axis) logarithmically to capture the solution across orders of magnitude. Layout is specified to stack outputs for each variable, improving clarity especially on multi-scale systems. Dependency is Plots.jl and an existing solution object; no modification of the solution occurs, only visualization. The layout and axis scaling are customized for the problem's stiff dynamics.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/dae_example.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nplot(sol, xscale = :log10, tspan = (1e-6, 1e5), layout = (3, 1))\n```\n\n----------------------------------------\n\nTITLE: Saving Full Solution Object using JLD2.jl in Julia\nDESCRIPTION: Demonstrates how to serialize and save the entire DifferentialEquations.jl solution object (`sol`), including its interpolation functions and other metadata, to a file using the JLD2.jl package's `@save` macro. Requires `OrdinaryDiffEq` (to generate `sol`) and `JLD2`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/io.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, Euler(); dt = 1 // 2^(4))\nusing JLD2\n@save \"out.jld2\" sol\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for SciMLBase RODESolution (Julia)\nDESCRIPTION: This Documenter.jl `@docs` block is used to include the documentation for the `SciMLBase.RODESolution` type. This type encapsulates the results obtained after numerically solving an RODE problem defined using SciMLBase.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/rode_types.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nSciMLBase.RODESolution\n```\n```\n\n----------------------------------------\n\nTITLE: Defining AMG Preconditioner Action Function for Sundials in Julia\nDESCRIPTION: This snippet defines the `precamg` function, specifying the action of the Algebraic Multigrid (AMG) preconditioner for Sundials. It applies the inverse of the AMG preconditioner (stored in `preccache2`) to the residual vector `r` using `ldiv!` to compute the preconditioned vector `z`. This function is used with `psetupamg`. Requires `LinearAlgebra` and access to `preccache2`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/advanced_ode_example.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\nfunction precamg(z, r, p, t, y, fy, gamma, delta, lr)\n    ldiv!(z, preccache2[], r)\nend\n```\n\n----------------------------------------\n\nTITLE: Solving ODE with Sundials using GMRES and Custom ILU Preconditioner in Julia\nDESCRIPTION: This code demonstrates solving the sparse Brusselator ODE problem using the Sundials `CVODE_BDF` solver with the `:GMRES` linear solver. It specifies the custom ILU preconditioner defined by the `precilu` (action) and `psetupilu` (setup) functions. `prec_side = 1` indicates that it's a left preconditioner. Requires `Sundials.jl`, `DifferentialEquations.jl`, and the previously defined `precilu` and `psetupilu` functions.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/advanced_ode_example.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\n@btime solve(prob_ode_brusselator_2d_sparse,\n    CVODE_BDF(linear_solver = :GMRES, prec = precilu, psetup = psetupilu,\n        prec_side = 1), save_everystep = false);\n```\n\n----------------------------------------\n\nTITLE: Full Manifest Dependency Listing with Pkg.status and PKGMODE_MANIFEST (Julia)\nDESCRIPTION: Produces a comprehensive manifest of all dependencies (including indirect dependencies) in the Julia environment using Pkg.status with the 'mode = PKGMODE_MANIFEST' keyword argument. This snippet needs the Pkg module and outputs an exhaustive versioned list. It is best used when a complete reproduction of the development environment is needed.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/index.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nusing Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide\n```\n\n----------------------------------------\n\nTITLE: Installing and Using QuDiffEq Quantum ODE Solvers in Julia\nDESCRIPTION: This snippet covers installing QuDiffEq.jl directly from GitHub and importing it to leverage quantum algorithm-based ODE solvers in Julia. It depends on Julia's Pkg and QuDiffEq, with optional Yao.jl for quantum simulation. Inputs: None; Output: QuDiffEq loaded for quantum ODE algorithms.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_49\n\nLANGUAGE: julia\nCODE:\n```\nusing Pkg\nPkg.add(url = \"https://github.com/QuantumBFS/QuDiffEq.jl\")\nusing QuDiffEq\n```\n\n----------------------------------------\n\nTITLE: Directly Solving a Second-Order BVP System in Julia\nDESCRIPTION: This snippet shows how to directly solve a system of second-order ODEs formulated as a BVP, avoiding manual conversion to a first-order system. It defines the second-derivative function `f!` and the boundary condition function `bc!` which accesses both the solution `u` and its derivative `du` at specified times. A `SecondOrderBVProblem` is constructed and solved using `MIRKN4`, specifying automatic differentiation (`AutoForwardDiff`) via `BVPJacobianAlgorithm` for Jacobian computation.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/bvp_example.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nfunction f!(ddu, du, u, p, t)\n    Ïµ = 0.1\n    ddu[1] = u[2]\n    ddu[2] = (-u[1] * du[2] - u[3] * du[3]) / Ïµ\n    ddu[3] = (du[1] * u[3] - u[1] * du[3]) / Ïµ\nend\nfunction bc!(res, du, u, p, t)\n    res[1] = u(0.0)[1]\n    res[2] = u(1.0)[1]\n    res[3] = u(0.0)[3] + 1\n    res[4] = u(1.0)[3] - 1\n    res[5] = du(0.0)[1]\n    res[6] = du(1.0)[1]\nend\nu0 = [1.0, 1.0, 1.0]\ntspan = (0.0, 1.0)\nprob = SecondOrderBVProblem(f!, bc!, u0, tspan)\nsol = solve(prob, MIRKN4(; jac_alg = BVPJacobianAlgorithm(AutoForwardDiff())), dt = 0.01)\n```\n\n----------------------------------------\n\nTITLE: Benchmarking an Out-of-Place ODE Function Using DifferentialEquations.jl (Julia)\nDESCRIPTION: Benchmarks the solve step for the out-of-place Lorenz function using DifferentialEquations.jl and BenchmarkTools.jl. Dependencies: DifferentialEquations, BenchmarkTools. Demonstrates allocation and timing details for the naive out-of-place ODE form.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations, BenchmarkTools\nu0 = [1.0; 0.0; 0.0]\ntspan = (0.0, 100.0)\nprob = ODEProblem(lorenz, u0, tspan)\n@btime solve(prob, Tsit5());\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Saving Full Solution Object using BSON.jl in Julia\nDESCRIPTION: Illustrates saving the complete DifferentialEquations.jl solution object (`sol`) to a file using the BSON.jl package. The solution is typically stored within a dictionary. Requires `OrdinaryDiffEq` (to generate `sol`) and `BSON`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/io.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, Euler(); dt = 1 // 2^(4))\nusing BSON\nbson(\"test.bson\", Dict(:sol => sol))\n```\n\n----------------------------------------\n\nTITLE: Iterated Stochastic Integral in SDE Schemes - LaTeX/Math\nDESCRIPTION: Shows the definition of a two-dimensional stochastic iterated integral, relevant to higher strong order SDE solvers. The integral describes secondary interactions between two Wiener processes over a timestep and its correct approximation is crucial for advanced algorithmsâ accuracy. This is a theoretical definition requiring understanding of stochastic calculus, no explicit computational dependencies.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/sde_solve.md#_snippet_1\n\nLANGUAGE: math\nCODE:\n```\nI(h) = \\int_0^h\\int_0^s dW^1_t dW^2_s\n```\n\n----------------------------------------\n\nTITLE: Gustafsson Acceleration Controller Algorithm - Julia\nDESCRIPTION: Introduces acceleration in timestep changes for stiff solvers using the Gustafsson controller. Uses current error, Newton iteration count, and algorithmic order to compute an accelerated scaling factor, which is further adjusted for safety and historical acceptance. Inputs include algorithm parameters, iteration counters, and error estimates; outputs new q for timestep scaling. The snippet expects structures for integrator, algorithm, and options.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/extras/timestepping.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\n```julia\ngamma = integrator.opts.gamma\nniters = integrator.cache.newton_iters\nfac = min(gamma,\n    (1 + 2 * integrator.alg.max_newton_iter) * gamma /\n    (niters + 2 * integrator.alg.max_newton_iter))\nexpo = 1 / (alg_order(integrator.alg) + 1)\nqtmp = (integrator.EEst^expo) / fac\n@fastmath q = max(inv(integrator.opts.qmax), min(inv(integrator.opts.qmin), qtmp))\nif q <= integrator.opts.qsteady_max && q >= integrator.opts.qsteady_min\n    q = one(q)\nend\nintegrator.qold = q\nq\n```\n```\n\n----------------------------------------\n\nTITLE: Listing Solvers Available via Sundials.jl Wrapper\nDESCRIPTION: Enumerates specific solver interfaces like `CVODE_Adams`, `CVODE_BDF`, `IDA`, and `ARKODE` provided by the Sundials C++ library, accessible in Julia via the `Sundials.jl` wrapper package. These are often robust choices for stiff and differential-algebraic equations.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nCVODE_Adams, CVODE_BDF, IDA, ARKODE\n```\n\n----------------------------------------\n\nTITLE: Calculating Cardiac Currents and Updating Transmembrane Potential Derivative (Julia)\nDESCRIPTION: Contains helper functions for calculating individual cardiac currents (`calc_iK1`, `calc_ix1`, `calc_iNa`, `calc_iCa`) per the Beeler-Reuter model and the coupled updater `update_du_cpu`. Each current is computed using inputs such as the membrane potential (v) and relevant gating variables. `update_du_cpu` computes total ionic current per cell and updates the du (derivative) array accordingly. Requires physical constants like C_Na, g_Na, ENa, g_NaC, and C_m, and expects input variables as arrays. Outputs: updated du matrix for use by ODE solvers. Handles complex ionic interactions and their translation into discrete updates for a reaction-diffusion PDE system.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/beeler_reuter.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\n# iK1 is the inward-rectifying potassium current\nfunction calc_iK1(v)\n    ea = exp(0.04f0 * (v + 85.0f0))\n    eb = exp(0.08f0 * (v + 53.0f0))\n    ec = exp(0.04f0 * (v + 53.0f0))\n    ed = exp(-0.04f0 * (v + 23.0f0))\n    return 0.35f0 * (4.0f0 * (ea - 1.0f0) / (eb + ec)\n            +\n            0.2f0 * (isapprox(v, -23.0f0) ? 25.0f0 : (v + 23.0f0) / (1.0f0 - ed)))\nend\n\n# ix1 is the time-independent background potassium current\nfunction calc_ix1(v, xi)\n    ea = exp(0.04f0 * (v + 77.0f0))\n    eb = exp(0.04f0 * (v + 35.0f0))\n    return xi * 0.8f0 * (ea - 1.0f0) / eb\nend\n\n# iNa is the sodium current (similar to the classic Hodgkin-Huxley model)\nfunction calc_iNa(v, m, h, j)\n    return C_Na * (g_Na * m^3 * h * j + g_NaC) * (v - ENa)\nend\n\n# iCa is the calcium current\nfunction calc_iCa(v, d, f, c)\n    ECa = D_Ca - 82.3f0 - 13.0278f0 * log(c)    # ECa is the calcium reversal potential\n    return C_s * g_s * d * f * (v - ECa)\nend\n\nfunction update_du_cpu(du, u, XI, M, H, J, D, F, C)\n    n1, n2 = size(u)\n\n    for j in 1:n2\n        for i in 1:n1\n            v = Float32(u[i, j])\n\n            # calculating individual currents\n            iK1 = calc_iK1(v)\n            ix1 = calc_ix1(v, XI[i, j])\n            iNa = calc_iNa(v, M[i, j], H[i, j], J[i, j])\n            iCa = calc_iCa(v, D[i, j], F[i, j], C[i, j])\n\n            # total current\n            I_sum = iK1 + ix1 + iNa + iCa\n\n            # the reaction part of the reaction-diffusion equation\n            du[i, j] = -I_sum / C_m\n        end\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Spike Detection and Reset Callbacks for LIF Model in Julia\nDESCRIPTION: Sets up callback mechanisms for the LIF model simulation. `thr` defines the spike condition (voltage `u` exceeding threshold `Vth`). `reset!` defines the action upon spiking (resetting `u` to `EL`). `threshold` combines these into a `ContinuousCallback`. `current_step` uses a `PresetTimeCallback` to increase input current `I` at specified times (t=2 and t=15). Finally, `cb` groups these callbacks into a `CallbackSet` for the ODE solver. Depends on the `DifferentialEquations` package.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nfunction thr(u, t, integrator)\n    u - integrator.p.Vth\nend\n\nfunction reset!(integrator)\n    integrator.u = integrator.p.EL\nend\n\nthreshold = ContinuousCallback(thr, reset!, nothing)\ncurrent_step = PresetTimeCallback([2, 15], integrator -> integrator.p.I += 150.0)\ncb = CallbackSet(current_step, threshold)\n```\n\n----------------------------------------\n\nTITLE: Referencing SciMLBase ODE Solution Documentation\nDESCRIPTION: This snippet uses the Documenter.jl `@docs` directive to embed the documentation for the `ODESolution` type from the SciMLBase package.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/ode_types.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nSciMLBase.ODESolution\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing State-Independent Time-Varying ODE Operator with MagnusGL6 in Julia\nDESCRIPTION: This Julia example configures a time-dependent linear operator via an update function and solves the ODE using the MagnusGL6 algorithm from DifferentialEquations.jl. It relies on SciMLOperators for defining a mutable matrix operator whose values are updated at each time step. The key parameter is the update_func, which alters A using trigonometric functions of time. The code illustrates problem creation, solver selection, and solution with a fixed time step (dt).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/nonautonomous_linear_ode.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nfunction update_func(A, u, p, t)\n    A[1, 1] = cos(t)\n    A[2, 1] = sin(t)\n    A[1, 2] = -sin(t)\n    A[2, 2] = cos(t)\nend\nA = SciMLOperators.MatrixOperator(ones(2, 2), update_func = update_func)\nprob = ODEProblem(A, ones(2), (1.0, 6.0))\nsol = solve(prob, MagnusGL6(), dt = 1 / 10)\n```\n\n----------------------------------------\n\nTITLE: Listing Example ODE Solvers in Julia SciML\nDESCRIPTION: Provides a list of different ODE solver algorithms available within the Julia SciML ecosystem, such as `Tsit5()`, `Vern7()`, `QNDF()`, `Rodas5()`, `TRBDF2()`, `KenCarp4()`, and `Sundials.CVODE_BDF()`. Trying different solvers is recommended when encountering stability or performance issues.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nTsit5(), Vern7(), QNDF(), Rodas5(), TRBDF2(), KenCarp4(), Sundials.CVODE_BDF()\n```\n\n----------------------------------------\n\nTITLE: Defining Izhikevich Spiking Neuron Model with DifferentialEquations.jl in Julia\nDESCRIPTION: Implements the two-dimensional Izhikevich model ODE function suitable for DifferentialEquations.jl. The function `izh!` calculates membrane potential and recovery variable derivatives for a given state, adhering to Julia's in-place function convention (using the `!`). Relies on correct parameter (`a, b, c, d, I`) ordering, requires installation of DifferentialEquations.jl, and input vectors sized appropriately for the system. Intended for use with ODEProblem setup in DifferentialEquations.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\n#Izhikevichch Model\nusing DifferentialEquations\nusing Plots\n\nfunction izh!(du, u, p, t)\n    a, b, c, d, I = p\n\n    du[1] = 0.04 * u[1]^2 + 5 * u[1] + 140 - u[2] + I\n    du[2] = a * (b * u[1] - u[2])\nend\n```\n\n----------------------------------------\n\nTITLE: Benchmarking ODE Solution Without Saving Every Step (Julia, DifferentialEquations.jl)\nDESCRIPTION: Repeats benchmarking the solve using BenchmarkTools.jl, but disables saving every timestep. Measures effect on memory allocations and runtime, showing the persistent allocation due to out-of-place function. Uses previously defined prob object. Dependency: BenchmarkTools.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n@btime solve(prob, Tsit5(), save_everystep = false);\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Computing Ensemble Summary Statistics by Time Point - SciML - Julia\nDESCRIPTION: Provides a suite of functions for calculating mean, median, quantile, variance, covariance, and correlation at a specific (interpolated) simulation time across the ensemble. These routines support interpolated time points and weighted statistics. Users provide the simulation results and required indices/quantiles; output is summary statistics per component. Requires solutions with interpolation and aligned time grids.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\ntimepoint_mean(sim, t) # Computes the mean of each component at time t\ntimepoint_median(sim, t) # Computes the median of each component at time t\ntimepoint_quantile(sim, q, t) # Computes the quantile q of each component at time t\ntimepoint_meanvar(sim, t) # Computes the mean and variance of each component at time t\ntimepoint_meancov(sim, t1, t2) # Computes the mean at t1 and t2, the covariance, for each component\ntimepoint_meancor(sim, t1, t2) # Computes the mean at t1 and t2, the correlation, for each component\ntimepoint_weighted_meancov(sim, W, t1, t2) # Computes the mean at t1 and t2, the weighted covariance W, for each component\n```\n\n----------------------------------------\n\nTITLE: Solving a System of RODEs with In-Place Function in Julia\nDESCRIPTION: Demonstrates solving a system of two RODEs using an efficient in-place function `f(du, u, p, t, W)`, where `du` is updated directly. It sets up an `RODEProblem` with a vector initial condition `u0 = [1.00; 1.00]` and solves it using `RandomEM` with `dt=1/100`. The default noise process `W` has the same dimension as `u0`. Requires `DifferentialEquations.jl` and `Plots.jl`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/rode_example.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\nusing Plots\nfunction f(du, u, p, t, W)\n    du[1] = 2u[1] * sin(W[1] - W[2])\n    du[2] = -2u[2] * cos(W[1] + W[2])\nend\nu0 = [1.00; 1.00]\ntspan = (0.0, 5.0)\nprob = RODEProblem(f, u0, tspan)\nsol = solve(prob, RandomEM(), dt = 1 / 100)\nplot(sol)\n```\n\n----------------------------------------\n\nTITLE: Combining Units-Aware Arrays for Multi-Variable Initial Conditions - Julia\nDESCRIPTION: This example initializes arrays for position and velocity with units (using Unitful.jl) and bundles them into an ArrayPartition for use as an initial condition in a dynamics equation. Required dependencies are Unitful.jl (for units), RecursiveArrayTools.jl (for ArrayPartition), DifferentialEquations.jl, and LinearAlgebra. It expects vectors with physical units and outputs a partitioned initial condition for ODE problems. The snippet demonstrates integrating diverse numerical arrays and preparing them for simulation.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/diffeq_arrays.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nusing Unitful, RecursiveArrayTools, DifferentialEquations\nusing LinearAlgebra\n\nr0 = [1131.340, -2282.343, 6672.423]u\"km\"\nv0 = [-5.64305, 4.30333, 2.42879]u\"km/s\"\nÎt = 86400.0 * 365u\"s\"\nÎ¼ = 398600.4418u\"km^3/s^2\"\nrv0 = ArrayPartition(r0, v0)\n```\n\n----------------------------------------\n\nTITLE: Generating Download Links for Project and Manifest Files Using TOML Parsing (Julia)\nDESCRIPTION: Reads and parses Project.toml to extract project version and name, then constructs download links for the project's manifest and project files from the SciML GitHub pages structure. Relies on TOML and Markdown Julia modules. The code is meant to be run at build/eval time to generate reproducibility download links for documentation. Users must have access to Project.toml in the parent directory for the code to function.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/index.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\nusing TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")\n```\n\n----------------------------------------\n\nTITLE: Creating and Combining Multiple Discrete Callbacks using CallbackSet in Julia\nDESCRIPTION: Demonstrates the creation of two `DiscreteCallback` instances (`cb` and `cb2`) using previously defined `condition`/`affect!` pairs. It specifies `save_positions` for each callback to control data saving around the event times (`save_positions = (true, true)` saves before and after, `(false, true)` saves only after). Finally, it combines these individual callbacks into a single `CallbackSet` (`cbs`) which can be passed collectively to the ODE solver. Requires `DifferentialEquations`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\n```@example callback2\nusing DifferentialEquations\nsave_positions = (true, true)\n\ncb = DiscreteCallback(condition, affect!, save_positions = save_positions)\n\nsave_positions = (false, true)\n\ncb2 = DiscreteCallback(condition2, affect2!, save_positions = save_positions)\n\ncbs = CallbackSet(cb, cb2)\n```\n```\n\n----------------------------------------\n\nTITLE: Solving Boundary Value Problems with `solve` in Julia\nDESCRIPTION: Defines the `solve` function signatures for various Boundary Value Problem types (`BVProblem`, `TwoPointBVProblem`, `SecondOrderBVProblem`, `SecondOrderTwoPointBVProblem`) in Julia. It takes the problem definition `prob`, a solver algorithm `alg`, an initial step size `dt` (required for most methods except Shooting and MultipleShooting), and optional keyword arguments `kwargs`. This function initiates the numerical solution process for the specified BVP using the chosen algorithm.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/bvp_solve.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nsolve(prob::BVProblem, alg, dt; kwargs)\nsolve(prob::TwoPointBVProblem, alg, dt; kwargs)\nsolve(prob::SecondOrderBVProblem, alg, dt; kwargs)\nsolve(prob::SecondOrderTwoPointBVProblem, alg, dt; kwargs)\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Up and Solving Kepler as First-Order ODE (RK4) in Julia\nDESCRIPTION: Reformulates the Kepler problem as a standard first-order `ODEProblem`. Defines new plotting functions (`plot_orbit2`, `plot_first_integrals2`, `analysis_plot2`) compatible with the `[q; p]` state vector format (indices 1,2 for position, 3,4 for momentum). Defines the `hamiltonian` derivative function for the first-order system using views for efficiency. Solves the problem (`prob2`) using the non-adaptive `RK4` method with a fixed step size (`dt=1/5`) and plots the results to show the baseline drift in first integrals without projection. Requires `OrdinaryDiffEq`, `DiffEqCallbacks`, and `Plots`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/kepler_problem.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\nusing DiffEqCallbacks\n\nfunction plot_orbit2(sol)\n    plot(sol, vars = (1, 2), lab = \"Orbit\", title = \"Kepler Problem Solution\")\nend\n\nfunction plot_first_integrals2(sol, H, L)\n    plot(initial_first_integrals[1] .- map(u -> H(u[1:2], u[3:4]), sol.u),\n        lab = \"Energy variation\", title = \"First Integrals\")\n    plot!(initial_first_integrals[2] .- map(u -> L(u[1:2], u[3:4]), sol.u),\n        lab = \"Angular momentum variation\")\nend\n\nanalysis_plot2(sol, H, L) = plot(plot_orbit2(sol), plot_first_integrals2(sol, H, L))\n\nfunction hamiltonian(du, u, params, t)\n    q, p = u[1:2], u[3:4]\n    qdot(@view(du[1:2]), p, q, params, t)\n    pdot(@view(du[3:4]), p, q, params, t)\nend\n\nprob2 = ODEProblem(hamiltonian, [initial_position; initial_velocity], tspan)\nsol_ = solve(prob2, RK4(), dt = 1 // 5, adaptive = false)\nanalysis_plot2(sol_, H, L)\n```\n\n----------------------------------------\n\nTITLE: Defining and Solving an SDDE (Hayes Model) in Julia\nDESCRIPTION: This Julia code snippet demonstrates how to define the drift (`hayes_modelf`) and diffusion (`hayes_modelg`) functions for a Stochastic Delay Differential Equation (SDDE), along with a history function `h`. It then sets up the parameters (`pmul`, `padd`), defines an `SDDEProblem` for the Hayes model with a constant lag, and solves it using the `RKMil()` algorithm from DifferentialEquations.jl. This example illustrates the typical workflow for setting up and solving SDDEs.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/sdde_solve.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nfunction hayes_modelf(du, u, h, p, t)\n    Ï, a, b, c, Î±, Î², Î³ = p\n    du .= a .* u .+ b .* h(p, t - Ï) .+ c\nend\nfunction hayes_modelg(du, u, h, p, t)\n    Ï, a, b, c, Î±, Î², Î³ = p\n    du .= Î± .* u .+ Î³\nend\nh(p, t) = (ones(1) .+ t);\ntspan = (0.0, 10.0)\n\npmul = [1.0, -4.0, -2.0, 10.0, -1.3, -1.2, 1.1]\npadd = [1.0, -4.0, -2.0, 10.0, -0.0, -0.0, 0.1]\n\nprob = SDDEProblem(hayes_modelf, hayes_modelg, [1.0], h, tspan, pmul;\n    constant_lags = (pmul[1],));\nsol = solve(prob, RKMil())\n```\n\n----------------------------------------\n\nTITLE: Setting the Maximum Iterations for ODE Solvers in Julia\nDESCRIPTION: Illustrates the `maxiters` keyword argument used in the `solve` function to set the maximum number of internal steps the ODE solver is allowed to take. Increasing this value from the default might be necessary for long time spans, but frequent triggering often indicates stiffness.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\nmaxiters=...\n```\n\n----------------------------------------\n\nTITLE: Benchmarking ODE Solve with Symbolic Jacobian - Julia\nDESCRIPTION: Benchmarks solving an ODE problem constructed from a ModelingToolkit symbolic system, benefiting from automatic Jacobian calculation. The snippet uses BenchmarkTools.jl's `@btime` macro to assess performance. Inputs: the symbolic ODEProblem (`prob_jac2`); output: elapsed time; the result is hidden with `nothing # hide`. Dependencies: DifferentialEquations.jl, ModelingToolkit.jl, BenchmarkTools.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_19\n\nLANGUAGE: julia\nCODE:\n```\n@btime solve(prob_jac2);\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Installing diffeqpy Python Module with pip - Bash\nDESCRIPTION: This shell command installs the diffeqpy Python module via pip, allowing Python users to access DifferentialEquations.jl functionality. The command downloads and installs diffeqpy and its dependencies from PyPI. Requires an active Python environment and internet connection. Output: diffeqpy installed and ready to use.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/index.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npip install diffeqpy\n```\n\n----------------------------------------\n\nTITLE: Loading and Solving a Sample DDE Problem in Julia\nDESCRIPTION: This Julia code demonstrates how to use a pre-defined DDE problem from the `DiffEqProblemLibrary.jl`. It first ensures the library is added, then imports necessary modules (`DDEProblemLibrary`, `DelayDiffEq`), loads a specific problem (`prob_dde_constant_1delay_ip`), and finally solves it using the `MethodOfSteps` algorithm with the `Tsit5` integrator.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/dde_types.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n#] add DiffEqProblemLibrary\nusing DiffEqProblemLibrary.ODEProblemLibrary, DelayDiffEq\n# load problems\nprob = DDEProblemLibrary.prob_dde_constant_1delay_ip\nsol = solve(prob, MethodOfSteps(Tsit5()))\n```\n\n----------------------------------------\n\nTITLE: Solving and Plotting Basic Drug Decay ODE in Julia\nDESCRIPTION: Solves the previously defined ODE problem (`prob`) using the `Tsit5()` algorithm from DifferentialEquations.jl. It then uses the Plots.jl library (with the GR backend initialized via `gr()`) to visualize the resulting drug amount `u[1]` over time, showing the baseline decay without any conditional dosing.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/conditional_dosing.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, Tsit5())\nusing Plots;\ngr();\nplot(sol)\n```\n\n----------------------------------------\n\nTITLE: Customizing Problem Initialization for Ensemble Runs - SciML - Julia\nDESCRIPTION: Provides an example function for modifying the initial condition (`u0`) of each ensemble trajectory with a normally distributed random multiplier. This enables Monte Carlo initialization when building parallel simulation ensembles. It assumes the base problem type allows field mutation or broadcasting. Required: Julia's random functions (randn), and ensemble routines accepting `prob_func`. Input parameters are the base problem, the trajectory index, and repeat count; function returns the mutated problem instance.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nfunction prob_func(prob, i, repeat)\n    @. prob.u0 = randn() * prob.u0\n    prob\nend\n```\n\n----------------------------------------\n\nTITLE: Solving ODEs with Matrix States - DifferentialEquations.jl - Julia\nDESCRIPTION: Demonstrates use of matrices as ODE system states by initializing a random 4x2 matrix and defining a linear ODE using matrix multiplication. Dependencies: DifferentialEquations, Plots. `A` is the system matrix, `u0` the matrix initial condition, `f` computes the derivative. Shows packaging into `ODEProblem` and outlines standard steps for solution and plotting.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/getting_started.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\nusing Plots\nA = [1.0 0 0 -5\n     4 -2 4 -3\n     -4 0 0 1\n     5 -2 2 3]\nu0 = rand(4, 2)\ntspan = (0.0, 1.0)\nf(u, p, t) = A * u\nprob = ODEProblem(f, u0, tspan)\n```\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob)\nplot(sol)\n```\n\n----------------------------------------\n\nTITLE: Initializing Terminal Progress Logger for ODE Solving in Julia\nDESCRIPTION: This snippet demonstrates the explicit initialization of a terminal logger (TerminalLogger) before solving an ODE problem using DifferentialEquations.jl. It imports OrdinaryDiffEq, configures the global logger from Logging and TerminalLoggers, and defines the Lorenz system and its initial conditions. The solution is computed with progress and maxiters control parameters. Inputs include the ODE function, initial state, and system parameters, with output as the numerical solution and visible terminal progress updates. It is crucial to set global_logger(TerminalLogger()) before any computational steps to ensure logging output appears.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/progress_bar.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nusing OrdinaryDiffEq\nusing Logging: global_logger\nusing TerminalLoggers: TerminalLogger\nglobal_logger(TerminalLogger())\n\nfunction lorenz!(du, u, p, t)\n    du[1] = 10.0(u[2] - u[1])\n    du[2] = u[1] * (28.0 - u[3]) - u[2]\n    du[3] = u[1] * u[2] - (8 / 3) * u[3]\nend\nu0 = [1.0; 0.0; 0.0]\ntspan = (0.0, 1000000.0)\nprob = ODEProblem(lorenz!, u0, tspan)\nsol = solve(prob, Tsit5(), progress = true, maxiters = 1e8)\n\n```\n\n----------------------------------------\n\nTITLE: Constructing an ArrayPartition with RecursiveArrayTools - Julia\nDESCRIPTION: This snippet demonstrates how to construct an ArrayPartition using the RecursiveArrayTools.jl package in Julia. Dependencies include RecursiveArrayTools.jl, and the function expects multiple AbstractArrays as input. The resulting ArrayPartition object acts like a single array while internally storing each input array, supporting efficient and type-stable broadcast operations. The typical input is a sequence of arrays, and the output is a single partitioned array structure usable in DiffEq solvers.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/diffeq_arrays.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nusing RecursiveArrayTools\nA = ArrayPartition(x::AbstractArray...)\n```\n\n----------------------------------------\n\nTITLE: In-Place DDE Model with Cached History and Constants in Julia\nDESCRIPTION: Defines a DDE function leveraging a constant output cache, modifying du in-place using the cached delayed state from the history function. Inputs and outputs are in-place, with required constants v0, beta0, and others in scope. Demonstrates in-place and memory-efficient DDE coding style.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/dde_example.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nconst out = zeros(3) # Define a cache variable\nfunction bc_model(du, u, h, p, t)\n    h(out, p, t - tau) # updates out to be the correct history function\n    du[1] = (v0 / (1 + beta0 * (out[3]^2))) * (p0 - q0) * u[1] - d0 * u[1]\n    du[2] = (v0 / (1 + beta0 * (out[3]^2))) * (1 - p0 + q0) * u[1] +\n            (v1 / (1 + beta1 * (out[3]^2))) * (p1 - q1) * u[2] - d1 * u[2]\n    du[3] = (v1 / (1 + beta1 * (out[3]^2))) * (1 - p1 + q1) * u[2] - d2 * u[3]\nend\n```\n\n----------------------------------------\n\nTITLE: Including Documentation for SciMLBase.SteadyStateAliasSpecifier in Julia\nDESCRIPTION: This Julia `@docs` directive incorporates the documentation for `SciMLBase.SteadyStateAliasSpecifier`. This component likely deals with specifying how states or variables are referenced or aliased, potentially for clarity or specific solver interactions, within the context of steady-state problems defined in SciMLBase.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/steady_state_types.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nSciMLBase.SteadyStateAliasSpecifier\n```\n```\n\n----------------------------------------\n\nTITLE: Simulating Suprathreshold Alpha Synapse by Increasing Conductance in Julia\nDESCRIPTION: Repeats the alpha synapse simulation with a higher 'max_gSyn' parameter to evoke a spiking (suprathreshold) response in the HH neuron. Solves the ODE and overlays the new result on the previous plot using plot!. Shows suprathreshold activity resulting from increased synaptic conductance. Requires the plotting and ODE packages, along with variable definitions of u0 and HH!.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_17\n\nLANGUAGE: julia\nCODE:\n```\np = [35.0, 40.0, 0.3, -77.0, 55.0, -65.0, 1, 0, 0.01, 0, 20, 100]\ntspan = (0.0, 200)\nprob = ODEProblem(HH!, u0, tspan, p)\nsol = solve(prob);\nplot!(sol, vars = 1)\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for RADAR5 Test Problems\nDESCRIPTION: This Documenter.jl `@docs` block generates documentation for DDE problems originating from the RADAR5 test suite, specifically the Oregonator, Robertson, and Waltman models, as defined in `DDEProblemLibrary`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/dde_types.md#_snippet_8\n\nLANGUAGE: markdown\nCODE:\n```\n```@docs\nprob_dde_RADAR5_oregonator\nprob_dde_RADAR5_robertson\nprob_dde_RADAR5_waltman\n```\n```\n\n----------------------------------------\n\nTITLE: Generating Optimized ODE Code with ModelingToolkit.jl in Julia\nDESCRIPTION: This snippet demonstrates using ModelingToolkit.jl to automatically generate optimized code for an ODE system. It defines a basic, potentially less optimized version (`basic_version!`) of the ODE function, sets up the initial conditions `r0` and parameters `p`, creates a standard `ODEProblem`, and then uses `modelingtoolkitize` to convert it into a symbolic representation (`de`). Finally, it creates a new, potentially optimized `ODEProblem` (`fastprob`) from the symbolic model, enabling features like automatic sparse Jacobian generation.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_29\n\nLANGUAGE: julia\nCODE:\n```\nusing ModelingToolkit\nfunction basic_version!(dr, r, p, t)\n    a, Î±, ubar, Î², D1, D2 = p\n    u = r[:, :, 1]\n    v = r[:, :, 2]\n    Du = D1 * (Ay * u + u * Ax)\n    Dv = D2 * (Ay * v + v * Ax)\n    dr[:, :, 1] = Du .+ a .* u .* u ./ v .+ ubar .- Î± * u\n    dr[:, :, 2] = Dv .+ a .* u .* u .- Î² * v\nend\n\na, Î±, ubar, Î², D1, D2 = p\nuss = (ubar + Î²) / Î±\nvss = (a / Î²) * uss^2\nr0 = zeros(100, 100, 2)\nr0[:, :, 1] .= uss .+ 0.1 .* rand.()\nr0[:, :, 2] .= vss\n\nprob = ODEProblem(basic_version!, r0, (0.0, 0.1), p)\nde = complete(modelingtoolkitize(prob))\n\n# Note jac=true,sparse=true makes it automatically build sparse Jacobian code\n# as well!\n\nfastprob = ODEProblem(de, [], (0.0, 0.1), jac = true, sparse = true)\n```\n\n----------------------------------------\n\nTITLE: Memory-Efficient Batch Reduction by Summing Endpoints - DifferentialEquations.jl - Julia\nDESCRIPTION: A reduction function is defined to sum endpoints from each batch, reducing memory by not storing all trajectories. Repeatedly adds the sum of each batch to a running accumulator. Used within EnsembleProblem along with other configuration. Yields a single number as result, from which the mean can be computed by dividing by number of trajectories. Useful when only summary statistics are desired.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_30\n\nLANGUAGE: julia\nCODE:\n```\nfunction reduction(u, batch, I)\n    u + sum(batch), false\nend\nprob2 = EnsembleProblem(prob, prob_func = prob_func, output_func = output_func,\n    reduction = reduction, u_init = 0.0)\nsim2 = solve(prob2, Tsit5(), trajectories = 100, batch_size = 20)\n```\n\n----------------------------------------\n\nTITLE: Setting Up and Solving the Hamiltonian ODE System with ModelingToolkit.jl (Julia)\nDESCRIPTION: Formulates the N-body Hamiltonian equations as a second order ODE system, creates the corresponding ODESystem, simplifies it, initializes the ODE problem with current state and velocities, and numerically solves for planet positions over time. Requires ModelingToolkit.jl, OrdinaryDiffEq.jl, and previously defined model variables (potential, u, D, M, tspan, pos, vel). Expects consistent dimensional shapes for input vectors and initial conditions. Outputs a solution object containing trajectories for all bodies.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/outer_solar_system.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\neqs = vec(@. D(D(u))) .~ .-ModelingToolkit.gradient(potential, vec(u)) ./\n                         repeat(M, inner = 3)\n@named sys = ODESystem(eqs, t)\nss = structural_simplify(sys)\nprob = ODEProblem(ss, [vec(u .=> pos); vec(D.(u) .=> vel)], tspan)\nsol = solve(prob, Tsit5());\n```\n\n----------------------------------------\n\nTITLE: Redirecting Using HTML Meta Tag in Julia Documentation - HTML\nDESCRIPTION: This snippet uses a raw HTML \\u003cmeta\\u003e tag for immediate page redirection within a Julia documentation site. No external dependencies are required. The key parameter is the 'content' attribute, which sets a refresh delay of 0 seconds and specifies '../getting_started' as the new URL. Inputs: user navigation to the page. Output: user is redirected. Limitation: content is HTML-specific and only works in environments rendering raw HTML.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/ode_example.md#_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n&#x60;&#x60;&#x60;@raw html\\n&#x3C;meta http-equiv=\\\"Refresh\\\" content=\\\"0; url='../getting_started'\\\" /&#x3E;\\n&#x60;&#x60;&#x60;\n```\n\n----------------------------------------\n\nTITLE: Interpolated Solution with API Options - SciMLBase - Julia\nDESCRIPTION: Demonstrates the full interpolation API: computes the solution or its derivatives at time(s) t, optionally specifying the derivative order, indices, and continuity side. Requires dense output support from the solver and a compatible solution type. Returns interpolated values or derivatives.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/solution.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nsol(t, deriv = Val{0}; idxs = nothing, continuity = :left)\n```\n\n----------------------------------------\n\nTITLE: Solving ODE with Callback and tstops for Precise Event Timing in Julia\nDESCRIPTION: Solves the ODE problem (`prob`) using the `Tsit5()` solver, the `DiscreteCallback` (`cb`), and explicitly specifies `tstops = [4.0]`. This forces the solver to step exactly at `t=4.0`, guaranteeing the callback's condition is evaluated and the effect (dosing) is applied at the intended time. The result is plotted using `Plots`. Requires `DifferentialEquations` and `Plots`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\n```@example callback1\nsol = solve(prob, Tsit5(), callback = cb, tstops = [4.0])\nplot(sol)\n```\n```\n\n----------------------------------------\n\nTITLE: Compute Covariances over Ensemble Simulations - DifferentialEquations.EnsembleAnalysis.jl - Julia\nDESCRIPTION: Performs covariance analysis across ensemble solutions. timeseries_steps_meancov computes covariances at all time steps, assuming a fixed dt. timeseries_point_meancov computes at interpolated points as defined by user-supplied ranges. Enables advanced joint-uncertainty assessment and dimensional correlation analysis of ensembles.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_37\n\nLANGUAGE: julia\nCODE:\n```\ntimeseries_steps_meancov(sim) # Use the time steps, assume fixed dt\ntimeseries_point_meancov(sim, 0:(1 // 2^(3)):1, 0:(1 // 2^(3)):1) # Use time points, interpolate\n```\n\n----------------------------------------\n\nTITLE: Installing and Using LSODA.jl Algorithm in Julia\nDESCRIPTION: This code snippet shows how to install and use the LSODA.jl package, which provides access to the well-known LSODA algorithm for solving both stiff and non-stiff ODEs in Julia. Dependencies are the Pkg module and LSODA package, which must be added explicitly. The snippet is essential for setting up the environment to utilize the LSODA wrapper, as it is not bundled with DifferentialEquations.jl by default.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_39\n\nLANGUAGE: julia\nCODE:\n```\nusing Pkg\nPkg.add(\"LSODA\")\nusing LSODA\n\n```\n\n----------------------------------------\n\nTITLE: Plotting Custom-Transformed Solution Data with Plots.jl in Julia\nDESCRIPTION: These snippets show how to use custom functions as part of idxs to define transformed axes, e.g., norm of the solution state, for plotting. Dependencies: Plots.jl. Inputs: solution object, a function to compute transformations, idxs settings. Outputs: plots of arbitrary functional forms of the solution. Enables advanced plotting such as norms or projections over time.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/plot.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nf(x, y, z) = (sqrt(x^2 + y^2 + z^2), x)\nplot(sol, idxs = (f, 1, 2, 3))\n```\n\nLANGUAGE: julia\nCODE:\n```\nf(t, x, y, z) = (t, sqrt(x^2 + y^2 + z^2))\nplot(sol, idxs = (f, 0, 1, 2, 3))\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Various Linear Solver Strategies for Large Stiff ODEs in Julia using BenchmarkTools\nDESCRIPTION: These benchmarking commands use BenchmarkTools.jl's @btime macro to measure performance of various DifferentialEquations.jl solver configurations on the 2D Brusselator problem, including dense versus sparse Jacobians, and different linear solver backends (TRBDF2, KenCarp47, KLUFactorization). No outputs are stored (final 'nothing'). Users should ensure BenchmarkTools is imported and that problem definitions are available in the session.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/advanced_ode_example.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nusing BenchmarkTools # for @btime\n@btime solve(prob_ode_brusselator_2d, TRBDF2(), save_everystep = false);\n@btime solve(prob_ode_brusselator_2d_sparse, TRBDF2(), save_everystep = false);\n@btime solve(prob_ode_brusselator_2d_sparse, KenCarp47(linsolve = KLUFactorization()),\n    save_everystep = false);\nnothing # hide\n\n```\n\n----------------------------------------\n\nTITLE: Defining ILU Preconditioner Setup Function for Sundials in Julia\nDESCRIPTION: This code defines the `psetupilu` function required by Sundials for setting up a preconditioner. It computes the Jacobian using the function from the `ModelingToolkit`-generated problem (`prob_ode_brusselator_2d_mtk.f.jac`), calculates the `W = I - gamma*J` matrix, and then builds the ILU preconditioner using `IncompleteLU.ilu`. The computed preconditioner is stored in a `Ref` called `preccache` for use by the `prec` function. It uses pre-allocated caches `jaccache` and `W`. Requires `LinearAlgebra`, `IncompleteLU.jl`, and access to the `prob_ode_brusselator_2d_mtk` object.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/advanced_ode_example.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nusing LinearAlgebra\nu0 = prob_ode_brusselator_2d_mtk.u0\np = prob_ode_brusselator_2d_mtk.p\nconst jaccache = prob_ode_brusselator_2d_mtk.f.jac(u0, p, 0.0)\nconst W = I - 1.0 * jaccache\n\nprectmp = ilu(W, Ï = 50.0)\nconst preccache = Ref(prectmp)\n\nfunction psetupilu(p, t, u, du, jok, jcurPtr, gamma)\n    if jok\n        prob_ode_brusselator_2d_mtk.f.jac(jaccache, u, p, t)\n        jcurPtr[] = true\n\n        # W = I - gamma*J\n        @. W = -gamma * jaccache\n        idxs = diagind(W)\n        @. @view(W[idxs]) = @view(W[idxs]) + 1\n\n        # Build preconditioner on W\n        preccache[] = ilu(W, Ï = 5.0)\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Computing Derivatives in GPU Kernel with CUDA and Julia\nDESCRIPTION: This CUDA kernel function implements the calculation of the derivative array du (reaction portion) by summing various ionic currents which are computed through device-side functions using thread/block coordinates for 2D data. It then updates du in-place for each medium site according to a classical reaction-diffusion equation. The function assumes device memory inputs and must be launched as a CUDA kernel. Inputs are arrays for all variables and parameters, and output is via in-place modification of du; no value is returned due to CUDA kernel constraints.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/beeler_reuter.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\nfunction update_du_gpu(du, u, XI, M, H, J, D, F, C)\n    i = (blockIdx().x - UInt32(1)) * blockDim().x + threadIdx().x\n    j = (blockIdx().y - UInt32(1)) * blockDim().y + threadIdx().y\n\n    v = Float32(u[i, j])\n\n    # calculating individual currents\n    iK1 = calc_iK1(v)\n    ix1 = calc_ix1(v, XI[i, j])\n    iNa = calc_iNa(v, M[i, j], H[i, j], J[i, j])\n    iCa = calc_iCa(v, D[i, j], F[i, j], C[i, j])\n\n    # total current\n    I_sum = iK1 + ix1 + iNa + iCa\n\n    # the reaction part of the reaction-diffusion equation\n    du[i, j] = -I_sum / C_m\n    nothing\nend\n```\n\n----------------------------------------\n\nTITLE: Improved Readability Parameterized Lorenz Definition - DifferentialEquations.jl - Julia\nDESCRIPTION: Enhances clarity by unpacking state and parameter vectors and explicitly naming derivatives. Improves code maintainability while preserving the parameterized Lorenz system structure. Accepts the same arguments as earlier; only variable desctructuring and named assignment differ.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/getting_started.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nfunction parameterized_lorenz!(du, u, p, t)\n    x, y, z = u\n    Ï, Ï, Î² = p\n    du[1] = dx = Ï * (y - x)\n    du[2] = dy = x * (Ï - z) - y\n    du[3] = dz = x * y - Î² * z\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Conditional Discrete Callback with State Dependency in Julia\nDESCRIPTION: Implements a more complex `DiscreteCallback` for multiple dose times (`dosetimes`). The `condition` function now includes a state-dependent check: it triggers only if the time `t` is in `dosetimes` *and* the current state `u[1]` is less than 1.0. The `affect!` function applies a time-dependent dose, adding `10*integrator.t` to `u[1]`. The ODE is solved with `Tsit5()`, using `tstops` to hit the specified `dosetimes`, and the result is plotted. Requires `DifferentialEquations` and `Plots`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\n```@example callback1\ndosetimes = [4.0, 6.0, 8.0]\ncondition(u, t, integrator) = t â dosetimes && (u[1] < 1.0)\naffect!(integrator) = integrator.u[1] += 10integrator.t\ncb = DiscreteCallback(condition, affect!)\nsol = solve(prob, Tsit5(), callback = cb, tstops = dosetimes)\nplot(sol)\n```\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Rosenbrock23 ODE Solver - Julia\nDESCRIPTION: Benchmarks the performance of the Rosenbrock23 solver when applied to a stiff ODE problem. Uses the `@btime` macro from BenchmarkTools.jl and the `solve` function. Inputs required are an ODE problem instance (`prob`) and the Rosenbrock23 method; outputs are measured execution time. Only works if the dependencies DifferentialEquations.jl, and BenchmarkTools.jl are installed; `nothing # hide` is used to prevent output in documentation builds.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\n@btime solve(prob, Rosenbrock23());\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Plotting the Solution of a BVP Solved via Shooting Method in Julia\nDESCRIPTION: This simple snippet uses the `Plots` package to visualize the solution object `sol3`, which was obtained by solving the simple pendulum Boundary Value Problem using the Shooting method in the previous step.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/bvp_example.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nplot(sol3)\n```\n\n----------------------------------------\n\nTITLE: Initializing Integrator with Custom Time Stops and Iterating Solution (SciMLBase, Julia)\nDESCRIPTION: Initializes an integrator for an ODE problem using Tsit5 algorithm with specified dt, tstops, and advance_to_tstop. Iterates over solution values at tstops, using tuples to access (u, t). Useful for capturing solution only at specified time points. Requires DifferentialEquations, a problem definition, and appropriate solver.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/integrator.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nintegrator = init(prob, Tsit5(); dt = 1 // 2^(4), tstops = [0.5], advance_to_tstop = true)\nfor (u, t) in tuples(integrator)\n    @test t â [0.5, 1.0]\nend\n```\n\n----------------------------------------\n\nTITLE: Summarizing Ensemble Solutions - DifferentialEquations.jl - Julia\nDESCRIPTION: Builds an EnsembleSummary from simulation results to allow summary statistics and ready visualization. Supports both default timestep-wise summaries and summaries at user-specified time grids. Highly useful for systematic postprocessing and reporting of ensemble results.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_38\n\nLANGUAGE: julia\nCODE:\n```\nsumm = EnsembleSummary(sim)\n\nsumm = EnsembleSummary(sim, 0.0:0.1:1.0)\n```\n\n----------------------------------------\n\nTITLE: Defining an Out-of-Place Lorenz System in Julia\nDESCRIPTION: Defines the Lorenz ODEs in out-of-place form, returning a new array at every call. No dependencies aside from core Julia required at definition; intended as a demonstration of standard high-level language approach. Inputs: u (state vector), p (parameters), t (time); returns 3-element array of derivatives. Allocates a new array on each call, leading to performance/memory issues for repeated solves or inside solvers.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nfunction lorenz(u, p, t)\n    dx = 10.0 * (u[2] - u[1])\n    dy = u[1] * (28.0 - u[3]) - u[2]\n    dz = u[1] * u[2] - (8 / 3) * u[3]\n    [dx, dy, dz]\nend\n```\n\n----------------------------------------\n\nTITLE: Terminating ODE Integration with DiscreteCallback in Julia\nDESCRIPTION: Demonstrates terminating an ODE integration using a `DiscreteCallback`. The integration stops at the first *step* where the condition `u[2] > 0` (velocity becomes positive) is met. The `affect!` function simply calls `terminate!(integrator)`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_38\n\nLANGUAGE: julia\nCODE:\n```\ncondition(u, t, integrator) = u[2] > 0\naffect!(integrator) = terminate!(integrator)\ncb = DiscreteCallback(condition, affect!)\nsol = solve(prob, Tsit5(), callback = cb)\n```\n\n----------------------------------------\n\nTITLE: List Comprehension over Solution Tuples - SciMLBase - Julia\nDESCRIPTION: Uses the 'tuples(sol)' iterator to get solution values paired with timepoints, then performs a list comprehension where 't + 2u' is calculated for each tuple. Requires that the 'tuples' function is available (provided by SciMLBase). Useful for vectorized manipulations or analyses of solution series.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/solution.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\n[t + 2u for (u, t) in tuples(sol)]\n```\n\n----------------------------------------\n\nTITLE: Example Explicit Solvers Less Suitable for Stiff ODEs\nDESCRIPTION: Lists examples of explicit ODE solvers, `Tsit5()` and `Vern7()`, which are generally efficient for non-stiff problems but may require excessively small time steps (leading to exceeding `maxiters`) for stiff ODEs.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_17\n\nLANGUAGE: julia\nCODE:\n```\nTsit5(), Vern7()\n```\n\n----------------------------------------\n\nTITLE: Visualizing Numerical vs. Analytic Solution and Error in Julia using Plots.jl\nDESCRIPTION: Extracts the final numerical solution `T_end` from the `sol` object. Uses the `Plots.jl` library to create two plots: the first (`p1`) compares the numerical solution (`T_end`) with the analytic steady-state solution (`T_analytic`) over the spatial domain `zf`; the second (`p2`) plots the absolute error between the numerical and analytic solutions. Finally, it displays both plots side-by-side using `Plots.plot(p1, p2)`. Depends on `sol`, `T_analytic`, `zf`, and the `Plots` package.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/diffusion_implicit_heat_equation.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nT_end = sol.u[end]\n\np1 = Plots.plot(zf, T_analytic.(zf), label = \"analytic\", markershape = :circle,\n    markersize = 6)\np1 = Plots.plot!(p1, zf, T_end, label = \"numerical\", markershape = :diamond)\np1 = Plots.plot!(p1, title = \"T \\u2208 cell faces\")\n\np2 = Plots.plot(zf, abs.(T_end .- T_analytic.(zf)), label = \"error\", markershape = :circle,\n    markersize = 6)\np2 = Plots.plot!(p2, title = \"T \\u2208 cell faces\")\n\nPlots.plot(p1, p2)\n```\n\n----------------------------------------\n\nTITLE: Parametric ODE Problem with Distribution-Valued Initial Condition - DifferentialEquations.jl - Julia\nDESCRIPTION: This code constructs an ODEProblem where the initial condition is a distribution from the Distributions.jl package, dependent on parameters and initial time. Every time `solve` or `init` is called, the system samples a new initial condition from `Normal(p, 1)`, which allows for stochastic or uncertain initial values. Requires both DifferentialEquations.jl and Distributions.jl; key parameters include the main ODE function, a function of parameters and time returning a distribution, a time span tuple, and scalar parameter `p`. Inputs are parameterized functions; output is an ODEProblem supporting sampling-based workflows.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/problem.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nusing Distributions\nprob = ODEProblem((u, p, t) -> u, (p, t) -> Normal(p, 1), (0.0, 1.0), 1.0)\n```\n\n----------------------------------------\n\nTITLE: Solving and Plotting Voltage Trace of Izhikevich Model in Julia\nDESCRIPTION: Numerically solves the ODE problem for the Izhikevich neuron and generates a plot of the first state variable (membrane potential) over time. Assumes that 'prob' is an instance of ODEProblem and Plots.jl is properly loaded. Outputs a voltage trace representative of the model's spiking behavior.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob);\nplot(sol, vars = 1)\n```\n\n----------------------------------------\n\nTITLE: Defining Drift and Diffusion Functions for Heston SDE in Julia\nDESCRIPTION: Defines the drift and diffusion functions (f and g) used in the Heston SDE. The 'f' function encodes the drift for asset price and variance, while 'g' describes the respective noise contributions. Dependencies: requires Î¼, Îº, Î, and Ï to be defined prior. Inputs are derivative vector du, state vector u, parameters p, and time t. Produces updated derivatives in du; meant for use within Julia's differential equation solvers. Assumes Î¼, Îº, Î, Ï are globally accessible.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/sde_example.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\nfunction f(du, u, p, t)\n    du[1] = Î¼ * u[1]\n    du[2] = Îº * (Î - u[2])\nend\nfunction g(du, u, p, t)\n    du[1] = âu[2] * u[1]\n    du[2] = Ï * âu[2]\nend\n```\n\n----------------------------------------\n\nTITLE: Plotting ODE Solution with Global Extrema in Julia\nDESCRIPTION: Visualizes the 4th state variable of the ODE solution over time and overlays the identified global minimum and maximum points found using global optimization. It uses `Plots.jl` to plot the solution curve and `scatter!` to mark the global extrema obtained from `gopt` and `gopt2` results.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/min_and_max.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nplot(sol, vars = (0, 4), plotdensity = 10000)\nscatter!([gopt.u], [gopt.minimum], label = \"Global Min\")\nscatter!([gopt2.u], [-gopt2.minimum], label = \"Global Max\")\n```\n\n----------------------------------------\n\nTITLE: Analyzing Energy Conservation for HÃ©non-Heiles (KahanLi8 Symplectic Solution) in Julia\nDESCRIPTION: This snippet analyzes the energy conservation of the symplectic `KahanLi8` solver for the HÃ©non-Heiles system. It calculates the total energy `E` at each time step using the solution `sol2` (adjusting indices for the `SecondOrderODEProblem` output format `[dx, dy, x, y]`), computes and displays the total energy drift (`ÎE`), and plots the change in energy over time using the `Plots` package. It highlights the superior energy conservation compared to non-symplectic methods.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/classical_physics.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\nenergy = map(x -> E(x[3], x[4], x[1], x[2]), sol2.u)\n#We use @show here to easily spot erratic behaviour in our system by seeing if the loss in energy was too great.\n@show ÎE = energy[1] - energy[end]\n\n#Plot\nplot(sol2.t, energy .- energy[1], title = \"Change in Energy over Time\",\n    xaxis = \"Time in iterations\", yaxis = \"Change in Energy\")\n```\n\n----------------------------------------\n\nTITLE: High Accuracy Non-Stiff Solver VCABM for Large/Expensive Systems in Julia\nDESCRIPTION: `VCABM` (Variable-coefficient Adams-Bashforth-Moulton) can be a good choice for high accuracy non-stiff solving when the system is very large (>1000 ODEs), the function calculation is expensive, or the solution is very smooth.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\nVCABM\n```\n\n----------------------------------------\n\nTITLE: Plotting ODE Solution Phase Space in Julia\nDESCRIPTION: Generates a phase-space plot for the double pendulum ODE solution, showing the trajectory of the 4th state variable against the 3rd state variable. It utilizes the `Plots.jl` library and the `sol` object.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/min_and_max.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nplot(sol, vars = (3, 4), leg = false)\n```\n\n----------------------------------------\n\nTITLE: Saving Plots with savefig in Plots.jl in Julia\nDESCRIPTION: This snippet demonstrates saving a plot to a file using Plots.jl's savefig function. Dependencies: Plots.jl. Inputs: a filename string for output. Outputs: the generated plot is written to the specified PNG file. The plot must already be displayed or available in the current context.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/plot.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nsavefig(\"myplot.png\")\n```\n\n----------------------------------------\n\nTITLE: Solving State-Dependent ODEs using LieRK4 in Julia\nDESCRIPTION: This Julia snippet sets up and solves a non-stiff non-autonomous linear ODE with a state-dependent operator using the LieRK4 algorithm from DifferentialEquations.jl. It features an update_func that modifies the operator matrix based on the current state, requiring SciMLOperators for a mutable operator representation. The solver is executed with a fixed \\'dt\\', and outputs the solution trajectory for the problem. Prerequisite libraries are DifferentialEquations and SciMLOperators.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/nonautonomous_linear_ode.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nfunction update_func(A, u, p, t)\n    A[1, 1] = 0\n    A[2, 1] = sin(u[1])\n    A[1, 2] = -1\n    A[2, 2] = 0\nend\nA = SciMLOperators.MatrixOperator(ones(2, 2), update_func = update_func)\nprob = ODEProblem(A, ones(2), (0, 30.0))\nsol = solve(prob, LieRK4(), dt = 1 / 4)\n```\n\n----------------------------------------\n\nTITLE: Rosenbrock Solver ROS3P for Parabolic PDEs in Julia\nDESCRIPTION: `ROS3P` is a 3rd order Rosenbrock method noted for achieving 3rd order accuracy on discretizations of nonlinear parabolic PDEs, potentially offering efficiency advantages in such cases.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_24\n\nLANGUAGE: julia\nCODE:\n```\nROS3P\n```\n\n----------------------------------------\n\nTITLE: Solving an ODE Problem with lsoda Solver in Julia\nDESCRIPTION: Demonstrates how to solve an ODE problem `prob` using the `lsoda` solver, accessed through its Julia wrapper (e.g., `LSODA.jl`), showcasing the ease of switching solvers.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\nsolve(prob,lsoda())\n```\n\n----------------------------------------\n\nTITLE: Plotting with Other Backends Without Recipes in Julia\nDESCRIPTION: These examples show how to directly access solution values for plotting with other plotting libraries such as PyPlot, Gadfly, or GR without using DiffEq recipes. The solution is treated as an AbstractMatrix, with sol[i,j] indexing. Inputs: solution object, selection indices. Outputs: typical x/y/z data arrays for plotting. No interpolation or recipes are used; for continuous results, manual interpolation is required.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/plot.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nplot(sol.t, sol')\n```\n\nLANGUAGE: julia\nCODE:\n```\nplot(sol[i, :], sol[j, :], sol[k, :])\n```\n\n----------------------------------------\n\nTITLE: Solving SDEs with Higher-Order SRIW1 Solver (Adaptive and Fixed dt) in Julia\nDESCRIPTION: This snippet demonstrates use of the higher-order SRIW1() solver to improve solution accuracy for scalar SDEs, both with fixed and automatically estimated timesteps (adaptive). Requires DifferentialEquations.jl. The output is plotted against the analytic solution for accuracy assessment.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/sde_example.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, SRIW1(), dt = dt, adaptive = false)\nplot(sol, plot_analytic = true)\n```\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, SRIW1())\nplot(sol, plot_analytic = true)\n```\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, SRIW1(), dt = dt)\nplot(sol, plot_analytic = true)\n```\n\n----------------------------------------\n\nTITLE: Compute Mean and Variance Series at Timesteps - DifferentialEquations.EnsembleAnalysis.jl - Julia\nDESCRIPTION: Extracts arrays of mean and variance at each time step using timeseries_steps_meanvar, facilitating statistics over the trajectory. Operates on ensemble simulation results. Outputs series that can be further visualized. Useful for time-course analysis over fixed time grids.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_35\n\nLANGUAGE: julia\nCODE:\n```\nm_series, v_series = timeseries_steps_meanvar(sim)\n```\n\n----------------------------------------\n\nTITLE: Custom Noise Function for Diagonal-System SDE (Lorenz) in Julia\nDESCRIPTION: This snippet demonstrates a custom in-place noise function for a system SDE, where the noise on each variable can depend nonlinearly on state variables. This allows for more general types of diagonal noise in system SDEs. There are no outputsâthis is a function definition for later problem construction.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/sde_example.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nfunction Ï_lorenz!(du, u, p, t)\n    du[1] = sin(u[3]) * 3.0\n    du[2] = u[2] * u[1] * 3.0\n    du[3] = 3.0\nend\n```\n\n----------------------------------------\n\nTITLE: Defining SDE Problems with Matrix State - DifferentialEquations.jl - Julia\nDESCRIPTION: Defines functions f and Ï for drift and diffusion in an SDE system, operating on 4x2 arrays. Each component's derivative is a linear function of its value. SDEProblem is constructed with these functions, a 4x2 matrix initial state, and a time interval. Requires DifferentialEquations.jl and is set up for high-dimensional stochastic simulations.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_31\n\nLANGUAGE: julia\nCODE:\n```\nfunction f(du, u, p, t)\n    for i in 1:length(u)\n        du[i] = 1.01 * u[i]\n    end\nend\nfunction Ï(du, u, p, t)\n    for i in 1:length(u)\n        du[i] = 0.87 * u[i]\n    end\nend\nusing DifferentialEquations\nprob = SDEProblem(f, Ï, ones(4, 2) / 2, (0.0, 1.0)) #prob_sde_2Dlinear\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Tsit5 with Disabled save_everystep (DifferentialEquations.jl, Julia)\nDESCRIPTION: This code benchmarks the Tsit5 solver on a longer integration interval (0.0 to 100.0) and disables save_everystep to significantly reduce memory usage, mitigating potential out-of-memory errors. The snippet warns that enabling step-wise saving may cause excessive memory allocations for large-scale problems. The ODEProblem structure and approach are consistent with prior examples. Dependencies: DifferentialEquations.jl, BenchmarkTools.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_32\n\nLANGUAGE: julia\nCODE:\n```\nprob = ODEProblem(fast_gm!, r0, (0.0, 100.0), p)\n# Will go out of memory if we don't turn off `save_everystep`!\n@btime solve(prob, Tsit5(), save_everystep = false);\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Applying Manifold Projection for Energy Conservation Only in Julia\nDESCRIPTION: Shows the effect of projecting the solution onto the energy conservation manifold only. Defines the `energy_manifold` function, which calculates the residual only for the Hamiltonian (H) and sets the residual components for angular momentum (L) to zero. Creates a `ManifoldProjection` callback (`energy_cb`). Solves the first-order ODE problem (`prob2`) with `RK4` (fixed step) using this callback and plots the results (`analysis_plot2`), illustrating good energy conservation but drift in angular momentum. Requires previous definitions and libraries.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/kepler_problem.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nfunction energy_manifold(residual, u, p, t)\n    residual[1:2] .= initial_first_integrals[1] - H(u[1:2], u[3:4])\n    residual[3:4] .= 0\nend\nenergy_cb = ManifoldProjection(energy_manifold, autodiff = AutoForwardDiff())\nsol6 = solve(prob2, RK4(), dt = 1 // 5, adaptive = false, callback = energy_cb)\nanalysis_plot2(sol6, H, L)\n```\n\n----------------------------------------\n\nTITLE: Selecting Variables for Plotting in Plots.jl in Julia\nDESCRIPTION: These snippets declare idxs variable to specify which variables or combinations should be plotted. The idxs array/tuples allow users to choose dependent and independent variables, custom functions, and variable associations for multi-dimensional or transformed visualizations. Inputs: variable/function indices or symbols. Dependencies: Plots.jl. Output: tuple or array of indices/functions for use with plot commands. Enables flexible customization of axes and plotted data.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/plot.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nidxs = [(f1, 0, 1), (f2, 1, 3), (f3, 4, 5)]\n```\n\nLANGUAGE: julia\nCODE:\n```\nidxs = [(0, 1), (1, 3), (4, 5)]\n```\n\nLANGUAGE: julia\nCODE:\n```\nidxs = [1, (1, 3), (4, 5)]\n```\n\nLANGUAGE: julia\nCODE:\n```\nidxs = [1, 3, 4]\n```\n\nLANGUAGE: julia\nCODE:\n```\nidxs = ([1, 2, 3], [4, 5, 6])\n```\n\nLANGUAGE: julia\nCODE:\n```\nidxs = [(1, 4), (2, 5), (3, 6)]\n```\n\nLANGUAGE: julia\nCODE:\n```\nidxs = (1, [2, 3, 4])\n```\n\nLANGUAGE: julia\nCODE:\n```\nidxs = [(1, 2), (1, 3), (1, 4)]\n```\n\n----------------------------------------\n\nTITLE: Benchmarking StaticArray ODE Solution Without Saving Every Step (Julia)\nDESCRIPTION: Benchmarks solving the static array Lorenz ODE but disables saving at every timestep. Used to monitor allocations and timings specific to static array (SVector) usage. Dependencies: BenchmarkTools.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\n@btime solve(prob, Tsit5(), save_everystep = false);\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Solving Double Pendulum ODE System with OrdinaryDiffEq.jl in Julia\nDESCRIPTION: This Julia code tackles the complex dynamics of a double pendulum by defining and solving its governing system of four first-order ODEs using `OrdinaryDiffEq.jl`. It sets up constants, initial conditions, defines the `double_pendulum` function representing the ODE system, and includes a `polar2cart` helper for coordinate transformation. The system is solved using the `Vern7` integrator with specified accuracy tolerances via `ODEProblem` and `solve`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/classical_physics.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\n#Double Pendulum Problem\nusing OrdinaryDiffEq, Plots\n\n#Constants and setup\nconst mâ, mâ, Lâ, Lâ = 1, 2, 1, 2\ninitial = [0, Ï / 3, 0, 3pi / 5]\ntspan = (0.0, 50.0)\n\n#Convenience function for transforming from polar to Cartesian coordinates\nfunction polar2cart(sol; dt = 0.02, l1 = Lâ, l2 = Lâ, vars = (2, 4))\n    u = sol.t[1]:dt:sol.t[end]\n\n    p1 = l1 * map(x -> x[vars[1]], sol.(u))\n    p2 = l2 * map(y -> y[vars[2]], sol.(u))\n\n    x1 = l1 * sin.(p1)\n    y1 = l1 * -cos.(p1)\n    (u, (x1 + l2 * sin.(p2),\n        y1 - l2 * cos.(p2)))\nend\n\n#Define the Problem\nfunction double_pendulum(xdot, x, p, t)\n    xdot[1] = x[2]\n    xdot[2] = -((g * (2 * mâ + mâ) * sin(x[1]) +\n                 mâ * (g * sin(x[1] - 2 * x[3]) +\n                  2 * (Lâ * x[4]^2 + Lâ * x[2]^2 * cos(x[1] - x[3])) * sin(x[1] - x[3]))) /\n                (2 * Lâ * (mâ + mâ - mâ * cos(x[1] - x[3])^2)))\n    xdot[3] = x[4]\n    xdot[4] = (((mâ + mâ) * (Lâ * x[2]^2 + g * cos(x[1])) +\n                Lâ * mâ * x[4]^2 * cos(x[1] - x[3])) * sin(x[1] - x[3])) /\n              (Lâ * (mâ + mâ - mâ * cos(x[1] - x[3])^2))\nend\n\n#Pass to Solvers\ndouble_pendulum_problem = ODEProblem(double_pendulum, initial, tspan)\nsol = solve(double_pendulum_problem, Vern7(), abstol = 1e-10, dt = 0.05);\n```\n\n----------------------------------------\n\nTITLE: Defining Colored Noise Processes in SDEProblem in Julia\nDESCRIPTION: This snippet presents the interface for adding arbitrary colored noise objects to an SDE model via the noise keyword in SDEProblem. The noise object (my_noise) must implement the Noise Process interface. Compatible only with certain methods such as EM and EulerHeun. No code execution; serves as an API usage illustration.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/sde_example.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\nSDEProblem(f, g, u0, tspan, noise = my_noise)\n```\n\n----------------------------------------\n\nTITLE: Standard ODE Solution Invocation - Julia\nDESCRIPTION: Shows the typical usage pattern for solving an ODE in Julia with DifferentialEquations.jl using a provided problem definition and algorithm. Inputs: prob (problem struct), alg (algorithm choice). Output: solution object. Dependencies: DifferentialEquations.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_26\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob, alg)\n```\n\n----------------------------------------\n\nTITLE: Correcting Floating Point Error in Affect Function (Julia)\nDESCRIPTION: This Julia code modifies the `affect!` function (`floor_aff!`) for the sticky bouncing ball to explicitly set the height `int.u[1] = 0` after the event. This manually corrects for potential floating-point inaccuracies where the root-finding might leave `u[1]` at a tiny non-zero value, ensuring the ball state is exactly `[0.0, 0.0]` after sticking.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_33\n\nLANGUAGE: julia\nCODE:\n```\nfunction floor_aff!(int)\n    int.p[1] = 0\n    int.u[1] = 0\n    int.u[2] = 0\n    @show int.u[1], int.t\nend\nfloor_event = ContinuousCallback(condition, floor_aff!)\nu0 = [1.0, 0.0]\np = [1.0]\nprob = ODEProblem{true}(dynamics!, u0, (0.0, 1.75), p)\nsol = solve(prob, Tsit5(), callback = floor_event)\nsol[end] # [0.0,0.0]\n```\n\n----------------------------------------\n\nTITLE: Defining and Using an AMG Preconditioner with Jacobi Smoothers in Julia\nDESCRIPTION: This snippet defines a function `algebraicmultigrid2` creating an Algebraic Multigrid (AMG) preconditioner using `ruge_stuben` but explicitly specifies `AlgebraicMultigrid.Jacobi` as both the pre-smoother and post-smoother. The preconditioner is updated conditionally based on `newW`. It then solves the sparse Brusselator ODE using `KenCarp47`, `KrylovJL_GMRES`, and this custom AMG preconditioner with Jacobi smoothers. Requires `AlgebraicMultigrid.jl` and `DifferentialEquations.jl`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/advanced_ode_example.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nfunction algebraicmultigrid2(W, du, u, p, t, newW, Plprev, Prprev, solverdata)\n    if newW === nothing || newW\n        A = convert(AbstractMatrix, W)\n        Pl = AlgebraicMultigrid.aspreconditioner(AlgebraicMultigrid.ruge_stuben(A,\n            presmoother = AlgebraicMultigrid.Jacobi(rand(size(A,\n                1))),\n            postsmoother = AlgebraicMultigrid.Jacobi(rand(size(A,\n                1)))))\n    else\n        Pl = Plprev\n    end\n    Pl, nothing\nend\n\n@btime solve(prob_ode_brusselator_2d_sparse,\n    KenCarp47(linsolve = KrylovJL_GMRES(), precs = algebraicmultigrid2,\n        concrete_jac = true), save_everystep = false);\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Safe Dual Number Handling with Cached Arrays - PreallocationTools.jl - Julia\nDESCRIPTION: Provides a workaround for cache incompatibility when using Dual numbers by leveraging PreallocationTools.jl's get_tmp and dualcache. Redefines the ODE to acquire a type-compatible temporary array every step, ensuring correctness for autodifferentiation. Suitable for high-performance ODE solving where temporary arrays are required.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_33\n\nLANGUAGE: julia\nCODE:\n```\nusing LinearAlgebra, OrdinaryDiffEq, PreallocationTools\nfunction foo(du, u, (A, tmp), t)\n    tmp = get_tmp(tmp, first(u) * t)\n    mul!(tmp, A, u)\n    @. du = u + tmp\n    nothing\nend\nprob = ODEProblem(foo, ones(5, 5), (0.0, 1.0),\n    (ones(5, 5), PreallocationTools.dualcache(zeros(5, 5))))\nsolve(prob, TRBDF2())\n```\n\n----------------------------------------\n\nTITLE: Defining prob_func for Varying SDE Noise Parameters (Julia)\nDESCRIPTION: Defines a Julia function `prob_func` for an `EnsembleProblem` that modifies the parameters of a base SDE problem (`prob`). Specifically, it randomizes the noise parameters (`p[3]`, `p[4]`) while keeping the drift parameters (`p[1]`, `p[2]`) constant. It uses a `let` block to capture the initial parameter vector `p` in a type-stable manner and `remake` to create the new problem for each trajectory.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_22\n\nLANGUAGE: julia\nCODE:\n```\n# `p` is a global variable, referencing it would be type unstable.\n# Using a let block defines a small local scope in which we can\n# capture that local `p` which isn't redefined anywhere in that local scope.\n# This allows it to be type stable.\nprob_func = let p = p\n    (prob, i, repeat) -> begin\n        x = 0.3rand(2)\n        remake(prob, p = [p[1], p[2], x[1], x[2]])\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Solving Bouncing Ball ODE Over Longer Time (Julia)\nDESCRIPTION: This Julia snippet demonstrates the robustness of the `ContinuousCallback` by solving the same bouncing ball problem over a much longer time span (`tspan = (0.0, 100.0)`). The plot shows that the callback correctly handles multiple bounce events.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_30\n\nLANGUAGE: julia\nCODE:\n```\nu0 = [50.0, 0.0]\ntspan = (0.0, 100.0)\nprob = ODEProblem(f, u0, tspan, p)\nsol = solve(prob, Tsit5(), callback = cb)\nplot(sol)\n```\n\n----------------------------------------\n\nTITLE: LSODA Solver for Large ODE Systems in Julia\nDESCRIPTION: The `lsoda` algorithm is recommended for very large ODE systems (e.g., >1000 ODEs) with unknown stiffness or for large, stiff systems where other methods like QNDF/FBDF might be used. It requires the external `LSODA.jl` package.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nlsoda\n```\n\n----------------------------------------\n\nTITLE: Calculating Linear Thread Index in CUDA (C/C++ and Julia)\nDESCRIPTION: This snippet shows how to compute a unique thread index within a 1D or 2D CUDA block-grid launching pattern. In C/C++, thread indices start at 0; in Julia, indices start at 1 (necessitating a subtraction when translating C/C++ code). It demonstrates proper use of thread and block indexing variables making the code portable across block dimensions. The resulting index is typically used to select the element of a tensor or array for each thread's computation.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/beeler_reuter.md#_snippet_14\n\nLANGUAGE: C/C++\nCODE:\n```\n    int idx = blockDim.x * blockIdx.x + threadIdx.x;\n```\n\nLANGUAGE: Julia\nCODE:\n```\n    idx = (blockIdx().x-UInt32(1)) * blockDim().x + threadIdx().x\n```\n\n----------------------------------------\n\nTITLE: Benchmarking PDE Discretization ODE Solver - Julia\nDESCRIPTION: Measures runtime of solving a large, semi-discretized PDE (reaction-diffusion system) using the Tsit5 solver. Utilizes the `@btime` macro and expects an already constructed, large ODEProblem (`prob`). Purpose is to demonstrate the baseline solver speed for further optimization. Dependencies: DifferentialEquations.jl, BenchmarkTools.jl. Output: speed and allocation stats (result suppressed with `nothing # hide`).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_23\n\nLANGUAGE: julia\nCODE:\n```\n@btime solve(prob, Tsit5());\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Defining and Using an Algebraic Multigrid Preconditioner with KenCarp47 in Julia\nDESCRIPTION: This snippet defines a function `algebraicmultigrid` that creates an Algebraic Multigrid (AMG) preconditioner using `AlgebraicMultigrid.aspreconditioner` and `ruge_stuben`. Similar to the ILU example, it updates the preconditioner based on the `newW` flag. It then solves the sparse Brusselator ODE problem using `KenCarp47` with `KrylovJL_GMRES` and the defined `algebraicmultigrid` preconditioner. `concrete_jac = true` is used to compute the sparse Jacobian. Dependencies include `AlgebraicMultigrid.jl` and `DifferentialEquations.jl`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/advanced_ode_example.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nusing AlgebraicMultigrid\nfunction algebraicmultigrid(W, du, u, p, t, newW, Plprev, Prprev, solverdata)\n    if newW === nothing || newW\n        Pl = aspreconditioner(ruge_stuben(convert(AbstractMatrix, W)))\n    else\n        Pl = Plprev\n    end\n    Pl, nothing\nend\n\n@btime solve(prob_ode_brusselator_2d_sparse,\n    KenCarp47(linsolve = KrylovJL_GMRES(), precs = algebraicmultigrid,\n        concrete_jac = true), save_everystep = false);\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Computing Jacobian using Finite Differences - FiniteDiff.jl - Julia\nDESCRIPTION: Computes the Jacobian of the function f using FiniteDiff.jl by evaluating finite differences around a parameter point. Requires FiniteDiff.jl and a function f. Takes an array input and outputs the corresponding Jacobian matrix. Serves as a reference to compare with automatically differentiated results.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_30\n\nLANGUAGE: julia\nCODE:\n```\nusing FiniteDiff\nFiniteDiff.finite_difference_jacobian(f, [1.5, 1.0])\n```\n\n----------------------------------------\n\nTITLE: Computing Jacobian using Forward-mode AD - ForwardDiff.jl - Julia\nDESCRIPTION: Uses ForwardDiff.jl to compute the Jacobian of the ODE solution function f(p) at a given parameter point. Requires ForwardDiff.jl and access to a differentiable function f. Expects an array input for parameter values and returns a Jacobian matrix. Designed for high-precision and compatibility with Dual-number-typed ODE solutions.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_29\n\nLANGUAGE: julia\nCODE:\n```\nusing ForwardDiff\nForwardDiff.jacobian(f, [1.5, 1.0])\n```\n\n----------------------------------------\n\nTITLE: Verifying Dose Application at Event Time in Julia\nDESCRIPTION: Demonstrates the effect of the conditional dose by printing the interpolated value of the solution `sol` exactly at the event time `t=4.0` and infinitesimally after (`t=4.000000000001`). This comparison highlights the discontinuity introduced by the `affect!` function, confirming that 10 units were added to `u[1]` at t=4.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/conditional_dosing.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nprintln(sol(4.00000))\nprintln(sol(4.000000000001))\n```\n\n----------------------------------------\n\nTITLE: Defining a Mutable Struct to Maintain State within a Callback in Julia\nDESCRIPTION: Defines a mutable struct `AutoAbstolAffect` parameterized by type `T`. It contains a single field `curmax::T`, intended to store and update the maximum value encountered so far during the simulation. Using a mutable struct allows an instance of this type (when used in the `affect!` function) to maintain persistent state across multiple calls to the callback during the integration process, which is necessary for tracking the running maximum for the AutoAbstol algorithm.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_19\n\nLANGUAGE: julia\nCODE:\n```\n```@example callback3\nmutable struct AutoAbstolAffect{T}\n    curmax::T\nend\n```\n```\n\n----------------------------------------\n\nTITLE: Updating Gating Variables Using CUDA-Compatible Rush-Larsen Scheme in Julia\nDESCRIPTION: This set of functions implements explicit gating variable update schemes tailored for GPU computation using CUDA.jl in Julia. Each function updates a specific gating variable (M, H, J, D, F, XI, and C) using the Rush-Larsen algorithm, where all mathematical operations are replaced with their CUDAnative-prefixed counterparts to ensure GPU compatibility. Dependencies include CUDA.jl and CUDAnative, and the functions take the current variable value, transmembrane potential, and timestep as inputs. The code demonstrates careful attention to numerical stability (e.g., avoiding division by zero), and the updates are designed to be called from within GPU kernels. Limitations include the manual prefixing of math functions due to current restrictions in CUDA.jl interoperability.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/beeler_reuter.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nfunction rush_larsen_gpu(g, Î±, Î², Ît)\n    inf = Î± / (Î± + Î²)\n    Ï = 1.0 / (Î± + Î²)\n    return clamp(g + (g - inf) * CUDAnative.expm1(-Ît / Ï), 0.0f0, 1.0f0)\nend\n\nfunction update_M_gpu(g, v, Ît)\n    # the condition is needed here to prevent NaN when v == 47.0\n    Î± = isapprox(v, 47.0f0) ? 10.0f0 :\n        -(v + 47.0f0) / (CUDAnative.exp(-0.1f0 * (v + 47.0f0)) - 1.0f0)\n    Î² = (40.0f0 * CUDAnative.exp(-0.056f0 * (v + 72.0f0)))\n    return rush_larsen_gpu(g, Î±, Î², Ît)\nend\n\nfunction update_H_gpu(g, v, Ît)\n    Î± = 0.126f0 * CUDAnative.exp(-0.25f0 * (v + 77.0f0))\n    Î² = 1.7f0 / (CUDAnative.exp(-0.082f0 * (v + 22.5f0)) + 1.0f0)\n    return rush_larsen_gpu(g, Î±, Î², Ît)\nend\n\nfunction update_J_gpu(g, v, Ît)\n    Î± = (0.55f0 * CUDAnative.exp(-0.25f0 * (v + 78.0f0))) /\n        (CUDAnative.exp(-0.2f0 * (v + 78.0f0)) + 1.0f0)\n    Î² = 0.3f0 / (CUDAnative.exp(-0.1f0 * (v + 32.0f0)) + 1.0f0)\n    return rush_larsen_gpu(g, Î±, Î², Ît)\nend\n\nfunction update_D_gpu(g, v, Ît)\n    Î± = Î³ * (0.095f0 * CUDAnative.exp(-0.01f0 * (v - 5.0f0))) /\n        (CUDAnative.exp(-0.072f0 * (v - 5.0f0)) + 1.0f0)\n    Î² = Î³ * (0.07f0 * CUDAnative.exp(-0.017f0 * (v + 44.0f0))) /\n        (CUDAnative.exp(0.05f0 * (v + 44.0f0)) + 1.0f0)\n    return rush_larsen_gpu(g, Î±, Î², Ît)\nend\n\nfunction update_F_gpu(g, v, Ît)\n    Î± = Î³ * (0.012f0 * CUDAnative.exp(-0.008f0 * (v + 28.0f0))) /\n        (CUDAnative.exp(0.15f0 * (v + 28.0f0)) + 1.0f0)\n    Î² = Î³ * (0.0065f0 * CUDAnative.exp(-0.02f0 * (v + 30.0f0))) /\n        (CUDAnative.exp(-0.2f0 * (v + 30.0f0)) + 1.0f0)\n    return rush_larsen_gpu(g, Î±, Î², Ît)\nend\n\nfunction update_XI_gpu(g, v, Ît)\n    Î± = (0.0005f0 * CUDAnative.exp(0.083f0 * (v + 50.0f0))) /\n        (CUDAnative.exp(0.057f0 * (v + 50.0f0)) + 1.0f0)\n    Î² = (0.0013f0 * CUDAnative.exp(-0.06f0 * (v + 20.0f0))) /\n        (CUDAnative.exp(-0.04f0 * (v + 20.0f0)) + 1.0f0)\n    return rush_larsen_gpu(g, Î±, Î², Ît)\nend\n\nfunction update_C_gpu(c, d, f, v, Ît)\n    ECa = D_Ca - 82.3f0 - 13.0278f0 * CUDAnative.log(c)\n    kCa = C_s * g_s * d * f\n    iCa = kCa * (v - ECa)\n    inf = 1.0f-7 * (0.07f0 - c)\n    Ï = 1.0f0 / 0.07f0\n    return c + (c - inf) * CUDAnative.expm1(-Ît / Ï)\nend\n```\n\n----------------------------------------\n\nTITLE: PI (Proportional-Integral) Controller Algorithm - Julia\nDESCRIPTION: Defines an adaptive timestep selection using both proportional and integral control to stabilize step changes. Key parameters include beta1 (proportional gain), beta2 (integral/history gain), and qold (previously used gain). Algorithm computes scaling factor using exponents and applies safety margins. A targetted for explicit methods; requires integrator data structure, controller parameters, and fastmath enabled. Inputs are error estimate, gain parameters; output is suggested time-step factor.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/extras/timestepping.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nEEst, beta1, q11, qold, beta2 = integrator.EEst, integrator.opts.beta1, integrator.q11,\nintegrator.qold, integrator.opts.beta2\n@fastmath q11 = EEst^beta1\n@fastmath q = q11 / (qold^beta2)\nintegrator.q11 = q11\n@fastmath q = max(inv(integrator.opts.qmax),\n    min(inv(integrator.opts.qmin), q / integrator.opts.gamma))\nif q <= integrator.opts.qsteady_max && q >= integrator.opts.qsteady_min\n    q = one(q)\nend\nq\n```\n```\n\n----------------------------------------\n\nTITLE: Interpolated Solution for Specific Components - SciMLBase - Julia\nDESCRIPTION: Shows how to interpolate for a specific subset of components at a given time using the 'idxs' keyword. For example, 'idxs = 1:2:5' selects components 1, 3, and 5. This is an optimization for large systems when only some outputs are needed.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/solution.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nsol(t, idxs = 1:2:5)\n```\n\n----------------------------------------\n\nTITLE: Stepping to a tstop and Forcing Early Stopping with SciMLBase in Julia\nDESCRIPTION: Initializes the integrator with tstops and sets stop_at_next_tstop to true to force solver to only solve up to the specified stopping time. Calls solve! to perform computation. Useful for fine-grained control over solution interpolation endpoint and early stopping.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/integrator.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nintegrator = init(prob, Tsit5(); dt = 1 // 2^(4), tstops = [0.5])\nintegrator.opts.stop_at_next_tstop = true\nsolve!(integrator)\n```\n\n----------------------------------------\n\nTITLE: Callback Definitions for Spike Threshold and Reset in Izhikevich Model with Julia\nDESCRIPTION: Defines the spike detection (`thr`), reset (`reset!`), and associated callbacks for managing state updates in the Izhikevich neuron simulation. Utilizes DiscreteCallback and PresetTimeCallback from DifferentialEquations.jl for threshold-based state reset and step increases in input current. Relies on the model's state conventions and consistent parameter indexing. Designed to be passed as a callback set to ODEProblem.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\nfunction thr(u, t, integrator)\n    integrator.u[1] >= 30\nend\n\nfunction reset!(integrator)\n    integrator.u[1] = integrator.p[3]\n    integrator.u[2] += integrator.p[4]\nend\n\nthreshold = DiscreteCallback(thr, reset!)\ncurrent_step = PresetTimeCallback(50, integrator -> integrator.p[5] += 10)\ncb = CallbackSet(current_step, threshold)\n```\n\n----------------------------------------\n\nTITLE: Integrating GPU Kernels with an Implicit Solver in Julia\nDESCRIPTION: This function overload implements the right-hand side for an ODEProblem using the BeelerReuterGpu model, handling data copies between host and device, launching custom CUDA kernels for state update and derivative computation, and finally adding a diffusion term computed on the CPU. It demonstrates advanced usage of CUDA.jl with DifferentialEquations.jl, leveraging @cuda for kernel invocation, and preserves correct memory synchronization between host and GPU. Required libraries: DifferentialEquations, CUDA.jl, and custom kernel setups. Inputs include host/device arrays and configuration parameters, and outputs the updated du vector for the ODE solver. Key constraints are that only the explicit portions are computed on the GPU, making CPU-GPU data transfers a potential performance bottleneck.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/beeler_reuter.md#_snippet_17\n\nLANGUAGE: julia\nCODE:\n```\nfunction (f::BeelerReuterGpu)(du, u, p, t)\n    L = 16   # block size\n    Ît = t - f.t\n    copyto!(f.d_u, u)\n    ny, nx = size(u)\n\n    if Ît != 0 || t == 0\n        @cuda blocks=(ny Ã· L, nx Ã· L) threads=(L, L) update_gates_gpu(f.d_u, f.d_XI, f.d_M,\n            f.d_H, f.d_J, f.d_D,\n            f.d_F, f.d_C, Ît)\n        f.t = t\n    end\n\n    laplacian(f.Îv, u)\n\n    # calculate the reaction portion\n    @cuda blocks=(ny Ã· L, nx Ã· L) threads=(L, L) update_du_gpu(\n        f.d_du, f.d_u, f.d_XI, f.d_M,\n        f.d_H, f.d_J, f.d_D, f.d_F,\n        f.d_C)\n\n    copyto!(du, f.d_du)\n\n    # ...add the diffusion portion\n    du .+= f.diff_coef .* f.Îv\nend\n```\n\n----------------------------------------\n\nTITLE: Solving a Sample DAE Problem with Sundials in Julia\nDESCRIPTION: This code demonstrates how to load and solve a predefined DAE problem using the DiffEqProblemLibrary.DAEProblemLibrary package and the Sundials solver suite. It requires installing both DiffEqProblemLibrary.jl and Sundials.jl. The key parameters are the loaded problem (prob_dae_resrob) and the solver (IDA), accepting no additional arguments for the basic example. The input is a registered example problem, and the output is a solution object containing results from the Sundials IDA solver.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/dae_types.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nusing DiffEqProblemLibrary.DAEProblemLibrary, Sundials\nprob = DAEProblemLibrary.prob_dae_resrob\nsol = solve(prob, IDA())\n```\n\n----------------------------------------\n\nTITLE: Defining Affect Function for AutoAbstol Callback (Julia)\nDESCRIPTION: This Julia function defines the `affect!` behavior for the `AutoAbstolAffect` struct. It updates an internal maximum value (`p.curmax`) with the current state `integrator.u`, and then adjusts the integrator's absolute tolerance (`integrator.opts.abstol`) based on this maximum value and the relative tolerance (`integrator.opts.reltol`). It notifies the integrator that `u` was not modified directly.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_20\n\nLANGUAGE: julia\nCODE:\n```\n# Now make `affect!` for this:\nfunction (p::AutoAbstolAffect)(integrator)\n    p.curmax = max(p.curmax, integrator.u)\n    integrator.opts.abstol = p.curmax * integrator.opts.reltol\n    u_modified!(integrator, false)\nend\n```\n\n----------------------------------------\n\nTITLE: Defining and Solving the Cardiac ODE Problem with DifferentialEquations.jl and Sundials (Julia)\nDESCRIPTION: Instantiates the ODE problem and solves it using the CVODE_BDF solver (with GMRES linear solver for stiff systems) suitable for reaction-diffusion equations in cardiac models. Assumes the existence of a `BeelerReuterCpu` type and already-set initial condition u0. Dependencies: DifferentialEquations.jl, Sundials.jl. Inputs: ODE operator, initial condition, and time span. Outputs: a solution object (sol) for post-processing. Critical for applying high-performance numerical integration to simulate cardiac tissue dynamics.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/beeler_reuter.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations, Sundials\n\nderiv_cpu = BeelerReuterCpu(u0, 1.0);\nprob = ODEProblem(deriv_cpu, u0, (0.0, 50.0));\n```\n\nLANGUAGE: julia\nCODE:\n```\n@time sol = solve(prob, CVODE_BDF(linear_solver = :GMRES), saveat = 100.0);\n```\n\n----------------------------------------\n\nTITLE: Specifying Correlation Matrix for Heston Model Noise in Julia\nDESCRIPTION: Declares the correlation coefficient (Ï) and constructs the noise correlation matrix (Î) for two Wiener processes in the Heston SDE. This matrix is essential for simulating correlated noise. No external dependencies except that Ï is a real number. Inputs: none explicitly, as variables are assigned directly. Outputs: assignment of Ï and Î. Should precede construction of correlated noise processes.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/sde_example.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\nÏ = 0.2\nÎ = [1 Ï; Ï 1]\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for DDETST Problems\nDESCRIPTION: This Documenter.jl `@docs` block generates documentation for a comprehensive suite of DDE test problems (DDETST) from `DDEProblemLibrary`. These problems cover various delay types including time-dependent (A), vanishing time-dependent (B), state-dependent (C), vanishing state-dependent (D), neutral time-dependent (E), neutral vanishing time-dependent (F), neutral state-dependent (G), and neutral vanishing state-dependent (H).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/dde_types.md#_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\n```@docs\nprob_dde_DDETST_A1\nprob_dde_DDETST_A2\nprob_dde_DDETST_B1\nprob_dde_DDETST_B2\nprob_dde_DDETST_C1\nprob_dde_DDETST_C2\nprob_dde_DDETST_C3\nprob_dde_DDETST_C4\nprob_dde_DDETST_D1\nprob_dde_DDETST_D2\nprob_dde_DDETST_E1\nprob_dde_DDETST_E2\nprob_dde_DDETST_F1\nprob_dde_DDETST_F2\nprob_dde_DDETST_F3\nprob_dde_DDETST_F4\nprob_dde_DDETST_F5\nprob_dde_DDETST_G1\nprob_dde_DDETST_G2\nprob_dde_DDETST_H1\nprob_dde_DDETST_H2\nprob_dde_DDETST_H3\nprob_dde_DDETST_H4\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing the 5-Point Stencil Laplacian with Neumann Boundary Conditions in Julia\nDESCRIPTION: Defines the `laplacian` function which computes the discrete Laplacian of a 2D array `u` using a 5-point finite difference stencil. The result is stored in-place in the `Îu` array. The implementation explicitly handles Neumann boundary conditions (zero-flux) by adjusting the stencil calculation at the grid edges and corners. This function calculates the spatial diffusion term for the PDE.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/beeler_reuter.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n# 5-point stencil\nfunction laplacian(Îu, u)\n    n1, n2 = size(u)\n\n    # internal nodes\n    for j in 2:(n2 - 1)\n        for i in 2:(n1 - 1)\n            @inbounds Îu[i, j] = u[i + 1, j] + u[i - 1, j] + u[i, j + 1] + u[i, j - 1] -\n                                 4 * u[i, j]\n        end\n    end\n\n    # left/right edges\n    for i in 2:(n1 - 1)\n        @inbounds Îu[i, 1] = u[i + 1, 1] + u[i - 1, 1] + 2 * u[i, 2] - 4 * u[i, 1]\n        @inbounds Îu[i, n2] = u[i + 1, n2] + u[i - 1, n2] + 2 * u[i, n2 - 1] - 4 * u[i, n2]\n    end\n\n    # top/bottom edges\n    for j in 2:(n2 - 1)\n        @inbounds Îu[1, j] = u[1, j + 1] + u[1, j - 1] + 2 * u[2, j] - 4 * u[1, j]\n        @inbounds Îu[n1, j] = u[n1, j + 1] + u[n1, j - 1] + 2 * u[n1 - 1, j] - 4 * u[n1, j]\n    end\n\n    # corners\n    @inbounds Îu[1, 1] = 2 * (u[2, 1] + u[1, 2]) - 4 * u[1, 1]\n    @inbounds Îu[n1, 1] = 2 * (u[n1 - 1, 1] + u[n1, 2]) - 4 * u[n1, 1]\n    @inbounds Îu[1, n2] = 2 * (u[2, n2] + u[1, n2 - 1]) - 4 * u[1, n2]\n    @inbounds Îu[n1, n2] = 2 * (u[n1 - 1, n2] + u[n1, n2 - 1]) - 4 * u[n1, n2]\nend\n```\n\n----------------------------------------\n\nTITLE: Defining ILU Preconditioner Action Function for Sundials in Julia\nDESCRIPTION: This snippet defines the `precilu` function, which specifies the action of the preconditioner for Sundials. It takes the residual vector `r` and computes the preconditioned vector `z` by applying the inverse of the ILU preconditioner stored in `preccache` using `ldiv!`. This function works in conjunction with `psetupilu`. Requires `LinearAlgebra` (for `ldiv!`) and access to the `preccache` Ref.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/advanced_ode_example.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\nfunction precilu(z, r, p, t, y, fy, gamma, delta, lr)\n    ldiv!(z, preccache[], r)\nend\n```\n\n----------------------------------------\n\nTITLE: Custom Reduction with Convergence Test for Ensemble Simulations - DifferentialEquations.jl - Julia\nDESCRIPTION: Implements a reduction function accumulating simulation results over batches and tests convergence by comparing relative standard error to a threshold. Uses Statistics.jl (var, mean) and assumes batch results are appendable numeric vectors. Finishes ensemble runs early if (var(u)/sqrt(last(I)))/mean(u) < 0.5. Aims to save time by early stopping. Suitable for use as reduction callback in EnsembleProblem.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_28\n\nLANGUAGE: julia\nCODE:\n```\nusing Statistics\nfunction reduction(u, batch, I)\n    u = append!(u, batch)\n    finished = (var(u) / sqrt(last(I))) / mean(u) < 0.5\n    u, finished\nend\n```\n\n----------------------------------------\n\nTITLE: Plotting HÃ©non-Heiles Phase Space (KahanLi8 Symplectic Solution) in Julia\nDESCRIPTION: This snippet uses the `Plots` package in Julia to visualize the phase space of the HÃ©non-Heiles system from the symplectic `KahanLi8` solution (`sol2`). It plots position ('x', index 3) vs. velocity ('dx', index 1) and overlays position ('y', index 4) vs. velocity ('dy', index 2). Note the specific indices used due to the structure of `SecondOrderODEProblem` solutions.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/classical_physics.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\nplot(sol2, idxs = (3, 1), title = \"Phase space for the HÃ©non-Heiles system\",\n    xaxis = \"Position\", yaxis = \"Velocity\")\nplot!(sol2, idxs = (4, 2), leg = false)\n```\n\n----------------------------------------\n\nTITLE: Defining the Simple Pendulum ODE System in Julia\nDESCRIPTION: This snippet defines the first-order ODE system for a simple pendulum (`\\ddot{u} + (g/L)sin(u) = 0`) as required by the ODE solvers. It sets up constants `g` and `L`, the time span `tspan`, and the in-place function `simplependulum!` which calculates the derivatives `du` based on the current state `u`, parameters `p` (unused here), and time `t`. It depends on the `BoundaryValueDiffEq` and `Plots` packages.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/bvp_example.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nusing BoundaryValueDiffEq\nusing Plots\nconst g = 9.81\nL = 1.0\ntspan = (0.0, pi / 2)\nfunction simplependulum!(du, u, p, t)\n    Î¸ = u[1]\n    dÎ¸ = u[2]\n    du[1] = dÎ¸\n    du[2] = -(g / L) * sin(Î¸)\nend\n```\n\n----------------------------------------\n\nTITLE: Setting Plot Timespan in Plots.jl in Julia\nDESCRIPTION: This snippet demonstrates restricting a solution plot to a specific timespan using the tspan keyword argument in Plots.jl. Dependencies: Plots.jl. Inputs: solution object, tspan tuple specifying (start, end) times. Output: plot displays data only within the requested interval, with behavior depending on denseplot setting.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/plot.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nplot(sol, tspan = (0.0, 40.0))\n```\n\n----------------------------------------\n\nTITLE: Configuring and Creating the ODEProblem for LIF Simulation in Julia\nDESCRIPTION: Initializes the simulation parameters for the LIF model. Sets the initial membrane potential `u0`, the simulation time interval `tspan`, and defines the model parameters (`gL`, `EL`, `C`, `Vth`, `I`) using a `ComponentArray`. Constructs the `ODEProblem` named `prob` by providing the `lif` function, initial state `u0`, time span `tspan`, parameters `p`, and the previously defined callback set `cb`. Requires the `lif` function, the `cb` callback set, and the `ComponentArrays` and `DifferentialEquations` packages.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nu0 = -75\ntspan = (0.0, 40.0)\np = ComponentArray(gL = 5.0, EL = -75.0, C = 50.0, Vth = -55.0, I = 0)\n\nprob = ODEProblem(lif, u0, tspan, p, callback = cb)\n```\n\n----------------------------------------\n\nTITLE: Using Example Problems from DiffEqProblemLibrary in Julia\nDESCRIPTION: Demonstrates how to use the DiffEqProblemLibrary package in Julia. It involves adding the package, importing it, loading the standard set of ODE problems, accessing a specific problem (`prob_ode_linear`), and then solving it using a suitable solver (implicitly chosen by `solve`). Requires `DiffEqProblemLibrary` and a SciML solver package (like `OrdinaryDiffEq`) to be installed.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/ode_types.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\n```julia\n#] add DiffEqProblemLibrary\nusing DiffEqProblemLibrary.ODEProblemLibrary\n# load problems\nODEProblemLibrary.importodeproblems()\nprob = ODEProblemLibrary.prob_ode_linear\nsol = solve(prob)\n```\n```\n\n----------------------------------------\n\nTITLE: Solving Stiff State-Dependent ODEs using MagnusAdapt4 in Julia\nDESCRIPTION: This Julia code demonstrates solving a stiff non-autonomous linear ODE with a state-dependent operator using the MagnusAdapt4 method in DifferentialEquations.jl. The operator matrix is updated using the current state variable, including trigonometric manipulation. Dependencies are DifferentialEquations and SciMLOperators, and the update_func expresses intricate state influence. The sample covers construction of the mutable operator, ODE problem setup, and invocation of the MagnusAdapt4 solver.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/nonautonomous_linear_ode.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nfunction update_func(A, u, p, t)\n    A[1, 1] = 0\n    A[2, 1] = 1\n    A[1, 2] = -2 * (1 - cos(u[2]) - u[2] * sin(u[2]))\n    A[2, 2] = 0\nend\nA = SciMLOperators.MatrixOperator(ones(2, 2), update_func = update_func)\nprob = ODEProblem(A, ones(2), (30, 150.0))\nsol = solve(prob, MagnusAdapt4())\n```\n\n----------------------------------------\n\nTITLE: Configuring and Solving SDE Ensemble Problems with Fixed Steps - DifferentialEquations.jl - Julia\nDESCRIPTION: Constructs an ensemble of SDEProblem instances, solves each with the SRIW1() algorithm, using fixed step dt and disables adaptivity for synchronized outputs. Intended for comparative statistics at common timesteps across trajectories. Specifies number of trajectories and timestep explicitly. Useful for consistent time grids in downstream analysis.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_32\n\nLANGUAGE: julia\nCODE:\n```\nprob2 = EnsembleProblem(prob)\nsim = solve(prob2, SRIW1(), dt = 1 // 2^(3), trajectories = 10, adaptive = false)\n```\n\n----------------------------------------\n\nTITLE: Solving DDE with Undeclared Delays and Residual Control in Julia\nDESCRIPTION: Demonstrates solving a DDEProblem without explicitly declared lags, using MethodOfSteps(RK4()) for residual-based error control. Useful for problems with state-dependent or undeclared delays. p, u0, h, tspan assumed pre-defined. Outputs solution for postprocessing or visualization.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/dde_example.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nprob = DDEProblem(bc_model, u0, h, tspan)\nalg = MethodOfSteps(RK4())\nsol = solve(prob, alg)\n```\n\n----------------------------------------\n\nTITLE: Manually Interpolating and Plotting Differential Equation Solutions in Julia\nDESCRIPTION: This snippet illustrates how to manually generate a time vector and interpolate the solution at desired points, then plot projections or phase spaces using the sampled data. Dependencies: solution with interpolation support, Plots.jl. Inputs: chosen indices, number of timepoints. Output: plot using interpolated solution values. This is required if not using built-in plotting recipes with nonuniform or dense output.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/plot.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nn = 101 #number of timepoints\nts = range(0, stop = 1, length = n)\nplot(sol(ts, idxs = i), sol(ts, idxs = j), sol(ts, idxs = k))\n```\n\n----------------------------------------\n\nTITLE: Defining the State Structure for CPU Beeler-Reuter Simulation in Julia\nDESCRIPTION: Defines the `BeelerReuterCpu` mutable struct, which acts as a functor to hold the state variables and parameters for the CPU-based simulation. It contains fields for simulation time (`t`), diffusion coefficient (`diff_coef`), state variable arrays (`C`, `M`, `H`, `J`, `D`, `F`, `XI` as `Float32`), and a placeholder for the Laplacian (`Îu` as `Float64`). The constructor initializes these fields, setting default values and dimensions based on the initial condition array `u0`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/beeler_reuter.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nmutable struct BeelerReuterCpu\n    t::Float64              # the last timestep time to calculate Ît\n    diff_coef::Float64      # the diffusion-coefficient (coupling strength)\n\n    C::Array{Float32, 2}    # intracellular calcium concentration\n    M::Array{Float32, 2}    # sodium current activation gate (m)\n    H::Array{Float32, 2}    # sodium current inactivation gate (h)\n    J::Array{Float32, 2}    # sodium current slow inactivation gate (j)\n    D::Array{Float32, 2}    # calcium current activation gate (d)\n    F::Array{Float32, 2}    # calcium current inactivation gate (f)\n    XI::Array{Float32, 2}   # inward-rectifying potassium current (iK1)\n\n    Îu::Array{Float64, 2}   # place-holder for the Laplacian\n\n    function BeelerReuterCpu(u0, diff_coef)\n        self = new()\n\n        ny, nx = size(u0)\n        self.t = 0.0\n        self.diff_coef = diff_coef\n\n        self.C = fill(0.0001f0, (ny, nx))\n        self.M = fill(0.01f0, (ny, nx))\n        self.H = fill(0.988f0, (ny, nx))\n        self.J = fill(0.975f0, (ny, nx))\n        self.D = fill(0.003f0, (ny, nx))\n        self.F = fill(0.994f0, (ny, nx))\n        self.XI = fill(0.0001f0, (ny, nx))\n\n        self.Îu = zeros(ny, nx)\n\n        return self\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Plotting Double Pendulum Path in Cartesian Coordinates in Julia\nDESCRIPTION: This Julia snippet utilizes the `polar2cart` function (defined previously) and the solution (`sol`) of the double pendulum ODE system obtained from `OrdinaryDiffEq.jl` to generate a plot of the trajectory of the second bob in Cartesian coordinates using `Plots.jl`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/classical_physics.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\n#Obtain coordinates in Cartesian Geometry\nts, ps = polar2cart(sol, l1 = Lâ, l2 = Lâ, dt = 0.01)\nplot(ps...)\n```\n\n----------------------------------------\n\nTITLE: Derivative-Specific History Function Dispatch for DDEs in Julia\nDESCRIPTION: Shows how to extend the history function to supply derivative values for times before t0 using Julia type dispatch. When called as h(p, t, Val{1}), returns zeros(3), i.e., all derivatives zero. Useful when DDE definition depends on derivative history.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/dde_example.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nh(p, t, ::Type{Val{1}}) = zeros(3)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Choice Function for Algorithm Switching - Julia\nDESCRIPTION: Defines a function that selects an algorithm index for the StochasticCompositeAlgorithm based on the current integrator's timestep. The choice function enables dynamic selection between multiple solvers (such as EM and RKMil) during SDE integration to balance trade-offs between accuracy and performance. The integrator object is provided by the solver interface, and properties like dt must be accessible. Returns an integer index for the algorithm tuple.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/sde_solve.md#_snippet_5\n\nLANGUAGE: Julia\nCODE:\n```\nchoice_function(integrator) = (Int(integrator.dt < 0.001) + 1)\n```\n\n----------------------------------------\n\nTITLE: Sampling Solution at Specific Times with TimeChoiceIterator in SciMLBase (Julia)\nDESCRIPTION: Constructs an array of desired sample times and iterates over the integrator so that (u, t) are returned at those specified time points. The TimeChoiceIterator accommodates non-uniform or exact desired output grids. Useful when one needs values at strict time intervals regardless of adaptive stepping.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/integrator.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nts = range(0, stop = 1, length = 11)\nfor (u, t) in TimeChoiceIterator(integrator, ts)\n    @show u, t\nend\n```\n\n----------------------------------------\n\nTITLE: Creating Continuous Callback for Bouncing Ball (Julia)\nDESCRIPTION: This snippet creates a `ContinuousCallback` instance using the `condition` (detects ground collision) and `affect!` (reverses velocity) functions defined previously. This callback will be used with an ODE solver to simulate the bouncing ball.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_28\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\ncb = ContinuousCallback(condition, affect!)\n```\n\n----------------------------------------\n\nTITLE: Plotting Recovery Variable of Izhikevich Model Simulation in Julia\nDESCRIPTION: Visualizes the second dimension (recovery variable, u[2]) from the ODE solution of the Izhikevich model. This shows spike-induced hyperpolarization over time using Plots.jl. Requires 'sol' as a solution object from DifferentialEquations.jl's solve function.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nplot(sol, vars = 2)\n```\n\n----------------------------------------\n\nTITLE: Solving the LIF Model ODE Problem in Julia\nDESCRIPTION: Executes the simulation of the Leaky Integrate-and-Fire model by calling the `solve` function from DifferentialEquations.jl on the configured `ODEProblem` (`prob`). The result, containing the time steps, corresponding voltage values, and solver status, is stored in the `sol` variable. Depends on the `DifferentialEquations` package and a previously defined `ODEProblem` object (`prob`).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nsol = solve(prob)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Parameter Sensitivity in ODE Stability\nDESCRIPTION: Demonstrates a simple linear ODE (`u'=a*u`) where the stability of the solution depends critically on the sign of the parameter 'a'. If 'a' is negative, the solution decays to zero; if positive, it diverges to infinity. This highlights the importance of correct parameter specification.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nu'=a*u\n```\n\n----------------------------------------\n\nTITLE: Generating and Plotting PoincarÃ© Section for Double Pendulum in Julia\nDESCRIPTION: This Julia snippet generates and displays a PoincarÃ© section for the double pendulum using `Plots.jl` and the setup from the previous step. It initializes a scatter plot with points from an initial trajectory (`sol2`) and then iterates through various initial conditions, using the `poincare_map` function to compute and add corresponding points (Î², lÎ² when Î±=0) to the section, visualizing the system's dynamics.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/classical_physics.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nlÎ²range = -0.02:0.0025:0.02\np = scatter(sol2, idxs = (3, 4), leg = false, markersize = 3, msw = 0)\nfor lÎ² in lÎ²range\n    poincare_map(poincare, [0.01, 0.01, 0.01, lÎ²], p)\nend\nplot(p, xlabel = \"\\\\beta\", ylabel = \"l_\\\\beta\", ylims = (0, 0.03))\n```\n\n----------------------------------------\n\nTITLE: Calculating Mean Correlation at Specific Timepoints in SDE Ensembles in Julia\nDESCRIPTION: This snippet uses the timepoint_meancor utility to compute and report both the means and the correlation coefficient between ensemble values at two specified timepoints. Useful for analyzing correlations over the SDE evolution. Assumes sol is an ensemble solution object.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/sde_example.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\ntimepoint_meancor(sol, 0.2, 0.7) # Gives both means and then the correlation coefficient\n```\n\n----------------------------------------\n\nTITLE: Iterating Integration Steps with take and for in SciMLBase (Julia)\nDESCRIPTION: Loops over a limited number of step iterations using the take iterator, which yields the integrator object n times. Allows fine control over the number of integration advancements and is useful for interactive applications.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/integrator.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nfor i in take(integrator, n)\nend\n```\n\n----------------------------------------\n\nTITLE: Benchmarking CVODE_BDF for Extended Integration Periods (Sundials.jl, Julia)\nDESCRIPTION: This example benchmarks CVODE_BDF with GMRES on a significantly longer integration interval (0.0 to 500.0), again with save_everystep set to false to avoid memory exhaustion. The snippet is designed to evaluate the scalability and sustained performance of stiff problem solvers for very large ODE simulations in Julia. Dependencies: Sundials.jl, BenchmarkTools.jl, DifferentialEquations.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_34\n\nLANGUAGE: julia\nCODE:\n```\nprob = ODEProblem(fast_gm!, r0, (0.0, 500.0), p)\n@btime solve(prob, CVODE_BDF(linear_solver = :GMRES), save_everystep = false);\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Defining an IMEX (Implicit-Explicit) ODE Split - Math\nDESCRIPTION: This LaTeX snippet presents the mathematical form of an IMEX (Implicit-Explicit) ODE for use with a SplitODEProblem, clearly separating the stiff (implicit) and nonstiff (explicit) terms. It defines the general structure on which solver methods operate. No technical dependencies. The parameters u, t, f_1, and f_2 determine the nature of the stiffness and explicitness involved. No computational outputâthis snippet is for mathematical reference only.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/split_ode_solve.md#_snippet_0\n\nLANGUAGE: math\nCODE:\n```\n\\frac{du}{dt} =  f_1(t,u) + f_2(t,u)\n```\n\n----------------------------------------\n\nTITLE: Viewing Step Intervals with intervals Iterator in SciMLBase (Julia)\nDESCRIPTION: Uses the intervals iterator to examine the full step intervals. In each loop iteration, yields (uprev, tprev, u, t), which are the previous and current values/states and times. Facilitates detailed inspection of each subinterval traversed by the integrator.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/integrator.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\nfor (uprev, tprev, u, t) in intervals(integrator)\n    @show tprev, t\nend\n```\n\n----------------------------------------\n\nTITLE: SDE System with Sparse Matrix-Valued Diffusion Term in Julia\nDESCRIPTION: This advanced example shows how to configure an SDEProblem for a system with matrix-valued diffusion, where the diffusion is sparse. It builds a sparse matrix, defines the in-place diffusion function with nonzero structure, and sets noise_rate_prototype accordingly. Used for SDEs with large or structured noise interaction. Dependencies: DifferentialEquations.jl and SparseArrays.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/sde_example.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\n# Define a sparse matrix by making a dense matrix and setting some values as not zero\nusing SparseArrays\nA = zeros(2, 4)\nA[1, 1] = 1\nA[1, 4] = 1\nA[2, 4] = 1\nA = sparse(A)\n\n# Make `g` write the sparse matrix values\nfunction g(du, u, p, t)\n    du[1, 1] = 0.3u[1]\n    du[1, 4] = 0.12u[2]\n    du[2, 4] = 1.8u[2]\nend\n\n# Make `g` use the sparse matrix\nprob = SDEProblem(f, g, ones(2), (0.0, 1.0), noise_rate_prototype = A)\n```\n\n----------------------------------------\n\nTITLE: Initializing StochasticCompositeAlgorithm with Switch Function - Julia\nDESCRIPTION: Creates a StochasticCompositeAlgorithm instance, configuring it to switch between EM and RKMil methods using a provided choice function based on integrator state. Dependencies include StochasticDiffEq.jl, and algorithms EM and RKMil must be available. This enables multi-method adaptive SDE solving. Required parameters are a tuple of algorithms and a choice function. The resulting object is used for solving SDE problems with dynamic method selection.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/sde_solve.md#_snippet_6\n\nLANGUAGE: Julia\nCODE:\n```\nalg_switch = StochasticCompositeAlgorithm((EM(), RKMil()), choice_function)\n```\n\n----------------------------------------\n\nTITLE: Benchmarking CVODE_BDF with GMRES and Disabled save_everystep (Sundials.jl, Julia)\nDESCRIPTION: This snippet profiles the performance of Sundials.jl's CVODE_BDF solver configured with the GMRES sparse linear solver for a stiff ODE problem, disabling save_everystep to curb memory usage. Suitable for large-scale or long-time simulations, this test assesses how effective implicit solvers with sparse Jacobian support can be for managing computational and memory resources. Dependencies: Sundials.jl, BenchmarkTools.jl, DifferentialEquations.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_33\n\nLANGUAGE: julia\nCODE:\n```\n@btime solve(prob, CVODE_BDF(linear_solver = :GMRES), save_everystep = false);\nnothing # hide\n```\n\n----------------------------------------\n\nTITLE: Solving an ODE Problem with Tsit5 Solver in Julia\nDESCRIPTION: Illustrates the standard syntax in DifferentialEquations.jl for solving an ODE problem represented by `prob` using the `Tsit5` explicit Runge-Kutta solver.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\nsolve(prob,Tsit5())\n```\n\n----------------------------------------\n\nTITLE: Listing Solvers Available via ODEInterfaceDiffEq.jl Wrapper\nDESCRIPTION: Lists classic Fortran ODE solvers like `dorpi5`, `dop853`, `radau`, and `rodas`, which can be accessed in Julia through the `ODEInterfaceDiffEq.jl` wrapper package. These are well-established and robust numerical methods.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\ndorpi5, dop853, radau, rodas\n```\n\n----------------------------------------\n\nTITLE: Deleting Element from Integrator State in Julia\nDESCRIPTION: Shows the syntax for removing an element (e.g., the second cell) from the integrator's state vector and associated caches during an ODE solve using `deleteat!(integrator, index)`. This allows modeling cell death or removal.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_49\n\nLANGUAGE: julia\nCODE:\n```\ndeleteat!(integrator, 2)\n```\n\n----------------------------------------\n\nTITLE: Modeling Tsodyks-Markram Synapse and Event-Driven State Updates in Julia\nDESCRIPTION: Defines an advanced HH neuron model augmented with Tsodyks-Markram synapse dynamics (short-term facilitation/depression). The system of ODEs includes new fast synaptic variables (u, R, gsyn) and an event callback 'epsp!' that implements discontinuous synaptic updates at specified times. ODEProblem is configured with the callback, and the resulting solution is plotted. Dependencies include DifferentialEquations.jl, callback support, and initial/default variable definitions.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_18\n\nLANGUAGE: julia\nCODE:\n```\nfunction HH!(du, u, p, t)\n    gK, gNa, gL, EK, ENa, EL, C, I, tau, tau_u, tau_R, u0, gmax, Esyn = p\n    v, n, m, h, u, R, gsyn = u\n\n    du[1] = ((gK * (n^4.0) * (EK - v)) + (gNa * (m^3.0) * h * (ENa - v)) + (gL * (EL - v)) +\n             I + gsyn * (Esyn - v)) / C\n    du[2] = (alpha_n(v) * (1.0 - n)) - (beta_n(v) * n)\n    du[3] = (alpha_m(v) * (1.0 - m)) - (beta_m(v) * m)\n    du[4] = (alpha_h(v) * (1.0 - h)) - (beta_h(v) * h)\n\n    # Synaptic variables\n    du[5] = -(u / tau_u)\n    du[6] = (1 - R) / tau_R\n    du[7] = -(gsyn / tau)\nend\n\nfunction epsp!(integrator)\n    integrator.u[5] += integrator.p[12] * (1 - integrator.u[5])\n    integrator.u[7] += integrator.p[13] * integrator.u[5] * integrator.u[6]\n    integrator.u[6] -= integrator.u[5] * integrator.u[6]\nend\n\nepsp_ts = PresetTimeCallback(100:100:500, epsp!)\n\np = [35.0, 40.0, 0.3, -77.0, 55.0, -65.0, 1, 0, 30, 1000, 50, 0.5, 0.005, 0]\nu0 = [-60, n_inf(-60), m_inf(-60), h_inf(-60), 0.0, 1.0, 0.0]\ntspan = (0.0, 700)\nprob = ODEProblem(HH!, u0, tspan, p, callback = epsp_ts)\nsol = solve(prob);\nplot(sol, vars = 1)\n```\n\n----------------------------------------\n\nTITLE: Bulk Update of Gating and Calcium Variables Over a 2D Grid (Julia)\nDESCRIPTION: Implements the `update_gates_cpu` function to update all gating (XI, M, H, J, D, F) and intracellular calcium (C) variables for every cell in a 2D grid. Utilizes the previously defined update functions for each variable. Takes in the current states as 2D arrays and applies updates across both axes. Inputs: 2D arrays u, XI, M, H, J, D, F, C, and time step Ît. Outputs: updated states in place. Handles explicit time-stepping for spatially-dependent ODE models and supports efficient interfacing with IMEX ODE solvers.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/beeler_reuter.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nfunction update_gates_cpu(u, XI, M, H, J, D, F, C, Ît)\n    let Ît = Float32(Ît)\n        n1, n2 = size(u)\n        for j in 1:n2\n            for i in 1:n1\n                v = Float32(u[i, j])\n\n                XI[i, j] = update_XI_cpu(XI[i, j], v, Ît)\n                M[i, j] = update_M_cpu(M[i, j], v, Ît)\n                H[i, j] = update_H_cpu(H[i, j], v, Ît)\n                J[i, j] = update_J_cpu(J[i, j], v, Ît)\n                D[i, j] = update_D_cpu(D[i, j], v, Ît)\n                F[i, j] = update_F_cpu(F[i, j], v, Ît)\n\n                C[i, j] = update_C_cpu(C[i, j], D[i, j], F[i, j], v, Ît)\n            end\n        end\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Using Example BVPs from DiffEqProblemLibrary with SciML Ecosystem (Julia)\nDESCRIPTION: This Julia snippet demonstrates how to add the DiffEqProblemLibrary package, import its BVProblemLibrary submodule alongside BoundaryValueDiffEq, retrieve a sample linear boundary value problem (BVP), and solve it using a specific solver (MIRK4) with a fixed step size. Dependencies include DiffEqProblemLibrary and BoundaryValueDiffEq. The main parameter, dt, sets the time step for the solver, and the main inputs are the selected problem instance and solver method; the output is a computed solution object. This usage pattern highlights typical problem retrieval and solution workflows in the SciML differential equations ecosystem.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/bvp_types.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n#] add DiffEqProblemLibrary\nusing DiffEqProblemLibrary.BVProblemLibrary, BoundaryValueDiffEq\n# load problems\nprob = BVProblemLibrary.prob_bvp_linear_1\nsol = solve(prob, MIRK4(), dt = 0.05)\n```\n\n----------------------------------------\n\nTITLE: Error Estimation and Norm Definitions - Math\nDESCRIPTION: Provides mathematical equations for scaling error per component and defining the standard Hairer norm used in adaptive timestepping. No code execution, just documentation standards to inform algorithm design; these forms are mathematically precise inputs and not evaluated programmatically. The variables represent per-component error, tolerances, and solution vectors.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/extras/timestepping.md#_snippet_1\n\nLANGUAGE: math\nCODE:\n```\n```math\nerr^{scaled}_i = norm(err_i/(abstol_i + max(uprev_i,u_i)reltol_i))\n```\n```\n\nLANGUAGE: math\nCODE:\n```\n```math\nnorm(x) = sqrt(sum(x^2)/length(x))\n```\n```\n\n----------------------------------------\n\nTITLE: Illustrating Initial Condition Sensitivity in ODE Behavior\nDESCRIPTION: Provides an example ODE, `u' = u^2 - 100u`, whose solution either goes to zero or diverges to infinity depending on whether the initial condition `u(0)` is below or above a certain threshold (10 in this case). This highlights the importance of initial conditions in determining qualitative solution behavior.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\nu' = u^2 - 100u\n```\n\n----------------------------------------\n\nTITLE: Overloading Custom Controller Callback Functions - Julia\nDESCRIPTION: Demonstrates how to implement custom step-size control logic by overloading stepsize_controller!, step_accept_controller!, and step_reject_controller! for a user-defined controller. Each function manipulates the integrator in conjunction with the custom controller structure. Functions are stubs; user is expected to fill with logic as appropriate for the controller's purpose.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/extras/timestepping.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nfunction stepsize_controller!(integrator, controller::CustomController, alg)\n    ...\n    nothing\nend\nfunction step_accept_controller!(integrator, controller::CustomController, alg)\n    ...\n    nothing\nend\nfunction step_reject_controller!(integrator, controller::CustomController, alg)\n    ...\n    nothing\nend\n```\n```\n\n----------------------------------------\n\nTITLE: Installing and Using BridgeDiffEq.jl - Julia\nDESCRIPTION: Shows how to install BridgeDiffEq.jl via Pkg.clone() with a direct GitHub URL and import the package for use with out-of-place SDE integrators. Necessary dependencies are: access to Pkg, internet for the clone, and a compatible Julia environment. After execution, the user can access BridgeEuler, BridgeHeun, and BridgeSRK methods.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/sde_solve.md#_snippet_8\n\nLANGUAGE: Julia\nCODE:\n```\nPkg.clone(\"https://github.com/SciML/BridgeDiffEq.jl\")\nusing BridgeDiffEq\n```\n\n----------------------------------------\n\nTITLE: Plotting Kepler Solution and First Integrals (Symplectic) in Julia\nDESCRIPTION: Generates plots for the Kepler problem solution obtained using the `KahanLi6` symplectic integrator. It calls the previously defined `analysis_plot` function, passing the solution object (`sol`) and the Hamiltonian (`H`) and Angular Momentum (`L`) functions to visualize the orbit and the conservation of first integrals. Requires `Plots` and the results from the previous snippets.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/kepler_problem.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nanalysis_plot(sol, H, L)\n```\n\n----------------------------------------\n\nTITLE: Loading and Solving Example SDE Problems Using DiffEqProblemLibrary in Julia\nDESCRIPTION: This code snippet illustrates how to load sample stochastic differential equation problems from DiffEqProblemLibrary.SDEProblemLibrary, instantiate an example (prob_sde_linear), and solve it using the solve function. Prerequisites include adding DiffEqProblemLibrary with the Julia package manager, and using relevant modules. This example demonstrates workflow setup for experimenting with prebuilt SDE problems. Inputs include an example problem, and the output is a solution object; custom solvers or arguments may be supplied as needed.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/sde_types.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n```julia\n#] add DiffEqProblemLibrary\nusing DiffEqProblemLibrary.SDEProblemLibrary\n# load problems\nSDEProblemLibrary.importsdeproblems()\nprob = SDEProblemLibrary.prob_sde_linear\nsol = solve(prob)\n```\n```\n\n----------------------------------------\n\nTITLE: Initializing Function Map Algorithm in OrdinaryDiffEq.jl (Julia)\nDESCRIPTION: These constructors initialize a FunctionMap object, the main algorithm for solving discrete function maps in OrdinaryDiffEq.jl. The parameter scale_by_time controls whether each step adds the output of a function f multiplied by the timestep dt (like Euler's method) or just applies the function directly. Inputs are no arguments or optionally a type parameter. These are required when passing to the solve function for discrete problems. OrdinaryDiffEq.jl must be available in the environment.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/discrete_solve.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nFunctionMap()\nFunctionMap{scale_by_time}()\n```\n\n----------------------------------------\n\nTITLE: Solving and Plotting Subthreshold Alpha Synapse Response in Julia\nDESCRIPTION: Runs a simulation of the HH model with an alpha synapse using preset parameters. It solves the ODE and plots the first state variable, typically the membrane voltage. Dependencies are ODEProblem and solve from DifferentialEquations.jl, and u0 (initial state) must be defined. This example demonstrates the EPSP produced by a subthreshold synaptic event.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\np = [35.0, 40.0, 0.3, -77.0, 55.0, -65.0, 1, 0, 0.008, 0, 20, 100]\ntspan = (0.0, 200)\nprob = ODEProblem(HH!, u0, tspan, p)\nsol = solve(prob);\nplot(sol, vars = 1)\n```\n\n----------------------------------------\n\nTITLE: Solving an Ensemble ODE with Reduced Dependencies in Julia\nDESCRIPTION: Replicates the FitzHugh-Nagumo ensemble problem solution from a previous example, but instead of using the full `DifferentialEquations.jl`, it imports only the necessary direct dependencies: `OrdinaryDiffEq.jl` (for the `ODEProblem`, `EnsembleProblem`, `solve`, and `Euler` method) and `DiffEqCallbacks.jl` (for `ProbIntsUncertainty`). This demonstrates dependency reduction.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/low_dep.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nusing OrdinaryDiffEq, DiffEqCallbacks\nfunction fitz(du, u, p, t)\n    V, R = u\n    a, b, c = p\n    du[1] = c * (V - V^3 / 3 + R)\n    du[2] = -(1 / c) * (V - a - b * R)\nend\nu0 = [-1.0; 1.0]\ntspan = (0.0, 20.0)\np = (0.2, 0.2, 3.0)\nprob = ODEProblem(fitz, u0, tspan, p)\ncb = ProbIntsUncertainty(0.2, 1)\nensemble_prob = EnsembleProblem(prob)\nsim = solve(ensemble_prob, Euler(), trajectories = 100, callback = cb, dt = 1 / 10)\n```\n\n----------------------------------------\n\nTITLE: Plotting the HÃ©non-Heiles Orbit (Vern9 Solution) in Julia\nDESCRIPTION: This snippet uses the `Plots` package in Julia to visualize the orbit (position space trajectory) of the HÃ©non-Heiles system. It plots the 'x' coordinate (index 1) against the 'y' coordinate (index 2) from the solution object `sol` obtained using the `Vern9` solver.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/classical_physics.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\n# Plot the orbit\nplot(sol, idxs = (1, 2), title = \"The orbit of the HÃ©non-Heiles system\", xaxis = \"x\",\n    yaxis = \"y\", leg = false)\n```\n\n----------------------------------------\n\nTITLE: Plotting the HÃ©non-Heiles Orbit (KahanLi8 Symplectic Solution) in Julia\nDESCRIPTION: This snippet uses the `Plots` package in Julia to visualize the orbit (position space trajectory) of the HÃ©non-Heiles system obtained from the symplectic `KahanLi8` solver. It plots the 'x' coordinate (index 3 in `sol2.u`) against the 'y' coordinate (index 4 in `sol2.u`). The indices differ from the first-order solution because `SecondOrderODEProblem` solutions store state as `[velocity..., position...]`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/classical_physics.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\n# Plot the orbit\nplot(sol2, idxs = (3, 4), title = \"The orbit of the HÃ©non-Heiles system\", xaxis = \"x\",\n    yaxis = \"y\", leg = false)\n```\n\n----------------------------------------\n\nTITLE: Calculating Boundary Source Terms for Discretized Heat Equation in Julia\nDESCRIPTION: Computes the source terms that arise from incorporating the boundary conditions into the finite difference scheme. `AT_b[1]` accounts for the Neumann boundary condition at the bottom (`z=a`), and `AT_b[end - 1]` accounts for the Dirichlet boundary condition source term affecting the penultimate cell face. The last element `AT_b[end]` remains zero as `T` is fixed at the boundary. Depends on parameters `FT`, `n`, `\\u03b1`, `\\u0394z`, `\\u2207T_bottom`, `n\\u0302_min`, `T_top`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/diffusion_implicit_heat_equation.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nAT_b = zeros(FT, n + 1);\nAT_b[1] = \\u03b1 * 2 / \\u0394z * \\u2207T_bottom * n\\u0302_min;\nAT_b[end - 1] = \\u03b1 * T_top / \\u0394z\\u00b2;\n```\n\n----------------------------------------\n\nTITLE: Defining a GPU-Resident Cardiac Cell Model Struct with CUDA.jl in Julia\nDESCRIPTION: This snippet defines the mutable struct BeelerReuterGpu, intended to encapsulate the state variables of a cardiac cell model in GPU memory using CuArray from CUDA.jl. The constructor asserts that the input array dimensions are multiples of 16, initializes various gating and ion concentration variables on the GPU with default values, and creates placeholders both on the GPU (for computation) and CPU (for temporary results). Key dependencies include CUDA.jl, and all variables to be computed with CUDA kernels are suffixed with d_ to denote GPU-residency. The struct facilitates explicit separation of GPU and CPU memory, a necessary prerequisite for efficient GPU computation workflows.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/beeler_reuter.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nusing CUDA\n\nmutable struct BeelerReuterGpu <: Function\n    t::Float64                  # the last timestep time to calculate Ît\n    diff_coef::Float64          # the diffusion-coefficient (coupling strength)\n\n    d_C::CuArray{Float32, 2}    # intracellular calcium concentration\n    d_M::CuArray{Float32, 2}    # sodium current activation gate (m)\n    d_H::CuArray{Float32, 2}    # sodium current inactivation gate (h)\n    d_J::CuArray{Float32, 2}    # sodium current slow inactivation gate (j)\n    d_D::CuArray{Float32, 2}    # calcium current activation gate (d)\n    d_F::CuArray{Float32, 2}    # calcium current inactivation gate (f)\n    d_XI::CuArray{Float32, 2}   # inward-rectifying potassium current (iK1)\n\n    d_u::CuArray{Float64, 2}    # place-holder for u in the device memory\n    d_du::CuArray{Float64, 2}   # place-holder for d_u in the device memory\n\n    Îv::Array{Float64, 2}       # place-holder for voltage gradient\n\n    function BeelerReuterGpu(u0, diff_coef)\n        self = new()\n\n        ny, nx = size(u0)\n        @assert (nx % 16 == 0) && (ny % 16 == 0)\n        self.t = 0.0\n        self.diff_coef = diff_coef\n\n        self.d_C = CuArray(fill(0.0001f0, (ny, nx)))\n        self.d_M = CuArray(fill(0.01f0, (ny, nx)))\n        self.d_H = CuArray(fill(0.988f0, (ny, nx)))\n        self.d_J = CuArray(fill(0.975f0, (ny, nx)))\n        self.d_D = CuArray(fill(0.003f0, (ny, nx)))\n        self.d_F = CuArray(fill(0.994f0, (ny, nx)))\n        self.d_XI = CuArray(fill(0.0001f0, (ny, nx)))\n\n        self.d_u = CuArray(u0)\n        self.d_du = CuArray(zeros(ny, nx))\n\n        self.Îv = zeros(ny, nx)\n\n        return self\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Out-of-Place Constant History Function for DDEs using Julia\nDESCRIPTION: Defines a simple constant history function h used in DDEProblem, returning a vector of ones for any parameter/time. No dependencies required. Used to set the solution history before t0 to [1.0, 1.0, 1.0]. Input: (p, t); Output: 3-element vector of ones.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/dde_example.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nh(p, t) = ones(3)\n```\n\n----------------------------------------\n\nTITLE: Viewing Generated Symbolic Jacobian - Julia\nDESCRIPTION: Calls ModelingToolkit's `generate_jacobian` function to compute and display the in-place symbolic Jacobian from a symbolic ODE definition. The second output tuple from `generate_jacobian` is printed, which provides the function as required by DifferentialEquations.jl. The input is a symbolic ODE (`de`), and the output is the generated Jacobian function code. ModelingToolkit.jl is required.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/faster_ode_example.md#_snippet_17\n\nLANGUAGE: julia\nCODE:\n```\nModelingToolkit.generate_jacobian(de)[2] # Second is in-place\n```\n\n----------------------------------------\n\nTITLE: Rosenbrock Solvers for Parabolic PDEs (Rodas4/4P) in Julia\nDESCRIPTION: Compares `Rodas4` and `Rodas4P`. `Rodas4` can lose accuracy on discretizations of nonlinear parabolic PDEs. `Rodas4P`, which is 3rd order, is recommended instead in these situations.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_22\n\nLANGUAGE: julia\nCODE:\n```\nRodas4\n```\n\nLANGUAGE: julia\nCODE:\n```\nRodas4P\n```\n\n----------------------------------------\n\nTITLE: Plotting Synaptic Conductance Time Course for Tsodyks-Markram Synapse in Julia\nDESCRIPTION: Plots the seventh variable (typically the gsyn value) of the last ODE solution, visualizing synaptic conductance dynamics. This follows the solution generated in the previous snippet and requires the variable 'sol' to exist. Outputs the conductance trajectory over time.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/spiking_neural_systems.md#_snippet_19\n\nLANGUAGE: julia\nCODE:\n```\nplot(sol, vars = 7)\n```\n\n----------------------------------------\n\nTITLE: Solving Kepler Problem with Adaptive RKN Solver (ERKN4) in Julia\nDESCRIPTION: Solves the Kepler `DynamicalODEProblem` using the `ERKN4` adaptive Runge-Kutta-NystrÃ¶m integrator, which is optimized for sinusoid-like periodic problems. It prints the number of steps taken using `@show sol3.u |> length` and then calls `analysis_plot` to visualize the results. The surrounding text notes this solver is less suitable for the Kepler problem compared to others shown. Requires `OrdinaryDiffEq`, `Plots`, and the problem definition (`prob`, `H`, `L`).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/kepler_problem.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nsol3 = solve(prob, ERKN4()) # dt is not necessary, because unlike symplectic\n# integrators ERKN4 is adaptive\n@show sol3.u |> length\nanalysis_plot(sol3, H, L)\n```\n\n----------------------------------------\n\nTITLE: Implementing Rush-Larsen Integration for Cardiac Gating Variables (Julia)\nDESCRIPTION: Defines a helper function, `rush_larsen`, to perform explicit exponential integration of gating variables per the Rush-Larsen method. The function computes the steady-state value (`inf`) and time constant (`Ï`) for the gating variable using provided reaction rates (Î±, Î²), and integrates across a timestep Ît. Dependencies: requires `expm1`, `clamp`, and expects inputs as Float32 for stability. Input parameters: g (current gating variable), Î±, Î² (reaction rates), Ît (time step). Output is the updated value of the gating variable, clamped between 0 and 1. Suited for use in cardiac cell models where gating variable update speed and stability are critical.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/beeler_reuter.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\n@inline function rush_larsen(g, Î±, Î², Ît)\n    inf = Î± / (Î± + Î²)\n    Ï = 1.0f0 / (Î± + Î²)\n    return clamp(g + (g - inf) * expm1(-Ît / Ï), 0.0f0, 1.0f0)\nend\n```\n\n----------------------------------------\n\nTITLE: Installing and Using DASKR.jl Package in Julia\nDESCRIPTION: Shows the necessary steps to install and use the DASKR.jl package in Julia. This enables access to the `daskr` solver, which is a wrapper for the well-known DASKR algorithm, for solving DAEs.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/dae_solve.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nusing Pkg\nPkg.add(\"DASKR\")\nusing DASKR\n```\n\n----------------------------------------\n\nTITLE: Disabling Autodifferentiation in Rosenbrock23 Solver - OrdinaryDiffEq.jl - Julia\nDESCRIPTION: Shows how to solve an ODEProblem with the Rosenbrock23 solver while disabling autodifferentiation (for compatibility reasons) by setting autodiff=false. This triggers a numerical fallback for Jacobian computation. Requires OrdinaryDiffEq.jl and a compatible ODE function f.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_32\n\nLANGUAGE: julia\nCODE:\n```\nprob = ODEProblem(f, ones(5, 5), (0.0, 1.0))\nsol = solve(prob, Rosenbrock23(autodiff = false))\n```\n\n----------------------------------------\n\nTITLE: Specifying Lag Parameter Vectors for DDEs in Julia\nDESCRIPTION: Assigns constant lag values for use with DDEProblem. Sets tau=1 and creates a lags vector containing tau. Inputs are numerical constants; outputs are their storage in variables for DDE definition. No dependencies.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/dde_example.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\ntau = 1\nlags = [tau]\n```\n\n----------------------------------------\n\nTITLE: Installing Numba for Accelerated Python Computations - Bash\nDESCRIPTION: This shell snippet installs the Numba package via pip, a Python library for JIT-compiling functions to increase the performance of user-defined derivative functions in differential equation solvers. Requires a Python environment with pip installed. Output: Numba installed for use.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/index.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npip install numba\n```\n\n----------------------------------------\n\nTITLE: Gustafsson Step Rejection Logic - Julia\nDESCRIPTION: Implements step rejection rules for Gustafsson-accelerated controllers. Reduces time step sharply on zero success iteration, else falls back to the previous qold. Relies on the current integrator data structure for control.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/extras/timestepping.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nif integrator.success_iter == 0\n    integrator.dt *= 0.1\nelse\n    integrator.dt = integrator.dt / integrator.qold\nend\n```\n```\n\n----------------------------------------\n\nTITLE: Updating Gates in a GPU Kernel using CUDA and Julia\nDESCRIPTION: This function implements a CUDA kernel in Julia to update neural or reaction gates for each element in a 2D array (medium) based on specified CUDA-style block and thread indices. It calls device functions to update various state matrices (XI, M, H, J, D, F, C) based on the current potential and time increment. This function must be called as a CUDA kernel with suitable grid and block configuration, expects arrays to reside in device memory, and returns nothing as required by CUDA. Dependencies include CuArrays, CUDA.jl, and device-specific update routines (update_XI_gpu, update_M_gpu, etc.). Inputs are 2D arrays of state and parameters, output is in-place update of passed arrays.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/beeler_reuter.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\nfunction update_gates_gpu(u, XI, M, H, J, D, F, C, Ît)\n    i = (blockIdx().x - UInt32(1)) * blockDim().x + threadIdx().x\n    j = (blockIdx().y - UInt32(1)) * blockDim().y + threadIdx().y\n\n    v = Float32(u[i, j])\n\n    let Ît = Float32(Ît)\n        XI[i, j] = update_XI_gpu(XI[i, j], v, Ît)\n        M[i, j] = update_M_gpu(M[i, j], v, Ît)\n        H[i, j] = update_H_gpu(H[i, j], v, Ît)\n        J[i, j] = update_J_gpu(J[i, j], v, Ît)\n        D[i, j] = update_D_gpu(D[i, j], v, Ît)\n        F[i, j] = update_F_gpu(F[i, j], v, Ît)\n\n        C[i, j] = update_C_gpu(C[i, j], D[i, j], F[i, j], v, Ît)\n    end\n    nothing\nend\n```\n\n----------------------------------------\n\nTITLE: Setting up PoincarÃ© Section Calculation for Double Pendulum in Julia\nDESCRIPTION: This Julia code prepares for generating a PoincarÃ© section for the double pendulum using `OrdinaryDiffEq.jl`. It defines the system using a Hamiltonian formulation (`double_pendulum_hamiltonian`), sets up a `ContinuousCallback` to detect zero-crossings of the first angle (Î±), and configures the solver (`Vern9`) to save only at these events with high precision. A helper function `poincare_map` is also defined to facilitate plotting points on the section for varying initial conditions.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/classical_physics.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\n#Constants and setup\nusing OrdinaryDiffEq\ninitial2 = [0.01, 0.005, 0.01, 0.01]\ntspan2 = (0.0, 500.0)\n\n#Define the problem\nfunction double_pendulum_hamiltonian(udot, u, p, t)\n    Î± = u[1]\n    lÎ± = u[2]\n    Î² = u[3]\n    lÎ² = u[4]\n    udot .= [2(lÎ± - (1 + cos(Î²))lÎ²) / (3 - cos(2Î²)),\n        -2sin(Î±) - sin(Î± + Î²),\n        2(-(1 + cos(Î²))lÎ± + (3 + 2cos(Î²))lÎ²) / (3 - cos(2Î²)),\n        -sin(Î± + Î²) - 2sin(Î²) * (((lÎ± - lÎ²)lÎ²) / (3 - cos(2Î²))) +\n        2sin(2Î²) * ((lÎ±^2 - 2(1 + cos(Î²))lÎ± * lÎ² + (3 + 2cos(Î²))lÎ²^2) / (3 - cos(2Î²))^2)]\nend\n\n# Construct a ContiunousCallback\ncondition(u, t, integrator) = u[1]\naffect!(integrator) = nothing\ncb = ContinuousCallback(condition, affect!, nothing,\n    save_positions = (true, false))\n\n# Construct Problem\npoincare = ODEProblem(double_pendulum_hamiltonian, initial2, tspan2)\nsol2 = solve(poincare, Vern9(), save_everystep = false, save_start = false,\n    save_end = false, callback = cb, abstol = 1e-16, reltol = 1e-16)\n\nfunction poincare_map(prob, uâ, p; callback = cb)\n    _prob = ODEProblem(prob.f, uâ, prob.tspan)\n    sol = solve(_prob, Vern9(), save_everystep = false, save_start = false,\n        save_end = false, callback = cb, abstol = 1e-16, reltol = 1e-16)\n    scatter!(p, sol, idxs = (3, 4), markersize = 3, msw = 0)\nend\n```\n\n----------------------------------------\n\nTITLE: Choosing MethodOfSteps(Tsit5) Algorithm for DDE Solving in Julia\nDESCRIPTION: Selects the MethodOfSteps(Tsit5()) numerical algorithm for high-efficiency DDE solving. Tsit5 is a 5th order ODE solver repurposed for DDE simulation through MethodOfSteps. Requires DifferentialEquations.jl.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/dde_example.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nalg = MethodOfSteps(Tsit5())\n```\n\n----------------------------------------\n\nTITLE: Installing and Importing GeometricIntegratorsDiffEq in Julia\nDESCRIPTION: This Julia code shows how to add and use the GeometricIntegratorsDiffEq.jl package for accessing additional geometric integrators not bundled with DifferentialEquations.jl. It requires network access to clone the GitHub repository and then load the package into the Julia environment. These steps are prerequisites for using advanced fixed timestep geometric integrators in OrdinaryDiffEq workflows.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/dynamical_solve.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nPkg.clone(\"https://github.com/SciML/GeometricIntegratorsDiffEq.jl\")\nusing GeometricIntegratorsDiffEq\n```\n\n----------------------------------------\n\nTITLE: High Accuracy Non-Stiff Solvers Vern6/7/8 in Julia\nDESCRIPTION: `Vern6`, `Vern7`, or `Vern8` are recommended as efficient choices for non-stiff problems requiring high accuracy within the Float64 range (e.g., tolerances ~1e-8 to 1e-12).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nVern6\n```\n\nLANGUAGE: julia\nCODE:\n```\nVern7\n```\n\nLANGUAGE: julia\nCODE:\n```\nVern8\n```\n\n----------------------------------------\n\nTITLE: Computing Correlation Matrix for Solution Across Time - SciMLBase - Julia\nDESCRIPTION: Uses Julia's Base 'cov' function to compute correlations among columns (timepoints) of the solution. Assumes that the solution type implements the AbstractArray interface. No extra dependencies required beyond SciMLBase and Julia's standard library.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/solution.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\ncov(sol)\n```\n\n----------------------------------------\n\nTITLE: Installing and Using SimpleDiffEq.jl - Julia\nDESCRIPTION: Demonstrates how to install the SimpleDiffEq.jl package and load it for use with simplified SDE solvers. Requires Julia's Pkg standard library. The commands add the package (if needed) and import its exported functions. Input is the SimpleDiffEq.jl package name, expected output is a working installation to allow the use of 'SimpleEM' and related methods.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/sde_solve.md#_snippet_7\n\nLANGUAGE: Julia\nCODE:\n```\nusing Pkg\nPkg.add(\"SimpleDiffEq\")\nusing SimpleDiffEq\n```\n\n----------------------------------------\n\nTITLE: Extreme Accuracy Non-Stiff Solvers Feagin12/14 in Julia\nDESCRIPTION: `Feagin12` or `Feagin14` methods are recommended for extremely high accuracy requirements (<1e-30) on non-stiff problems where a high-order interpolant is not needed. They offer robustness to discontinuities.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nFeagin12\n```\n\nLANGUAGE: julia\nCODE:\n```\nFeagin14\n```\n\n----------------------------------------\n\nTITLE: Integral (I) Controller Timestepping Algorithm - Julia\nDESCRIPTION: Implements the integral controller to adapt the time step in ODE solvers based on the current error estimate. Uses exponentiation informed by the algorithm order, clamps the scaling factor between qmin and qmax, and applies a safety factor gamma. Intended for implicit solvers; requires access to integrator structure, options, and fastmath for performance. Inputs include adaptive order, error, safety parameters; output is the next step size value.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/extras/timestepping.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nqtmp = integrator.EEst^(1 / (alg_adaptive_order(integrator.alg) + 1)) /\n       integrator.opts.gamma\n@fastmath q = max(inv(integrator.opts.qmax), min(inv(integrator.opts.qmin), qtmp))\nintegrator.dtnew = integrator.dt / q\n```\n```\n\n----------------------------------------\n\nTITLE: Dispatch for Preconditioner Construction in DifferentialEquations.jl (Julia)\nDESCRIPTION: This snippet documents the required dispatch form for the 'precs' function, which is used by DifferentialEquations.jl solvers to construct preconditioners (Pl, Pr) during solver setup. The function takes Jacobian-related data and solution context ('W', 'du', 'u', 'p', 't'), with the last three arguments (::Nothing) used in the initial setup phase, and returns a pair of preconditioners. The argument 'solverdata' may provide additional context. This interface is crucial for customizing or overriding the default preconditioning behavior and must be implemented when providing custom preconditioning logic.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/linear_nonlinear.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n```\n\n----------------------------------------\n\nTITLE: Installing diffeqr from GitHub Master Branch with devtools - R\nDESCRIPTION: This R code installs the latest development version of the diffeqr package from the SciML GitHub repository. It uses devtools::install_github and also builds vignettes. Input: none. Output: diffeqr package (master branch) installed for development or testing purposes. Dependencies: devtools package must be installed.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/index.md#_snippet_7\n\nLANGUAGE: R\nCODE:\n```\ndevtools::install_github('SciML/diffeqr', build_vignettes=T)\n```\n\n----------------------------------------\n\nTITLE: Checking Julia Project Dependencies with Pkg.status (Julia)\nDESCRIPTION: Shows how to inspect installed packages in a Julia environment using Pkg.status(). Requires the Pkg module, and provides a summary of all currently installed packages and their versions. This is commonly used for reproducibility and workflow tracking, especially in shared or research environments. Output includes package names and version information.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/index.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nusing Pkg # hide\nPkg.status() # hide\n```\n\n----------------------------------------\n\nTITLE: Defining Modified ODE Model with Slower Drug Decay in Julia\nDESCRIPTION: Defines a new ODE problem representing a patient with a slower drug decay rate. The ODE function `f` is updated to `du[1] = -u[1] / 6`. It uses the same initial condition `u0=[10.0]`, volume `V=1`, and time interval `(0.0, 10.0)` as the first example, creating a distinct `ODEProblem` for this scenario.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/conditional_dosing.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nfunction f(du, u, p, t)\n    du[1] = -u[1] / 6\nend\nu0 = [10.0]\nconst V = 1\nprob = ODEProblem(f, u0, (0.0, 10.0))\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation Links for Sundials ODE Solvers in Julia\nDESCRIPTION: This snippet uses the `@docs` macro, likely from Documenter.jl, to automatically generate documentation links for specific Ordinary Differential Equation (ODE) solvers provided by Sundials.jl. It references `CVODE_Adams`, `CVODE_BDF`, and `ARKODE`, which are distinct algorithms available through the Sundials wrapper for solving ODE problems within Julia.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/api/sundials.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nCVODE_Adams\nCVODE_BDF\nARKODE\n```\n```\n\n----------------------------------------\n\nTITLE: Defining In-Place Constant History Function for DDEs in Julia\nDESCRIPTION: Defines an in-place history function h that fills its output array with 1.0 given any parameter/time. Used when multiple interpolated values are required efficiently. Takes (out, p, t) and modifies out in-place.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/dde_example.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\nh(out, p, t) = (out .= 1.0)\n```\n\n----------------------------------------\n\nTITLE: Mathematical Specification of a Non-autonomous Linear ODE\nDESCRIPTION: Defines the general mathematical form of a non-autonomous linear ordinary differential equation (ODE) as `u' = A(u,p,t)u`. Here, `A` represents an `AbstractSciMLOperator` that can depend on the state `u`, parameters `p`, and time `t`. This formulation is targeted by specialized numerical solvers.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/nonautonomous_linear_ode.md#_snippet_0\n\nLANGUAGE: math\nCODE:\n```\nu^\\prime = A(u,p,t)u\n```\n\n----------------------------------------\n\nTITLE: Identifying Function Origin with @which in Julia\nDESCRIPTION: Demonstrates using the `@which` macro from Julia's `InteractiveUtils` module to determine the source package of a specific function or constructor. In this case, it identifies that `ProbIntsUncertainty` originates from the `DiffEqCallbacks.jl` package. This is useful for identifying necessary direct dependencies.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/low_dep.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nusing InteractiveUtils # hide\n@which ProbIntsUncertainty(0.2, 1)\n```\n\n----------------------------------------\n\nTITLE: Default Preconditioner Function Definition (DifferentialEquations.jl, Julia)\nDESCRIPTION: This snippet shows the default implementation of the preconditioner constructor used by DifferentialEquations.jl, which returns a pair of 'nothing' values, indicating no preconditioning is applied. This function is the default value for the 'precs' keyword argument and serves as a template for creating custom preconditioners. It takes full solver and system context as input and returns (nothing, nothing) unless overridden. No dependencies are required for this usage.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/linear_nonlinear.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n```\n\n----------------------------------------\n\nTITLE: Listing MATLAB Solvers Accessible via MATLABDiffEq.jl\nDESCRIPTION: Lists common MATLAB ODE solvers `ode45` and `ode15s`, which can be called from Julia using the `MATLABDiffEq.jl` wrapper. This allows for direct comparison or usage of familiar MATLAB solvers.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_10\n\nLANGUAGE: matlab\nCODE:\n```\node45, ode15s\n```\n\n----------------------------------------\n\nTITLE: Loading DifferentialEquations.jl in Julia - Julia\nDESCRIPTION: This snippet shows how to load the DifferentialEquations.jl package after installation in a Julia environment. Simply execute the using statement to make the package and its solvers accessible. There are no parameters, and it does not return outputs; after this, all DifferentialEquations.jl API functions are available.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/index.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\n```\n\n----------------------------------------\n\nTITLE: Accessing CUDA Grid and Block Dimensions in Julia\nDESCRIPTION: These declarations set values for the grid and block dimensions typically used in launching CUDA kernels. They help clarify how kernel threads are indexed, establishing the computational domain size for CUDA programs. These assignments assume the CUDA C/C++ coordinate system and are meant for didactic purposes.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/examples/beeler_reuter.md#_snippet_13\n\nLANGUAGE: C/C++\nCODE:\n```\n    gridDim.x = 128;\n    blockDim=256;\n```\n\n----------------------------------------\n\nTITLE: Expressing Second Order ODE as Acceleration in Mathematical Notation (Math)\nDESCRIPTION: This LaTeX equation presents the general form of a second order ODE, specifying the second derivative of position as a function of position, parameters, and time. It is required by SecondOrderODEProblem and similar solvers in Julia's ODE frameworks.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/dynamical_solve.md#_snippet_2\n\nLANGUAGE: math\nCODE:\n```\n\\frac{d^2u}{dt^2} = f(u,p,t)\n```\n\n----------------------------------------\n\nTITLE: Configuring DifferentialEquations.jl Precompilation with Preferences.jl in Julia\nDESCRIPTION: Uses the Preferences.jl package to set specific precompilation flags for the DifferentialEquations.jl package (identified by its UUID). This allows users to disable precompilation for certain categories like stiff solvers, auto-switching solvers, low-storage methods, and non-default specialization levels to potentially reduce initial load times at the cost of increased first-solve time for those categories. It requires the `Preferences` and `UUIDs` packages.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/low_dep.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nusing Preferences, UUIDs\nset_preferences!(UUID(\"1dea7af3-3e70-54e6-95c3-0bf5283fa5ed\"), \"PrecompileNonStiff\" => true)\nset_preferences!(UUID(\"1dea7af3-3e70-54e6-95c3-0bf5283fa5ed\"), \"PrecompileStiff\" => false)\nset_preferences!(UUID(\"1dea7af3-3e70-54e6-95c3-0bf5283fa5ed\"), \"PrecompileAutoSwitch\" => false)\nset_preferences!(UUID(\"1dea7af3-3e70-54e6-95c3-0bf5283fa5ed\"), \"PrecompileLowStorage\" => false)\nset_preferences!(UUID(\"1dea7af3-3e70-54e6-95c3-0bf5283fa5ed\"), \"PrecompileDefaultSpecialize\" => true)\nset_preferences!(UUID(\"1dea7af3-3e70-54e6-95c3-0bf5283fa5ed\"), \"PrecompileAutoSpecialize\" => false)\nset_preferences!(UUID(\"1dea7af3-3e70-54e6-95c3-0bf5283fa5ed\"), \"PrecompileFunctionWrapperSpecialize\" => false)\nset_preferences!(UUID(\"1dea7af3-3e70-54e6-95c3-0bf5283fa5ed\"), \"PrecompileNoSpecialize\" => false)\n```\n\n----------------------------------------\n\nTITLE: Condition for Divergence Based on Initial Value\nDESCRIPTION: Specifies the condition `u(0)>10` under which the solution to the ODE `u' = u^2 - 100u` diverges to infinity. This illustrates how the initial state can dictate the asymptotic behavior of the system.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\nu(0)>10\n```\n\n----------------------------------------\n\nTITLE: Installing and Using Sundials.jl Package in Julia\nDESCRIPTION: This Julia code snippet demonstrates how to install and load the Sundials.jl package. It uses the built-in package manager `Pkg` to add the package and then uses the `using` keyword to make the Sundials solvers available in the current Julia session. This step is necessary before utilizing the Sundials solvers within the SciML ecosystem.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/api/sundials.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nusing Pkg\nPkg.add(\"Sundials\")\nusing Sundials\n```\n```\n\n----------------------------------------\n\nTITLE: Installing and Using Sundials ODE Solvers in Julia\nDESCRIPTION: Shows how to install Sundials.jl and import its capability for advanced multistep ODE solvers in Julia, including BDF and Adams-Moulton variants. Dependencies are Julia's package manager, Sundials.jl, and DifferentialEquations.jl for solve workflows. Key steps include adding and importing the package; expected outputs are access to additional solver algorithms (`CVODE_BDF`, `CVODE_Adams`, `ARKODE`). Limitation: Sundials is not included by default and must be explicitly added.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_37\n\nLANGUAGE: julia\nCODE:\n```\nusing Pkg\nPkg.add(\"Sundials\")\nusing Sundials\n```\n\n----------------------------------------\n\nTITLE: Installing and Using DASKR Solvers in Julia\nDESCRIPTION: Demonstrates the necessary Julia commands to install the DASKR.jl package and import its functionality into the user's environment. Requires Julia's package manager (Pkg) and the DASKR.jl package, and must be executed in a Julia REPL session. The snippet instructs users on how to add the package and import it, prerequisites for accessing DASKR solver algorithms within SciML workflows. Inputs are the package name ('DASKR'); outputs are an installed module and loaded namespace.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/api/daskr.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nusing Pkg\\nPkg.add(\"DASKR\")\\nusing DASKR\n```\n\n----------------------------------------\n\nTITLE: Defining an Invalid ODE Function for 2N Methods in Julia\nDESCRIPTION: This Julia function snippet illustrates an invalid approach for defining ODE functions when using 2N low-storage Runge-Kutta methods in DifferentialEquations.jl. The key issue is that the update to the du variable on the right-hand side violates the 2-register (2N) optimization requirement, which expects all du assignments to only appear on the left. Dependencies: DifferentialEquations.jl; Function parameters: du (output), u (state), p (parameters), t (time). Input: arbitrary state vectors; Output: modifies du in-place. Limitation: Not compatible with 2N methods unless williamson_condition is set to false.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/ode_solve.md#_snippet_29\n\nLANGUAGE: julia\nCODE:\n```\nfunction f(du, u, p, t)\n    du[1] = u[1] * u[2]\n    du[2] = du[1] * u[2] # du appears on the RHS\nend\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for DDEProblem and DDEFunction in Julia\nDESCRIPTION: This Documenter.jl directive automatically includes the documentation for the `SciMLBase.DDEProblem` and `SciMLBase.DDEFunction` types from their respective Julia docstrings into the generated documentation page. These are fundamental types for defining Delay Differential Equation problems in the SciML ecosystem.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/dde_types.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```@docs\nSciMLBase.DDEProblem\nSciMLBase.DDEFunction\n```\n```\n\n----------------------------------------\n\nTITLE: PI Controller Implementation for SDEs (Custom Controller) - Julia\nDESCRIPTION: Implements the PI controller logic for stochastic differential equations by subtyping StochasticDiffEq.AbstractController and defining the necessary callback methods. Uses FastPower for efficient exponentiation, manipulates integrator's q, q11, and dtnew fields based on error estimates and options. Requires StochasticDiffEq, DiffEqBase, FastPower packages; inputs include error estimate and gain parameters; modifies integrator in-place per controller logic.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/extras/timestepping.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nstruct CustomController <: StochasticDiffEq.AbstractController\nend\n\nfunction StochasticDiffEq.stepsize_controller!(integrator::StochasticDiffEq.SDEIntegrator,\n        controller::CustomController, alg)\n    integrator.q11 = DiffEqBase.value(FastPower.fastpower(\n        integrator.EEst, controller.beta1))\n    integrator.q = DiffEqBase.value(integrator.q11 /\n                                    FastPower.fastpower(integrator.qold, controller.beta2))\n    integrator.q = DiffEqBase.value(max(inv(integrator.opts.qmax),\n        min(inv(integrator.opts.qmin),\n            integrator.q / integrator.opts.gamma)))\n    nothing\nend\n\nfunction StochasticDiffEq.step_accept_controller!(\n        integrator::StochasticDiffEq.SDEIntegrator,\n        controller::CustomController, alg)\n    integrator.dtnew = DiffEqBase.value(integrator.dt / integrator.q) *\n                       oneunit(integrator.dt)\n    nothing\nend\n\nfunction step_reject_controller!(integrator::StochasticDiffEq.SDEIntegrator,\n        controller::CustomController, alg)\n    integrator.dtnew = integrator.dt / min(inv(integrator.opts.qmin),\n        integrator.q11 / integrator.opts.gamma)\nend\n```\n```\n\n----------------------------------------\n\nTITLE: Reporting Julia Version and System Information with versioninfo (Julia)\nDESCRIPTION: Retrieves and prints out system and Julia version information for reproducibility, requiring the InteractiveUtils module. This includes Julia version, system architecture, CPU, and other detailed build information. Typical usage is for documenting software environment in scientific research or bug reporting.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/index.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nusing InteractiveUtils # hide\nversioninfo() # hide\n```\n\n----------------------------------------\n\nTITLE: Including Documentation for SciMLBase.SteadyStateProblem in Julia\nDESCRIPTION: This Julia `@docs` directive instructs the documentation generator (like Documenter.jl) to insert the official documentation for the `SciMLBase.SteadyStateProblem` type. This type is fundamental for defining the structure and parameters of a steady-state problem within the SciML ecosystem.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/steady_state_types.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nSciMLBase.SteadyStateProblem\n```\n```\n\n----------------------------------------\n\nTITLE: Referencing Specific Example ODE Problems Documentation\nDESCRIPTION: This snippet uses the Documenter.jl `@docs` directive to list and include documentation for numerous specific example ODE problems defined within the `ODEProblemLibrary` module (as set by the preceding `@meta` block).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/ode_types.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nprob_ode_linear\nprob_ode_2Dlinear\nprob_ode_bigfloatlinear\nprob_ode_bigfloat2Dlinear\nprob_ode_large2Dlinear\nprob_ode_2Dlinear_notinplace\nprob_ode_lotkavolterra\nprob_ode_fitzhughnagumo\nprob_ode_threebody\nprob_ode_pleiades\nprob_ode_vanderpol\nprob_ode_vanderpol_stiff\nprob_ode_rober\nprob_ode_rigidbody\nprob_ode_hires\nprob_ode_orego\nprob_ode_pollution\nprob_ode_nonlinchem\nprob_ode_brusselator_1d\nprob_ode_brusselator_2d\nprob_ode_filament\nprob_ode_thomas\nprob_ode_lorenz\nprob_ode_aizawa\nprob_ode_dadras\nprob_ode_chen\nprob_ode_rossler\nprob_ode_rabinovich_fabrikant\nprob_ode_sprott\nprob_ode_hindmarsh_rose\n```\n```\n\n----------------------------------------\n\nTITLE: Referencing the LSODA Solver Algorithm\nDESCRIPTION: References the `lsoda` solver algorithm, a well-known method for stiff and non-stiff problems, available in Julia through the `LSODA.jl` wrapper package.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nlsoda\n```\n\n----------------------------------------\n\nTITLE: Default Value for Maximum Solver Iterations in Julia\nDESCRIPTION: Specifies the default value for the `maxiters` keyword argument in DifferentialEquations.jl, which is `Int(1e5)` (100,000 iterations).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\nInt(1e5)\n```\n\n----------------------------------------\n\nTITLE: Referencing SciPy's odeint Solver via SciPyDiffEq.jl\nDESCRIPTION: References the `odeint` function from Python's SciPy library (which often wraps LSODA), accessible in Julia through the `SciPyDiffEq.jl` wrapper. This facilitates comparison with SciPy-based implementations.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/basics/faq.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nodeint\n```\n\n----------------------------------------\n\nTITLE: Documenting SciMLBase Problem Types and Functions (Julia)\nDESCRIPTION: Documents the types and constructors for dynamical ODE, second order ODE, and associated function types within the SciMLBase library. These doc directives generate API documentation for the referenced Julia types/functions (DynamicalODEProblem, SecondOrderODEProblem, DynamicalODEFunction). The code assumes SciMLBase is loaded and requires no parameters or runtime, producing documentation entries to be rendered in the Julia documentation system.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/dynamical_types.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nSciMLBase.DynamicalODEProblem\nSciMLBase.SecondOrderODEProblem\nSciMLBase.DynamicalODEFunction\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Non-Autonomous Linear ODEs in Mathematical Notation\nDESCRIPTION: These LaTeX mathematical expressions define the general forms of non-autonomous linear ODEs addressed in the documentation. The equations depict operator dependencies on time, state, or both, and set the theoretical context for the code examples. Inputs are the operators A as functions of u (state), t (time), or constants, with no computational outputs but serving as key reference formulas.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/nonautonomous_linear_ode.md#_snippet_4\n\nLANGUAGE: math\nCODE:\n```\nu^\\prime = A(u,p,t)u\n```\n\nLANGUAGE: math\nCODE:\n```\nu^\\prime = A(t)u\n```\n\nLANGUAGE: math\nCODE:\n```\nu^\\prime = A(u)u\n```\n\nLANGUAGE: math\nCODE:\n```\nu^\\prime = Au\n```\n\n----------------------------------------\n\nTITLE: Setting Up Reduction Example with prob_func (Julia)\nDESCRIPTION: Initial setup for Example 3, demonstrating ensemble reduction. It imports `DifferentialEquations.jl` and begins defining a `prob_func` which is intended to randomize the initial condition for each trajectory, similar to previous examples, but in the context of using an `output_func` for reduction. The `prob_func` definition is incomplete in the source.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/ensemble.md#_snippet_26\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\n```\n\n----------------------------------------\n\nTITLE: Documenting the SDE Alias Specifier in SciMLBase Using Julia\nDESCRIPTION: This macro block references and generates documentation for the SDEAliasSpecifier type or function in SciMLBase. The SDEAliasSpecifier is used to manage aliasing strategies or specifications in SDEProblem constructions. The block is intended for use within a documentation system such as Documenter.jl, requiring SciMLBase to be installed. Outputs rendered documentation when processed and does not accept programmatic input directly.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/sde_types.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nSciMLBase.SDEAliasSpecifier\n```\n```\n\n----------------------------------------\n\nTITLE: Redirecting with HTML Meta Tag in Julia Documentation - HTML/Julia\nDESCRIPTION: This snippet injects a raw HTML meta-refresh tag using the Julia documentation tools (indicated by the \"@raw html\" macro) to automatically redirect visitors to an external tutorial page. There are no additional dependencies beyond the Julia documentation system supporting raw HTML embedding. The main parameter is the target URL for redirection, ensuring seamless navigation for documentation users. No user input is required, and the redirect occurs immediately on page load.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/tutorials/jump_diffusion.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@raw html\n<meta http-equiv=\\\"Refresh\\\" content=\\\"0; url='https://docs.sciml.ai/JumpProcesses/stable/tutorials/jump_diffusion/'\\\" />\n```\n```\n\n----------------------------------------\n\nTITLE: Instantiating the AutoAbstol Callback (Julia)\nDESCRIPTION: This snippet demonstrates how to create an instance of the `AutoAbstol` callback using its constructor. It requires the `DifferentialEquations.jl` package and the previously defined `AutoAbstol` function.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_22\n\nLANGUAGE: julia\nCODE:\n```\nusing DifferentialEquations\ncb = AutoAbstol(true; init_curmax = 1e-6)\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for QS Example Problem\nDESCRIPTION: This Documenter.jl `@docs` block generates documentation for a specific DDE example problem named `prob_dde_qs` from the `DDEProblemLibrary`.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/dde_types.md#_snippet_9\n\nLANGUAGE: markdown\nCODE:\n```\n```@docs\nprob_dde_qs\n```\n```\n\n----------------------------------------\n\nTITLE: Gustafsson Step Acceptance Logic - Julia\nDESCRIPTION: Handles the step acceptance path in Gustafsson acceleration, updating time and error memories and computing new acceptance factors. Includes conditional logic based on recent success iteration count. Expects integrator structure with dtacc, erracc, qold, EEst, and algorithm information; adjusts future steps based on acceptance history.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/extras/timestepping.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nif integrator.success_iter > 0\n    expo = 1 / (alg_adaptive_order(integrator.alg) + 1)\n    qgus = (integrator.dtacc / integrator.dt) *\n           (((integrator.EEst^2) / integrator.erracc)^expo)\n    qgus = max(inv(integrator.opts.qmax),\n        min(inv(integrator.opts.qmin), qgus / integrator.opts.gamma))\n    qacc = max(q, qgus)\nelse\n    qacc = q\nend\nintegrator.dtacc = integrator.dt\nintegrator.erracc = max(1e-2, integrator.EEst)\nintegrator.dt / qacc\n```\n```\n\n----------------------------------------\n\nTITLE: Referencing VectorContinuousCallback Documentation in Julia Docs\nDESCRIPTION: Uses the `@docs` macro within Julia's documentation system (Documenter.jl) to automatically insert the documentation for the `VectorContinuousCallback` type from DifferentialEquations.jl at this location in the generated documentation.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nVectorContinuousCallback\n```\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for SciMLBase RODEProblem and RODEFunction (Julia)\nDESCRIPTION: This snippet uses the Documenter.jl `@docs` block to automatically pull and render the docstrings for `SciMLBase.RODEProblem` and `SciMLBase.RODEFunction`. These are core types used to define and represent Random Ordinary Differential Equation problems within the SciML ecosystem.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/rode_types.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nSciMLBase.RODEProblem\nSciMLBase.RODEFunction\n```\n```\n\n----------------------------------------\n\nTITLE: Function Map Update Equation (Mathematical Notation)\nDESCRIPTION: This LaTeX math formula expresses the update rule at each discrete step when using the default FunctionMap algorithm. The next state u_{n+1} is calculated by applying the discrete function f at time t_{n+1} to the previous state u_n. This formulation matches the mathematical definition of a discrete function map and helps distinguish it from continuous methods.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/discrete_solve.md#_snippet_2\n\nLANGUAGE: math\nCODE:\n```\nu_{n+1} = f(t_{n+1},u_n).\n```\n\n----------------------------------------\n\nTITLE: Referencing CallbackSet Documentation in Julia Docs\nDESCRIPTION: Uses the `@docs` macro within Julia's documentation system (Documenter.jl) to automatically insert the documentation for the `CallbackSet` type from DifferentialEquations.jl at this location in the generated documentation.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/features/callback_functions.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nCallbackSet\n```\n```\n\n----------------------------------------\n\nTITLE: Expressing Partitioned Equations of Motion in Mathematical Notation (Math)\nDESCRIPTION: These LaTeX equations describe the partitioned form required for certain dynamical ODE solvers in SciML. They define the time derivatives of velocity and position as functions f1 and f2, respectively. These forms are necessary when formulating problems with DynamicalODEProblem for specialized integrators.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/solvers/dynamical_solve.md#_snippet_1\n\nLANGUAGE: math\nCODE:\n```\n\\frac{dv}{dt} = f_1(t,u) \\\\\n\\frac{du}{dt} = f_2(v) \\\\\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for DDEAliasSpecifier in Julia\nDESCRIPTION: This Documenter.jl directive includes the documentation for `SciMLBase.DDEAliasSpecifier` from its Julia docstring. This type is likely used for specifying aliases or specific handling related to DDE problems within SciML.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/dde_types.md#_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n```@docs\nSciMLBase.DDEAliasSpecifier\n```\n```\n\n----------------------------------------\n\nTITLE: Referencing SciMLBase ODE Problem and Function Documentation\nDESCRIPTION: This snippet uses the Documenter.jl `@docs` directive to automatically include the documentation for the `ODEProblem` and `ODEFunction` types from the SciMLBase package within the generated documentation.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/ode_types.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nSciMLBase.ODEProblem\nSciMLBase.ODEFunction\n```\n```\n\n----------------------------------------\n\nTITLE: Including SciMLBase SDDE Alias Specifier Documentation (Julia)\nDESCRIPTION: This code employs the `@docs` macro in a Julia documentation context (likely Documenter.jl) to incorporate the documentation for the `SciMLBase.SDDEAliasSpecifier` type. This type likely relates to specifying aliases or alternative names within the context of SDDE problem definitions in SciML.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/sdde_types.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n@docs\nSciMLBase.SDDEAliasSpecifier\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for SciMLBase RODEAliasSpecifier (Julia)\nDESCRIPTION: This snippet uses the Documenter.jl `@docs` block to generate documentation for the `SciMLBase.RODEAliasSpecifier` type. This type is likely involved in specifying or handling aliases within the context of RODE problem definitions or solutions in SciMLBase.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/rode_types.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nSciMLBase.RODEAliasSpecifier\n```\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for Single Constant Delay DDE Problems\nDESCRIPTION: This Documenter.jl `@docs` block generates documentation for various pre-defined DDE problems from `DDEProblemLibrary` that feature a single constant delay. It includes both in-place (`_ip`), out-of-place (`_oop`), and scalar versions, as well as variants with longer time spans (`_long`).\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/dde_types.md#_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n```@docs\nprob_dde_constant_1delay_ip\nprob_dde_constant_1delay_oop\nprob_dde_constant_1delay_scalar\nprob_dde_constant_1delay_long_ip\nprob_dde_constant_1delay_long_oop\nprob_dde_constant_1delay_long_scalar\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Current Module for Documenter.jl\nDESCRIPTION: This Documenter.jl `@meta` block sets the `CurrentModule` to `DDEProblemLibrary`. This directive informs Documenter that subsequent `@docs` references without explicit module qualification should be looked up within the `DDEProblemLibrary` module.\nSOURCE: https://github.com/sciml/diffeqdocs.jl/blob/master/docs/src/types/dde_types.md#_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n```@meta\nCurrentModule = DDEProblemLibrary\n```\n```"
  }
]