[
  {
    "owner": "6p5ra",
    "repo": "lettre-docs",
    "content": "TITLE: Sending Email Asynchronously Using AsyncSmtpTransport with Tokio in Rust\nDESCRIPTION: This snippet demonstrates how to send an email asynchronously using lettre's AsyncSmtpTransport with the Tokio async runtime in Rust. It requires the lettre crate with the \"tokio1-native-tls\" feature and the tokio crate with the \"full\" feature in Cargo.toml. The example shows how to build an email message, configure async SMTP transport with relay, credentials, and executor, then send the email using the .send().await method. All parameters such as SMTP server address, credentials (username, app-specific password), and message details must be replaced with appropriate values for production use. The main limitation is the mandatory async context, and handling actual credentials securely should be implemented.\nSOURCE: https://github.com/6p5ra/lettre-docs/blob/main/lettre.md#_snippet_9\n\nLANGUAGE: Rust\nCODE:\n```\n// Requires `lettre = { version = \"0.11\", features = [\"tokio1-native-tls\"] }`\n// and `tokio = { version = \"1\", features = [\"full\"] }` in Cargo.toml\n\nuse lettre::message::{header::ContentType, Message};\n// Import the ASYNC transport and trait\nuse lettre::{AsyncSmtpTransport, AsyncTransport};\nuse lettre::transport::smtp::authentication::Credentials;\n// Use the tokio runtime\nuse lettre::Tokio1Executor;\n\n// Need an async main function\n#[tokio::main]\nasync fn main() {\n    let email = Message::builder()\n        // ... (build message exactly as before)\n        .from(\"Me <my_gmail_address@gmail.com>\".parse().unwrap())\n        .to(\"Friend <friend@example.com>\".parse().unwrap())\n        .subject(\"Trying out Async Lettre SMTP!\")\n        .header(ContentType::TEXT_PLAIN)\n        .body(\"Hello from async!\".to_string())\n        .expect(\"Failed to build email\");\n\n    let creds = Credentials::new(\"my_gmail_address@gmail.com\".to_owned(), \"my_app_password\".to_owned());\n\n    // Configure the Async SMTP Transport (requires runtime executor)\n    let mailer = AsyncSmtpTransport::<Tokio1Executor>::relay(\"smtp.gmail.com\")\n        .unwrap()\n        .credentials(creds)\n        .build(); // Build the async transport\n\n    println!(\"Async SMTP Transport configured for smtp.gmail.com\");\n\n    // Send the email using .send() and .await\n    println!(\"Attempting to send email asynchronously...\");\n    match mailer.send(email).await { // Note: Pass email by value, and use .await\n        Ok(response) => {\n            println!(\"Async email sent successfully! Response: {:?}\", response);\n        }\n        Err(e) => {\n            panic!(\"Could not send async email: {:?}\", e);\n        }\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring SmtpTransport with Credentials and Automatic TLS in Rust\nDESCRIPTION: Demonstrates creating an `SmtpTransport` instance in Rust using the `relay()` method for automatic TLS negotiation (STARTTLS/Implicit TLS) with a specified SMTP server. It shows how to provide authentication credentials using `Credentials::new()` and the `.credentials()` builder method before building the final transport. The example also includes basic email construction and sending with error handling, highlighting that TLS is typically enabled by default with this setup for common servers.\nSOURCE: https://github.com/6p5ra/lettre-docs/blob/main/lettre.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n// Assuming you have `lettre = \"0.11\"` with a TLS feature enabled (see below)\nuse lettre::transport::smtp::authentication::Credentials;\nuse lettre::{Message, SmtpTransport, Transport};\n// ... other imports and email building ...\n\nfn main() {\n    // ... build your email ...\n    let email = Message::builder()\n        // ... (From, To, Subject, Body) ...\n        .from(\"Me <me@example.com>\".parse().unwrap())\n        .to(\"Friend <friend@example.net>\".parse().unwrap())\n        .subject(\"Secure Sending!\")\n        .body(\"This email is sent over TLS!\".to_string())\n        .expect(\"Failed to build email\");\n\n    // ... create credentials ...\n    let creds = Credentials::new(\"me@example.com\".to_owned(), \"mypassword\".to_owned());\n\n    // This simple setup USUALLY enables TLS automatically!\n    let mailer = SmtpTransport::relay(\"smtp.example.com\") // e.g., smtp.gmail.com\n        .unwrap()\n        .credentials(creds)\n        .build();\n\n    println!(\"Attempting to send email securely...\");\n    // When send() is called, lettre will try STARTTLS or Implicit TLS\n    match mailer.send(&email) {\n        Ok(_) => println!(\"Email sent securely using TLS!\"),\n        Err(e) => eprintln!(\"Failed to send email: {:?}\", e), // Might be a TLS error if configuration fails\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SmtpTransport with Credentials in Rust Using lettre\nDESCRIPTION: This snippet shows how to configure the SmtpTransport in lettre to use explicit credentials for authenticating with an SMTP server in Rust. It demonstrates creating a Credentials object, attaching it to SmtpTransport using .credentials(), and sending an email message. The code includes building both the Credentials and the Message objects, error handling for connection and send operations, and highlights that sensitive parameters like email and password should be provided securely. Actual SMTP parameters and secrets must be replaced in non-demo environments.\nSOURCE: https://github.com/6p5ra/lettre-docs/blob/main/lettre.md#_snippet_11\n\nLANGUAGE: Rust\nCODE:\n```\nuse lettre::transport::smtp::authentication::Credentials;\nuse lettre::{Message, SmtpTransport, Transport}; // Added Transport trait\nuse lettre::message::header::ContentType; // For building the message\n\nfn main() {\n    // 1. Create Credentials (replace with real ones, loaded securely!)\n    let creds = Credentials::new(\n        \"your_email@example.com\".to_string(),\n        \"your_secret_password\".to_string(),\n    );\n\n    // 2. Configure the SmtpTransport using the credentials\n    let mailer = SmtpTransport::relay(\"smtp.example.com\") // Use your provider's server\n        .unwrap()\n        .credentials(creds) // <-- Tell the transport to use these credentials\n        .build();\n\n    println!(\"SmtpTransport configured with credentials.\");\n\n    // 3. Build a simple email message (details omitted for brevity)\n    let email = Message::builder()\n        .from(\"Me <your_email@example.com>\".parse().unwrap())\n        .to(\"Friend <friend@example.net>\".parse().unwrap())\n        .subject(\"Testing Credentials!\")\n        .header(ContentType::TEXT_PLAIN)\n        .body(\"This email should be sent using authentication.\".to_string())\n        .expect(\"Failed to build email\");\n\n    // 4. Attempt to send the email (will now try to authenticate)\n    match mailer.send(&email) {\n        Ok(_) => println!(\"Email sent successfully using authentication!\"),\n        Err(e) => eprintln!(\"Failed to send email: {:?}\", e), // More likely to show auth errors if creds are wrong\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Sending Email via SMTP using Lettre SmtpTransport (Rust)\nDESCRIPTION: Demonstrates sending an email using `lettre`'s synchronous `SmtpTransport` in Rust. It covers importing necessary modules (`Message`, `SmtpTransport`, `Transport`, `Credentials`), building an email message, creating `Credentials` (using placeholder values), configuring the `SmtpTransport` builder for an SMTP relay (e.g., `smtp.gmail.com`), adding credentials, building the transport, and finally calling the `send` method to transmit the email. Includes basic error handling for the send operation. Note: Requires replacing placeholder credentials with actual ones and potentially adjusting account security settings on the email provider's side.\nSOURCE: https://github.com/6p5ra/lettre-docs/blob/main/lettre.md#_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\nuse lettre::message::{header::ContentType, Message};\n// Import SmtpTransport for synchronous sending AND the Transport trait\nuse lettre::{SmtpTransport, Transport};\n// We need Credentials for authentication\nuse lettre::transport::smtp::authentication::Credentials;\n\nfn main() {\n    // 1. Build the email message\n    let email = Message::builder()\n        .from(\"Me <my_gmail_address@gmail.com>\".parse().unwrap()) // Use your actual address\n        .to(\"Friend <friend@example.com>\".parse().unwrap())    // The recipient\n        .subject(\"Trying out Lettre SMTP!\")\n        .header(ContentType::TEXT_PLAIN)\n        .body(\"Hello friend,\\n\\nThis is my first email sent via Lettre!\".to_string())\n        .expect(\"Failed to build email\");\n\n    // 2. Set up SMTP credentials (Replace with your actual credentials)\n    //    WARNING: Don't hardcode credentials in real applications!\n    //    We'll learn better ways in Chapter 5.\n    //    For Gmail, this is often an \"App Password\" if you have 2FA enabled.\n    let creds = Credentials::new(\"my_gmail_address@gmail.com\".to_owned(), \"my_app_password\".to_owned());\n\n    // 3. Configure the SMTP Transport (for Gmail)\n    let mailer = SmtpTransport::relay(\"smtp.gmail.com\")\n        .unwrap() // Check if the hostname is valid\n        .credentials(creds) // Add the credentials\n        .build(); // Create the transport instance\n\n    println!(\"SMTP Transport configured for smtp.gmail.com\");\n\n    // 4. Send the email using the transport\n    println!(\"Attempting to send email...\");\n    match mailer.send(&email) {\n        Ok(response) => {\n            // The response contains details from the SMTP server if successful\n            println!(\"Email sent successfully! Server response: {:?}\", response);\n        }\n        Err(e) => {\n            // This could be a connection error, auth error, etc.\n            panic!(\"Could not send email: {:?}\", e);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Validating an Email Message with lettre in Rust\nDESCRIPTION: This code demonstrates how to construct an email message using the lettre crate in Rust, utilizing the builder pattern for stepwise composition. Required dependencies are lettre and its message module with ContentType and Message, and the program must be run in a Rust environment with lettre installed. The builder sets the sender ('From'), recipient ('To'), subject, ‘Content-Type’ header, and body of the email, then handles potential errors arising from address formatting or other message-building issues. The expected input includes valid email addresses formatted as strings (with optional display names), and the output is a fully-structured Message object if building is successful; errors are printed or the process panics on failure. Limitations include strict adherence to address formatting and the need for proper error handling.\nSOURCE: https://github.com/6p5ra/lettre-docs/blob/main/lettre.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse lettre::message::{header::ContentType, Message};\n\nfn main() {\n    // Start building the email\n    let email_result = Message::builder()\n        // Set the sender's address (From)\n        .from(\"Me <me@example.com>\".parse().unwrap())\n        // Set the recipient's address (To)\n        .to(\"You <you@example.com>\".parse().unwrap())\n        // Set the subject line\n        .subject(\"Hello from Lettre!\")\n        // Specify that the body is plain text\n        .header(ContentType::TEXT_PLAIN)\n        // Set the email body content\n        .body(String::from(\"This is the email body.\")); // You can use .body(String::from(\"...\")) or .body(\"...\")\n\n    // Check if building the email was successful\n    match email_result {\n        Ok(email) => {\n            println!(\"Yay! Email message created successfully.\");\n            // Now the 'email' variable holds our complete Message object.\n            // We can't *see* the whole formatted email easily here,\n            // but it's ready for the next step: sending!\n        }\n        Err(e) => {\n            panic!(\"Oh no! Failed to build email: {e:?}\");\n        }\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Building Message with Parsed Mailbox in Lettre Rust\nDESCRIPTION: Shows how to build a `lettre` email `Message` by first parsing sender and recipient addresses into `Mailbox` objects before using the `Message::builder`. Emphasizes passing the pre-parsed `Mailbox` objects directly to the `.from()` and `.to()` builder methods for improved code structure and separate error handling. Uses `.expect()` for simplified address parsing error handling and a `match` statement for the final message building result.\nSOURCE: https://github.com/6p5ra/lettre-docs/blob/main/lettre.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nuse lettre::message::{header::ContentType, Mailbox, Message};\n// No need for FromStr here if we parse separately\n\nfn main() {\n    // 1. Parse the addresses into Mailbox objects first\n    let sender = \"Me <me@example.com>\".parse::<Mailbox>();\n    let recipient = \"You <you@example.com>\".parse::<Mailbox>();\n\n    // Check if parsing succeeded (using expect for simplicity in this example)\n    // In real code, you might use 'match' or '?' to handle errors gracefully.\n    let sender_mailbox = sender.expect(\"Invalid sender address format\");\n    let recipient_mailbox = recipient.expect(\"Invalid recipient address format\");\n\n    // 2. Build the email using the pre-parsed Mailbox objects\n    let email_result = Message::builder()\n        .from(sender_mailbox)       // Pass the Mailbox object directly\n        .to(recipient_mailbox)     // Pass the Mailbox object directly\n        .subject(\"Hello using Mailbox!\")\n        .header(ContentType::TEXT_PLAIN)\n        .body(String::from(\"Now we are using Mailbox objects properly!\"));\n\n    // 3. Check the final message building result\n    match email_result {\n        Ok(email) => {\n            println!(\"Email message created successfully using Mailbox objects.\");\n            // The 'email' variable now holds our complete message,\n            // ready for the next step: sending!\n        }\n        Err(e) => {\n            panic!(\"Failed to build email: {e:?}\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Strings to Mailbox in Lettre Rust\nDESCRIPTION: Demonstrates converting string representations of email addresses into `lettre::message::Mailbox` objects using the `FromStr` trait's `from_str` or `parse()` methods. Shows how to safely handle the returned `Result` using a `match` statement, covering successful parsing for addresses with/without names and failed parsing for invalid strings. Requires adding `lettre = \"0.11\"` to `Cargo.toml` and importing `Mailbox` and `FromStr`.\nSOURCE: https://github.com/6p5ra/lettre-docs/blob/main/lettre.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n// Make sure to add `lettre = \"0.11\"` to your Cargo.toml dependencies\nuse lettre::message::Mailbox;\nuse std::str::FromStr; // Trait needed for '.parse()' or 'Mailbox::from_str'\n\nfn main() {\n    let address_string_with_name = \"Ada Lovelace <ada@example.com>\";\n    let mailbox1_result = Mailbox::from_str(address_string_with_name); // Or .parse::<Mailbox>()\n\n    match mailbox1_result {\n        Ok(mailbox) => {\n            // The string was successfully parsed into a Mailbox object\n            println!(\"Successfully parsed '{}': {:?}\", address_string_with_name, mailbox);\n            // Output might look like: Successfully parsed 'Ada Lovelace <ada@example.com>': Mailbox { name: Some(\"Ada Lovelace\"), email: Address(\"ada@example.com\") }\n        }\n        Err(e) => {\n            // The string didn't look like a valid address format\n            println!(\"Failed to parse address '{}': {:?}\", address_string_with_name, e);\n        }\n    }\n\n    let address_string_simple = \"someone@example.org\";\n    let mailbox2_result = address_string_simple.parse::<Mailbox>(); // Using .parse() directly\n\n    match mailbox2_result {\n        Ok(mailbox) => {\n            println!(\"Successfully parsed '{}': {:?}\", address_string_simple, mailbox);\n            // Output might look like: Successfully parsed 'someone@example.org': Mailbox { name: None, email: Address(\"someone@example.org\") }\n        }\n        Err(e) => {\n            println!(\"Failed to parse address '{}': {:?}\", address_string_simple, e);\n        }\n    }\n\n    let invalid_address_string = \"Not an email address\";\n    let mailbox3_result = invalid_address_string.parse::<Mailbox>();\n\n    match mailbox3_result {\n      Ok(_) => {} // This won't happen\n      Err(e) => {\n          println!(\"Parsing '{}' correctly failed: {:?}\", invalid_address_string, e);\n          // Output will show some kind of parsing error\n      }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using FileTransport to Save an Email as a .eml File in Rust\nDESCRIPTION: This Rust example demonstrates how to build an email Message and use lettre's FileTransport to save it locally as a .eml file. It outlines importing necessary components, creating the email content, instantiating FileTransport with the current directory, and calling the .send() method to write the email file. The example handles the Result returned by send, printing success or panicking on error. This snippet requires lettre version 0.11 and access to the file system for saving emails.\nSOURCE: https://github.com/6p5ra/lettre-docs/blob/main/lettre.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n// Don't forget to add `lettre = \"0.11\"` to your Cargo.toml\n\nuse lettre::message::{header::ContentType, Mailbox, Message};\nuse lettre::{FileTransport, Transport}; // Import the specific transport AND the trait\nuse std::env; // To get the current directory for saving the file\n\nfn main() {\n    // 1. Build the email message (like in previous chapters)\n    let email = Message::builder()\n        .from(\"Me <me@example.com>\".parse().unwrap())\n        .to(\"You <you@example.com>\".parse().unwrap())\n        .subject(\"Saving to a File!\")\n        .header(ContentType::TEXT_PLAIN)\n        .body(\"This email will be saved as a .eml file.\".to_string())\n        .expect(\"Failed to build email\"); // Assume success for simplicity\n\n    // 2. Create a FileTransport instance\n    //    It saves emails to the specified directory. Let's use the current directory.\n    let file_path = env::current_dir().expect(\"Failed to get current directory\");\n    let mailer = FileTransport::new(&file_path);\n    println!(\n        \"FileTransport created. Will save emails to: {}\",\n        file_path.display()\n    );\n\n    // 3. Send the email using the transport's .send() method\n    match mailer.send(&email) {\n        Ok(result) => {\n            println!(\"Email saved successfully!\");\n            // The 'result' here contains information specific to FileTransport,\n            // often including the generated filename. Let's print it.\n            println!(\"Result: {:?}\", result);\n            println!(\"Check your current directory for a file ending with .eml\");\n        }\n        Err(e) => {\n            panic!(\"Could not save email to file: {e:?}\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SmtpTransport with Connection Pooling - Rust\nDESCRIPTION: This Rust code snippet demonstrates how to configure the `SmtpTransport` with connection pooling using the `lettre` library. It sets up email credentials, constructs an email message, and configures the `PoolConfig` with options such as `min_idle`, `max_size`, and `idle_timeout` to manage the connection pool. The code then sends multiple emails through the pooled transport, showcasing the performance benefits of connection reuse.\nSOURCE: https://github.com/6p5ra/lettre-docs/blob/main/lettre.md#_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\n// Make sure you have lettre = { version = \"0.11\", features = [\"smtp-transport\", \"pool\", \"builder\", \"native-tls\"] }\n// The \"pool\" feature is needed! (Or corresponding async pool feature)\nuse lettre::{\n    transport::smtp::{\n        authentication::Credentials,\n        pool::PoolConfig, // Import PoolConfig\n    },\n    Message, SmtpTransport, Transport, // Usual imports\n};\nuse std::time::Duration; // To specify timeouts\n\nfn main() {\n    // 1. Build an email (same as before)\n    let email = Message::builder()\n        .from(\"Me <me@example.com>\".parse().unwrap())\n        .to(\"Friend <friend@example.net>\".parse().unwrap())\n        .subject(\"Sending with a Connection Pool!\")\n        .body(\"This email reused a connection!\".to_string())\n        .expect(\"Failed to build email\");\n\n    // 2. Define credentials (same as before)\n    let creds = Credentials::new(\"me@example.com\".to_owned(), \"mypassword\".to_owned());\n\n    // 3. Configure the SmtpTransport WITH pooling\n    let mailer = SmtpTransport::relay(\"smtp.example.com\")\n        .unwrap()\n        .credentials(creds)\n        // Configure the connection pool\n        .pool_config(\n            PoolConfig::new()\n                .min_idle(1) // Keep at least 1 connection ready\n                .max_size(5) // Allow up to 5 connections total\n                .idle_timeout(Duration::from_secs(60)) // Close connections idle for 60s\n        )\n        .build(); // Build the pooled transport\n\n    println!(\"SMTP Transport with connection pooling configured.\");\n\n    // 4. Send multiple emails (this is where pooling shines!)\n    for i in 1..=3 { // Send 3 emails\n        println!(\"Sending email #{}\", i);\n        match mailer.send(&email) {\n            Ok(_) => println!(\"Email #{} sent successfully!\", i),\n            Err(e) => eprintln!(\"Failed to send email #{}: {:?}\", i, e),\n        }\n        // Small pause to simulate work between emails\n        std::thread::sleep(Duration::from_millis(100));\n    }\n    println!(\"Finished sending emails.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit TLS Configuration with SmtpTransport - Rust\nDESCRIPTION: This code snippet demonstrates how to explicitly configure TLS settings for the SmtpTransport in Lettre. It showcases how to use the Tls enum (Tls::Required) and TlsParameters to enforce TLS for secure email communication. It also provides a warning about disabling certificate validation only for local testing.\nSOURCE: https://github.com/6p5ra/lettre-docs/blob/main/lettre.md#_snippet_16\n\nLANGUAGE: Rust\nCODE:\n```\nuse lettre::transport::smtp::client::Tls;\nuse lettre::transport::smtp::client::TlsParameters;\nuse lettre::{SmtpTransport, Transport, Message, Credentials};\n// ... other imports ...\n\nfn main() {\n    // ... build email and credentials ...\n    let email = Message::builder() /* ... */ .build().unwrap();\n    let creds = Credentials::new(/* ... */);\n\n    // Example: Explicitly require TLS for smtp.example.com\n    // This is often equivalent to the default behaviour of relay()\n    let tls_parameters = TlsParameters::new(\"smtp.example.com\".to_string())\n         // WARNING: Only use for testing/local dev with self-signed certs!\n         // .dangerous_accept_invalid_certs(true)\n         // .dangerous_accept_invalid_hostnames(true)\n         .expect(\"Failed to create TLS parameters\");\n\n    let mailer = SmtpTransport::builder(\"smtp.example.com\", Tls::Required(tls_parameters))\n        // We specified TLS behaviour, so maybe manually set port if not default\n        // .port(587) // Or 465 for implicit TLS\n        .credentials(creds)\n        .build(); // Use .builder() instead of .relay() for more control\n\n    match mailer.send(&email) {\n        Ok(_) => println!(\"Email sent with explicit TLS requirement!\"),\n        Err(e) => eprintln!(\"Failed to send email: {:?}\", e),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Credentials for SMTP Authentication Using lettre in Rust\nDESCRIPTION: This example illustrates how to instantiate a Credentials object for SMTP authentication using lettre in Rust. It demonstrates importing the Credentials type, preparing username and password as String values, and securely initializing credentials via Credentials::new(username, password). Hardcoding credentials in source code, as shown, is not recommended for production; instead, use environment variables, configuration files, or secrets management. The code does not send email—its sole output is confirming the credentials object creation.\nSOURCE: https://github.com/6p5ra/lettre-docs/blob/main/lettre.md#_snippet_10\n\nLANGUAGE: Rust\nCODE:\n```\n// Make sure you have lettre in your Cargo.toml\n// `lettre = \"0.11\"`\nuse lettre::transport::smtp::authentication::Credentials;\n\nfn main() {\n    // Replace with your actual SMTP username and password\n    // WARNING: Avoid hardcoding sensitive information like passwords directly\n    // in your source code in real applications! Use environment variables,\n    // configuration files, or secrets management services instead.\n    let smtp_username = \"your_email@example.com\".to_string();\n    let smtp_password = \"your_secret_password\".to_string(); // Or an \"App Password\"\n\n    // Create the Credentials object\n    let creds = Credentials::new(smtp_username, smtp_password);\n\n    println!(\"Credentials object created successfully!\");\n    // We don't print the creds object itself for security reasons,\n    // but it now holds your username and password, ready to be used.\n}\n\n```\n\n----------------------------------------\n\nTITLE: Parsing Named Email Addresses into Mailbox Types with lettre in Rust\nDESCRIPTION: These lines illustrate usage of the .parse() and .unwrap() methods to convert human-readable email strings, with optional display names, into lettre's internal Mailbox representation. Dependencies are Rust’s standard library and the lettre crate; valid address strings must conform to RFC 5322 formatting. The main purpose is to ensure type-safe, standards-compliant encapsulation of addresses before assignment to message fields. Inputs are address strings like 'Me <me@example.com>', and outputs are Mailbox objects or panics on incorrect format. This pattern enforces validation at build time, with constraints that all supplied strings must be valid email addresses.\nSOURCE: https://github.com/6p5ra/lettre-docs/blob/main/lettre.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n.from(\"Me <me@example.com>\".parse().unwrap())\n.to(\"You <you@example.com>\".parse().unwrap())\n```\n\n----------------------------------------\n\nTITLE: SMTP Send Sequence Diagram (Mermaid)\nDESCRIPTION: A Mermaid sequence diagram illustrating the typical flow of commands exchanged between a client using `lettre`'s `SmtpTransport` and a remote SMTP server during an email sending process. It visualizes steps like DNS resolution, connection establishment, EHLO handshake, STARTTLS for encryption, authentication, sending sender/recipient information (MAIL FROM/RCPT TO), transmitting the email content (DATA), and finally quitting the session.\nSOURCE: https://github.com/6p5ra/lettre-docs/blob/main/lettre.md#_snippet_8\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant UserCode as Your Code\n    participant SmtpT as SmtpTransport\n    participant Network as Network/DNS\n    participant SmtpServer as Remote SMTP Server\n\n    UserCode->>SmtpT: transport.send(&message)\n    SmtpT->>Network: Resolve \"smtp.gmail.com\"\n    Network-->>SmtpT: IP Address\n    SmtpT->>SmtpServer: Connect (e.g., Port 587)\n    SmtpServer-->>SmtpT: Welcome (220)\n    SmtpT->>SmtpServer: EHLO mycomputer\n    SmtpServer-->>SmtpT: Capabilities (250 STARTTLS, AUTH LOGIN, ...)\n    Note over SmtpT,SmtpServer: Negotiate TLS (STARTTLS) - Encrypted now!\n    Note over SmtpT,SmtpServer: Authenticate (AUTH LOGIN, send user/pass)\n    SmtpT->>SmtpServer: MAIL FROM:<me@gmail.com>\n    SmtpServer-->>SmtpT: OK (250)\n    SmtpT->>SmtpServer: RCPT TO:<friend@example.com>\n    SmtpServer-->>SmtpT: OK (250)\n    SmtpT->>SmtpServer: DATA\n    SmtpServer-->>SmtpT: Start mail input (354)\n    SmtpT->>SmtpServer: Send formatted Message content...\n    SmtpT->>SmtpServer: . (End of data)\n    SmtpServer-->>SmtpT: OK, Queued (250)\n    SmtpT->>SmtpServer: QUIT\n    SmtpServer-->>SmtpT: Bye (221)\n    SmtpT->>UserCode: Return Ok(SmtpResponse)\n```\n\n----------------------------------------\n\nTITLE: Defining the Transport Trait Interface in Rust\nDESCRIPTION: This Rust snippet defines the conceptual Transport trait used in lettre. It specifies associated types Ok and Error representing the success and failure types for sending operations. The trait requires the implementation of a send method that takes a reference to a Message and returns a Result indicating success or failure. This trait acts as a uniform contract for all email transport mechanisms compatible with lettre.\nSOURCE: https://github.com/6p5ra/lettre-docs/blob/main/lettre.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub trait Transport {\n    type Ok; // Type returned on success\n    type Error; // Type returned on failure\n\n    // The main method: takes a message and tries to send it\n    fn send(&self, message: &Message) -> Result<Self::Ok, Self::Error>;\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling native-tls Backend for Lettre in Cargo.toml\nDESCRIPTION: Shows how to configure the `Cargo.toml` file to enable the `native-tls` backend for the `lettre` crate. This feature flag instructs `lettre` to use the operating system's native TLS library for secure connections (like SChannel, Secure Transport, or OpenSSL). The `smtp-transport` and `builder` features are also included as prerequisites for using `SmtpTransport`. Async features like `tokio1-native-tls` can be added if asynchronous operations are needed.\nSOURCE: https://github.com/6p5ra/lettre-docs/blob/main/lettre.md#_snippet_14\n\nLANGUAGE: toml\nCODE:\n```\nlettre = { version = \"0.11\", features = [\"smtp-transport\", \"builder\", \"native-tls\"] }\n```\n\n----------------------------------------\n\nTITLE: Enabling rustls Backend for Lettre in Cargo.toml\nDESCRIPTION: Shows an example of configuring the `Cargo.toml` file to enable the `rustls` backend for the `lettre` crate, using `ring` as the crypto provider and `webpki-roots` for certificate verification. This setup utilizes a pure-Rust TLS implementation. The `smtp-transport` and `builder` features are included. Note that the specific required features for `rustls` might vary (e.g., `aws-lc-rs` could be an alternative crypto provider), and async features like `tokio1-rustls` might be needed. The text indicates that `rustls-tls` is being deprecated in favor of `rustls`.\nSOURCE: https://github.com/6p5ra/lettre-docs/blob/main/lettre.md#_snippet_15\n\nLANGUAGE: toml\nCODE:\n```\nlettre = { version = \"0.11\", features = [\"smtp-transport\", \"builder\", \"rustls\", \"ring\", \"webpki-roots\"] }\n```\n\n----------------------------------------\n\nTITLE: Sequence Diagram Explaining Internal Processing of .send() Method in lettre (Mermaid)\nDESCRIPTION: This Mermaid sequence diagram visually represents the high-level internal flow of the .send() method as called on a FileTransport instance. It shows interactions between user code, Message construction, the Transport trait interface, the FileTransport implementation, and the local filesystem. The diagram clarifies how the email message is created, how send is called, how formatting and writing occurs, and how success or failure results are returned back to the caller.\nSOURCE: https://github.com/6p5ra/lettre-docs/blob/main/lettre.md#_snippet_6\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant UserCode as Your Code\n    participant Message as Message Object\n    participant TransportTrait as Transport Trait (.send())\n    participant FileTransport as FileTransport Implementation\n    participant FileSystem as Local File System\n\n    UserCode->>Message: Create email content\n    UserCode->>FileTransport: Create FileTransport instance (`mailer`)\n    UserCode->>TransportTrait: Call `mailer.send(&email)`\n    TransportTrait->>FileTransport: Execute `FileTransport::send`\n    FileTransport->>Message: Get email content (headers, body)\n    FileTransport->>FileTransport: Format content into RFC 5322 text\n    FileTransport->>FileSystem: Write formatted text to a .eml file\n    FileSystem-->>FileTransport: Confirm success/failure\n    FileTransport-->>TransportTrait: Return Result (Ok/Err)\n    TransportTrait-->>UserCode: Return Result to your code\n```\n\n----------------------------------------\n\nTITLE: STARTTLS Handshake Sequence Diagram - Mermaid\nDESCRIPTION: This Mermaid diagram illustrates the STARTTLS handshake process between an application (using lettre), the SmtpTransport, a TLS backend (native-tls/rustls), and the SMTP server. It visualizes the sequence of messages and the transition from an unencrypted to an encrypted connection.\nSOURCE: https://github.com/6p5ra/lettre-docs/blob/main/lettre.md#_snippet_17\n\nLANGUAGE: Mermaid\nCODE:\n```\nsequenceDiagram\n    participant App as Your App (using lettre)\n    participant Lettre as SmtpTransport\n    participant TlsLib as TLS Backend (native-tls/rustls)\n    participant Server as SMTP Server\n\n    App->>Lettre: mailer.send(&email)\n    Lettre->>Server: Connect (e.g., Port 587, unencrypted)\n    Server-->>Lettre: Welcome (220)\n    Lettre->>Server: EHLO mydomain.com\n    Server-->>Lettre: Capabilities (250 ..., STARTTLS, ...)\n    Note over Lettre,Server: Connection is still unencrypted\n    Lettre->>Server: STARTTLS\n    Server-->>Lettre: Ready to start TLS (220)\n    Note over Lettre,Server: Initiate TLS Handshake\n    Lettre->>TlsLib: Start TLS Handshake\n    TlsLib->>Server: TLS ClientHello\n    Server-->>TlsLib: TLS ServerHello, Certificate, etc.\n    TlsLib->>Server: TLS Key Exchange, etc.\n    Server-->>TlsLib: TLS Finished\n    TlsLib-->>Lettre: TLS Handshake Successful!\n    Note over Lettre,Server: Connection is NOW Encrypted!\n    Lettre->>Server: AUTH LOGIN (over encrypted channel)\n    Server-->>Lettre: Ask for Username (encrypted)\n    Lettre->>Server: Send Username (encrypted)\n    Server-->>Lettre: Ask for Password (encrypted)\n    Lettre->>Server: Send Password (encrypted)\n    Server-->>Lettre: Authentication Successful (235, encrypted)\n    Lettre->>Server: MAIL FROM, RCPT TO, DATA (encrypted)\n    Server-->>Lettre: OK (250, encrypted)\n    Lettre-->>App: Ok(response)\n```\n\n----------------------------------------\n\nTITLE: Visualizing SMTP AUTH LOGIN Flow with Lettre\nDESCRIPTION: A sequence diagram illustrating the step-by-step interaction between an application using `lettre`, the `SmtpTransport`, and an SMTP server during the `AUTH LOGIN` authentication process. It shows the commands exchanged, including the base64 encoding of username and password, and the final success response before email transmission begins. This clarifies the communication sequence handled internally by `lettre` when credentials are provided.\nSOURCE: https://github.com/6p5ra/lettre-docs/blob/main/lettre.md#_snippet_12\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant YourApp as Your App\n    participant Lettre as SmtpTransport\n    participant SmtpServer as SMTP Server\n\n    YourApp->>Lettre: transport.send(&message)\n    Lettre->>SmtpServer: Connect & EHLO\n    SmtpServer-->>Lettre: Announce capabilities (e.g., AUTH LOGIN PLAIN)\n    Note over Lettre,SmtpServer: (TLS encryption usually established here)\n    Lettre->>SmtpServer: AUTH LOGIN\n    SmtpServer-->>Lettre: 334 VXNlcm5hbWU6 (Ask for Username, base64)\n    Lettre->>SmtpServer: Send base64(username from Credentials)\n    SmtpServer-->>Lettre: 334 UGFzc3dvcmQ6 (Ask for Password, base64)\n    Lettre->>SmtpServer: Send base64(password from Credentials)\n    SmtpServer-->>Lettre: 235 Authentication successful\n    Note over Lettre,SmtpServer: Authentication done, proceed to send email...\n    Lettre->>SmtpServer: MAIL FROM, RCPT TO, DATA...\n    SmtpServer-->>Lettre: 250 OK\n    Lettre-->>YourApp: Ok(SmtpResponse)\n```"
  }
]