[
  {
    "owner": "crossterm-rs",
    "repo": "crossterm",
    "content": "TITLE: Basic Terminal Styling with Crossterm\nDESCRIPTION: A Rust example demonstrating how to style terminal output using Crossterm. The code shows two equivalent methods to set text colors, print styled text, and reset styling - one using the execute! macro and another using method chaining.\nSOURCE: https://github.com/crossterm-rs/crossterm/blob/master/README.md#2025-04-23_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::io::{stdout, Write};\n\nuse crossterm:{\n    execute,\n    style::{Color, Print, ResetColor, SetBackgroundColor, SetForegroundColor},\n    ExecutableCommand,\n    event,\n};\n\nfn main() -> std::io::Result<()> {\n    // using the macro\n    execute!(\n        stdout(),\n        SetForegroundColor(Color::Blue),\n        SetBackgroundColor(Color::Red),\n        Print(\"Styled text here.\"),\n        ResetColor\n    )?;\n\n    // or using functions\n    stdout()\n        .execute(SetForegroundColor(Color::Blue))?\n        .execute(SetBackgroundColor(Color::Red))?\n        .execute(Print(\"Styled text here.\"))?\n        .execute(ResetColor)?;\n    \n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Crossterm Wrapper\nDESCRIPTION: Shows how to use the Crossterm wrapper to manage Context and access the different modules in a more intuitive way.\nSOURCE: https://github.com/crossterm-rs/crossterm/blob/master/CHANGELOG.md#2025-04-23_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet crossterm = Crossterm::new();\nlet color = crossterm.color();\nlet cursor = crossterm.cursor();\nlet terminal = crossterm.terminal();\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Context in Crossterm\nDESCRIPTION: Demonstrates how to create a Context instance and use it to access different Crossterm modules like cursor, terminal, and color.\nSOURCE: https://github.com/crossterm-rs/crossterm/blob/master/CHANGELOG.md#2025-04-23_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet context = Context::new();\n\nlet cursor = cursor(&context);\nlet terminal = terminal(&context);\nlet color = color(&context);\n```\n\n----------------------------------------\n\nTITLE: Configuring Crossterm in Cargo.toml\nDESCRIPTION: Basic Cargo.toml configuration for adding Crossterm as a dependency to a Rust project. This specifies version 0.27 of the library.\nSOURCE: https://github.com/crossterm-rs/crossterm/blob/master/README.md#2025-04-23_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ncrossterm = \"0.27\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Crossterm with Feature Flags\nDESCRIPTION: Cargo.toml configuration showing how to enable optional features in Crossterm. This example enables the 'event-stream' feature which provides a futures::Stream for events.\nSOURCE: https://github.com/crossterm-rs/crossterm/blob/master/README.md#2025-04-23_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies.crossterm]\nversion = \"0.27\"\nfeatures = [\"event-stream\"]\n```\n\n----------------------------------------\n\nTITLE: Creating AlternateScreen from Crossterm\nDESCRIPTION: Shows how to create an alternate screen instance using the Crossterm wrapper and write to it.\nSOURCE: https://github.com/crossterm-rs/crossterm/blob/master/CHANGELOG.md#2025-04-23_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n// create context.\nlet crossterm = ::crossterm::Crossterm::new();\n// create instance of Alternatescreen by the given reference to crossterm, this will also switch to it.\nlet mut screen = crossterm::AlternateScreen::from(&crossterm);\n// write to the alternate screen.\nwrite!(screen,  \"test\");\n```\n\n----------------------------------------\n\nTITLE: Creating AlternateScreen from Context\nDESCRIPTION: Demonstrates how to create an alternate screen instance from a Context object and write to it.\nSOURCE: https://github.com/crossterm-rs/crossterm/blob/master/CHANGELOG.md#2025-04-23_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n// create context.\nlet context = crossterm::Context::new();\n// create instance of Alternatescreen by the given context, this will also switch to it.\nlet mut screen = crossterm::AlternateScreen::from(context.clone());\n// write to the alternate screen.\nwrite!(screen,  \"test\");\n```\n\n----------------------------------------\n\nTITLE: Writing to stdout in Rust\nDESCRIPTION: Example showing how to write text to the standard output in Rust using the write! macro.\nSOURCE: https://github.com/crossterm-rs/crossterm/blob/master/CHANGELOG.md#2025-04-23_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nwrite!(std::io::stdout(), \"{}\", \"some text\")\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Import Order Standards in Rust\nDESCRIPTION: Shows the proper grouping and ordering of imports in Rust code according to project standards. Groups imports from standard library, external crates, current crate, parent module, and current module, with empty lines between groups.\nSOURCE: https://github.com/crossterm-rs/crossterm/blob/master/docs/CONTRIBUTING.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse crossterm_utils::{csi, write_cout, Result};\n\nuse crate::sys::{get_cursor_position, show_cursor};\n\nuse super::Cursor;\n```\n\n----------------------------------------\n\nTITLE: Running Crossterm Examples Using Cargo\nDESCRIPTION: Demonstrates how to run Crossterm examples using the Cargo package manager. Replace [file name] with the desired example file name.\nSOURCE: https://github.com/crossterm-rs/crossterm/blob/master/examples/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo run --example [file name]\n```\n\n----------------------------------------\n\nTITLE: Rust Result Type Example\nDESCRIPTION: Example showing the change in return type to use crossterm::Result for various API methods.\nSOURCE: https://github.com/crossterm-rs/crossterm/blob/master/CHANGELOG.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nTerminalCursor::pos() -> Result<(u16, u16)>\nTerminal::size() -> Result<(u16, u16)>\nTerminalCursor::move_* -> crossterm::Result\nExecutableCommand::queue -> crossterm::Result\nQueueableCommand::queue -> crossterm::Result\nRawScreen::into_raw_mode -> crossterm::Result\nRawScreen::disable_raw_mode -> crossterm::Result\nAlternateScreen::to_alternate -> crossterm::Result\nTerminalInput::read_line -> crossterm::Result\nTerminalInput::read_char -> crossterm::Result\n```\n\n----------------------------------------\n\nTITLE: Rust Method Renames\nDESCRIPTION: Examples of method name changes for improved clarity and consistency.\nSOURCE: https://github.com/crossterm-rs/crossterm/blob/master/CHANGELOG.md#2025-04-23_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nAsyncReader::stop_reading() -> stop()\nRawScreen::disable_raw_mode_on_drop -> keep_raw_mode_on_drop\nTerminalCursor::reset_position() -> restore_position()\nCommand::get_anis_code() -> ansi_code()\navailable_color_count -> available_color_count()\nTerminal::terminal_size -> Terminal::size\nConsole::get_handle -> Console::handle\n```\n\n----------------------------------------\n\nTITLE: Documenting WinAPI Issues in PowerShell and CMD\nDESCRIPTION: Lists known problems with PowerShell and CMD when using WinAPI commands. Issues include color interpretation, unexpected newline insertion, and color reset behavior in PowerShell.\nSOURCE: https://github.com/crossterm-rs/crossterm/blob/master/docs/know-problems.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## WinAPI\n\n- Power shell does not interpreter 'DarkYellow' and is instead using gray instead, cmd is working perfectly fine.\n- Power shell inserts an '\\n' (enter) when the program starts, this enter is the one you pressed when running the command.\n- After the program ran, power shell will reset the background and foreground colors.\n```\n\n----------------------------------------\n\nTITLE: Displaying Crossterm Examples Directory Structure\nDESCRIPTION: Shows the directory structure of the Crossterm examples folder, including the interactive-test, event-*, and stderr subdirectories.\nSOURCE: https://github.com/crossterm-rs/crossterm/blob/master/examples/README.md#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n├── examples\n│   └── interactive-test\n│   └── event-*\n│   └── stderr\n```\n\n----------------------------------------\n\nTITLE: Documenting UNIX Terminal Resizing Issues\nDESCRIPTION: Describes a problem with terminal resizing in specific UNIX environments (Arc and Manjaro KDE Konsole), where the buffer is resized instead of the terminal window.\nSOURCE: https://github.com/crossterm-rs/crossterm/blob/master/docs/know-problems.md#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n## UNIX-terminals\n\nThe Arc and Manjaro KDE Konsole's are not seeming to resize the terminal instead they are resizing the buffer.\n```"
  }
]