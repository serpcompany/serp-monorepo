[
  {
    "owner": "jesse-ai",
    "repo": "docs",
    "content": "TITLE: Position Sizing with Risk Management in Jesse AI (Python)\nDESCRIPTION: This example implements position sizing using risk management principles. It calculates position size based on risking 10% per trade with a maximum capital allocation of 25%. It uses Bollinger Bands for entry, stop-loss, and take-profit levels.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/example-strategies.md#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef go_long(self):  \n    stop = self.bb.lowerband\n    qty = self.position_size(self.price, stop)  \n    take_profit = self.bb.upperband\n    self.buy = qty, self.price  \n    self.stop_loss = qty, stop  \n    self.take_profit = qty, take_profit  \n  \n@property  \ndef position_size(self, entry, stop):  \n    # risk 10%\n    risk_qty = utils.risk_to_qty(self.balance, 10, entry, stop, fee_rate=self.fee_rate)  \n    # never risk more than 25% of the capital\n    max_qty = utils.size_to_qty(0.25 * self.balance, entry, precision=6, fee_rate=self.fee_rate)  \n    qty = min(risk_qty, max_qty) \n    return qty\n```\n\n----------------------------------------\n\nTITLE: Executing a Backtest with Generated Candles in Python\nDESCRIPTION: Complete example showing how to generate test candles, define a basic strategy class, prepare configuration inputs, and execute a backtest in Jesse AI. The example includes accessing the results like metrics, charts, and logs.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/research/backtest.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# imports\nimport jesse.helpers as jh\nfrom jesse.strategies import Strategy\nfrom jesse import utils\nfrom jesse.research import backtest, candles_from_close_prices\n\n# generate fake candles\nprices01 = [10, 11, 12, 12, 11, 13, 14, 12, 11, 15]\nfake_candles01 = candles_from_close_prices(prices01)\n\n# strategy\nclass ResearchStrategy(Strategy):\n    def should_long(self):\n        return True\n\n    def should_short(self):\n        return False\n\n    def should_cancel_entry(self):\n        return True\n\n    def go_long(self):\n        entry_price = self.price\n        qty = utils.size_to_qty(self.balance * 0.5, entry_price)\n        self.buy = qty, entry_price\n\n    def go_short(self):\n        pass\n\n# prepare inputs\nexchange_name = 'Fake Exchange'\nsymbol = 'BTC-USDT'\ntimeframe = '4h'\nconfig = {\n    'starting_balance': 10_000,\n    'fee': 0,\n    'type': 'futures',\n    'futures_leverage': 2,\n    'futures_leverage_mode': 'cross',\n    'exchange': exchange_name,\n    'warm_up_candles': 0\n}\nroutes = [\n    {'exchange': exchange_name, 'strategy': ResearchStrategy, 'symbol': symbol, 'timeframe': timeframe}\n]\nextra_routes = []\ncandles = {\n    jh.key(exchange_name, symbol): {\n        'exchange': exchange_name,\n        'symbol': symbol,\n        'candles': fake_candles01,\n    },\n}\n\n# execute backtest\nresult = backtest(\n    config,\n    routes,\n    extra_routes,\n    candles,\n    generate_charts=True\n)\n# access the metrics dict:\nresult['metrics']\n# access the charts string (path of the generated file):\nresult['charts']\n# access the logs list:\nresult['logs']\n```\n\n----------------------------------------\n\nTITLE: Implementing ATR-Based Trailing Stop-Loss in Jesse AI (Python)\nDESCRIPTION: This code updates the stop-loss level dynamically based on the current price when in profit. For long positions, it sets the stop-loss 2 ATR units below the current price, and for short positions, 2 ATR units above.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/example-strategies.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef update_position(self):  \n    # update trailing_stop_loss only if in profit  \n    if self.position.pnl > 0:  \n        if self.is_long:  \n            self.stop_loss = self.position.qty, self.price - self.atr * 2  \n        else:  \n            self.stop_loss = self.position.qty, self.price + self.atr * 2\n```\n\n----------------------------------------\n\nTITLE: Example of Multiple Entry Points in go_long() for Jesse AI\nDESCRIPTION: This example shows how to set multiple entry points for a long trade using a list of tuples. It splits the quantity between two price levels.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/entering-and-exiting.md#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef go_long():\n    qty = 1\n\n    # open position at $120 and increase it at $140\n    self.buy = [\n        (qty/2, 120),\n        (qty/2, 140)\n    ]\n    self.stop_loss = qty, 100\n    self.take_profit = qty, 160\n```\n\n----------------------------------------\n\nTITLE: Implementing Bollinger Bands Price Crossover in Jesse AI (Python)\nDESCRIPTION: This code implements a property to detect when price crosses above the Bollinger Bands middle band. It compares the current price with the middle band and checks if the previous candle was below the previous middle band value.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/example-strategies.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@property  \ndef long_cross(self):  \n    return self.price > self.bb.middleband[-1] and self.candles[:, 2][-2] <= self.bb.middleband[-2]  \n  \n@property  \ndef bb(self):  \n    return ta.bollinger_bands(self.candles, sequential=True)\n```\n\n----------------------------------------\n\nTITLE: Calculating Moving Averages in Python\nDESCRIPTION: Computes various types of Moving Averages based on the specified parameters. It takes candle data, period, moving average type, and source type as inputs.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_79\n\nLANGUAGE: python\nCODE:\n```\nma(candles: np.ndarray, period: int = 30, matype: int = 0,  source_type: str = \"close\", sequential: bool = False) -> Union[float, np.ndarray]:\n```\n\n----------------------------------------\n\nTITLE: Implementing SuperTrend Indicator in Python\nDESCRIPTION: This function computes the SuperTrend indicator, a trend-following tool based on average true range (ATR). It plots a line above or below the price to indicate bullish or bearish trends, providing potential entry and exit signals.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_134\n\nLANGUAGE: python\nCODE:\n```\nsupertrend(candles: np.ndarray, period=10, factor=3, sequential=False) -> SuperTrend\n```\n\n----------------------------------------\n\nTITLE: Implementing Modified Inverse Fisher Transform RSI in Python\nDESCRIPTION: This function applies the Modified Inverse Fisher Transform to RSI values to create a more normalized distribution. It improves RSI effectiveness by reducing noise and providing clearer signals for identifying overbought and oversold market conditions.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_63\n\nLANGUAGE: python\nCODE:\n```\nift_rsi(candles: np.ndarray, rsi_period: int = 5, wma_period: int =9, source_type: str = \"close\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Williams %R in Python\nDESCRIPTION: Calculates Williams %R momentum indicator for identifying overbought and oversold conditions.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_165\n\nLANGUAGE: python\nCODE:\n```\nwillr(candles: np.ndarray, period=14, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Limiting Stop Loss Based on Risk Percentage\nDESCRIPTION: Adjusts the stop-loss price to ensure it doesn't exceed the maximum allowed risk percentage. Prevents setting stop losses that would risk more than the specified percentage.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/utils.md#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nlimit_stop_loss(entry_price, stop_price, trade_type, max_allowed_risk_percentage)\n```\n\n----------------------------------------\n\nTITLE: Implementing go_long() Method in Python for Jesse AI\nDESCRIPTION: This method sets the buy price, quantity, stop-loss, and take-profit for a long position. It demonstrates the basic syntax for entering a long trade.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/entering-and-exiting.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef go_long(self):\n    self.buy = qty, entry_price\n    self.stop_loss = qty, stop_loss_price\n    self.take_profit = qty, take_profit_price\n```\n\n----------------------------------------\n\nTITLE: Position Management with PNL Example\nDESCRIPTION: Shows how to update stop-loss to breakeven when position reaches certain profit level.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/api.md#2025-04-23_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef update_position(self):\n    if self.position.pnl_percentage >= 10:\n        self.stop_loss = self.position.qty, self.position.entry_price\n```\n\n----------------------------------------\n\nTITLE: Bollinger Bands Calculation in Python\nDESCRIPTION: Calculates Bollinger Bands using SMA and standard deviations to measure volatility and identify market conditions.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nbollinger_bands(candles: np.ndarray, period=20, devup=2, devdn=2, matype=0, devtype=0, source_type=\"close\", sequential=False) -> BollingerBands\n```\n\n----------------------------------------\n\nTITLE: Implementing Market Facilitation Index (MFI) in Python\nDESCRIPTION: Market Facilitation Index function developed by Bill Williams that measures the ease of price movement based on changes in volume. Calculates the ratio of price range to volume to identify periods of low liquidity, consolidation, and potential breakouts.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_84\n\nLANGUAGE: python\nCODE:\n```\nmarketfi(candles: np.ndarray, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing ATR-Based Stop-Loss and Take-Profit in Jesse AI (Python)\nDESCRIPTION: This code sets up a long position with stop-loss and take-profit levels calculated using the Average True Range (ATR) indicator. The take-profit is set 3 ATR units above entry, while stop-loss is 2 ATR units below.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/example-strategies.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef go_long(self):  \n    take_profit = self.price + self.atr * 3  \n    stop = self.price - self.atr * 2  \n    qty = 10\n    self.buy = qty, self.price  \n    self.stop_loss = qty, stop  \n    self.take_profit = qty, take_profit  \n  \n  \n@property  \ndef atr(self):  \n    return ta.atr(self.candles, period=22)\n```\n\n----------------------------------------\n\nTITLE: Handling Position Close Events in Python (Jesse Framework)\nDESCRIPTION: Demonstrates how to handle position closing events by detecting whether the position was closed due to take-profit or stop-loss orders.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/events.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef on_close_position(self, order):\n    if order.is_take_profit:\n        self.log(\"Take-profit closed the position\")\n    elif order.is_stop_loss:\n        self.log(\"Stop-loss closed the position\")\n```\n\n----------------------------------------\n\nTITLE: Accessing and Using Current Candle Data in Jesse AI\nDESCRIPTION: This snippet demonstrates how to access the current candle data in a Jesse AI strategy. The current_candle property returns a numpy array containing timestamp, open, close, high, low, and volume values that can be individually accessed.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/api.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pprint import pprint\n\npprint(self.current_candle)\n# array([1.54638714e+12, 3.79409000e+03, 3.79714000e+03, 3.79800000e+03,\n#        3.79400000e+03, 1.30908000e+02])\n\npprint(self.current_candle.dtype)\n# dtype('float64')\n```\n\n----------------------------------------\n\nTITLE: Multi-Symbol Position Management\nDESCRIPTION: Example of accessing positions for multiple trading pairs in a strategy.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/api.md#2025-04-23_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# assuming that I have two trading routes, one for BTC-USDT and one for ETH-USDT\nbtc_position = self.all_positions['BTC-USDT']\neth_position = self.all_positions['ETH-USDT']\n```\n\n----------------------------------------\n\nTITLE: Using atr (Average True Range) in Jesse AI\nDESCRIPTION: The Average True Range measures volatility by calculating the average of true ranges over a specified period, providing insight into price movement magnitude and potential trend changes.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\natr(candles: np.ndarray, period=14, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Calculating Directional Movement (dm) for Trend Analysis in Python\nDESCRIPTION: A concept in technical analysis that quantifies the strength and direction of price movements, comparing upward and downward price movements to determine the prevailing trend direction and strength.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_36\n\nLANGUAGE: python\nCODE:\n```\ndm(candles: np.ndarray, period=14, sequential=False) -> DM\n```\n\n----------------------------------------\n\nTITLE: Initializing AwesomeStrategy Class in Python for Jesse AI\nDESCRIPTION: This code snippet shows the basic structure of a strategy class in Jesse AI. It includes methods for determining long and short positions, entry cancellation, and executing long and short trades. The class inherits from the Strategy base class and imports necessary modules.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/generating-new-strategy.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom jesse.strategies import Strategy\nfrom jesse import utils\nimport jesse.indicators as ta\n\n\nclass AwesomeStrategy(Strategy):\n    def should_long(self):\n        return False\n\n    def should_short(self):\n        return False\n\n    def should_cancel_entry(self):\n        return False\n\n    def go_long(self):\n        pass\n\n    def go_short(self):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Managing Stop Loss After Partial Position Exit in Python (Jesse Framework)\nDESCRIPTION: Shows how to implement a break-even stop loss after partially taking profit on a position.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/events.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef go_long(self):\n    self.buy = 2, 100\n    # take-profit in two points\n    self.take_profit = [\n        (1, 120), \n        (1, 140)\n    ]\n\ndef on_reduced_position(self, order):\n    self.stop_loss = 1, 100\n```\n\n----------------------------------------\n\nTITLE: Using average_entry_price in Trading Strategy Filters\nDESCRIPTION: This example shows how to use the average_entry_price property in a filter function to ensure minimum potential profit percentage. The code demonstrates calculating entry prices with multiple orders and using those values to determine if a trade meets profitability criteria.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/api.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef go_long(self):\n    qty = 2\n\n    # self.average_entry_price is equal to (100 + 120) / 2 == 110\n    self.buy = [\n        (1, 100),\n        (1, 120)\n    ]\n    self.stop_loss = qty, 80\n    self.take_profit = qty, 140\n\ndef filter_min_pnl(self):\n    min_pnl = 1\n    reward_per_qty = abs(self.average_take_profit - self.average_entry_price)\n    return (reward_per_qty / self.average_entry_price) * 100 > min_pnl\n```\n\n----------------------------------------\n\nTITLE: Example of Multiple Take-Profit Points in go_long() for Jesse AI\nDESCRIPTION: This example demonstrates how to set multiple take-profit points in a long trade using a list of tuples. It divides the quantity between two price levels.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/entering-and-exiting.md#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef go_long():\n    qty = 1\n\n    self.buy = qty, 100\n    self.stop_loss = qty, 80\n\n    # take-profit at two points\n    self.take_profit = [\n        (qty/2, 120),\n        (qty/2, 140)\n    ]\n```\n\n----------------------------------------\n\nTITLE: Example of go_short() Implementation in Python for Jesse AI\nDESCRIPTION: This is a working example of the go_short() method, setting specific values for quantity, entry price, stop-loss, and take-profit based on current market conditions.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/entering-and-exiting.md#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef go_short(self):\n    qty = 1\n\n    # opens position with a MARKET order\n    self.sell = qty, self.price\n    self.stop_loss = qty, self.high + 10\n    self.take_profit = qty, self.low - 10\n```\n\n----------------------------------------\n\nTITLE: Conditionally Increasing Position Size Using Momentum\nDESCRIPTION: This example shows how to conditionally increase position size in a strategy based on momentum. It uses the update_position method to add to a long position when momentum exceeds a threshold.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/api.md#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef update_position(self):\n    # momentum_rank being a method you've defined somewhere that\n    # examines the momentum of the current trend or something\n    if self.momentum_rank > 100:\n        if self.is_long:\n            # buy qty of 1 for the current price (MARKET order)\n            self.buy = 1, self.price\n```\n\n----------------------------------------\n\nTITLE: Calculating Linear Regression Slope in Python\nDESCRIPTION: Computes the Linear Regression Slope, which helps identify potential trends in price movements. It takes candle data, period, and source type as inputs.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_77\n\nLANGUAGE: python\nCODE:\n```\nlinearreg_slope(candles: np.ndarray, period=14, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Using apo (Absolute Price Oscillator) in Jesse AI\nDESCRIPTION: The Absolute Price Oscillator measures the difference between two moving averages, providing insights into trend direction and strength by analyzing changes in absolute price values.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\napo(candles: np.ndarray, fast_period=12, slow_period=26, matype=0, source_type=\"close\", sequential=False) -> Union[\n  float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing update_position() to Increase Position Size in Python for Jesse AI\nDESCRIPTION: This method shows how to double the size of a long position if certain conditions are met, such as being in profit and RSI showing oversold conditions.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/entering-and-exiting.md#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef update_position(self):\n    if self.is_long:\n        if self.position.pnl_percentage > 5 and ta.rsi(self.candles) < 30:\n            # double the size of the already open position at current price (with a MARKET order)\n            self.buy = self.position.qty, self.price\n```\n\n----------------------------------------\n\nTITLE: Example of go_long() Implementation in Python for Jesse AI\nDESCRIPTION: This is a working example of the go_long() method, setting specific values for quantity, entry price, stop-loss, and take-profit based on current market conditions.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/entering-and-exiting.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef go_long(self):\n    qty = 1\n\n    self.buy = qty, self.price\n    self.stop_loss = qty, self.low - 10\n    self.take_profit = qty, self.high + 10\n```\n\n----------------------------------------\n\nTITLE: Candlestick Pattern Trading Example\nDESCRIPTION: Demonstrates how to create a simple bullish candlestick pattern trading strategy.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/api.md#2025-04-23_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndef should_long(self):\n    # go long if current candle is bullish\n    if self.close > self.open:\n        return True\n\n    return False\n```\n\n----------------------------------------\n\nTITLE: Using Moving Average for Trade Exit in Jesse AI (Python)\nDESCRIPTION: This code demonstrates how to exit a long position when the price falls below a specified EMA (Exponential Moving Average). It uses the update_position method to check conditions on each candle update.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/example-strategies.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef update_position(self):  \n    if self.is_long and self.price <= self.exit_ema:  \n       self.liquidate()  \n       \n@property  \ndef exit_ema(self):  \n    return ta.ema(self.candles)\n```\n\n----------------------------------------\n\nTITLE: Price-Based Entry Strategy Example\nDESCRIPTION: Shows how to use candle low and high prices to set entry and stop-loss levels.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/api.md#2025-04-23_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndef go_long(self):\n    qty = 1\n\n    # open position at 2 dollars above current candle's low\n    self.buy = qty, self.high + 2\n\n    # stop-loss at 2 dollars below current candle's low\n    self.buy = qty, self.low - 2\n```\n\n----------------------------------------\n\nTITLE: Kelly Criterion for Position Sizing in Jesse AI (Python)\nDESCRIPTION: This code implements the Kelly Criterion for optimal position sizing based on historical performance metrics. It uses win rate and average win/loss ratios (either from strategy metrics or default values) to calculate the optimal risk percentage for each trade.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/example-strategies.md#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef kelly_qty(self, entry, stop):  \n    if not self.metrics or self.metrics['total'] < 20:  \n        win_rate = 0.46  \n        avg_win_ratio = 1.1\n        avg_loss_ratio = 0.5\n    else:  \n        win_rate = self.metrics['win_rate']  \n        avg_win_ratio = self.metrics['avg_win_percentage'] / 100\n        avg_loss_ratio = self.metrics['avg_loss_percentage'] / 100\n    kc = utils.kelly_criterion(win_rate, avg_win_ratio, avg_loss_ratio) * 100  \n    if not kc or kc <= 0:  \n        raise ValueError(\"Bad Kelly criterion.\")  \n    risk_qty = utils.risk_to_qty(self.available_margin, kc, entry, stop, self.fee_rate)  \n    # never risk more than 25%  \n    max_qty = utils.size_to_qty(0.25 * self.available_margin, entry, precision=6, fee_rate=self.fee_rate)  \n    qty = min(risk_qty, max_qty)  \n    return qty\n```\n\n----------------------------------------\n\nTITLE: Using alma (Arnaud Legoux Moving Average) in Jesse AI\nDESCRIPTION: The Arnaud Legoux Moving Average adjusts sensitivity based on market volatility to reduce lag and provide smoother trend signals by incorporating a variable smoothing factor calculated from Gaussian distribution.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nalma(candles: np.ndarray, period: int = 9, sigma: float = 6.0, distribution_offset: float = 0.85, source_type: str = \"close\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: TTM Squeeze Indicator in Python\nDESCRIPTION: Identifies potential squeeze situations in the market by combining Bollinger Bands and Keltner Channels. It detects when volatility is decreasing, indicating a potential breakout. Authored by daviddtech. Requires numpy for array operations.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_145\n\nLANGUAGE: python\nCODE:\n```\nttm_squeeze(candles: np.ndarray, length_ttms: int = 20, bb_mult_ttms: float = 2.0, kc_mult_low_ttms: float = 2.0) -> bool\n```\n\n----------------------------------------\n\nTITLE: Implementing Moving Average Convergence Divergence (MACD) in Python\nDESCRIPTION: MACD momentum indicator function that calculates the difference between short-term and long-term exponential moving averages. Returns the MACD line, signal line, and histogram for identifying bullish/bearish momentum, trend reversals, and price divergence.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_82\n\nLANGUAGE: python\nCODE:\n```\nmacd(candles: np.ndarray, fast_period=12, slow_period=26, signal_period=9, source_type=\"close\", sequential=False) -> MACD\n```\n\n----------------------------------------\n\nTITLE: Position Size Reduction Strategy\nDESCRIPTION: Example of implementing a trailing take-profit after partial position exit.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/api.md#2025-04-23_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ndef go_long(self):\n    self.buy = 1, self.price\n    self.stop_loss = 1, self.price - 10\n    self.take_profit = [\n        (0.5, self.price + 10),\n        (0.5, self.price + 20)\n    ]\n\ndef update_position(self):\n    # even though we have especified the exit price\n    # for the second half, we now updated to exit with SMA20\n    if self.reduced_count > 0:\n        self.take_profit = 0.5, self.SMA20\n\n@property\ndef SMA20(self):\n    return ta.sma(self.candles, 20)\n```\n\n----------------------------------------\n\nTITLE: RSI (Relative Strength Index) Implementation in Python\nDESCRIPTION: Calculates the Relative Strength Index, a momentum oscillator that measures the speed and change of price movements on a scale from 0 to 100. Used to identify overbought or oversold conditions and potential trend reversals.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_113\n\nLANGUAGE: python\nCODE:\n```\nrsi(candles: np.ndarray, period=14, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Ichimoku Cloud Indicator in Python\nDESCRIPTION: This function calculates the Ichimoku Cloud (Ichimoku Kinko Hyo), a versatile technical indicator that provides insights into trend direction, momentum, and potential support/resistance levels. It returns components including conversion line, base line, span A, and span B.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_61\n\nLANGUAGE: python\nCODE:\n```\nichimoku_cloud(candles: np.ndarray, conversion_line_period=9, base_line_period=26, lagging_line_period=52, displacement=26) -> IchimokuCloud\n```\n\n----------------------------------------\n\nTITLE: Implementing should_long() Method in Python for Jesse AI\nDESCRIPTION: This method determines whether to open a long position based on the current candle being bullish. It returns True if the closing price is higher than the opening price.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/entering-and-exiting.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef should_long(self):\n    # return true if current candle is a bullish candle\n    if self.close > self.open:\n        return True\n\n    return False\n```\n\n----------------------------------------\n\nTITLE: Creating an Automated Backtest Execution Function in Python\nDESCRIPTION: A production-ready function that automates the process of executing backtests for strategy evaluation. It retrieves candles data, sets up routes, and executes the backtest with multiple output options enabled. The function also prints the result as a JSON string.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/research/backtest.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef execute_strategy(\n        strategy_name: str,\n        exchange_name: str,\n        symbol: str,\n        timeframe: str,\n        config: dict,\n        start_date_str: str,\n        finish_date_str: str\n):\n    warmup_candles, trading_candles = get_candles(\n        exchange_name, symbol, timeframe, jh.date_to_timestamp(start_date_str), jh.date_to_timestamp(finish_date_str),\n        config['warm_up_candles'], caching=True, is_for_jesse=True\n    )\n\n    routes = [\n        {'exchange': exchange_name, 'strategy': strategy_name, 'symbol': symbol, 'timeframe': timeframe}\n    ]\n\n    trading_candles = {\n        jh.key(exchange_name, symbol): {\n            'exchange': exchange_name,\n            'symbol': symbol,\n            'candles': trading_candles,\n        },\n    }\n    warmup_candles = {\n        jh.key(exchange_name, symbol): {\n            'exchange': exchange_name,\n            'symbol': symbol,\n            'candles': warmup_candles,\n        },\n    }\n\n    # Execute backtest\n    result = backtest(\n        config,\n        routes,\n        [],\n        candles=trading_candles,\n        warmup_candles=warmup_candles,\n        generate_charts=True,\n        generate_equity_curve=True,\n        generate_csv=True,\n        generate_json=True,\n        generate_logs=True,\n        fast_mode=True\n    )\n\n    # Print result as a JSON string\n    print(json.dumps(result, ignore_nan=True, cls=NpEncoder))\n```\n\n----------------------------------------\n\nTITLE: Implementing Gaussian Filter in Python\nDESCRIPTION: Function that applies a Gaussian Filter to smooth out noise and extract underlying trends from price data by applying a bell-shaped curve weighting to data points, with more emphasis on central points.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_54\n\nLANGUAGE: python\nCODE:\n```\ngauss(candles: np.ndarray, period=14, poles=4, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Variable Index Dynamic Average (VIDYA) in Python for Trend Analysis\nDESCRIPTION: Function to calculate VIDYA, a moving average that adjusts sensitivity based on market volatility. It provides smoother and more responsive results compared to traditional moving averages.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_151\n\nLANGUAGE: python\nCODE:\n```\nvidya(candles: np.ndarray, length: int = 9, fix_cmo: bool = True, select: bool = True, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing update_position() with Trailing Stop in Python for Jesse AI\nDESCRIPTION: This method updates the take-profit price dynamically using a trailing stop. It sets the take-profit $10 away from the high/low of the current candle.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/entering-and-exiting.md#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef update_position(self):\n    qty = self.position.qty \n\n    # set stop-loss price $10 away from the high/low of the current candle\n    if self.is_long:\n        self.take_profit = qty, self.high - 10\n    else:\n        self.take_profit = qty, self.low + 10\n```\n\n----------------------------------------\n\nTITLE: Accessing Candles from Different Timeframes with get_candles\nDESCRIPTION: This example demonstrates how to use the get_candles method to access candle data from different exchanges, symbols, or timeframes than the current trading route. It implements a big_trend property using SRSI on a daily timeframe.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/api.md#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@property\ndef big_trend(self):\n    \"\"\"\n    Uses the SRSI indicator to determine the bigger trend of the market.\n    The trading timeframe is \"4h\" so we use \"1D\" timeframe as the anchor timeframe.\n    \"\"\"\n    k, d = ta.srsi(self.get_candles(self.exchange, self.symbol, '1D'))\n\n    if k > d:\n        return 1\n    elif k < d:\n        return -1\n    else:\n        return 0\n```\n\n----------------------------------------\n\nTITLE: Implementing Stochastic Oscillator in Python\nDESCRIPTION: This function computes the Stochastic Oscillator, a momentum indicator for identifying overbought and oversold conditions. It returns %K and %D lines to signal potential market reversals.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_129\n\nLANGUAGE: python\nCODE:\n```\nstoch(candles: np.ndarray, fastk_period=14, slowk_period=3, slowk_matype=0, slowd_period=3, slowd_matype=0, sequential=False) -> Stochastic\n```\n\n----------------------------------------\n\nTITLE: SMA (Simple Moving Average) Implementation in Python\nDESCRIPTION: Calculates the arithmetic mean of prices over a specified period. This fundamental technical indicator smooths price data to identify trends by averaging a set number of previous price points.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_121\n\nLANGUAGE: python\nCODE:\n```\nsma(candles: np.ndarray, period=5, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing should_short() Method in Python for Jesse AI\nDESCRIPTION: This method determines whether to open a short position based on the current candle being bearish. It returns True if the closing price is lower than the opening price.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/entering-and-exiting.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef should_short(self):\n    # return true if current candle is a bearish candle\n    if self.close < self.open:\n        return True\n\n    return False\n```\n\n----------------------------------------\n\nTITLE: Using Crossed Utility for Bollinger Bands Crossover in Jesse AI (Python)\nDESCRIPTION: An alternative implementation using Jesse's built-in 'crossed' utility function to detect when price crosses above the Bollinger Bands middle band, simplifying the crossover detection logic.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/example-strategies.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@property  \ndef long_cross(self):  \n    return utils.crossed(self.candles[:, 2], self.bb.middleband, 'above')  \n  \n@property  \ndef bb(self):  \n    return ta.bollinger_bands(self.candles, sequential=True)\n```\n\n----------------------------------------\n\nTITLE: Calculating Gator Oscillator in Python\nDESCRIPTION: Function that implements the Gator Oscillator developed by Bill M. Williams, used to identify trends and their strength through two histograms representing differences between components of the Alligator indicator.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_53\n\nLANGUAGE: python\nCODE:\n```\ngatorosc(candles: np.ndarray, source_type=\"close\", sequential=False) -> GATOR\n```\n\n----------------------------------------\n\nTITLE: Implementing Jurik Moving Average (JMA) in Python\nDESCRIPTION: This function calculates the Jurik Moving Average developed by Mark Jurik, which reduces lag and improves responsiveness compared to traditional moving averages. It uses advanced smoothing techniques with customizable period, phase, and power parameters.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_65\n\nLANGUAGE: python\nCODE:\n```\njma(candles: np.ndarray, period:int=7, phase:float=50, power:int=2, source_type:str='close', sequential:bool=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Hull Moving Average (HMA) in Python\nDESCRIPTION: This function calculates the Hull Moving Average (HMA), a weighted average of three different EMAs that reduces lag while maintaining smoothness. It's more responsive to recent price movements than traditional moving averages, making it useful for identifying trends and entry/exit points.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_58\n\nLANGUAGE: python\nCODE:\n```\nhma(candles: np.ndarray, period=5, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Enhanced Position Update Debugging with Logging in Python\nDESCRIPTION: Extended version of the position update method with added logging statements to track execution flow and variable values\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/debugging.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef update_position(self):\n    self.log(\n        f'pnl_percentage: {self.position.pnl_percentage}'\n    )\n\n    if self.position.pnl_percentage > 2:\n        self.log('if statement is True, liquidate is called')\n        self.liquidate()\n```\n\n----------------------------------------\n\nTITLE: Calculating Exponential Moving Average (EMA) in Python\nDESCRIPTION: Function that calculates the Exponential Moving Average, which places more weight on recent data points, making it more responsive to recent price changes compared to a simple moving average. It accepts candles data and returns the calculated EMA.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_43\n\nLANGUAGE: python\nCODE:\n```\nema(candles: np.ndarray, period=5, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing go_short() Method in Python for Jesse AI\nDESCRIPTION: This method sets the sell price, quantity, stop-loss, and take-profit for a short position. It demonstrates the basic syntax for entering a short trade.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/entering-and-exiting.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef go_short(self):\n    self.sell = qty, entry_price\n    self.stop_loss = qty, stop_loss_price\n    self.take_profit = qty, take_profit_price\n```\n\n----------------------------------------\n\nTITLE: Using High Price in Entry Logic\nDESCRIPTION: This example shows how to use the high property to access the current candle's high price in a strategy. It demonstrates setting a buy order at a price 2 units above the current candle's high.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/api.md#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef go_long(self):\n    qty = 1\n\n    # open position at 2 dollars above current candle's high\n    self.buy = qty, self.high + 2\n```\n\n----------------------------------------\n\nTITLE: Implementing watch_list() with Custom Properties in Jesse AI\nDESCRIPTION: Example implementation of the watch_list() method that returns a table of EMA values and trend direction. The method uses custom properties to calculate indicator values and displays them in the monitoring dashboard during live trading.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/api.md#2025-04-23_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n@property\ndef short_ema(self):\n    return ta.ema(self.candles, 50)\n\n@property\ndef long_ema(self):\n    return ta.ema(self.candles, 100)\n\ndef watch_list(self):\n    return [\n        ('Short EMA', self.short_ema),\n        ('Long EMA', self.long_ema),\n        ('Trend', 1 if self.short_ema > self.long_ema else -1),\n    ]\n```\n\n----------------------------------------\n\nTITLE: Beta Calculation in Python\nDESCRIPTION: Measures volatility in relation to a benchmark index by comparing price movements.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nbeta(candles: np.ndarray, benchmark_candles: np.ndarray, period: int = 5, sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Computing Pivot Points in Python\nDESCRIPTION: Function to calculate Pivot Points, which are used to identify potential support and resistance levels in trading. It takes candle data, mode, and a sequential flag as inputs, returning a PIVOT object with various support and resistance levels.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_101\n\nLANGUAGE: python\nCODE:\n```\npivot(candles: np.ndarray, mode=0, sequential=False) -> PIVOT\n```\n\n----------------------------------------\n\nTITLE: RVI (Relative Volatility Index) Implementation in Python\nDESCRIPTION: Calculates the Relative Volatility Index by comparing smoothed moving averages of positive and negative price changes. Used to measure directional volatility and potentially signal trend changes.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_116\n\nLANGUAGE: python\nCODE:\n```\nrvi(candles: np.ndarray, period: int = 10, ma_len: int = 14, matype: int = 1, devtype: int = 0, source_type: str = \"close\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing DNA Method in Jesse AI Strategy\nDESCRIPTION: This code snippet shows how to define a 'dna' method inside a trading strategy class that returns a DNA string. When implemented, this method overrides the default hyperparameter values with optimized ones encoded in the DNA string.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/optimize/dna-usage.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef dna(self):\n    return 't4'\n```\n\n----------------------------------------\n\nTITLE: Detecting Crosses Between Time Series\nDESCRIPTION: Helper function for detecting when one time series crosses above or below another. Can return a boolean or an array of booleans depending on the sequential parameter.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/utils.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncrossed(series1, series2, direction=None, sequential=False)\n```\n\n----------------------------------------\n\nTITLE: Implementing Holt-Winters Moving Average (HWMA) in Python\nDESCRIPTION: This function calculates the Holt-Winters Moving Average (Triple Exponential Smoothing), which extends EMA by incorporating seasonal components. It's suitable for capturing and predicting seasonal patterns in price data, using customizable smoothing parameters.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_60\n\nLANGUAGE: python\nCODE:\n```\nhwma(candles: np.ndarray, na: float = 0.2, nb: float = 0.1, nc: float = 0.1, source_type: str = \"close\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Multi-Point Position Entry in Python (Jesse Framework)\nDESCRIPTION: Shows how to enter a long position at multiple price points using an array of buy orders.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/events.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef go_long(self):\n    self.buy = [\n        (1, 100), \n        (1, 90), \n    ]\n```\n\n----------------------------------------\n\nTITLE: Chandelier Exits Implementation in Python\nDESCRIPTION: Implements volatility-based trailing stop-loss indicator for risk management.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nchande(candles: np.ndarray, period=22, mult=3.0, direction=\"long\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Kaufman Adaptive Moving Average (KAMA) in Python\nDESCRIPTION: This function calculates the Kaufman Adaptive Moving Average (KAMA), which dynamically adjusts its smoothing period based on market volatility. It increases responsiveness during high volatility and decreases it during low volatility, adapting to changing market conditions.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_67\n\nLANGUAGE: python\nCODE:\n```\nkama(candles: np.ndarray, period=30, fast_length=2, slow_length=30, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Using acosc (Acceleration/Deceleration Oscillator) in Jesse AI\nDESCRIPTION: The Acceleration/Deceleration Oscillator (AC) measures acceleration or deceleration of price momentum by subtracting a 5-period SMA from a 34-period SMA, providing signals for potential trend direction changes.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nacosc(candles: np.ndarray, sequential=False) -> AC\n```\n\n----------------------------------------\n\nTITLE: Implementing Ehlers Predictive Moving Average (PMA) in Python\nDESCRIPTION: Function to calculate the Ehlers Predictive Moving Average, which attempts to predict future price movement. It takes candle data, source type, and a sequential flag as inputs, returning a PMA object with predict and trigger values.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_102\n\nLANGUAGE: python\nCODE:\n```\npma(candles: np.ndarray, source_type: str = \"hl2\", sequential: bool = False) -> PMA\n```\n\n----------------------------------------\n\nTITLE: Adding Filter Methods to Filters List in Python for Jesse AI\nDESCRIPTION: Demonstrates how to add custom filter methods to the filters() method list in a Jesse AI strategy. It's important to add the method object, not call the method.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/filters.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef filters(self):\n    return [\n        self.filter_1\n    ]\n```\n\n----------------------------------------\n\nTITLE: Implementing Elder Ray Index (ERI) in Python\nDESCRIPTION: Function that calculates the Elder Ray Index, which helps traders assess the balance of power between bulls and bears and identify potential trend reversals based on the divergence between price and the EMA.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_48\n\nLANGUAGE: python\nCODE:\n```\neri(candles: np.ndarray, period: int = 13, matype: int = 1, source_type: str = \"close\", sequential: bool = False) -> ERI\n```\n\n----------------------------------------\n\nTITLE: Implementing MESA Adaptive Moving Average (MAMA) in Python\nDESCRIPTION: MAMA technical indicator function developed by John F. Ehlers that adaptively adjusts smoothing periods based on market volatility. Returns both the MAMA value and the Following Adaptive Moving Average (FAMA) for trend identification in dynamic market conditions.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_83\n\nLANGUAGE: python\nCODE:\n```\nmama(candles: np.ndarray, fastlimit=0.5, slowlimit=0.05, source_type=\"close\", sequential=False) -> MAMA\n```\n\n----------------------------------------\n\nTITLE: Implementing Variable Length Moving Average (VLMA) in Python for Trend Analysis\nDESCRIPTION: Function to calculate VLMA, an adaptive moving average that adjusts its length based on market conditions. It dynamically changes its period in response to volatility for better trend capture.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_153\n\nLANGUAGE: python\nCODE:\n```\nvlma(candles: np.ndarray, min_period: int = 5, max_period: int = 50, matype: int = 0, devtype: int = 0, source_type: str = \"close\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Chande Kroll Stop Implementation in Python\nDESCRIPTION: Implements a dynamic trailing stop-loss indicator based on market volatility.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_22\n\nLANGUAGE: python\nCODE:\n```\ncksp(candles: np.ndarray, p: int = 10, x: float = 1.0, q: int = 9, sequential: bool = False) -> CKSP\n```\n\n----------------------------------------\n\nTITLE: Adding Horizontal Support and Resistance Lines to Candle Chart in Python\nDESCRIPTION: Demonstrates how to add horizontal lines representing support and resistance levels along with technical indicators using add_horizontal_line_to_candle_chart and add_line_to_candle_chart methods.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/charts/Interactive-charts.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef after(self) -> None:\n    self.add_line_to_candle_chart('supertrend', ta.supertrend(self.candles).trend)\n    self.add_line_to_candle_chart('ema5', ta.ema(self.candles, 50))\n    # Resistance and support lines\n    self.add_horizontal_line_to_candle_chart('resistance', 18266, 'red')\n    self.add_horizontal_line_to_candle_chart('support', 17756, 'green')\n```\n\n----------------------------------------\n\nTITLE: Bollinger Bands Width Calculation in Python\nDESCRIPTION: Calculates the width of Bollinger Bands relative to the moving average to measure volatility.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nbollinger_bands_width(candles: np.ndarray, period=20, mult=2, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Generating Heikin Ashi Candlesticks in Python\nDESCRIPTION: Function that converts traditional candlestick data to Heikin Ashi candlesticks, which use modified price calculations to filter out market noise and emphasize trends, making trend identification easier.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_55\n\nLANGUAGE: python\nCODE:\n```\nheikin_ashi_candles(candles: np.ndarray, sequential=False) -> HA\n```\n\n----------------------------------------\n\nTITLE: Calculating Stochastic Fast in Python\nDESCRIPTION: This function computes the Stochastic Fast indicator, calculating fast %K and %D lines. It measures the current closing price relative to the high-low range over a specified period.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_130\n\nLANGUAGE: python\nCODE:\n```\nstochf(candles: np.ndarray, fastk_period=5, fastd_period=3, fastd_matype=0, sequential=False) -> StochasticFast\n```\n\n----------------------------------------\n\nTITLE: Implementing the hyperparameters() Method in Jesse AI Strategy\nDESCRIPTION: Implementation of the hyperparameters() method that defines configurable parameters for strategy optimization. Each parameter includes name, type, min/max values, and defaults.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/optimize/hyperparameters.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef hyperparameters(self):\n    return [\n        {'name': 'slow_sma_period', 'type': int, 'min': 150, 'max': 210, 'default': 200},\n        {'name': 'fast_sma_period', 'type': int, 'min': 20, 'max': 100, 'default': 50},\n    ]\n```\n\n----------------------------------------\n\nTITLE: Calculating Stochastic RSI (SRSI) in Python\nDESCRIPTION: This function calculates the Stochastic RSI, a momentum oscillator combining RSI and Stochastic Oscillator. It measures the RSI's position within its range over a specified period, helping identify overbought and oversold conditions.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_124\n\nLANGUAGE: python\nCODE:\n```\nsrsi(candles: np.ndarray, period=14, source_type=\"close\", sequential=False) -> StochasticRSI\n```\n\n----------------------------------------\n\nTITLE: Dynamic Position Size Update in Python (Jesse Framework)\nDESCRIPTION: Example of dynamically increasing position size based on profit percentage condition.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/events.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef update_position(self):\n    # increase position size if the long\n    # position is in more than 2% profit\n    if self.is_long and self.position.pnl_percentage > 2:\n        self.buy = self.position.qty, self.price\n```\n\n----------------------------------------\n\nTITLE: Correlation Cycle Analysis in Python\nDESCRIPTION: Implements John Ehlers' correlation cycle analysis framework for identifying market patterns.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_26\n\nLANGUAGE: python\nCODE:\n```\ncorrelation_cycle(candles: np.ndarray, period=20, threshold=9, source_type=\"close\", sequential=False) -> CC\n```\n\n----------------------------------------\n\nTITLE: SQWMA (Square Weighted Moving Average) Implementation in Python\nDESCRIPTION: Calculates a weighted moving average where weights applied to data points are squared. This assigns greater importance to recent prices while still considering older ones, creating a responsive yet smooth moving average.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_123\n\nLANGUAGE: python\nCODE:\n```\nsqwma(candles: np.ndarray, period: int = 14, source_type: str = \"close\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Computing Rate of Change (ROC) Indicator in Python\nDESCRIPTION: Function to calculate the Rate of Change (ROC) indicator, which measures the percentage change in price from one period to the next. It takes candle data, period, source type, and a sequential flag as inputs, returning either a float or numpy array.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_108\n\nLANGUAGE: python\nCODE:\n```\nroc(candles: np.ndarray, period=10, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Calculating Efficiency Ratio (ER) in Python\nDESCRIPTION: Function that computes the Efficiency Ratio (Kaufman Efficiency Indicator), which quantifies the efficiency of price movements by comparing net price change to total price movement over a specified period on a scale from 0 to 1.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_47\n\nLANGUAGE: python\nCODE:\n```\ner(candles: np.ndarray, period: int = 5, source_type: str = \"close\", sequential: bool = False) -> Union[float, np.ndarray]:\n```\n\n----------------------------------------\n\nTITLE: Using ad (Chaikin A/D Line) in Jesse AI\nDESCRIPTION: The Chaikin A/D Line calculates the sum of money flows based on price movements and volume to identify trends and potential reversals in price action.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nad(candles: np.ndarray, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Calculating Know Sure Thing (KST) Indicator in Python\nDESCRIPTION: Implements the Know Sure Thing (KST) indicator, a momentum oscillator that combines multiple smoothed rate-of-change indicators. It takes candle data and various period parameters for SMA and ROC calculations.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_71\n\nLANGUAGE: python\nCODE:\n```\nkst(candles: np.ndarray, sma_period1=10, sma_period2=10, sma_period3=10, sma_period4=15, roc_period1=10, roc_period2=15, roc_period3=20, roc_period4=30, signal_period=9, source_type=\"close\", sequential=False) -> KST:\n```\n\n----------------------------------------\n\nTITLE: Computing Schaff Trend Cycle (STC) in Python\nDESCRIPTION: This function calculates the Schaff Trend Cycle, an indicator for identifying market trends and potential reversals. It combines cycle analysis and momentum oscillators, producing signals for trending and range-bound markets.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_126\n\nLANGUAGE: python\nCODE:\n```\nstc(candles: np.ndarray, fast_period: int = 23, fast_matype: int = 1, slow_period: int = 50, slow_matype: int = 1, k_period: int = 10, d_period: int = 3, source_type: str = \"close\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Importing and Plotting Bitcoin Price Data with SMA in Python\nDESCRIPTION: This code snippet demonstrates how to import Bitcoin price data, calculate a 50-period Simple Moving Average (SMA), and plot both the price and SMA using matplotlib. It uses Jesse AI's research and indicator modules to fetch and process the data.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/research/indicators.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\nimport matplotlib.pyplot as plt\nfrom pandas.plotting import register_matplotlib_converters\nregister_matplotlib_converters()\nfrom jesse import research\nimport jesse.indicators as ta\nimport jesse.helpers as jh\n\n\n_, btc_candles = research.get_candles(\n    'Binance Spot',\n    'BTC-USDT',\n    '30m',\n    jh.date_to_timestamp('2021-11-10'),\n    jh.date_to_timestamp('2021-11-20')\n)\nbtc_sma_50 = ta.sma(btc_candles, 50, sequential=True)\nbtc_close = btc_candles[:, 2]\n\n# convect timestamps into a format that is supported for plotting\ntimes = []\nfor c in btc_candles:\n    times.append(datetime.fromtimestamp(c[0] / 1000))\n\nplt.figure(figsize=(15, 6))\nplt.plot(times, btc_close, color='blue', label='btc')\nplt.plot(times, btc_sma_50, color='black', label='SMA 50')\nplt.legend();\n```\n\n----------------------------------------\n\nTITLE: Balance of Power Indicator in Python\nDESCRIPTION: Measures the strength of buyers versus sellers based on price relationships.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nbop(candles: np.ndarray, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Computing Linear Regression in Python\nDESCRIPTION: Calculates the Linear Regression indicator, which fits a linear regression line to the given data points. It takes candle data, period, and source type as inputs.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_74\n\nLANGUAGE: python\nCODE:\n```\nlinearreg(candles: np.ndarray, period=14, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Using ao (Awesome Oscillator) in Jesse AI\nDESCRIPTION: The Awesome Oscillator is a momentum indicator measuring the difference between 34-period and 5-period simple moving averages, indicating market momentum based on the interaction between these moving averages.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nao(candles: np.ndarray, sequential=False) -> AO\n```\n\n----------------------------------------\n\nTITLE: True Range (TRANGE) Volatility Indicator in Python\nDESCRIPTION: Calculates the True Range as a measure of market volatility. It represents the greatest of: current high minus low, absolute value of high minus previous close, or absolute value of low minus previous close. Used in ATR calculations. Requires numpy.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_138\n\nLANGUAGE: python\nCODE:\n```\ntrange(candles: np.ndarray, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing update_position() with Liquidation in Python for Jesse AI\nDESCRIPTION: This method demonstrates how to liquidate an open position based on a certain condition. It closes the long position if the RSI reaches 100.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/entering-and-exiting.md#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef update_position(self):\n    if self.is_long and ta.rsi(self.candles) == 100:\n        self.liquidate()\n```\n\n----------------------------------------\n\nTITLE: Elliott Wave Oscillator Python Implementation\nDESCRIPTION: Python implementation of the Elliott Wave Oscillator for Jesse, calculating the difference between short and long period EMAs with configurable parameters and sequential output option.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/custom-indicators.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nfrom typing import Union\n\nfrom jesse.helpers import get_candle_source, slice_candles\n\ndef ewo(candles: np.ndarray, short_period: int = 5, long_period: int = 34, source_type=\"close\", sequential = False) -> Union[float, np.ndarray]:\n    \"\"\"\n    Elliott Wave Oscillator\n    :param candles: np.ndarray\n    :param short_period: int - default: 5\n    :param long_period: int - default: 34\n    :param source_type: str - default: close\n    :param sequential: bool - default: False\n    :return: Union[float, np.ndarray]\n    \"\"\"\n    candles = slice_candles(candles, sequential)\n\n    src = get_candle_source(candles, source_type)\n    # Calculate EMAs using Jesse's built-in EMA function\n    from jesse.indicators import ema\n    ewo = np.subtract(ema(src, period=short_period, sequential=True), ema(src, period=long_period, sequential=True))\n\n    if sequential:\n        return ewo\n    else:\n        return ewo[-1]\n```\n\n----------------------------------------\n\nTITLE: Time Series Forecast (TSF) Indicator in Python\nDESCRIPTION: Calculates the Time Series Forecast (TSF) which predicts future price movements using linear regression on historical prices. It extrapolates the trend of data points into the future to project potential price movement. Requires numpy for calculations.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_142\n\nLANGUAGE: python\nCODE:\n```\ntsf(candles: np.ndarray, period=14, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Calculating Quantity Based on Risk Percentage\nDESCRIPTION: Determines the quantity to trade based on the percentage of capital to risk, entry price, and stop loss price. Essential for implementing risk-based position sizing strategies.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/utils.md#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nrisk_to_qty(capital, risk_per_capital, entry_price, stop_loss_price, precision=3, fee_rate=0)\n```\n\nLANGUAGE: python\nCODE:\n```\ndef go_long(self):\n    # risk 1% of the capital($10000) for a trade entering at $100 with the stop-loss at $80\n    risk_perc = 1\n    entry = 100\n    stop = 80\n    profit = 150\n    capital = 10000\n    # or we could access capital dynamically:\n    capital = self.balance\n    qty = utils.risk_to_qty(capital, risk_perc, entry, stop)\n\n    self.buy = qty, entry\n    self.stop_loss = qty, stop\n    self.take_profit = qty, profit\n```\n\nLANGUAGE: python\nCODE:\n```\n# so instead of\nqty = utils.risk_to_qty(capital, risk_perc, entry, stop)\n\n# it's better to do\nqty = utils.risk_to_qty(capital, risk_perc, entry, stop, self.fee_rate)\n```\n\n----------------------------------------\n\nTITLE: Computing Ehlers Distance Coefficient Filter (edcf) in Python\nDESCRIPTION: A filter that removes high-frequency noise from price data while preserving underlying trends by calculating the distance between current price and a weighted moving average, with adaptive weighting based on market conditions.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_41\n\nLANGUAGE: python\nCODE:\n```\nedcf(candles: np.ndarray, period: int = 15, source_type: str = \"hl2\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Using adx (Average Directional Movement Index) in Jesse AI\nDESCRIPTION: The Average Directional Movement Index (ADX) quantifies trend strength regardless of direction by measuring the magnitude of price movements over a specified period.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nadx(candles: np.ndarray, period=14, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Converting Position Size to Quantity\nDESCRIPTION: Converts a position size to the corresponding quantity based on price. Can account for trading fees to ensure the position doesn't exceed available capital.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/utils.md#2025-04-23_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nsize_to_qty(position_size, price, precision=3, fee_rate=0)\n```\n\n----------------------------------------\n\nTITLE: Converting Price Series to Returns\nDESCRIPTION: Transforms a series of asset prices into returns. This is important for statistical analysis since returns, unlike prices, are typically stationary and better suited for time series analysis.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/utils.md#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nprices_to_returns(price_series: np.ndarray) -> np.ndarray\n```\n\n----------------------------------------\n\nTITLE: Computing Keltner Channels in Python\nDESCRIPTION: Calculates Keltner Channels, a volatility-based indicator used to identify potential price breakouts and trend reversals. It takes candle data, period, multiplier, moving average type, and source type as inputs.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_70\n\nLANGUAGE: python\nCODE:\n```\nkeltner(candles: np.ndarray, period=20, multiplier=2, matype=1, source_type=\"close\", sequential=False) -> KeltnerChannel\n```\n\n----------------------------------------\n\nTITLE: Converting Quantity to Position Size\nDESCRIPTION: Calculates the position size corresponding to a given quantity and price. Useful for determining the capital required for a position.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/utils.md#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nqty_to_size(qty, price)\n```\n\n----------------------------------------\n\nTITLE: Parabolic SAR Trend-Following Indicator Implementation in Python\nDESCRIPTION: Implements the Parabolic SAR (Stop and Reverse) indicator that plots dots above or below price to indicate trend direction. Used to identify potential reversal points with acceleration and maximum parameters controlling sensitivity.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_118\n\nLANGUAGE: python\nCODE:\n```\nsar(candles: np.ndarray, acceleration=0.02, maximum=0.2, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Periodic Updates in Trading Strategy\nDESCRIPTION: Example showing how to perform expensive operations like machine learning tasks once per day while trading on 1-minute candles.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/api.md#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef before(self):\n    if self.index % 1440 == 0:\n        do_slow_updates()\n```\n\n----------------------------------------\n\nTITLE: Computing Positive Volume Index (PVI) in Python\nDESCRIPTION: Function to calculate the Positive Volume Index (PVI), which is used to identify the strength of positive volume flows. It takes candle data, source type, and a sequential flag as inputs, returning either a float or numpy array.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_104\n\nLANGUAGE: python\nCODE:\n```\npvi(candles: np.ndarray, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Using adosc (Chaikin A/D Oscillator) in Jesse AI\nDESCRIPTION: The Chaikin A/D Oscillator is a momentum oscillator derived from the Chaikin A/D Line, measuring the difference between short-term and long-term accumulation/distribution values.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nadosc(candles: np.ndarray, fast_period=3, slow_period=10, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Klinger Volume Oscillator (KVO) in Python\nDESCRIPTION: Calculates the Klinger Volume Oscillator (KVO), a volume-based indicator that combines two volume-based moving averages. It takes candle data, short and long periods as inputs.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_73\n\nLANGUAGE: python\nCODE:\n```\nkvo(candles: np.ndarray, short_period=34, long_period=55, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Weighted Moving Average in Python\nDESCRIPTION: Calculates Weighted Moving Average (WMA) with customizable period and source type, giving more weight to recent data.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_166\n\nLANGUAGE: python\nCODE:\n```\nwma(candles: np.ndarray, period=30, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Money Flow Index (MFI) in Python\nDESCRIPTION: Money Flow Index momentum indicator function that measures the strength and direction of money flow in a security. Combines price and volume data to assess buying and selling pressure, returning values between 0 and 100.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_90\n\nLANGUAGE: python\nCODE:\n```\nmfi(candles: np.ndarray, period=14, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing KDJ Oscillator in Python\nDESCRIPTION: Calculates the KDJ Oscillator, derived from the Stochastic Oscillator. It consists of three lines: %K, %D, and J. The function takes candle data and various period parameters as inputs.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_69\n\nLANGUAGE: python\nCODE:\n```\nkdj(candles: np.ndarray, fastk_period: int = 9, slowk_period: int = 3, slowk_matype: int = 0, slowd_period: int = 3, slowd_matype: int = 0, sequential: bool = False) -> KDJ\n```\n\n----------------------------------------\n\nTITLE: Implementing Directional Movement Index (dx/DMI) in Python\nDESCRIPTION: A technical indicator that assesses the strength and direction of a trend in a financial asset. Returns ADX value along with positive and negative directional indicators to determine trend quality.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_40\n\nLANGUAGE: python\nCODE:\n```\ndx(candles: np.ndarray, di_length=14, adx_smoothing=14,sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Filter Method in Python for Jesse AI\nDESCRIPTION: Shows how to define a custom filter method within a Jesse AI strategy class. This example compares the current price to two different EMAs.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/filters.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef filter_1(self):\n    return abs(self.price - self.long_EMA) < abs(self.price - self.longer_EMA)\n```\n\n----------------------------------------\n\nTITLE: Implementing Median Absolute Deviation in Python\nDESCRIPTION: Median Absolute Deviation statistical function that quantifies data dispersion around the median. Similar to Mean Absolute Deviation but uses median instead of mean, making it more robust to outliers when assessing price volatility.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_88\n\nLANGUAGE: python\nCODE:\n```\nmedian_ad(candles: np.ndarray, period: int = 5, source_type: str = \"hl2\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Moving Average Bands (MAB) in Python\nDESCRIPTION: Moving Average Bands function that creates dynamic support and resistance levels based on multiple moving averages. The bands expand or contract based on market volatility and can use different moving average types for slow and fast periods.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_81\n\nLANGUAGE: python\nCODE:\n```\nmab(candles: np.ndarray, fast_period: int = 10, slow_period: int = 50, devup: float = 1, devdn: float = 1, fast_matype: int = 0, slow_matype: int = 0, source_type: str = \"close\", sequential: bool = False) -> MAB\n```\n\n----------------------------------------\n\nTITLE: Calculating Directional Trend Index (dti) by William Blau in Python\nDESCRIPTION: A technical indicator that combines elements of ADX and DMI to gauge both trend strength and direction in the market, providing traders with insights into the quality and sustainability of price movements.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_39\n\nLANGUAGE: python\nCODE:\n```\ndti(candles: np.ndarray, r=14, s=10, u=5, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Williams Accumulation/Distribution in Python\nDESCRIPTION: Calculates the Williams Accumulation/Distribution (WAD) indicator to evaluate fund flow based on price movements and volume.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_161\n\nLANGUAGE: python\nCODE:\n```\nwad(candles: np.ndarray, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Ultimate Oscillator (ULTOSC) in Python for Momentum Analysis\nDESCRIPTION: Function to calculate the Ultimate Oscillator, a momentum oscillator that combines short, intermediate, and long-term price action. It ranges from 0 to 100 to identify overbought/oversold conditions.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_148\n\nLANGUAGE: python\nCODE:\n```\nultosc(candles: np.ndarray, timeperiod1=7, timeperiod2=14, timeperiod3=28, sequential=False) -> Union[\n  float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Fibonacci's Weighted Moving Average (FWMA) in Python\nDESCRIPTION: Function that calculates the Fibonacci's Weighted Moving Average, which assigns weights to data points based on Fibonacci ratios to prioritize recent data while still considering historical prices.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_52\n\nLANGUAGE: python\nCODE:\n```\nfwma(candles: np.ndarray, period: int = 5, source_type: str = \"close\",sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Using Technical Indicators with Candles in Jesse AI\nDESCRIPTION: This snippet shows how to use the candles property with technical indicators in a Jesse AI strategy. It demonstrates calculating a Simple Moving Average (SMA) with a period of 8 for the current trading route.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/api.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# get SMA with a period of 8 for current trading route\nsma8 = ta.sma(self.candles, 8)\n```\n\n----------------------------------------\n\nTITLE: Calculating Normalized Average True Range (NATR) in Python\nDESCRIPTION: Function to calculate the Normalized Average True Range (NATR), a volatility indicator that measures market volatility as a percentage of the closing price. It takes candle data, a period, and a sequential flag as inputs, returning either a float or numpy array.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_96\n\nLANGUAGE: python\nCODE:\n```\nnatr(candles: np.ndarray, period=14, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Donchian Channels for Volatility and Breakout Analysis in Python\nDESCRIPTION: A technical indicator used to identify potential breakout and breakdown levels, as well as gauge market volatility. Returns upper, middle, and lower bands to establish entry and exit points for trades.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_37\n\nLANGUAGE: python\nCODE:\n```\ndonchian(candles: np.ndarray, period=20, sequential=False) -> DonchianChannel\n```\n\n----------------------------------------\n\nTITLE: Using adxr (Average Directional Movement Index Rating) in Jesse AI\nDESCRIPTION: The Average Directional Movement Index Rating (ADXR) calculates the average of current and previous ADX values to provide a smoothed indication of trend strength over time.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nadxr(candles: np.ndarray, period=14, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Calculating Z-Score for Price Returns\nDESCRIPTION: Computes the Z-score which measures how many standard deviations a data point is from the mean. Requires price returns rather than raw prices as input.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/utils.md#2025-04-23_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nz_score(price_returns: np.ndarray) -> np.ndarray\n```\n\n----------------------------------------\n\nTITLE: Implementing RSI Laguerre Filter in Python\nDESCRIPTION: Calculates the RSI Laguerre Filter, which combines the Relative Strength Index with Laguerre filtering techniques. It takes candle data and alpha parameter as inputs.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_78\n\nLANGUAGE: python\nCODE:\n```\nlrsi(candles: np.ndarray, alpha=0.2, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Fetching Candles from Database\nDESCRIPTION: Retrieves candles from database as NumPy array with optional warm-up period and Jesse-specific formatting.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/research/candles.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nget_candles(exchange, symbol, timeframe, start_date_timestamp, finish_date_timestamp, warmup_candles_num=0, caching=False, is_for_jesse=False)\n```\n\n----------------------------------------\n\nTITLE: Computing Symmetric Weighted Moving Average (SWMA) in Python\nDESCRIPTION: This function calculates the Symmetric Weighted Moving Average, assigning weights symmetrically to data points. It responds quickly to recent price changes while providing smoother results than other weighted averages.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_133\n\nLANGUAGE: python\nCODE:\n```\nswma(candles: np.ndarray, period: int = 5, source_type: str = \"close\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Accessing metrics in Strategy API (Python)\nDESCRIPTION: A new 'metrics' property has been added to the Strategy API, allowing access to performance metrics during strategy execution.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/changelog.md#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass MyStrategy(Strategy):\n    def should_long(self):\n        current_pnl = self.metrics['pnl']\n        return current_pnl > 0\n```\n\n----------------------------------------\n\nTITLE: Triple Exponential Moving Average (TEMA) Indicator in Python\nDESCRIPTION: Calculates the Triple Exponential Moving Average (TEMA) which applies triple exponential smoothing to reduce lag. It responds rapidly to price changes while maintaining a smooth trajectory, useful for trend-following strategies. Requires numpy for array operations.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_137\n\nLANGUAGE: python\nCODE:\n```\ntema(candles: np.ndarray, period=9, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Calculating Ease of Movement (EMV) Indicator in Python\nDESCRIPTION: Function that calculates the Ease of Movement indicator, which assesses the relationship between price and volume by quantifying how easily prices move relative to volume, helping identify potential trend reversals based on price-volume divergence.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_45\n\nLANGUAGE: python\nCODE:\n```\nemv(candles: np.ndarray, length=14, div=10000, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Triangular Moving Average (TRIMA) Indicator in Python\nDESCRIPTION: Calculates the Triangular Moving Average (TRIMA) which places equal weight on prices over a specified period. The middle prices receive the most weight in this moving average calculation. Requires numpy for array operations.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_140\n\nLANGUAGE: python\nCODE:\n```\ntrima(candles: np.ndarray, period=30, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Calculating Stiffness Indicator in Python\nDESCRIPTION: This function computes the Stiffness Indicator, which measures the power of a trend based on moving average and standard deviation of price. It's useful for assessing trend strength in financial markets.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_127\n\nLANGUAGE: python\nCODE:\n```\nstiffness(candles: np.ndarray, ma_length: int = 100, stiff_length: int = 60, stiff_smooth: int = 3, source_type: str = \"close\")\n```\n\n----------------------------------------\n\nTITLE: Calculating Linear Regression Angle in Python\nDESCRIPTION: Computes the Linear Regression Angle, which measures the angle of the linear regression line. It takes candle data, period, and source type as inputs.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_75\n\nLANGUAGE: python\nCODE:\n```\nlinearreg_angle(candles: np.ndarray, period=14, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Calculating Double Exponential Moving Average (dema) in Python\nDESCRIPTION: A moving average that applies two exponential smoothing techniques to price data, resulting in a smoother and more responsive indicator compared to traditional moving averages. Reduces lag by placing more weight on recent price data.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_33\n\nLANGUAGE: python\nCODE:\n```\ndema(candles: np.ndarray, period=30, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Square Root Weighted Moving Average (SRWMA) in Python\nDESCRIPTION: This function calculates the Square Root Weighted Moving Average, which assigns weights to data points based on the square root of their position. It emphasizes recent data while smoothing price movements.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_125\n\nLANGUAGE: python\nCODE:\n```\nsrwma(candles: np.ndarray, period: int = 14, source_type: str = \"close\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Defining the backtest() Function Signature in Python\nDESCRIPTION: Function signature for Jesse's backtest() function with parameters for configuration, routes, candles data, and various output generation options.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/research/backtest.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nbacktest(\n    config: dict,\n    routes: list,\n    extra_routes: list,\n    candles: dict,\n    warmup_candles: dict = None,\n    generate_charts: bool = False,\n    generate_tradingview: bool = False,\n    generate_hyperparameters: bool = False,\n    generate_equity_curve: bool = False,\n    generate_csv: bool = False,\n    generate_json: bool = False,\n    generate_logs: bool = False,\n    hyperparameters: dict = None,\n    fast_mode: bool = False\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Volume Weighted Average Price (VWAP) in Python for Trend Analysis\nDESCRIPTION: Function to calculate VWAP, which averages price weighted by trading volume over a specified time period. The anchor parameter specifies the time interval (daily, weekly, etc.) for calculation.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_158\n\nLANGUAGE: python\nCODE:\n```\nvwap(candles: np.ndarray, source_type: str = \"hlc3\", anchor: str = \"D\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Calculating Hurst Exponent for Time Series Analysis in Python\nDESCRIPTION: This function calculates the Hurst Exponent to quantify the long-term memory of price data, identifying whether the data is trending, mean-reverting, or random. It supports multiple calculation methods including RS, DMA, and DSOD, with customizable parameters for chunk sizes.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_59\n\nLANGUAGE: python\nCODE:\n```\nhurst_exponent(candles: np.ndarray, min_chunksize: int = 8, max_chunksize: int = 200, num_chunksize: int = 5, method: int = 1, source_type: str = \"close\") -> float\n```\n\n----------------------------------------\n\nTITLE: Implementing Momentum (MOM) Indicator in Python\nDESCRIPTION: Momentum indicator function that measures the rate of price change over a specified period. Calculates the difference between current closing price and a previous period's closing price to identify upward or downward momentum.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_94\n\nLANGUAGE: python\nCODE:\n```\nmom(candles: np.ndarray, period=10, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Super Smoother Filter in Python\nDESCRIPTION: This function applies the Super Smoother Filter 2-pole Butterworth, designed to eliminate aliasing noise while preserving signal phase characteristics. It provides smoother output compared to traditional moving averages.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_131\n\nLANGUAGE: python\nCODE:\n```\nsupersmoother(candles: np.ndarray, period=14, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Calculating Signal Line for Indicators\nDESCRIPTION: Returns the moving average of a series, which is commonly used to create signal lines for technical indicators. Supports different moving average types.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/utils.md#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nsignal_line(series, period=10, matype=0)\n```\n\n----------------------------------------\n\nTITLE: Calculating Kelly Criterion for Position Sizing\nDESCRIPTION: Implements the Kelly Criterion formula which determines the optimal position size based on win rate and average win/loss ratio. Used for optimal capital allocation.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/utils.md#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nkelly_criterion(win_rate, ratio_avg_win_loss)\n```\n\n----------------------------------------\n\nTITLE: Using Custom Indicator in a Strategy\nDESCRIPTION: Example of importing and using the custom Elliott Wave Oscillator indicator in a Jesse trading strategy class.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/custom-indicators.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom jesse.strategies import Strategy\nimport custom_indicators as cta\n\nclass Strategy01(Strategy):\n    @property\n    def ewo(self):\n        return cta.ewo(self.candles, short_period=5, long_period=34, source_type=\"close\", sequential=True)\n```\n\n----------------------------------------\n\nTITLE: Support and Resistance Levels with Breaks Indicator in Python\nDESCRIPTION: Calculates support and resistance levels with break lines based on candle data. It returns a SupportResistanceWithBreaks object containing support, resistance, and various break signals. Requires numpy for array operations.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_135\n\nLANGUAGE: python\nCODE:\n```\nsupport_resistance_with_breaks(candles: np.ndarray, left_bars: int = 15, right_bars: int = 15, vol_threshold: int = 20) -> SupportResistanceWithBreaks\n```\n\n----------------------------------------\n\nTITLE: Implementing Volume Price Confirmation Indicator (VPCI) in Python for Trend Analysis\nDESCRIPTION: Function to calculate VPCI, which confirms price movements based on volume. It combines price and volume data to assess trend strength and returns a named tuple with VPCI and VPCIs values.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_152\n\nLANGUAGE: python\nCODE:\n```\nvpci(candles: np.ndarray, short_range=5, long_range=25, sequential=False) -> VPCI\n```\n\n----------------------------------------\n\nTITLE: Calculating On Balance Volume (OBV) in Python\nDESCRIPTION: Function to compute the On Balance Volume (OBV), a momentum indicator that uses volume flow to predict changes in stock price. It takes candle data and a sequential flag as inputs, returning either a float or numpy array.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_99\n\nLANGUAGE: python\nCODE:\n```\nobv(candles: np.ndarray, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Wavetrend Indicator in Python\nDESCRIPTION: Calculates the Wavetrend indicator combining moving averages to identify trend strength and direction.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_167\n\nLANGUAGE: python\nCODE:\n```\nwt(candles: np.ndarray, wtchannellen: int = 9, wtaveragelen: int = 12, wtmalen: int = 3, oblevel: int = 53,  oslevel: int = -53, source_type: str = \"hlc3\", sequential: bool = False) -> Wavetrend\n```\n\n----------------------------------------\n\nTITLE: Implementing Wilders Smoothing in Python\nDESCRIPTION: Applies Wilders Smoothing technique using exponential moving average with customizable period and source type.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_164\n\nLANGUAGE: python\nCODE:\n```\nwilders(candles: np.ndarray, period=5, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Typical Price (TYPPRICE) Indicator in Python\nDESCRIPTION: Calculates the Typical Price which represents the average price of a security over a specific period. It's calculated by adding high, low, and closing prices and dividing by three. Useful for smoothing price fluctuations. Requires numpy for calculations.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_146\n\nLANGUAGE: python\nCODE:\n```\ntypprice(candles: np.ndarray, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Cached Property in Jesse AI Strategy\nDESCRIPTION: This snippet demonstrates how to use the @cached decorator in a Jesse AI strategy to improve performance by caching computationally intensive operations like indicator calculations. The cache is cleared with each new candle.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/api.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom jesse.strategies import Strategy, cached\n\n@property\n@cached\ndef donchian(self):\n    return ta.donchian(self.candles)\n```\n\n----------------------------------------\n\nTITLE: Implementing Median Price in Python\nDESCRIPTION: Median Price function that calculates the median of high and low prices for each period. Provides a single value representing the central tendency of the price range over a specified period for trend analysis.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_89\n\nLANGUAGE: python\nCODE:\n```\nmedprice(candles: np.ndarray, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Vortex Indicator (VI) in Python for Trend Analysis\nDESCRIPTION: Function to calculate the Vortex Indicator, which consists of two components: Positive Vortex (+VI) and Negative Vortex (-VI). It returns a named tuple with both values.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_150\n\nLANGUAGE: python\nCODE:\n```\nvi(candles: np.ndarray, period=14, sequential=False) -> VI\n```\n\n----------------------------------------\n\nTITLE: Checking if Series is Strictly Decreasing\nDESCRIPTION: Determines whether a series is strictly decreasing over a specified lookback period. Useful for identifying consistent downward trends.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/utils.md#2025-04-23_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nstrictly_increasing(series, lookback)\n```\n\n----------------------------------------\n\nTITLE: Implementing MidPrice Indicator in Python\nDESCRIPTION: MidPrice technical indicator function that calculates a basic hl2 (high-low average), serving as a price filter over the specified period.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_92\n\nLANGUAGE: python\nCODE:\n```\nmidprice(candles: np.ndarray, period=14, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Moving Average Adaptive Q in Python\nDESCRIPTION: Calculates the Moving Average Adaptive Q, which dynamically adjusts the smoothing factor of the moving average. It takes candle data, period, fast period, slow period, and source type as inputs.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_80\n\nLANGUAGE: python\nCODE:\n```\nmaaq(candles: np.ndarray, period: int = 11, fast_period: int = 2, slow_period: int = 30, source_type: str = \"close\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Importing the Research Module in Jesse AI\nDESCRIPTION: This code snippet demonstrates how to import the research module from Jesse AI. This module provides programmatic access to Jesse's features that are typically available via the GUI dashboard, allowing users to utilize these functions in custom Python scripts or Jupyter Notebooks for research purposes.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/research/index.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom jesse import research\n```\n\n----------------------------------------\n\nTITLE: Commodity Channel Index in Python\nDESCRIPTION: Calculates CCI to identify overbought and oversold conditions in market prices.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_19\n\nLANGUAGE: python\nCODE:\n```\ncci(candles: np.ndarray, period=14, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Volume Weighted Moving Average (VWMA) in Python for Trend Analysis\nDESCRIPTION: Function to calculate VWMA, a moving average that considers volume traded at each price level. It provides a more accurate representation of average price compared to traditional moving averages.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_159\n\nLANGUAGE: python\nCODE:\n```\nvwma(candles: np.ndarray, period=20, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Inter-Strategy Position Management in Python (Jesse Framework)\nDESCRIPTION: Demonstrates how to manage positions across multiple strategies by monitoring events from other strategies.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/events.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef on_route_open_position(self, strategy):\n    # example usage: trading BTC-USDT in the current route \n    # strategy and wanting to close it as soon as a position \n    # is opened in the ETH-USDT route:\n    if self.is_open and strategy.symbol == 'ETH-USDT':\n        self.liquidate()\n```\n\n----------------------------------------\n\nTITLE: Implementing Volume Oscillator (VOSC) in Python for Momentum Analysis\nDESCRIPTION: Function to calculate the Volume Oscillator, which measures the difference between two volume-based moving averages. It helps identify bullish and bearish trends in trading volume.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_154\n\nLANGUAGE: python\nCODE:\n```\nvosc(candles: np.ndarray, short_period=2, long_period=5, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Instantaneous Trendline (iTrend) in Python\nDESCRIPTION: This function calculates the Instantaneous Trendline, a dynamic indicator that quickly captures current trend direction. It helps identify trend reversals and entry/exit points, returning signal, trend, and trigger values for comprehensive analysis.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_64\n\nLANGUAGE: python\nCODE:\n```\nitrend(candles: np.ndarray, alpha=0.07, source_type=\"hl2\", sequential=False) -> ITREND\n```\n\n----------------------------------------\n\nTITLE: Implementing Empirical Mode Decomposition (EMD) in Python\nDESCRIPTION: Function that implements the Empirical Mode Decomposition technique by John F. Ehlers and Ric Way, which decomposes time series signals into intrinsic mode functions and a residual component to reveal underlying cyclical patterns.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_44\n\nLANGUAGE: python\nCODE:\n```\nemd(candles: np.ndarray, period=20, delta=0.5, fraction=0.1, sequential=False) -> EMD\n```\n\n----------------------------------------\n\nTITLE: Implementing Zero-Lag EMA in Python\nDESCRIPTION: Calculates Zero-Lag Exponential Moving Average (ZLEMA) designed to reduce lag in traditional EMAs.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_168\n\nLANGUAGE: python\nCODE:\n```\nzlema(candles: np.ndarray, period=20, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Generating Combinations Without Repetition\nDESCRIPTION: Creates an array containing all combinations of the input array's values without repetitions. This is particularly useful for optimization mode in trading strategies.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/utils.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncombinations_without_repeat(a: np.ndarray, n: int = 2) -> np.ndarray\n```\n\n----------------------------------------\n\nTITLE: Using alligator indicator in Jesse AI\nDESCRIPTION: The Alligator is a technical analysis tool with three smoothed moving averages representing the balance between trend-following and range-bound market conditions, helping identify trends and trade signals.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nalligator(candles: np.ndarray, source_type=\"close\", sequential=False) -> AG\n```\n\n----------------------------------------\n\nTITLE: Implementing Variable Power Weighted Moving Average (VPWMA) in Python for Trend Analysis\nDESCRIPTION: Function to calculate VPWMA, which adjusts the weights of price data points based on their trading volumes. Periods with higher volumes have greater influence on the moving average.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_157\n\nLANGUAGE: python\nCODE:\n```\nvpwma(candles: np.ndarray, period: int = 14, power: float = 0.382, source_type: str = \"close\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Converting Close Prices to Candles\nDESCRIPTION: Generates candle data from a list of close prices, useful for backtesting with price series data.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/research/candles.md#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nclose_prices = [10, 11, 12, 12, 11, 13, 14, 12, 11, 15]\nnp_candles = research.candles_from_close_prices(close_prices)\n\nprint(np_candles)\n# output:\n# [[1.60945920e+12 9.50000000e+00 1.00000000e+01 1.00000000e+01\n#   9.50000000e+00 1.00000000e+02]\n#  [1.60945926e+12 1.00000000e+01 1.10000000e+01 1.10000000e+01\n#   1.00000000e+01 2.80000000e+01]\n#  [1.60945932e+12 1.10000000e+01 1.20000000e+01 1.20000000e+01\n#   1.10000000e+01 1.30000000e+02]\n#  [1.60945938e+12 1.20000000e+01 1.20000000e+01 1.20000000e+01\n#   1.20000000e+01 7.50000000e+01]\n#  [1.60945944e+12 1.20000000e+01 1.10000000e+01 1.20000000e+01\n#   1.10000000e+01 1.51000000e+02]\n#  [1.60945950e+12 1.10000000e+01 1.30000000e+01 1.30000000e+01\n#   1.10000000e+01 5.10000000e+01]\n#  [1.60945956e+12 1.30000000e+01 1.40000000e+01 1.40000000e+01\n#   1.30000000e+01 1.68000000e+02]\n#  [1.60945962e+12 1.40000000e+01 1.20000000e+01 1.40000000e+01\n#   1.20000000e+01 2.20000000e+01]\n#  [1.60945968e+12 1.20000000e+01 1.10000000e+01 1.20000000e+01\n#   1.10000000e+01 1.44000000e+02]\n#  [1.60945974e+12 1.10000000e+01 1.50000000e+01 1.50000000e+01\n#   1.10000000e+01 1.80000000e+02]]\n```\n\n----------------------------------------\n\nTITLE: Calculating Pearson's Correlation Coefficient (correl) in Python\nDESCRIPTION: Function that calculates the Pearson's Correlation Coefficient between the high and low of each candle over a specified period. Returns a value between -1 and 1 indicating correlation direction and strength.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_27\n\nLANGUAGE: python\nCODE:\n```\ncorrel(candles: np.ndarray, period=5, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Volume Price Trend (VPT) in Python for Trend Analysis\nDESCRIPTION: Function to calculate VPT, which analyzes the relationship between volume and price changes to assess trend strength. It cumulatively adds percentage price changes multiplied by volume.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_156\n\nLANGUAGE: python\nCODE:\n```\nvpt(candles: np.ndarray, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Skewness Statistical Measure Implementation in Python\nDESCRIPTION: Calculates the skewness of price distribution over a specified period. Positive values indicate right-leaning distribution, negative values indicate left-leaning distribution, and zero indicates symmetry.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_120\n\nLANGUAGE: python\nCODE:\n```\nskew(candles: np.ndarray, period: int = 5, source_type: str = \"hl2\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Volume Weighted MACD in Python\nDESCRIPTION: Calculates the Volume Weighted Moving Average Convergence/Divergence (VWMACD) indicator using price and volume data. Takes fast, slow and signal periods as parameters.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_160\n\nLANGUAGE: python\nCODE:\n```\nvwmacd(candles: np.ndarray, fast_period=12, slow_period=26, signal_period=9, sequential=False) -> VWMACD\n```\n\n----------------------------------------\n\nTITLE: Accessing Candle Data Directly\nDESCRIPTION: Example of how to directly access and calculate different candle data components (open, close, high, low, volume and their combinations) from the candles numpy array.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/custom-indicators.md#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ncandles_open = candles[:, 1]\ncandles_close = candles[:, 2]\ncandles_high = candles[:, 3]\ncandles_low = candles[:, 4]\ncandles_volume = candles[:, 5]\ncandles_hl2 = (candles[:, 3] + candles[:, 4]) / 2\ncandles_hlc3 = (candles[:, 3] + candles[:, 4] + candles[:, 2]) / 3\ncandles_ohlc4 = (candles[:, 1] + candles[:, 3] + candles[:, 4] + candles[:, 2]) / 4\n```\n\n----------------------------------------\n\nTITLE: Implementing 1-pole High Pass Filter in Python\nDESCRIPTION: Function that applies a 1-pole High Pass Filter designed by John F. Ehlers to reduce low-frequency noise while retaining high-frequency components in price data for better trend analysis.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_56\n\nLANGUAGE: python\nCODE:\n```\nhigh_pass(candles: np.ndarray, period=48, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Advanced Candle Retrieval with Warm-up\nDESCRIPTION: Demonstrates retrieving candles with warm-up period and Jesse-specific formatting for backtesting.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/research/candles.md#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport jesse.helpers as jh\n\nwarmup_candles, trading_candles = get_candles(\n    'Binance Spot', 'BTC-USDT', '4h', jh.date_to_timestamp('2020-01-25'), jh.date_to_timestamp('2020-03-25'),\n    warmup_candles_num=210, caching=True, is_for_jesse=True\n)\n\ntrading_candles = {\n    jh.key('Binance Spot', 'BTC-USDT'): {\n        'exchange': 'Binance Spot',\n        'symbol': 'BTC-USDT',\n        'candles': trading_candles,\n    },\n}\nwarmup_candles = {\n    jh.key('Binance Spot', 'BTC-USDT'): {\n        'exchange': 'Binance Spot',\n        'symbol': 'BTC-USDT',\n        'candles': warmup_candles,\n    },\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Position Update Debugging in Python\nDESCRIPTION: Example of a simple position update method that liquidates a position when profit exceeds 2%\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/debugging.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef update_position(self):\n    if self.position.pnl_percentage > 2:\n        self.liquidate()\n```\n\n----------------------------------------\n\nTITLE: Working with Named Tuples from Indicators in Jesse AI (Object Approach)\nDESCRIPTION: Shows how to access indicator values using attribute notation on named tuples, providing a more readable way to access multiple return values from indicators like Bollinger Bands.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/index.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nbb = bollinger_bands(self.candles, period=20)\nbb.upperband\nbb.middleband\nbb.lowerband\n```\n\n----------------------------------------\n\nTITLE: Using log() Method in Jesse AI for Strategy Debugging\nDESCRIPTION: The log() method outputs text messages from within a trading strategy for debugging or monitoring. It supports both info and error log types, with additional options for sending notifications in live mode and custom webhook integration.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/api.md#2025-04-23_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nlog(\n    msg: str,\n    log_type: str = 'info',\n    send_notification: bool = False,\n    webhook: str = None\n)\n```\n\n----------------------------------------\n\nTITLE: Computing Directional Indicator (di) for Trend Strength Analysis in Python\nDESCRIPTION: A technical analysis tool that measures the strength and direction of market trends. Returns two components: positive Directional Indicator (+DI) and negative Directional Indicator (-DI) to quantify price movement strength.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_35\n\nLANGUAGE: python\nCODE:\n```\ndi(candles: np.ndarray, period=14, sequential=False) -> DI\n```\n\n----------------------------------------\n\nTITLE: Calculating Fisher Transform in Python\nDESCRIPTION: Function that implements the Fisher Transform indicator developed by John Ehlers, which transforms prices into a Gaussian distribution to make trends and turning points easier to identify, with values oscillating between -1 and 1.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_49\n\nLANGUAGE: python\nCODE:\n```\nfisher(candles: np.ndarray, period=9, sequential=False) -> FisherTransform\n```\n\n----------------------------------------\n\nTITLE: Defining Hard-Coded SMA Properties in Jesse AI Strategy\nDESCRIPTION: Example showing a strategy with hard-coded SMA periods (50 and 200) that will later be converted to use hyperparameters.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/optimize/hyperparameters.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@property\ndef slow_sma(self):\n    return ta.sma(self.candles, 200)\n\n@property\ndef fast_sma(self):\n    return ta.sma(self.candles, 50)\n```\n\n----------------------------------------\n\nTITLE: Implementing a 2-pole High Pass Filter in Python\nDESCRIPTION: This function implements John F. Ehlers' 2-pole High Pass Filter which attenuates low-frequency components while preserving high-frequency components in price data. It offers improved noise reduction compared to single-pole filters and is used for trend analysis.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_57\n\nLANGUAGE: python\nCODE:\n```\nhigh_pass_2_pole(candles: np.ndarray, period=48, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Calculating Fractal Adaptive Moving Average (FRAMA) in Python\nDESCRIPTION: Function that implements the Fractal Adaptive Moving Average, which dynamically adjusts its sensitivity based on market volatility to provide smoother and more accurate trend signals compared to traditional moving averages.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_51\n\nLANGUAGE: python\nCODE:\n```\nframa(candles: np.ndarray, window=10, FC=1, SC=300, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Starting Jupyter environments\nDESCRIPTION: Commands to start either Jupyter Notebook (classic interface) or JupyterLab (newer interface). Both environments provide the same core functionality but with different user interfaces.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/research/jupyter.md#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n# to start Jupyter Notebook\njupyter notebook\n# to start Jupyter Lab\njupyter-lab\n```\n\n----------------------------------------\n\nTITLE: Using aroonosc (Aroon Oscillator) in Jesse AI\nDESCRIPTION: The Aroon Oscillator is derived from the Aroon indicator, representing the difference between Aroon Up and Aroon Down lines to provide insights into trend strength and potential reversals.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\naroonosc(candles: np.ndarray, period=14, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Using aroon indicator in Jesse AI\nDESCRIPTION: The Aroon indicator identifies trends and reversals by calculating the time elapsed since the highest and lowest prices within a specified period, indicating trend strength and direction.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\naroon(candles: np.ndarray, period=14, sequential=False) -> AROON\n```\n\n----------------------------------------\n\nTITLE: Chande Momentum Oscillator in Python\nDESCRIPTION: Calculates momentum by analyzing the difference between gains and losses.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_25\n\nLANGUAGE: python\nCODE:\n```\ncmo(candles: np.ndarray, period=14, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Coppock Curve Implementation in Python\nDESCRIPTION: Implements the Coppock Curve momentum indicator for identifying long-term buying opportunities.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ncc(candles: np.ndarray, wma_period=10, roc_short_period=11, roc_long_period=14, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Extracting Values from Candle Data Array\nDESCRIPTION: This code shows how to extract individual values from the candle array in a Jesse AI strategy. It demonstrates accessing timestamp, open, close, high, low, and volume values from the numpy array.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/api.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ntimestamp = self.current_candle[0]\nopen_price = self.current_candle[1]\nclose_price = self.current_candle[2]\nhigh_price = self.current_candle[3]\nlow_price = self.current_candle[4]\nvolume = self.current_candle[5]\n```\n\n----------------------------------------\n\nTITLE: Implementing MinMax (Extrema Detection) in Python\nDESCRIPTION: MinMax function that identifies local extrema (minimum and maximum values) in price data. Also known as ZigZag, it detects support and resistance levels with signals that are delayed by the specified order parameter.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_93\n\nLANGUAGE: python\nCODE:\n```\nminmax(candles: np.ndarray, order=3, sequential=False) -> EXTREMA\n```\n\n----------------------------------------\n\nTITLE: Configuring UFW Firewall in Ubuntu for Jesse AI\nDESCRIPTION: Commands for setting up Ubuntu's UFW firewall to secure a Jesse AI installation. This snippet includes checking status, allowing SSH access, limiting dashboard access to specific IP addresses, and activating the firewall.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/security.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n# to see if ufw is installed and activated\nufw status\n# if it's active, stop it:\nsystemctl stop ufw\n# allow all outgoing traffic\nufw default allow outgoing\n# deny all incoming traffic\nufw default deny incoming\n# allow ssh port (22)\nufw allow ssh\n# If you don't have specific IP addresses, you can open the targeted port\n# (9000 by default) for all, but it's best to allow specific IP addresses only. \n# Assuming your IP addresses are 1.1.1.1, 1.1.1.2, and 1.1.1.3, run:\nufw allow from 1.1.1.1 to any port 9000 proto tcp\nufw allow from 1.1.1.2 to any port 9000 proto tcp\nufw allow from 1.1.1.3 to any port 9000 proto tcp\n# enable the firewall\nufw enable\n# check the status\nufw status numbered\n# restart ufw to apply the changes\nsystemctl restart ufw\n```\n\n----------------------------------------\n\nTITLE: Initializing Basic Filter Structure in Python for Jesse AI\nDESCRIPTION: Demonstrates how to set up the basic structure for filters in a Jesse AI trading strategy class. The filters() method returns a list of filter methods.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/filters.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef filters(self):\n    return []\n```\n\n----------------------------------------\n\nTITLE: True Strength Index (TSI) Momentum Oscillator in Python\nDESCRIPTION: Calculates the True Strength Index (TSI), a momentum oscillator measuring price strength relative to volatility. It uses two moving averages of price momentum. Positive values indicate bullish momentum, negative values suggest bearish momentum. Requires numpy.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_143\n\nLANGUAGE: python\nCODE:\n```\ntsi(candles: np.ndarray, long_period=25, short_period=13, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Sequential Ichimoku Cloud in Python\nDESCRIPTION: This function extends the standard Ichimoku Cloud with sequential analysis capabilities, combining the indicator with specific rules for trade entry/exit. Returns additional components including lagging line and future span projections for more comprehensive trend analysis.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_62\n\nLANGUAGE: python\nCODE:\n```\nichimoku_cloud_seq(candles: np.ndarray, conversion_line_period=9, base_line_period=26, lagging_line_period=52,displacement=26, sequential=False) -> IchimokuCloud\n```\n\n----------------------------------------\n\nTITLE: Implementing Z-Score Indicator in Python\nDESCRIPTION: Calculates the Z-Score indicator to measure standard deviation distance from mean, useful for identifying overbought/oversold conditions.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_169\n\nLANGUAGE: python\nCODE:\n```\nzscore(candles: np.ndarray, period=14, matype=0, nbdev=1, devtype: int = 0, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Calculating Streaks in Time Series\nDESCRIPTION: Returns the streaks of a series, with positive numbers representing positive streaks and negative numbers for negative streaks. Can use the first discrete difference by default.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/utils.md#2025-04-23_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nstreaks(series: np.array, use_diff=True) -> np.array\n```\n\n----------------------------------------\n\nTITLE: TTM Trend Indicator in Python\nDESCRIPTION: Calculates the TTM Trend indicator which identifies the prevailing market trend by analyzing price action. It returns True for bullish trends and False for bearish trends using proprietary algorithms. Requires numpy for array operations.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_144\n\nLANGUAGE: python\nCODE:\n```\nttm_trend(candles: np.ndarray, period: int = 5, source_type: str = \"hl2\", sequential: bool = False) -> Union[bool, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: SMMA (Smoothed Moving Average) Implementation in Python\nDESCRIPTION: Calculates a moving average that gives less weight to recent data points compared to SMA. It aims to provide smoother price trend representation with reduced lag effects.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_122\n\nLANGUAGE: python\nCODE:\n```\nsmma(candles: np.ndarray, period=5, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: ROCR100 (Rate of Change Ratio 100) Indicator Implementation in Python\nDESCRIPTION: Calculates the percentage change in price over a specified period by measuring the ratio of current price to price 'n' periods ago and multiplying by 100. Used as a momentum indicator expressed as a percentage.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_111\n\nLANGUAGE: python\nCODE:\n```\nrocr100(candles: np.ndarray, period=10, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Voss Filter in Python for Price Pattern Prediction\nDESCRIPTION: Function to calculate the Voss Filter indicator by John Ehlers that identifies price patterns and predicts future movements. It applies filters to smooth price data and returns a named tuple with voss and filt values.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_155\n\nLANGUAGE: python\nCODE:\n```\nvoss(candles: np.ndarray, period=20, predict=3, bandwith=0.25, source_type=\"close\", sequential=False) -> VossFilter\n```\n\n----------------------------------------\n\nTITLE: Calculating Kaufman's Stops in Python\nDESCRIPTION: Implements Perry Kaufman's Stops, a dynamic exit strategy indicator that provides adaptive stop-loss levels based on market conditions. It takes candle data, period, multiplier, direction, and moving average type as inputs.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_68\n\nLANGUAGE: python\nCODE:\n```\nkaufmanstop(candles: np.ndarray, period: int = 22, mult: float = 2, direction: str = \"long\", matype: int = 0,  sequential: bool = False) -> Union[ float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Converting Numpy Candles to DataFrame\nDESCRIPTION: Converts numpy array of candle data to a pandas DataFrame with customizable column names. Useful for data analysis and visualization tasks.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/utils.md#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nnumpy_candles_to_dataframe(candles: np.ndarray, name_date=\"date\", name_open=\"open\", name_high=\"high\",\n                               name_low=\"low\", name_close=\"close\", name_volume=\"volume\")\n```\n\n----------------------------------------\n\nTITLE: RSX (Relative Strength Xtra) Momentum Oscillator Implementation in Python\nDESCRIPTION: Calculates the RSX momentum oscillator by applying exponential smoothing to the ratio of average gain to average loss. Used to identify overbought and oversold market conditions.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_115\n\nLANGUAGE: python\nCODE:\n```\nrsx(candles: np.ndarray, period=14, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Incorrect Filter Method Addition in Python for Jesse AI\nDESCRIPTION: Shows an incorrect way of adding filter methods to the filters() list. This example erroneously calls the method instead of passing the method object.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/filters.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef filters(self):\n    return [\n        self.filter_1()\n    ]\n```\n\n----------------------------------------\n\nTITLE: Implementing McGinley Dynamic Indicator in Python\nDESCRIPTION: McGinley Dynamic technical indicator function that tracks price movements more accurately than traditional moving averages. Adjusts its speed based on market conditions to be more responsive during volatile periods and smoother during quiet periods.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_86\n\nLANGUAGE: python\nCODE:\n```\nmcginley_dynamic(candles: np.ndarray, period=10, k=0.6, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Forecast Oscillator (FOSC) in Python\nDESCRIPTION: Function that calculates the Forecast Oscillator, which measures the difference between current price and a forecasted price based on linear regression to identify potential overbought or oversold conditions.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_50\n\nLANGUAGE: python\nCODE:\n```\nfosc(candles: np.ndarray, period=5, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Roofing Filter Technical Indicator Implementation in Python\nDESCRIPTION: Implements John F. Ehlers' Roofing Filter that uses a bandpass filter to extract dominant cycle components from price data. It smooths market cycles and reduces noise to provide clearer trend identification.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_112\n\nLANGUAGE: python\nCODE:\n```\nroofing(candles: np.ndarray, hp_period=48, lp_period=10, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Calculating Percentage Price Oscillator (PPO) in Python\nDESCRIPTION: Function to compute the Percentage Price Oscillator (PPO), a momentum oscillator that measures the difference between two moving averages as a percentage. It takes candle data, fast and slow periods, MA type, source type, and a sequential flag as inputs, returning either a float or numpy array.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_103\n\nLANGUAGE: python\nCODE:\n```\nppo(candles: np.ndarray, fast_period=12, slow_period=26, matype=0, source_type=\"close\", sequential=False) -> Union[\n  float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Waddah Attar Explosion Indicator in Python\nDESCRIPTION: Parameters configuration for the Waddah Attar Explosion indicator that combines MACD with Bollinger Bands.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_162\n\nLANGUAGE: python\nCODE:\n```\nwaddah_attar_explosion(candles, sensitivity=150,=20, slow_length=40,_length=20, mult=20,=\"close\")\n```\n\n----------------------------------------\n\nTITLE: Computing Ehlers Decycler Oscillator (dec_osc) for Momentum Analysis in Python\nDESCRIPTION: An oscillator that filters out short-term price fluctuations and highlights longer-term market trends by applying a high-pass filter to price data, removing high-frequency noise while emphasizing cyclical components.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_32\n\nLANGUAGE: python\nCODE:\n```\ndec_osc(candles: np.ndarray, hp_period=125, k=1, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Creating Jesse Environment on macOS\nDESCRIPTION: Commands to create and activate a dedicated environment for Jesse on macOS using Conda.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/environment-setup.md#2025-04-23_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\nconda create --name jesse python=3.12\n\nconda activate jesse\n```\n\n----------------------------------------\n\nTITLE: Implementing MidPoint Indicator in Python\nDESCRIPTION: MidPoint technical indicator function that calculates the midpoint price over a specified period. Takes the average of the current and previous candle to create a filtered price representation.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_91\n\nLANGUAGE: python\nCODE:\n```\nmidpoint(candles: np.ndarray, period=14, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Polarized Fractal Efficiency (PFE) in Python\nDESCRIPTION: Function to calculate the Polarized Fractal Efficiency (PFE), which measures how efficiently price moves over time. It takes candle data, period, smoothing, source type, and a sequential flag as inputs, returning either a float or numpy array.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_100\n\nLANGUAGE: python\nCODE:\n```\npfe(candles: np.ndarray, period: int = 10, smoothing: int = 5, source_type: str = \"close\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: SINWMA (Sine Weighted Moving Average) Implementation in Python\nDESCRIPTION: Calculates a moving average that weights data points using the sine function, giving more importance to recent data while gradually reducing older data's influence. This improves sensitivity to trend direction changes.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_119\n\nLANGUAGE: python\nCODE:\n```\nsinwma(candles: np.ndarray, period: int = 14, source_type: str = \"close\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Calculating Rate of Change Percentage (ROCP) in Python\nDESCRIPTION: Function to compute the Rate of Change Percentage (ROCP) indicator, which measures the percentage change in price over a specified number of periods. It takes candle data, period, source type, and a sequential flag as inputs, returning either a float or numpy array.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_109\n\nLANGUAGE: python\nCODE:\n```\nrocp(candles: np.ndarray, period=10, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Installing Miniconda on Windows\nDESCRIPTION: PowerShell commands to download and install Miniconda on Windows.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/environment-setup.md#2025-04-23_snippet_11\n\nLANGUAGE: sh\nCODE:\n```\ncurl https://repo.anaconda.com/miniconda/Miniconda3-latest-Windows-x86_64.exe -o .\\miniconda.exe\nstart /wait \"\" .\\miniconda.exe /S\ndel .\\miniconda.exe\n```\n\n----------------------------------------\n\nTITLE: NumPy Array Shift Implementation\nDESCRIPTION: A utility function for shifting numpy arrays in either direction with customizable fill values, useful for implementing indicators that need to access past or future values.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/custom-indicators.md#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef np_shift(arr: np.ndarray, num: int, fill_value=np.nan) -> np.ndarray:\n    result = np.empty_like(arr)\n\n    if num > 0:\n        result[:num] = fill_value\n        result[num:] = arr[:-num]\n    elif num < 0:\n        result[num:] = fill_value\n        result[:num] = arr[-num:]\n    else:\n        result[:] = arr\n\n    return result\n```\n\n----------------------------------------\n\nTITLE: Estimating Risk Per Share\nDESCRIPTION: Calculates the risk per share based on entry price and stop price. Helps determine potential loss for each unit of the asset.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/utils.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nestimate_risk(entry_price, stop_price)\n```\n\n----------------------------------------\n\nTITLE: Initializing Conda on macOS\nDESCRIPTION: Commands to initialize Conda after installation on macOS.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/environment-setup.md#2025-04-23_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\nsource ~/miniconda3/bin/activate\nconda init --all\n```\n\n----------------------------------------\n\nTITLE: Implementing a Loop in Custom Indicator\nDESCRIPTION: Example of using a loop in an indicator calculation to find the difference between current closing price and the price 10 candles ago, with proper NaN initialization.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/custom-indicators.md#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n    close = candles[:, 2]\n    my_indicator_from_loop = np.full_like(close, np.nan)\n    for i in range(10, len(close)):\n        my_indicator_from_loop[i] = close[i] - close[i-10]\n```\n\n----------------------------------------\n\nTITLE: Calculating Damiani Volatmeter for Volatility Analysis in Python\nDESCRIPTION: A technical indicator used to gauge market volatility by comparing high-low price differences with reference levels. Provides insights into potential volatility changes to help traders adjust their strategies accordingly.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_30\n\nLANGUAGE: python\nCODE:\n```\ndamiani_volatmeter(candles: np.ndarray, vis_atr=13, vis_std=20, sed_atr=40, sed_std=100, threshold=1.4, source_type=\"close\", sequential=False) -> DamianiVolatmeter\n```\n\n----------------------------------------\n\nTITLE: Example of Using Jesse's Built-in Indicators\nDESCRIPTION: Demonstration of importing and using Jesse's built-in technical indicators (EMA, SMA, RSI) with candle data in sequential mode.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/custom-indicators.md#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom jesse.indicators import ema, sma, rsi\n\nema_value = ema(candles, period=14, sequential=True)\nsma_value = sma(candles, period=20, sequential=True)\nrsi_value = rsi(candles, period=14, sequential=True)\n```\n\n----------------------------------------\n\nTITLE: Safezone Stops Indicator Implementation for Setting Stop Losses in Python\nDESCRIPTION: Calculates stop levels for positions based on price volatility. For long positions, it uses the minimum between previous low minus directional movement multiple and lookback period; for shorts, it uses maximum between previous high plus directional movement multiple and lookback period.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_117\n\nLANGUAGE: python\nCODE:\n```\nsafezonestop(candles: np.ndarray, period: int = 22, mult: float = 2.5, max_lookback: int = 3, direction: str = \"long\", sequential: bool = False) -> Union[float, np.ndarray]:\n```\n\n----------------------------------------\n\nTITLE: Using Hyperparameters in SMA Properties\nDESCRIPTION: Updated properties that access the hyperparameters through the self.hp dictionary instead of using hard-coded values, allowing for dynamic parameter adjustment.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/optimize/hyperparameters.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@property\ndef slow_sma(self):\n    return ta.sma(self.candles, self.hp['slow_sma_period'])\n\n@property\ndef fast_sma(self):\n    return ta.sma(self.candles, self.hp['fast_sma_period'])\n```\n\n----------------------------------------\n\nTITLE: Implementing End Point Moving Average (EPMA) in Python\nDESCRIPTION: Function that calculates the End Point Moving Average, which emphasizes the most recent data points to provide a smoother representation of recent price trends while minimizing lag compared to traditional moving averages.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nepma(candles: np.ndarray, period: int = 11, offset: int = 4, source_type: str = \"close\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Installing Homebrew on macOS\nDESCRIPTION: Command to install Homebrew package manager on macOS, which is needed to install other dependencies.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/environment-setup.md#2025-04-23_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"\n```\n\n----------------------------------------\n\nTITLE: Calculating Variance (VAR) in Python for Volatility Measurement\nDESCRIPTION: Function to calculate Variance, a statistical measure of dispersion in a dataset. In finance, it's used to assess the volatility or risk of an asset's returns.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_149\n\nLANGUAGE: python\nCODE:\n```\nvar(candles: np.ndarray, period=14, nbdev=1, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Volume Indicator in Python\nDESCRIPTION: Calculates current candle volume and its moving average over a specified period.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_170\n\nLANGUAGE: python\nCODE:\n```\nvolume(candles: np.ndarray, period: int = 20, sequential: bool = False) -> Volume\n```\n\n----------------------------------------\n\nTITLE: Accessing Indicators for Different Trading Routes in Jesse AI\nDESCRIPTION: Shows how to get indicator values for candles from trading routes other than the current one by using the self.get_candles() method to specify exchange, symbol, and timeframe.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/index.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nta.sma(self.get_candles('Binance', 'BTC-USDT', '4h'), 8)\n```\n\n----------------------------------------\n\nTITLE: Implementing Ulcer Index (UI) in Python for Volatility Analysis\nDESCRIPTION: Function to calculate the Ulcer Index (UI), which measures downside volatility by quantifying drawdowns over a specified period. Higher values indicate higher volatility and risk.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_147\n\nLANGUAGE: python\nCODE:\n```\nui(candles: np.ndarray, period: int = 14, scalar: float = 100, source_type: str = \"close\",  sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Using Index to Track Strategy Execution Count\nDESCRIPTION: This example demonstrates how to use the index property as a counter for strategy execution. It shows a simple condition to enter a long position when the first candle is received.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/api.md#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Example #1: Go long when the first candle is received\ndef should_long(self):\n    return self.index == 0\n```\n\n----------------------------------------\n\nTITLE: Implementing Natural Moving Average (NMA) in Python\nDESCRIPTION: Function to calculate the Natural Moving Average (NMA), a dynamic moving average that adjusts its smoothing factor based on market volatility. It takes candle data, period, source type, and a sequential flag as inputs, returning either a float or numpy array.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_97\n\nLANGUAGE: python\nCODE:\n```\nnma(candles: np.ndarray, period: int = 40, source_type: str = \"close\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Computing Standard Deviation (STDDEV) in Python\nDESCRIPTION: This function calculates the Standard Deviation, measuring the dispersion of data points from their mean. It's used to assess price volatility and adjust trading strategies accordingly.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_128\n\nLANGUAGE: python\nCODE:\n```\nstddev(candles: np.ndarray, period=5, nbdev=1, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Kase Dev Stop for Adaptive Stop-Loss in Python\nDESCRIPTION: An adaptive stop-loss indicator that adjusts dynamically based on market volatility and price behavior, helping traders manage risk with stops that respond to changing market conditions.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_34\n\nLANGUAGE: python\nCODE:\n```\ndevstop(candles: np.ndarray, period:int=20, mult: float = 0, devtype: int = 0, direction: str = \"long\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Using Indicators with Current Candles in Jesse AI\nDESCRIPTION: Demonstrates how to get the Simple Moving Average (SMA) indicator value for the current candle in a Jesse AI trading strategy by passing self.candles to the indicator function.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/index.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# give me SMA with period=8 for current candle:\nta.sma(self.candles, 8)\n```\n\n----------------------------------------\n\nTITLE: Trendflex Indicator in Python\nDESCRIPTION: Calculates the Trendflex indicator developed by John F. Ehlers to identify trend reversals. It combines cycle extraction and trend extraction to filter noise and identify underlying trends. Requires numpy for array operations.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_139\n\nLANGUAGE: python\nCODE:\n```\ntrendflex(candles: np.ndarray, period=20, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Adding Horizontal Lines to RSI Chart in Python\nDESCRIPTION: Demonstrates how to add overbought and oversold horizontal reference lines to an RSI chart panel using the add_horizontal_line_to_extra_chart method with color customization.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/charts/Interactive-charts.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef after(self) -> None:\n    # RSI lines\n    self.add_extra_line_chart('RSI', 'RSI14', ta.rsi(self.candles, period=14))\n    self.add_extra_line_chart('RSI', 'RSI21', ta.rsi(self.candles, period=21))\n    # Add overbought and oversold lines\n    self.add_horizontal_line_to_extra_chart('RSI', 'overbought', 70, color='red')\n    self.add_horizontal_line_to_extra_chart('RSI', 'oversold', 30, color='green')\n```\n\n----------------------------------------\n\nTITLE: Calculating Qstick Indicator in Python\nDESCRIPTION: Function to compute the Qstick indicator, which measures the difference between opening and closing prices over a period. It takes candle data, period, and a sequential flag as inputs, returning either a float or numpy array.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_106\n\nLANGUAGE: python\nCODE:\n```\nqstick(candles: np.ndarray, period=5, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Pascal's Weighted Moving Average (PWMA) in Python\nDESCRIPTION: Function to calculate Pascal's Weighted Moving Average (PWMA), a type of moving average that assigns weights based on Pascal's triangle. It takes candle data, period, source type, and a sequential flag as inputs, returning either a float or numpy array.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_105\n\nLANGUAGE: python\nCODE:\n```\npwma(candles: np.ndarray, period: int = 5, source_type: str = \"close\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Subtracting Floats Without Rounding Issues\nDESCRIPTION: Performs floating-point subtraction without the typical rounding issues in Python. Ensures accurate mathematical calculations for financial applications.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/utils.md#2025-04-23_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nsubtract_floats(float1: float, float2: float) -> float\n```\n\n----------------------------------------\n\nTITLE: Importing Indicators Module in Jesse AI\nDESCRIPTION: Shows how to import the indicators module in Jesse AI to access all available technical indicators for strategy development and research.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/index.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport jesse.indicators as ta\n```\n\n----------------------------------------\n\nTITLE: Using Fee Rate in Position Sizing Calculations\nDESCRIPTION: This snippet demonstrates how to use the fee_rate property in risk calculation. It passes the exchange fee rate to the risk_to_qty utility function when determining position size based on risk percentage.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/api.md#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nqty = utils.risk_to_qty(self.balance, 3, entry, stop, fee_rate=self.fee_rate)\n```\n\n----------------------------------------\n\nTITLE: Generating Multiple Fake Candles\nDESCRIPTION: Creates a range of synthetic candles for testing and development purposes.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/research/candles.md#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nrange_candles = research.fake_range_candles(3)\nprint(range_candles)\n# output:\n# [[1.60945920e+12 1.06000000e+02 1.09000000e+02 1.09000000e+02\n#   1.05000000e+02 9.70000000e+01]\n#  [1.60945926e+12 1.09000000e+02 1.10000000e+02 1.10000000e+02\n#   1.08000000e+02 1.50000000e+01]\n#  [1.60945932e+12 1.10000000e+02 1.17000000e+02 1.17000000e+02\n#   1.09000000e+02 2.00000000e+00]]\n```\n\n----------------------------------------\n\nTITLE: Triple Exponential Moving Average (T3) Indicator in Python\nDESCRIPTION: Calculates the Triple Exponential Moving Average (T3) which applies triple exponential smoothing to price data. It reduces lag and provides smoother trends compared to traditional moving averages. Requires numpy for array operations.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_136\n\nLANGUAGE: python\nCODE:\n```\nt3(candles: np.ndarray, period=5, vfactor=0, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Working with Named Tuples from Indicators in Jesse AI (Tuple Approach)\nDESCRIPTION: Demonstrates how to work with indicators that return multiple values using Python's tuple unpacking or index-based access, using Bollinger Bands as an example.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/index.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# as three variables\nupperband, middleband, lowerband = bollinger_bands(self.candles, period=20)\n\n# or you could fetch it as one tuple and retrieve values as you would from a tuple:\nbb = bollinger_bands(self.candles, period=20)\nbb[0] # upperband\nbb[1] # middleband\nbb[2] # lowerband\n```\n\n----------------------------------------\n\nTITLE: TRIX Momentum Oscillator in Python\nDESCRIPTION: Calculates TRIX, a momentum oscillator that measures the percentage change in a triple-smoothed EMA over a specified time period. It compares the current value to the value from 1 day ago as a percentage. Requires numpy for array operations.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_141\n\nLANGUAGE: python\nCODE:\n```\ntrix(candles: np.ndarray, period=18, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Adding Extra Chart with RSI Indicators in Python\nDESCRIPTION: Shows how to create an additional chart panel for RSI indicators with different periods using the add_extra_line_chart method, alongside the main candle chart with its indicators and horizontal lines.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/charts/Interactive-charts.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef after(self) -> None:\n    self.add_line_to_candle_chart('supertrend', ta.supertrend(self.candles).trend)\n    self.add_line_to_candle_chart('ema5', ta.ema(self.candles, 50))\n    self.add_horizontal_line_to_candle_chart('resistance', 18266, 'red')\n    self.add_horizontal_line_to_candle_chart('support', 17756, 'green')\n\n    # RSI lines\n    self.add_extra_line_chart('RSI', 'RSI14', ta.rsi(self.candles, period=14))\n    self.add_extra_line_chart('RSI', 'RSI21', ta.rsi(self.candles, period=21))\n```\n\n----------------------------------------\n\nTITLE: Using cached property decorator for performance optimization (Python)\nDESCRIPTION: A @cached_property decorator has been added to improve performance by caching the results of property calculations. This can be applied to indicators in user-defined strategies.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/changelog.md#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom jesse.decorators import cached_property\n\nclass MyStrategy(Strategy):\n    @cached_property\n    def my_indicator(self):\n        return ta.sma(self.candles, 14)\n```\n\n----------------------------------------\n\nTITLE: Storing Candles in Database\nDESCRIPTION: Stores 1-minute timeframe candles in database for later retrieval or backtesting. Accepts numpy array of candle data.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/research/candles.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nstore_candles(candles, exchange, symbol)\n```\n\n----------------------------------------\n\nTITLE: Choppiness Index Calculation in Python\nDESCRIPTION: Measures market trendiness or choppiness by analyzing price ranges.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nchop(candles: np.ndarray, period: int = 14, scalar: float = 100, drift: int = 1, sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing JSA Moving Average in Python\nDESCRIPTION: This function calculates the JSA Moving Average, which computes the midpoint of a price series by averaging each element with the element shifted forward by a specified period. It provides a simple yet effective method for trend analysis.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_66\n\nLANGUAGE: python\nCODE:\n```\njsa(candles: np.ndarray, period: int = 30, source_type: str = \"close\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Long Entry Order Check Example\nDESCRIPTION: Demonstrates checking for long entry orders in a strategy's should_cancel_entry method.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/api.md#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef should_cancel_entry(self):\n    # cancel entry orders only if trying to enter a long trade\n    if self.has_long_entry_orders:\n        return True\n```\n\n----------------------------------------\n\nTITLE: Adding Indicator Lines to Candle Chart in Python\nDESCRIPTION: Shows how to add technical indicators (supertrend and EMA) to the candle chart using the add_line_to_candle_chart method in a strategy's after method.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/charts/Interactive-charts.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef after(self) -> None:\n    # add the supertrend to the candle chart\n    self.add_line_to_candle_chart('supertrend', ta.supertrend(self.candles).trend)\n    # you can also add the ema5 to the chart\n    self.add_line_to_candle_chart('ema5', ta.ema(self.candles, 50))\n```\n\n----------------------------------------\n\nTITLE: Implementing Minimum PNL Filter in Python for Jesse AI\nDESCRIPTION: Demonstrates a filter that ensures the minimum PNL for trades is greater than 1%. This filter uses properties like average_take_profit and average_entry_price, which are not available in should_long() methods.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/filters.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef minimum_pnl_filter(self):\n    reward_per_qty = abs(self.average_take_profit - self.average_entry_price)\n    pnl_percentage = (reward_per_qty / self.average_entry_price) * 100\n    return pnl_percentage > 1\n```\n\n----------------------------------------\n\nTITLE: Implementing should_cancel_entry() Method in Python for Jesse AI\nDESCRIPTION: This method determines whether to cancel a pending entry order. In this example, it always returns True, canceling the order on every new candle.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/entering-and-exiting.md#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef should_cancel_entry(self):\n    return True\n```\n\n----------------------------------------\n\nTITLE: Implementing Ehlers Simple Decycler for Trend Analysis in Python\nDESCRIPTION: A technical indicator developed by John Ehlers that filters out high-frequency noise from price data while preserving underlying trends using a low-pass filter, emphasizing longer-term price movements.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_31\n\nLANGUAGE: python\nCODE:\n```\ndecycler(candles: np.ndarray, hp_period=125, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Computing Negative Volume Index (NVI) in Python\nDESCRIPTION: Function to calculate the Negative Volume Index (NVI), which focuses on the relationship between volume and price changes. It takes candle data, source type, and a sequential flag as inputs, returning either a float or numpy array.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_98\n\nLANGUAGE: python\nCODE:\n```\nnvi(candles: np.ndarray, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Elder's Force Index (EFI) in Python\nDESCRIPTION: Function that calculates Elder's Force Index, a technical indicator that combines price movement and volume to measure the strength of bulls or bears in the market. It returns either a single value or an array depending on the sequential parameter.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_42\n\nLANGUAGE: python\nCODE:\n```\nefi(candles: np.ndarray, period=13, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Setting Stop Loss and Take Profit in Spot Trading Mode\nDESCRIPTION: This code snippet demonstrates how to set stop loss and take profit targets in the on_open_position() method when using spot trading mode in Jesse AI. It's necessary to set these after the position is opened due to fee deductions affecting the final position size.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/futures-vs-spot.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef on_open_position(self, order):\n    self.stop_loss = self.position.qty, self.price - 10\n    self.take_profit = self.position.qty, self.price + 10\n```\n\n----------------------------------------\n\nTITLE: Break-Even Stop-Loss Update When in Profit in Jesse AI (Python)\nDESCRIPTION: This code updates a trade's stop-loss to break-even (entry price) once the trade is in profit by more than 2 ATR units. This helps secure profits by eliminating the possibility of a losing trade after achieving a certain profit threshold.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/example-strategies.md#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef update_position(self):  \n    # update trailing_stop_loss only if in profit more than 2 ATR\n    if self.is_long and self.price > self.position.entry_price + ta.atr(self.candles) * 2:\n        self.stop_loss = self.position.qty, self.position.entry_price\n```\n\n----------------------------------------\n\nTITLE: Strategy __init__ Usage - Python\nDESCRIPTION: The __init__ method was added to the strategy API allowing initialization of strategy instances.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/changelog.md#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef __init__(self):\n    # Initialize strategy instance\n```\n\n----------------------------------------\n\nTITLE: Bandpass Filter Implementation in Python\nDESCRIPTION: Implements a bandpass filter to isolate specific frequency ranges within price data for technical analysis.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nbandpass(candles: np.ndarray, period: int = 20, bandwidth: float = 0.3, source_type: str = \"close\", sequential: bool = False) -> BandPass\n```\n\n----------------------------------------\n\nTITLE: RSMK (Relative Strength) Indicator Implementation in Python\nDESCRIPTION: Calculates the relative strength between two securities by taking the logarithm of their price ratio and applying a moving average. Used to identify trends or reversals in the comparative performance of securities.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_114\n\nLANGUAGE: python\nCODE:\n```\nrsmk(candles: np.ndarray, candles_compare: np.ndarray, lookback: int = 90, period: int = 3, signal_period: int = 20, source_type: str = \"close\", sequential: bool = False) -> RSMK\n```\n\n----------------------------------------\n\nTITLE: Computing Detrended Price Oscillator (dpo) for Momentum Analysis in Python\nDESCRIPTION: A momentum oscillator that helps identify short-term cycles or overbought/oversold conditions by comparing current price to a historical average. Filters out longer-term trends to focus on shorter-term price movements.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_38\n\nLANGUAGE: python\nCODE:\n```\ndpo(candles: np.ndarray, period=5, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Using watch_list() Method for Live Trading Monitoring\nDESCRIPTION: The watch_list() method returns a list of tuples containing key-value pairs that are displayed in a table during live trading. This method is useful for monitoring indicator values, signals, and other relevant data in real-time.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/api.md#2025-04-23_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nwatch_list() -> list\n```\n\n----------------------------------------\n\nTITLE: Starting Jesse Application\nDESCRIPTION: This command starts the Jesse application in a native setup. It should be run inside the Jesse project directory after ensuring that POSTGRES_HOST and REDIS_HOST are set to localhost in the .env file.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/index.md#2025-04-23_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\njesse run\n```\n\n----------------------------------------\n\nTITLE: Installing Redis on Ubuntu\nDESCRIPTION: Command to install Redis server on Ubuntu, which is required for Jesse.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/environment-setup.md#2025-04-23_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nsudo apt-get install redis-server\n```\n\n----------------------------------------\n\nTITLE: Calculating 3-Pole Super Smoother Filter in Python\nDESCRIPTION: This function implements the Super Smoother Filter 3-pole Butterworth, an advanced smoothing filter that reduces noise while preserving signal phase. It's particularly effective in removing high-frequency noise from data.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_132\n\nLANGUAGE: python\nCODE:\n```\nsupersmoother_3_pole(candles: np.ndarray, period=14, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: ROCR (Rate of Change Ratio) Indicator Implementation in Python\nDESCRIPTION: Calculates the Rate of Change Ratio by measuring the ratio of current price to price 'n' periods ago. Used as a momentum indicator to assess price velocity and potential trend changes.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_110\n\nLANGUAGE: python\nCODE:\n```\nrocr(candles: np.ndarray, period=10, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Computing Cubed Weighted Moving Average (cwma) in Python\nDESCRIPTION: A variant of the Weighted Moving Average that assigns higher weights to recent data points cubically. Provides traders with a smoother trend indicator that responds quickly to price changes while reducing the impact of older data.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_29\n\nLANGUAGE: python\nCODE:\n```\ncwma(candles: np.ndarray, period: int = 14, source_type: str = \"close\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Tracking Position Increases with increased_count\nDESCRIPTION: These examples demonstrate how to use the increased_count property to track how many times a position size has been increased. The first example shows multiple entry points, while the second shows conditional position increases.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/api.md#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef go_long(self):\n    self.buy = [\n        (0.5, self.price + 10),\n        # after this point self.increased_count will be 1\n        (0.5, self.price + 20),\n        # after this point self.increased_count will be 2\n        (0.5, self.price + 30),\n        # after this point self.increased_count will be 3\n    ]\n```\n\n----------------------------------------\n\nTITLE: Position Liquidation Check Example\nDESCRIPTION: Example showing how to liquidate a position after a certain number of candles.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/api.md#2025-04-23_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef update_position(self):\n    if self.index == 10:\n        self.liquidate()\n\ndef should_long(self):\n    return self.index == 0\n\ndef go_long(self):\n    self.buy = 1, self.price\n```\n\n----------------------------------------\n\nTITLE: Installing Docker and Docker-Compose on Ubuntu\nDESCRIPTION: Shell commands for installing Docker and Docker-Compose on Ubuntu systems. Downloads and installs Docker using the official installation script and sets up Docker-Compose with appropriate permissions.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/docker.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n# install docker\ncurl -fsSL https://get.docker.com -o get-docker.sh && sudo sh get-docker.sh\n# install docker-compose \nsudo curl -L \"https://github.com/docker/compose/releases/download/1.25.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose && sudo chmod +x /usr/local/bin/docker-compose\n```\n\n----------------------------------------\n\nTITLE: Chande Forecast Oscillator in Python\nDESCRIPTION: Predicts future price movements by analyzing price relationships over a specified period.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_20\n\nLANGUAGE: python\nCODE:\n```\ncfo(candles: np.ndarray, period: int = 14, scalar: float = 100, source_type: str = \"close\", squential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Average Price Calculation in Python\nDESCRIPTION: Calculates the average price of a security over a specified period to smooth price fluctuations.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\navgprice(candles: np.ndarray, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Chaikin's Volatility Indicator (cvi) in Python\nDESCRIPTION: Function that measures the volatility of a security by calculating the difference between high and low prices over a specified period. Helps traders identify periods of increased or decreased price movement volatility.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_28\n\nLANGUAGE: python\nCODE:\n```\ncvi(candles: np.ndarray, period=5, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Creating a New Jesse Project with Git and Environment Setup\nDESCRIPTION: This snippet shows how to clone the Jesse project template, rename it, and set up the initial environment file. It creates a new project with the necessary file structure for Jesse strategies.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/index.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n# change the name \"my-bot\" to whatever you want\ngit clone https://github.com/jesse-ai/project-template my-bot\n# enter the directory\ncd my-bot\n# create a .env file by copying it from the template\n# edit this to match you enviroment\ncp .env.example .env\n```\n\n----------------------------------------\n\nTITLE: Using Anchor Timeframe Function in Python\nDESCRIPTION: Returns the anchor timeframe based on the input timeframe. Useful for creating dynamic strategies that use multiple timeframes.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/utils.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nanchor_timeframe(timeframe)\n```\n\nLANGUAGE: python\nCODE:\n```\nbigger_timeframe = anchor_timeframe('1h') # prints '4h'\n```\n\n----------------------------------------\n\nTITLE: Implementing Mass Index in Python\nDESCRIPTION: Mass Index technical indicator function developed by Donald Dorsey that measures range expansion to identify potential trend reversals. Calculates the difference between exponential moving averages of the high-low range with smoothing applied.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_85\n\nLANGUAGE: python\nCODE:\n```\nmass(candles: np.ndarray, period=5, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing MWDX Average in Python\nDESCRIPTION: MWDX Average function that provides a customized version of the exponential moving average with adjustable sensitivity. The factor parameter controls the responsiveness of this trend-following indicator.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_95\n\nLANGUAGE: python\nCODE:\n```\nmwdx(candles: np.ndarray, factor: float = 0.2, source_type: str = \"close\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Reflex Indicator by John F. Ehlers in Python\nDESCRIPTION: Function to calculate the Reflex indicator, which aims to filter out high-frequency noise in price data. It takes candle data, period, source type, and a sequential flag as inputs, returning either a float or numpy array.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_107\n\nLANGUAGE: python\nCODE:\n```\nreflex(candles: np.ndarray, period=20, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Elliott Wave Oscillator Pine Script Implementation\nDESCRIPTION: Original TradingView Pine Script code for the Elliott Wave Oscillator indicator, which calculates the difference between a 5-period and 34-period EMA of the close price.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/custom-indicators.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n//@version=3\nstudy(\"Elliott Wave Oscillator\")\ns2=ema(close, 5) - ema(close, 34)\nc_color=s2 <= 0 ? red : lime\nplot(s2, color=c_color, style=histogram, linewidth=2)\n```\n\n----------------------------------------\n\nTITLE: Displaying Telegram Bot API Token Example\nDESCRIPTION: This snippet shows an example of a Telegram bot API token, which is a string of characters used to authenticate the bot. This token should be entered in the project's .env file for either GENERAL_TELEGRAM_BOT_TOKEN or ERROR_TELEGRAM_BOT_TOKEN.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/notifications.md#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n234325981:BBF5-H-FIdlfGVwXaSDfsAdy5A9_4uVsnH\n```\n\n----------------------------------------\n\nTITLE: Generating Fake Candles\nDESCRIPTION: Creates synthetic candle data for testing purposes with optional custom attributes.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/research/candles.md#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfake_candle(attributes, reset)\n```\n\n----------------------------------------\n\nTITLE: Computing Kurtosis in Python\nDESCRIPTION: Calculates the Kurtosis, a statistical measure of the \"tailedness\" or \"peakedness\" of a probability distribution. It takes candle data, period, and source type as inputs.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_72\n\nLANGUAGE: python\nCODE:\n```\nkurtosis(candles: np.ndarray, period: int = 5, source_type: str = \"hl2\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Candle Slicing Function\nDESCRIPTION: Helper function to slice candles array for performance optimization, using configured warmup_candles_num to limit unnecessary calculations when sequential mode is off.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/custom-indicators.md#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef slice_candles(candles: np.ndarray, sequential: bool) -> np.ndarray:\n    warmup_candles_num = get_config('env.data.warmup_candles_num', 240)\n    if not sequential and len(candles) > warmup_candles_num:\n        candles = candles[-warmup_candles_num:]\n    return candles\n```\n\n----------------------------------------\n\nTITLE: Updating Jesse Live Trade Plugin in Native Setup\nDESCRIPTION: Commands to update the Jesse live trade plugin by first uninstalling the current version and then installing the latest version.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/update.md#2025-04-23_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n# delete the already installed version\npip uninstall jesse-live -y\n# install the latest version\njesse install-live\n```\n\n----------------------------------------\n\nTITLE: Implementing NumPy Forward Fill for Array Data\nDESCRIPTION: A function that performs forward fill (ffill) operation on NumPy arrays to handle missing values. It replaces NaN values with the last valid value along a specified axis, commonly used in time series data processing.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/custom-indicators.md#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef np_ffill(arr: np.ndarray, axis: int = 0) -> np.ndarray:\n    idx_shape = tuple([slice(None)] + [np.newaxis] * (len(arr.shape) - axis - 1))\n    idx = np.where(~np.isnan(arr), np.arange(arr.shape[axis])[idx_shape], 0)\n    np.maximum.accumulate(idx, axis=axis, out=idx)\n    slc = [np.arange(k)[tuple([slice(None) if dim == i else np.newaxis\n                               for dim in range(len(arr.shape))])]\n           for i, k in enumerate(arr.shape)]\n    slc[axis] = idx\n    return arr[tuple(slc)]\n```\n\n----------------------------------------\n\nTITLE: Importing Candles in Python with Jesse AI\nDESCRIPTION: Function to import candles from exchange into the database. Shows progress bar by default and returns success message as string.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/research/candles.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport_candles(exchange, symbol, start_date, show_progressbar=True)\n```\n\n----------------------------------------\n\nTITLE: Implementing Weighted Close Price in Python\nDESCRIPTION: Calculates the Weighted Close Price (WCLPRICE) by averaging high, low, and twice the closing price.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_163\n\nLANGUAGE: python\nCODE:\n```\nwclprice(candles: np.ndarray, sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Implementing Mean Absolute Deviation in Python\nDESCRIPTION: Mean Absolute Deviation statistical function that quantifies data dispersion around the mean. Calculates the average of absolute differences between each data point and the mean to assess risk and volatility in price movements.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_87\n\nLANGUAGE: python\nCODE:\n```\nmean_ad(candles: np.ndarray, period: int = 5, source_type: str = \"hl2\", sequential: bool = False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Updating Jesse in Docker Environment\nDESCRIPTION: Series of Docker commands to update Jesse containers to the latest version by stopping current containers, pulling latest images, and restarting them.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/update.md#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n# in case the containers are still running:\ndocker-compose stop\n# to fetch the latest version\ndocker-compose pull\n# to start the containers again with the latest version\ndocker-compose up -d\n```\n\n----------------------------------------\n\nTITLE: Basic Candle Retrieval Example\nDESCRIPTION: Shows basic usage of get_candles function to retrieve trading data without warm-up period.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/research/candles.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nwarmup_candles, trading_candles = research.get_candles('Binance Spot', 'ETH-USDT', '4h', 1564272000000, 1569628800000)\n\nprint(warmup_candles)\n# None\n\nprint(trading_candles[0])\n# array([\n#     1.56427200e+12, # timestamp\n#     2.07300000e+02, # open\n#     2.07750000e+02, # close\n#     2.08230000e+02, # high\n#     2.06170000e+02, # low\n#     2.15143531e+04 # volume\n# ])\n```\n\n----------------------------------------\n\nTITLE: Testing for Cointegration Between Price Return Series\nDESCRIPTION: Uses unit-root test on residuals to test if two price return series are cointegrated. The function requires price returns rather than raw prices and uses a p-value threshold specified by the cutoff parameter.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/utils.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nare_cointegrated(\n    price_returns_1: np.ndarray, price_returns_2: np.ndarray, cutoff=0.05\n) -> bool\n```\n\n----------------------------------------\n\nTITLE: Example of Storing Candles\nDESCRIPTION: Demonstrates storing candles generated from close prices into the database.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/research/candles.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclose_prices = [10, 11, 12, 12, 11, 13, 14, 12, 11, 15]\nnp_candles = research.candles_from_close_prices(close_prices)\n\nresearch.store_candles(np_candles, 'Test Exchange', 'BTC-USDT')\n```\n\n----------------------------------------\n\nTITLE: Computing Linear Regression Intercept in Python\nDESCRIPTION: Calculates the Linear Regression Intercept, which represents the y-intercept of the linear regression line. It takes candle data, period, and source type as inputs.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_76\n\nLANGUAGE: python\nCODE:\n```\nlinearreg_intercept(candles: np.ndarray, period=14, source_type=\"close\", sequential=False) -> Union[float, np.ndarray]\n```\n\n----------------------------------------\n\nTITLE: Stopping Docker Containers\nDESCRIPTION: Command to stop running Docker containers using docker-compose.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/docker.md#2025-04-23_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ndocker-compose stop\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with Homebrew on macOS\nDESCRIPTION: Command to install Redis and PostgreSQL on macOS using Homebrew.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/environment-setup.md#2025-04-23_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\nbrew install redis postgresql@17\n```\n\n----------------------------------------\n\nTITLE: Making Arrays Same Length with NumPy Concatenation\nDESCRIPTION: A technique to match the lengths of arrays by prepending NaN values to the shorter array. This is useful when working with indicators that produce results shorter than the original candle data.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/custom-indicators.md#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\narray_with_matching_lenght = np.concatenate((np.full((candles.shape[0] - array_with_shorter_lenght.shape[0]), np.nan), array_with_shorter_lenght)\n```\n\n----------------------------------------\n\nTITLE: Making Arrays Same Length with Jesse Helper Function\nDESCRIPTION: An alternative approach to match array lengths using Jesse's built-in helper function 'same_length'. This function performs the same operation as the manual NumPy concatenation but with a more readable syntax.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/custom-indicators.md#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom jesse.helpers import same_length\narray_with_matching_lenght = same_length(candles, array_with_shorter_lenght)\n```\n\n----------------------------------------\n\nTITLE: Fake Candle Generation Examples\nDESCRIPTION: Shows how to generate fake candles with and without custom attributes.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/research/candles.md#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# example without attributes\nc1 = research.fake_candle()\nprint(c1)\n# output:\n# [1.60945986e+12 9.70000000e+01 1.02000000e+02 1.02000000e+02\n#  9.60000000e+01 2.20000000e+01]\n\n# example with attributes\nc2 = research.fake_candle({\n    'timestamp': 1643104557000,\n    'open': 10,\n    'close': 11,\n    'high': 12,\n    'low': 8,\n    'volume': 200,\n})\nprint(c2)\n# output:\n# [1.64310456e+12 1.00000000e+01 1.10000000e+01 1.20000000e+01\n#  8.00000000e+00 2.00000000e+02]\n```\n\n----------------------------------------\n\nTITLE: Installing Cython on Windows\nDESCRIPTION: Command to install Cython on Windows, which is required for Jesse.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/environment-setup.md#2025-04-23_snippet_17\n\nLANGUAGE: sh\nCODE:\n```\npip install cython\n```\n\n----------------------------------------\n\nTITLE: Installing Miniconda on Ubuntu\nDESCRIPTION: Commands to install Miniconda and create a dedicated environment for Jesse with Python 3.12.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/environment-setup.md#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nbash {name of the file you downloaded}\n\nconda create --name jesse python=3.12\nconda activate jesse\n```\n\n----------------------------------------\n\nTITLE: Implementing terminate() Method in Python for Jesse AI\nDESCRIPTION: This method is called right before the strategy terminates. It can be used for final logging or cleanup tasks.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/entering-and-exiting.md#2025-04-23_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef terminate(self):\n    self.log('About to terminate execution...')\n```\n\n----------------------------------------\n\nTITLE: Implementing __init__() Method in Python for Jesse AI\nDESCRIPTION: This method is the constructor for the strategy class. It demonstrates how to initialize the strategy, including calling the superclass constructor.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/strategies/entering-and-exiting.md#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef __init__(self):\n    super().__init__()\n\n    print('initiated the strategy class')\n```\n\n----------------------------------------\n\nTITLE: Configuring Jesse AI Environment Variables in .env File\nDESCRIPTION: This snippet shows the default environment variables for Jesse AI, including database credentials, API tokens, and exchange API keys. The file contains sections for general settings, notification configurations, and API credentials for various exchanges including Bitget, Binance, Bybit, and DYDX.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/configuration.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nPASSWORD=test\nAPP_PORT=9000\n\n# If not using docker, you probably want to set this to \"localhost\"\nPOSTGRES_HOST=postgres\n# POSTGRES_HOST=localhost\nPOSTGRES_NAME=jesse_db\nPOSTGRES_PORT=5432\nPOSTGRES_USERNAME=jesse_user\nPOSTGRES_PASSWORD=password\n\n# If not using docker, you probably want to set this to \"localhost\"\n# REDIS_HOST=localhost\nREDIS_HOST=redis\nREDIS_PORT=6379\nREDIS_PASSWORD=\n\n\n# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # \n# Live Trade Only                                                                 # \n# =============================================================================== #\n# Below values don't concern you if you haven't installed the live trade plugin   #\n# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # \n\n# Enter the API token which you created at https://jesse.trade/user/api-tokens:\nLICENSE_API_TOKEN=\n\n# For all notifications\nGENERAL_TELEGRAM_BOT_TOKEN=\nGENERAL_TELEGRAM_BOT_CHAT_ID=\nGENERAL_DISCORD_WEBHOOK=\nGENERAL_SLACK_WEBHOOK=\n\n# For error notifications only\nERROR_TELEGRAM_BOT_TOKEN=\nERROR_TELEGRAM_BOT_CHAT_ID=\nERROR_DISCORD_WEBHOOK=\nERROR_SLACK_WEBHOOK=\n\n# # # # # # # # # # # # # # # # # # # # # # \n# ======= Bitget\n# # # # # # # # # # # # # # # # # # # # # # \n\n# USDT Futures https://www.bitget.com/en/mix/usdt/BTCUSDT_UMCBL\nBITGET_USDT_PERPETUAL_API_KEY=\nBITGET_USDT_PERPETUAL_API_SECRET=\nBITGET_USDT_PERPETUAL_API_PASSPHRASE=\n\n# # # # # # # # # # # # # # # # # # # # # # \n# ======= Binance\n# # # # # # # # # # # # # # # # # # # # # # \n\n# Testnet Binance Futures (http://testnet.binancefuture.com)\nBINANCE_PERPETUAL_FUTURES_TESTNET_API_KEY=\nBINANCE_PERPETUAL_FUTURES_TESTNET_API_SECRET=\n\n# Binance Futures (https://www.binance.com/en/futures/btcusdt)\nBINANCE_PERPETUAL_FUTURES_API_KEY=\nBINANCE_PERPETUAL_FUTURES_API_SECRET=\n\n# Binance Spot (https://www.binance.com/en/trade/BTC_USDT?type=spot)\nBINANCE_SPOT_API_KEY=\nBINANCE_SPOT_API_SECRET=\n\n# Binance US Spot (https://www.binance.us)\nBINANCE_US_SPOT_API_KEY=\nBINANCE_US_SPOT_API_SECRET=\n\n# # # # # # # # # # # # # # # # # # # # \n# ======= Bybit\n# # # # # # # # # # # # # # # # # # # # \n\n# Bybit USDT futures testnet (https://testnet.bybit.com/trade/usdt/BTCUSDT)\nBYBIT_USDT_PERPETUAL_TESTNET_API_KEY=\nBYBIT_USDT_PERPETUAL_TESTNET_API_SECRET=\n\n# Bybit USDT futures (https://www.bybit.com/trade/usdt/BTCUSDT)\nBYBIT_USDT_PERPETUAL_API_KEY=\nBYBIT_USDT_PERPETUAL_API_SECRET=\n\n# Bybit USDC futures testnet (https://testnet.bybit.com/trade/futures/usdc/BTC-PERP)\nBYBIT_USDC_PERPETUAL_TESTNET_API_KEY=\nBYBIT_USDC_PERPETUAL_TESTNET_API_SECRET=\n\n# Bybit USDC futures (https://bybit.com/trade/futures/usdc/BTC-PERP)\nBYBIT_USDC_PERPETUAL_API_KEY=\nBYBIT_USDC_PERPETUAL_API_SECRET=\n\n# Bybit Spot Testnet (https://testnet.bybit.com/en/trade/spot/BTC/USDT)\nBYBIT_SPOT_TESTNET_API_KEY=\nBYBIT_SPOT_TESTNET_API_SECRET=\n\n# Bybit Spot (https://bybit.com/en/trade/spot/BTC/USDT)\nBYBIT_SPOT_API_KEY=\nBYBIT_SPOT_API_SECRET=\n\n# # # # # # # # # # # # # # # # # # # # # # \n# ======= DYDX\n# # # # # # # # # # # # # # # # # # # # # #\n\n# DYDX Perpetual Testnet (https://trade.stage.dydx.exchange/trade/ETH-USD)\nDYDX_PERPETUAL_TESTNET_API_KEY=\nDYDX_PERPETUAL_TESTNET_API_SECRET=\nDYDX_PERPETUAL_TESTNET_API_PASSPHRASE=\nDYDX_PERPETUAL_TESTNET_WALLET_ADDRESS=\nDYDX_PERPETUAL_TESTNET_STARK_PRIVATE_KEY=\n\n# DYDX Perpetual (https://jesse.trade/dydx)\nDYDX_PERPETUAL_API_KEY=\nDYDX_PERPETUAL_API_SECRET=\nDYDX_PERPETUAL_API_PASSPHRASE=\nDYDX_PERPETUAL_WALLET_ADDRESS=\nDYDX_PERPETUAL_STARK_PRIVATE_KEY=\n```\n\n----------------------------------------\n\nTITLE: Installing Redis on Windows Subsystem for Linux\nDESCRIPTION: Commands to install and run Redis server on Ubuntu under Windows Subsystem for Linux.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/environment-setup.md#2025-04-23_snippet_14\n\nLANGUAGE: sh\nCODE:\n```\n    sudo apt-get update\n    sudo apt-get upgrade\n    sudo apt-get install redis-server\n    redis-cli -v\n```\n\n----------------------------------------\n\nTITLE: Strategy Terminate Method - Python\nDESCRIPTION: The terminate() method was added to the strategy API for cleanup operations when strategy execution ends.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/changelog.md#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef terminate(self):\n    # Perform cleanup operations\n```\n\n----------------------------------------\n\nTITLE: Summing Floats Without Rounding Issues\nDESCRIPTION: Performs floating-point addition without the typical rounding issues in Python. Ensures accurate mathematical calculations for financial applications.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/utils.md#2025-04-23_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nsum_floats(float1: float, float2: float) -> float\n```\n\n----------------------------------------\n\nTITLE: Updating config for futures trading (Python)\nDESCRIPTION: The configuration for futures trading has been updated. Instead of using 'margin', now 'futures' should be used in the config file.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/changelog.md#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nconfig = {\n    'exchange': {\n        'name': 'Binance',\n        'type': 'futures'\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Indicators Directory Structure\nDESCRIPTION: The required folder structure for adding custom indicators to a Jesse project, showing the location of the main project folders and the new custom_indicators directory.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/custom-indicators.md#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n├── storage # folder containing logs, chart images, etc\n├── strategies # folder where you define your strategies\n└── custom_indicators # folder for Jesse's custom indicator\n    ├── __init__.py\n    └── ewo.py\n```\n\n----------------------------------------\n\nTITLE: Installing Miniconda on Intel-based Macs\nDESCRIPTION: Commands to download and install Miniconda on Intel-based Mac machines.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/environment-setup.md#2025-04-23_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\nmkdir -p ~/miniconda3\ncurl https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-x86_64.sh -o ~/miniconda3/miniconda.sh\nbash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3\nrm ~/miniconda3/miniconda.sh\n```\n\n----------------------------------------\n\nTITLE: Checking if Series is Strictly Increasing\nDESCRIPTION: Determines whether a series is strictly increasing over a specified lookback period. Useful for identifying consistent upward trends.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/utils.md#2025-04-23_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nstrictly_increasing(series, lookback)\n```\n\n----------------------------------------\n\nTITLE: Installing Jesse via PIP\nDESCRIPTION: This command installs Jesse using pip, the Python package installer. It's used for native installations when not using Docker.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/index.md#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\npip install jesse\n```\n\n----------------------------------------\n\nTITLE: Upgrading Jesse to the Latest Version\nDESCRIPTION: This command upgrades Jesse to the latest version using pip. It's recommended to run this command periodically to ensure you have the most recent updates and patches.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/index.md#2025-04-23_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\npip install -U jesse\n```\n\n----------------------------------------\n\nTITLE: Installing Jesse Live Trading Plugin in Native Environment\nDESCRIPTION: Command to install the live trading plugin for Jesse-AI in a native environment setup. This automatically downloads the correct version based on your system's CPU architecture, OS, Python version, and Jesse version.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/livetrade.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\njesse install-live\n```\n\n----------------------------------------\n\nTITLE: Installing PostgreSQL on Ubuntu\nDESCRIPTION: Commands to install PostgreSQL and set up the necessary database and user for Jesse.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/environment-setup.md#2025-04-23_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nsudo apt-get install postgresql postgresql-contrib\n\nsudo -u postgres psql -c \"CREATE DATABASE jesse_db;\"\nsudo -u postgres psql -c \"CREATE USER jesse_user WITH PASSWORD 'password';\"\nsudo -u postgres psql -c \"GRANT ALL PRIVILEGES ON DATABASE jesse_db TO jesse_user;\"\nsudo -u postgres psql -c \"ALTER DATABASE jesse_db OWNER TO jesse_user;\"\n```\n\n----------------------------------------\n\nTITLE: Enabling Windows Subsystem for Linux\nDESCRIPTION: PowerShell command to enable Windows Subsystem for Linux, which is needed to run Redis on Windows.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/environment-setup.md#2025-04-23_snippet_13\n\nLANGUAGE: sh\nCODE:\n```\nEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux\n```\n\n----------------------------------------\n\nTITLE: Running Jupyter in Docker or on a remote server\nDESCRIPTION: Command for running Jupyter Notebook in a Docker container or on a remote server with appropriate flags to enable remote access. The flags allow accessing Jupyter from a different machine using the server's IP address.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/research/jupyter.md#2025-04-23_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\njupyter notebook --ip 0.0.0.0 --no-browser --allow-root\n```\n\n----------------------------------------\n\nTITLE: Updating Jesse via PIP in Native Setup\nDESCRIPTION: Updates Jesse to the latest version using PIP package manager in a native environment setup. Requires verifying the installed version matches the latest release on PyPi.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/update.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -U jesse\n```\n\n----------------------------------------\n\nTITLE: Jesse AI Framework Change Log Entry 0.33.0\nDESCRIPTION: Release notes for version 0.33.0 highlighting new research module features, dashboard improvements, and multiple instance support.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/changelog.md#2025-04-23_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n## 0.33.0 (15 February 2022)\n\n- [NEW FEATURE] Added backtest function to research module\n- [NEW FEATURE] Added store_candles function\n- [NEW FEATURE] Added fake candle generation functions\n- [IMPROVEMENT] Added support for multiple instances\n```\n\n----------------------------------------\n\nTITLE: Converting Risk Percentage to Position Size\nDESCRIPTION: Calculates the position size based on capital, risk percentage, risk per quantity, and entry price. Helps determine how much capital to allocate to a position.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/utils.md#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nrisk_to_size(capital_size, risk_percentage, risk_per_qty, entry_price)\n```\n\n----------------------------------------\n\nTITLE: Installing JupyterLab using pip\nDESCRIPTION: Command to install JupyterLab using pip package manager. This should be run either in your virtual environment or inside the Jesse Docker container.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/research/jupyter.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npip install jupyterlab\n```\n\n----------------------------------------\n\nTITLE: Updating import statement in ExampleStrategy (Python)\nDESCRIPTION: The ExampleStrategy now imports ta and utils modules by default to provide easier access to technical analysis indicators and utility functions.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/changelog.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom jesse.strategies import Strategy\nimport jesse.indicators as ta\nfrom jesse import utils\n\nclass ExampleStrategy(Strategy):\n    # Strategy implementation\n```\n\n----------------------------------------\n\nTITLE: Jesse AI Framework Change Log Entry 0.35.0\nDESCRIPTION: Release notes for version 0.35.0 covering new candle import functionality, REST API improvements for live mode, and bug fixes.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/changelog.md#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n## 0.35.0 (6 April 2022)\n\n- [NEW FEATURE] Added the import_candles() method\n- [IMPROVEMENT] Live mode now uses REST API\n- [IMPROVEMENT] Added error handling\n- [FIX] Fixed various TypeError and visual bugs\n```\n\n----------------------------------------\n\nTITLE: Setting Up PostgreSQL on Windows\nDESCRIPTION: SQL commands to create the necessary database and user for Jesse on Windows PostgreSQL.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/environment-setup.md#2025-04-23_snippet_16\n\nLANGUAGE: sh\nCODE:\n```\n# Switch to postgres user. You will be asked for the password\npsql -U postgres\n# Create the database\nCREATE DATABASE jesse_db;\n# create a new user\nCREATE USER jesse_user WITH PASSWORD 'password';\n# set privileges of the created user\nGRANT ALL PRIVILEGES ON DATABASE jesse_db to jesse_user;\n# set the owner of the database to the new user (required for PostgreSQL >= 15)\nALTER DATABASE jesse_db OWNER TO jesse_user;\n# exit PostgreSQL CLI\n\\q\n```\n\n----------------------------------------\n\nTITLE: Starting Docker Containers for Jesse AI\nDESCRIPTION: Commands for navigating to the docker directory and starting the containers in detached mode using docker-compose.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/docker.md#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n# open the `docker` directory\ncd docker\n# run without the \"-d\" flag to see the output\ndocker-compose up -d\n```\n\n----------------------------------------\n\nTITLE: Installing Jesse Stack on Ubuntu 22.04 with Bash Script\nDESCRIPTION: A one-line command to install all required dependencies for Jesse on a fresh Ubuntu 22.04 LTS installation using the stack-installer script.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/environment-setup.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nsource <(curl -fsSL https://raw.githubusercontent.com/jesse-ai/stack-installer/master/ubuntu-22.04.sh)\n```\n\n----------------------------------------\n\nTITLE: Installing Miniconda on Apple Silicon Macs\nDESCRIPTION: Commands to download and install Miniconda on Apple Silicon (M1/M2/M3/M4) Mac machines.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/environment-setup.md#2025-04-23_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nmkdir -p ~/miniconda3\ncurl https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-arm64.sh -o ~/miniconda3/miniconda.sh\nbash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3\nrm ~/miniconda3/miniconda.sh\n```\n\n----------------------------------------\n\nTITLE: Configuring Shared Database Volume in Docker-Compose\nDESCRIPTION: YAML configuration for setting up shared database volumes across multiple Jesse AI instances using external volumes in docker-compose.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/docker.md#2025-04-23_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nvolumes:\n  postgres-data:\n    external: true\n```\n\n----------------------------------------\n\nTITLE: Creating Jesse Environment on Windows\nDESCRIPTION: Commands to create and activate a dedicated environment for Jesse on Windows using Conda.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/environment-setup.md#2025-04-23_snippet_12\n\nLANGUAGE: sh\nCODE:\n```\nconda create --name jesse python=3.12\n\nconda activate jesse\n```\n\n----------------------------------------\n\nTITLE: Setting Up PostgreSQL on macOS\nDESCRIPTION: SQL commands to create the necessary database and user for Jesse on macOS PostgreSQL.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/environment-setup.md#2025-04-23_snippet_10\n\nLANGUAGE: sh\nCODE:\n```\n# open PostgreSQL CLI\npsql postgres\n# create database\nCREATE DATABASE jesse_db;\n# create new user\nCREATE USER jesse_user WITH PASSWORD 'password';\n# set privileges of the created user\nGRANT ALL PRIVILEGES ON DATABASE jesse_db to jesse_user;\n# set the owner of the database to the new user (required for PostgreSQL >= 15)\nALTER DATABASE jesse_db OWNER TO jesse_user;\n# exit PostgreSQL CLI\n\\q\n```\n\n----------------------------------------\n\nTITLE: Jesse AI Framework Change Log Entry 0.36.0\nDESCRIPTION: Release notes for version 0.36.0 documenting new features in research module, improvements to logging and notifications, and various bug fixes.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/changelog.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## 0.36.0 (18 May 2022)\n\n- [NEW FEATURE] Added new optional parameters to research module's backtest() function\n- [IMPROVEMENT] Updated the self.log() method\n- [IMPROVEMENT] Improved handling of errors in the REST API\n- [IMPROVEMENT] Improved handling of the entry_price at FTX\n- [FIX] Fixed various bugs and errors\n```\n\n----------------------------------------\n\nTITLE: Starting Redis Server on WSL\nDESCRIPTION: Command to start the Redis server on Windows Subsystem for Linux.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/getting-started/environment-setup.md#2025-04-23_snippet_15\n\nLANGUAGE: sh\nCODE:\n```\nredis-server\n```\n\n----------------------------------------\n\nTITLE: Importing Custom Indicator in __init__.py\nDESCRIPTION: Code for importing the Elliott Wave Oscillator indicator in the custom_indicators/__init__.py file, making it available to strategies.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/custom-indicators.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom .ewo import ewo\n```\n\n----------------------------------------\n\nTITLE: Jesse AI Framework Change Log Entry 0.34.0\nDESCRIPTION: Release notes for version 0.34.0 documenting real-time sync improvements, persistency support, and new position tracking features.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/changelog.md#2025-04-23_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n## 0.34.0 (24 March 2022)\n\n- [IMPROVEMENTS] Real-time sync implementation\n- [NEW FEATURE] Added persistency support\n- [NEW FEATURE] Added order class properties\n- [BREAKING CHANGE] Dependencies are now locked\n```\n\n----------------------------------------\n\nTITLE: Configuring Vitepress Homepage Layout for Jesse AI Trading Framework\nDESCRIPTION: This YAML/Markdown configuration sets up the homepage for the Jesse AI trading framework website using Vitepress. It defines the layout, hero section with promotional text and images, call-to-action buttons, and a comprehensive feature list showcasing the framework's capabilities.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/index.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\n# https://vitepress.dev/reference/default-theme-home-page\nlayout: home\n\nhero:\n  name: \"Jesse\"\n  text: \"The Advanced Algo-Trading Framework in Python\"\n  tagline: \"Self-Hosted and Privacy-First: Simplicity, Accuracy, and Flexibility in Algorithmic Trading\"\n  image:\n    src: /imgs/w-01.png\n    alt: Jesse\n  actions:\n    - theme: brand\n      text: Get Started →\n      link: /docs/getting-started/\n    - theme: alt\n      text: Join the Community →\n      link: https://jesse.trade/discord\n\nfeatures:\n  - title: \"📝 Simple Syntax\"\n    details: Define both simple and advanced trading strategies with the simplest syntax in the fastest time.\n  - title: \"📊 Comprehensive Indicator Library\"\n    details: Access a complete library of technical indicators with easy-to-use syntax.\n  - title: \"📈 Smart Ordering\"\n    details: Supports market, limit, and stop orders, automatically choosing the best one for you.\n  - title: \"⏰ Multiple Timeframes and Symbols\"\n    details: Backtest and livetrade multiple timeframes and symbols simultaneously without look-ahead bias.\n  - title: \"🔒 Self-Hosted and Privacy-First\"\n    details: Jesse is designed with your privacy in mind, fully self-hosted to ensure your trading strategies and data remain secure.\n  - title: \"🛡️ Risk Management\"\n    details: Built-in helper functions for robust risk management.\n  - title: \"📋 Metrics System\"\n    details: A comprehensive metrics system to evaluate your trading strategy's performance.\n  - title: \"🔍 Debug Mode\"\n    details: Observe your strategy in action with a detailed debug mode.\n  - title: \"🔧 Optimize Mode\"\n    details: Fine-tune your strategies using AI, without needing a technical background.\n  - title: \"📈 Leveraged and Short-Selling\"\n    details: First-class support for leveraged trading and short-selling.\n  - title: \"🔀 Partial Fills\"\n    details: Supports entering and exiting positions in multiple orders, allowing for greater flexibility.\n  - title: \"🔔 Advanced Alerts\"\n    details: Create real-time alerts within your strategies for effective monitoring.\n  - title: \"📉 Auto-Generated Charts\"\n    details: View your portfolio's performance with automatically generated charts.\n  - title: \"🧹 Data Cleaning\"\n    details: Automatic handling of importing candles and cleaning data.\n  - title: \"📈 First-Class Support for Trading Futures and Spot\"\n    details: Jesse Offers specialized support for both futures and spot markets.\n  - title: \"🔐 Support for Decentralized Exchanges (DEX)\"\n    details: Jesse's support for DEX ensures you can maintain full custody of your assets while trading.\n---\n```\n\n----------------------------------------\n\nTITLE: Converting Timeframe to Minutes\nDESCRIPTION: Converts a given timeframe string (e.g., '1h', '1d') to its equivalent value in minutes. Useful for timeframe comparisons and calculations.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/utils.md#2025-04-23_snippet_20\n\nLANGUAGE: python\nCODE:\n```\ntimeframe_to_one_minutes(timeframe)\n```\n\nLANGUAGE: python\nCODE:\n```\nminutes = timeframe_to_one_minutes('1h')  # returns 60\n```\n\n----------------------------------------\n\nTITLE: Center of Gravity Indicator in Python\nDESCRIPTION: Identifies potential reversal points by calculating average price levels.\nSOURCE: https://github.com/jesse-ai/docs/blob/master/docs/docs/indicators/reference.md#2025-04-23_snippet_21\n\nLANGUAGE: python\nCODE:\n```\ncg(candles: np.ndarray, period: int = 10, source_type: str = \"close\", sequential: bool = False) -> Union[float, np.ndarray]\n```"
  }
]