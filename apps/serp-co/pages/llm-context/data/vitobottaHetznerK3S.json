[
  {
    "owner": "vitobotta",
    "repo": "hetzner-k3s",
    "content": "TITLE: Defining Hetzner K3s Cluster Configuration with YAML\nDESCRIPTION: This YAML snippet serves as the main configuration file for the hetzner-k3s tool, specifying parameters for cluster creation, such as Hetzner API token, cluster name, Kubernetes version, and kubeconfig path. It includes detailed networking settings including SSH access, allowed networks, public and private network configuration, and CNI plugin options. The masters and worker node pools are defined with instance types, instance counts, locations, and autoscaling settings. Additional optional configurations such as manifests URLs, datastore mode, embedded registry mirror, upgrade concurrency, custom OS images, cloud-init commands, and API server hostname can be customized. It supports disabling public IPs, defining multiple node pools with distinct specs, and setting cluster IP ranges. This configuration file is intended to be passed to hetzner-k3s CLI commands for cluster management.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Creating_a_cluster.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nhetzner_token: <your token>\ncluster_name: test\nkubeconfig_path: \"./kubeconfig\"\nk3s_version: v1.30.3+k3s1\n\nnetworking:\n  ssh:\n    port: 22\n    use_agent: false # set to true if your key has a passphrase\n    public_key_path: \"~/.ssh/id_ed25519.pub\"\n    private_key_path: \"~/.ssh/id_ed25519\"\n  allowed_networks:\n    ssh:\n      - 0.0.0.0/0\n    api: # this will firewall port 6443 on the nodes\n      - 0.0.0.0/0\n  public_network:\n    ipv4: true\n    ipv6: true\n    # hetzner_ips_query_server_url: https://.. # for large clusters, see https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Recommendations.md\n    # use_local_firewall: false # for large clusters, see https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Recommendations.md\n  private_network:\n    enabled: true\n    subnet: 10.0.0.0/16\n    existing_network_name: \"\"\n  cni:\n    enabled: true\n    encryption: false\n    mode: flannel\n\n  # cluster_cidr: 10.244.0.0/16 # optional: a custom IPv4/IPv6 network CIDR to use for pod IPs\n  # service_cidr: 10.43.0.0/16 # optional: a custom IPv4/IPv6 network CIDR to use for service IPs. Warning, if you change this, you should also change cluster_dns!\n  # cluster_dns: 10.43.0.10 # optional: IPv4 Cluster IP for coredns service. Needs to be an address from the service_cidr range\n\n\n# manifests:\n#   cloud_controller_manager_manifest_url: \"https://github.com/hetznercloud/hcloud-cloud-controller-manager/releases/download/v1.23.0/ccm-networks.yaml\"\n#   csi_driver_manifest_url: \"https://raw.githubusercontent.com/hetznercloud/csi-driver/v2.12.0/deploy/kubernetes/hcloud-csi.yml\"\n#   system_upgrade_controller_deployment_manifest_url: \"https://github.com/rancher/system-upgrade-controller/releases/download/v0.14.2/system-upgrade-controller.yaml\"\n#   system_upgrade_controller_crd_manifest_url: \"https://github.com/rancher/system-upgrade-controller/releases/download/v0.14.2/crd.yaml\"\n#   cluster_autoscaler_manifest_url: \"https://raw.githubusercontent.com/kubernetes/autoscaler/master/cluster-autoscaler/cloudprovider/hetzner/examples/cluster-autoscaler-run-on-master.yaml\"\n#   cluster_autoscaler_container_image_tag: \"v1.32.0\"\n\ndatastore:\n  mode: etcd # etcd (default) or external\n  external_datastore_endpoint: postgres://....\n\nschedule_workloads_on_masters: false\n\n# image: rocky-9 # optional: default is ubuntu-24.04\n# autoscaling_image: 103908130 # optional, defaults to the `image` setting\n# snapshot_os: microos # optional: specified the os type when using a custom snapshot\n\nmasters_pool:\n  instance_type: cpx21\n  instance_count: 3 # for HA; you can also create a single master cluster for dev and testing (not recommended for production)\n  locations: # You can choose a single location for single master clusters or if you prefer to have all masters in the same location. For regional clusters (which are only available in the eu-central network zone), each master needs to be placed in a separate location.\n    - fsn1\n    - hel1\n    - nbg1\n\nworker_node_pools:\n- name: small-static\n  instance_type: cpx21\n  instance_count: 4\n  location: hel1\n  # image: debian-11\n  # labels:\n  #   - key: purpose\n  #     value: blah\n  # taints:\n  #   - key: something\n  #     value: value1:NoSchedule\n- name: medium-autoscaled\n  instance_type: cpx31\n  location: fsn1\n  autoscaling:\n    enabled: true\n    min_instances: 0\n    max_instances: 3\n\nembedded_registry_mirror:\n  enabled: false # Enables fast p2p distribution of container images between nodes for faster pod startup. Check if your k3s version is compatible before enabling this option. You can find more information at https://docs.k3s.io/installation/registry-mirror\n\nprotect_against_deletion: true\n\ncreate_load_balancer_for_the_kubernetes_api: false # Just a heads up: right now, we can’t limit access to the load balancer by IP through the firewall. This feature hasn’t been added by Hetzner yet.\n\nk3s_upgrade_concurrency: 1 # how many nodes to upgrade at the same time\n\n# additional_packages:\n# - somepackage\n\n# post_create_commands:\n# - apt update\n# - apt upgrade -y\n# - apt autoremove -y\n\n# kube_api_server_args:\n# - arg1\n# - ...\n# kube_scheduler_args:\n# - arg1\n# - ...\n# kube_controller_manager_args:\n# - arg1\n# - ...\n# kube_cloud_controller_manager_args:\n# - arg1\n# - ...\n# kubelet_args:\n# - arg1\n# - ...\n# kube_proxy_args:\n# - arg1\n# - ...\n# api_server_hostname: k8s.example.com # optional: DNS for the k8s API LoadBalancer. After the script has run, create a DNS record with the address of the API LoadBalancer.\n```\n\n----------------------------------------\n\nTITLE: Configuring hetzner-k3s Cluster Settings (YAML)\nDESCRIPTION: This YAML configuration file defines the settings for creating a Kubernetes cluster using the hetzner-k3s tool. It specifies the Hetzner API token, cluster name, kubeconfig path, K3s version, networking details (SSH keys, allowed networks), and node pool configurations including instance types, counts, and locations for both master and worker nodes. An optional autoscaling configuration for a worker pool is also shown.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Setting up a cluster.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nhetzner_token: ...\ncluster_name: hello-world\nkubeconfig_path: \"./kubeconfig\"  # or /cluster/kubeconfig if you are going to use Docker\nk3s_version: v1.32.0+k3s1\n\nnetworking:\n  ssh:\n    port: 22\n    use_agent: false\n    public_key_path: \"~/.ssh/id_rsa.pub\"\n    private_key_path: \"~/.ssh/id_rsa\"\n  allowed_networks:\n    ssh:\n      - 0.0.0.0/0\n    api:\n      - 0.0.0.0/0\n\nmasters_pool:\n  instance_type: cpx21\n  instance_count: 3\n  locations:\n    - fsn1\n    - hel1\n    - nbg1\n\nworker_node_pools:\n- name: small\n  instance_type: cpx21\n  instance_count: 4\n  location: hel1\n- name: big\n  instance_type: cpx31\n  location: fsn1\n  autoscaling:\n    enabled: true\n    min_instances: 0\n    max_instances: 3\n```\n\n----------------------------------------\n\nTITLE: Cluster Configuration: Disable Public Network\nDESCRIPTION: This YAML configuration snippet disables the public network interfaces (IPv4 and IPv6) and enables the private network.  It also defines the subnet for the private network and the name of the existing Hetzner Cloud private network.  It also configures allowed networks for SSH and API access.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Private_clusters_with_public_network_interface_disabled.md#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n  public_network:\n    ipv4: false\n    ipv6: false\n  private_network:\n    enabled : true\n    subnet: 10.0.0.0/16\n    existing_network_name: \"<name of your private network>\"\n  allowed_networks:\n    ssh:\n      - 0.0.0.0/0\n    api:\n      - 0.0.0.0/0\n```\n\n----------------------------------------\n\nTITLE: Upgrading hetzner-k3s Cluster Using Bash\nDESCRIPTION: Commands to upgrade k3s clusters managed by hetzner-k3s. The upgrade command updates the cluster configuration with the specified k3s version, automatically applying changes. Monitoring commands enable live tracking of node upgrade status. Additional bash snippets provide cleanup operations for stalled upgrades, restarting the upgrade controller deployment, and viewing logs to diagnose upgrade problems. Labeling masters as upgraded helps continue upgrades of worker nodes if stuck.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Maintenance.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nhetzner-k3s upgrade --config cluster_config.yaml --new-k3s-version v1.27.1-rc2+k3s1\n```\n\nLANGUAGE: bash\nCODE:\n```\nkubectl -n system-upgrade delete job --all\nkubectl -n system-upgrade delete plan --all\n\nkubectl label node --all plan.upgrade.cattle.io/k3s-server- plan.upgrade.cattle.io/k3s-agent-\n\nkubectl -n system-upgrade rollout restart deployment system-upgrade-controller\nkubectl -n system-upgrade rollout status deployment system-upgrade-controller\n```\n\nLANGUAGE: bash\nCODE:\n```\nkubectl -n system-upgrade \\\n  logs -f $(kubectl -n system-upgrade get pod -l pod-template-hash -o jsonpath=\"{.items[0].metadata.name}\")\n```\n\nLANGUAGE: bash\nCODE:\n```\nkubectl label node <master1> <master2> <master2> plan.upgrade.cattle.io/k3s-server=upgraded\n```\n\n----------------------------------------\n\nTITLE: Customizing ingress-nginx Helm Chart with Annotations (YAML)\nDESCRIPTION: This YAML snippet provides custom values, primarily annotations, for the ingress-nginx Helm chart deployment, specifically tailored for Hetzner Cloud. It configures the controller service to use a DaemonSet and specifies Hetzner Load Balancer annotations like location, name, enabling private IP usage, enabling proxy protocol (to preserve client IPs), and setting a hostname for cert-manager compatibility. These values are intended to be saved in a file (e.g., `ingress-nginx-annotations.yaml`) and applied using `helm upgrade --install -f`. Comments within the code provide context on prerequisites and annotation purposes.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Setting up a cluster.md#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n# INSTALLATION\n# 1. Install Helm: https://helm.sh/docs/intro/install/\n# 2. Add ingress-nginx Helm repo: helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx\n# 3. Update information of available charts: helm repo update\n# 4. Install ingress-nginx:\n# helm upgrade --install \\\n# ingress-nginx ingress-nginx/ingress-nginx \\\n# --set controller.ingressClassResource.default=true \\ # Remove this line if you don’t want Nginx to be the default Ingress Controller\n# -f ./ingress-nginx-annotations.yaml \\\n# --namespace ingress-nginx \\\n# --create-namespace\n\n# LIST of all ANNOTATIONS: https://github.com/hetznercloud/hcloud-cloud-controller-manager/blob/master/internal/annotation/load_balancer.go\n\ncontroller:\n  kind: DaemonSet\n  service:\n    annotations:\n      # Germany:\n      # - nbg1 (Nuremberg)\n      # - fsn1 (Falkenstein)\n      # Finland:\n      # - hel1 (Helsinki)\n      # USA:\n      # - ash (Ashburn, Virginia)\n      # Without this, the load balancer won’t be provisioned and will stay in \"pending\" state.\n      # You can check this state using \"kubectl get svc -n ingress-nginx\"\n      load-balancer.hetzner.cloud/location: nbg1\n\n      # Name of the load balancer. This name will appear in your Hetzner cloud console under \"Your project -> Load Balancers\".\n      # NOTE: This is NOT the load balancer created automatically for HA clusters. You need to specify a different name here to create a separate load balancer for ingress Nginx.\n      load-balancer.hetzner.cloud/name: WORKERS_LOAD_BALANCER_NAME\n\n      # Ensures communication between the load balancer and cluster nodes happens through the private network.\n      load-balancer.hetzner.cloud/use-private-ip: \"true\"\n\n      # [ START: Use these annotations if you care about seeing the actual client IP ]\n      # \"uses-proxyprotocol\" enables the proxy protocol on the load balancer so that the ingress controller and applications can see the real client IP.\n      # \"hostname\" is needed if you use cert-manager (LetsEncrypt SSL certificates). It fixes HTTP01 challenges for cert-manager (https://cert-manager.io/docs/).\n      # Check this link for more details: https://github.com/compumike/hairpin-proxy\n      # In short: the easiest fix provided by some providers (including Hetzner) is to configure the load balancer to use a hostname instead of an IP.\n      load-balancer.hetzner.cloud/uses-proxyprotocol: 'true'\n\n      # 1. \"yourDomain.com\" must be correctly configured in DNS to point to the Nginx load balancer; otherwise, certificate provisioning won’t work.\n      # 2. If you use multiple domains, specify any one.\n      load-balancer.hetzner.cloud/hostname: yourDomain.com\n      # [ END: Use these annotations if you care about seeing the actual client IP ]\n\n      load-balancer.hetzner.cloud/http-redirect-https: 'false'\n```\n\n----------------------------------------\n\nTITLE: Creating Hetzner K3s Cluster via CLI Using YAML Configuration\nDESCRIPTION: This command runs the hetzner-k3s CLI tool to create a Kubernetes cluster on Hetzner Cloud using the specified YAML configuration file. The --config flag passes the cluster configuration file (e.g., cluster_config.yaml) to the tool. The output is piped to tee to log the creation process to create.log while displaying it interactively. The cluster creation process duration depends on the number and type of master and worker nodes defined in the configuration. The command assumes the environment is properly set up with access to Hetzner's APIs either via the config or HCLOUD_TOKEN environment variable.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Creating_a_cluster.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nhetzner-k3s create --config cluster_config.yaml | tee create.log\n```\n\n----------------------------------------\n\nTITLE: Configuring Load Balancer Location and Private IP - YAML\nDESCRIPTION: This YAML snippet demonstrates the essential annotations required for configuring a Hetzner Cloud load balancer.  It sets the load balancer's location to the 'nbg1' network zone and configures it to route traffic through the private network. This avoids the need for firewall changes.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Load_balancers.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nload-balancer.hetzner.cloud/location: nbg1  # Ensures the load balancer is in the same network zone as your nodes\nload-balancer.hetzner.cloud/use-private-ip: \"true\"  # Routes traffic between the load balancer and nodes through the private network, avoiding firewall changes\n```\n\n----------------------------------------\n\nTITLE: Deleting a hetzner-k3s Cluster (Bash)\nDESCRIPTION: This command initiates the deletion process for a Kubernetes cluster managed by `hetzner-k3s`, referencing a specific configuration file (`cluster_config.yaml`). It removes Hetzner Cloud resources created by `hetzner-k3s` but requires the `protect_against_deletion` flag in the config file to be set to `false`. Users will be prompted to enter the cluster name for confirmation. Note that application-created load balancers and persistent volumes are not automatically deleted.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Deleting_a_cluster.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nhetzner-k3s delete --config cluster_config.yaml\n```\n\n----------------------------------------\n\nTITLE: Installing ingress-nginx using Helm (Bash)\nDESCRIPTION: This Bash command uses Helm to install or upgrade the ingress-nginx chart from its repository. It sets ingress-nginx as the default Ingress Class (`--set controller.ingressClassResource.default=true`), applies custom configurations from the `ingress-nginx-annotations.yaml` file (`-f`), installs it into the `ingress-nginx` namespace, and creates the namespace if it doesn't exist (`--namespace ingress-nginx --create-namespace`). Requires Helm and kubectl to be installed and configured.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Setting up a cluster.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nhelm upgrade --install \\\ningress-nginx ingress-nginx/ingress-nginx \\\n--set controller.ingressClassResource.default=true \\\n-f ./ingress-nginx-annotations.yaml \\\n--namespace ingress-nginx \\\n--create-namespace\n```\n\n----------------------------------------\n\nTITLE: Configuring LetsEncrypt ClusterIssuer in Kubernetes\nDESCRIPTION: Creates a ClusterIssuer resource that connects to LetsEncrypt's production ACME server for issuing TLS certificates using HTTP-01 challenge with the nginx ingress controller.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Setting up a cluster.md#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\n  name: letsencrypt-prod\n  namespace: cert-manager\nspec:\n  acme:\n    email: [REDACTED]\n    server: https://acme-v02.api.letsencrypt.org/directory\n    privateKeySecretRef:\n      name: letsencrypt-prod-account-key\n    solvers:\n    - http01:\n        ingress:\n          class: nginx\n```\n\n----------------------------------------\n\nTITLE: Configuring Kubernetes Ingress with TLS Support\nDESCRIPTION: Updates an existing Ingress resource to use LetsEncrypt for TLS certificate generation and termination, specifying the domain name and secret for certificate storage.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Setting up a cluster.md#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: hello-world\n  annotations:\n    cert-manager.io/cluster-issuer: \"letsencrypt-prod\"  # <<<--- Add annotation\n    kubernetes.io/tls-acme: \"true\"                      # <<<--- Add annotation\nspec:\n  rules:\n  - host: yourDomain.com  # <<<---- Your actual domain\n  tls: # <<<---- Add this block\n  - hosts:\n    - yourDomain.com\n    secretName: yourDomain.com-tls # <<<--- Add reference to secret\n  ....\n```\n\n----------------------------------------\n\nTITLE: Automating OS Upgrade on Kubernetes Nodes Using YAML and Bash\nDESCRIPTION: YAML snippet for adding necessary packages and commands to enable unattended OS upgrades on cluster nodes. This ensures security updates are automatically applied. The configuration integrates with the Kubernetes Reboot Daemon (Kured) for automated node reboots post-upgrade. The instructions emphasize draining nodes before upgrade, rebooting, and uncordoning to maintain cluster availability.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Maintenance.md#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nadditional_packages:\n- unattended-upgrades\n- update-notifier-common\npost_create_commands:\n- sudo systemctl enable unattended-upgrades\n- sudo systemctl start unattended-upgrades\n```\n\n----------------------------------------\n\nTITLE: Enabling Proxy Protocol for ingress-nginx Controller (YAML)\nDESCRIPTION: This Kubernetes manifest defines a ConfigMap named `ingress-nginx-controller` in the `ingress-nginx` namespace. It sets the `use-proxy-protocol` data key to `\"true\"`, which configures the Nginx Ingress Controller to correctly handle requests when the Hetzner Load Balancer has the `load-balancer.hetzner.cloud/uses-proxyprotocol: 'true'` annotation enabled, allowing backend applications to see the original client IP address. This ConfigMap needs to be applied using `kubectl apply -f <filename>.yaml`.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Setting up a cluster.md#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  # Do not change the name - this is required by the Nginx Ingress Controller\n  name: ingress-nginx-controller\n  namespace: ingress-nginx\ndata:\n  use-proxy-protocol: \"true\"\n```\n\n----------------------------------------\n\nTITLE: Installing LetsEncrypt Certificate Manager with Helm\nDESCRIPTION: Installs the cert-manager Helm chart in the cert-manager namespace with CRDs enabled to handle LetsEncrypt certificate issuance for the Kubernetes cluster.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Setting up a cluster.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nhelm upgrade --install \\\n--namespace cert-manager \\\n--create-namespace \\\n--set crds.enabled=true \\\ncert-manager jetstack/cert-manager\n```\n\n----------------------------------------\n\nTITLE: Recommended Load Balancer Annotations - YAML\nDESCRIPTION: This YAML snippet shows the recommended annotations for a Hetzner Cloud load balancer, including setting a hostname, disabling HTTP to HTTPS redirection, assigning a name, and enabling the proxy protocol. Enabling the proxy protocol is useful for detecting the real client IP address, but can conflict with cert-manager HTTP01 challenges.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Load_balancers.md#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nload-balancer.hetzner.cloud/hostname: <a valid fqdn>\nload-balancer.hetzner.cloud/http-redirect-https: 'false'\nload-balancer.hetzner.cloud/name: <lb name>\nload-balancer.hetzner.cloud/uses-proxyprotocol: 'true'\n```\n\n----------------------------------------\n\nTITLE: Configuring Kubernetes Ingress for Hello World App (YAML)\nDESCRIPTION: This YAML snippet shows modifications needed for a Kubernetes Ingress resource to route traffic to the 'hello-world' application. It adds the `kubernetes.io/ingress.class: nginx` annotation to specify that the Nginx Ingress Controller should manage this Ingress. It also sets the hostname rule (`spec.rules[0].host`) to use a dynamic DNS service (`.nip.io`) combined with the Load Balancer's public IP for easy testing without actual DNS configuration.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Setting up a cluster.md#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: hello-world\n  annotations:                       # <<<--- Add annotation\n    kubernetes.io/ingress.class: nginx  # <<<--- Add annotation\nspec:\n  rules:\n  - host: hello-world.IP_FROM_STEP_12.nip.io # <<<--- Replace `IP_FROM_STEP_12` with the IP from step 16.\n  ....\n```\n\n----------------------------------------\n\nTITLE: Querying Hetzner Cloud Server Types Using Bash\nDESCRIPTION: This bash command uses curl with an Authorization header bearing the Hetzner API token to retrieve JSON data about available server types from Hetzner Cloud's API endpoint. This is useful for dynamically discovering instance types and their specifications before configuring cluster nodes. The API token must be set in the environment variable $API_TOKEN prior to running the command. The output includes server type details like CPU, memory, and storage, which helps in selecting appropriate instance types for masters and workers.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Creating_a_cluster.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -H \"Authorization: Bearer $API_TOKEN\" 'https://api.hetzner.cloud/v1/server_types'\n```\n\n----------------------------------------\n\nTITLE: YAML Configuration for Master Locations\nDESCRIPTION: This YAML snippet demonstrates how to specify the locations for the master nodes in a Hetzner K3s cluster. The `locations` property under the `masters` pool should be updated to include `fsn1`, `hel1`, and `nbg1` to create a regional cluster.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Masters_in_different_locations.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nlocations:\n- fns1\n- hel1\n- nbg1\n```\n\n----------------------------------------\n\nTITLE: Querying Hetzner Cloud Available Images Using Bash\nDESCRIPTION: This bash snippet leverages curl with Hetzner Cloud API token authorization to fetch a list of all available images, including official OS images and user snapshots. The token must be stored in the environment variable $API_TOKEN. The 'per_page=100' query parameter ensures up to 100 images are returned. This list helps users select valid image IDs or names to specify in cluster YAML configurations for node operating system choices or snapshots. Proper network connectivity and valid token are prerequisites.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Creating_a_cluster.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nexport API_TOKEN=...\n\ncurl -H \"Authorization: Bearer $API_TOKEN\" 'https://api.hetzner.cloud/v1/images?per_page=100'\n```\n\n----------------------------------------\n\nTITLE: Configuring NAT Gateway Interface (Debian)\nDESCRIPTION: This snippet modifies the `/etc/network/interfaces` file on a Debian-based NAT gateway instance to enable IP forwarding and set up masquerading for the private network. This allows nodes in the private network to access the internet through the NAT gateway.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Private_clusters_with_public_network_interface_disabled.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nauto enp7s0\niface enp7s0 inet dhcp\n    post-up echo 1 > /proc/sys/net/ipv4/ip_forward\n    post-up iptables -t nat -A POSTROUTING -s '10.0.0.0/16' -o enp7s0 -j MASQUERADE\n```\n\n----------------------------------------\n\nTITLE: Cluster Configuration: Debian 12 Image\nDESCRIPTION: This YAML snippet sets the OS image for the cluster nodes to Debian 12. This setting changes the image used for the cluster's master and worker nodes. This is an example and can be set to another available OS image.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Private_clusters_with_public_network_interface_disabled.md#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nimage: debian-12\nautoscaling_image: debian-12\n```\n\n----------------------------------------\n\nTITLE: Post-Create Commands: Ubuntu 24.04 Configuration\nDESCRIPTION: This YAML snippet specifies commands to be executed after the cluster nodes are created.  This example sets up the network configuration and DNS settings for Ubuntu, ensuring nodes use the NAT gateway and correct DNS for internet access. These commands configure the network interface to use DHCP and sets a gateway and DNS servers.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Private_clusters_with_public_network_interface_disabled.md#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\npost_create_commands:\n- printf \"[Match]\\nName=enp7s0\\n\\n[Network]\\nDHCP=yes\\nGateway=10.0.0.1\\n\" > /etc/systemd/network/10-enp7s0.network\n- printf \"[Resolve]\\nDNS=185.12.64.2 185.12.64.1\" > /etc/systemd/resolved.conf\n- systemctl restart systemd-networkd\n- systemctl restart systemd-resolved\n```\n\n----------------------------------------\n\nTITLE: Post-Create Commands: Debian 12 Configuration\nDESCRIPTION: This YAML snippet configures network settings and DNS for Debian 12 after the cluster is created, ensuring nodes can reach the internet through the NAT gateway.  This includes apt updates, adding network configuration, adding nameservers, and restarting services.  This is a series of commands to configure the network and DNS settings.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Private_clusters_with_public_network_interface_disabled.md#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\npost_create_commands:\n- apt update\n- apt upgrade -y\n- apt install ifupdown resolvconf -y\n- apt autoremove -y hc-utils\n- apt purge -y hc-utils\n- echo \"auto enp7s0\" > /etc/network/interfaces.d/60-private\n- echo \"iface enp7s0 inet dhcp\" >> /etc/network/interfaces.d/60-private\n- echo \"    post-up ip route add default via 10.0.0.1\"  >> /etc/network/interfaces.d/60-private\n- echo \"[Resolve]\" > /etc/systemd/resolved.conf\n- echo \"DNS=1.1.1.1 1.0.0.1\" >> /etc/systemd/resolved.conf\n- ifdown enp7s0\n- ifup enp7s0\n- systemctl start resolvconf\n- systemctl enable resolvconf\n- echo \"nameserver 1.1.1.1\" >> /etc/resolvconf/resolv.conf.d/head\n- echo \"nameserver 1.0.0.1\" >> /etc/resolvconf/resolv.conf.d/head\n- resolvconf --enable-updates\n- resolvconf -u\n```\n\n----------------------------------------\n\nTITLE: Automated DNS resolver configuration script using hcloud CLI\nDESCRIPTION: This Bash script automates the process of setting DNS resolvers on existing servers by iterating through server IPs obtained via 'hcloud server list', and configuring each server with Google's public DNS (8.8.8.8). It uses SSH and AWK for parsing and command execution, facilitating DNS setup during cluster migration.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Upgrading_a_cluster_from_1x_to_2x.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nhcloud server list | awk '{print $4}' | tail -n +2 | while read ip; do\n  echo \"Setting DNS for ${ip}\"\n  ssh -n root@${ip} \"echo nameserver 8.8.8.8 | tee /etc/k8s-resolv.conf\"\n  ssh -n root@${ip} \"cat /etc/k8s-resolv.conf\"\n done\n```\n\n----------------------------------------\n\nTITLE: Post-creation Commands for Node Autoscaling with NAT\nDESCRIPTION: Configuration example for setting up automatic IP routing through a NAT server when new nodes are created during autoscaling, using post-creation commands.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Setting up a cluster.md#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\nadditional_packages:\n  - ifupdown\npost_create_commands:\n  - apt update\n  - apt upgrade -y\n  - apt autoremove -y\n  - ip route add default via [REDACTED]  # Replace this with your gateway IP\n```\n\n----------------------------------------\n\nTITLE: etcdctl member list command for verifying etcd cluster membership\nDESCRIPTION: This set of commands installs the etcd client, sets environment variables for secure communication with the etcd server, and lists cluster members to verify the etcd control plane nodes are in sync after replacement. It is used during control plane rotation to ensure cluster health.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Upgrading_a_cluster_from_1x_to_2x.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get update\nsudo apt-get install etcd-client\n\nexport ETCDCTL_API=3\nexport ETCDCTL_ENDPOINTS=https://127.0.0.1:2379\nexport ETCDCTL_CACERT=/var/lib/rancher/k3s/server/tls/etcd/server-ca.crt\nexport ETCDCTL_CERT=/var/lib/rancher/k3s/server/tls/etcd/server-client.crt\nexport ETCDCTL_KEY=/var/lib/rancher/k3s/server/tls/etcd/server-client.key\n\netcdctl member list\n```\n\n----------------------------------------\n\nTITLE: Bash Commands to Verify Etcd Cluster Membership\nDESCRIPTION: This bash snippet provides a series of commands to verify that the K3s cluster's etcd setup is functioning correctly after converting to a regional cluster. It updates the package list, installs `etcd-client`, sets necessary environment variables, and then lists the etcd members to confirm their status.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Masters_in_different_locations.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get update\nsudo apt-get install etcd-client\n\nexport ETCDCTL_API=3\nexport ETCDCTL_ENDPOINTS=https://[REDACTED].1:2379\nexport ETCDCTL_CACERT=/var/lib/rancher/k3s/server/tls/etcd/server-ca.crt\nexport ETCDCTL_CERT=/var/lib/rancher/k3s/server/tls/etcd/server-client.crt\nexport ETCDCTL_KEY=/var/lib/rancher/k3s/server/tls/etcd/server-client.key\n\netcdctl member list\n```\n\n----------------------------------------\n\nTITLE: DNS resolution debugging and agent restart script\nDESCRIPTION: This Bash script restarts k3s agent services on worker nodes to troubleshoot DNS resolution issues after control plane upgrades. It retrieves worker IPs via 'hcloud server list' with filtering, loops through each IP, and restarts the 'k3s-agent' service remotely, helping to resolve DNS problems affecting cluster operation.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Upgrading_a_cluster_from_1x_to_2x.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nhcloud server list | grep worker | awk '{print $4}'| while read ip; do\n  echo \"${ip}\"\n  ssh -n root@${ip} \"systemctl restart k3s-agent\"\n  sleep 10\n done\n```\n\n----------------------------------------\n\nTITLE: Common Kubernetes Management Commands\nDESCRIPTION: Collection of essential kubectl and helm commands for managing and troubleshooting Kubernetes resources, including services, ingresses, pods, and deployments.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Setting up a cluster.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nkubectl get service [serviceName] -A or -n [nameSpace]\nkubectl get ingress [ingressName] -A or -n [nameSpace]\nkubectl get pod [podName] -A or -n [nameSpace]\nkubectl get all -A\nkubectl get events -A\nhelm ls -A\nhelm uninstall [name] -n [nameSpace]\nkubectl -n ingress-nginx get svc\nkubectl describe ingress -A\nkubectl describe svc -n ingress-nginx\nkubectl delete configmap nginx-config -n ingress-nginx\nkubectl rollout restart deployment -n NAMESPACE_OF_YOUR_APP\nkubectl get all -A` does not include \"ingress\", so use `kubectl get ing -A\n```\n\n----------------------------------------\n\nTITLE: Example Etcd Member List Output\nDESCRIPTION: This is an example output from the `etcdctl member list` command. It shows the expected format when the etcd cluster is working properly, listing each master node with its status and endpoints. The redacted parts represent specific node identifiers and IP addresses.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Masters_in_different_locations.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n285ab4b980c2c8c, started, test-master2-d[REDACTED]af, https://[REDACTED]:2380, https://[REDACTED]:2379, false\naad3fac89b68bfb7, started, test-master1-5e550de0, https://[REDACTED]:2380, https://[REDACTED]:2379, false\nc[REDACTED]e25aef34e8, started, test-master3-0ed051a3, https://[REDACTED]:2380, https://[REDACTED]:2379, false\n```\n\n----------------------------------------\n\nTITLE: Enabling SSH Agent on macOS\nDESCRIPTION: This snippet shows how to configure an SSH agent to enable the use of SSH keys with passphrases when accessing a Hetzner K3s cluster. It specifically targets macOS environments and utilizes `ssh-agent` and `ssh-add` to manage and load the SSH key.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Creating_a_cluster.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\neval \"$(ssh-agent -s)\"\nssh-add --apple-use-keychain ~/.ssh/<private key>\n```\n\n----------------------------------------\n\nTITLE: Installing hetzner-k3s with Homebrew on macOS\nDESCRIPTION: Command to install the hetzner-k3s tool using Homebrew package manager on macOS systems.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Installation.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbrew install vitobotta/tap/hetzner_k3s\n```\n\n----------------------------------------\n\nTITLE: Installing hetzner-k3s binary on Apple Silicon/ARM macOS\nDESCRIPTION: Commands to download, make executable, and install the hetzner-k3s binary for Apple Silicon/ARM architecture on macOS. Requires libevent, bdw-gc, libyaml, pcre, and gmp dependencies to be installed.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Installation.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nwget https://github.com/vitobotta/hetzner-k3s/releases/download/v2.2.9/hetzner-k3s-macos-arm64\nchmod +x hetzner-k3s-macos-arm64\nsudo mv hetzner-k3s-macos-arm64 /usr/local/bin/hetzner-k3s\n```\n\n----------------------------------------\n\nTITLE: Installing hetzner-k3s binary on Intel/x86 macOS\nDESCRIPTION: Commands to download, make executable, and install the hetzner-k3s binary for Intel/x86 architecture on macOS. Requires libevent, bdw-gc, libyaml, pcre, and gmp dependencies to be installed.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Installation.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nwget https://github.com/vitobotta/hetzner-k3s/releases/download/v2.2.9/hetzner-k3s-macos-amd64\nchmod +x hetzner-k3s-macos-amd64\nsudo mv hetzner-k3s-macos-amd64 /usr/local/bin/hetzner-k3s\n```\n\n----------------------------------------\n\nTITLE: Installing hetzner-k3s on Linux amd64\nDESCRIPTION: Commands to download, make executable, and install the hetzner-k3s binary for amd64 architecture on Linux systems.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Installation.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nwget https://github.com/vitobotta/hetzner-k3s/releases/download/v2.2.9/hetzner-k3s-linux-amd64\nchmod +x hetzner-k3s-linux-amd64\nsudo mv hetzner-k3s-linux-amd64 /usr/local/bin/hetzner-k3s\n```\n\n----------------------------------------\n\nTITLE: Installing hetzner-k3s on Linux arm64\nDESCRIPTION: Commands to download, make executable, and install the hetzner-k3s binary for arm64 architecture on Linux systems.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Installation.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nwget https://github.com/vitobotta/hetzner-k3s/releases/download/v2.2.9/hetzner-k3s-linux-arm64\nchmod +x hetzner-k3s-linux-arm64\nsudo mv hetzner-k3s-linux-arm64 /usr/local/bin/hetzner-k3s\n```\n\n----------------------------------------\n\nTITLE: Running a Single Hetzner-k3s Test (Bash)\nDESCRIPTION: This script executes a single test based on a configuration file template and optional variable substitutions.  It takes the configuration file template as the first argument, and then a list of variable assignments in the format VARIABLE=value.  The configuration file is used by the test harness.  The command will run the test as specified.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/e2e-tests/README.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\n./run-single-test.sh config-sshport-image.yaml IMAGE=ubuntu-22.04 SSHPORT=222\n```\n\n----------------------------------------\n\nTITLE: Running All Hetzner-k3s Tests (Bash)\nDESCRIPTION: This script executes all available tests defined within the test harness.  It orchestrates running a suite of tests designed to validate different configurations of hetzner-k3s. No arguments are required. This script is crucial for comprehensive validation and regression testing of the hetzner-k3s tool.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/e2e-tests/README.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\n./run-all-tests.sh\n```\n\n----------------------------------------\n\nTITLE: Listing Hetzner-k3s Test Results (Bash)\nDESCRIPTION: This script displays the results of the executed tests, providing a summary of each test's status. The output includes the configuration file, parameters, the result (error, ok), and a unique test identifier. This script helps quickly assess the outcome of the tests and identify any issues.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/e2e-tests/README.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\n./list-test-results.sh\n```\n\n----------------------------------------\n\nTITLE: Building and Starting Development Container with Docker Compose\nDESCRIPTION: This command builds and starts the development container using Docker Compose. The `-d` flag runs the container in detached mode.  This sets up an environment with Crystal and dependencies.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Contributing_and_support.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose up -d\n```\n\n----------------------------------------\n\nTITLE: Accessing the Development Container with Docker Compose\nDESCRIPTION: This command provides interactive access to the running development container using Docker Compose.  The `exec` command executes a command (bash) inside the container.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Contributing_and_support.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose exec hetzner-k3s bash\n```\n\n----------------------------------------\n\nTITLE: Running hetzner-k3s inside the Container\nDESCRIPTION: This command runs the `hetzner-k3s` application within the development container. It specifies the entry point Crystal file, the `create` subcommand, and a configuration file for cluster setup. The application relies on the Crystal runtime and potentially external libraries.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Contributing_and_support.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncrystal run ./src/hetzner-k3s.cr -- create --config cluster_config.yaml\n```\n\n----------------------------------------\n\nTITLE: Generating a Static Binary of hetzner-k3s\nDESCRIPTION: This command builds a static binary of the `hetzner-k3s` application. The `--static` flag ensures the binary is statically linked, including all dependencies, making it executable on systems without Crystal runtime or related libraries. The output is a standalone executable.\nSOURCE: https://github.com/vitobotta/hetzner-k3s/blob/main/docs/Contributing_and_support.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncrystal build ./src/hetzner-k3s.cr --static\n```"
  }
]