[
  {
    "owner": "yewstack",
    "repo": "yew",
    "content": "TITLE: Creating a Basic Video List Component in Rust/Yew\nDESCRIPTION: Defines a VideosList function component that renders a list of videos. Demonstrates component props, the Properties trait implementation, and basic HTML rendering in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/tutorial/index.mdx#2025-04-16_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nstruct Video {\n    id: usize,\n    title: String,\n    speaker: String,\n    url: String,\n}\n\n#[derive(Properties, PartialEq)]\nstruct VideosListProps {\n    videos: Vec<Video>,\n}\n\n#[function_component(VideosList)]\nfn videos_list(VideosListProps { videos }: &VideosListProps) -> Html {\n    videos.iter().map(|video| html! {\n        <p key={video.id}>{format!(\"{}: {}\", video.speaker, video.title)}</p>\n    }).collect()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Components with and without Properties in Yew\nDESCRIPTION: Demonstrates how to create function components with and without properties in Yew, and shows various ways to pass properties when using components in the html! macro. This includes passing individual properties, cloning a props object, and overriding specific values.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/components.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[function_component]\nfn MyComponent() -> Html {\n    html! {\n        { \"This component has no properties!\" }\n    }\n}\n\n#[derive(Clone, PartialEq, Properties)]\nstruct Props {\n    user_first_name: String,\n    user_last_name: String,\n}\n\n#[function_component]\nfn MyComponentWithProps(props: &Props) -> Html {\n    let Props { user_first_name, user_last_name } = props;\n    html! {\n        <>{\"user_first_name: \"}{user_first_name}{\" and user_last_name: \"}{user_last_name}</>\n    }\n}\n\nlet props = Props {\n    user_first_name: \"Bob\".to_owned(),\n    user_last_name: \"Smith\".to_owned(),\n};\n\nhtml!{\n    <>\n        // No properties\n        <MyComponent />\n\n        // With Properties\n        <MyComponentWithProps user_first_name=\"Sam\" user_last_name=\"Idle\" />\n\n        // With the whole set of props provided at once\n        <MyComponentWithProps ..props.clone() />\n\n        // With Properties from a variable and specific values overridden\n        <MyComponentWithProps user_last_name=\"Elm\" ..props />\n    </>\n};\n```\n\n----------------------------------------\n\nTITLE: Nested Components with Props in Yew - List Component (Rust)\nDESCRIPTION: Shows the implementation of a List component that can contain and manipulate ListItem components with properties. It uses ChildrenWithProps to handle typed children components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.18.0/concepts/html/components.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub struct List(Props);\n\n#[derive(Properties)]\npub struct Props {\n    pub children: ChildrenWithProps<ListItem>,\n}\n\nimpl Component for List {\n    type Properties = Props;\n\n    // ...\n\n    fn view(&self) -> Html {\n        html!{{\n            for self.0.children.iter().map(|mut item| {\n                item.props.value = format!(\"item-{}\", item.props.value);\n                item\n            })\n        }}\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested Router Structure in Yew\nDESCRIPTION: Comprehensive example showing how to implement a nested router structure with multiple route enums and switch functions. Includes main routes and nested settings routes with redirection handling.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/router.mdx#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew_router::prelude::*;\n\n#[derive(Clone, Routable, PartialEq)]\nenum MainRoute {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/news\")]\n    News,\n    #[at(\"/contact\")]\n    Contact,\n    #[at(\"/settings/:s\")]\n    Settings,\n    #[not_found]\n    #[at(\"/404\")]\n    NotFound,\n}\n\n#[derive(Clone, Routable, PartialEq)]\nenum SettingsRoute {\n    #[at(\"/settings/profile\")]\n    Profile,\n    #[at(\"/settings/friends\")]\n    Friends,\n    #[at(\"/settings/theme\")]\n    Theme,\n    #[not_found]\n    #[at(\"/settings/404\")]\n    NotFound,\n}\n\nfn switch_main(route: &MainRoute) -> Html {\n    match route {\n        MainRoute::Home => html! {<h1>{\"Home\"}</h1>},\n        MainRoute::News => html! {<h1>{\"News\"}</h1>},\n        MainRoute::Contact => html! {<h1>{\"Contact\"}</h1>},\n        MainRoute::Settings => html! {\n            <Switch<SettingsRoute> render={Switch::render(switch_settings)} />\n        },\n        MainRoute::NotFound => html! {<h1>{\"Not Found\"}</h1>},\n    }\n}\n\nfn switch_settings(route: &SettingsRoute) -> Html {\n    match route {\n        SettingsRoute::Profile => html! {<h1>{\"Profile\"}</h1>},\n        SettingsRoute::Friends => html! {<h1>{\"Friends\"}</h1>},\n        SettingsRoute::Theme => html! {<h1>{\"Theme\"}</h1>},\n        SettingsRoute::NotFound => html! {\n            <Redirect<MainRoute> to={MainRoute::NotFound}/>\n        }\n    }\n}\n\n#[function_component(App)]\npub fn app() -> Html {\n    html! {\n        <BrowserRouter>\n            <Switch<MainRoute> render={Switch::render(switch_main)} />\n        </BrowserRouter>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Navigation in Struct Components with Yew Router\nDESCRIPTION: Example of using the Navigator API in struct components to implement programmatic navigation. It shows how to create a button that navigates to the home route when clicked.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/router.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfn view(&self, ctx: &Context<Self>) -> Html {\n    let navigator = ctx.link().navigator().unwrap();\n    let onclick = Callback::from(move |_| navigator.push(&MainRoute::Home));\n    html!{\n        <button {onclick}>{\"Go Home\"}</button>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Complete Router with BrowserRouter and Switch Components\nDESCRIPTION: Demonstrates a full router implementation including route definition, a switch function to render different components based on the current route, and a secure page component with navigation. Uses BrowserRouter as the container for the routing system.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/router.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew_router::prelude::*;\nuse yew::prelude::*;\n\n#[derive(Clone, Routable, PartialEq)]\nenum Route {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/secure\")]\n    Secure,\n    #[not_found]\n    #[at(\"/404\")]\n    NotFound,\n}\n\n#[function_component(Secure)]\nfn secure() -> Html {\n    let navigator = use_navigator().unwrap();\n\n    let onclick = Callback::from(move |_| navigator.push(&Route::Home));\n    html! {\n        <div>\n            <h1>{ \"Secure\" }</h1>\n            <button {onclick}>{ \"Go Home\" }</button>\n        </div>\n    }\n}\n\nfn switch(routes: Route) -> Html {\n    match routes {\n        Route::Home => html! { <h1>{ \"Home\" }</h1> },\n        Route::Secure => html! {\n            <Secure />\n        },\n        Route::NotFound => html! { <h1>{ \"404\" }</h1> },\n    }\n}\n\n#[function_component(Main)]\nfn app() -> Html {\n    html! {\n        <BrowserRouter>\n            <Switch<Route> render={switch} /> // <- must be child of <BrowserRouter>\n        </BrowserRouter>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Component View Function Signature in Rust\nDESCRIPTION: Shows the signature of a component's view function in Yew, which takes a reference to self and returns Html.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.18.0/concepts/components/properties.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn view(&self) -> Html\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Function Components in Rust with Yew\nDESCRIPTION: Demonstrates how to create function components using the #[function_component] attribute. Shows a HelloWorld component and an App component that uses it. The example highlights the component naming convention (PascalCase) and the basic structure of function components that return Html.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/function-components/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html};\n\n#[function_component]\nfn HelloWorld() -> Html {\n    html! { \"Hello world\" }\n}\n\n// Then somewhere else you can use the component inside `html!`\n#[function_component]\nfn App() -> Html {\n    html! { <HelloWorld /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Yew Application\nDESCRIPTION: Implementing a simple Yew application with a function component that renders 'Hello World'.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/tutorial/index.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[function_component(App)]\nfn app() -> Html {\n    html! {\n        <h1>{ \"Hello World\" }</h1>\n    }\n}\n\nfn main() {\n    yew::Renderer::<App>::new().render();\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Function Components in Yew\nDESCRIPTION: Demonstrates how to create a basic function component 'HelloWorld' and use it within another component 'App'. The code shows the use of the #[function_component] attribute and the html! macro for rendering.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/function-components/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html};\n\n#[function_component]\nfn HelloWorld() -> Html {\n    html! { \"Hello world\" }\n}\n\n// Then somewhere else you can use the component inside `html!`\n#[function_component]\nfn App() -> Html {\n    html! { <HelloWorld /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Components Using Yew Framework in Rust\nDESCRIPTION: This snippet demonstrates the basic implementation of components using the Yew framework in Rust. It highlights how a simple component without properties is created and another component with properties defined by a 'Props' struct. Dependencies include the 'yew' crate and the 'Component', 'Context', and 'Html' types. It accepts HTML tags as input and outputs rendered HTML components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/components.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Component, Html, html, Context, Properties};\n\nstruct MyComponent;\n\nimpl Component for MyComponent {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"This component has no properties!\" }\n        }\n    }\n}\n\n#[derive(Clone, PartialEq, Properties)]\nstruct Props {\n    prop1: String,\n    prop2: String,\n}\n\nstruct MyComponentWithProps;\n\nimpl Component for MyComponentWithProps {\n    type Message = ();\n    type Properties = Props;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            {\n                format!(\n                    \"prop1: {} and prop2: {}\",\n                    ctx.props().prop1,\n                    ctx.props().prop2\n                )\n            }\n        }\n    }\n}\n\nlet props = Props {\n    prop1: \"Hello\".to_owned(),\n    prop2: \"World\".to_owned(),\n};\n\n\nhtml!{\n    <>\n        // No properties\n        <MyComponent />\n\n        // With Properties\n        <MyComponentWithProps prop1=\"lorem\" prop2=\"ipsum\" />\n\n        // With the whole set of props provided at once\n        <MyComponentWithProps ..props.clone() />\n\n        // With Properties from a variable and specific values overridden\n        <MyComponentWithProps prop2=\"lorem\" ..props />\n    </>\n};\n```\n\n----------------------------------------\n\nTITLE: Complete Yew Suspense Example with Function Components in Rust\nDESCRIPTION: This is a complete example demonstrating the implementation of Suspense in Yew. It includes the User struct, loading functions, a suspending hook, and function components that use the suspending hook.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/suspense.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew::suspense::{Suspension, SuspensionResult};\n\n#[derive(Debug)]\nstruct User {\n    name: String,\n}\n\nfn load_user() -> Option<User> {\n    todo!()  // implementation omitted.\n}\n\nfn on_load_user_complete<F: FnOnce()>(_fn: F) {\n    todo!()  // implementation omitted.\n}\n\n#[hook]\nfn use_user() -> SuspensionResult<User> {\n    match load_user() {\n        // If a user is loaded, then we return it as Ok(user).\n        Some(m) => Ok(m),\n        None => {\n            // When user is still loading, then we create a `Suspension`\n            // and call `SuspensionHandle::resume` when data loading\n            // completes, the component will be re-rendered\n            // automatically.\n            let (s, handle) = Suspension::new();\n            on_load_user_complete(move || {handle.resume();});\n            Err(s)\n        },\n    }\n}\n\n#[function_component(Content)]\nfn content() -> HtmlResult {\n    let user = use_user()?;\n\n    Ok(html! {<div>{\"Hello, \"}{&user.name}</div>})\n}\n\n#[function_component(App)]\nfn app() -> Html {\n    let fallback = html! {<div>{\"Loading...\"}</div>};\n\n    html! {\n        <Suspense {fallback}>\n            <Content />\n        </Suspense>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Dependencies to Cargo.toml for API Fetching\nDESCRIPTION: This code adds the `gloo-net`, `serde`, and `wasm-bindgen-futures` crates to the `Cargo.toml` file. These crates are required for making HTTP requests, de-serializing JSON responses, and executing Rust Futures as Promises.  This configuration enables the application to fetch video data from an external REST API.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_21\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ngloo-net = \"0.2\"\nserde = { version = \"1.0\", features = [\"derive\"] }\nwasm-bindgen-futures = \"0.4\"\n```\n\n----------------------------------------\n\nTITLE: Using Props in Yew Function Components\nDESCRIPTION: Shows how to define and use props in a Yew function component. The component receives props as a function argument and they are supplied via attributes in the html! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/function-components/properties.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub is_loading: bool,\n}\n\n#[function_component]\nfn HelloWorld(&Props { is_loading }: &Props) -> Html {\n    html! { <>{{\"Am I loading? - \"}}{{is_loading}}</> }\n}\n\n// Then supply the prop\n#[function_component]\nfn App() -> Html {\n    html! { <HelloWorld is_loading=true /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Path Segments with Dynamic and Wildcard Parameters\nDESCRIPTION: Shows how to extract information from routes using dynamic segments (`:id`) and wildcard segments (`*path`). The extracted values are accessible in the switch function and can be passed to components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/router.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew_router::prelude::*;\n\n#[derive(Clone, Routable, PartialEq)]\nenum Route {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/post/:id\")]\n    Post { id: String },\n    #[at(\"/*path\")]\n    Misc { path: String },\n}\n\nfn switch(route: Route) -> Html {\n    match route {\n        Route::Home => html! { <h1>{ \"Home\" }</h1> },\n        Route::Post { id } => html! {<p>{format!(\"You are looking at Post {}\", id)}</p>},\n        Route::Misc { path } => html! {<p>{format!(\"Matched some other path: {}\", path)}</p>},\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Yew App with BrowserRouter and Switch Component\nDESCRIPTION: This code snippet shows how to set up a basic Yew application with `yew-router`.  It includes defining routes, a function component for a secure page that navigates back home, a switch function to render content based on the route, and the main app component that renders the `BrowserRouter` and `Switch` components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/router.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew_router::prelude::*;\nuse yew::prelude::*;\n\n#[derive(Clone, Routable, PartialEq)]\nenum Route {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/secure\")]\n    Secure,\n    #[not_found]\n    #[at(\"/404\")]\n    NotFound,\n}\n\n#[function_component(Secure)]\nfn secure() -> Html {\n    let navigator = use_navigator().unwrap();\n\n    let onclick = Callback::from(move |_| navigator.push(&Route::Home));\n    html! {\n        <div>\n            <h1>{ \"Secure\" }</h1>\n            <button {onclick}>{ \"Go Home\" }</button>\n        </div>\n    }\n}\n\nfn switch(routes: Route) -> Html {\n    match routes {\n        Route::Home => html! { <h1>{ \"Home\" }</h1> },\n        Route::Secure => html! {\n            <Secure />\n        },\n        Route::NotFound => html! { <h1>{ \"404\" }</h1> },\n    }\n}\n\n#[function_component(Main)]\nfn app() -> Html {\n    html! {\n        <BrowserRouter>\n            <Switch<Route> render={switch} /> // <- must be child of <BrowserRouter>\n        </BrowserRouter>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Complete Custom Event Hook in Yew\nDESCRIPTION: Full implementation of the use_event custom hook that manages event listeners. The hook uses use_effect_with to properly handle dependencies and cleanup when the component unmounts or dependencies change.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse web_sys::{Event, EventTarget};\nuse std::borrow::Cow;\nuse std::rc::Rc;\nuse gloo::events::EventListener;\n\n#[hook]\npub fn use_event<E, F>(target: &EventTarget, event_type: E, callback: F)\nwhere\n    E: Into<Cow<'static, str>>,\n    F: Fn(Event) + 'static,\n{\n    #[derive(PartialEq, Clone)]\n    struct EventDependents {\n        target: EventTarget,\n        event_type: Cow<'static, str>,\n        callback: Callback<Event>,\n    }\n\n    let deps = EventDependents {\n        target: target.clone(),\n        event_type: event_type.into(),\n        callback: Callback::from(callback),\n    };\n\n    use_effect_with(\n        deps,\n        |deps| {\n            let EventDependents {\n                target,\n                event_type,\n                callback,\n            } = deps.clone();\n\n            let listener = EventListener::new(&target, event_type, move |e| {\n                callback.emit(e.clone());\n            });\n\n            move || {\n                drop(listener);\n            }\n        },\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Function Component in Rust\nDESCRIPTION: Demonstrates creating a simple function component using the #[function_component] attribute in Yew. The component returns a static HTML message.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.21/concepts/function-components/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[function_component(HelloWorld)]\nfn hello_world() -> Html {\n    html! { \"Hello world\" }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Trunk and Adding WASM Target\nDESCRIPTION: Commands for installing the Trunk build tool and adding the WebAssembly target to Rust toolchain, which are prerequisites for developing Yew applications.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo install trunk\n```\n\nLANGUAGE: bash\nCODE:\n```\nrustup target add wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Creating a Yew Function Component\nDESCRIPTION: This snippet demonstrates how to create a function component in Yew using the `#[function_component]` attribute. The component returns an `Html` element, defining the UI to be rendered. It shows how the component can then be used within another component's `html!` macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/function-components/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html};\n\n#[function_component]\nfn HelloWorld() -> Html {\n    html! { \"Hello world\" }\n}\n\n// 然后在其他地方，您可以在 `html!` 中使用组件\n#[function_component]\nfn App() -> Html {\n    html! { <HelloWorld /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Children Props in Yew Components with Rust\nDESCRIPTION: This example demonstrates how to use the Children prop type in Yew to receive and render nested HTML elements. It shows a parent component (HelloWorld) that accepts child elements from the App component and renders them within a styled container.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/function-components/children.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties};\n\n#[function_component]\nfn App() -> Html {\n    html! {\n        // highlight-start\n        <HelloWorld>\n            <span>{\"Hey what is up ;)\"}</span>\n            <h1>{\"THE SKY\"}</h1>\n        </HelloWorld>\n        // highlight-end\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    // highlight-next-line\n    pub children: Html, // the field name `children` is important!\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n    html! {\n        <div class=\"very-stylized-container\">\n    // highlight-next-line\n            { props.children.clone() } // you can forward children like this\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested Router in Yew\nDESCRIPTION: This extensive code snippet demonstrates how to implement a nested router structure in Yew. It defines two levels of routes (MainRoute and SettingsRoute) and implements switch functions for both. The example includes redirection for not found routes within the nested structure.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/router.mdx#2025-04-16_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew_router::prelude::*;\nuse gloo::utils::window;\nuse wasm_bindgen::UnwrapThrowExt;\n\n#[derive(Clone, Routable, PartialEq)]\nenum MainRoute {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/news\")]\n    News,\n    #[at(\"/contact\")]\n    Contact,\n    #[at(\"/settings\")]\n    SettingsRoot,\n    #[at(\"/settings/*\")]\n    Settings,\n    #[not_found]\n    #[at(\"/404\")]\n    NotFound,\n}\n\n#[derive(Clone, Routable, PartialEq)]\nenum SettingsRoute {\n    #[at(\"/settings\")]\n    Profile,\n    #[at(\"/settings/friends\")]\n    Friends,\n    #[at(\"/settings/theme\")]\n    Theme,\n    #[not_found]\n    #[at(\"/settings/404\")]\n    NotFound,\n}\n\nfn switch_main(route: MainRoute) -> Html {\n    match route {\n        MainRoute::Home => html! {<h1>{\"Home\"}</h1>},\n        MainRoute::News => html! {<h1>{\"News\"}</h1>},\n        MainRoute::Contact => html! {<h1>{\"Contact\"}</h1>},\n        MainRoute::SettingsRoot | MainRoute::Settings => html! { <Switch<SettingsRoute> render={switch_settings} /> },\n        MainRoute::NotFound => html! {<h1>{\"Not Found\"}</h1>},\n    }\n}\n\nfn switch_settings(route: SettingsRoute) -> Html {\n    match route {\n        SettingsRoute::Profile => html! {<h1>{\"Profile\"}</h1>},\n        SettingsRoute::Friends => html! {<h1>{\"Friends\"}</h1>},\n        SettingsRoute::Theme => html! {<h1>{\"Theme\"}</h1>},\n        SettingsRoute::NotFound => html! {<Redirect<MainRoute> to={MainRoute::NotFound}/>}\n    }\n}\n\n#[function_component(App)]\npub fn app() -> Html {\n    html! {\n        <BrowserRouter>\n            <Switch<MainRoute> render={switch_main} />\n        </BrowserRouter>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building HTML Structure with Yew's html! Macro\nDESCRIPTION: Example of how to use Yew's html! macro to create a UI structure with multiple elements, demonstrating Yew's JSX-like syntax for building HTML components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n    <>\n        <h1>{ \"RustConf Explorer\" }</h1>\n        <div>\n            <h3>{\"Videos to watch\"}</h3>\n            <p>{ \"John Doe: Building and breaking things\" }</p>\n            <p>{ \"Jane Smith: The development process\" }</p>\n            <p>{ \"Matt Miller: The Web 7.0\" }</p>\n            <p>{ \"Tom Jerry: Mouseless development\" }</p>\n        </div>\n        <div>\n            <h3>{ \"John Doe: Building and breaking things\" }</h3>\n            <img src=\"https://placehold.co/640x360.png?text=Video+Player+Placeholder\" alt=\"video thumbnail\" />\n        </div>\n    </>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Components in Yew with Rust\nDESCRIPTION: Demonstrates how to create basic components in Yew with and without properties. Shows different ways to pass properties to components including individual properties, cloned props, and overridden values.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/components.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[function_component]\nfn MyComponent() -> Html {\n    html! {\n        { \"This component has no properties!\" }\n    }\n}\n\n#[derive(Clone, PartialEq, Properties)]\nstruct Props {\n    user_first_name: String,\n    user_last_name: String,\n}\n\n#[function_component]\nfn MyComponentWithProps(props: &Props) -> Html {\n    let Props { user_first_name, user_last_name } = props;\n    html! {\n        <>{\"user_first_name: \"}{user_first_name}{\" and user_last_name: \"}{user_last_name}</>\n    }\n}\n\nlet props = Props {\n    user_first_name: \"Bob\".to_owned(),\n    user_last_name: \"Smith\".to_owned(),\n};\n\nhtml!{\n    <>\n        // No properties\n        <MyComponent />\n\n        // With Properties\n        <MyComponentWithProps user_first_name=\"Sam\" user_last_name=\"Idle\" />\n\n        // With the whole set of props provided at once\n        <MyComponentWithProps ..props.clone() />\n\n        // With Properties from a variable and specific values overridden\n        <MyComponentWithProps user_last_name=\"Elm\" ..props />\n    </>\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Function Component in Yew\nDESCRIPTION: This code snippet demonstrates how to create a simple function component in Yew using the `#[function_component]` attribute. The component, named `HelloWorld`, returns an `Html` element that displays \"Hello world\". It requires the `yew` crate to be included as a dependency.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/function-components/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html};\n\n#[function_component(HelloWorld)]\nfn hello_world() -> Html {\n    html! { \"Hello world\" }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Button Click Callback in Yew\nDESCRIPTION: Demonstrates how to create a simple callback for a button click event that sends a message to the component for processing. The callback is created using ctx.link().callback() and attached to a button element.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/struct-components/callbacks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html};\n\nenum Msg {\n    Clicked,\n}\n\nstruct Comp;\n\nimpl Component for Comp {\n\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        // highlight-next-line\n        let onclick = ctx.link().callback(|_| Msg::Clicked);\n        html! {\n            // highlight-next-line\n            <button {onclick}>{ \"Click\" }</button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Generic Function Component in Rust with Yew\nDESCRIPTION: This code snippet shows how to define a generic function component in Yew. It includes a generic Props struct and a function component that can render different data types. The component is then demonstrated with both integer and string data.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/function-components/generics.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt::Display;\nuse yew::{function_component, html, Properties, Html};\n\n#[derive(Properties, PartialEq)]\npub struct Props<T>\nwhere\n    T: PartialEq,\n{\n    data: T,\n}\n\n#[function_component]\npub fn MyGenericComponent<T>(props: &Props<T>) -> Html\nwhere\n    T: PartialEq + Clone + Into<Html>,\n{\n    html! {\n        <p>\n            { props.data.clone().into() }\n        </p>\n    }\n}\n\n// then can be used like this\nhtml! {\n    <MyGenericComponent<i32> data=123 />\n};\n\n// or\nhtml! {\n    <MyGenericComponent<String> data={\"foo\".to_string()} />\n};\n```\n\n----------------------------------------\n\nTITLE: Rendering Lists Using collect::<Html>() in Yew\nDESCRIPTION: This snippet demonstrates how to render a list of items in Yew by transforming an iterator into HTML using the collect::<Html>() method. It creates a numbered list from 1 to 10 and renders it as an unordered list with a CSS class.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/lists.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet items = (1..=10).collect::<Vec<_>>();\n\nhtml! {\n    <ul class=\"item-list\">\n        { items.iter().collect::<Html>() }\n    </ul>\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Callbacks with Component Scope in Rust using Yew\nDESCRIPTION: This example demonstrates how to create callbacks using a component's Scope in Yew. It shows how to define a component with a message type, create callbacks that convert input into messages, and emit those messages to trigger component updates.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/struct-components/scope.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html};\n\nenum Msg {\n    Text(String),\n}\n\nstruct Comp;\n\nimpl Component for Comp {\n\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        // Create a callback that accepts some text and sends it\n        // to the component as the `Msg::Text` message variant.\n        // highlight-next-line\n        let cb = ctx.link().callback(|text: String| Msg::Text(text));\n\n        // The previous line is needlessly verbose to make it clearer.\n        // It can be simplified it to this:\n        // highlight-next-line\n        let cb = ctx.link().callback(Msg::Text);\n\n        // Will send `Msg::Text(\"Hello World!\")` to the component.\n        // highlight-next-line\n        cb.emit(\"Hello World!\".to_owned());\n\n        html! {\n            // html here\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Suspense Implementation Example in Yew\nDESCRIPTION: A full example showing the implementation of suspense-based data fetching in Yew, including the user loading hook, Content component that suspends, and App component with fallback UI.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/suspense.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew::suspense::{Suspension, SuspensionResult};\n\n#[derive(Debug)]\nstruct User {\n    name: String,\n}\n\nfn load_user() -> Option<User> {\n    todo!()  // implementation omitted.\n}\n\nfn on_load_user_complete<F: FnOnce()>(_fn: F) {\n    todo!()  // implementation omitted.\n}\n\n#[hook]\nfn use_user() -> SuspensionResult<User> {\n    match load_user() {\n        // If a user is loaded, then we return it as Ok(user).\n        Some(m) => Ok(m),\n        None => {\n            // When user is still loading, then we create a `Suspension`\n            // and call `SuspensionHandle::resume` when data loading\n            // completes, the component will be re-rendered\n            // automatically.\n            let (s, handle) = Suspension::new();\n            on_load_user_complete(move || {handle.resume();});\n            Err(s)\n        },\n    }\n}\n\n#[function_component(Content)]\nfn content() -> HtmlResult {\n    let user = use_user()?;\n\n    Ok(html! {<div>{\"Hello, \"}{&user.name}</div>})\n}\n\n#[function_component(App)]\nfn app() -> Html {\n    let fallback = html! {<div>{\"Loading...\"}</div>};\n\n    html! {\n        <Suspense {fallback}>\n            <Content />\n        </Suspense>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Yew Application in Rust\nDESCRIPTION: Creates a basic Yew application with a button that increments a counter when clicked. This code replaces the contents of src/main.rs.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[function_component]\nfn App() -> Html {\n    let counter = use_state(|| 0);\n    let onclick = {\n        let counter = counter.clone();\n        move |_| {\n            let value = *counter + 1;\n            counter.set(value);\n        }\n    };\n\n    html! {\n        <div>\n            <button {onclick}>{ \"+1\" }</button>\n            <p>{ *counter }</p>\n        </div>\n    }\n}\n\nfn main() {\n    yew::Renderer::<App>::new().render();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Router and Switch in Yew Application\nDESCRIPTION: Comprehensive example of setting up a router in a Yew application, including route definition, component rendering, and switch implementation.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/router.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew_router::prelude::*;\nuse yew::prelude::*;\n\n#[derive(Clone, Routable, PartialEq)]\nenum Route {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/secure\")]\n    Secure,\n    #[not_found]\n    #[at(\"/404\")]\n    NotFound,\n}\n\n#[function_component(Secure)]\nfn secure() -> Html {\n    let navigator = use_navigator().unwrap();\n\n    let onclick = Callback::from(move |_| navigator.push(&Route::Home));\n    html! {\n        <div>\n            <h1>{ \"Secure\" }</h1>\n            <button {onclick}>{ \"Go Home\" }</button>\n        </div>\n    }\n}\n\nfn switch(routes: Route) -> Html {\n    match routes {\n        Route::Home => html! { <h1>{ \"Home\" }</h1> },\n        Route::Secure => html! {\n            <Secure />\n        },\n        Route::NotFound => html! { <h1>{ \"404\" }</h1> },\n    }\n}\n\n#[function_component(Main)]\nfn app() -> Html {\n    html! {\n        <BrowserRouter>\n            <Switch<Route> render={switch} /> // <- must be child of <BrowserRouter>\n        </BrowserRouter>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Function Components in Yew\nDESCRIPTION: This snippet demonstrates how to create a simple function component 'HelloWorld' and use it within another component 'App'. It shows the basic structure of function components and how they are rendered in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/function-components/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html};\n\n#[function_component]\nfn HelloWorld() -> Html {\n    html! { \"Hello world\" }\n}\n\n// Then somewhere else you can use the component inside `html!`\n#[function_component]\nfn App() -> Html {\n    html! { <HelloWorld /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Nested HTML Layout in Yew\nDESCRIPTION: Demonstrates creating complex nested HTML layouts with various form elements including div, span, label, input, textarea and select elements with their respective attributes.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/introduction.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <div>\n        <div data-key=\"abc\"></div>\n        <div class=\"parent\">\n            <span class=\"child\" value=\"anything\"></span>\n            <label for=\"first-name\">{ \"First Name\" }</label>\n            <input type=\"text\" id=\"first-name\" value=\"placeholder\" />\n            <input type=\"checkbox\" checked=true />\n            <textarea value=\"write a story\" />\n            <select name=\"status\">\n                <option selected=true disabled=false value=\"\">{ \"Selected\" }</option>\n                <option selected=false disabled=true value=\"\">{ \"Unselected\" }</option>\n            </select>\n        </div>\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Function Component in Yew\nDESCRIPTION: Demonstrates how to create a simple function component using the #[function_component] attribute. This snippet shows a HelloWorld component that returns a static HTML string.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/function-components/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html};\n\n#[function_component]\nfn HelloWorld() -> Html {\n    html! { \"Hello world\" }\n}\n\n#[function_component]\nfn App() -> Html {\n    html! { <HelloWorld /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying App Component to Display VideoDetails in Yew\nDESCRIPTION: This code modifies the `App` component to display the `VideoDetails` component when a video is selected. It uses the `use_state` hook to store the selected video and a callback `on_video_select` to update the state when a video is clicked. The `{4,6-11,13-15,22-23,25-29}` annotations are not included in the code.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\n#[function_component(App)]\nfn app() -> Html {\n    // ...\n    let selected_video = use_state(|| None);\n\n    let on_video_select = {\n        let selected_video = selected_video.clone();\n        Callback::from(move |video: Video| {\n            selected_video.set(Some(video))\n        })\n    };\n\n    let details = selected_video.as_ref().map(|video| html! {\n        <VideoDetails video={video.clone()} />\n    });\n\n    html! {\n        <>\n            <h1>{ \"RustConf Explorer\" }</h1>\n            <div>\n                <h3>{\"Videos to watch\"}</h3>\n                <VideosList videos={videos} on_click={on_video_select.clone()} />\n            </div>\n            { for details }\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing WebAssembly Target for Rust\nDESCRIPTION: Command to add the wasm32-unknown-unknown target to Rust toolchain for browser-based WebAssembly compilation.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/getting-started/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nrustup target add wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Creating New Yew Project\nDESCRIPTION: Commands for creating a new Cargo project and verifying the Rust environment by running the initial project.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo new yew-app\ncd yew-app\n```\n\nLANGUAGE: bash\nCODE:\n```\ncargo run\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering in Yew\nDESCRIPTION: Shows how to implement conditional rendering using if statements\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/introduction.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n  if true {\n      <p>{ \"True case\" }</p>\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Using `use_state` Hook in Yew\nDESCRIPTION: This code demonstrates the usage of the `use_state` hook in a Yew function component. The hook manages a counter state and provides a setter function to update the value, triggering a re-render of the component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/function-components/pre-defined-hooks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Callback, function_component, html, use_state};\n\n#[function_component(UseState)]\nfn state() -> Html {\n    let counter = use_state(|| 0);\n    let onclick = {\n        let counter = counter.clone();\n        Callback::from(move |_| counter.set(*counter + 1))\n    };\n\n\n    html! {\n        <div>\n            <button {onclick}>{ \"Increment value\" }</button>\n            <p>\n                <b>{ \"Current value: \" }</b>\n                { *counter }\n            </p>\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Yew Component in main.rs\nDESCRIPTION: This Rust code creates a `Model` component that displays a button and a counter. The button updates the counter when clicked. It leverages the Yew framework's Component trait to manage the component's lifecycle and state updates.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nenum Msg {\n    AddOne,\n}\n\nstruct Model {\n    value: i64,\n}\n\nimpl Component for Model {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            value: 0,\n        }\n    }\n\n    fn update(&mut self, _ctx: &Context<Self>, msg: Self::Message) -> bool {\n        match msg {\n            Msg::AddOne => {\n                self.value += 1;\n                // the value has changed so we need to\n                // re-render for it to appear on the page\n                true\n            }\n        }\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        // This gives us a component's \"`Scope`\" which allows us to send messages, etc to the component.\n        let link = ctx.link();\n        html! {\n            <div>\n                <button onclick={link.callback(|_| Msg::AddOne)}>{ \"+1\" }</button>\n                <p>{ self.value }</p>\n            </div>\n        }\n    }\n}\n\nfn main() {\n    yew::start_app::<Model>();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining VideosListProps with Callback for Video Selection (Yew/Rust)\nDESCRIPTION: This snippet defines the properties for the `VideosList` component.  It includes a `videos` vector and a `on_click` callback function that accepts a `Video` struct. The `on_click` callback will be triggered when a video is selected in the list.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Properties, PartialEq)]\nstruct VideosListProps {\n    videos: Vec<Video>,\n+    on_click: Callback<Video>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Properties Trait with Derive Macro in Rust\nDESCRIPTION: Example of implementing the Properties trait for a struct using Yew's derive macro. The struct must also implement PartialEq to enable Yew to perform data comparison.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/function-components/properties.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::Properties;\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub is_loading: bool,\n}\n```\n\n----------------------------------------\n\nTITLE: Using `use_effect` Hook in Yew\nDESCRIPTION: This code demonstrates the usage of the `use_effect` hook in a Yew function component. The hook allows performing side effects after the component renders and cleaning up when the component is destroyed.  In this example, the title of the document is being updated and then reset on destruction.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/function-components/pre-defined-hooks.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Callback, function_component, html, use_effect, use_state};\n\n#[function_component(UseEffect)]\nfn effect() -> Html {\n    let counter = use_state(|| 0);\n\n    {\n        let counter = counter.clone();\n        use_effect(move || {\n            // Make a call to DOM API after component is rendered\n            gloo_utils::document().set_title(&format!(\"You clicked {} times\", *counter));\n\n            // Perform the cleanup\n            || gloo_utils::document().set_title(\"You clicked 0 times\")\n        });\n    }\n    let onclick = {\n        let counter = counter.clone();\n        Callback::from(move |_| counter.set(*counter + 1))\n    };\n\n    html! {\n        <button {onclick}>{ format!(\"Increment to {}\", *counter) }</button>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Yew Function Component Template in Rust\nDESCRIPTION: Template for creating Yew function components with Properties derivation and HTML structure. Includes props structure and function component implementation.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/getting-started/editor-setup.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(PartialEq, Properties)]\npub struct $Name$Props {\n}\n\n#[function_component]\npub fn $Name$(props: &$Name$Props) -> Html {\n    html! {\n        <$tag$>$END$</$tag$>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NodeRef in a Yew Component (Rust)\nDESCRIPTION: This snippet demonstrates how to use NodeRef in a Yew component to access DOM elements. It shows the creation of a NodeRef, its assignment to a div element in the view method, and its usage in the rendered method to check for attributes.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/struct-components/refs.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::Element;\nuse yew::{html, Component, Context, Html, NodeRef};\n\nstruct Comp {\n    node_ref: NodeRef,\n}\n\nimpl Component for Comp {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            node_ref: NodeRef::default(),\n        }\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            <div ref={self.node_ref.clone()}></div>\n        }\n    }\n\n    fn rendered(&mut self, _ctx: &Context<Self>, _first_render: bool) {\n        let has_attributes = self.node_ref\n            .cast::<Element>()\n            .unwrap()\n            .has_attributes();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Yew Components\nDESCRIPTION: This code demonstrates creating basic Yew components, including a function component with no properties and a function component that accepts properties. The `html!` macro is used to define the component's structure, and the `Properties` derive macro is used to define the component's properties.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/components.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[function_component]\nfn MyComponent() -> Html {\n    html! {\n        { \"This component has no properties!\" }\n    }\n}\n\n#[derive(Clone, PartialEq, Properties)]\nstruct Props {\n    user_first_name: String,\n    user_last_name: String,\n}\n\n#[function_component]\nfn MyComponentWithProps(props: &Props) -> Html {\n    let Props { user_first_name, user_last_name } = props;\n    html! {\n        <>{\"user_first_name: \"}{user_first_name}{\" and user_last_name: \"}{user_last_name}</>\n    }\n}\n\nlet props = Props {\n    user_first_name: \"Bob\".to_owned(),\n    user_last_name: \"Smith\".to_owned(),\n};\n\nhtml!{\n    <>\n        // 没有属性\n        <MyComponent />\n\n        // 使用属性\n        <MyComponentWithProps user_first_name=\"Sam\" user_last_name=\"Idle\" />\n\n        // 一次性提供所有属性\n        <MyComponentWithProps ..props.clone() />\n\n        // 使用变量中的属性，并覆盖特定值\n        <MyComponentWithProps user_last_name=\"Elm\" ..props />\n    </>\n};\n```\n\n----------------------------------------\n\nTITLE: Using NodeRef to Access DOM Elements in Yew\nDESCRIPTION: This example demonstrates how to create a `NodeRef`, attach it to a DOM element in the view, and then access the actual DOM element in the rendered lifecycle method. The pattern involves creating a reference, cloning it in the view, and then casting it to the appropriate type when needed.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/components/refs.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, NodeRef, web_sys::Element};\n\n// In create\nself.node_ref = NodeRef::default();\n\n// In view\nhtml! {\n    <div ref=self.node_ref.clone()></div>\n}\n\n// In rendered\nlet has_attributes = self.node_ref.cast::<Element>().unwrap().has_attributes();\n```\n\n----------------------------------------\n\nTITLE: Complete Suspense Example in Yew\nDESCRIPTION: A full example demonstrating Suspense implementation in Yew, including the User struct, loading functions, suspense-enabled hook, Content component, and App component. It showcases the entire flow of suspense-based data fetching.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/suspense.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew::suspense::{Suspension, SuspensionResult};\n\n#[derive(Debug)]\nstruct User {\n    name: String,\n}\n\nfn load_user() -> Option<User> {\n    todo!()  // implementation omitted.\n}\n\nfn on_load_user_complete<F: FnOnce()>(_fn: F) {\n    todo!()  // implementation omitted.\n}\n\n#[hook]\nfn use_user() -> SuspensionResult<User> {\n    match load_user() {\n        // If a user is loaded, then we return it as Ok(user).\n        Some(m) => Ok(m),\n        None => {\n            // When user is still loading, then we create a `Suspension`\n            // and call `SuspensionHandle::resume` when data loading\n            // completes, the component will be re-rendered\n            // automatically.\n            let (s, handle) = Suspension::new();\n            on_load_user_complete(move || {handle.resume();});\n            Err(s)\n        },\n    }\n}\n\n#[function_component(Content)]\nfn content() -> HtmlResult {\n    let user = use_user()?;\n\n    Ok(html! {<div>{\"Hello, \"}{&user.name}</div>})\n}\n\n#[function_component(App)]\nfn app() -> Html {\n    let fallback = html! {<div>{\"Loading...\"}</div>};\n\n    html! {\n        <Suspense {fallback}>\n            <Content />\n        </Suspense>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Complete Router with BrowserRouter and Switch Components\nDESCRIPTION: Shows a complete implementation of routing in a Yew application using BrowserRouter and Switch components, including a nested Secure component with navigation.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/router.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew_router::prelude::*;\nuse yew::prelude::*;\n\n#[derive(Clone, Routable, PartialEq)]\nenum Route {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/secure\")]\n    Secure,\n    #[not_found]\n    #[at(\"/404\")]\n    NotFound,\n}\n\n#[function_component(Secure)]\nfn secure() -> Html {\n    let navigator = use_navigator().unwrap();\n\n    let onclick = Callback::from(move |_| navigator.push(&Route::Home));\n    html! {\n        <div>\n            <h1>{ \"Secure\" }</h1>\n            <button {onclick}>{ \"Go Home\" }</button>\n        </div>\n    }\n}\n\nfn switch(routes: Route) -> Html {\n    match routes {\n        Route::Home => html! { <h1>{ \"Home\" }</h1> },\n        Route::Secure => html! {\n            <Secure />\n        },\n        Route::NotFound => html! { <h1>{ \"404\" }</h1> },\n    }\n}\n\n#[function_component(Main)]\nfn app() -> Html {\n    html! {\n        <BrowserRouter>\n            <Switch<Route> render={switch} /> // <- must be child of <BrowserRouter>\n        </BrowserRouter>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting Text and Literals in Yew HTML Templates\nDESCRIPTION: Demonstrates how to insert text literals, variables, and numbers into Yew HTML templates using expression blocks {}. All display text must be enclosed in these blocks.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet text = \"lorem ipsum\";\nhtml!{\n    <>\n        <div>{text}</div>\n        <div>{\"dolor sit\"}</div>\n        <span>{42}</span>\n    </>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Yew Application in Rust\nDESCRIPTION: Creates a basic Yew application with a single component that renders 'Hello World'.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/tutorial/index.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[function_component(App)]\nfn app() -> Html {\n    html! {\n        <h1>{ \"Hello World\" }</h1>\n    }\n}\n\nfn main() {\n    yew::Renderer::<App>::new().render();\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing DOM Element with NodeRef in Yew\nDESCRIPTION: This code snippet shows how to access the DOM element associated with a `NodeRef` inside the `rendered` lifecycle method. It uses `cast::<Element>()` to convert the `NodeRef` to a `web_sys::Element`, allowing you to call methods on the DOM element, such as `has_attributes()`.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/advanced-topics/struct-components/refs.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::Element;\nuse yew::{html, Component, Context, Html, NodeRef};\n\nstruct Comp {\n    node_ref: NodeRef,\n}\n\nimpl Component for Comp {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            // highlight-next-line\n            node_ref: NodeRef::default(),\n        }\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            // highlight-next-line\n            <div ref={self.node_ref.clone()}></div>\n        }\n    }\n\n    fn rendered(&mut self, _ctx: &Context<Self>, _first_render: bool) {\n        // highlight-start\n        let has_attributes = self.node_ref\n            .cast::<Element>()\n            .unwrap()\n            .has_attributes();\n        // highlight-end\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using LinkProps in Yew with Rust\nDESCRIPTION: This Rust snippet illustrates defining a Yew component's property structure, LinkProps, using derive macros and field attributes to specify default values and configurations. It utilizes AttrValue for property values and includes a default LinkColor using a custom function. Dependencies include yew::Properties and yew::virtual_dom::AttrValue. Key parameters include href, text, color, and size, each with specific purposes in the component's properties.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/components/properties.mdx#2025-04-16_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse yew::Properties;\n/// Importing the AttrValue from virtual_dom\nuse yew::virtual_dom::AttrValue;\n\n#[derive(Clone, PartialEq)]\npub enum LinkColor {\n    Blue,\n    Red,\n    Green,\n    Black,\n    Purple,\n}\n\nfn create_default_link_color() -> LinkColor {\n    LinkColor::Blue\n}\n\n#[derive(Properties, PartialEq)]\npub struct LinkProps {\n    /// The link must have a target.\n    href: AttrValue,\n    /// Also notice that we\\'re using AttrValue instead of String\n    text: AttrValue,\n    /// Color of the link. Defaults to `Blue`.\n    #[prop_or_else(create_default_link_color)]\n    color: LinkColor,\n    /// The view function will not specify a size if this is None.\n    #[prop_or_default]\n    size: Option<u32>,\n    /// When the view function doesn\\'t specify active, it defaults to true.\n    #[prop_or(true)]\n    active: bool,\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Yew Suspense Example\nDESCRIPTION: This code provides a complete example of using the `Suspense` component in Yew with a custom hook `use_user`. It includes the definition of the `User` struct, placeholder functions for loading user data (`load_user`) and handling completion (`on_load_user_complete`), the `use_user` hook implementation, and the `Content` and `App` components that utilize `Suspense` to display a loading indicator while fetching user data.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/suspense.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew::suspense::{Suspension, SuspensionResult};\n\n#[derive(Debug)]\nstruct User {\n    name: String,\n}\n\nfn load_user() -> Option<User> {\n    todo!()  // 略\n}\n\nfn on_load_user_complete<F: FnOnce()>(_fn: F) {\n    todo!()  // 略\n}\n\n#[hook]\nfn use_user() -> SuspensionResult<User> {\n    match load_user() {\n        // 如果用户已加载，则将其作为 Ok(user) 返回。\n        Some(m) => Ok(m),\n        None => {\n            // 当用户仍在加载时，我们创建一个 `Suspension`\n            // 并在数据加载完成时调用 `SuspensionHandle::resume`，\n            // 组件将自动重新渲染。\n            let (s, handle) = Suspension::new();\n            on_load_user_complete(move || {handle.resume();});\n            Err(s)\n        },\n    }\n}\n\n#[function_component(Content)]\nfn content() -> HtmlResult {\n    let user = use_user()?;\n\n    Ok(html! {<div>{\"Hello, \"}{&user.name}</div>})\n}\n\n#[function_component(App)]\nfn app() -> Html {\n    let fallback = html! {<div>{\"Loading...\"}</div>};\n\n    html! {\n        <Suspense {fallback}>\n            <Content />\n        </Suspense>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Callbacks as Props Between Components\nDESCRIPTION: Shows how to create, pass, and use callbacks as properties between components. Demonstrates parent-child component communication where a child component can call functions defined in its parent.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/function-components/callbacks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties, Callback};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub on_name_entry: Callback<String>,\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n\n    props.on_name_entry.emit(String::from(\"Bob\"));\n\n    html! { \"Hello\" }\n}\n\n// Then supply the prop\n#[function_component]\nfn App() -> Html {\n    let on_name_entry: Callback<String> = Callback::from(move |name: String| {\n        let greeting = format!(\"Hey, {}!\", name);\n        // web_sys::console::log_1(&greeting.into()); // if uncommented will print\n    });\n\n    html! { <HelloWorld {on_name_entry} /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Nested Components with Children in Yew\nDESCRIPTION: Shows how to create components that accept child elements using the children field in Properties. The Container component wraps its children in a div with a specified ID.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/components.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    id: String,\n    children: Html,\n}\n\n#[function_component]\nfn Container(props: &Props) -> Html {\n    html! {\n        <div id={props.id.clone()}>\n            { props.children.clone() }\n        </div>\n    }\n}\n\nhtml! {\n    <Container id=\"container\">\n        <h4>{ \"Hi\" }</h4>\n        <div>{ \"Hello\" }</div>\n    </Container>\n};\n```\n\n----------------------------------------\n\nTITLE: Passing Yew Callback as Property\nDESCRIPTION: This snippet shows how to pass a callback function as a property to a child component in Yew. The `HelloWorld` component receives a callback `on_name_entry` as a property, emits a string when rendered, and the parent `App` component defines this callback and passes it to the child.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/function-components/callbacks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties, Callback};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub on_name_entry: Callback<String>,\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n\n    props.on_name_entry.emit(String::from(\"Bob\"));\n\n    html! { \"Hello\" }\n}\n\n// 然后提供属性 (Props)\n#[function_component]\nfn App() -> Html {\n    let on_name_entry: Callback<String> = Callback::from(move |name: String| {\n        let greeting = format!(\"Hey, {}!\", name);\n        // web_sys::console::log_1(&greeting.into()); // 如果取消注释，这里会打印文本\n    });\n\n    html! { <HelloWorld {on_name_entry} /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Callbacks with DOM Events in Yew\nDESCRIPTION: Shows how to create a callback for a DOM event, specifically for handling a button click. The callback is attached to the button's onclick event.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/function-components/callbacks.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties, Callback};\n\n#[function_component]\nfn App() -> Html {\n    let onclick = Callback::from(move |_| {\n        let greeting = String::from(\"Hi there\");\n        // web_sys::console::log_1(&greeting.into()); // if uncommented will print\n    });\n\n    html! {\n        <button {onclick}>{ \"Click\" }</button>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using #[prop_or_else(function)] for Dynamic Default Values\nDESCRIPTION: Shows how to use the #[prop_or_else(function)] attribute to dynamically generate default property values by calling a function when no explicit value is provided.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/function-components/properties.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nfn create_default_name() -> AttrValue {\n    AttrValue::Static(\"Bob\")\n}\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    #[prop_or_default]\n    pub is_loading: bool,\n    #[prop_or_else(create_default_name)]\n    pub name: AttrValue,\n}\n\n#[function_component]\nfn Hello(&Props { is_loading, ref name }: &Props) -> Html {\n    if is_loading {\n        html! { \"Loading\" }\n    } else {\n        html! { <>\"Hello \"{name}</> }\n    }\n}\n\n// Then use like this with default\n#[function_component]\nfn Case1() -> Html {\n    html! { <Hello /> }\n}\n// Or no override the default\n#[function_component]\nfn Case2() -> Html {\n    html! { <Hello name=\"Sam\" /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Callbacks as Props in Yew Components\nDESCRIPTION: Shows how to pass callbacks between components using props. Includes component property definition, callback creation, and usage within child components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/function-components/callbacks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties, Callback};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub on_name_entry: Callback<String>,\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n\n    props.on_name_entry.emit(String::from(\"Bob\"));\n\n    html! { \"Hello\" }\n}\n\n// Then supply the prop\n#[function_component]\nfn App() -> Html {\n    let on_name_entry: Callback<String> = Callback::from(move |name: String| {\n        let greeting = format!(\"Hey, {}!\", name);\n        // web_sys::console::log_1(&greeting.into()); // if uncommented will print\n    });\n\n    html! { <HelloWorld {on_name_entry} /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Modal Component with Yew Portals\nDESCRIPTION: This example demonstrates how to create a simple modal dialogue component using `yew::create_portal`. The modal's children are rendered into an element with the id \"modal_host\" that is outside of Yew's control. This example requires the `gloo_utils` crate to access the DOM.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/portals.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(Properties, PartialEq)]\npub struct ModalProps {\n    #[prop_or_default]\n    pub children: Html,\n}\n\n#[function_component]\nfn Modal(props: &ModalProps) -> Html {\n    let modal_host = gloo::utils::document()\n        .get_element_by_id(\"modal_host\")\n        .expect(\"Expected to find a #modal_host element\");\n\n    create_portal(\n        props.children.clone(),\n        modal_host.into(),\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Switch trait for routing in Yew applications\nDESCRIPTION: This example demonstrates how to create an enum representing application routes and implement the Switch trait using the derive macro. Each route is annotated with a path pattern, and some routes include parameter capturing for dynamic routing.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/router.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew_router::Switch;\n\n#[derive(Switch)]\nenum AppRoute {\n  #[to=\"/login\"]\n  Login,\n  #[to=\"/register\"]\n  Register,\n  #[to=\"/delete_account\"]\n  Delete,\n  #[to=\"/posts/{id}\"]\n  ViewPost(i32),\n  #[to=\"/posts/view\"]\n  ViewPosts,\n  #[to=\"/\"]\n  Home\n}\n```\n\n----------------------------------------\n\nTITLE: Using Props in Yew Function Components\nDESCRIPTION: Demonstrates how to define and use properties in Yew function components. The example shows creating a component that accepts props and rendering it with supplied property values.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/function-components/properties.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub is_loading: bool,\n}\n\n#[function_component]\nfn HelloWorld(&Props { is_loading }: &Props) -> Html {\n    html! { <>\"Am I loading? - \"{is_loading}</> }\n}\n\n// Then supply the prop\n#[function_component]\nfn App() -> Html {\n    html! { <HelloWorld is_loading=true /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Programmatic Navigation in Function Components\nDESCRIPTION: Demonstrates how to use the `use_navigator` hook in function components to programmatically navigate to different routes when events occur, such as button clicks.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/router.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[function_component(MyComponent)]\npub fn my_component() -> Html {\n    let navigator = use_navigator().unwrap();\n    let onclick = Callback::from(move |_| navigator.push(&Route::Home));\n\n    html! {\n        <>\n            <button {onclick}>{\"Click to go home\"}</button>\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic If Block Rendering in Yew\nDESCRIPTION: Demonstrates the simplest form of conditional rendering using an if block within Yew's html! macro\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/conditional-rendering.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    if true {\n        <p>{ \"True case\" }</p>\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Updating App Component with State Management in Rust\nDESCRIPTION: This snippet updates the App component to manage state for the selected video and render the VideoDetails component conditionally. It demonstrates state management and conditional rendering in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/tutorial/index.mdx#2025-04-16_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n#[function_component(App)]\nfn app() -> Html {\n    // ...\n    let selected_video = use_state(|| None);\n\n    let on_video_select = {\n        let selected_video = selected_video.clone();\n        Callback::from(move |video: Video| {\n            selected_video.set(Some(video))\n        })\n    };\n\n    let details = selected_video.as_ref().map(|video| html! {\n        <VideoDetails video={video.clone()} />\n    });\n\n    html! {\n        <>\n            <h1>{ \"RustConf Explorer\" }</h1>\n            <div>\n                <h3>{\"Videos to watch\"}</h3>\n                <VideosList videos={videos} on_click={on_video_select.clone()} />\n            </div>\n            { for details }\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Data from External API in Yew App Component\nDESCRIPTION: This snippet updates the App component to fetch video data from an external API using gloo-net and wasm-bindgen-futures. It demonstrates how to perform asynchronous operations in a Yew component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/tutorial/index.mdx#2025-04-16_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nuse gloo_net::http::Request;\n\n#[function_component(App)]\nfn app() -> Html {\n    let videos = use_state(|| vec![]);\n    {\n        let videos = videos.clone();\n        use_effect_with_deps(move |_| {\n            let videos = videos.clone();\n            wasm_bindgen_futures::spawn_local(async move {\n                let fetched_videos: Vec<Video> = Request::get(\"/tutorial/data.json\")\n                    .send()\n                    .await\n                    .unwrap()\n                    .json()\n                    .await\n                    .unwrap();\n                videos.set(fetched_videos);\n            });\n            || ()\n        }, ());\n    }\n\n    // ...\n\n    html! {\n        <>\n            <h1>{ \"RustConf Explorer\" }</h1>\n            <div>\n                <h3>{\"Videos to watch\"}</h3>\n                <VideosList videos={(*videos).clone()} on_click={on_video_select.clone()} />\n            </div>\n            { for details }\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Counter Component with Yew in Rust\nDESCRIPTION: Rust implementation of a basic counter component using the Yew framework. The code defines a Model component with a button that increments a value when clicked, demonstrating Yew's component lifecycle methods and event handling.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nenum Msg {\n    AddOne,\n}\n\nstruct Model {\n    // `ComponentLink` is like a reference to a component.\n    // It can be used to send messages to the component\n    link: ComponentLink<Self>,\n    value: i64,\n}\n\nimpl Component for Model {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_props: Self::Properties, link: ComponentLink<Self>) -> Self {\n        Self {\n            link,\n            value: 0,\n        }\n    }\n\n    fn update(&mut self, msg: Self::Message) -> ShouldRender {\n        match msg {\n            Msg::AddOne => {\n                self.value += 1;\n                // the value has changed so we need to\n                // re-render for it to appear on the page\n                true\n            }\n        }\n    }\n\n    fn change(&mut self, _props: Self::Properties) -> ShouldRender {\n        // Should only return \"true\" if new properties are different to\n        // previously received properties.\n        // This component has no properties so we will always return \"false\".\n        false\n    }\n\n    fn view(&self) -> Html {\n        html! {\n            <div>\n                <button onclick=self.link.callback(|_| Msg::AddOne)>{ \"+1\" }</button>\n                <p>{ self.value }</p>\n            </div>\n        }\n    }\n}\n\nfn main() {\n    yew::start_app::<Model>();\n}\n```\n\n----------------------------------------\n\nTITLE: Nested Components in Yew\nDESCRIPTION: Shows how to pass children to components using the `children` field in their `Properties`. Components can contain HTML elements or other components as children.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/components.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nhtml! {\n    <Container id=\"container\">\n        <h4>{ \"Hi\" }</h4>\n        <div>{ \"Hello\" }</div>\n    </Container>\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic Tag Names in Yew (Rust)\nDESCRIPTION: Shows how to use dynamic tag names in Yew, useful for building higher-order components where the element's tag name is not static.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/elements.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet level = 5;\nlet text = \"Hello World!\".to_owned();\n\nhtml! {\n    <@{format!(\"h{}\", level)} class=\"title\">{ text }</@>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing the Rendered Lifecycle Method in Rust for Yew Components\nDESCRIPTION: Example of implementing the rendered lifecycle method for a Yew component. This method is called after the component has been rendered to the DOM but before the browser refreshes the page.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::{Component, Context, html, Html, NodeRef};\n\npub struct MyComponent {\n    node_ref: NodeRef,\n}\n\nimpl Component for MyComponent {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            node_ref: NodeRef::default(),\n        }\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <input ref={self.node_ref.clone()} type=\"text\" />\n        }\n    }\n\n    fn rendered(&mut self, _ctx: &Context<Self>, first_render: bool) {\n        if first_render {\n            if let Some(input) = self.node_ref.cast::<HtmlInputElement>() {\n                input.focus();\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Context Provider in Yew\nDESCRIPTION: This example demonstrates how to create a context provider in Yew. A Theme context is created in the App component and provided to all child components using ContextProvider. Child components can then access the theme data without prop drilling.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/contexts.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n\n/// App theme\n#[derive(Clone, Debug, PartialEq)]\nstruct Theme {\n    foreground: String,\n    background: String,\n}\n\n/// Main component\n#[function_component]\npub fn App() -> Html {\n    let ctx = use_state(|| Theme {\n        foreground: \"#000000\".to_owned(),\n        background: \"#eeeeee\".to_owned(),\n    });\n\n    html! {\n        // `ctx` is type `Rc<UseStateHandle<Theme>>` while we need `Theme`\n        // so we deref it.\n        // It derefs to `&Theme`, hence the clone\n        <ContextProvider<Theme> context={(*ctx).clone()}>\n            // Every child here and their children will have access to this context.\n            <Toolbar />\n        </ContextProvider<Theme>>\n    }\n}\n\n/// The toolbar.\n/// This component has access to the context\n#[function_component]\npub fn Toolbar() -> Html {\n    html! {\n        <div>\n            <ThemedButton />\n        </div>\n    }\n}\n\n/// Button placed in `Toolbar`.\n/// As this component is a child of `ThemeContextProvider` in the component tree, it also has access\n/// to the context.\n#[function_component]\npub fn ThemedButton() -> Html {\n    let theme = use_context::<Theme>().expect(\"no ctx found\");\n\n    html! {\n        <button style={format!(\"background: {}; color: {};\", theme.background, theme.foreground)}>\n            { \"Click me!\" }\n        </button>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Post-Render Operations in Yew\nDESCRIPTION: This code demonstrates the `rendered` lifecycle method in Yew, which is called after the component's `view` has been rendered to the DOM but before the browser refreshes the page. The snippet illustrates how to focus an input element using a `NodeRef` after the component is first rendered. It checks `first_render` to ensure the focus is applied only once.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n```rust\nuse web_sys::HtmlInputElement;\nuse yew::{\n    Component, Context, html, Html, NodeRef,\n};\n\npub struct MyComponent {\n    node_ref: NodeRef,\n}\n\nimpl Component for MyComponent {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            node_ref: NodeRef::default(),\n        }\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <input ref={self.node_ref.clone()} type=\"text\" />\n        }\n    }\n\n    // highlight-start\n    fn rendered(&mut self, _ctx: &Context<Self>, first_render: bool) {\n        if first_render {\n            if let Some(input) = self.node_ref.cast::<HtmlInputElement>() {\n                input.focus();\n            }\n        }\n    }\n    // highlight-end\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Suspense with Hooks in Yew\nDESCRIPTION: Demonstrates how to use Suspense with hooks in a Yew application. It shows a Content component that uses a suspense-enabled hook to fetch user data, and an App component that wraps Content in a Suspense component with a fallback UI.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/suspense.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[function_component(Content)]\nfn content() -> HtmlResult {\n    let user = use_user()?;\n\n    Ok(html! {<div>{\"Hello, \"}{&user.name}</div>})\n}\n\n#[function_component(App)]\nfn app() -> Html {\n    let fallback = html! {<div>{\"Loading...\"}</div>};\n\n    html! {\n        <Suspense {fallback}>\n            <Content />\n        </Suspense>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Hook Signature in Yew\nDESCRIPTION: This code defines the signature for a custom hook called use_event. It takes an event target, event type, and callback as parameters. The #[hook] attribute marks it as a hook function.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{Event, EventTarget};\nuse std::borrow::Cow;\nuse gloo::events::EventListener;\nuse yew::prelude::*;\n\n#[hook]\npub fn use_event<E, F>(target: &EventTarget, event_type: E, callback: F)\nwhere\n    E: Into<Cow<'static, str>>,\n    F: Fn(&Event) + 'static,\n{\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Component View in Yew\nDESCRIPTION: Example demonstrating the view lifecycle method implementation which handles component rendering. Shows how to use the html! macro and handle events.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Component, Context, html, Html, Properties};\n\nenum Msg {\n    Click,\n}\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    button_text: String,\n}\n\nstruct MyComponent;\n\nimpl Component for MyComponent {\n    type Message = Msg;\n    type Properties = Props;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let onclick = ctx.link().callback(|_| Msg::Click);\n        html! {\n            <button {onclick}>{ &ctx.props().button_text }</button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Context Implementation in Yew\nDESCRIPTION: Shows how to implement context providers and consumers in Yew to share theme data across components. Demonstrates the usage of ContextProvider and use_context hook.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/contexts.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n/// App theme\n#[derive(Clone, Debug, PartialEq)]\nstruct Theme {\n    foreground: String,\n    background: String,\n}\n\n/// Main component\n#[function_component]\npub fn App() -> Html {\n    let ctx = use_state(|| Theme {\n        foreground: \"#000000\".to_owned(),\n        background: \"#eeeeee\".to_owned(),\n    });\n\n    html! {\n        <ContextProvider<Theme> context={(*ctx).clone()}>\n            <Toolbar />\n        </ContextProvider<Theme>>\n    }\n}\n\n/// The toolbar.\n/// This component has access to the context\n#[function_component]\npub fn Toolbar() -> Html {\n    html! {\n        <div>\n            <ThemedButton />\n        </div>\n    }\n}\n\n/// Button placed in `Toolbar`.\n/// As this component is a child of `ThemeContextProvider` in the component tree, it also has access\n/// to the context.\n#[function_component]\npub fn ThemedButton() -> Html {\n    let theme = use_context::<Theme>().expect(\"no ctx found\");\n\n    html! {\n        <button style={format!(\"background: {}; color: {};\", theme.background, theme.foreground)}>\n            { \"Click me!\" }\n        </button>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Suspense Example in Rust\nDESCRIPTION: This snippet provides a complete example of implementing Suspense in Yew. It includes the User struct, loading functions, suspending hook, and components using the hook.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/suspense.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew::suspense::{Suspension, SuspensionResult};\n\n#[derive(Debug)]\nstruct User {\n    name: String,\n}\n\nfn load_user() -> Option<User> {\n    todo!()  // implementation omitted.\n}\n\nfn on_load_user_complete<F: FnOnce()>(_fn: F) {\n    todo!()  // implementation omitted.\n}\n\n#[hook]\nfn use_user() -> SuspensionResult<User> {\n    match load_user() {\n        // If a user is loaded, then we return it as Ok(user).\n        Some(m) => Ok(m),\n        None => {\n            // When user is still loading, then we create a `Suspension`\n            // and call `SuspensionHandle::resume` when data loading\n            // completes, the component will be re-rendered\n            // automatically.\n            let (s, handle) = Suspension::new();\n            on_load_user_complete(move || {handle.resume();});\n            Err(s)\n        },\n    }\n}\n\n#[function_component(Content)]\nfn content() -> HtmlResult {\n    let user = use_user()?;\n\n    Ok(html! {<div>{\"Hello, \"}{&user.name}</div>})\n}\n\n#[function_component(App)]\nfn app() -> Html {\n    let fallback = html! {<div>{\"Loading...\"}</div>};\n\n    html! {\n        <Suspense {fallback}>\n            <Content />\n        </Suspense>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using #[prop_or(value)] Attribute in Yew Properties with Rust\nDESCRIPTION: Shows how to use the #[prop_or(value)] attribute to set a default value for a prop when not explicitly provided by the parent component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/function-components/properties.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    #[prop_or(\"Bob\".to_string())]\n    pub name: String,\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n    html! {<>{\"Hello world\"}{props.name.clone()}</>}\n}\n\n// Then use like this with default\n#[function_component]\nfn Case1() -> Html {\n    html! {<HelloWorld />}\n}\n// Or no override the default\n#[function_component]\nfn Case2() -> Html {\n    html! {<HelloWorld name={\"Sam\".to_string()} />}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Typed Children Components in Yew\nDESCRIPTION: This example shows how to create a List component that only accepts Item components as children. It uses the ChildrenWithProps<T> type to enforce this constraint.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/children.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, ChildrenWithProps, Component, Context, Html, Properties};\n\npub struct Item;\n\nimpl Component for Item {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"item\" }\n        }\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: ChildrenWithProps<Item>,\n}\n\npub struct List;\n\nimpl Component for List {\n    type Message = ();\n    type Properties = ListProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"list\">\n                { for ctx.props().children.iter() }\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Callbacks as Props in Yew Components\nDESCRIPTION: Illustrates how to define a component that accepts a callback as a prop, and how to create and pass that callback from a parent component. The callback handles a String input.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/function-components/callbacks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties, Callback};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub on_name_entry: Callback<String>,\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n\n    props.on_name_entry.emit(String::from(\"Bob\"));\n\n    html! { \"Hello\" }\n}\n\n// Then supply the prop\n#[function_component]\nfn App() -> Html {\n    let on_name_entry: Callback<String> = Callback::from(move |name: String| {\n        let greeting = format!(\"Hey, {}!\", name);\n        // web_sys::console::log_1(&greeting.into()); // if uncommented will print\n    });\n\n    html! { <HelloWorld {on_name_entry} /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Yew Application Component\nDESCRIPTION: Main application code that defines a function component using Yew's html! macro to render a simple \"Hello World\" heading and initializes the Yew renderer.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[function_component(App)]\nfn app() -> Html {\n    html! {\n        <h1>{ \"Hello World\" }</h1>\n    }\n}\n\nfn main() {\n    yew::Renderer::<App>::new().render();\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Video Data in App Component\nDESCRIPTION: Updates the App component to fetch video data from an external API using gloo-net and wasm-bindgen-futures.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/tutorial/index.mdx#2025-04-16_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nuse gloo_net::http::Request;\n\n#[function_component(App)]\nfn app() -> Html {\n    let videos = use_state(|| vec![]);\n    {\n        let videos = videos.clone();\n        use_effect_with_deps(move |_| {\n            let videos = videos.clone();\n            wasm_bindgen_futures::spawn_local(async move {\n                let fetched_videos: Vec<Video> = Request::get(\"/tutorial/data.json\")\n                    .send()\n                    .await\n                    .unwrap()\n                    .json()\n                    .await\n                    .unwrap();\n                videos.set(fetched_videos);\n            });\n            || ()\n        }, ());\n    }\n\n    // ...\n\n    html! {\n        <>\n            <h1>{ \"RustConf Explorer\" }</h1>\n            <div>\n                <h3>{\"Videos to watch\"}</h3>\n                <VideosList videos={(*videos).clone()} on_click={on_video_select.clone()} />\n            </div>\n            { for details }\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Modal Component with Portals in Rust using Yew\nDESCRIPTION: This code snippet demonstrates how to create a Modal component that uses Yew's create_portal function to render its children into an external DOM element. It requires the yew crate and assumes the existence of a #modal_host element in the DOM.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/portals.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(Properties, PartialEq)]\npub struct ModalProps {\n    #[prop_or_default]\n    pub children: Html,\n}\n\n#[function_component]\nfn Modal(props: &ModalProps) -> Html {\n    let modal_host = gloo::utils::document()\n        .get_element_by_id(\"modal_host\")\n        .expect(\"Expected to find a #modal_host element\");\n\n    create_portal(\n        props.children.clone(),\n        modal_host.into(),\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering in Yew HTML\nDESCRIPTION: Shows how to use conditional expressions within Yew's HTML structure. This example demonstrates rendering an anchor tag based on a boolean condition.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet show_link = true;\n\nhtml! {\n  <div>\n    {\n      if show_link {\n        html! {\n          <a href=\"https://example.com\">{\"Link\"}</a>\n        }\n      } else {\n        html! {}\n      }\n    }\n  </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering in Yew\nDESCRIPTION: Demonstrates conditional rendering of markup using Rust's if statement within the `html!` macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/introduction.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n  if true {\n      <p>{ \"True case\" }</p>\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering with Expressions in Yew HTML Templates\nDESCRIPTION: Shows how to use conditional expressions within Yew's html! macro to dynamically render content. The example demonstrates an if-else statement that conditionally renders a link based on a boolean value.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nhtml! {\n  <div>\n    {\n      if show_link {\n        html! {\n          <a href=\"https://example.com\">{\"Link\"}</a>\n        }\n      } else {\n        html! {}\n      }\n    }\n  </div>\n}\n```\n\n----------------------------------------\n\nTITLE: Show Messages Component\nDESCRIPTION: This code defines a functional component `ShowMessages` in Yew that subscribes to an event bus and displays received messages. It uses `use_state` to manage the messages and `use_effect` to subscribe to the event bus and update the state when new messages are received.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.21/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n#[function_component(ShowMessages)]\npub fn show_messages() -> Html {\n    let (state, set_state) = use_state(|| vec![]);\n\n    {\n        let mut state = Rc::clone(&state);\n        use_effect(move || {\n            let producer = EventBus::bridge(Callback::from(move |msg| {\n                let mut messages = (*state).clone();\n                messages.push(msg);\n                set_state(messages)\n            }));\n\n            || drop(producer)\n        });\n    }\n\n    let output = state.iter().map(|it| html! { <p>{ it }</p> });\n    html! { <div>{ for output }</div> }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Handling Input Events with InputData in Yew\nDESCRIPTION: This code demonstrates how to correctly handle `oninput` events in Yew using the `InputData` type. The `InputData` struct provides access to the current value of the input element. The callback function extracts the value from the `InputData` and sends it as a message.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/events.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Html, InputData};\n\nenum Msg {\n    InputValue(String),\n}\n\n\nfn view(&self) -> Html {\n\n    let oninput = self.link.callback(|e: InputData| Msg::InputValue(e.value));\n\n    html! {\n        <div>\n            <input oninput={oninput} />\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Component with Window Event Listener in Yew\nDESCRIPTION: This snippet demonstrates a function component that listens to storage changes on the window object using Yew's built-in hooks. It creates an event listener and manages its lifecycle with use_effect.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse gloo::events::EventListener;\nuse gloo::utils::window;\nuse std::mem::drop;\n\n\n#[function_component(ShowStorageChanged)]\npub fn show_storage_changed() -> Html {\n    let state_storage_changed = use_state(|| false);\n\n    {\n        let state_storage_changed = state_storage_changed.clone();\n        use_effect(|| {\n            let listener = EventListener::new(&window(), \"storage\", move |_| state_storage_changed.set(true));\n\n            move || { drop(listener); }\n        });\n    }\n\n    html! { <div>{\"Storage Event Fired: \"}{*state_storage_changed}</div> }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Properties in Yew Function Components with Rust\nDESCRIPTION: Shows how to use properties in a Yew function component. The component receives props as an argument and uses them in the rendered HTML. Also demonstrates how to supply props when using the component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/function-components/properties.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub is_loading: bool,\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n    html! { <>{\"Am I loading? - \"}{props.is_loading.clone()}</> }\n}\n\n// Then supply the prop\n#[function_component]\nfn App() -> Html {\n    html! {<HelloWorld is_loading={true} />}\n}\n```\n\n----------------------------------------\n\nTITLE: Implement Basic Yew Component\nDESCRIPTION: Main application code implementing a counter component with button interaction\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[function_component]\nfn App() -> Html {\n    let counter = use_state(|| 0);\n    let onclick = {\n        let counter = counter.clone();\n        move |_| {\n            let value = *counter + 1;\n            counter.set(value);\n        }\n    };\n\n    html! {\n        <div>\n            <button {onclick}>{ \"+1\" }</button>\n            <p>{ *counter }</p>\n        </div>\n    }\n}\n\nfn main() {\n    yew::Renderer::<App>::new().render();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Window Storage Event Handler Component in Rust/Yew\nDESCRIPTION: Example component that listens to storage events on the window object using Yew's function components and hooks. Shows basic event listener implementation with state management.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse gloo::events::EventListener;\nuse gloo::utils::window;\nuse std::mem::drop;\n\n\n#[function_component(ShowStorageChanged)]\npub fn show_storage_changed() -> Html {\n    let state_storage_changed = use_state(|| false);\n\n    {\n        let state_storage_changed = state_storage_changed.clone();\n        use_effect(|| {\n            let listener = EventListener::new(&window(), \"storage\", move |_| state_storage_changed.set(true));\n\n            move || { drop(listener); }\n        });\n    }\n\n    html! { <div>{\"Storage Event Fired: \"}{*state_storage_changed}</div> }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Routes in Rust for Yew Router\nDESCRIPTION: Shows how to define routes as an enum that derives Routable for use with Yew's router.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/router.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew_router::prelude::*;\n\n#[derive(Clone, Routable, PartialEq)]\nenum Route {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/secure\")]\n    Secure,\n    #[not_found]\n    #[at(\"/404\")]\n    NotFound,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Properties for a Link Component in Rust\nDESCRIPTION: This code snippet demonstrates how to define a Properties struct for a Link component in Yew. It shows the use of field attributes for default values, AttrValue for efficient string handling, and custom enum types for properties.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/struct-components/properties.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::Properties;\nuse yew::virtual_dom::AttrValue;\n\n#[derive(Clone, PartialEq)]\npub enum LinkColor {\n    Blue,\n    Red,\n    Green,\n    Black,\n    Purple,\n}\n\nfn create_default_link_color() -> LinkColor {\n    LinkColor::Blue\n}\n\n#[derive(Properties, PartialEq)]\npub struct LinkProps {\n    /// The link must have a target.\n    href: AttrValue,\n    /// Also notice that we are using AttrValue instead of String\n    text: AttrValue,\n    /// Color of the link. Defaults to `Blue`.\n    #[prop_or_else(create_default_link_color)]\n    color: LinkColor,\n    /// The view function will not specify a size if this is None.\n    #[prop_or_default]\n    size: Option<u32>,\n    /// When the view function does not specify active, it defaults to true.\n    #[prop_or(true)]\n    active: bool,\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Yew Application Component - Rust\nDESCRIPTION: This snippet defines a simple Yew component that returns HTML content to display 'Hello World'.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[function_component(App)]\nfn app() -> Html {\n    html! {\n        <h1>{ \"Hello World\" }</h1>\n    }\n}\n\nfn main() {\n    yew::Renderer::<App>::new().render();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Routes in Yew Router\nDESCRIPTION: Example of defining routes as an enum that derives Routable in Yew. It shows how to specify paths for different routes and handle not found cases.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/router.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew_router::prelude::*;\n\n#[derive(Clone, Routable, PartialEq)]\nenum Route {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/secure\")]\n    Secure,\n    #[not_found]\n    #[at(\"/404\")]\n    NotFound,\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering with if-let-else in Yew\nDESCRIPTION: Shows pattern matching with if-let-else for conditional rendering in Yew, handling both Some and None cases of an Option. This allows for different content depending on whether a value exists.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/conditional-rendering.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nlet some_text = Some(\"text\");\n\nhtml! {\n    if let Some(text) = some_text {\n        <p>{ text }</p>\n    } else {\n        <p>{ \"False case\" }</p>\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Router and Switch in Yew Application\nDESCRIPTION: This snippet demonstrates how to implement a router and switch component in a Yew application, including a secure route with navigation.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/router.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew_router::prelude::*;\nuse yew::prelude::*;\n\n#[derive(Clone, Routable, PartialEq)]\nenum Route {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/secure\")]\n    Secure,\n    #[not_found]\n    #[at(\"/404\")]\n    NotFound,\n}\n\n#[function_component(Secure)]\nfn secure() -> Html {\n    let navigator = use_navigator().unwrap();\n\n    let onclick = Callback::from(move |_| navigator.push(&Route::Home));\n    html! {\n        <div>\n            <h1>{ \"Secure\" }</h1>\n            <button {onclick}>{ \"Go Home\" }</button>\n        </div>\n    }\n}\n\nfn switch(routes: Route) -> Html {\n    match routes {\n        Route::Home => html! { <h1>{ \"Home\" }</h1> },\n        Route::Secure => html! {\n            <Secure />\n        },\n        Route::NotFound => html! { <h1>{ \"404\" }</h1> },\n    }\n}\n\n#[function_component(Main)]\nfn app() -> Html {\n    html! {\n        <BrowserRouter>\n            <Switch<Route> render={switch} /> // <- must be child of <BrowserRouter>\n        </BrowserRouter>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Complete Custom Event Hook in Yew\nDESCRIPTION: This snippet shows the full implementation of the use_event custom hook in Yew. It uses use_effect_with to manage an event listener's lifecycle and properly handles dependencies to recreate the listener when arguments change.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse web_sys::{Event, EventTarget};\nuse std::borrow::Cow;\nuse std::rc::Rc;\nuse gloo::events::EventListener;\n\n#[hook]\npub fn use_event<E, F>(target: &EventTarget, event_type: E, callback: F)\nwhere\n    E: Into<Cow<'static, str>>,\n    F: Fn(Event) + 'static,\n{\n    #[derive(PartialEq, Clone)]\n    struct EventDependents {\n        target: EventTarget,\n        event_type: Cow<'static, str>,\n        callback: Callback<Event>,\n    }\n\n    let deps = EventDependents {\n        target: target.clone(),\n        event_type: event_type.into(),\n        callback: Callback::from(callback),\n    };\n\n    use_effect_with(\n        deps,\n        |deps| {\n            let EventDependents {\n                target,\n                event_type,\n                callback,\n            } = deps.clone();\n\n            let listener = EventListener::new(&target, event_type, move |e| {\n                callback.emit(e.clone());\n            });\n\n            move || {\n                drop(listener);\n            }\n        },\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Children Props in Yew Components with Rust\nDESCRIPTION: This example demonstrates how to create a component that accepts child elements. It shows the proper structure for defining a Props struct with a children field, and how to use those child elements within the component's render function.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/function-components/children.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties};\n\n#[function_component]\nfn App() -> Html {\n    html! {\n        // highlight-start\n        <HelloWorld>\n            <span>{\"Hey what is up ;)\"}</span>\n            <h1>{\"THE SKY\"}</h1>\n        </HelloWorld>\n        // highlight-end\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    // highlight-next-line\n    pub children: Html, // the field name `children` is important!\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n    html! {\n        <div class=\"very-stylized-container\">\n    // highlight-next-line\n            { props.children.clone() } // you can forward children like this\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Video Details Component in Rust with Yew\nDESCRIPTION: Creates a VideoDetails component that displays details of a selected video. Shows component props and HTML templating for displaying video information.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nuse website_test::tutorial::Video;\nuse yew::prelude::*;\n\n#[derive(Properties, PartialEq)]\nstruct VideosDetailsProps {\n    video: Video,\n}\n\n#[function_component(VideoDetails)]\nfn video_details(VideosDetailsProps { video }: &VideosDetailsProps) -> Html {\n    html! {\n        <div>\n            <h3>{ video.title.clone() }</h3>\n            <img src=\"https://placehold.co/640x360.png?text=Video+Player+Placeholder\" alt=\"video thumbnail\" />\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Event Callback Implementation in Yew\nDESCRIPTION: A simple example of adding an onclick event callback to a button element in Yew. This demonstrates the basic syntax for attaching event handlers to HTML elements using the html! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/events.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <button onclick={Callback::from(|_| ())}>\n    //      ^^^^^^^ event listener name\n        { \"Click me!\" }\n    </button>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Path Segments in Yew Router\nDESCRIPTION: Example of using dynamic and named wildcard segments in Yew router to extract information from routes. It demonstrates how to access and use path parameters in components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/router.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew_router::prelude::*;\n\n#[derive(Clone, Routable, PartialEq)]\nenum Route {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/post/:id\")]\n    Post { id: String },\n    #[at(\"/*path\")]\n    Misc { path: String },\n}\n\nfn switch(route: Route) -> Html {\n    match route {\n        Route::Home => html! { <h1>{ \"Home\" }</h1> },\n        Route::Post { id } => html! {<p>{format!(\"You are looking at Post {}\", id)}</p>},\n        Route::Misc { path } => html! {<p>{format!(\"Matched some other path: {}\", path)}</p>},\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Nested Components with Typed Children in Yew\nDESCRIPTION: Shows how to create a list component that can wrap and modify ListItem components. The List component uses ChildrenWithProps to type its children and gain access to their properties.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/components.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nhtml! {\n    <List>\n        <ListItem value=\"a\" />\n        <ListItem value=\"b\" />\n        <ListItem value=\"c\" />\n    </List>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Callbacks in Yew Components (Rust)\nDESCRIPTION: This snippet demonstrates how to create and use callbacks in a Yew component. It shows how to create a callback that sends a message to the component when executed, and provides examples of both verbose and simplified syntax for creating callbacks.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/advanced-topics/struct-components/scope.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html};\n\nenum Msg {\n    Text(String),\n}\n\nstruct Comp;\n\nimpl Component for Comp {\n\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        // 创建一个接受一些文本并将其作为 `Msg::Text` 消息变体发送到组件的回调。\n        let cb = ctx.link().callback(|text: String| Msg::Text(text));\n\n        // 上一行是多余的冗长，为了更清晰，可以简化为这样：\n        let cb = ctx.link().callback(Msg::Text);\n\n        // 将 `Msg::Text(\"Hello World!\")` 发送到组件。\n        cb.emit(\"Hello World!\".to_owned());\n\n        html! {\n            // 在这里放置 HTML\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Yew Components in Rust\nDESCRIPTION: Demonstrates how to create basic Yew components with and without properties, and different ways to use them in the html! macro. Shows property passing and clone patterns.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/components.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[function_component]\nfn MyComponent() -> Html {\n    html! {\n        { \"This component has no properties!\" }\n    }\n}\n\n#[derive(Clone, PartialEq, Properties)]\nstruct Props {\n    user_first_name: String,\n    user_last_name: String,\n}\n\n#[function_component]\nfn MyComponentWithProps(props: &Props) -> Html {\n    let Props { user_first_name, user_last_name } = props;\n    html! {\n        <>{\"user_first_name: \"}{user_first_name}{\" and user_last_name: \"}{user_last_name}</>\n    }\n}\n\nlet props = Props {\n    user_first_name: \"Bob\".to_owned(),\n    user_last_name: \"Smith\".to_owned(),\n};\n\nhtml!{\n    <>\n        // No properties\n        <MyComponent />\n\n        // With Properties\n        <MyComponentWithProps user_first_name=\"Sam\" user_last_name=\"Idle\" />\n\n        // With the whole set of props provided at once\n        <MyComponentWithProps ..props.clone() />\n\n        // With Properties from a variable and specific values overridden\n        <MyComponentWithProps user_last_name=\"Elm\" ..props />\n    </>\n};\n```\n\n----------------------------------------\n\nTITLE: If-Else Conditional Rendering in Yew\nDESCRIPTION: Shows how to implement if-else conditional rendering with a boolean condition in Yew's html! macro\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/conditional-rendering.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nlet some_condition = true;\n\nhtml! {\n    if some_condition {\n        <p>{ \"True case\" }</p>\n    } else {\n        <p>{ \"False case\" }</p>\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Updating App Component to Fetch Data from API in Yew\nDESCRIPTION: This code updates the `App` component to fetch the video list from an external API using the `gloo-net` crate. It uses the `use_effect_with` hook to perform the fetch request when the component is mounted.  It fetches JSON data from \"https://yew.rs/tutorial/data.json\", de-serializes it into a vector of `Video` structs, and updates the component's state.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\nuse gloo_net::http::Request;\n\n#[function_component(App)]\nfn app() -> Html {\n    let videos = use_state(|| vec![]);\n    {\n        let videos = videos.clone();\n        use_effect_with((), move |_| {\n            let videos = videos.clone();\n            wasm_bindgen_futures::spawn_local(async move {\n                let fetched_videos: Vec<Video> = Request::get(\"https://yew.rs/tutorial/data.json\")\n                    .send()\n                    .await\n                    .unwrap()\n                    .json()\n                    .await\n                    .unwrap();\n                videos.set(fetched_videos);\n            });\n            || ()\n        });\n    }\n\n    // ...\n\n    html! {\n        <>\n            <h1>{ \"RustConf Explorer\" }</h1>\n            <div>\n                <h3>{\"Videos to watch\"}</h3>\n                <VideosList videos={(*videos).clone()} on_click={on_video_select.clone()} />\n            </div>\n            { for details }\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Components with Children in Yew in Rust\nDESCRIPTION: This snippet details how to implement a component that can accept children in Yew for Rust. It describes creating a 'Container' component where children components are passed through a 'children' field within 'Properties'. Essential dependencies include the 'yew' crate with 'Children', 'Component', 'Context', and 'Html'. It results in rendered HTML containing nested children elements.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/components.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Children, Component, Context, html, Html, Properties};\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    id: String,\n    children: Children,\n}\n\nstruct Container;\n\nimpl Component for Container {\n    type Message = ();\n    type Properties = Props;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div id={ctx.props().id.clone()}>\n                { ctx.props().children.clone() }\n            </div>\n        }\n    }\n}\n\nhtml! {\n    <Container id=\"container\">\n        <h4>{ \"Hi\" }</h4>\n        <div>{ \"Hello\" }</div>\n    </Container>\n};\n```\n\n----------------------------------------\n\nTITLE: Basic Component Usage in Yew (Rust)\nDESCRIPTION: Demonstrates how to use components in Yew's html! macro, including components without attributes, with attributes, and with full props.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.18.0/concepts/html/components.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nhtml!{\n    <>\n        // 没有属性\n        <MyComponent />\n\n        // 具有属性\n        <MyComponent prop1=\"lorem\" prop2=\"ipsum\" />\n\n        // 同时提供全套的 props\n        <MyComponent with props />\n    </>\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Lists Using Iterator Collect in Yew\nDESCRIPTION: Demonstrates how to render a list by collecting iterator items into HTML using the collect::<Html>() syntax. This approach transforms a range of numbers into an unordered list.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/lists.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet items = (1..=10).collect::<Vec<_>>();\n\nhtml! {\n    <ul class=\"item-list\">\n        { items.iter().collect::<Html>() }\n    </ul>\n};\n```\n\n----------------------------------------\n\nTITLE: Using Fragments in Yew's html! Macro\nDESCRIPTION: Demonstrates the proper way to use fragments (empty tags) in Yew to include multiple root elements in an html! macro. Fragments (<></>) allow grouping multiple elements without adding an extra DOM node.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/fragments.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <>\n        <div></div>\n        <p></p>\n    </>    \n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Redirection in Yew Router\nDESCRIPTION: This snippet demonstrates how to use the <Redirect /> component from yew-router to redirect users based on certain conditions. It shows an example of redirecting to a login page when a user is not authenticated.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/router.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n#[function_component(SomePage)]\nfn some_page() -> Html {\n    // made-up hook `use_user`\n    let user = match use_user() {\n        Some(user) => user,\n        // Redirects to the login page when user is `None`.\n        None => return html! {\n            <Redirect<Route> to={Route::Login}/>\n        },\n    };\n    // ... actual page content.\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Event Hook - Rust\nDESCRIPTION: This snippet defines a reusable event hook named 'use_event'. It accepts an event target, an event type, and a callback function. This hook allows any component to easily listen for events on any target without duplicating logic. The hook needs to be marked with #[hook] and is designed to handle any event type.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{Event, EventTarget};\nuse std::borrow::Cow;\nuse gloo::events::EventListener;\nuse yew::prelude::*;\n\n#[hook]\npub fn use_event<E, F>(target: &EventTarget, event_type: E, callback: F)\nwhere\n    E: Into<Cow<'static, str>>, \n    F: Fn(&Event) + 'static,\n{\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Comments in Yew HTML\nDESCRIPTION: Demonstrates how to use Rust-style comments within HTML structure\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/introduction.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n  <>\n    <h1>{ \"My heading\" }</h1>\n    // here comes the content\n    <main>\n      { \"…\" }\n    </main>\n  </>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Properties with Derive Macro in Rust for Yew Components\nDESCRIPTION: This example demonstrates how to create a LinkProps struct with various property types including required and optional fields. It shows how to use field attributes like #[prop_or_default], #[prop_or(value)], and #[prop_or_else(function)] to provide default values for properties.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/struct-components/properties.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::Properties;\n/// Importing the AttrValue from virtual_dom\nuse yew::virtual_dom::AttrValue;\n\n#[derive(Clone, PartialEq)]\npub enum LinkColor {\n    Blue,\n    Red,\n    Green,\n    Black,\n    Purple,\n}\n\nfn create_default_link_color() -> LinkColor {\n    LinkColor::Blue\n}\n\n#[derive(Properties, PartialEq)]\npub struct LinkProps {\n    /// The link must have a target.\n    href: AttrValue,\n    /// Also notice that we are using AttrValue instead of String\n    text: AttrValue,\n    /// Color of the link. Defaults to `Blue`.\n    #[prop_or_else(create_default_link_color)]\n    color: LinkColor,\n    /// The view function will not specify a size if this is None.\n    #[prop_or_default]\n    size: Option<u32>,\n    /// When the view function does not specify active, it defaults to true.\n    #[prop_or(true)]\n    active: bool,\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Lists Using collect::<Html>() in Yew\nDESCRIPTION: Demonstrates how to render a list in Yew using the collect::<Html>() syntax on an iterator. This approach transforms a range of numbers into HTML elements.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/lists.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet items = (1..=10).collect::<Vec<_>>();\n\nhtml! {\n    <ul class=\"item-list\">\n        { items.iter().collect::<Html>() }\n    </ul>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing API Data Fetching in App Component\nDESCRIPTION: This code implements data fetching from an external API using gloo-net and the useEffect hook. It makes an HTTP request when the component mounts, deserializes the JSON response into Video objects, and updates the component state.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\nuse gloo_net::http::Request;\n\n#[function_component(App)]\nfn app() -> Html {\n    let videos = use_state(|| vec![]);\n    {\n        let videos = videos.clone();\n        use_effect_with((), move |_| {\n            let videos = videos.clone();\n            wasm_bindgen_futures::spawn_local(async move {\n                let fetched_videos: Vec<Video> = Request::get(\"/tutorial/data.json\")\n                    .send()\n                    .await\n                    .unwrap()\n                    .json()\n                    .await\n                    .unwrap();\n                videos.set(fetched_videos);\n            });\n            || ()\n        });\n    }\n\n    // ...\n\n    html! {\n        <>\n            <h1>{ \"RustConf Explorer\" }</h1>\n            <div>\n                <h3>{\"Videos to watch\"}</h3>\n                <VideosList videos={(*videos).clone()} on_click={on_video_select.clone()} />\n            </div>\n            { for details }\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using classes! macro with a String in Yew (Rust)\nDESCRIPTION: Demonstrates how to use the classes! macro with a String variable containing multiple classes in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/classes.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nlet my_classes = String::from(\"class-1 class-2\");\n\nhtml! {\n  <div class={classes!(my_classes)}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: String-like Attributes in Yew (Rust)\nDESCRIPTION: Shows different ways to pass string-like values to components in Yew, encouraging the use of Yew's custom AttrValue.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/elements.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, virtual_dom::AttrValue};\n\nlet str_placeholder = \"I'm a str!\";\nlet string_placeholder = String::from(\"I'm a String!\");\nlet attrvalue_placeholder = AttrValue::from(\"I'm an AttrValue!\");\n\nhtml! {\n    <div>\n        <input placeholder={str_placeholder} />\n        <input placeholder={string_placeholder} />\n        <input placeholder={attrvalue_placeholder} />\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Handling Events with TargetCast in Yew\nDESCRIPTION: This Rust snippet demonstrates using the TargetCast trait in Yew to safely and unsafely cast event targets to HtmlInputElement, capturing changes through callbacks. The primary dependencies are Yew and web-sys, with expected inputs being HTML events. It utilizes TargetCast to safely convert an event's target and manage state in the Yew component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/events.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::prelude::*;\n\n#[function_component]\nfn MyComponent() -> Html {\n    let input_value_handle = use_state(String::default);\n    let input_value = (*input_value_handle).clone();\n\n    let on_cautious_change = {\n        let input_value_handle = input_value_handle.clone();\n\n        Callback::from(move |e: Event| {\n            let input = e.target_dyn_into::<HtmlInputElement>();\n\n            if let Some(input) = input {\n                input_value_handle.set(input.value());\n            }\n        })\n    };\n\n    let on_dangerous_change = Callback::from(move |e: Event| {\n        // You must KNOW target is a HtmlInputElement, otherwise\n        // the call to value would be Undefined Behaviour (UB).\n        //highlight-next-line\n        input_value_handle.set(e.target_unchecked_into::<HtmlInputElement>().value());\n    });\n\n    html! {\n        <>\n            <label for=\"cautious-input\">\n                { \"My cautious input:\" }\n                <input onchange={on_cautious_change}\n                    id=\"cautious-input\"\n                    type=\"text\"\n                    value={input_value.clone()}\n                />\n            </label>\n            <label for=\"dangerous-input\">\n                { \"My dangerous input:\" }\n                <input onchange={on_dangerous_change}\n                    id=\"dangerous-input\"\n                    type=\"text\"\n                    value={input_value}\n                />\n            </label>\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Basic Callbacks in Yew\nDESCRIPTION: Demonstrates how to create a basic callback in Yew that takes a String and returns a String. Shows how to emit (call) the callback manually with a parameter.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/function-components/callbacks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html, Callback};\n\nlet cb: Callback<String, String> = Callback::from(move |name: String| {\n    format!(\"Bye {}\", name)\n});\n\nlet result = cb.emit(String::from(\"Bob\")); // call the callback\n// web_sys::console::log_1(&result.into()); // if uncommented will print \"Bye Bob\"\n```\n\n----------------------------------------\n\nTITLE: HTML Macro: Complex HTML Layout Example in Yew\nDESCRIPTION: This snippet illustrates how to build a more complex nested HTML structure using the `html!` macro in Yew. It includes various HTML elements with attributes and text content. The `use yew::prelude::*;` statement imports necessary Yew functionalities.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/html/introduction.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <div>\n        <div data-key=\"abc\"></div>\n        <div class=\"parent\">\n            <span class=\"child\" value=\"anything\"></span>\n            <label for=\"first-name\">{ \"First Name\" }</label>\n            <input type=\"text\" id=\"first-name\" value=\"placeholder\" />\n            <input type=\"checkbox\" checked=true />\n            <textarea value=\"write a story\" />\n            <select name=\"status\">\n                <option selected=true disabled=false value=\"\">{ \"Selected\" }</option>\n                <option selected=false disabled=true value=\"\">{ \"Unselected\" }</option>\n            </select>\n        </div>\n    </div>\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using use_effect_with_deps Hook in Yew\nDESCRIPTION: Demonstrates how to use the use_effect_with_deps hook to manually define dependencies for side effects. The dependencies must implement PartialEq trait.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/function-components/pre-defined-hooks.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::use_effect_with_deps;\n\nuse_effect_with_deps(\n    move |_| {\n        // ...\n        || ()\n    },\n    (), // dependents\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing a Complete Custom Event Hook in Yew\nDESCRIPTION: A fully implemented custom hook that manages event listeners using the use_effect_with hook. This hook takes a target, event type, and callback function, allowing any component to easily subscribe to DOM events.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse web_sys::{Event, EventTarget};\nuse std::borrow::Cow;\nuse std::rc::Rc;\nuse gloo::events::EventListener;\n\n#[hook]\npub fn use_event<E, F>(target: &EventTarget, event_type: E, callback: F)\nwhere\n    E: Into<Cow<'static, str>>,\n    F: Fn(Event) + 'static,\n{\n    #[derive(PartialEq, Clone)]\n    struct EventDependents {\n        target: EventTarget,\n        event_type: Cow<'static, str>,\n        callback: Callback<Event>,\n    }\n\n    let deps = EventDependents {\n        target: target.clone(),\n        event_type: event_type.into(),\n        callback: Callback::from(callback),\n    };\n\n    use_effect_with(\n        deps,\n        |deps| {\n            let EventDependents {\n                target,\n                event_type,\n                callback,\n            } = deps.clone();\n\n            let listener = EventListener::new(&target, event_type, move |e| {\n                callback.emit(e.clone());\n            });\n\n            move || {\n                drop(listener);\n            }\n        },\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Building HTML from Iterator using collect() in Yew\nDESCRIPTION: This snippet demonstrates how to use the collect::<Html>() method to transform an iterator into HTML in Yew. It creates a list of items from a range and renders them as an unordered list.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/lists.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet items = (1..=10).collect::<Vec<_>>();\n\nhtml! {\n    <ul class=\"item-list\">\n        { items.iter().collect::<Html>() }\n    </ul>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested Routers in Yew\nDESCRIPTION: Comprehensive example of implementing nested routers in Yew. It shows how to create a main router and a settings sub-router, with proper route handling including redirects for not-found routes. This pattern helps organize routing in larger applications.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/router.mdx#2025-04-16_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew_router::prelude::*;\nuse gloo::utils::window;\nuse wasm_bindgen::UnwrapThrowExt;\n\n#[derive(Clone, Routable, PartialEq)]\nenum MainRoute {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/news\")]\n    News,\n    #[at(\"/contact\")]\n    Contact,\n    #[at(\"/settings\")]\n    SettingsRoot,\n    #[at(\"/settings/*\")]\n    Settings,\n    #[not_found]\n    #[at(\"/404\")]\n    NotFound,\n}\n\n#[derive(Clone, Routable, PartialEq)]\nenum SettingsRoute {\n    #[at(\"/settings\")]\n    Profile,\n    #[at(\"/settings/friends\")]\n    Friends,\n    #[at(\"/settings/theme\")]\n    Theme,\n    #[not_found]\n    #[at(\"/settings/404\")]\n    NotFound,\n}\n\nfn switch_main(route: MainRoute) -> Html {\n    match route {\n        MainRoute::Home => html! {<h1>{\"Home\"}</h1>},\n        MainRoute::News => html! {<h1>{\"News\"}</h1>},\n        MainRoute::Contact => html! {<h1>{\"Contact\"}</h1>},\n        MainRoute::SettingsRoot | MainRoute::Settings => html! { <Switch<SettingsRoute> render={switch_settings} /> },\n        MainRoute::NotFound => html! {<h1>{\"Not Found\"}</h1>},\n    }\n}\n\nfn switch_settings(route: SettingsRoute) -> Html {\n    match route {\n        SettingsRoute::Profile => html! {<h1>{\"Profile\"}</h1>},\n        SettingsRoute::Friends => html! {<h1>{\"Friends\"}</h1>},\n        SettingsRoute::Theme => html! {<h1>{\"Theme\"}</h1>},\n        SettingsRoute::NotFound => html! {<Redirect<MainRoute> to={MainRoute::NotFound}/>}\n    }\n}\n\n#[function_component(App)]\npub fn app() -> Html {\n    html! {\n        <BrowserRouter>\n            <Switch<MainRoute> render={switch_main} />\n        </BrowserRouter>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Context Provider and Consumer in Yew\nDESCRIPTION: This code demonstrates how to create a context provider for a theme and consume it in child components using the use_context hook. It shows the implementation of App, Toolbar, and ThemedButton components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/contexts.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n/// App theme\n#[derive(Clone, Debug, PartialEq)]\nstruct Theme {\n    foreground: String,\n    background: String,\n}\n\n/// Main component\n#[function_component]\npub fn App() -> Html {\n    let ctx = use_state(|| Theme {\n        foreground: \"#000000\".to_owned(),\n        background: \"#eeeeee\".to_owned(),\n    });\n\n    html! {\n        <ContextProvider<Theme> context={(*ctx).clone()}>\n            <Toolbar />\n        </ContextProvider<Theme>>\n    }\n}\n\n/// The toolbar.\n/// This component has access to the context\n#[function_component]\npub fn Toolbar() -> Html {\n    html! {\n        <div>\n            <ThemedButton />\n        </div>\n    }\n}\n\n/// Button placed in `Toolbar`.\n/// As this component is a child of `ThemeContextProvider` in the component tree, it also has access\n/// to the context.\n#[function_component]\npub fn ThemedButton() -> Html {\n    let theme = use_context::<Theme>().expect(\"no ctx found\");\n\n    html! {\n        <button style={format!(\"background: {}; color: {};\", theme.background, theme.foreground)}>\n            { \"Click me!\" }\n        </button>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic List Component in Yew - Rust\nDESCRIPTION: This snippet shows how to define a basic List component that accepts arbitrary children in the Yew framework. It uses the 'Children' type to handle multiple child components passed to it.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/components/children.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Children, Component, Context, Html, Properties};\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: Children,\n}\n\npub struct List;\n\nimpl Component for List {\n    type Message = ();\n    type Properties = ListProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"list\">\n                { for ctx.props().children.iter() }\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Deriving Properties Trait in Rust\nDESCRIPTION: Demonstrates how to use the derive macro to implement the Properties trait on a struct. The struct must also implement PartialEq for Yew's data comparison.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/function-components/properties.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::Properties;\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub is_loading: bool,\n}\n```\n\n----------------------------------------\n\nTITLE: use_subscribe Hook Implementation without use_hook\nDESCRIPTION: This code implements the `use_subscribe` custom hook without using `use_hook`. It utilizes `use_state` and `use_effect` directly to manage the state and subscribe to the event bus. This implementation serves as a more straightforward alternative to using `use_hook` for creating custom hooks.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.21/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n```rust\nfn use_subscribe() -> Rc<Vec<String>> {\n    let (state, set_state) = use_state(Vec::new);\n\n    use_effect(move || {\n        let producer = EventBus::bridge(Callback::from(move |msg| {\n            let mut messages = (*state).clone();\n            messages.push(msg);\n            set_state(messages)\n        }));\n        || drop(producer)\n    });\n\n    state\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for Yew Application\nDESCRIPTION: Cargo.toml configuration that includes the Yew dependency with client-side rendering (csr) feature enabled, necessary for building a Yew application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"yew-app\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nyew = { git = \"https://github.com/yewstack/yew/\", features = [\"csr\"] }\n```\n\n----------------------------------------\n\nTITLE: Implementing a Pure Function Component in Rust using Yew\nDESCRIPTION: Demonstrates how to create a pure function component in Yew. The component takes a boolean prop 'is_loading' and renders different HTML based on its value, without side effects.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/function-components/pure-components.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Properties, function_component, Html, html};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub is_loading: bool,\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n    if props.is_loading {\n        html! { \"Loading\" }\n    } else {\n        html! { \"Hello world\" }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering in Yew HTML Templates\nDESCRIPTION: Shows how to use conditional expressions within Yew HTML templates to dynamically render content based on a boolean condition.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet show_link = true;\n\nhtml! {\n  <div>\n    {\n      if show_link {\n        html! {\n          <a href=\"https://example.com\">{\"Link\"}</a>\n        }\n      } else {\n        html! {}\n      }\n    }\n  </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Deriving Properties for a Component in Yew (Rust)\nDESCRIPTION: This snippet shows how to define properties for a Yew component using the `#[derive(Properties)]` macro. It emphasizes the need for each field to implement `PartialEq` and provides examples of property attributes for default values.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/struct-components/properties.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::Properties;\n/// Importing the AttrValue from virtual_dom\nuse yew::virtual_dom::AttrValue;\n\n#[derive(Clone, PartialEq)]\npub enum LinkColor {\n    Blue,\n    Red,\n    Green,\n    Black,\n    Purple,\n}\n\nfn create_default_link_color() -> LinkColor {\n    LinkColor::Blue\n}\n\n#[derive(Properties, PartialEq)]\npub struct LinkProps {\n    /// The link must have a target.\n    href: AttrValue,\n    /// Also notice that we are using AttrValue instead of String\n    text: AttrValue,\n    /// Color of the link. Defaults to `Blue`.\n    #[prop_or_else(create_default_link_color)]\n    color: LinkColor,\n    /// The view function will not specify a size if this is None.\n    #[prop_or_default]\n    size: Option<u32>,\n    /// When the view function does not specify active, it defaults to true.\n    #[prop_or(true)]\n    active: bool,\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{props, Properties, virtual_dom::AttrValue};\n\n#[derive(Clone, PartialEq)]\npub enum LinkColor {\n    Blue,\n    Red,\n    Green,\n    Black,\n    Purple,\n}\n\nfn create_default_link_color() -> LinkColor {\n    LinkColor::Blue\n}\n\n#[derive(Properties, PartialEq)]\npub struct LinkProps {\n    /// The link must have a target.\n    href: AttrValue,\n    /// Also notice that we're using AttrValue instead of String\n    text: AttrValue,\n    /// Color of the link. Defaults to `Blue`.\n    #[prop_or_else(create_default_link_color)]\n    color: LinkColor,\n    /// The view function will not specify a size if this is None.\n    #[prop_or_default]\n    size: Option<u32>,\n    /// When the view function doesn't specify active, it defaults to true.\n    #[prop_or(true)]\n    active: bool,\n}\n\nimpl LinkProps {\n    /// Notice that this function receives href and text as String\n    /// We can use `AttrValue::from` to convert it to a `AttrValue`\n    pub fn new_link_with_size(href: String, text: String, size: u32) -> Self {\n        // highlight-start\n        props! {LinkProps {\n            href: AttrValue::from(href),\n            text: AttrValue::from(text),\n            size,\n        }}\n        // highlight-end\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using `use_mut_ref` Hook in Yew\nDESCRIPTION: This code demonstrates the usage of the `use_mut_ref` hook in a Yew function component.  The hook allows to obtain a mutable reference to a value that persists across renders. In this example, it's used to track the number of messages sent, limiting the user to a maximum of 3 messages.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/function-components/pre-defined-hooks.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::{\n    events::Event,\n    function_component, html, use_mut_ref, use_state,\n    Callback, TargetCast,\n};\n\n#[function_component(UseMutRef)]\nfn mut_ref_hook() -> Html {\n    let message = use_state(|| \"\".to_string());\n    let message_count = use_mut_ref(|| 0);\n\n    let onclick = Callback::from(move |_| {\n        let window = gloo_utils::window();\n\n        if *message_count.borrow_mut() > 3 {\n            window.alert_with_message(\"Message limit reached\").unwrap();\n        } else {\n            *message_count.borrow_mut() += 1;\n            window.alert_with_message(\"Message sent\").unwrap();\n        }\n    });\n\n    let onchange = {\n        let message = message.clone();\n        Callback::from(move |e: Event| {\n            let input: HtmlInputElement = e.target_unchecked_into();\n            message.set(input.value());\n        })\n    };\n\n    html! {\n        <div>\n            <input {onchange} value={(*message).clone()} />\n            <button {onclick}>{ \"Send\" }</button>\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Props Macro for Building Properties in Yew\nDESCRIPTION: Illustrates the usage of the yew::props! macro to construct properties in a way similar to the html! macro. It shows how to create a new instance of LinkProps using the props! macro with custom values.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/advanced-topics/struct-components/properties.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{props, Properties, virtual_dom::AttrValue};\n\n#[derive(Clone, PartialEq)]\npub enum LinkColor {\n    Blue,\n    Red,\n    Green,\n    Black,\n    Purple,\n}\n\nfn create_default_link_color() -> LinkColor {\n    LinkColor::Blue\n}\n\n#[derive(Properties, PartialEq)]\npub struct LinkProps {\n    /// 链接必须有一个目标\n    href: AttrValue,\n    /// 还要注意我们使用的是 AttrValue 而不是 String\n    text: AttrValue,\n    /// 链接的颜色，默认为 `Blue`\n    #[prop_or_else(create_default_link_color)]\n    color: LinkColor,\n    /// 如果值为 None，则视图函数不会指定大小\n    #[prop_or_default]\n    size: Option<u32>,\n    /// 当视图函数没有指定活动时，默认为 true\n    #[prop_or(true)]\n    active: bool,\n}\n\nimpl LinkProps {\n    /// 注意此函数接收 href 和 text 作为 String\n    /// 我们可以使用 `AttrValue::from` 将其转换为 `AttrValue`\n    pub fn new_link_with_size(href: String, text: String, size: u32) -> Self {\n        // highlight-start\n        props! {LinkProps {\n            href: AttrValue::from(href),\n            text: AttrValue::from(text),\n            size,\n        }}\n        // highlight-end\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using NodeRef for Element References in Yew\nDESCRIPTION: Shows how to use NodeRef to maintain references to DOM elements and access their values. Includes example of handling input changes using NodeRef instead of event parameters.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/events.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::{html, Component, Context, Html, NodeRef};\n\npub struct Comp {\n    my_input: NodeRef,\n}\n\npub enum Msg {\n    InputValue(String),\n}\n\nimpl Component for Comp {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_: &Context<Self>) -> Self {\n        Self {\n            my_input: NodeRef::default(),\n        }\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let link = ctx.link();\n\n        let my_input_ref = self.my_input.clone();\n\n        let onchange = link.batch_callback(move |_| {\n            let input = my_input_ref.cast::<HtmlInputElement>();\n\n            input.map(|input| Msg::InputValue(input.value()))\n        });\n\n        html! {\n            <>\n                <label for=\"my-input\">\n                    { \"My input:\" }\n                    <input ref={self.my_input.clone()}\n                        {onchange}\n                        id=\"my-input\"\n                        type=\"text\"\n                    />\n                </label>\n            </>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Suspending Hook in Yew\nDESCRIPTION: Shows how to implement a custom hook that suspends component rendering. The hook returns SuspensionResult and creates a Suspension context when data is not ready, resuming rendering when the data becomes available.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/suspense.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew::suspense::{Suspension, SuspensionResult};\n\nstruct User {\n    name: String,\n}\n\n#[hook]\nfn use_user() -> SuspensionResult<User> {\n    match load_user() {\n        // If a user is loaded, then we return it as Ok(user).\n        Some(m) => Ok(m),\n        None => {\n            // When user is still loading, then we create a `Suspension`\n            // and call `SuspensionHandle::resume` when data loading\n            // completes, the component will be re-rendered\n            // automatically.\n            let (s, handle) = Suspension::new();\n            on_load_user_complete(move || {handle.resume();});\n            Err(s)\n        },\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Hook in a Yew Component\nDESCRIPTION: This snippet shows how to use the custom `use_subscribe` hook in a Yew function component. It simplifies the component logic by abstracting the subscription and message handling.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.20/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[function_component(ShowMessages)]\npub fn show_messages() -> Html {\n    let state = use_subscribe();\n    let output = state.borrow().deref().into_iter().map(|it| html! { <p>{ it }</p> });\n\n    html! { <div>{ for output }</div> }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Optional Typed Child Component in Yew\nDESCRIPTION: Demonstrates how to create a component that accepts an optional child of a specific type using Option<VChild<T>>. The example shows a Page component that can optionally include a PageSideBar.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/components/children.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, virtual_dom::VChild, Component, Html, Properties};\n\n#[derive(Clone, Properties)]\npub struct PageProps {\n    #[prop_or_default]\n    pub sidebar: Option<VChild<PageSideBar>>,\n}\n\nstruct Page {\n    props: PageProps,\n}\n\nimpl Component for Page {\n    type Properties = PageProps;\n    // ...\n\n    fn view(&self) -> Html {\n        html! {\n            <div class=\"page\">\n                { self.props.sidebar.clone().map(Html::from).unwrap_or_default() }\n                // ... page content\n            </div>\n        }\n    }\n}\n\n// The page component can be called either with the sidebar or without:\n\n// Page without sidebar\nhtml! {\n    <Page />\n}\n\n// Page with sidebar\nhtml! {\n<Page sidebar=html_nested! {\n    <PageSideBar />\n    } />\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Router with Switch Component in Yew\nDESCRIPTION: Demonstrates how to use the Switch component to render different components based on the current route in a Yew application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/router.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew_router::prelude::*;\nuse yew::prelude::*;\n\n#[derive(Clone, Routable, PartialEq)]\nenum Route {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/secure\")]\n    Secure,\n    #[not_found]\n    #[at(\"/404\")]\n    NotFound,\n}\n\n#[function_component(Secure)]\nfn secure() -> Html {\n    let navigator = use_navigator().unwrap();\n\n    let onclick = Callback::from(move |_| navigator.push(&Route::Home));\n    html! {\n        <div>\n            <h1>{ \"Secure\" }</h1>\n            <button {onclick}>{ \"Go Home\" }</button>\n        </div>\n    }\n}\n\nfn switch(routes: Route) -> Html {\n    match routes {\n        Route::Home => html! { <h1>{ \"Home\" }</h1> },\n        Route::Secure => html! {\n            <Secure />\n        },\n        Route::NotFound => html! { <h1>{ \"404\" }</h1> },\n    }\n}\n\n#[function_component(Main)]\nfn app() -> Html {\n    html! {\n        <BrowserRouter>\n            <Switch<Route> render={switch} /> // <- must be child of <BrowserRouter>\n        </BrowserRouter>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Properties with Derive Macro in Yew\nDESCRIPTION: This code defines a `LinkProps` struct using the `#[derive(Properties)]` macro in Yew. It includes required properties (`href`), properties wrapped in `Rc` for memory efficiency (`text`), optional properties with default values (`color`, `size`, `active`), and uses attributes like `#[prop_or_default]` and `#[prop_or_else]` to specify default values for optional properties.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.21/advanced-topics/struct-components/properties.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub struct LinkColor {\n    Blue,\n    Red,\n    Green,\n    Black,\n    Purple,\n}\n\nimpl Default for LinkColor {\n    fn default() -> Self {\n        // 除非另有说明，否则链接的颜色将为蓝色\n        LinkColor::Blue\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct LinkProps {\n    /// 链接必须有一个目标地址\n    href: String,\n    /// 如果链接文本很大，这将使得复制字符串开销更小\n    /// 除非有性能问题，否则通常不建议这么做\n    text: Rc<String>,\n    /// 链接的颜色\n    #[prop_or_default]\n    color: LinkColor,\n    /// 如果为 None，则 view 函数将不指定大小\n    #[prop_or_default]\n    size: Option<u32>\n    /// 当 view 函数没有指定 active，其默认为 true\n    #[prop_or_else(true)]\n    active: bool,\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Event Listener Callback in Yew HTML Macro\nDESCRIPTION: Demonstrates how to add an onclick event listener callback to a button element using Yew's html macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/events.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <button onclick={Callback::from(|_| ())}>\n    //      ^^^^^^^ event listener name\n        { \"Click me!\" }\n    </button>\n};\n```\n\n----------------------------------------\n\nTITLE: Adding Interactivity to VideosList Component in Rust\nDESCRIPTION: This snippet updates the VideosList component to handle click events on videos. It demonstrates how to pass callbacks from parent to child components in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/tutorial/index.mdx#2025-04-16_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Clone, Properties, PartialEq)]\nstruct VideosListProps {\n    videos: Vec<Video>,\n    on_click: Callback<Video>\n}\n\n#[function_component(VideosList)]\nfn videos_list(VideosListProps { videos, on_click }: &VideosListProps) -> Html {\n    let on_click = on_click.clone();\n    videos.iter().map(|video| {\n        let on_video_select = {\n            let on_click = on_click.clone();\n            let video = video.clone();\n            Callback::from(move |_| {\n                on_click.emit(video.clone())\n            })\n        };\n\n        html! {\n            <p onclick={on_video_select}>{format!(\"{}: {}\", video.speaker, video.title)}</p>\n        }\n    }).collect()\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Callback Implementation in Yew\nDESCRIPTION: Demonstrates creation and usage of a basic callback in Yew that processes a string input and returns a formatted string output. Shows how to create a callback and emit values.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/function-components/callbacks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html, Callback};\n\nlet cb: Callback<String, String> = Callback::from(move |name: String| {\n    format!(\"Bye {}\", name)\n});\n\nlet result = cb.emit(String::from(\"Bob\")); // call the callback\n// web_sys::console::log_1(&result.into()); // if uncommented will print \"Bye Bob\"\n```\n\n----------------------------------------\n\nTITLE: Using classes! Macro with String Variable in Yew (Rust)\nDESCRIPTION: Illustrates using the classes! macro with a String variable containing multiple classes to set on a div element in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/html/classes.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nlet my_classes = String::from(\"class-1 class-2\");\n\nhtml! {\n  <div class={classes!(my_classes)}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Subscription Hook in Yew\nDESCRIPTION: This Rust snippet defines a custom hook, use_subscribe, which facilitates subscribing to a messaging EventBus. It utilizes hooks like use_state and use_effect to maintain a list of messages and react to lifecycle changes. The dependency on yew, yew_agent, and EventBus reflects its integration with the Yew framework for managing state and agent subscriptions. It returns a cloned Vec<String> holding messages.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/function-components/custom-hooks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::HashSet;\nuse yew::{use_effect, use_state, Callback};\nuse yew_agent::Bridged;\n// EventBus is an implementation yew_agent::Agent\nuse website_test::agents::EventBus;\n\nfn use_subscribe() -> Vec<String> {\n    let state = use_state(Vec::new);\n\n    let effect_state = state.clone();\n\n    use_effect(move || {\n        let producer = EventBus::bridge(Callback::from(move |msg| {\n            let mut messages = (*effect_state).clone();\n            messages.push(msg);\n            effect_state.set(messages)\n        }));\n        || drop(producer)\n    });\n\n    (*state).clone()\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Prop Drilling in Yew Components\nDESCRIPTION: This code shows the problem of prop drilling where a Theme object is passed through multiple component layers. The Theme is created in the App component and passed down through Navbar to Title and NavButton components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/contexts.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html, Properties, function_component};\n\n#[derive(Clone, PartialEq)]\npub struct Theme {\n    foreground: String,\n    background: String,\n}\n\n#[derive(PartialEq, Properties)]\npub struct NavbarProps {\n    theme: Theme,\n}\n\n#[function_component]\nfn Navbar(props: &NavbarProps) -> Html {\n    html! {\n        <div>\n            <Title theme={props.theme.clone()}>\n                { \"App title\" }\n            </Title>\n            <NavButton theme={props.theme.clone()}>\n                { \"Somewhere\" }\n            </NavButton>\n        </div>\n    }\n}\n\n#[derive(PartialEq, Properties)]\npub struct ThemeProps {\n    theme: Theme,\n    children: Html,\n}\n\n#[function_component]\nfn Title(_props: &ThemeProps) -> Html {\n    html! {\n        // impl\n    }\n}\n\n#[function_component]\nfn NavButton(_props: &ThemeProps) -> Html {\n    html! {\n        // impl\n    }\n}\n\n/// App root\n#[function_component]\nfn App() -> Html {\n    let theme = Theme {\n        foreground: \"yellow\".to_owned(),\n        background: \"pink\".to_owned(),\n    };\n\n    html! {\n        <Navbar {theme} />\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Callbacks in Yew\nDESCRIPTION: This snippet demonstrates how to create a callback function using `ctx.link().callback` that sends a message to the component when executed. The callback can either directly wrap a message constructor (like `Msg::Text`) or accept input and construct a message. The snippet also shows how to emit a message using the callback.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/advanced-topics/struct-components/scope.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html};\n\nenum Msg {\n    Text(String),\n}\n\nstruct Comp;\n\nimpl Component for Comp {\n\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        // 建立一個接受一些文本並將其作為 `Msg::Text` 訊息變體發送到元件的回調。\n        // highlight-next-line\n        let cb = ctx.link().callback(|text: String| Msg::Text(text));\n\n        // 上一行是多餘的冗長，為了更清晰，可以簡化為這樣：\n        // highlight-next-line\n        let cb = ctx.link().callback(Msg::Text);\n\n        // 將 `Msg::Text(\"Hello World!\")` 發送到元件。\n        // highlight-next-line\n        cb.emit(\"Hello World!\".to_owned());\n\n        html! {\n            // 在這裡放置 HTML\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Children Props in Yew Components\nDESCRIPTION: Demonstrates how to create a component that accepts and renders child elements using Yew's Children prop type. Shows both the parent component implementation and how to forward children in the child component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/function-components/children.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties, Children};\n\n#[function_component]\nfn App() -> Html {\n    html! {\n        // highlight-start\n        <HelloWorld>\n            <span>{\"Hey what is up ;)\"}</span>\n            <h1>{\"THE SKY\"}</h1>\n        </HelloWorld>\n        // highlight-end\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    // highlight-next-line\n    pub children: Children, // the field name `children` is important!\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n    html! {\n        <div class=\"very-stylized-container\">\n    // highlight-next-line\n            { for props.children.iter() } // you can forward children like this\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Routes with Path Segments in Yew Router\nDESCRIPTION: Illustrates how to define routes with dynamic and named wildcard segments in Yew's router.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/router.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew_router::prelude::*;\n\n#[derive(Clone, Routable, PartialEq)]\nenum Route {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/post/:id\")]\n    Post { id: String },\n    #[at(\"/*path\")]\n    Misc { path: String },\n}\n\nfn switch(route: Route) -> Html {\n    match route {\n        Route::Home => html! { <h1>{ \"Home\" }</h1> },\n        Route::Post { id } => html! {<p>{format!(\"You are looking at Post {}\", id)}</p>},\n        Route::Misc { path } => html! {<p>{format!(\"Matched some other path: {}\", path)}</p>},\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Properties Implementation in Rust/Yew\nDESCRIPTION: Basic example showing how to implement Properties trait using the derive macro. Properties must also implement PartialEq for comparison.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/function-components/properties.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::Properties;\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub is_loading: bool,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Suspending Hook in Yew with Rust\nDESCRIPTION: This code snippet shows how to create a hook that suspends component rendering. It demonstrates the use of SuspensionResult and Suspension to handle loading states and resume rendering when data is available.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/suspense.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew::suspense::{Suspension, SuspensionResult};\n\nstruct User {\n    name: String,\n}\n\n#[hook]\nfn use_user() -> SuspensionResult<User> {\n    match load_user() {\n        // If a user is loaded, then we return it as Ok(user).\n        Some(m) => Ok(m),\n        None => {\n            // When user is still loading, then we create a `Suspension`\n            // and call `SuspensionHandle::resume` when data loading\n            // completes, the component will be re-rendered\n            // automatically.\n            let (s, handle) = Suspension::new();\n            on_load_user_complete(move || {handle.resume();});\n            Err(s)\n        },\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Event Listeners in Yew HTML Macro\nDESCRIPTION: This Rust code snippet demonstrates how to add an event listener to a button element in Yew using the `html` macro. It utilizes the `Callback` function to attach an `onclick` listener that triggers on a `click` event. The code exemplifies usage without version conflicts by re-exporting event types through `yew::events`.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/events.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Callback};\n\nhtml! {\n    <button onclick={Callback::from(|_| ())}>\n    //      ^^^^^^^ event listener name\n        { \"Click me!\" }\n    </button>\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Suspense-enabled Hook in Yew\nDESCRIPTION: Shows how to create a hook that suspends component rendering while data is loading. It returns a SuspensionResult<T> and uses a Suspension to handle the loading state.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/suspense.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew::suspense::{Suspension, SuspensionResult};\n\nstruct User {\n    name: String,\n}\n\n#[hook]\nfn use_user() -> SuspensionResult<User> {\n    match load_user() {\n        // If a user is loaded, then we return it as Ok(user).\n        Some(m) => Ok(m),\n        None => {\n            // When user is still loading, then we create a `Suspension`\n            // and call `SuspensionHandle::resume` when data loading\n            // completes, the component will be re-rendered\n            // automatically.\n            let (s, handle) = Suspension::new();\n            on_load_user_complete(move || {handle.resume();});\n            Err(s)\n        },\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Type-Specific Child Components in Yew\nDESCRIPTION: Implementation of a list component that only accepts specific child component types\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/advanced-topics/children.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, ChildrenWithProps, Component, Context, Html, Properties};\n\npub struct Item;\n\nimpl Component for Item {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"item\" }\n        }\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: ChildrenWithProps<Item>,\n}\n\npub struct List;\n\nimpl Component for List {\n    type Message = ();\n    type Properties = ListProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"list\">\n                { for ctx.props().children.iter() }\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Event Hook in Yew\nDESCRIPTION: This snippet shows the full implementation of the use_event custom hook. It uses use_effect_with to manage the event listener lifecycle and handle changes to the hook's arguments.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse web_sys::{Event, EventTarget};\nuse std::borrow::Cow;\nuse std::rc::Rc;\nuse gloo::events::EventListener;\n\n#[hook]\npub fn use_event<E, F>(target: &EventTarget, event_type: E, callback: F)\nwhere\n    E: Into<Cow<'static, str>>,\n    F: Fn(Event) + 'static,\n{\n    #[derive(PartialEq, Clone)]\n    struct EventDependents {\n        target: EventTarget,\n        event_type: Cow<'static, str>,\n        callback: Callback<Event>,\n    }\n\n    let deps = EventDependents {\n        target: target.clone(),\n        event_type: event_type.into(),\n        callback: Callback::from(callback),\n    };\n\n    use_effect_with(\n        deps,\n        |deps| {\n            let EventDependents {\n                target,\n                event_type,\n                callback,\n            } = deps.clone();\n\n            let listener = EventListener::new(&target, event_type, move |e| {\n                callback.emit(e.clone());\n            });\n\n            move || {\n                drop(listener);\n            }\n        },\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Classes in Yew Component Properties\nDESCRIPTION: This snippet demonstrates how to define a Yew component that accepts a `class` property of type `Classes` and uses it to apply CSS classes to a div element. It also shows how to combine the `class` prop with other conditional classes. It requires the `yew` crate.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/classes.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    #[prop_or_default]\n    class: Classes,\n    fill: bool,\n    children: Html,\n}\n\n#[function_component]\nfn MyComponent(props: &Props) -> Html {\n    let Props {\n        class,\n        fill,\n        children,\n    } = props;\n    html! {\n        <div\n            class={classes!(\n                \"my-container-class\",\n                fill.then(|| Some(\"my-fill-class\")),\n                class.clone(),\n            )}\n        >\n            { children.clone() }\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Conditional Expressions in Yew HTML (Rust)\nDESCRIPTION: This example shows how to use a conditional expression within Yew's HTML macro. It demonstrates rendering different HTML based on a boolean condition.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.18.0/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nhtml! {\n  <div>\n    {\n      if show_link {\n        html! {\n          <a href=\"https://example.com\">{\"Link\"}</a>\n        }\n      } else {\n        html! {}\n      }\n    }\n  </div>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Child Components in Yew\nDESCRIPTION: Demonstrates how to create a component that accepts generic children using the Html type. This approach is suitable for most cases where the specific type of children is not important.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/advanced-topics/children.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html, Properties};\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: Html,\n}\n\npub struct List;\n\nimpl Component for List {\n    type Message = ();\n    type Properties = ListProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"list\">\n                {ctx.props().children.clone()}\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Children Components in Yew\nDESCRIPTION: This snippet demonstrates how to create a List component that accepts generic children. It uses the Html type for children, which is recommended for most cases due to its lower performance overhead.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/children.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html, Properties};\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: Html,\n}\n\npub struct List;\n\nimpl Component for List {\n    type Message = ();\n    type Properties = ListProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"list\">\n                {ctx.props().children.clone()}\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Context Provider in Yew\nDESCRIPTION: This snippet demonstrates how to create and use a context provider in Yew. It shows the implementation of a Theme context and how to wrap components with the ContextProvider.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/contexts.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::rc::Rc;\nuse yew::prelude::*;\n\n#[derive(Clone, Debug, PartialEq)]\nstruct Theme {\n    foreground: String,\n    background: String,\n}\n\n#[function_component]\nfn NavButton() -> Html {\n    let theme = use_context::<Rc<Theme>>().expect(\"Context not found\");\n\n    html! {\n        // use theme\n    }\n}\n\n#[function_component]\nfn App() -> Html {\n    let theme = use_memo(|_| Theme {\n        foreground: \"yellow\".to_owned(),\n        background: \"pink\".to_owned(),\n    }, ());\n\n    html! {\n        <ContextProvider<Rc<Theme>> context={theme}>\n            <NavButton />\n        </ContextProvider<Rc<Theme>>>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Lists Using Yew's for Keyword\nDESCRIPTION: Shows an alternative syntax for rendering lists in Yew using the special 'for' keyword in the HTML macro. This approach provides a more declarative way to iterate over collections.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/lists.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet items = (1..=10).collect::<Vec<_>>();\n\nhtml! {\n    <ul class=\"item-list\">\n        { for items.iter() }\n    </ul>\n};\n```\n\n----------------------------------------\n\nTITLE: SVG Rendering with Yew\nDESCRIPTION: Shows how to render SVG content using the `html!` macro, including paths, circles, and filters with dynamic tag names for SVG-specific elements.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/introduction.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <svg width=\"149\" height=\"147\" viewBox=\"0 0 149 147\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n        <path d=\"M60.5776 13.8268L51.8673 42.6431L77.7475 37.331L60.5776 13.8268Z\" fill=\"#DEB819\"/>\n        <path d=\"M108.361 94.9937L138.708 90.686L115.342 69.8642\" stroke=\"black\" stroke-width=\"4\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        <g filter=\"url(#filter0_d)\">\n            <circle cx=\"75.3326\" cy=\"73.4918\" r=\"55\" fill=\"#FDD630\"/>\n            <circle cx=\"75.3326\" cy=\"73.4918\" r=\"52.5\" stroke=\"black\" stroke-width=\"5\"/>\n        </g>\n        <circle cx=\"71\" cy=\"99\" r=\"5\" fill=\"white\" fill-opacity=\"0.75\" stroke=\"black\" stroke-width=\"3\"/>\n        <defs>\n            <filter id=\"filter0_d\" x=\"16.3326\" y=\"18.4918\" width=\"118\" height=\"118\" filterUnits=\"userSpaceOnUse\" color-interpolation-filters=\"sRGB\">\n                <@{\"feGaussianBlur\"} stdDeviation=\"2\"/>\n                <@{\"feColorMatrix\"} in=\"SourceAlpha\" type=\"matrix\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\"/>\n            </filter>\n        </defs>\n    </svg>\n};\n```\n\n----------------------------------------\n\nTITLE: Embedding Values in HTML with Yew\nDESCRIPTION: This snippet shows how to embed variables and expressions into HTML using Yew's `html!` macro. It includes examples of embedding strings and numbers within the HTML structure.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/basic-web-technologies/html.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet header_text = \"Hello world\".to_string();\nlet header_html: Html = html! {\n    <h1>{header_text}</h1>\n};\n\nlet count: usize = 5;\nlet counter_html: Html = html! {\n    <p>{\"My age is: \"}{count}</p>\n};\n\nlet combined_html: Html = html! {\n    <div>{header_html}{counter_html}</div>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a Component with State and Effect in Yew\nDESCRIPTION: This snippet shows a Yew function component that subscribes to an agent and displays received messages. It uses `use_state` and `use_effect` hooks to manage state and side effects.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.20/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[function_component(ShowMessages)]\npub fn show_messages() -> Html {\n    let (state, set_state) = use_state(|| vec![]);\n\n    {\n        let mut state = Rc::clone(&state);\n        use_effect(move || {\n            let producer = EventBus::bridge(Callback::from(move |msg| {\n                let mut messages = (*state).clone();\n                messages.push(msg);\n                set_state(messages)\n            }));\n\n            || drop(producer)\n        });\n    }\n\n    let output = state.iter().map(|it| html! { <p>{ it }</p> });\n    html! { <div>{ for output }</div> }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Suspense with Function Components in Rust\nDESCRIPTION: This snippet demonstrates how to use Suspense with function components in Yew. It shows the basic structure of a suspending hook and how to use it in a component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/suspense.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[function_component(Content)]\nfn content() -> HtmlResult {\n    let user = use_user()?;\n\n    Ok(html! {<div>{\"Hello, \"}{&user.name}</div>})\n}\n\n#[function_component(App)]\nfn app() -> Html {\n    let fallback = html! {<div>{\"Loading...\"}</div>};\n\n    html! {\n        <Suspense {fallback}>\n            <Content />\n        </Suspense>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AppRoute Enum with Switch Trait in Rust\nDESCRIPTION: This code snippet demonstrates how to create an enum representing application routes and implement the Switch trait for routing. It shows the use of #[to] attributes for route mapping and various route patterns including capturing segments.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.21/concepts/router.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Switch)]\nenum AppRoute {\n  #[to=\"/login\"]\n  Login,\n  #[to=\"/register\"]\n  Register,\n  #[to=\"/delete_account\"]\n  Delete,\n  #[to=\"/posts/{id}\"]\n  ViewPost(i32),\n  #[to=\"/posts/view\"]\n  ViewPosts,\n  #[to=\"/\"]\n  Home\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Navigation in Function Components with Yew Router\nDESCRIPTION: Example of using the Navigator API in function components to implement programmatic navigation. It demonstrates creating buttons that navigate to different routes when clicked.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/router.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew_router::prelude::*;\n\n#[function_component(NavItems)]\npub fn nav_items() -> Html {\n    let navigator = use_navigator().unwrap();\n\n    let go_home_button = {\n        let navigator = navigator.clone();\n        let onclick = Callback::from(move |_| navigator.push(&Route::Home));\n        html! {\n            <button {onclick}>{\"click to go home\"}</button>\n        }\n    };\n\n    let go_to_first_post_button = {\n        let navigator = navigator.clone();\n        let onclick = Callback::from(move |_| navigator.push(&Route::Post { id: \"first-post\".to_string() }));\n        html! {\n            <button {onclick}>{\"click to go the first post\"}</button>\n        }\n    };\n\n    let go_to_secure_button = {\n        let onclick = Callback::from(move |_| navigator.push(&Route::Secure));\n        html! {\n            <button {onclick}>{\"click to go to secure\"}</button>\n        }\n    };\n\n    html! {\n        <>\n            {go_home_button}\n            {go_to_first_post_button}\n            {go_to_secure_button}\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using classes! Macro with String in Yew (Rust)\nDESCRIPTION: Illustrates how to use a String containing multiple class names with the classes! macro in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(String::from(\"class-1 class-2\"))}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Nested Yew Components with Children\nDESCRIPTION: This code snippet demonstrates how to create a Yew component that accepts child components/elements via a `children` field in its `Properties`. It showcases how to render the children within the parent component using `props.children.clone()`. The snippet defines a `Container` component that wraps its children in a `div` element with a specified ID.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/components.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    id: String,\n    children: Html,\n}\n\n#[function_component]\nfn Container(props: &Props) -> Html {\n    html! {\n        <div id={props.id.clone()}>\n            { props.children.clone() }\n        </div>\n    }\n}\n\nhtml! {\n    <Container id=\"container\">\n        <h4>{ \"Hi\" }</h4>\n        <div>{ \"Hello\" }</div>\n    </Container>\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a Modal Component using Portals in Rust with Yew\nDESCRIPTION: This code snippet demonstrates how to create a simple modal dialog component using Yew's create_portal function. It renders its children into an element outside Yew's control, identified by the id 'modal_host'. The component accepts children as a prop and uses the gloo utility to find the host element in the document.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/portals.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(Properties, PartialEq)]\npub struct ModalProps {\n    #[prop_or_default]\n    pub children: Html,\n}\n\n#[function_component]\nfn Modal(props: &ModalProps) -> Html {\n    let modal_host = gloo::utils::document()\n        .get_element_by_id(\"modal_host\")\n        .expect(\"Expected to find a #modal_host element\");\n\n    create_portal(\n        props.children.clone(),\n        modal_host.into(),\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Generic Function Component in Yew\nDESCRIPTION: This snippet demonstrates creating a generic function component using the #[function_component] attribute. It includes defining generic Props with type constraints, implementing the component function with appropriate trait bounds, and shows example usage with different types.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/function-components/generics.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt::Display;\nuse yew::{function_component, html, Properties, Html};\n\n#[derive(Properties, PartialEq)]\npub struct Props<T>\nwhere\n    T: PartialEq,\n{\n    data: T,\n}\n\n#[function_component]\npub fn MyGenericComponent<T>(props: &Props<T>) -> Html\nwhere\n    T: PartialEq + Clone + Into<Html>,\n{\n    html! {\n        <p>\n            { props.data.clone().into() }\n        </p>\n    }\n}\n\n// then can be used like this\nhtml! {\n    <MyGenericComponent<i32> data=123 />\n};\n\n// or\nhtml! {\n    <MyGenericComponent<String> data={\"foo\".to_string()} />\n};\n```\n\n----------------------------------------\n\nTITLE: DOM Event Handling with Callbacks in Yew\nDESCRIPTION: Demonstrates how to handle DOM events using callbacks in Yew. Shows implementation of a click event handler on a button element.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/function-components/callbacks.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties, Callback};\n\n#[function_component]\nfn App() -> Html {\n    let onclick = Callback::from(move |_| {\n        let greeting = String::from(\"Hi there\");\n        // web_sys::console::log_1(&greeting.into()); // if uncommented will print\n    });\n\n    html! {\n        <button {onclick}>{ \"Click\" }</button>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Keyed Lists in Yew\nDESCRIPTION: This snippet demonstrates how to create a keyed list in Yew by assigning unique keys to list items. Keys are added using the special 'key' prop and help optimize rendering performance when list items are added, removed, or reordered.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/lists.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet names = vec![\"Sam\",\"Bob\",\"Ray\"]\n\nhtml! {\n    <div id=\"introductions\">\n        {\n            names.into_iter().map(|name| {\n                html!{<div key={name}>{ format!(\"Hello, I'am {}!\",name) }</div>}\n            }).collect::<Html>()\n        }\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Function Component With Props in Yew\nDESCRIPTION: Example of a function component that accepts and uses Props, showing both component definition and usage.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/function-components/properties.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub is_loading: bool,\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n    html! { <>{\"Am I loading? - \"}{props.is_loading.clone()}</> }\n}\n\n#[function_component]\nfn App() -> Html {\n    html! {<HelloWorld is_loading={true} />}\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Event Listener with web-sys and wasm-bindgen\nDESCRIPTION: This Rust snippet illustrates how to add a manual event listener in Yew using the web-sys and wasm-bindgen libraries, particularly for events not supported by Yew. It shows how to wrap callback functions in closures and attach them to DOM elements. This approach requires familiarity with Rust's closure characteristics and external library usage.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/events.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::{prelude::Closure, JsCast};\nuse web_sys::HtmlElement;\nuse yew::prelude::*;\n\n#[function_component]\nfn MyComponent() -> Html {\n    let div_node_ref = use_node_ref();\n\n    use_effect_with(\n        div_node_ref.clone(),\n        {\n            let div_node_ref = div_node_ref.clone();\n\n            move |_| {\n                let mut custard_listener = None;\n\n                if let Some(element) = div_node_ref.cast::<HtmlElement>() {\n                    // Create your Callback as you normally would\n                    let oncustard = Callback::from(move |_: Event| {\n                        // do something about custard..\n                    });\n\n                    // Create a Closure from a Box<dyn Fn> - this has to be 'static\n                    let listener =\n                        Closure::<dyn Fn(Event)>::wrap(\n                            Box::new(move |e: Event| oncustard.emit(e))\n                        );\n\n                    element\n                        .add_event_listener_with_callback(\n                            \"custard\",\n                            listener.as_ref().unchecked_ref()\n                        )\n                        .unwrap();\n\n                    custard_listener = Some(listener);\n                }\n\n                move || drop(custard_listener)\n            }\n        }\n    );\n\n    html! {\n        <div ref={div_node_ref} id=\"my-div\"></div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Keyed Lists in Yew\nDESCRIPTION: Demonstrates how to implement keyed lists in Yew using the special 'key' prop. Keys help optimize list rendering by providing unique identifiers for list items.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/lists.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet names = vec![\"Sam\",\"Bob\",\"Ray\"]\n\nhtml! {\n    <div id=\"introductions\">\n        {\n            names.into_iter().map(|name| {\n                html!{<div key={name}>{ format!(\"Hello, I'am {}!\",name) }</div>}\n            }).collect::<Html>()\n        }\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Redirect Component in Yew Router\nDESCRIPTION: Example showing how to use the Redirect component to handle conditional navigation based on user authentication state.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/router.mdx#2025-04-16_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n#[function_component(SomePage)]\nfn some_page() -> Html {\n    // made-up hook `use_user`\n    let user = match use_user() {\n        Some(user) => user,\n        // Redirects to the login page when user is `None`.\n        None => return html! {\n            <Redirect<Route> to={Route::Login}/>\n        },\n    };\n    // ... actual page content.\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Suspense with Function Components in Yew\nDESCRIPTION: Demonstrates the basic pattern for using Suspense with function components, showing how to create a component that suspends rendering while waiting for user data to load, with a Loading fallback UI.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/suspense.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[function_component(Content)]\nfn content() -> HtmlResult {\n    let user = use_user()?;\n\n    Ok(html! {<div>{\"Hello, \"}{&user.name}</div>})\n}\n\n#[function_component(App)]\nfn app() -> Html {\n    let fallback = html! {<div>{\"Loading...\"}</div>};\n\n    html! {\n        <Suspense {fallback}>\n            <Content />\n        </Suspense>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Component with Window Event Listener in Yew\nDESCRIPTION: Example of a function component that listens for storage events on the window object using Yew's use_effect hook. This component demonstrates stateful logic that could be extracted into a custom hook.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse gloo::events::EventListener;\nuse gloo::utils::window;\nuse std::mem::drop;\n\n\n#[function_component(ShowStorageChanged)]\npub fn show_storage_changed() -> Html {\n    let state_storage_changed = use_state(|| false);\n\n    {\n        let state_storage_changed = state_storage_changed.clone();\n        use_effect(|| {\n            let listener = EventListener::new(&window(), \"storage\", move |_| state_storage_changed.set(true));\n\n            move || { drop(listener); }\n        });\n    }\n\n    html! { <div>{\"Storage Event Fired: \"}{*state_storage_changed}</div> }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Yew Application Component\nDESCRIPTION: Creates a Yew function component with a counter that increments when a button is clicked. The component demonstrates state management with use_state and event handling in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[function_component]\nfn App() -> Html {\n    let counter = use_state(|| 0);\n    let onclick = {\n        let counter = counter.clone();\n        move |_| {\n            let value = *counter + 1;\n            counter.set(value);\n        }\n    };\n\n    html! {\n        <div>\n            <button {onclick}>{ \"+1\" }</button>\n            <p>{ *counter }</p>\n        </div>\n    }\n}\n\nfn main() {\n    yew::Renderer::<App>::new().render();\n}\n```\n\n----------------------------------------\n\nTITLE: Using `use_node_ref` Hook in Yew\nDESCRIPTION: This code demonstrates the usage of the `use_node_ref` hook in a Yew function component. The hook allows accessing a DOM node. The code retrieves the value of the input and adds to the current value.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/function-components/pre-defined-hooks.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::{\n    function_component, functional::*, html,\n    NodeRef\n};\n\n#[function_component(UseRef)]\npub fn ref_hook() -> Html {\n    let input_ref = use_node_ref();\n    let value = use_state(|| 25f64);\n\n    let onclick = {\n        let input_ref = input_ref.clone();\n        let value = value.clone();\n        move |_| {\n            if let Some(input) = input_ref.cast::<HtmlInputElement>() {\n                value.set(*value + input.value_as_number());\n            }\n        }\n    };\n\n    html! {\n        <div>\n            <input ref={input_ref} type=\"number\" />\n            <button {onclick}>{ format!(\"Add input to {}\", *value) }</button>\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Pure Function Component in Yew\nDESCRIPTION: This snippet demonstrates a pure component in Yew where the HTML output is deterministically derived from props. It defines a Props struct with a boolean flag and implements a function component that conditionally renders different content based on the loading state.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/function-components/pure-components.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Properties, function_component, Html, html};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub is_loading: bool,\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n    if props.is_loading {\n        html! { \"Loading\" }\n    } else {\n        html! { \"Hello world\" }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Handling with JsCast in Yew using Rust\nDESCRIPTION: Demonstrates how to implement event handling in Yew by converting event targets to specific input elements using JsCast. It provides two approaches: a cautious method using dyn_into and a less cautious method using unchecked_into for type casting.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/events.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::JsCast;\nuse web_sys::{EventTarget, HtmlInputElement};\nuse yew::{\n    events::Event,\n    html,\n    Component, Context, Html,\n};\n\npub struct Comp;\n\npub enum Msg {\n    InputValue(String),\n}\n\nimpl Component for Comp {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let link = ctx.link();\n\n        // Use batch_callback so if something unexpected happens we can return\n        // None and do nothing\n        let on_cautious_change = link.batch_callback(|e: Event| {\n            // When events are created the target is undefined, it's only\n            // when dispatched does the target get added.\n            let target: Option<EventTarget> = e.target();\n            // Events can bubble so this listener might catch events from child\n            // elements which are not of type HtmlInputElement\n            let input = target.and_then(|t| t.dyn_into::<HtmlInputElement>().ok());\n\n            input.map(|input| Msg::InputValue(input.value()))\n        });\n\n        let on_dangerous_change = link.callback(|e: Event| {\n            let target: EventTarget = e\n                .target()\n                .expect(\"Event should have a target when dispatched\");\n            // You must KNOW target is a HtmlInputElement, otherwise\n            // the call to value would be Undefined Behaviour (UB).\n            Msg::InputValue(target.unchecked_into::<HtmlInputElement>().value())\n        });\n\n        html! {\n            <>\n                <label for=\"cautious-input\">\n                    { \"My cautious input:\" }\n                    <input onchange={on_cautious_change}\n                        id=\"cautious-input\"\n                        type=\"text\"\n                    />\n                </label>\n                <label for=\"dangerous-input\">\n                    { \"My dangerous input:\" }\n                    <input onchange={on_dangerous_change}\n                        id=\"dangerous-input\"\n                        type=\"text\"\n                    />\n                </label>\n            </>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Callback in Yew Component\nDESCRIPTION: This code snippet demonstrates how to create a callback within a Yew component that sends a message to the component when executed. It showcases the usage of `ctx.link().callback` to create callbacks and emit messages, triggering updates in the component's state. The callback accepts a String and uses it to create the Msg::Text variant.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/components/scope.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html};\n\nenum Msg {\n    Text(String),\n}\n\nstruct Comp;\n\nimpl Component for Comp {\n\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        // Create a callback that accepts some text and sends it\n        // to the component as the `Msg::Text` message variant.\n        // highlight-next-line\n        let cb = ctx.link().callback(|text: String| Msg::Text(text));\n\n        // The previous line is needlessly verbose to make it clearer.\n        // It can be simplified it to this:\n        // highlight-next-line\n        let cb = ctx.link().callback(Msg::Text);\n\n        // Will send `Msg::Text(\"Hello World!\")` to the component.\n        // highlight-next-line\n        cb.emit(\"Hello World!\".to_owned());\n\n        html! {\n            // html here\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Nested HTML Elements with html! Macro in Rust\nDESCRIPTION: Shows how to create complex nested HTML structures with the html! macro, including various form elements with attributes and text content. This example demonstrates form elements with various states and properties.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/introduction.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nhtml! {\n    <div>\n        <div data-key=\"abc\"></div>\n        <div class=\"parent\">\n            <span class=\"child\" value=\"anything\"></span>\n            <label for=\"first-name\">{ \"First Name\" }</label>\n            <input type=\"text\" id=\"first-name\" value=\"placeholder\" />\n            <input type=\"checkbox\" checked=true />\n            <textarea value=\"write a story\" />\n            <select name=\"status\">\n                <option selected=true disabled=false value=\"\">{ \"Selected\" }</option>\n                <option selected=false disabled=true value=\"\">{ \"Unselected\" }</option>\n            </select>\n        </div>\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Complete ISS Location Tracker Example Using Yew's Fetch Service\nDESCRIPTION: A comprehensive example demonstrating how to create a Yew component that fetches the current location of the International Space Station using an API. The example includes data structures, message handling, component lifecycle methods, and UI rendering.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/services/fetch.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// requires the serde and anyhow crates\n\nuse serde::Deserialize;\nuse yew::\n    format::{Json, Nothing},\n    prelude::*,\n    services::fetch::{FetchService, FetchTask, Request, Response},\n};\n\n#[derive(Deserialize, Debug, Clone)]\npub struct ISSPosition {\n    latitude: String,\n    longitude: String,\n}\n\n#[derive(Deserialize, Debug, Clone)]\npub struct ISS {\n    message: String,\n    timestamp: i32,\n    iss_position: ISSPosition,\n}\n\n#[derive(Debug)]\npub enum Msg {\n    GetLocation,\n    ReceiveResponse(Result<ISS, anyhow::Error>),\n}\n\n#[derive(Debug)]\npub struct FetchServiceExample {\n    fetch_task: Option<FetchTask>,\n    iss: Option<ISS>,\n    link: ComponentLink<Self>,\n    error: Option<String>,\n}\n/// Some of the code to render the UI is split out into smaller functions here to make the code\n/// cleaner and show some useful design patterns.\nimpl FetchServiceExample {\n    fn view_iss_location(&self) -> Html {\n        match self.iss {\n            Some(ref space_station) => {\n                html! {\n                    <>\n                        <p>{ \"The ISS is at:\" }</p>\n                        <p>{ format!(\"Latitude: {}\", space_station.iss_position.latitude) }</p>\n                        <p>{ format!(\"Longitude: {}\", space_station.iss_position.longitude) }</p>\n                    </>\n                }\n            }\n            None => {\n                html! {\n                     <button onclick=self.link.callback(|_| Msg::GetLocation)>\n                         { \"Where is the ISS?\" }\n                     </button>\n                }\n            }\n        }\n    }\n    fn view_fetching(&self) -> Html {\n        if self.fetch_task.is_some() {\n            html! { <p>{ \"Fetching data...\" }</p> }\n        } else {\n            html! { <p></p> }\n        }\n    }\n    fn view_error(&self) -> Html {\n        if let Some(ref error) = self.error {\n            html! { <p>{ error.clone() }</p> }\n        } else {\n            html! {}\n        }\n    }\n}\nimpl Component for FetchServiceExample {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_props: Self::Properties, link: ComponentLink<Self>) -> Self {\n        Self {\n            fetch_task: None,\n            iss: None,\n            link,\n            error: None,\n        }\n    }\n    fn change(&mut self, _props: Self::Properties) -> bool {\n        false\n    }\n    fn update(&mut self, msg: Self::Message) -> bool {\n        use Msg::*;\n\n        match msg {\n            GetLocation => {\n                // 1. build the request\n                let request = Request::get(\"http://api.open-notify.org/iss-now.json\")\n                    .body(Nothing)\n                    .expect(\"Could not build request.\");\n                // 2. construct a callback\n                let callback =\n                    self.link\n                        .callback(|response: Response<Json<Result<ISS, anyhow::Error>>>| {\n                            let Json(data) = response.into_body();\n                            Msg::ReceiveResponse(data)\n                        });\n                // 3. pass the request and callback to the fetch service\n                let task = FetchService::fetch(request, callback).expect(\"failed to start request\");\n                // 4. store the task so it isn't canceled immediately\n                self.fetch_task = Some(task);\n                // we want to redraw so that the page displays a 'fetching...' message to the user\n                // so return 'true'\n                true\n            }\n            ReceiveResponse(response) => {\n                match response {\n                    Ok(location) => {\n                        self.iss = Some(location);\n                    }\n                    Err(error) => {\n                        self.error = Some(error.to_string())\n                    }\n                }\n                self.fetch_task = None;\n                // we want to redraw so that the page displays the location of the ISS instead of\n                // 'fetching...'\n                true\n            }\n        }\n    }\n    fn view(&self) -> Html {\n        html! {\n            <>\n                { self.view_fetching() }\n                { self.view_iss_location() }\n                { self.view_error() }\n            </>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Video List in Yew Component\nDESCRIPTION: Converts the vector of Video structs into HTML using Yew's html! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/tutorial/index.mdx#2025-04-16_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nlet videos = videos.iter().map(|video| html! {\n    <p key={video.id}>{format!(\"{}: {}\", video.speaker, video.title)}</p>\n}).collect::<Html>();\n```\n\n----------------------------------------\n\nTITLE: Defining Routes using Enum and Switch in Yew\nDESCRIPTION: This code snippet demonstrates how to define routes for a Yew application using an enum and the `Switch` derive macro. Each enum variant represents a different route, specified using the `#[to = \"/some/route\"]` attribute.  The macro automatically implements the `Switch` trait, enabling the router to map URLs to corresponding application states.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.21/concepts/router.mdx#2025-04-16_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n```rust\n#[derive(Switch)]\nenum AppRoute {\n  #[to=\"/login\"]\n  Login,\n  #[to=\"/register\"]\n  Register,\n  #[to=\"/delete_account\"]\n  Delete,\n  #[to=\"/posts/{id}\"]\n  ViewPost(i32),\n  #[to=\"/posts/view\"]\n  ViewPosts,\n  #[to=\"/\"]\n  Home\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Event Hook in Rust/Yew\nDESCRIPTION: Complete implementation of a custom event hook using use_effect_with_deps. Handles event listener creation, cleanup, and dependency management for reactive updates.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse web_sys::{Event, EventTarget};\nuse std::borrow::Cow;\nuse std::rc::Rc;\nuse gloo::events::EventListener;\n\n#[hook]\npub fn use_event<E, F>(target: &EventTarget, event_type: E, callback: F)\nwhere\n    E: Into<Cow<'static, str>>,\n    F: Fn(Event) + 'static,\n{\n    #[derive(PartialEq, Clone)]\n    struct EventDependents {\n        target: EventTarget,\n        event_type: Cow<'static, str>,\n        callback: Callback<Event>,\n    }\n\n    let deps = EventDependents {\n        target: target.clone(),\n        event_type: event_type.into(),\n        callback: Callback::from(callback),\n    };\n\n    use_effect_with_deps(\n        |deps| {\n            let EventDependents {\n                target,\n                event_type,\n                callback,\n            } = deps.clone();\n\n            let listener = EventListener::new(&target, event_type, move |e| {\n                callback.emit(e.clone());\n            });\n\n            move || {\n                drop(listener);\n            }\n        },\n        deps,\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Component State in Yew\nDESCRIPTION: This code snippet demonstrates how to initialize a Yew component's state within the `create` lifecycle method. The `create` method is called when the component is first created and receives properties from its parent component via the context. The component's initial state is then set based on these properties, using the passed context.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```rust\nuse yew::{Component, Context, html, Html, Properties};\n\n#[derive(PartialEq, Properties)]\npub struct Props;\n\npub struct MyComponent;\n\nimpl Component for MyComponent {\n    type Message = ();\n    type Properties = Props;\n\n    // highlight-start\n    fn create(ctx: &Context<Self>) -> Self {\n        MyComponent\n    }\n    // highlight-end\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            // 具体实现\n        }\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Concise Event Listener with gloo in Yew\nDESCRIPTION: This Rust snippet demonstrates using the gloo_events library to succinctly create an event listener in Yew. It simplifies event handling with the EventListener type from gloo, reducing boilerplate compared to using web-sys and wasm-bindgen directly. This approach is suitable for developers favoring modularity and ease of use in event management.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/events.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlElement;\nuse yew::prelude::*;\n\nuse gloo::events::EventListener;\n\n#[function_component]\nfn MyComponent() -> Html {\n    let div_node_ref = use_node_ref();\n\n    use_effect_with(\n        div_node_ref.clone(),\n        {\n            let div_node_ref = div_node_ref.clone();\n\n            move |_| {\n                let mut custard_listener = None;\n\n                if let Some(element) = div_node_ref.cast::<HtmlElement>() {\n                    // Create your Callback as you normally would\n                    let oncustard = Callback::from(move |_: Event| {\n                        // do something about custard..\n                    });\n\n                    // Create a Closure from a Box<dyn Fn> - this has to be 'static\n                    let listener = EventListener::new(\n                        &element,\n                        \"custard\",\n                        move |e| oncustard.emit(e.clone())\n                    );\n\n                    custard_listener = Some(listener);\n                }\n\n                move || drop(custard_listener)\n            }\n        }\n    );\n\n    html! {\n        <div ref={div_node_ref} id=\"my-div\"></div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting UI Logic into Functions in Yew\nDESCRIPTION: Demonstrates how to improve code readability by extracting UI logic into separate functions or closures. The example creates a reusable function that handles conditional rendering of a link element.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Html};\n\nlet show_link = true;\nlet maybe_display_link = move || -> Html {\n  if show_link {\n    html! {\n      <a href=\"https://example.com\">{\"Link\"}</a>\n    }\n  } else {\n    html! {}\n  }\n};\n\nhtml! {\n     <div>{maybe_display_link()}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Path Segments in Routes\nDESCRIPTION: Demonstrates how to define routes with dynamic path segments and wildcards, and how to access these parameters in the switch function.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/router.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew_router::prelude::*;\n\n#[derive(Clone, Routable, PartialEq)]\nenum Route {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/post/:id\")]\n    Post { id: String },\n    #[at(\"/*path\")]\n    Misc { path: String },\n}\n\nfn switch(route: Route) -> Html {\n    match route {\n        Route::Home => html! { <h1>{ \"Home\" }</h1> },\n        Route::Post { id } => html! {<p>{format!(\"You are looking at Post {}\", id)}</p>},\n        Route::Misc { path } => html! {<p>{format!(\"Matched some other path: {}\", path)}</p>},\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Navigation in Yew Struct Components\nDESCRIPTION: This code snippet shows how to implement navigation in Yew struct components using the Navigator API obtained through the component's context.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/router.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn view(&self, ctx: &Context<Self>) -> Html {\n    let navigator = ctx.link().navigator().unwrap();\n    let onclick = Callback::from(move |_| navigator.push(&MainRoute::Home));\n    html!{\n        <button {onclick}>{\"Go Home\"}</button>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Routes with Path Segments in Yew Router\nDESCRIPTION: This code shows how to define routes with dynamic and named wildcard segments in Yew Router, allowing for parameter extraction.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/router.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew_router::prelude::*;\n\n#[derive(Clone, Routable, PartialEq)]\nenum Route {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/post/:id\")]\n    Post { id: String },\n    #[at(\"/*path\")]\n    Misc { path: String },\n}\n\nfn switch(route: Route) -> Html {\n    match route {\n        Route::Home => html! { <h1>{ \"Home\" }</h1> },\n        Route::Post { id } => html! {<p>{format!(\"You are looking at Post {}\", id)}</p>},\n        Route::Misc { path } => html! {<p>{format!(\"Matched some other path: {}\", path)}</p>},\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic HTML Tag Structure in Yew\nDESCRIPTION: Demonstrates proper open-close tag structure using the html! macro in Yew\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n  <div id=\"my_div\"></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using classes! Macro with Literal in Yew (Rust)\nDESCRIPTION: Demonstrates using the classes! macro with a literal string to set a class on a div element in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/html/classes.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n    <div class={classes!(\"container\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Conditional Batch Callback with Keyboard Event\nDESCRIPTION: Illustrates using `batch_callback()` to create a conditional callback that only triggers a message under specific keyboard event conditions, such as pressing the Enter key.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/components/callbacks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{events::KeyboardEvent, html, Component, Context, Html};\n\nenum Msg {\n    Submit,\n}\n\nstruct Comp;\n\nimpl Component for Comp {\n\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let onkeypress = ctx.link().batch_callback(|event: KeyboardEvent| {\n            if event.key() == \"Enter\" {\n                Some(Msg::Submit)\n            } else {\n                None\n            }\n        });\n\n        html! {\n            <input type=\"text\" {onkeypress} />\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Contexts in Struct Components in Yew\nDESCRIPTION: This code demonstrates the use of `Scope::context` method to consume a context within a struct component in Yew. The example shows how a `Theme` is accessed and applied to style a button in the component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/contexts.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Callback, html, Component, Context, Html};\n\n#[derive(Clone, Debug, PartialEq)]\nstruct Theme {\n    foreground: String,\n    background: String,\n}\n\nstruct ContextDemo;\n\nimpl Component for ContextDemo {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let (theme, _) = ctx\n            .link()\n            .context::<Theme>(Callback::noop())\n            .expect(\"context to be set\");\n        html! {\n            <button style={format!(\n                    \"background: {}; color: {};\",\n                    theme.background,\n                    theme.foreground\n                )}\n            >\n                { \"Click me!\" }\n            </button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Value Interpolation in html! Macro\nDESCRIPTION: Shows how to embed Rust values into HTML using curly braces interpolation. Demonstrates combining multiple HTML elements and interpolated values.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/basic-web-technologies/html.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet header_text = \"Hello world\".to_string();\nlet header_html: Html = html! {\n    <h1>{header_text}</h1>\n};\n\nlet count: usize = 5;\nlet counter_html: Html = html! {\n    <p>{\"My age is: \"}{count}</p>\n};\n\nlet combined_html: Html = html! {\n    <div>{header_html}{counter_html}</div>\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Theme Context in Yew\nDESCRIPTION: This snippet defines a `Theme` struct to be used as a context in Yew. It outlines the structure required for data intended to be shared across components using contexts.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/contexts.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Clone, Debug, PartialEq)]\nstruct Theme {\n    foreground: String,\n    background: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering with If-Else Block in Yew (Rust)\nDESCRIPTION: Illustrates the use of an if-else block for conditional rendering in Yew. It renders different paragraph elements based on a boolean condition.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/conditional-rendering.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nlet some_condition = true;\n\nhtml! {\n    if some_condition {\n        <p>{ \"True case\" }</p>\n    } else {\n        <p>{ \"False case\" }</p>\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Video List Component in Rust with Yew\nDESCRIPTION: Creates a VideosList component that displays a list of videos. Demonstrates component props, function component syntax and HTML templating in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nstruct Video {\n    id: usize,\n    title: String,\n    speaker: String,\n    url: String,\n}\n\n#[derive(Properties, PartialEq)]\nstruct VideosListProps {\n    videos: Vec<Video>,\n}\n\n#[function_component(VideosList)]\nfn videos_list(VideosListProps { videos }: &VideosListProps) -> Html {\n    videos.iter().map(|video| html! {\n        <p key={video.id}>{format!(\"{}: {}\", video.speaker, video.title)}</p>\n    }).collect()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Enum Typed Children in Yew\nDESCRIPTION: This example shows how to create a List component that accepts multiple specific types of children components. It uses an enum to define the allowed child types and implements the necessary traits for rendering.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/children.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::\n    html, html::ChildrenRenderer, virtual_dom::VChild, Component,\n    Context, Html, Properties,\n};\n\npub struct Primary;\n\nimpl Component for Primary {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"Primary\" }\n        }\n    }\n}\n\npub struct Secondary;\n\nimpl Component for Secondary {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"Secondary\" }\n        }\n    }\n}\n\n#[derive(Clone, derive_more::From, PartialEq)]\npub enum Item {\n    Primary(VChild<Primary>),\n    Secondary(VChild<Secondary>),\n}\n\n#[allow(clippy::from_over_into)]\nimpl Into<Html> for Item {\n    fn into(self) -> Html {\n        match self {\n            Self::Primary(child) => child.into(),\n            Self::Secondary(child) => child.into(),\n        }\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: ChildrenRenderer<Item>,\n}\n\npub struct List;\n\nimpl Component for List {\n    type Message = ();\n    type Properties = ListProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"list\">\n                { for ctx.props().children.iter() }\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Hydration with Yew's Renderer in Rust\nDESCRIPTION: Illustrates how to perform hydration using Yew's Renderer to reconcile server-rendered HTML with client operations. Requires Yew's Renderer module. The example demonstrates setting up a Yew function component and initiating hydration to integrate server-generated HTML. Input is a reference to the renderer; the expected result is a seamless integration of server-generated HTML into a client-rendered DOM.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/server-side-rendering.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\\nuse yew::Renderer;\\n\\n#[function_component]\\nfn App() -> Html {\\n    html! {<div>{\"Hello, World!\"}</div>}\\n}\\n\\nfn main() {\\n    let renderer = Renderer::<App>::new();\\n\\n    // 直接在 body 元素下注水，并移除可能有的任何尾随元素。\\n    renderer.hydrate();\\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Boolean Attributes in Yew HTML\nDESCRIPTION: This snippet demonstrates how to set boolean attributes in Yew's html! macro. It shows setting the 'hidden' attribute to true and false using a boolean expression.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/elements.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <div hidden=true>\n        { \"This div is hidden.\" }\n    </div>\n};\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet no = 1 + 1 != 2;\n\nhtml! {\n    <div hidden={no}>\n        { \"This div is NOT hidden.\" }\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Routes in Rust for Yew Router\nDESCRIPTION: This code defines an enum for routes in a Yew application, using the Routable derive macro. It includes basic routes and a not found route.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/router.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew_router::prelude::*;\n\n#[derive(Clone, Routable, PartialEq)]\nenum Route {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/secure\")]\n    Secure,\n    #[not_found]\n    #[at(\"/404\")]\n    NotFound,\n}\n```\n\n----------------------------------------\n\nTITLE: Using yew::props! Macro for Building Properties in Rust\nDESCRIPTION: Shows how to use the yew::props! macro to build properties in a similar way to the html! macro. This allows for creating properties outside of the html! macro context.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/function-components/properties.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties, props, virtual_dom::AttrValue};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    #[prop_or(AttrValue::from(\"Bob\"))]\n    pub name: AttrValue,\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n    html! {<>{\"Hello world\"}{props.name.clone()}</>}\n}\n\n#[function_component]\nfn App() -> Html {\n    let pre_made_props = props! {\n        Props {} // Notice we did not need to specify name prop\n    };\n    html! {<HelloWorld ..pre_made_props />}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Component in Yew with Rust\nDESCRIPTION: Implementation of the create method for a Yew component, which is called when a component is first created and receives properties from its parent component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Component, Context, html, Html, Properties};\n\n#[derive(PartialEq, Properties)]\npub struct Props;\n\npub struct MyComponent;\n\nimpl Component for MyComponent {\n    type Message = ();\n    type Properties = Props;\n\n    // highlight-start\n    fn create(ctx: &Context<Self>) -> Self {\n        MyComponent\n    }\n    // highlight-end\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            // impl\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using #[prop_or_else(function)] Attribute in Yew\nDESCRIPTION: Demonstrates the use of #[prop_or_else(function)] attribute to set a default value for a prop by calling a function when no explicit value is provided.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/function-components/properties.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nfn create_default_name() -> AttrValue {\n    AttrValue::Static(\"Bob\")\n}\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    #[prop_or_default]\n    pub is_loading: bool,\n    #[prop_or_else(create_default_name)]\n    pub name: AttrValue,\n}\n\n#[function_component]\nfn Hello(&Props { is_loading, ref name }: &Props) -> Html {\n    if is_loading {\n        html! { \"Loading\" }\n    } else {\n        html! { <>{{\"Hello \"}}{{name}}</> }\n    }\n}\n\n// Then use like this with default\n#[function_component]\nfn Case1() -> Html {\n    html! { <Hello /> }\n}\n// Or no override the default\n#[function_component]\nfn Case2() -> Html {\n    html! { <Hello name=\"Sam\" /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating App Component to Use VideosList in Yew\nDESCRIPTION: This code updates the `App` component to use the `VideosList` component. It replaces the previous inline rendering of the video list with the new `VideosList` component, passing the `videos` data as props. The `{4-7,13-14}` annotations are not included in the code.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\n#[function_component(App)]\nfn app() -> Html {\n    // ...\n\n    html! {\n        <>\n            <h1>{ \"RustConf Explorer\" }</h1>\n            <div>\n                <h3>{\"Videos to watch\"}</h3>\n                <VideosList videos={videos} />\n            </div>\n            // ...\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Navigation Buttons with Multiple Navigators\nDESCRIPTION: Shows how to implement multiple navigation buttons for different routes by cloning the navigator object, allowing it to be moved into multiple callbacks.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/router.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew_router::prelude::*;\n\n#[function_component(NavItems)]\npub fn nav_items() -> Html {\n    let navigator = use_navigator().unwrap();\n\n    let go_home_button = {\n        let navigator = navigator.clone();\n        let onclick = Callback::from(move |_| navigator.push(&Route::Home));\n        html! {\n            <button {onclick}>{\"click to go home\"}</button>\n        }\n    };\n\n    let go_to_first_post_button = {\n        let navigator = navigator.clone();\n        let onclick = Callback::from(move |_| navigator.push(&Route::Post { id: \"first-post\".to_string() }));\n        html! {\n            <button {onclick}>{\"click to go the first post\"}</button>\n        }\n    };\n\n    let go_to_secure_button = {\n        let onclick = Callback::from(move |_| navigator.push(&Route::Secure));\n        html! {\n            <button {onclick}>{\"click to go to secure\"}</button>\n        }\n    };\n\n    html! {\n        <>\n            {go_home_button}\n            {go_to_first_post_button}\n            {go_to_secure_button}\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Typed Children with ChildrenWithProps in Yew\nDESCRIPTION: This snippet demonstrates how to enforce that a component's children are of a specific type, using `ChildrenWithProps<T>`. It defines an `Item` component and a `List` component that only accepts `Item` components as children.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/children.mdx#2025-04-16_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nuse yew::{html, ChildrenWithProps, Component, Context, Html, Properties};\n\npub struct Item;\n\nimpl Component for Item {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"item\" }\n        }\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: ChildrenWithProps<Item>,\n}\n\npub struct List;\n\nimpl Component for List {\n    type Message = ();\n    type Properties = ListProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"list\">\n                { for ctx.props().children.iter() }\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Conditional Rendering with if in Yew\nDESCRIPTION: Demonstrates the simplest form of conditional rendering in Yew using an if statement within the html! macro. This pattern allows rendering content only when a condition is true.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/conditional-rendering.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    if true {\n        <p>{ \"True case\" }</p>\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Creating SVG Elements in Yew\nDESCRIPTION: Shows how to create SVG elements within Yew's html! macro, including paths, circles, and filters.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.20/concepts/html/elements.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n    <svg width=\"149\" height=\"147\" viewBox=\"0 0 149 147\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n        <path d=\"M60.5776 13.8268L51.8673 42.6431L77.7475 37.331L60.5776 13.8268Z\" fill=\"#DEB819\"/>\n        <path d=\"M108.361 94.9937L138.708 90.686L115.342 69.8642\" stroke=\"black\" stroke-width=\"4\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        <g filter=\"url(#filter0_d)\">\n            <circle cx=\"75.3326\" cy=\"73.4918\" r=\"55\" fill=\"#FDD630\"/>\n            <circle cx=\"75.3326\" cy=\"73.4918\" r=\"52.5\" stroke=\"black\" stroke-width=\"5\"/>\n        </g>\n        <circle cx=\"71\" cy=\"99\" r=\"5\" fill=\"white\" fill-opacity=\"0.75\" stroke=\"black\" stroke-width=\"3\"/>\n        <defs>\n            <filter id=\"filter0_d\" x=\"16.3326\" y=\"18.4918\" width=\"118\" height=\"118\" filterUnits=\"userSpaceOnUse\" color-interpolation-filters=\"sRGB\">\n                <feGaussianBlur stdDeviation=\"2\"/>\n                <feColorMatrix in=\"SourceAlpha\" type=\"matrix\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\"/>\n            </filter>\n        </defs>\n    </svg>\n}\n```\n\n----------------------------------------\n\nTITLE: Mouse Position Tracking in JavaScript\nDESCRIPTION: A JavaScript implementation of tracking mouse position within an element by capturing mousemove events and calculating the relative position using getBoundingClientRect.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\ndocument.getElementById('mousemoveme').onmousemove = (e) => {\n    // e = Mouse event.\n    var rect = e.target.getBoundingClientRect()\n    var x = e.clientX - rect.left //x position within the element.\n    var y = e.clientY - rect.top //y position within the element.\n    console.log('Left? : ' + x + ' ; Top? : ' + y + '.')\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Input Change Events with JsCast in Yew\nDESCRIPTION: Demonstrates two approaches (cautious and dangerous) for handling input change events and accessing the typed event target using JsCast in a Yew function component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/events.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::JsCast;\nuse web_sys::{EventTarget, HtmlInputElement};\nuse yew::prelude::*;\n\n#[function_component]\nfn MyComponent() -> Html {\n    let input_value_handle = use_state(String::default);\n    let input_value = (*input_value_handle).clone();\n\n    let on_cautious_change = {\n        let input_value_handle = input_value_handle.clone();\n\n        Callback::from(move |e: Event| {\n            let target: Option<EventTarget> = e.target();\n            let input = target.and_then(|t| t.dyn_into::<HtmlInputElement>().ok());\n\n            if let Some(input) = input {\n                input_value_handle.set(input.value());\n            }\n        })\n    };\n\n    let on_dangerous_change = Callback::from(move |e: Event| {\n        let target: EventTarget = e\n            .target()\n            .expect(\"Event should have a target when dispatched\");\n        input_value_handle.set(target.unchecked_into::<HtmlInputElement>().value());\n    });\n\n    html! {\n        <>\n            <label for=\"cautious-input\">\n                { \"My cautious input:\" }\n                <input onchange={on_cautious_change}\n                    id=\"cautious-input\"\n                    type=\"text\"\n                    value={input_value.clone()}\n                />\n            </label>\n            <label for=\"dangerous-input\">\n                { \"My dangerous input:\" }\n                <input onchange={on_dangerous_change}\n                    id=\"dangerous-input\"\n                    type=\"text\"\n                    value={input_value}\n                />\n            </label>\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Optional Typed Child in Yew\nDESCRIPTION: This snippet demonstrates how to create a Page component that optionally accepts a PageSideBar child component. It uses Option<VChild<PageSideBar>> to represent the optional child.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/children.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::\n    html, html_nested, virtual_dom::VChild, Component,\n    Context, Html, Properties\n};\n\npub struct PageSideBar;\n\nimpl Component for PageSideBar {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"sidebar\" }\n        }\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct PageProps {\n    #[prop_or_default]\n    pub sidebar: Option<VChild<PageSideBar>>,\n}\n\nstruct Page;\n\nimpl Component for Page {\n    type Message = ();\n    type Properties = PageProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"page\">\n                { ctx.props().sidebar.clone().map(Html::from).unwrap_or_default() }\n                // ... page content\n            </div>\n        }\n    }\n}\n\npub fn render_page(with_sidebar: bool) -> Html {\n    if with_sidebar {\n        // Page with sidebar\n        html! {\n            <Page sidebar={html_nested! {\n                <PageSideBar />\n            }} />\n        }\n    } else {\n        // Page without sidebar\n        html! {\n            <Page />\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Redirect in Yew Router (Rust)\nDESCRIPTION: Demonstrates how to use the <Redirect /> component from yew-router to redirect users based on certain conditions. This example shows redirecting to a login page when a user is not found.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/router.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[function_component(SomePage)]\nfn some_page() -> Html {\n    // made-up hook `use_user`\n    let user = match use_user() {\n        Some(user) => user,\n        // Redirects to the login page when user is `None`.\n        None => return html! {\n            <Redirect<Route> to={Route::Login}/>\n        },\n    };\n    // ... actual page content.\n}\n```\n\n----------------------------------------\n\nTITLE: Using Callbacks for DOM Events in Yew\nDESCRIPTION: Shows how to create a callback for handling a DOM event (button click) in a Yew component. The callback is attached to a button's onclick event and logs a message when triggered.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/function-components/callbacks.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties, Callback};\n\n#[function_component]\nfn App() -> Html {\n    let onclick = Callback::from(move |_| {\n        let greeting = String::from(\"Hi there\");\n        // web_sys::console::log_1(&greeting.into()); // if uncommented will print\n    });\n\n    html! {\n        <button {onclick}>{ \"Click\" }</button>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering HTML with Yew View\nDESCRIPTION: This snippet showcases the `view` lifecycle method in Yew, responsible for rendering the component's HTML output. The `html!` macro provides a JSX-like syntax for declaring HTML elements and attaching attributes and event listeners. The example demonstrates binding an `onclick` event to a button and rendering text using properties.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```rust\nuse yew::{Component, Context, html, Html, Properties};\n\nenum Msg {\n    Click,\n}\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    button_text: String,\n}\n\nstruct MyComponent;\n\nimpl Component for MyComponent {\n    type Message = Msg;\n    type Properties = Props;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    // highlight-start\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let onclick = ctx.link().callback(|_| Msg::Click);\n        html! {\n            <button {onclick}>{ &ctx.props().button_text }</button>\n        }\n    }\n    // highlight-end\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Rendering Components Based on Route\nDESCRIPTION: In this snippet, a switch function is defined to render different components based on the matched route. 'Secure' component showcases how to navigate programmatically using the history API.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/router.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[function_component(Secure)]\nfn secure() -> Html {\n    let history = use_history().unwrap();\n\n    let onclick = Callback::once(move |_| history.push(Route::Home));\n    html! {\n        <div>\n            <h1>{ \"Secure\" }</h1>\n            <button {onclick}>{ \"Go Home\" }</button>\n        </div>\n    }\n}\n\nfn switch(routes: &Route) -> Html {\n    match routes {\n        Route::Home => html! { <h1>{ \"Home\" }</h1> },\n        Route::Secure => html! {\n            <Secure />\n        },\n        Route::NotFound => html! { <h1>{ \"404\" }</h1> },\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating App Component to Fetch Video Data from API (Yew/Rust)\nDESCRIPTION: This snippet modifies the `App` component to fetch video data from an external API using `gloo-net`. It uses `use_state` to store the fetched videos and `use_effect_with` to trigger the data fetching on component mount.  The `wasm_bindgen_futures::spawn_local` function is used to spawn an asynchronous task that fetches the data and updates the component's state.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n+ use gloo_net::http::Request;\n\n#[function_component(App)]\nfn app() -> Html {\n-    let videos = vec![\n-        // ...\n-    ]\n+    let videos = use_state(|| vec![]);\n+    {\n+        let videos = videos.clone();\n+        use_effect_with((), move |_| {\n+            let videos = videos.clone();\n+            wasm_bindgen_futures::spawn_local(async move {\n+                let fetched_videos: Vec<Video> = Request::get(\"https://yew.rs/tutorial/data.json\")\n+                    .send()\n+                    .await\n+                    .unwrap()\n+                    .json()\n+                    .await\n+                    .unwrap();\n+                videos.set(fetched_videos);\n+            });\n+            || ()\n+        });\n+    }\n\n    // ...\n\n    html! {\n        <>\n            <h1>{ \"RustConf Explorer\" }</h1>\n            <div>\n                <h3>{\"Videos to watch\"}</h3>\n-                <VideosList videos={videos} on_click={on_video_select.clone()} />\n+                <VideosList videos={(*videos).clone()} on_click={on_video_select.clone()} />\n            </div>\n            { for details }\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Nested Children Props in Yew\nDESCRIPTION: This snippet demonstrates how to access and modify the properties of nested children components. It uses a function component to create a List that modifies the value prop of its ListItem children.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/children.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::rc::Rc;\nuse yew::prelude::*;\n\n#[derive(Clone, PartialEq, Properties)]\npub struct ListItemProps {\n    value: String,\n}\n\n#[function_component]\nfn ListItem(props: &ListItemProps) -> Html {\n    let ListItemProps { value } = props.clone();\n    html! {\n        <span>\n            {value}\n        </span>\n    }\n}\n\n#[derive(PartialEq, Properties)]\npub struct Props {\n    pub children: ChildrenWithProps<ListItem>,\n}\n\n#[function_component]\nfn List(props: &Props) -> Html {\n    let modified_children = props.children.iter().map(|mut item| {\n            let mut props = Rc::make_mut(&mut item.props);\n            props.value = format!(\"item-{}\", props.value);\n            item\n    });\n    html! { for modified_children }\n}\n\nhtml! {\n    <List>\n        <ListItem value=\"a\" />\n        <ListItem value=\"b\" />\n        <ListItem value=\"c\" />\n    </List>\n};\n```\n\n----------------------------------------\n\nTITLE: Using classes! Macro with Literal in Yew (Rust)\nDESCRIPTION: Demonstrates how to use the classes! macro with a literal string to set the class attribute of a div element in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(\"container\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Rendering Lists Using 'for' Keyword in Yew\nDESCRIPTION: This snippet shows the alternative syntax for rendering lists in Yew using the special 'for' keyword in the HTML macro. This approach is specific to Yew's HTML macro and generates the necessary code to display all items from an iterator.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/lists.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet items = (1..=10).collect::<Vec<_>>();\n\nhtml! {\n    <ul class=\"item-list\">\n        { for items.iter() }\n    </ul>\n};\n```\n\n----------------------------------------\n\nTITLE: Using TargetCast with Input Elements in Yew\nDESCRIPTION: This code snippet demonstrates how to use the TargetCast trait to manage input element changes in a Yew functional component. The cautious change handler uses a safe method to cast the event target, while the dangerous change handler uses unchecked casting, which requires prior knowledge of the target's type.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/events.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::prelude::*;\n\n#[function_component]\nfn MyComponent() -> Html {\n    let input_value_handle = use_state(String::default);\n    let input_value = (*input_value_handle).clone();\n\n    let on_cautious_change = {\n        let input_value_handle = input_value_handle.clone();\n\n        Callback::from(move |e: Event| {\n            let input = e.target_dyn_into::<HtmlInputElement>();\n\n            if let Some(input) = input {\n                input_value_handle.set(input.value());\n            }\n        })\n    };\n\n    let on_dangerous_change = Callback::from(move |e: Event| {\n        // You must KNOW target is a HtmlInputElement, otherwise\n        // the call to value would be Undefined Behaviour (UB).\n        //highlight-next-line\n        input_value_handle.set(e.target_unchecked_into::<HtmlInputElement>().value());\n    });\n\n    html! {\n        <> \n            <label for=\"cautious-input\">\n                { \"My cautious input:\" }\n                <input onchange={on_cautious_change}\n                    id=\"cautious-input\"\n                    type=\"text\"\n                    value={input_value.clone()}\n                />\n            </label>\n            <label for=\"dangerous-input\">\n                { \"My dangerous input:\" }\n                <input onchange={on_dangerous_change}\n                    id=\"dangerous-input\"\n                    type=\"text\"\n                    value={input_value}\n                />\n            </label>\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering HTML with Literals in Yew using Rust\nDESCRIPTION: Demonstrates how to insert literals into HTML by using `{}` blocks within Yew, where the expressions resolve to types implementing `Display`. Prerequisites include the `yew` crate. This snippet uses literal strings and integers to show content within HTML tags.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nlet text = \"lorem ipsum\";\nhtml!{\n    <>\n        <div>{text}</div>\n        <div>{\"dolor sit\"}</div>\n        <span>{42}</span>\n    </>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Navigation with Link Component\nDESCRIPTION: This example demonstrates the use of the `<Link/>` component to navigate within the application, showing how to pass route information and render nested components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/router.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n<Link<Route> to={Route::Home}>{ \"click here to go home\" }</Link<Route>>\n\n<Link<Route> to={Route::Post { id: \"new-yew-release\".to_string() }}>{ \"Yew v0.19 out now!\" }</Link<Route>>\n```\n\n----------------------------------------\n\nTITLE: Basic Yew Component with Click Callback\nDESCRIPTION: Demonstrates implementing a basic click callback in a Yew component. The callback is created using ctx.link().callback() and attached to a button element to handle click events.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/advanced-topics/struct-components/callbacks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html};\n\nenum Msg {\n    Clicked,\n}\n\nstruct Comp;\n\nimpl Component for Comp {\n\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let onclick = ctx.link().callback(|_| Msg::Clicked);\n        html! {\n            <button {onclick}>{ \"Click\" }</button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Pure Function Component in Yew\nDESCRIPTION: Demonstrates a pure function component implementation where the HTML output is deterministically derived from props. The component takes a boolean loading prop and renders different content based on its value.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/function-components/pure-components.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Properties, function_component, Html, html};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub is_loading: bool,\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n    if props.is_loading {\n        html! { \"Loading\" }\n    } else {\n        html! { \"Hello world\" }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic HTML Tag Structure in Yew\nDESCRIPTION: Demonstrates the basic open-close tag structure using the `html!` macro in Yew for a div element with an ID attribute.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n  <div id=\"my_div\"></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Nested Children with Props in Yew\nDESCRIPTION: This code shows how to access and modify properties of nested children components. The `List` component receives `ListItem` components as children, and it modifies the `value` prop of each `ListItem` before rendering them.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/children.mdx#2025-04-16_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::rc::Rc;\nuse yew::prelude::*;\n\n#[derive(Clone, PartialEq, Properties)]\npub struct ListItemProps {\n    value: String,\n}\n\n#[function_component]\nfn ListItem(props: &ListItemProps) -> Html {\n    let ListItemProps { value } = props.clone();\n    html! {\n        <span>\n            {value}\n        </span>\n    }\n}\n\n#[derive(PartialEq, Properties)]\npub struct Props {\n    pub children: ChildrenWithProps<ListItem>,\n}\n\n#[function_component]\nfn List(props: &Props) -> Html {\n    let modified_children = props.children.iter().map(|mut item| {\n            let mut props = Rc::make_mut(&mut item.props);\n            props.value = format!(\"item-{}\", props.value);\n            item\n    });\n    html! { for modified_children }\n}\n\nhtml! {\n    <List>\n        <ListItem value=\"a\" />\n        <ListItem value=\"b\" />\n        <ListItem value=\"c\" />\n    </List>\n};\n```\n\n----------------------------------------\n\nTITLE: Rendering with If-Let Expression in Yew (Rust)\nDESCRIPTION: Shows how to use an if-let expression for conditional rendering in Yew. This example renders a paragraph element if the Option contains a value.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/conditional-rendering.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nlet some_text = Some(\"text\");\n\nhtml! {\n    if let Some(text) = some_text {\n        <p>{ text }</p>\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Container Component Implementation in Yew\nDESCRIPTION: Implements a `Container` component that accepts an ID and children. The component renders a div with the specified ID and renders its children inside the div.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/components.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Children, Component, Html, Properties};\n\n#[derive(Properties, Clone)]\npub struct Props {\n    pub id: String,\n    pub children: Children,\n}\n\npub struct Container(Props);\nimpl Component for Container {\n    type Properties = Props;\n\n    // ...\n\n    fn view(&self) -> Html {\n       html! {\n           <div id=self.0.id.clone()>\n               { self.0.children.clone() }\n           </div>\n       }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Routes with Enum in Yew Router\nDESCRIPTION: This snippet demonstrates how to define routes in a Yew application using an enum that derives Routable. Routes must implement Clone and PartialEq, with associated paths defined using attributes.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/router.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew_router::prelude::*;\n\n#[derive(Clone, Routable, PartialEq)]\nenum Route {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/secure\")]\n    Secure,\n    #[not_found]\n    #[at(\"/404\")]\n    NotFound,\n}\n```\n\n----------------------------------------\n\nTITLE: Event Handling with JsCast in Web Applications\nDESCRIPTION: This snippet demonstrates how to use the JsCast trait to safely convert JavaScript event targets to specific HTML element types. It shows both checked casting with dyn_ref and unchecked casting with unchecked_into.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/basic-web-technologies/wasm-bindgen.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// need to import the trait.\nuse wasm_bindgen::JsCast;\nuse web_sys::{Event, EventTarget, HtmlInputElement, HtmlSelectElement};\n\nfn handle_event(event: Event) {\n    let target: EventTarget = event\n        .target()\n        .expect(\"I'm sure this event has a target!\");\n\n    // maybe the target is a select element?\n    if let Some(select_element) = target.dyn_ref::<HtmlSelectElement>() {\n        // do something amazing here\n        return;\n    }\n\n    // if it wasn't a select element then I KNOW it's a input element!\n    let input_element: HtmlInputElement = target.unchecked_into();\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Emitting a Callback in Rust with Yew\nDESCRIPTION: Demonstrates how to create a callback using Yew's Callback type and emit a value. The callback takes a String input and returns a formatted String output.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/function-components/callbacks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html, Callback};\n\nlet cb: Callback<String, String> = Callback::from(move |name: String| {\n    format!(\"Bye {}\", name)\n});\n\nlet result = cb.emit(String::from(\"Bob\")); // call the callback\n// web_sys::console::log_1(&result.into()); // if uncommented will print \"Bye Bob\"\n```\n\n----------------------------------------\n\nTITLE: Yew Mouse Movement Implementation\nDESCRIPTION: Implementation of mouse movement tracking using Yew framework and web-sys.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{console, HtmlElement, MouseEvent};\nuse yew::{\n    html,\n    Callback, TargetCast,\n};\n\nlet onmousemove = Callback::from(|e: MouseEvent| {\n    if let Some(target) = e.target_dyn_into::<HtmlElement>() {\n        let rect = target.get_bounding_client_rect();\n        let x = (e.client_x() as f64) - rect.left();\n        let y = (e.client_y() as f64) - rect.top();\n        console::log_1(&format!(\"Left? : {} ; Top? : {}\", x, y).into());\n    }\n});\n\nhtml! {\n    <div id=\"mousemoveme\" {onmousemove}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Collecting Iterators to HTML - Syntax 1\nDESCRIPTION: Demonstrates converting an iterator to HTML using collect method in Yew framework\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/lists.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Html};\n\nlet items = (1..=10).collect::<Vec<_>>();\n\nhtml! {\n    <ul class=\"item-list\">\n        { items.iter().collect::<Html>() }\n    </ul>\n};\n```\n\n----------------------------------------\n\nTITLE: Using Vector of Classes with classes! Macro in Yew\nDESCRIPTION: Demonstrates how to use a vector of string literals with the classes! macro to set multiple classes on an HTML element in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/classes.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(vec![\"class-1\", \"class-2\"])}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using NodeRef to Access DOM Elements in Yew (Rust)\nDESCRIPTION: This code demonstrates the complete workflow for using refs in Yew: creating a NodeRef, attaching it to a DOM element in the view function, and then accessing the element's properties. The example shows how to check if an element has attributes.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.18.0/concepts/components/refs.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// 建立\nself.node_ref = NodeRef::default();\n\n// 在 view 裡\nhtml! {\n    <div ref=self.node_ref.clone()></div>\n}\n\n// 更新\nlet has_attributes = self.node_ref.cast::<Element>().unwrap().has_attributes();\n```\n\n----------------------------------------\n\nTITLE: Using Callback for Button Click Event in Yew\nDESCRIPTION: This Rust code snippet demonstrates how to define an event listener for a button click event in a Yew application using the 'html' macro and 'Callback'. The 'onclick' event listener is specified within the button element to trigger a callback with no operation. This snippet requires Yew and assumes an understanding of the 'html' macro usage in creating Yew components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/events.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Callback};\n\nhtml! {\n    <button onclick={Callback::from(|_| ())}>\n    //      ^^^^^^^ event listener name\n        { \"Click me!\" }\n    </button>\n};\n```\n\n----------------------------------------\n\nTITLE: SVG Rendering in Yew\nDESCRIPTION: Shows how to create SVG elements with complex paths and filters using the html! macro\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/introduction.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <svg width=\"149\" height=\"147\" viewBox=\"0 0 149 147\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n        <path d=\"M60.5776 13.8268L51.8673 42.6431L77.7475 37.331L60.5776 13.8268Z\" fill=\"#DEB819\"/>\n        <path d=\"M108.361 94.9937L138.708 90.686L115.342 69.8642\" stroke=\"black\" stroke-width=\"4\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        <g filter=\"url(#filter0_d)\">\n            <circle cx=\"75.3326\" cy=\"73.4918\" r=\"55\" fill=\"#FDD630\"/>\n            <circle cx=\"75.3326\" cy=\"73.4918\" r=\"52.5\" stroke=\"black\" stroke-width=\"5\"/>\n        </g>\n        <circle cx=\"71\" cy=\"99\" r=\"5\" fill=\"white\" fill-opacity=\"0.75\" stroke=\"black\" stroke-width=\"3\"/>\n        <defs>\n            <filter id=\"filter0_d\" x=\"16.3326\" y=\"18.4918\" width=\"118\" height=\"118\" filterUnits=\"userSpaceOnUse\" color-interpolation-filters=\"sRGB\">\n                <@{\"feGaussianBlur\"} stdDeviation=\"2\"/>\n                <@{\"feColorMatrix\"} in=\"SourceAlpha\" type=\"matrix\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\"/>\n            </filter>\n        </defs>\n    </svg>\n};\n```\n\n----------------------------------------\n\nTITLE: Rendering in a Yew Component\nDESCRIPTION: This snippet shows how to implement the `view` method for rendering the component in Yew. It leverages the `html!` macro for cleanly defining HTML structures.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Component, Context, html, Html, Properties};\n\nenum Msg {\n    Click,\n}\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    button_text: String,\n}\n\nstruct MyComponent;\n\nimpl Component for MyComponent {\n    type Message = Msg;\n    type Properties = Props;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    // highlight-start\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let onclick = ctx.link().callback(|_| Msg::Click);\n        html! {\n            <button {onclick}>{ &ctx.props().button_text }</button>\n        }\n    }\n    // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Yew Component Rendered Callback\nDESCRIPTION: This code snippet demonstrates the `rendered` lifecycle method, which is called after the component has been rendered to the DOM. It uses a `NodeRef` to access a DOM element and focus it. It checks `first_render` to ensure the focus is only set on the initial render.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::{\n    Component, Context, html, Html, NodeRef,\n};\n\npub struct MyComponent {\n    node_ref: NodeRef,\n}\n\nimpl Component for MyComponent {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            node_ref: NodeRef::default(),\n        }\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <input ref={self.node_ref.clone()} type=\"text\" />\n        }\n    }\n\n    // highlight-start\n    fn rendered(&mut self, _ctx: &Context<Self>, first_render: bool) {\n        if first_render {\n            if let Some(input) = self.node_ref.cast::<HtmlInputElement>() {\n                input.focus();\n            }\n        }\n    }\n    // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Updating a Yew Component Based on Messages\nDESCRIPTION: This snippet shows how to implement the `update` method in a Yew component, allowing the component to respond to messages and decide when to re-render.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Component, Context, html, Html};\n// highlight-start\npub enum Msg {\n    SetInputEnabled(bool)\n}\n// highlight-end\n\nstruct MyComponent {\n    input_enabled: bool,\n}\n\nimpl Component for MyComponent {\n    // highlight-next-line\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            input_enabled: false,\n        }\n    }\n\n    // highlight-start\n    fn update(&mut self, _ctx: &Context<Self>, msg: Self::Message) -> bool {\n        match msg {\n            Msg::SetInputEnabled(enabled) => {\n                if self.input_enabled != enabled {\n                    self.input_enabled = enabled;\n                    true // Re-render\n                } else {\n                    false\n                }\n            }\n        }\n    }\n    // highlight-end\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            // impl\n        }\n    }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering with if let - Rust\nDESCRIPTION: Illustrates the use of `if let` for conditional rendering in Yew, presenting an element based on pattern matching, specifically with option types.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/introduction.mdx#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\\nlet some_text = Some(\\\"text\\\");\\n\\nhtml! {\\n    if let Some(text) = some_text {\\n        <p>{ text }</p>\\n    }\\n};\n```\n\n----------------------------------------\n\nTITLE: Updating Component State with Messages in Yew\nDESCRIPTION: This snippet shows how to update a Yew component's state using messages within the `update` lifecycle method. Messages are defined as an enum, and the `update` method handles different message types, updating the component's state accordingly. The method returns a boolean value indicating whether the component should be re-rendered after the update.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n```rust\nuse yew::{Component, Context, html, Html};\n\n// highlight-start\npub enum Msg {\n    SetInputEnabled(bool)\n}\n// highlight-end\n\nstruct MyComponent {\n    input_enabled: bool,\n}\n\nimpl Component for MyComponent {\n    // highlight-next-line\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            input_enabled: false,\n        }\n    }\n\n    // highlight-start\n    fn update(&mut self, _ctx: &Context<Self>, msg: Self::Message) -> bool {\n        match msg {\n            Msg::SetInputEnabled(enabled) => {\n                if self.input_enabled != enabled {\n                    self.input_enabled = enabled;\n                    true // 重新渲染\n                } else {\n                    false\n                }\n            }\n        }\n    }\n    // highlight-end\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            // 具体实现\n        }\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Creating an Event Listener Hook in Yew - Rust\nDESCRIPTION: This snippet demonstrates how to create a custom hook that listens for storage changes on the window object. It uses Yew's function component system and the Gloo event listener API. The state reflects whether a storage event has been fired, which is displayed in the rendered HTML.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse gloo::events::EventListener;\nuse gloo::utils::window;\nuse std::mem::drop;\n\n\n#[function_component(ShowStorageChanged)]\npub fn show_storage_changed() -> Html {\n    let state_storage_changed = use_state(|| false);\n\n    {\n        let state_storage_changed = state_storage_changed.clone();\n        use_effect(|| {\n            let listener = EventListener::new(&window(), \"storage\", move |_| state_storage_changed.set(true));\n\n            move || { drop(listener); }\n        });\n    }\n\n    html! { <div>{\"Storage Event Fired: \"}{*state_storage_changed}</div> }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Callbacks in Yew\nDESCRIPTION: Demonstrates how to create callbacks that send messages to a component. The example shows creating a callback that accepts text and converts it to a message, as well as a simplified version using type inference.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/components/callbacks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Create a callback that accepts some text and sends it to the component as the `Msg::Text` message variant.\nlet cb = link.callback(|text: String| Msg::Text(text));\n\n// The previous line is needlessly verbose to make it clearer.\n// It can be simplified it to this:\nlet cb = link.callback(Msg::Text);\n\n// Will send `Msg::Text(\"Hello World!\")` to the component.\ncb.emit(\"Hello World!\".to_owned());\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for Optimized Release Builds in Rust\nDESCRIPTION: This snippet shows how to configure the release profile in Cargo.toml to optimize for smaller binary sizes. It includes settings for panic behavior, code generation units, optimization level, and link-time optimization.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/optimizations.mdx#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[profile.release]\n# less code to include into binary\npanic = 'abort'\n# optimization over all codebase ( better optimization, slower build )\ncodegen-units = 1\n# optimization for size ( more aggressive )\nopt-level = 'z'\n# optimization for size\n# opt-level = 's'\n# link time optimization using using whole-program analysis\nlto = true\n```\n\n----------------------------------------\n\nTITLE: Basic HTML Creation with html! Macro\nDESCRIPTION: Demonstrates creating a basic HTML image element using Yew's html! macro. Shows how to specify standard HTML attributes in Rust.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/basic-web-technologies/html.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet my_header: Html = html! {\n    <img src=\"img_girl.jpg\" alt=\"Girl in a jacket\" width=\"500\" height=\"600\" />\n};\n```\n\n----------------------------------------\n\nTITLE: Context Usage in Yew Function Components\nDESCRIPTION: Shows a complete example of context usage in Yew, including creating a theme context provider and consuming it in nested components using use_context hook. Demonstrates proper context propagation through the component tree.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/function-components/pre-defined-hooks.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{ContextProvider, function_component, html, use_context, use_state};\n\n\n/// App theme\n#[derive(Clone, Debug, PartialEq)]\nstruct Theme {\n    foreground: String,\n    background: String,\n}\n\n/// Main component\n#[function_component(App)]\npub fn app() -> Html {\n    let ctx = use_state(|| Theme {\n        foreground: \"#000000\".to_owned(),\n        background: \"#eeeeee\".to_owned(),\n    });\n\n    html! {\n        // `ctx` is type `Rc<UseStateHandle<Theme>>` while we need `Theme`\n        // so we deref it.\n        // It derefs to `&Theme`, hence the clone\n        <ContextProvider<Theme> context={(*ctx).clone()}>\n            // Every child here and their children will have access to this context.\n            <Toolbar />\n        </ContextProvider<Theme>>\n    }\n}\n\n/// The toolbar.\n/// This component has access to the context\n#[function_component(Toolbar)]\npub fn toolbar() -> Html {\n    html! {\n        <div>\n            <ThemedButton />\n        </div>\n    }\n}\n\n/// Button placed in `Toolbar`.\n/// As this component is a child of `ThemeContextProvider` in the component tree, it also has access to the context.\n#[function_component(ThemedButton)]\npub fn themed_button() -> Html {\n    let theme = use_context::<Theme>().expect(\"no ctx found\");\n\n    html! {\n        <button style={format!(\"background: {}; color: {};\", theme.background, theme.foreground)}>\n            { \"Click me!\" }\n        </button>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using JsCast for Type Conversion in DOM Event Handling\nDESCRIPTION: This example shows how to use the JsCast trait to convert between JavaScript types when handling DOM events. It demonstrates both checked (dyn_ref) and unchecked (unchecked_into) type conversions to convert an EventTarget into specific HTML element types.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/basic-web-technologies/wasm-bindgen.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// need to import the trait.\nuse wasm_bindgen::JsCast;\nuse web_sys::{Event, EventTarget, HtmlInputElement, HtmlSelectElement};\n\nfn handle_event(event: Event) {\n    let target: EventTarget = event\n        .target()\n        .expect(\"I'm sure this event has a target!\");\n\n    // maybe the target is a select element?\n    if let Some(select_element) = target.dyn_ref::<HtmlSelectElement>() {\n        // do something amazing here\n        return;\n    }\n\n    // if it wasn't a select element then I KNOW it's a input element!\n    let input_element: HtmlInputElement = target.unchecked_into();\n}\n```\n\n----------------------------------------\n\nTITLE: Creating DOM nodes with web-sys and Yew (Rust)\nDESCRIPTION: This snippet creates a DOM element using the web-sys library and returns it as an Html value using Yew's VRef. It showcases the use of the use_memo hook to ensure the DOM element is created only once.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/elements.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{Element, Node};\nuse yew::prelude::*;\nuse gloo::utils::document;\n\n#[function_component]\nfn MyComponent() -> Html {\n    // 带记忆能力的函数，只会执行一次\n    let node = use_memo(\n        (),\n        |_| {\n            // 从文档中创建一个 div 元素\n            let div: Element = document().create_element(\"div\").unwrap();\n            // 添加内容、类等\n            div.set_inner_html(\"Hello, World!\");\n            // 将 Element 转换为 Node\n            let node: Node = div.into();\n            // 将该 Node 作为 Html 值返回\n            Html::VRef(node)\n        },\n    );\n\n    // use_memo 返回的是 Rc 指针，所以我们需要解引用和克隆\n    (*node).clone()\n}\n```\n\n----------------------------------------\n\nTITLE: Using HTML Fragments in Yew\nDESCRIPTION: This snippet illustrates the use of HTML fragments within the `html!` macro to render multiple elements. It demonstrates the correct way to wrap multiple elements in a fragment to satisfy Yew's requirement of a single root node.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/basic-web-technologies/html.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\n// fixed: using HTML fragments\nhtml! {\n    <>\n        <div></div>\n        <p></p>\n    </>\n};\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Callbacks in Yew Components\nDESCRIPTION: Demonstrates how to create and use callbacks within a Yew component. The example shows creating a callback that sends a message to the component when executed, and how to simplify the callback creation syntax.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/struct-components/scope.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html};\n\nenum Msg {\n    Text(String),\n}\n\nstruct Comp;\n\nimpl Component for Comp {\n\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        // Create a callback that accepts some text and sends it\n        // to the component as the `Msg::Text` message variant.\n        let cb = ctx.link().callback(|text: String| Msg::Text(text));\n\n        // The previous line is needlessly verbose to make it clearer.\n        // It can be simplified it to this:\n        let cb = ctx.link().callback(Msg::Text);\n\n        // Will send `Msg::Text(\"Hello World!\")` to the component.\n        cb.emit(\"Hello World!\".to_owned());\n\n        html! {\n            // html here\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Event Callback in Yew Component\nDESCRIPTION: Demonstrates creating a simple callback for handling button click events in a Yew component. Uses `ctx.link().callback()` to transform mouse events into component messages.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/components/callbacks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html};\n\nenum Msg {\n    Clicked,\n}\n\nstruct Comp;\n\nimpl Component for Comp {\n\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let onclick = ctx.link().callback(|_| Msg::Clicked);\n        html! {\n            <button {onclick}>{ \"Click\" }</button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Properties Trait with Derive Macro in Rust\nDESCRIPTION: Demonstrates how to use Yew's derive macro to easily implement the Properties trait on a struct. The struct must also implement PartialEq for Yew to perform data comparison.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/function-components/properties.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::Properties;\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub is_loading: bool,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Navigation in Yew Function Components\nDESCRIPTION: This snippet demonstrates how to implement navigation in Yew function components using the Navigator API, including multiple navigation buttons.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/router.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew_router::prelude::*;\n\n#[function_component(NavItems)]\npub fn nav_items() -> Html {\n    let navigator = use_navigator().unwrap();\n\n    let go_home_button = {\n        let navigator = navigator.clone();\n        let onclick = Callback::from(move |_| navigator.push(&Route::Home));\n        html! {\n            <button {onclick}>{\"click to go home\"}</button>\n        }\n    };\n\n    let go_to_first_post_button = {\n        let navigator = navigator.clone();\n        let onclick = Callback::from(move |_| navigator.push(&Route::Post { id: \"first-post\".to_string() }));\n        html! {\n            <button {onclick}>{\"click to go the first post\"}</button>\n        }\n    };\n\n    let go_to_secure_button = {\n        let onclick = Callback::from(move |_| navigator.push(&Route::Secure));\n        html! {\n            <button {onclick}>{\"click to go to secure\"}</button>\n        }\n    };\n\n    html! {\n        <>\n            {go_home_button}\n            {go_to_first_post_button}\n            {go_to_secure_button}\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using classes! macro with literal values in Yew\nDESCRIPTION: This snippet shows how to use the `classes!` macro with a literal string to define the class attribute of a div element in Yew. It demonstrates a simple way to apply a single CSS class to an HTML element. It requires the `yew` crate.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/classes.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n    <div class={classes!(\"container\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using Optional Classes with classes! Macro in Yew\nDESCRIPTION: Shows how to conditionally apply a class using Option types with the classes! macro in Yew HTML templates.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/classes.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(Some(\"class\"))} />\n};\n```\n\n----------------------------------------\n\nTITLE: Creating and Initializing a Yew Component\nDESCRIPTION: Example of defining a component struct that stores props and ComponentLink for handling component state and callbacks.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/components/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Component, ComponentLink};\n\npub struct MyComponent {\n    props: Props,\n    link: ComponentLink<Self>,\n}\n\nimpl Component for MyComponent {\n    type Properties = Props;\n    // ...\n\n    fn create(props: Self::Properties, link: ComponentLink<Self>) -> Self {\n        MyComponent { props, link }\n    }\n\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Rendered Lifecycle Method in Yew\nDESCRIPTION: Implementation of the rendered method for a Yew component, which is called after the view has been rendered to the DOM but before browser refresh. It's useful for DOM operations that need to run after rendering.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew:{\n    Component, Context, html, Html, NodeRef,\n};\n\npub struct MyComponent {\n    node_ref: NodeRef,\n}\n\nimpl Component for MyComponent {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            node_ref: NodeRef::default(),\n        }\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <input ref={self.node_ref.clone()} type=\"text\" />\n        }\n    }\n\n    // highlight-start\n    fn rendered(&mut self, _ctx: &Context<Self>, first_render: bool) {\n        if first_render {\n            if let Some(input) = self.node_ref.cast::<HtmlInputElement>() {\n                input.focus();\n            }\n        }\n    }\n    // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Children Prop in Yew Components (Rust)\nDESCRIPTION: This snippet demonstrates how to use the 'Children' prop in Yew to pass and render nested HTML elements. It shows the implementation in both the parent App component and the child HelloWorld component. The Props struct includes a 'children' field of type Html, which is then rendered in the child component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/function-components/children.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties};\n\n#[function_component]\nfn App() -> Html {\n    html! {\n        <HelloWorld>\n            <span>{\"Hey what is up ;)\"}</span>\n            <h1>{\"THE SKY\"}</h1>\n        </HelloWorld>\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub children: Html, // the field name `children` is important!\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n    html! {\n        <div class=\"very-stylized-container\">\n            { props.children.clone() } // you can forward children like this\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Mouse Position Tracking using web-sys\nDESCRIPTION: A Rust implementation using web-sys to track mouse position within an element. Uses Closure to wrap the callback function and manually handles element type conversion with JsCast.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::{prelude::Closure, JsCast};\nuse web_sys::{console, Document, HtmlElement, MouseEvent};\n\nlet mousemove = Closure::<dyn Fn(MouseEvent)>::wrap(Box::new(|e| {\n    let rect = e\n        .target()\n        .expect(\"mouse event doesn't have a target\")\n        .dyn_into::<HtmlElement>()\n        .expect(\"event target should be of type HtmlElement\")\n        .get_bounding_client_rect();\n    let x = (e.client_x() as f64) - rect.left();\n    let y = (e.client_y() as f64) - rect.top();\n    console::log_1(&format!(\"Left? : {} ; Top? : {}\", x, y).into());\n}));\n\nDocument::new()\n    .expect(\"global document not set\")\n    .get_element_by_id(\"mousemoveme\")\n    .expect(\"element with id `mousemoveme` not present\")\n    .unchecked_into::<HtmlElement>()\n    .set_onmousemove(mousemove.as_ref().dyn_ref());\n\n// we now need to save the `mousemove` Closure so that when\n// this event fires the closure is still in memory.\n```\n\n----------------------------------------\n\nTITLE: Navigating Using History API in Function Components\nDESCRIPTION: This snippet shows how to use the history API within function components to navigate between routes based on user interactions. It incorporates the use of the `use_history` hook.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/router.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[function_component(MyComponent)]\npub fn my_component() -> Html {\n    let history = use_history().unwrap();\n    let onclick = Callback::once(move |_| history.push(Route::Home));\n\n    html! {\n        <>\n            <button {onclick}>{\"Click to go home\"}</button>\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Yew component that accepts classes (Rust)\nDESCRIPTION: Demonstrates how to create a Yew component that accepts classes as a prop and combines them with its own classes. It also shows how to handle conditional classes based on props.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/classes.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    #[prop_or_default]\n    class: Classes,\n    fill: bool,\n    children: Html,\n}\n\n#[function_component]\nfn MyComponent(props: &Props) -> Html {\n    let Props {\n        class,\n        fill,\n        children,\n    } = props;\n    html! {\n        <div\n            class={classes!(\n                \"my-container-class\",\n                fill.then(|| Some(\"my-fill-class\")),\n                class.clone(),\n            )}\n        >\n            { children.clone() }\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Themed Button Higher Order Component in Yew (Rust)\nDESCRIPTION: This Rust function component demonstrates how to create a Higher Order Component (HOC) that utilizes context for theming. It uses Yew's context provider to pass theme settings down to a nested button component, allowing for dynamic theming based on context.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/struct-components/hoc.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(Clone, Debug, PartialEq)]\nstruct Theme {\n    foreground: String,\n    background: String,\n}\n\n#[function_component]\npub fn App() -> Html {\n    let ctx = use_state(|| Theme {\n        foreground: \"#000000\".to_owned(),\n        background: \"#eeeeee\".to_owned(),\n    });\n\n    html! {\n        <ContextProvider<Theme> context={(*ctx).clone()}>\n            <ThemedButtonHOC />\n        </ContextProvider<Theme>>\n    }\n}\n\n// highlight-start\n#[function_component]\npub fn ThemedButtonHOC() -> Html {\n    let theme = use_context::<Theme>().expect(\"no ctx found\");\n\n    html! {<ThemedButtonStructComponent {theme} />}\n}\n// highlight-end\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub theme: Theme,\n}\n\nstruct ThemedButtonStructComponent;\n\nimpl Component for ThemedButtonStructComponent {\n    type Message = ();\n    type Properties = Props;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let theme = &ctx.props().theme;\n        html! {\n            <button style={format!(\n                    \"background: {}; color: {};\",\n                    theme.background,\n                    theme.foreground\n                )}\n            >\n                { \"Click me!\" }\n            </button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting Literals and Expressions in Yew HTML\nDESCRIPTION: Demonstrates how to insert text literals, variables, and numbers into Yew's HTML structure. All display text must be enclosed in curly braces as expressions.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet text = \"lorem ipsum\";\nhtml!{\n    <>\n        <div>{text}</div>\n        <div>{\"dolor sit\"}</div>\n        <span>{42}</span>\n    </>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Callback with batch_callback in Yew\nDESCRIPTION: Shows how to create a conditional callback using batch_callback that only triggers a component update when a specific condition is met. This example processes keyboard events and only submits when the Enter key is pressed.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/struct-components/callbacks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{events::KeyboardEvent, html, Component, Context, Html};\n\nenum Msg {\n    Submit,\n}\n\nstruct Comp;\n\nimpl Component for Comp {\n\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        // highlight-start\n        let onkeypress = ctx.link().batch_callback(|event: KeyboardEvent| {\n            if event.key() == \"Enter\" {\n                Some(Msg::Submit)\n            } else {\n                None\n            }\n        });\n\n        html! {\n            <input type=\"text\" {onkeypress} />\n        }\n        // highlight-end\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the View Method for Yew Component Rendering\nDESCRIPTION: Example of implementing the view method that renders the component to the DOM using the html! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/components/introduction.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Html};\n\nimpl Component for MyComponent {\n    // ...\n\n    fn view(&self) -> Html {\n        let onclick = self.link.callback(|_| Msg::Click);\n        html! {\n            <button onclick=onclick>{ self.props.button_text }</button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: HTML Macro Transformation\nDESCRIPTION: This snippet translates the raw HTML into a Yew `html!` macro. This macro enables a syntax similar to JSX to construct the user interface of the application. The expressions must be enclosed in curly braces `{}`, and HTML elements must be correctly closed.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n\"html! {\n    <>\n        <h1>{ \\\"RustConf Explorer\\\" }</h1>\n        <div>\n            <h3>{\\\"Videos to watch\\\"}</h3>\n            <p>{ \\\"John Doe: Building and breaking things\\\" }</p>\n            <p>{ \\\"Jane Smith: The development process\\\" }</p>\n            <p>{ \\\"Matt Miller: The Web 7.0\\\" }</p>\n            <p>{ \\\"Tom Jerry: Mouseless development\\\" }</p>\n        </div>\n        <div>\n            <h3>{ \\\"John Doe: Building and breaking things\\\" }</h3>\n            <img src=\\\"https://placehold.co/640x360.png?text=Video+Player+Placeholder\\\" alt=\\\"video thumbnail\\\" />\n        </div>\n    </>\n}\"\n```\n\n----------------------------------------\n\nTITLE: Initializing Yew Component with Properties and Link\nDESCRIPTION: Demonstrates how to create a Yew component by implementing the Component trait, storing props and component link in the struct\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.21/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub struct MyComponent {\n    props: Props,\n    link: ComponentLink<Self>,\n}\n\nimpl Component for MyComponent {\n    type Properties = Props;\n    // ...\n\n    fn create(props: Self::Properties, link: ComponentLink<Self>) -> Self {\n        MyComponent { props, link }\n    }\n\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Properties for a Link Component in Rust\nDESCRIPTION: Demonstrates how to define a Properties struct for a link component, including required and optional properties with default values and attributes.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.20/advanced-topics/struct-components/properties.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub struct LinkColor {\n    Blue,\n    Red,\n    Green,\n    Black,\n    Purple,\n}\n\nimpl Default for LinkColor {\n    fn default() -> Self {\n        // 除非另有说明，否则链接的颜色将为蓝色\n        LinkColor::Blue\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct LinkProps {\n    /// 链接必须有一个目标地址\n    href: String,\n    /// 如果链接文本很大，这将使得复制字符串开销更小\n    /// 除非有性能问题，否则通常不建议这么做\n    text: Rc<String>,\n    /// 链接的颜色\n    #[prop_or_default]\n    color: LinkColor,\n    /// 如果为 None，则 view 函数将不指定大小\n    #[prop_or_default]\n    size: Option<u32>\n    /// 当 view 函数没有指定 active，其默认为 true\n    #[prop_or_else(true)]\n    active: bool,\n}\n```\n\n----------------------------------------\n\nTITLE: Using Fragments in Yew's html! Macro (Rust)\nDESCRIPTION: This code snippet demonstrates the correct usage of fragments in Yew's html! macro. It shows how to use empty tags (<></>) to wrap multiple root elements, allowing for more flexible HTML structure creation.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/fragments.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <>\n        <div></div>\n        <p></p>\n    </>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Keyed Lists in Yew\nDESCRIPTION: Demonstrates how to implement keyed lists in Yew by adding unique keys to list items. Keys help optimize rendering performance when list items change or reorder.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/lists.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet names = vec![\"Sam\",\"Bob\",\"Ray\"]\n\nhtml! {\n    <div id=\"introductions\">\n        {\n            names.into_iter().map(|name| {\n                html!{<div key={name}>{ format!(\"Hello, I'am {}!\",name) }</div>}\n            }).collect::<Html>()\n        }\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Event Message Enum for Component Updates\nDESCRIPTION: Example of defining a message enum to handle input value changes in a Yew component, demonstrating type-safe event handling\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/events.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub enum Msg {\n    InputValue(String),\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Conditional Callback with batch_callback in Yew (Rust)\nDESCRIPTION: This example shows how to use batch_callback for conditional message sending based on keyboard events. It demonstrates handling an 'Enter' key press to trigger a submit action in a Yew component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/struct-components/callbacks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{events::KeyboardEvent, html, Component, Context, Html};\n\nenum Msg {\n    Submit,\n}\n\nstruct Comp;\n\nimpl Component for Comp {\n\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let onkeypress = ctx.link().batch_callback(|event: KeyboardEvent| {\n            if event.key() == \"Enter\" {\n                Some(Msg::Submit)\n            } else {\n                None\n            }\n        });\n\n        html! {\n            <input type=\"text\" {onkeypress} />\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Video Details Component in Yew\nDESCRIPTION: Creates a VideoDetails component that displays detailed information about a selected video, including a title and placeholder image.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/tutorial/index.mdx#2025-04-16_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nuse website_test::tutorial::Video;\nuse yew::prelude::*;\n\n#[derive(Properties, PartialEq)]\nstruct VideosDetailsProps {\n    video: Video,\n}\n\n#[function_component(VideoDetails)]\nfn video_details(VideosDetailsProps { video }: &VideosDetailsProps) -> Html {\n    html! {\n        <div>\n            <h3>{ video.title.clone() }</h3>\n            <img src=\"https://placehold.co/640x360.png?text=Video+Player+Placeholder\" alt=\"video thumbnail\" />\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Proper Tag Structure in Yew\nDESCRIPTION: Examples of correct and incorrect tag structures for HTML elements in Yew. Shows self-closing tags and paired opening/closing tags.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.18.0/concepts/html/elements.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n  <div id=\"my_div\"></div>\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n  <div id=\"my_div\"> // <- 缺少闭合标签\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n  <input id=\"my_input\" />\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n  <input id=\"my_input\"> // <- 没有自闭合\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering with Yew ServerRenderer in Rust\nDESCRIPTION: Demonstrates the use of the ServerRenderer to perform server-side rendering of a Yew component in Rust. Prerequisites include having Yew and Tokio's async runtime set up. The code creates a new ServerRenderer for a simple Yew application component and renders it, printing the result. Expected input is a Yew component; output is the rendered HTML as a string.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/server-side-rendering.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\\nuse yew::ServerRenderer;\\n\\n#[function_component]\\nfn App() -> Html {\\n    html! {<div>{\"Hello, World!\"}</div>}\\n}\\n\\n// we use `flavor = \"current_thread\"` so this snippet can be tested in CI,\\n// where tests are run in a WASM environment. You likely want to use\\n// the (default) `multi_thread` favor as:\\n// #[tokio::main]\\n#[tokio::main(flavor = \"current_thread\")]\\nasync fn no_main() {\\n    let renderer = ServerRenderer::<App>::new();\\n\\n    let rendered = renderer.render().await;\\n\\n    // Prints: <div>Hello, World!</div>\\n    println!(\"{}\", rendered);\\n}\n```\n\n----------------------------------------\n\nTITLE: HTML Macro Expansion in Rust\nDESCRIPTION: Demonstrates how the html! macro transforms declarative HTML-like syntax into valid Rust code, providing a more readable and maintainable approach to UI development\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/how-it-works.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Example of html! macro usage\nhtml! {\n    <div>\n        <h1>{ \"Hello, World!\" }</h1>\n    </div>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Server-side Rendering in Yew\nDESCRIPTION: Demonstrates how to create a basic server-side rendered Yew component using ServerRenderer. The example shows rendering a simple component that displays 'Hello, World!' using the current_thread runtime configuration.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/advanced-topics/server-side-rendering.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew::ServerRenderer;\n\n#[function_component]\nfn App() -> Html {\n    html! {<div>{\"Hello, World!\"}</div>}\n}\n\n#[tokio::main(flavor = \"current_thread\")]\nasync fn no_main() {\n    let renderer = ServerRenderer::<App>::new();\n\n    let rendered = renderer.render().await;\n\n    // Prints: <div>Hello, World!</div>\n    println!(\"{}\", rendered);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NodeRef in Yew Component\nDESCRIPTION: Demonstrates how to use NodeRef to access DOM elements in a Yew component. Shows creation of NodeRef, attaching it to a div element, and accessing the element's attributes in the rendered lifecycle method.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/struct-components/refs.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::Element;\nuse yew::{html, Component, Context, Html, NodeRef};\n\nstruct Comp {\n    node_ref: NodeRef,\n}\n\nimpl Component for Comp {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            // highlight-next-line\n            node_ref: NodeRef::default(),\n        }\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            // highlight-next-line\n            <div ref={self.node_ref.clone()}></div>\n        }\n    }\n\n    fn rendered(&mut self, _ctx: &Context<Self>, _first_render: bool) {\n        // highlight-start\n        let has_attributes = self.node_ref\n            .cast::<Element>()\n            .unwrap()\n            .has_attributes();\n        // highlight-end\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Callback for Click Events in Yew (Rust)\nDESCRIPTION: This snippet illustrates the implementation of a simple click event callback in a Yew component. The 'onclick' callback is defined to handle button clicks, which triggers a message to be sent back to the component's state.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/struct-components/callbacks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse yew::{html, Component, Context, Html};\n\nenum Msg {\n    Clicked,\n}\n\nstruct Comp;\n\nimpl Component for Comp {\n\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        // highlight-next-line\n        let onclick = ctx.link().callback(|_| Msg::Clicked);\n        html! {\n            // highlight-next-line\n            <button {onclick}>{ \"Click\" }</button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Keyed List in Yew\nDESCRIPTION: This example demonstrates how to create a keyed list in Yew for performance optimization. It maps over a vector of names, creating a div for each name with a unique key prop.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/lists.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet names = vec![\"Sam\",\"Bob\",\"Ray\"]\n\nhtml! {\n    <div id=\"introductions\">\n        {\n            names.into_iter().map(|name| {\n                html!{<div key={name}>{ format!(\"Hello, I'am {}!\",name) }</div>}\n            }).collect::<Html>()\n        }\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using Custom Child Types with Render Props in Yew Components\nDESCRIPTION: Shows how to use Yew's new support for any type as children within components, including closures. This example demonstrates the render props pattern where a closure is passed as a child to a component, which then receives rendering properties.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/blog/2023-09-23-release-0-21.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n    <Comp>\n        {|p: RenderProps| html!{<>\"Hello, \"{p.name}</>}}\n    </Comp>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Modal Component Using Yew Portals - Rust\nDESCRIPTION: This code snippet defines a modal component in Yew that uses the `create_portal` function to render its children outside the main Yew component hierarchy. It retrieves a DOM element with the id 'modal_host' and renders the children of the modal into this external element. Dependencies required include the Yew framework and the Gloo library for document manipulation.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/advanced-topics/portals.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, create_portal, function_component, Children, Properties};\n\n#[derive(Properties, PartialEq)]\npub struct ModalProps {\n    #[prop_or_default]\n    pub children: Children,\n}\n\n#[function_component(Modal)]\nfn modal(props: &ModalProps) -> Html {\n    let modal_host = gloo_utils::document()\n        .get_element_by_id(\"modal_host\")\n        .expect(\"a #modal_host element\");\n\n    create_portal(\n        html!{ {for props.children.iter()} },\n        modal_host.into(),\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Using Dynamic Tag Names in Yew HTML\nDESCRIPTION: This snippet shows how to use dynamic tag names in Yew's html! macro. It demonstrates creating an h5 element with a dynamic level and setting its class and content.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/elements.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet level = 5;\nlet text = \"Hello World!\".to_owned();\n\nhtml! {\n    <@{format!(\"h{}\", level)} class=\"title\">{ text }</@>\n};\n```\n\n----------------------------------------\n\nTITLE: Using NodeRef in Rendered Lifecycle Method (Rust)\nDESCRIPTION: Example showing how to implement the rendered lifecycle method to perform actions after component rendering, such as focusing an input element on first render.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.18.0/concepts/components/introduction.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse stdweb::web::html_element::InputElement;\nuse stdweb::web::IHtmlElement;\nuse yew::prelude::*;\n\npub struct MyComponent {\n    node_ref: NodeRef,\n}\n\nimpl Component for MyComponent {\n    // ...\n\n    fn view(&self) -> Html {\n        html! {\n            <input ref=self.node_ref.clone() type=\"text\" />\n        }\n    }\n\n    fn rendered(&mut self, first_render: bool) {\n        if first_render {\n            if let Some(input) = self.node_ref.cast::<InputElement>() {\n                input.focus();\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: DOM Document Access Comparison in JS vs Rust\nDESCRIPTION: Demonstrates how to access the document object from the window in both JavaScript and Rust using web-sys. The Rust version includes error handling with expect_throw for undefined cases.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/basic-web-technologies/js.mdx#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nlet document = window.document\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::UnwrapThrowExt;\nuse web_sys::window;\n\nlet document = window()\n    .expect_throw(\"window is undefined\")\n    .document()\n    .expect_throw(\"document is undefined\");\n```\n\n----------------------------------------\n\nTITLE: Implementing the Update Method for Component Communication in Yew\nDESCRIPTION: Implementation of the update method for a Yew component, which handles messages sent to the component from event listeners, child components, or other sources. It updates the component state and determines if re-rendering is needed.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Component, Context, html, Html};\n\n// highlight-start\npub enum Msg {\n    SetInputEnabled(bool)\n}\n// highlight-end\n\nstruct MyComponent {\n    input_enabled: bool,\n}\n\nimpl Component for MyComponent {\n    // highlight-next-line\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            input_enabled: false,\n        }\n    }\n\n    // highlight-start\n    fn update(&mut self, _ctx: &Context<Self>, msg: Self::Message) -> bool {\n        match msg {\n            Msg::SetInputEnabled(enabled) => {\n                if self.input_enabled != enabled {\n                    self.input_enabled = enabled;\n                    true // Re-render\n                } else {\n                    false\n                }\n            }\n        }\n    }\n    // highlight-end\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            // impl\n        }\n    }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Mouse Event Handling with Web-Sys and Closure\nDESCRIPTION: Demonstrates JavaScript mouse event handling translated to Rust using web-sys and Closure for event management\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/wasm-bindgen/web-sys.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::{prelude::Closure, JsCast};\nuse web_sys::{console, Document, HtmlElement, MouseEvent};\n\nlet mousemove = Closure::<dyn Fn(MouseEvent)>::wrap(Box::new(|e| {\n    let rect = e\n        .target()\n        .expect(\"mouse event doesn't have a target\")\n        .dyn_into::<HtmlElement>()\n        .expect(\"event target should be of type HtmlElement\")\n        .get_bounding_client_rect();\n    let x = (e.client_x() as f64) - rect.left();\n    let y = (e.client_y() as f64) - rect.top();\n    console::log_1(&format!(\"Left? : {} ; Top? : {}\", x, y).into());\n}));\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for Yew\nDESCRIPTION: Adding Yew as a dependency in the Cargo.toml file with the client-side rendering feature enabled.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/tutorial/index.mdx#2025-04-16_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"yew-app\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nyew = { version = \"0.20\", features = [\"csr\"] }\n```\n\n----------------------------------------\n\nTITLE: Tracing Inheritance Chain of HtmlTextAreaElement in web-sys\nDESCRIPTION: Demonstrates the inheritance hierarchy of a web-sys HtmlTextAreaElement by using Deref::deref to traverse through HtmlElement, Element, Node, EventTarget, Object, and finally JsValue. Shows how to pass elements as their parent types.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ops::Deref;\nuse web_sys:{\n    Element,\n    EventTarget,\n    HtmlElement,\n    HtmlTextAreaElement,\n    Node,\n};\n\nfn inheritance_of_text_area(text_area: HtmlTextAreaElement) {\n    // HtmlTextAreaElement is <textarea> in html.\n    let html_element: &HtmlElement = text_area.deref();\n\n    let element: &Element = html_element.deref();\n\n    let node: &Node = element.deref();\n\n    let event_target: &EventTarget = node.deref();\n\n    // Notice we have moved from web-sys types now into built-in\n    // JavaScript types which are in the js-sys crate.\n    let object: &js_sys::Object = event_target.deref();\n\n    // Notice we have moved from js-sys type to the root JsValue from\n    // the wasm-bindgen crate.\n    let js_value: &wasm_bindgen::JsValue = object.deref();\n\n    // Using deref like this means we have to manually traverse\n    // the inheritance tree, however, you can call JsValue methods\n    // on the HtmlTextAreaElement type.\n    // The `is_string` method comes from JsValue.\n    assert!(!text_area.is_string());\n\n    // empty function just to prove we can pass HtmlTextAreaElement as a\n    // &EventTarget.\n    fn this_function_only_takes_event_targets(targets: &EventTarget) {};\n\n    // The compiler will walk down the deref chain in order to match the types here.\n    this_function_only_takes_event_targets(&text_area);\n\n    // The AsRef implementations allow you to treat the HtmlTextAreaElement\n    // as an &EventTarget.\n    let event_target: &EventTarget = text_area.as_ref();\n\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing DOM Nodes in Yew (Rust)\nDESCRIPTION: Demonstrates how to create and manage DOM nodes manually in Yew using web-sys, useful for integrating with JS libraries that may conflict with managed components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/elements.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{Element, Node};\nuse yew::prelude::*;\nuse gloo::utils::document;\n\n#[function_component]\nfn MyComponent() -> Html {\n    // memoize as this only needs to be executed once\n    let node = use_memo(\n        (),\n        |_| {\n            // Create a div element from the document\n            let div: Element = document().create_element(\"div\").unwrap();\n            // Add content, classes etc.\n            div.set_inner_html(\"Hello, World!\");\n            // Convert Element into a Node\n            let node: Node = div.into();\n            // Return that Node as a Html value\n            Html::VRef(node)\n        },\n    );\n\n    // use_memo return Rc so we need to deref and clone\n    (*node).clone()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Properties for a Link Component in Rust\nDESCRIPTION: Demonstrates how to define and implement Properties for a Link component in Yew. It shows the use of #[derive(Properties, PartialEq)], required and optional props, and default values.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.18.0/concepts/components/properties.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub struct LinkColor {\n    Blue,\n    Red,\n    Green,\n    Black,\n    Purple,\n}\n\nimpl Default for LinkColor {\n    fn default() -> Self {\n        // 除非另有说明，否则链接的颜色将为蓝色\n        LinkColor::Blue\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct LinkProps {\n    /// 链接必须有一个目标地址\n    href: String,\n    /// 如果链接文本很大，这将使得复制字符串开销更小\n    /// 除非有性能问题，否则通常不建议这么做\n    text: Rc<String>,\n    /// 链接的颜色\n    #[prop_or_default]\n    color: LinkColor,\n    /// 如果为 None，则 view 函数将不指定大小\n    #[prop_or_default]\n    size: Option<u32>\n    /// 当 view 函数没有指定 active，其默认为 true\n    #[prop_or_else(true)]\n    active: bool,\n}\n```\n\n----------------------------------------\n\nTITLE: Using Props in Function Components with Yew\nDESCRIPTION: Example of how to implement a function component with props in Yew. The code shows both a component that accepts props and how to provide props from a parent component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/function-components/properties.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub is_loading: bool,\n}\n\n#[function_component]\nfn HelloWorld(&Props { is_loading }: &Props) -> Html {\n    html! { <>\"Am I loading? - \"{is_loading}</> }\n}\n\n// 然後提供屬性\n#[function_component]\nfn App() -> Html {\n    html! { <HelloWorld is_loading=true /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the Rendered Method with DOM Interaction\nDESCRIPTION: Example of the rendered lifecycle method that allows interaction with the DOM after rendering, using NodeRef to focus an input element.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/components/introduction.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, web_sys::HtmlInputElement, Component, Html, NodeRef};\n\npub struct MyComponent {\n    node_ref: NodeRef,\n}\n\nimpl Component for MyComponent {\n    // ...\n\n    fn view(&self) -> Html {\n        html! {\n            <input ref=self.node_ref.clone() type=\"text\" />\n        }\n    }\n\n    fn rendered(&mut self, first_render: bool) {\n        if first_render {\n            if let Some(input) = self.node_ref.cast::<HtmlInputElement>() {\n                input.focus();\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Nested HTML Layouts with Yew - Rust\nDESCRIPTION: Demonstrates creating complex nested HTML layouts using the Yew framework, covering elements like div, span, label, input, textarea, and select.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/introduction.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\\n\\nhtml! {\\n    <div>\\n        <div data-key=\\\"abc\\\"></div>\\n        <div class=\\\"parent\\\">\\n            <span class=\\\"child\\\" value=\\\"anything\\\"></span>\\n            <label for=\\\"first-name\\\">{ \\\"First Name\\\" }</label>\\n            <input type=\\\"text\\\" id=\\\"first-name\\\" value=\\\"placeholder\\\" />\\n            <input type=\\\"checkbox\\\" checked=true />\\n            <textarea value=\\\"write a story\\\" />\\n            <select name=\\\"status\\\">\\n                <option selected=true disabled=false value=\\\"\\\">{ \\\"Selected\\\" }</option>\\n                <option selected=false disabled=true value=\\\"\\\">{ \\\"Unselected\\\" }</option>\\n            </select>\\n        </div>\\n    </div>\\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Listeners with Agent Handlers in Yew\nDESCRIPTION: Demonstrates how to create event listeners that dispatch messages to a worker agent using the Yew agent system.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/elements.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html};\nuse yew_agent::{Dispatcher, Dispatched};\nuse website_test::agents::{MyWorker, WorkerMsg};\n\nstruct MyComponent {\n    worker: Dispatcher<MyWorker>,\n}\n\nimpl Component for MyComponent {\n    type Message = WorkerMsg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        MyComponent {\n            worker: MyWorker::dispatcher(),\n        }\n    }\n\n    fn update(&mut self, _ctx: &Context<Self>, msg: Self::Message) -> bool {\n        self.worker.send(msg);\n        false\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        // Create a callback from a worker to handle it in another context\n        let click_callback = ctx.link().callback(|_| WorkerMsg::Process);\n        html! {\n            <button onclick={click_callback}>\n                { \"Click me!\" }\n            </button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Hydrating Server-Side Rendered Yew Components\nDESCRIPTION: This example shows how to hydrate a server-side rendered Yew application on the client side. It creates a Renderer for the App component and calls the hydrate method to connect the application to the server-generated HTML.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/server-side-rendering.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew::Renderer;\n\n#[function_component]\nfn App() -> Html {\n    html! {<div>{\"Hello, World!\"}</div>}\n}\n\nfn main() {\n    let renderer = Renderer::<App>::new();\n\n    // 直接在 body 元素下注水，并移除可能有的任何尾随元素。\n    renderer.hydrate();\n}\n```\n\n----------------------------------------\n\nTITLE: List Rendering with Keys\nDESCRIPTION: Demonstration of adding keys to list items for performance optimization in Yew, using unique identifiers for each list element\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/lists.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet names = vec![\"Sam\",\"Bob\",\"Ray\"]\n\nhtml! {\n    <div id=\"introductions\">\n        {\n            names.into_iter().map(|name| {\n                html!{<div key={name}>{ format!(\"Hello, I'am {}!\",name) }</div>}\n            }).collect::<Html>()\n        }\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using Typed Children with ChildrenWithProps in Yew\nDESCRIPTION: Shows how to use ChildrenWithProps<T> to accept children of a specific component type. This is useful when you want to ensure that only certain types of components can be passed as children.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/advanced-topics/children.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, ChildrenWithProps, Component, Context, Html, Properties};\n\npub struct Item;\n\nimpl Component for Item {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"item\" }\n        }\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: ChildrenWithProps<Item>,\n}\n\npub struct List;\n\nimpl Component for List {\n    type Message = ();\n    type Properties = ListProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"list\">\n                { for ctx.props().children.iter() }\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Ephemeral Event Callbacks in Yew\nDESCRIPTION: Shows how to create standalone callbacks for event handling without dispatching to a component's update method, useful for simple operations like logging.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/elements.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Callback, Context, Component, html, Html};\nuse weblog::console_log;\n\nstruct MyComponent;\n\nimpl Component for MyComponent {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        MyComponent\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        // Create an ephemeral callback\n        let click_callback = Callback::from(|_| {\n            console_log!(\"clicked!\");\n        });\n\n        html! {\n            <button onclick={click_callback}>\n                { \"Click me!\" }\n            </button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Props with Callbacks in Rust\nDESCRIPTION: This code shows how to define props for a VideosList component that includes a callback function for handling click events. The component passes selected video data to its parent through this callback.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Properties, PartialEq)]\nstruct VideosListProps {\n    videos: Vec<Video>,\n    on_click: Callback<Video>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the View Method in Yew Components\nDESCRIPTION: Implementation of the view method for a Yew component, which defines how the component should be rendered to the DOM using the html! macro to create HTML-like structures.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Component, Context, html, Html, Properties};\n\nenum Msg {\n    Click,\n}\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    button_text: String,\n}\n\nstruct MyComponent;\n\nimpl Component for MyComponent {\n    type Message = Msg;\n    type Properties = Props;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    // highlight-start\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let onclick = ctx.link().callback(|_| Msg::Click);\n        html! {\n            <button {onclick}>{ &ctx.props().button_text }</button>\n        }\n    }\n    // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: 处理HTML元素的可选属性 - Rust\nDESCRIPTION: 演示如何在Yew中处理HTML元素的可选属性。通过使用Option<T>，可以根据需要包含或省略某些属性。\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/html/elements.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet maybe_id = Some(\"foobar\");\n\nhtml! {\n    <div id={maybe_id}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering in Yew\nDESCRIPTION: Illustrates conditional rendering of markup using Rust's if statement within Yew's html! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/introduction.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n  if true {\n      <p>{ \"True case\" }</p>\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Event Hook in Rust for Yew\nDESCRIPTION: This snippet provides a full implementation of the use_event custom hook. It uses the use_effect_with hook to manage the event listener lifecycle and handle parameter changes.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse web_sys::{Event, EventTarget};\nuse std::borrow::Cow;\nuse std::rc::Rc;\nuse gloo::events::EventListener;\n\n#[hook]\npub fn use_event<E, F>(target: &EventTarget, event_type: E, callback: F)\nwhere\n    E: Into<Cow<'static, str>>,\n    F: Fn(Event) + 'static,\n{\n    #[derive(PartialEq, Clone)]\n    struct EventDependents {\n        target: EventTarget,\n        event_type: Cow<'static, str>,\n        callback: Callback<Event>,\n    }\n\n    let deps = EventDependents {\n        target: target.clone(),\n        event_type: event_type.into(),\n        callback: Callback::from(callback),\n    };\n\n    use_effect_with(\n        deps,\n        |deps| {\n            let EventDependents {\n                target,\n                event_type,\n                callback,\n            } = deps.clone();\n\n            let listener = EventListener::new(&target, event_type, move |e| {\n                callback.emit(e.clone());\n            });\n\n            move || {\n                drop(listener);\n            }\n        },\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering with If-Let-Else Expression in Yew (Rust)\nDESCRIPTION: Demonstrates the use of an if-let-else expression for conditional rendering in Yew. It renders different paragraph elements based on whether the Option contains a value or not.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/conditional-rendering.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nlet some_text = Some(\"text\");\n\nhtml! {\n    if let Some(text) = some_text {\n        <p>{ text }</p>\n    } else {\n        <p>{ \"False case\" }</p>\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Using NodeRef in Yew Components with Rust\nDESCRIPTION: This Rust code snippet exemplifies the use of NodeRef in a Yew component to obtain a DOM element reference and interact with it directly. The component defines a NodeRef, which is cloned in the view method to reference a DOM element. In the rendered method, NodeRef is used to verify the presence of attributes in the element. Dependencies include the `web_sys::Element` and Yew's component traits and modules. The key syntax involves using NodeRef to access DOM nodes post-render.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/struct-components/refs.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::Element;\\nuse yew::{html, Component, Context, Html, NodeRef};\\n\\nstruct Comp {\\n    node_ref: NodeRef,\\n}\\n\\nimpl Component for Comp {\\n    type Message = ();\\n    type Properties = ();\\n\\n    fn create(_ctx: &Context<Self>) -> Self {\\n        Self {\\n            // highlight-next-line\\n            node_ref: NodeRef::default(),\\n        }\\n    }\\n\\n    fn view(&self, _ctx: &Context<Self>) -> Html {\\n        html! {\\n            // highlight-next-line\\n            <div ref={self.node_ref.clone()}></div>\\n        }\\n    }\\n\\n    fn rendered(&mut self, _ctx: &Context<Self>, _first_render: bool) {\\n        // highlight-start\\n        let has_attributes = self.node_ref\\n            .cast::<Element>()\\n            .unwrap()\\n            .has_attributes();\\n        // highlight-end\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Utilizing NodeRef in Yew Components\nDESCRIPTION: This Rust snippet shows how to use NodeRef for accessing and manipulating DOM elements in Yew, eliminating the need to query event targets in callbacks. Dependencies include Yew and web-sys, with inputs being component state changes. NodeRef::cast is used to safely cast nodes, offering a more streamlined approach to interacting with the DOM within React-style components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/events.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::prelude::*;\n\n#[function_component]\nfn MyComponent() -> Html {\n    //highlight-next-line\n    let input_node_ref = use_node_ref();\n\n    let input_value_handle = use_state(String::default);\n    let input_value = (*input_value_handle).clone();\n\n    let onchange = {\n        let input_node_ref = input_node_ref.clone();\n\n        Callback::from(move |_| {\n            //highlight-next-line\n            let input = input_node_ref.cast::<HtmlInputElement>();\n\n            if let Some(input) = input {\n                input_value_handle.set(input.value());\n            }\n        })\n    };\n\n    html! {\n        <>\n            <label for=\"my-input\">\n                { \"My input:\" }\n                //highlight-next-line\n                <input ref={input_node_ref}\n                    {onchange}\n                    id=\"my-input\"\n                    type=\"text\"\n                    value={input_value}\n                />\n            </label>\n        </>\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::prelude::*;\n\n#[function_component]\nfn MyComponent() -> Html {\n    let input_node_ref = use_node_ref();\n\n    //highlight-start\n    let onchange = {\n        let input_node_ref = input_node_ref.clone();\n\n        Callback::from(move |_| {\n            if let Some(input) = input_node_ref.cast::<HtmlInputElement>() {\n                let value = input.value();\n                // do something with value\n            }\n        })\n    };\n    //highlight-end\n\n    html! {\n        <>\n            <label for=\"my-input\">\n                { \"My input:\" }\n                <input ref={input_node_ref}\n                    {onchange}\n                    id=\"my-input\"\n                    type=\"text\"\n                />\n            </label>\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Fragments in html! Macro for Multiple Elements\nDESCRIPTION: Demonstrates the correct way to render multiple elements using fragments in the html! macro. Fragments act as invisible wrappers that produce no HTML element by themselves.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/basic-web-technologies/html.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\n// fixed: using HTML fragments\nhtml! {\n    <>\n        <div></div>\n        <p></p>\n    </>\n};\n```\n\n----------------------------------------\n\nTITLE: Rendering Text Literals and Values in Yew\nDESCRIPTION: Demonstrates how to render text literals, variables, and numeric values in Yew components using curly braces syntax. The example shows inserting text content into different HTML elements.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet text = \"lorem ipsum\";\nhtml!{\n    <>\n        <div>{text}</div>\n        <div>{\"dolor sit\"}</div>\n        <span>{42}</span>\n    </>\n};\n```\n\n----------------------------------------\n\nTITLE: Handling onchange event with File Input in Yew\nDESCRIPTION: This snippet showcases how to handle the `onchange` event for a file input element in Yew. It uses `ChangeData::Files` to access the selected files. The `batch_callback` is used to conditionally process the file list, returning `None` if the event is not a `Files` event.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/events.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Html, ChangeData};\n\nfn view(&self) -> Html {\n\n    let onchange = self.link.batch_callback(|e| {\n        if let ChangeData::Files(files) = e {\n            // do something with web_sys::FileList\n        } else {\n            None\n        }\n    });\n\n    html! {\n        <div>\n            <input onchange={onchange} type=\"file\" />\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Optional Typed Child in Yew - Rust\nDESCRIPTION: This snippet outlines how to create a component that accepts an optional child of a specific type. It demonstrates the rendering of the child if present or a default when it is absent.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/components/children.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{\n    html, html_nested, virtual_dom::VChild, Component,\n    Context, Html, Properties\n};\n\npub struct PageSideBar;\n\nimpl Component for PageSideBar {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"sidebar\" }\n        }\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct PageProps {\n    #[prop_or_default]\n    pub sidebar: Option<VChild<PageSideBar>>,  \n}\n\nstruct Page;\n\nimpl Component for Page {\n    type Message = ();\n    type Properties = PageProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"page\">\n                { ctx.props().sidebar.clone().map(Html::from).unwrap_or_default() }\n                // ... page content\n            </div>\n        }\n    }\n}\n\n// The page component can be called either with the sidebar or without:\n\npub fn render_page(with_sidebar: bool) -> Html {\n    if with_sidebar {\n        // Page with sidebar\n        html! {\n            <Page sidebar={{html_nested! {\n                <PageSideBar />\n            }}} />\n        }\n    } else {\n        // Page without sidebar\n        html! {\n            <Page />\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Event Listener with Gloo\nDESCRIPTION: Demonstrates a more concise method of adding custom event listeners using the Gloo library, simplifying DOM event handling in a Yew component\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/events.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlElement;\nuse yew::prelude::*;\n\nuse gloo::events::EventListener;\n\n#[function_component]\nfn MyComponent() -> Html {\n    let div_node_ref = use_node_ref();\n\n    use_effect_with_deps(\n        {\n            let div_node_ref = div_node_ref.clone();\n\n            move |_| {\n                let mut custard_listener = None;\n\n                if let Some(element) = div_node_ref.cast::<HtmlElement>() {\n                    let oncustard = Callback::from(move |_: Event| {\n                        // do something about custard..\n                    });\n\n                    let listener = EventListener::new(\n                        &element,\n                        \"custard\",\n                        move |e| oncustard.emit(e.clone())\n                    );\n\n                    custard_listener = Some(listener);\n                }\n\n                move || drop(custard_listener)\n            }\n        },\n        div_node_ref.clone()\n    );\n\n    html! {\n        <div ref={div_node_ref} id=\"my-div\"></div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Logging to Browser Console with wasm-logger in Rust\nDESCRIPTION: Demonstrates how to use the wasm-logger crate to log messages to the browser console in a Yew application. It integrates with the log crate and provides log level, source line, and filename information.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/more/debugging.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse log::info;\nuse wasm_bindgen::JsValue;\n\nfn main() {\n    wasm_logger::init(wasm_logger::Config::default());\n\n    let object = JsValue::from(\"world\");\n    info!(\"Hello {}\", object.as_string().unwrap());\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo.toml Configuration for Yew Example\nDESCRIPTION: This TOML snippet shows the necessary dependencies and feature flags for the Yew example in Rust.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies.web-sys]\nversion = \"0.3\"\n# 我们需要启用 `DomRect` 特性以使用 `get_bounding_client_rect` 方法。\nfeatures = [\n    \"console\",\n    \"HtmlElement\",\n    \"MouseEvent\",\n    \"DomRect\",\n]\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Routes in Yew Router\nDESCRIPTION: Creates a Route enum that defines the application's routes, with each variant marked by an `at` attribute specifying the URL path. Includes a not_found route for handling 404 errors.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/router.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew_router::prelude::*;\n\n#[derive(Clone, Routable, PartialEq)]\nenum Route {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/secure\")]\n    Secure,\n    #[not_found]\n    #[at(\"/404\")]\n    NotFound,\n}\n```\n\n----------------------------------------\n\nTITLE: Mouse Movement Tracking using web-sys in Rust\nDESCRIPTION: This Rust snippet uses web-sys to replicate the JavaScript mouse movement tracking example. It demonstrates how to interact with the DOM and handle events using web-sys.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::{prelude::Closure, JsCast};\nuse web_sys::{console, Document, HtmlElement, MouseEvent};\n\nlet mousemove = Closure::<dyn Fn(MouseEvent)>::wrap(Box::new(|e| {\n    let rect = e\n        .target()\n        .expect(\"mouse event doesn't have a target\")\n        .dyn_into::<HtmlElement>()\n        .expect(\"event target should be of type HtmlElement\")\n        .get_bounding_client_rect();\n    let x = (e.client_x() as f64) - rect.left();\n    let y = (e.client_y() as f64) - rect.top();\n    console::log_1(&format!(\"Left? : {} ; Top? : {}\", x, y).into());\n}));\n\nDocument::new()\n    .expect(\"global document not set\")\n    .get_element_by_id(\"mousemoveme\")\n    .expect(\"element with id `mousemoveme` not present\")\n    .unchecked_into::<HtmlElement>()\n    .set_onmousemove(mousemove.as_ref().dyn_ref());\n\n// we now need to save the `mousemove` Closure so that when\n// this event fires the closure is still in memory.\n```\n\n----------------------------------------\n\nTITLE: Passing Theme Using Props in Yew\nDESCRIPTION: This Rust code snippet showcases a simple Yew application where a theme is passed through components using props. It demonstrates the structure of components requiring theme data, highlighting the tedious approach of passing the data explicitly.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/contexts.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Children, Component, Context, Html, Properties};\n\n#[derive(Clone, PartialEq)]\npub struct Theme {\n    foreground: String,\n    background: String,\n}\n\n#[derive(PartialEq, Properties)]\npub struct NavbarProps {\n    theme: Theme,\n}\n\npub struct Navbar;\n\nimpl Component for Navbar {\n    type Message = ();\n    type Properties = NavbarProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div>\n                <Title theme={ctx.props().theme.clone()}>\n                    { \"App title\" }\n                </Title>\n                <NavButton theme={ctx.props().theme.clone()}>\n                    { \"Somewhere\" }\n                </NavButton>\n            </div>\n        }\n    }\n}\n\n#[derive(PartialEq, Properties)]\npub struct ThemeProps {\n    theme: Theme,\n    children: Children,\n}\n\n#[yew::function_component(Title)]\nfn title(_props: &ThemeProps) -> Html {\n    html! {\n        // impl\n    }\n}\n#[yew::function_component(NavButton)]\nfn nav_button(_props: &ThemeProps) -> Html {\n    html! {\n        // impl\n    }\n}\n\n// root\nlet theme = Theme {\n    foreground: \"yellow\".to_owned(),\n    background: \"pink\".to_owned(),\n};\n\nhtml! {\n    <Navbar {theme} />\n};\n```\n\n----------------------------------------\n\nTITLE: Modifying Video Struct for Properties in Yew\nDESCRIPTION: This code snippet modifies the `Video` struct to derive `Clone` and `PartialEq` traits. This is necessary for the previous snippet to compile, as the `Video` struct needs to be cloneable and comparable for use in the `VideosList` component. Requires the `yew` crate.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Clone, PartialEq)]\nstruct Video {\n    id: usize,\n    title: String,\n    speaker: String,\n    url: String,\n}\n```\n\n----------------------------------------\n\nTITLE: HTML Macro: Open-Close Tag Example in Yew\nDESCRIPTION: This snippet demonstrates the basic structure of an HTML element using the `html!` macro in Yew.  It showcases a simple `div` element with an `id` attribute, correctly opened and closed. The `use yew::prelude::*;` statement imports necessary Yew functionalities.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/html/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n  <div id=\"my_div\"></div>\n};\n\n```\n\n----------------------------------------\n\nTITLE: Modifying Nested Child Component Properties in Yew\nDESCRIPTION: Illustrates how to access and modify properties of nested child components when the parent component has typed children. This example uses function components and demonstrates property modification.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/advanced-topics/children.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::rc::Rc;\nuse yew::prelude::*;\n\n#[derive(Clone, PartialEq, Properties)]\npub struct ListItemProps {\n    value: String,\n}\n\n#[function_component]\nfn ListItem(props: &ListItemProps) -> Html {\n    let ListItemProps { value } = props.clone();\n    html! {\n        <span>\n            {value}\n        </span>\n    }\n}\n\n#[derive(PartialEq, Properties)]\npub struct Props {\n    pub children: ChildrenWithProps<ListItem>,\n}\n\n#[function_component]\nfn List(props: &Props) -> Html {\n    let modified_children = props.children.iter().map(|mut item| {\n            let mut props = Rc::make_mut(&mut item.props);\n            props.value = format!(\"item-{}\", props.value);\n            item\n    });\n    html! { for modified_children }\n}\n\nhtml! {\n    <List>\n        <ListItem value=\"a\" />\n        <ListItem value=\"b\" />\n        <ListItem value=\"c\" />\n    </List>\n};\n```\n\n----------------------------------------\n\nTITLE: Using spawn_local with Async Functions in Rust WebAssembly\nDESCRIPTION: Demonstrates how to use spawn_local to execute asynchronous functions in WebAssembly context. Shows creating an async function that returns a String and handling its result with console logging.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/basic-web-technologies/wasm-bindgen.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::console;\nuse wasm_bindgen_futures::spawn_local;\n\nasync fn my_async_fn() -> String { String::from(\"Hello\") }\n\nspawn_local(async {\n    let mut string = my_async_fn().await;\n    string.push_str(\", world!\");\n    // console log \"Hello, world!\"\n    console::log_1(&string.into());\n});\n```\n\n----------------------------------------\n\nTITLE: Updating API Endpoint for Proxy (Yew/Rust)\nDESCRIPTION: This snippet updates the API endpoint to use a relative path instead of the full URL. This allows the `trunk` development server to proxy requests to the actual API endpoint, resolving CORS issues. It changes the URL from `https://yew.rs/tutorial/data.json` to `/tutorial/data.json`.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n// ...\n-                let fetched_videos: Vec<Video> = Request::get(\"https://yew.rs/tutorial/data.json\")\n+                let fetched_videos: Vec<Video> = Request::get(\"/tutorial/data.json\")\n// ...\n```\n\n----------------------------------------\n\nTITLE: List Component with Typed Children Implementation\nDESCRIPTION: Implements a List component that accepts ListItem components as children. The component iterates through its children, modifies their properties, and then renders them.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/components.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, ChildrenWithProps, Component, Html, Properties};\n\n#[derive(Properties, Clone)]\npub struct Props {\n    pub children: ChildrenWithProps<ListItem>,\n}\n\npub struct List(Props);\nimpl Component for List {\n    type Properties = Props;\n\n    // ...\n\n    fn view(&self) -> Html {\n        html!{{\n            for self.0.children.iter().map(|mut item| {\n                item.props.value = format!(\"item-{}\", item.props.value);\n                item\n            })\n        }}\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Yew Component with Conditional Batch Callback\nDESCRIPTION: Shows how to implement a batch callback that conditionally updates the component based on keyboard events. The callback only triggers a component update when the Enter key is pressed.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/advanced-topics/struct-components/callbacks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{events::KeyboardEvent, html, Component, Context, Html};\n\nenum Msg {\n    Submit,\n}\n\nstruct Comp;\n\nimpl Component for Comp {\n\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let onkeypress = ctx.link().batch_callback(|event: KeyboardEvent| {\n            if event.key() == \"Enter\" {\n                Some(Msg::Submit)\n            } else {\n                None\n            }\n        });\n\n        html! {\n            <input type=\"text\" {onkeypress} />\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Optional Typed Child Components in Yew\nDESCRIPTION: Shows how to create a component that accepts an optional child component of a specific type. This pattern is useful when a child component is not always required but should be of a specific type when present.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/advanced-topics/children.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew:{\n    html, html_nested, virtual_dom::VChild, Component,\n    Context, Html, Properties\n};\n\npub struct PageSideBar;\n\nimpl Component for PageSideBar {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"sidebar\" }\n        }\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct PageProps {\n    #[prop_or_default]\n    pub sidebar: Option<VChild<PageSideBar>>,\n}\n\nstruct Page;\n\nimpl Component for Page {\n    type Message = ();\n    type Properties = PageProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"page\">\n                { ctx.props().sidebar.clone().map(Html::from).unwrap_or_default() }\n                // ... page content\n            </div>\n        }\n    }\n}\n\npub fn render_page(with_sidebar: bool) -> Html {\n    if with_sidebar {\n        html! {\n            <Page sidebar={html_nested! {\n                <PageSideBar />\n            }} />\n        }\n    } else {\n        html! {\n            <Page />\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Mouse Position Tracking using Yew\nDESCRIPTION: A Yew implementation of mouse position tracking that uses Callback and Yew's TargetCast for more idiomatic event handling within Yew components, with declarative HTML through the html! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{console, HtmlElement, MouseEvent};\nuse yew:{\n    html,\n    Callback, TargetCast,\n};\n\nlet onmousemove = Callback::from(|e: MouseEvent| {\n    if let Some(target) = e.target_dyn_into::<HtmlElement>() {\n        let rect = target.get_bounding_client_rect();\n        let x = (e.client_x() as f64) - rect.left();\n        let y = (e.client_y() as f64) - rect.top();\n        console::log_1(&format!(\"Left? : {} ; Top? : {}\", x, y).into());\n    }\n});\n\nhtml! {\n    <div id=\"mousemoveme\" {onmousemove}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Click Handling in VideosList Component\nDESCRIPTION: This function component implementation shows how to handle click events on videos in a list. It clones the callback and video data to create a closure that will be executed when a video is clicked.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\n#[function_component(VideosList)]\nfn videos_list(VideosListProps { videos, on_click }: &VideosListProps) -> Html {\n    let on_click = on_click.clone();\n    videos.iter().map(|video| {\n        let on_video_select = {\n            let on_click = on_click.clone();\n            let video = video.clone();\n            Callback::from(move |_| {\n                on_click.emit(video.clone())\n            })\n        };\n\n        html! {\n            <p key={video.id} onclick={on_video_select}>{format!(\"{}: {}\", video.speaker, video.title)}</p>\n        }\n    }).collect()\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Callbacks as Props in Yew Components\nDESCRIPTION: Illustrates how to define a component that accepts a callback as a prop, and how to create and pass that callback from a parent component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/function-components/callbacks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties, Callback};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub on_name_entry: Callback<String>,\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n\n    props.on_name_entry.emit(String::from(\"Bob\"));\n\n    html! { \"Hello\" }\n}\n\n// Then supply the prop\n#[function_component]\nfn App() -> Html {\n    let on_name_entry: Callback<String> = Callback::from(move |name: String| {\n        let greeting = format!(\"Hey, {}!\", name);\n        // web_sys::console::log_1(&greeting.into()); // if uncommented will print\n    });\n\n    html! { <HelloWorld {on_name_entry} /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Nested Components with Props in Yew - Parent Component (Rust)\nDESCRIPTION: Demonstrates how to create a parent component with nested child components that have properties. This example shows a List component containing ListItem components with values.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.18.0/concepts/html/components.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n    <List>\n        <ListItem value=\"a\" />\n        <ListItem value=\"b\" />\n        <ListItem value=\"c\" />\n    </List>\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Expressions into Functions in Yew\nDESCRIPTION: Illustrates how to improve code readability by extracting conditional rendering logic into separate functions or closures while maintaining the same functionality.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet show_link = true;\nlet maybe_display_link = move || -> Html {\n  if show_link {\n    html! {\n      <a href=\"https://example.com\">{\"Link\"}</a>\n    }\n  } else {\n    html! {}\n  }\n};\n\nhtml! {\n     <div>{maybe_display_link()}</div>\n};\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing DOM Nodes in Rust with Yew\nDESCRIPTION: This snippet demonstrates how to create DOM elements manually using web-sys in a Yew function component. It creates a div element, sets its content, and converts it to a Node which is then used as an Html value.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/elements.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{Element, Node};\nuse yew::prelude::*;\nuse gloo::utils::document;\n\n#[function_component]\nfn MyComponent() -> Html {\n    // memoize as this only needs to be executed once\n    let node = use_memo(\n        (),\n        |_| {\n            // Create a div element from the document\n            let div: Element = document().create_element(\"div\").unwrap();\n            // Add content, classes etc.\n            div.set_inner_html(\"Hello, World!\");\n            // Convert Element into a Node\n            let node: Node = div.into();\n            // Return that Node as a Html value\n            Html::VRef(node)\n        },\n    );\n\n    // use_memo return Rc so we need to deref and clone\n    (*node).clone()\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Parameters from Route\nDESCRIPTION: This snippet illustrates how to extract parameters from a route, such as a post ID, and use that parameter within a rendered component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/router.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Clone, Routable, PartialEq)]\nenum Route {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/post/:id\")]\n    Post { id: String },\n}\n\nfn switch(route: &Route) -> Html {\n    match route {\n        Route::Home => html! { <h1>{ \"Home\" }</h1> },\n        Route::Post { id } => html! {<p>{format!(\"You are looking at Post {}\", id)}</p>},\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using classes! macro with literal in Yew (Rust)\nDESCRIPTION: Demonstrates how to use the classes! macro with a literal string to set a class on an HTML element in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/classes.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n    <div class={classes!(\"container\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Listener Component in Yew\nDESCRIPTION: This snippet demonstrates a Yew function component that listens for storage events on the window object. It uses the use_state and use_effect hooks to manage state and side effects.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse gloo::events::EventListener;\nuse gloo::utils::window;\nuse std::mem::drop;\n\n\n#[function_component(ShowStorageChanged)]\npub fn show_storage_changed() -> Html {\n    let state_storage_changed = use_state(|| false);\n\n    {\n        let state_storage_changed = state_storage_changed.clone();\n        use_effect(|| {\n            let listener = EventListener::new(&window(), \"storage\", move |_| state_storage_changed.set(true));\n\n            move || { drop(listener); }\n        });\n    }\n\n    html! { <div>{\"Storage Event Fired: \"}{*state_storage_changed}</div> }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering with Expressions in Yew\nDESCRIPTION: Shows how to use conditional logic inside Yew templates by placing if/else expressions within curly braces. The example conditionally renders a link based on a boolean variable.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet show_link = true;\n\nhtml! {\n  <div>\n    {\n      if show_link {\n        html! {\n          <a href=\"https://example.com\">{\"Link\"}</a>\n        }\n      } else {\n        html! {}\n      }\n    }\n  </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Modal Component with Portals in Yew\nDESCRIPTION: Example implementation of a modal dialog component using Yew portals. The component renders its children into an external DOM element identified by 'modal_host'. Demonstrates props setup, document element access, and portal creation.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/advanced-topics/portals.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(Properties, PartialEq)]\npub struct ModalProps {\n    #[prop_or_default]\n    pub children: Children,\n}\n\n#[function_component]\nfn Modal(props: &ModalProps) -> Html {\n    let modal_host = gloo::utils::document()\n        .get_element_by_id(\"modal_host\")\n        .expect(\"Expected to find a #modal_host element\");\n\n    create_portal(\n        html!{ {for props.children.iter()} },\n        modal_host.into(),\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Listeners with Component Handlers in Yew\nDESCRIPTION: Shows how to create event listeners that dispatch messages to a component's update method using the component's context link.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/elements.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Component, Context, html, Html};\n\nstruct MyComponent;\n\nenum Msg {\n    Click,\n}\n\nimpl Component for MyComponent {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn update(&mut self, _ctx: &Context<Self>, msg: Self::Message) -> bool {\n        match msg {\n            Msg::Click => {\n                // Handle Click\n            }\n        };\n        true\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        // Create a callback from a component link to handle it in a component\n        let click_callback = ctx.link().callback(|_| Msg::Click);\n        html! {\n            <button onclick={click_callback}>\n                { \"Click me!\" }\n            </button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Event Hook Interface in Rust/Yew\nDESCRIPTION: Initial structure for a custom event hook that accepts an event target, event type, and callback. Shows the basic hook setup with type parameters and trait bounds.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{Event, EventTarget};\nuse std::borrow::Cow;\nuse gloo::events::EventListener;\nuse yew::prelude::*;\n\n#[hook]\npub fn use_event<E, F>(target: &EventTarget, event_type: E, callback: F)\nwhere\n    E: Into<Cow<'static, str>>,\n    F: Fn(&Event) + 'static,\n{\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Single-Threaded Server-Side Rendering with WASI\nDESCRIPTION: Demonstrates server-side rendering in a single-threaded WASI environment using LocalServerRenderer\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/advanced-topics/server-side-rendering.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew::LocalServerRenderer;\n\n#[function_component]\nfn App() -> Html {\n    html! {\n        <>\n            <h1>{\"Yew WASI SSR demo\"}</h1>\n        </>\n    }\n}\n\npub async fn render() -> String {\n    let renderer = LocalServerRenderer::<App>::new();\n    let html_raw = renderer.render().await;\n\n    let mut body = String::new();\n    body.push_str(\"<body>\");\n    body.push_str(\"<div id='app'>\");\n    body.push_str(&html_raw);\n    body.push_str(\"</div>\");\n    body.push_str(\"</body>\");\n\n    body\n}\n\n#[tokio::main(flavor = \"current_thread\")]\nasync fn main() {\n    println!(\"{}\", render().await);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DOM References with NodeRef in Yew\nDESCRIPTION: Demonstrates how to create and use a NodeRef to access DOM elements in a Yew component. The example shows creating a ref, attaching it to a div element, and checking its attributes in the rendered lifecycle method.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/advanced-topics/struct-components/refs.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::Element;\nuse yew::{html, Component, Context, Html, NodeRef};\n\nstruct Comp {\n    node_ref: NodeRef,\n}\n\nimpl Component for Comp {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            // highlight-next-line\n            node_ref: NodeRef::default(),\n        }\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            // highlight-next-line\n            <div ref={self.node_ref.clone()}></div>\n        }\n    }\n\n    fn rendered(&mut self, _ctx: &Context<Self>, _first_render: bool) {\n        // highlight-start\n        let has_attributes = self.node_ref\n            .cast::<Element>()\n            .unwrap()\n            .has_attributes();\n        // highlight-end\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Component with Window Event Listener in Rust/Yew\nDESCRIPTION: A function component that listens to storage events on the window object and updates its state when the event fires. This demonstrates component-specific event handling logic that could be extracted into a custom hook.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse gloo::events::EventListener;\nuse gloo::utils::window;\nuse std::mem::drop;\n\n\n#[function_component(ShowStorageChanged)]\npub fn show_storage_changed() -> Html {\n    let state_storage_changed = use_state(|| false);\n\n    {\n        let state_storage_changed = state_storage_changed.clone();\n        use_effect(|| {\n            let listener = EventListener::new(&window(), \"storage\", move |_| state_storage_changed.set(true));\n\n            move || { drop(listener); }\n        });\n    }\n\n    html! { <div>{\"Storage Event Fired: \"}{*state_storage_changed}</div> }\n}\n```\n\n----------------------------------------\n\nTITLE: Using #[prop_or(value)] Attribute for Custom Default Values\nDESCRIPTION: Demonstrates how to set custom default values for properties using the #[prop_or(value)] attribute, where value can be any expression that returns the field's type.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/function-components/properties.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    #[prop_or_default]\n    pub is_loading: bool,\n    #[prop_or(AttrValue::Static(\"Bob\"))]\n    pub name: AttrValue,\n}\n\n#[function_component]\nfn Hello(&Props { is_loading, ref name }: &Props) -> Html {\n    if is_loading {\n        html! { \"Loading\" }\n    } else {\n        html! { <>\"Hello \"{name} </> }\n    }\n}\n\n// Then use like this with default\n#[function_component]\nfn Case1() -> Html {\n    html! { <Hello /> }\n}\n// Or no override the default\n#[function_component]\nfn Case2() -> Html {\n    html! { <Hello name=\"Sam\" /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Routes and Setting Up Router in Yew\nDESCRIPTION: Demonstrates how to define a Route enum with the Routable derive macro, and implement the switch function to render different components based on the current route.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/router.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew_router::prelude::*;\n\n#[derive(Clone, Routable, PartialEq)]\nenum Route {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/secure\")]\n    Secure,\n    #[not_found]\n    #[at(\"/404\")]\n    NotFound,\n}\n```\n\n----------------------------------------\n\nTITLE: Spawning Local Async Function in Rust with wasm-bindgen-futures\nDESCRIPTION: This snippet demonstrates how to use spawn_local from wasm-bindgen-futures to run an async function in Rust. It creates an async function, calls it, modifies the result, and logs it to the console.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/basic-web-technologies/wasm-bindgen.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::console;\nuse wasm_bindgen_futures::spawn_local;\n\nasync fn my_async_fn() -> String { String::from(\"Hello\") }\n\nspawn_local(async {\n    let mut string = my_async_fn().await;\n    string.push_str(\", world!\");\n    // console log \"Hello, world!\"\n    console::log_1(&string.into());\n});\n```\n\n----------------------------------------\n\nTITLE: Event Handler Type Mappings in Yew\nDESCRIPTION: A markdown table documenting the mapping between event handler names and their corresponding web-sys event types. Includes pointer events, touch events, transition events, and general events.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/events.mdx#2025-04-16_snippet_8\n\nLANGUAGE: markdown\nCODE:\n```\n| `onpointerlockerror`        | [Event](https://docs.rs/web-sys/latest/web_sys/struct.Event.html)                     |\n| `onpointermove`             | [PointerEvent](https://docs.rs/web-sys/latest/web_sys/struct.PointerEvent.html)       |\n| `onpointerout`              | [PointerEvent](https://docs.rs/web-sys/latest/web_sys/struct.PointerEvent.html)       |\n| `onpointerover`             | [PointerEvent](https://docs.rs/web-sys/latest/web_sys/struct.PointerEvent.html)       |\n| `onpointerup`               | [PointerEvent](https://docs.rs/web-sys/latest/web_sys/struct.PointerEvent.html)       |\n| `onselectionchange`         | [Event](https://docs.rs/web-sys/latest/web_sys/struct.Event.html)                     |\n| `onselectstart`             | [Event](https://docs.rs/web-sys/latest/web_sys/struct.Event.html)                     |\n| `onshow`                    | [Event](https://docs.rs/web-sys/latest/web_sys/struct.Event.html)                     |\n| `ontouchcancel`             | [TouchEvent](https://docs.rs/web-sys/latest/web_sys/struct.TouchEvent.html)           |\n| `ontouchend`                | [TouchEvent](https://docs.rs/web-sys/latest/web_sys/struct.TouchEvent.html)           |\n| `ontouchmove`               | [TouchEvent](https://docs.rs/web-sys/latest/web_sys/struct.TouchEvent.html)           |\n| `ontouchstart`              | [TouchEvent](https://docs.rs/web-sys/latest/web_sys/struct.TouchEvent.html)           |\n| `ontransitioncancel`        | [TransitionEvent](https://docs.rs/web-sys/latest/web_sys/struct.TransitionEvent.html) |\n| `ontransitionend`           | [TransitionEvent](https://docs.rs/web-sys/latest/web_sys/struct.TransitionEvent.html) |\n| `ontransitionrun`           | [TransitionEvent](https://docs.rs/web-sys/latest/web_sys/struct.TransitionEvent.html) |\n| `ontransitionstart`         | [TransitionEvent](https://docs.rs/web-sys/latest/web_sys/struct.TransitionEvent.html) |\n```\n\n----------------------------------------\n\nTITLE: Using Dynamic Tag Names in Yew\nDESCRIPTION: Shows how to use dynamic tag names in Yew using the @{name} syntax, where name is any expression that returns a string. This is useful for building higher-order components with variable tag names.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/html/elements.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet level = 5;\nlet text = \"Hello World!\".to_owned();\n\nhtml! {\n    <@{format!(\"h{}\", level)} class=\"title\">{ text }</@>\n};\n```\n\n----------------------------------------\n\nTITLE: Generate Yew Project from Template\nDESCRIPTION: Creates a new Yew project using cargo-generate with a minimal template\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo generate --git https://github.com/yewstack/yew-trunk-minimal-template\n```\n\n----------------------------------------\n\nTITLE: Implementing the Update Method for Component State - Rust\nDESCRIPTION: Explains how to define an update method that responds to messages and updates the state of a component, focusing on enabling or disabling an input based on user interaction.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/components/introduction.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Component, Context, html, Html};\n\n// highlight-start\npub enum Msg {\n    SetInputEnabled(bool)\n}\n// highlight-end\n\nstruct MyComponent {\n    input_enabled: bool,\n}\n\nimpl Component for MyComponent {\n    // highlight-next-line\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            input_enabled: false,\n        }\n    }\n\n    // highlight-start\n    fn update(&mut self, _ctx: &Context<Self>, msg: Self::Message) -> bool {\n        match msg {\n            Msg::SetInputEnabled(enabled) => {\n                if self.input_enabled != enabled {\n                    self.input_enabled = enabled;\n                    true // Re-render\n                } else {\n                    false\n                }\n            }\n        }\n    }\n    // highlight-end\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            // impl\n        }\n    }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Attribute and Property Usage in Yew\nDESCRIPTION: Shows how to specify attributes and properties in Yew components\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/introduction.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet value = \"something\";\nhtml! { <div attribute={value} /> };\n```\n\n----------------------------------------\n\nTITLE: Creating a View Method for a Component - Rust\nDESCRIPTION: Illustrates the implementation of the view method in a Yew component, which uses the html! macro for rendering and handling click events.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/components/introduction.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Component, Context, html, Html, Properties};\n\nenum Msg {\n    Click,\n}\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    button_text: String,\n}\n\nstruct MyComponent;\n\nimpl Component for MyComponent {\n    type Message = Msg;\n    type Properties = Props;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    // highlight-start\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let onclick = ctx.link().callback(|_| Msg::Click);\n        html! {\n            <button {onclick}>{ &ctx.props().button_text }</button>\n        }\n    }\n    // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Define use_subscribe function\nDESCRIPTION: This code defines a function named `use_subscribe`. This function is intended to be a custom hook that encapsulates the logic for subscribing to an event source and managing received messages. It currently has an empty body and is expected to return `Rc<RefCell<Vec<String>>>`.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.21/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```rust\nfn use_subscribe() -> Rc<RefCell<Vec<String>>> {\n    // ...\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Routes Enum in Yew with yew-router\nDESCRIPTION: This code defines an enum named `Route` with variants representing different routes in the application. The `Routable` derive macro from the `yew_router` crate automatically implements the necessary traits for routing, allowing the `Switch` component to match URLs to the corresponding enum variants. The enum must implement `Clone + PartialEq`.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/router.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew_router::prelude::*;\n\n#[derive(Clone, Routable, PartialEq)]\nenum Route {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/secure\")]\n    Secure,\n    #[not_found]\n    #[at(\"/404\")]\n    NotFound,\n}\n```\n\n----------------------------------------\n\nTITLE: If-Let Pattern Matching in Yew\nDESCRIPTION: Demonstrates conditional rendering using if-let pattern matching for Option types within Yew templates\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/conditional-rendering.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nlet some_text = Some(\"text\");\n\nhtml! {\n    if let Some(text) = some_text {\n        <p>{ text }</p>\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Updating html! Macro Prop Syntax in Yew 0.19.0 (Rust)\nDESCRIPTION: Demonstrates the new requirement to enclose props with braces in the html! macro. Shows invalid and valid syntax, as well as a new shorthand initialization feature.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/migration-guides/yew/from-0_18_0-to-0_19_0.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet super_age = 1;\nhtml!{\n    <JapaneseYew\n        age=super_age // ! Will throw an error\n    >\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet super_age = 1;\nhtml!{\n    <JapaneseYew\n        age={super_age} // Correct\n    >\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet age = 1;\nhtml!{\n    <JapaneseYew\n        {age}\n    >\n}\n```\n\n----------------------------------------\n\nTITLE: Using NodeRef::cast with web-sys Elements\nDESCRIPTION: Shows how to use Yew's NodeRef::cast method to convert a generic Node reference to a specific HtmlInputElement type for more specific DOM manipulation.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::NodeRef;\n\nfn with_node_ref_cast(node_ref: NodeRef) {\n    if let Some(input) = node_ref.cast::<HtmlInputElement>() {\n        // do something with HtmlInputElement\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Properties for a Link Component in Rust using Yew\nDESCRIPTION: This code snippet demonstrates how to define properties for a Link component in the Yew framework. It includes examples of required and optional properties, default values, and the use of Rc for performance optimization.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.18.0/concepts/components/properties.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::rc::Rc;\nuse yew::Properties;\n\n#[derive(Clone, PartialEq)]\npub enum LinkColor {\n    Blue,\n    Red,\n    Green,\n    Black,\n    Purple,\n}\n\nimpl Default for LinkColor {\n    fn default() -> Self {\n        // The link color will be blue unless otherwise specified.\n        LinkColor::Blue\n    }\n}\n\n#[derive(Properties, Clone, PartialEq)]\npub struct LinkProps {\n    /// The link must have a target.\n    href: String,\n    /// If the link text is huge, this will make copying the string much cheaper.\n    /// This isn't usually recommended unless performance is known to be a problem.\n    text: Rc<String>,\n    /// Color of the link.\n    #[prop_or_default]\n    color: LinkColor,\n    /// The view function will not specify a size if this is None.\n    #[prop_or_default]\n    size: Option<u32>,\n    /// When the view function doesn't specify active, it defaults to true.\n    #[prop_or(true)]\n    active: bool,\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Generic Components in Rust with Yew\nDESCRIPTION: This code snippet shows how to define a generic function component in Yew. It creates a Props struct and a MyGenericComponent function that can work with any type T that implements PartialEq and ToHtml traits. The component renders the generic data within a paragraph element.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/function-components/generics.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt::Display;\nuse yew::{function_component, html, Properties, Html, ToHtml};\n\n#[derive(Properties, PartialEq)]\npub struct Props<T>\nwhere\n    T: PartialEq,\n{\n    data: T,\n}\n\n#[function_component]\npub fn MyGenericComponent<T>(props: &Props<T>) -> Html\nwhere\n    T: PartialEq + ToHtml,\n{\n    html! {\n        <p>\n            { &props.data }\n        </p>\n    }\n}\n\n// then can be used like this\nhtml! {\n    <MyGenericComponent<i32> data=123 />\n};\n\n// or\nhtml! {\n    <MyGenericComponent<String> data={\"foo\".to_string()} />\n};\n```\n\n----------------------------------------\n\nTITLE: Accessing Document Object in JavaScript and Rust\nDESCRIPTION: Demonstrates how to access the document object from the window in both JavaScript and Rust (using web-sys). The Rust version shows proper error handling with expect_throw to handle potential undefined values.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/basic-web-technologies/js.mdx#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nlet document = window.document\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::UnwrapThrowExt;\nuse web_sys::window;\n\nlet document = window()\n    .expect_throw(\"window is undefined\")\n    .document()\n    .expect_throw(\"document is undefined\");\n```\n\n----------------------------------------\n\nTITLE: Using #[prop_or_default] Attribute for Default Property Values\nDESCRIPTION: Shows how to use the #[prop_or_default] attribute to initialize properties with the default value of their type when not explicitly provided by the parent component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/function-components/properties.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    #[prop_or_default]\n    pub is_loading: bool,\n}\n\n#[function_component]\nfn HelloWorld(&Props { is_loading }: &Props) -> Html {\n    if is_loading {\n        html! { \"Loading\" }\n    } else {\n        html! { \"Hello world\" }\n    }\n}\n\n// Then use like this with default\n#[function_component]\nfn Case1() -> Html {\n    html! { <HelloWorld /> }\n}\n// Or no override the default\n#[function_component]\nfn Case2() -> Html {\n    html! { <HelloWorld is_loading=true /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Using gloo for Event Listeners in Yew\nDESCRIPTION: This snippet illustrates a more concise method for adding event listeners in Yew using the gloo library's EventListener type. It simplifies the process of managing event listeners tied to DOM elements.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/events.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlElement;\nuse yew::prelude::*;\n\nuse gloo::events::EventListener;\n\n#[function_component]\nfn MyComponent() -> Html {\n    let div_node_ref = use_node_ref();\n\n    use_effect_with(\n        div_node_ref.clone(),\n        {\n            let div_node_ref = div_node_ref.clone();\n\n            move |_| {\n                let mut custard_listener = None;\n\n                if let Some(element) = div_node_ref.cast::<HtmlElement>() {\n                    // Create your Callback as you normally would\n                    let oncustard = Callback::from(move |_: Event| {\n                        // do something about custard..\n                    });\n\n                    // Create an EventListener with gloo\n                    let listener = EventListener::new(\n                        &element,\n                        \"custard\",\n                        move |e| oncustard.emit(e.clone())\n                    );\n\n                    custard_listener = Some(listener);\n                }\n\n                move || drop(custard_listener)\n            }\n        }\n    );\n\n    html! {\n        <div ref={div_node_ref} id=\"my-div\"></div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Logging with tracing-web in Rust\nDESCRIPTION: This snippet demonstrates how to use the `tracing-web` crate with `tracing-subscriber` to output tracing messages to the browser console. It configures a fmt layer for standard output and a performance layer for detailed tracing, then initializes the tracing subscriber and logs a message including a `JsValue` converted to a string.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/more/debugging.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing_subscriber::{\n    fmt::{\n        format::{FmtSpan, Pretty},\n        time::UtcTime,\n    },\n    prelude::*,\n};\nuse wasm_bindgen::JsValue;\n\nfn main() {\n    let fmt_layer = tracing_subscriber::fmt::layer()\n        .with_ansi(false)\n        .with_timer(UtcTime::rfc_3339())\n        .with_writer(tracing_web::MakeConsoleWriter)\n        .with_span_events(FmtSpan::ACTIVE);\n    let perf_layer = tracing_web::performance_layer().with_details_from_fields(Pretty::default());\n\n    tracing_subscriber::registry()\n        .with(fmt_layer)\n        .with(perf_layer)\n        .init();\n    let object = JsValue::from(\"world\");\n    tracing::info!(\"Hello {}\", object.as_string().unwrap());\n}\n```\n\n----------------------------------------\n\nTITLE: Basic If Block Rendering in Yew\nDESCRIPTION: Demonstrates the simplest form of conditional rendering using an if block within Yew's html! macro\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/conditional-rendering.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    if true {\n        <p>{ \"True case\" }</p>\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Handling onchange event with Select element in Yew\nDESCRIPTION: This code demonstrates handling the `onchange` event for a `select` element in Yew. It uses `ChangeData::Select` to access the `web_sys::HtmlSelectElement`. The `batch_callback` is utilized to process the selected element, returning `None` if the event is not a `Select` event.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/events.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Html, ChangeData};\n\nfn view(&self) -> Html {\n\n    let onchange = self.link.batch_callback(|e| {\n        if let ChangeData::Select(select) = e {\n            // do something with web_sys::HtmlSelectElement\n        } else {\n            None\n        }\n    });\n\n    html! {\n        <div>\n            <select onchange={onchange}>\n                <option value=\"English\">{ \"Hello!\" }</option>\n                <option value=\"French\">{ \"Bonjour!\" }</option>\n                <option value=\"German\">{ \"Guten Tag!\" }</option>\n            </select>\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying VideosList Component to Emit Callback in Yew\nDESCRIPTION: This code modifies the `VideosList` component to emit the selected video to the `on_click` callback when a video is clicked. It creates a new callback `on_video_select` for each video and attaches it to the `onclick` event of the paragraph element. The `{2-4,6-12,15-16}` annotations are not included in the code.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\n#[function_component(VideosList)]\nfn videos_list(VideosListProps { videos, on_click }: &VideosListProps) -> Html {\n    let on_click = on_click.clone();\n    videos.iter().map(|video| {\n        let on_video_select = {\n            let on_click = on_click.clone();\n            let video = video.clone();\n            Callback::from(move |_| {\n                on_click.emit(video.clone())\n            })\n        };\n\n        html! {\n            <p key={video.id} onclick={on_video_select}>{format!(\"{}: {}\", video.speaker, video.title)}</p>\n        }\n    }).collect()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Manual Event Listeners with gloo-events in Yew\nDESCRIPTION: A more concise implementation of custom event listeners using the gloo-events crate, which provides better abstractions over web-sys and wasm-bindgen. This approach simplifies memory management as EventListener automatically removes the listener when dropped.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/events.mdx#2025-04-16_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nuse yew:{\n    html,\n    web_sys::{Event, HtmlElement},\n    Component, ComponentLink, Html, NodeRef,\n};\n\nuse gloo::events::EventListener;\n\npub struct Comp {\n    link: ComponentLink<Self>,\n    my_div: NodeRef,\n    custard_listener: Option<EventListener>,\n}\n\npub enum Msg {\n    Custard,\n}\n\nimpl Component for Comp {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_: Self::Properties, link: ComponentLink<Self>) -> Self {\n        Self {\n            link,\n            my_div: NodeRef::default(),\n            custard_listener: None,\n        }\n    }\n\n    fn update(&mut self, msg: Self::Message) -> bool {\n        match msg {\n            Msg::Custard => {\n                // do something about custard..\n                true\n            }\n        }\n    }\n\n    fn change(&mut self, _props: Self::Properties) -> yew::ShouldRender {\n        false\n    }\n\n    fn view(&self) -> Html {\n        html! {\n            <div ref={self.my_div.clone()} id=\"my-div\"></div>\n        }\n    }\n\n    fn rendered(&mut self, first_render: bool) {\n        if !first_render {\n            return;\n        }\n\n        if let Some(element) = self.my_div.cast::<HtmlElement>() {\n            // Create your Callback as you normally would\n            let oncustard = self.link.callback(|_: Event| Msg::Custard);\n\n            let listener =\n                EventListener::new(\n                    &element,\n                    \"custard\",\n                    move |e| oncustard.emit(e.clone())\n                );\n\n            self.custard_listener = Some(listener);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using classes! macro with an Array in Yew (Rust)\nDESCRIPTION: Shows how to use the classes! macro with an Array of class strings in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/classes.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!([\"class-1\", \"class-2\"])}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using Open-Close Tags with html! Macro in Rust\nDESCRIPTION: Demonstrates the proper syntax for using opening and closing tags with the html! macro in Yew. This shows how to create a div element with an id attribute.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nhtml! {\n  <div id=\"my_div\"></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using Vector for Classes in Yew\nDESCRIPTION: This snippet provides an example of applying multiple classes from a Rust vector to an HTML element using the `classes!` macro in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/classes.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(vec![\"class-1\", \"class-2\"])}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using classes! macro with Optional values in Yew\nDESCRIPTION: This snippet shows how to use the `classes!` macro with an `Option<String>` to conditionally apply a CSS class to a div element in Yew. It provides a way to include or exclude classes based on certain conditions. Requires the `yew` crate.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/classes.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(Some(\"class\"))} />\n};\n```\n\n----------------------------------------\n\nTITLE: Using classes! macro with a slice in Yew\nDESCRIPTION: Shows how to apply multiple CSS classes using an array slice with the classes! macro in Yew components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!([\"class-1\", \"class-2\"].as_ref())}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Spawning Local Futures in Rust with wasm-bindgen-futures\nDESCRIPTION: This snippet demonstrates the use of spawn_local from the wasm-bindgen-futures crate to execute a Rust future on the current thread without sending it to JavaScript. It leverages the web_sys::console for logging and involves an async function that constructs a string by appending a greeting. Dependencies include web_sys and wasm_bindgen_futures. Inputs include an async block, and the output is a console log of the final string.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/wasm-bindgen/wasm-bindgen.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::console;\nuse wasm_bindgen_futures::spawn_local;\n\nasync fn my_async_fn() -> String { String::from(\"Hello\") }\n\nspawn_local(async {\n    let mut string = my_async_fn().await;\n    string.push_str(\", world!\");\n    // console log \"Hello, world!\"\n    console::log_1(&string.into());\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Enum Typed Children for a List Component in Yew - Rust\nDESCRIPTION: This snippet implements a List component that allows for children defined by an enum. It uses the 'derive_more' crate for easier enum manipulation and demonstrates how to convert enums into Html.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/components/children.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{\n    html, html::ChildrenRenderer, virtual_dom::VChild, Component,\n    Context, Html, Properties,\n};\n\npub struct Primary;\n\nimpl Component for Primary {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"Primary\" }\n        }\n    }\n}\n\npub struct Secondary;\n\nimpl Component for Secondary {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"Secondary\" }\n        }\n    }\n}\n\n#[derive(Clone, derive_more::From, PartialEq)]\npub enum Item {\n    Primary(VChild<Primary>),\n    Secondary(VChild<Secondary>),\n}\n\n// Now, we implement `Into<Html>` so that yew knows how to render `Item`.\n#[allow(clippy::from_over_into)]\nimpl Into<Html> for Item {\n    fn into(self) -> Html {\n        match self {\n            Self::Primary(child) => child.into(),\n            Self::Secondary(child) => child.into(),\n        }\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: ChildrenRenderer<Item>,\n}\n\npub struct List;\n\nimpl Component for List {\n    type Message = ();\n    type Properties = ListProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"list\">\n                { for ctx.props().children.iter() }\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Nested Child Components with Modifiable Props in Yew\nDESCRIPTION: Example of manipulating child component properties dynamically\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/advanced-topics/children.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::rc::Rc;\nuse yew::prelude::*;\n\n#[derive(Clone, PartialEq, Properties)]\npub struct ListItemProps {\n    value: String,\n}\n\n#[function_component]\nfn ListItem(props: &ListItemProps) -> Html {\n    let ListItemProps { value } = props.clone();\n    html! {\n        <span>\n            {value}\n        </span>\n    }\n}\n\n#[derive(PartialEq, Properties)]\npub struct Props {\n    pub children: ChildrenWithProps<ListItem>,\n}\n\n#[function_component]\nfn List(props: &Props) -> Html {\n    let modified_children = props.children.iter().map(|mut item| {\n            let mut props = Rc::make_mut(&mut item.props);\n            props.value = format!(\"item-{}\", props.value);\n            item\n    });\n    html! { for modified_children }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating HTML from Video Vector\nDESCRIPTION: This snippet transforms the `videos` vector into `Html` by mapping each `Video` to a `<p>` element within the `html!` macro. The `key` attribute is added to assist Yew in efficiently tracking changes to the list.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n\"let videos = videos.iter().map(|video| html! {\n    <p key={video.id}>{format!(\\\"{}: {}\\\", video.speaker, video.title)}</p>\n}).collect::<Html>();\"\n```\n\n----------------------------------------\n\nTITLE: Creating Infinite Loops in Yew Lifecycles\nDESCRIPTION: This example demonstrates a potential infinite loop scenario within Yew's lifecycle methods. It occurs when a component attempts to update itself after every render, triggering a continuous re-rendering cycle. The `rendered` method sends a message to trigger an update which always returns `true`, causing `view` to be called again.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n```rust\nuse yew::{Context, Component, Html};\n\nstruct Comp;\n\nimpl Component for Comp {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn update(&mut self, _ctx: &Context<Self>, _msg: Self::Message) -> bool {\n        // 我们总是请求在任何消息上重新渲染\n        true\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        // 无论渲染什么都不重要\n        Html::default()\n    }\n\n    fn rendered(&mut self, ctx: &Context<Self>, _first_render: bool) {\n        // 请求使用此新消息更新组件\n        ctx.link().send_message(());\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Working with Optional Attributes in Yew HTML Elements\nDESCRIPTION: Demonstrates how to use optional values (Some(x) or None) for HTML attributes, allowing attributes to be conditionally included in the DOM.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/elements.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nlet maybe_id = Some(\"foobar\");\n\nhtml! {\n    <div id=maybe_id></div>\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nlet id = \"foobar\";\n\nhtml! {\n    <div id=id></div>\n}\n```\n\n----------------------------------------\n\nTITLE: ShowMessages Component with Custom Hook\nDESCRIPTION: This code defines a functional component `ShowMessages` that uses the custom hook `use_subscribe` to retrieve the messages. It then iterates over the messages and displays them in paragraph elements within a div.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.21/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n#[function_component(ShowMessages)]\npub fn show_messages() -> Html {\n    let state = use_subscribe();\n    let output = state.borrow().deref().into_iter().map(|it| html! { <p>{ it }</p> });\n\n    html! { <div>{ for output }</div> }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Using Literal Classes in Yew Components\nDESCRIPTION: Demonstrates how to use the classes! macro with a literal string to add a single class to an HTML element in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/classes.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n    <div class={classes!(\"container\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing State Management in App Component\nDESCRIPTION: This modified App component uses useState hook to track the selected video and displays the VideoDetails component conditionally. It passes a callback to the VideosList component to handle video selection.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\n#[function_component(App)]\nfn app() -> Html {\n    // ...\n    let selected_video = use_state(|| None);\n\n    let on_video_select = {\n        let selected_video = selected_video.clone();\n        Callback::from(move |video: Video| {\n            selected_video.set(Some(video))\n        })\n    };\n\n    let details = selected_video.as_ref().map(|video| html! {\n        <VideoDetails video={video.clone()} />\n    });\n\n    html! {\n        <>\n            <h1>{ \"RustConf Explorer\" }</h1>\n            <div>\n                <h3>{\"Videos to watch\"}</h3>\n                <VideosList videos={videos} on_click={on_video_select.clone()} />\n            </div>\n            { for details }\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating HTML Template for Yew\nDESCRIPTION: Basic HTML template required for a Yew application\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_5\n\nLANGUAGE: html\nCODE:\n```\n<!doctype html>\n<html>\n    <head>\n        <meta charset=\"utf-8\" />\n        <title>Yew App</title>\n    </head>\n    <body></body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Rendering Lists from Iterators in Yew Using for Syntax\nDESCRIPTION: Demonstrates Yew's alternative syntax for rendering lists using the 'for' keyword within the html! macro, which simplifies the process of mapping iterator items to HTML elements.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/lists.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nhtml! {\n    <ul class=\"item-list\">\n        { for self.props.items.iter().map(renderItem) }\n    </ul>\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating web-sys Type Inheritance in Rust\nDESCRIPTION: Shows how to traverse the inheritance chain of web-sys types using Deref trait, demonstrating the relationship between HtmlTextAreaElement and its parent types.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ops::Deref;\nuse web_sys::{\n    Element,\n    EventTarget,\n    HtmlElement,\n    HtmlTextAreaElement,\n    Node,\n};\n\nfn inheritance_of_text_area(text_area: HtmlTextAreaElement) {\n    // HtmlTextAreaElement is <textarea> in html.\n    let html_element: &HtmlElement = text_area.deref();\n\n    let element: &Element = html_element.deref();\n\n    let node: &Node = element.deref();\n\n    let event_target: &EventTarget = node.deref();\n\n    // Notice we've moved from web-sys types now into built-in\n    // JavaScript types which are in the js-sys crate.\n    let object: &js_sys::Object = event_target.deref();\n\n    // Notice we've moved from js-sys type to the root JsValue from\n    // the wasm-bindgen crate.\n    let js_value: &wasm_bindgen::JsValue = object.deref();\n\n    // Using deref like this means we have to manually traverse\n    // the inheritance tree, however, you can call JsValue methods\n    // on the HtmlTextAreaElement type.\n    // The `is_string` method comes from JsValue.\n    assert!(!text_area.is_string());\n\n    // empty function just to prove we can pass HtmlTextAreaElement as a\n    // &EventTarget.\n    fn this_function_only_takes_event_targets(targets: &EventTarget) {};\n\n    // The compiler will walk down the deref chain in order to match the types here.\n    this_function_only_takes_event_targets(&text_area);\n\n    // The AsRef implementations allow you to treat the HtmlTextAreaElement\n    // as an &EventTarget.\n\n    let event_target: &EventTarget = text_area.as_ref();\n\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Video Data Instances\nDESCRIPTION: Code to instantiate a collection of Video structs with sample data that will be used to populate the UI dynamically.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse website_test::tutorial::Video; // replace with your own path\n\nlet videos = vec![\n    Video {\n        id: 1,\n        title: \"Building and breaking things\".to_string(),\n        speaker: \"John Doe\".to_string(),\n        url: \"https://youtu.be/PsaFVLr8t4E\".to_string(),\n    },\n    Video {\n        id: 2,\n        title: \"The development process\".to_string(),\n        speaker: \"Jane Smith\".to_string(),\n        url: \"https://youtu.be/PsaFVLr8t4E\".to_string(),\n    },\n    Video {\n        id: 3,\n        title: \"The Web 7.0\".to_string(),\n        speaker: \"Matt Miller\".to_string(),\n        url: \"https://youtu.be/PsaFVLr8t4E\".to_string(),\n    },\n    Video {\n        id: 4,\n        title: \"Mouseless development\".to_string(),\n        speaker: \"Tom Jerry\".to_string(),\n        url: \"https://youtu.be/PsaFVLr8t4E\".to_string(),\n    },\n];\n```\n\n----------------------------------------\n\nTITLE: Importing console.log with wasm-bindgen in Rust\nDESCRIPTION: This snippet demonstrates how to use the #[wasm_bindgen] macro to import different variations of the console.log function from JavaScript into Rust. It shows how to bind to the console namespace and create multiple function signatures.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/basic-web-technologies/wasm-bindgen.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\nextern \"C\" {\n    #[wasm_bindgen(js_namespace = console)]\n    fn log(s: &str);\n\n    #[wasm_bindgen(js_namespace = console, js_name = log)]\n    fn log_u32(a: u32);\n\n    #[wasm_bindgen(js_namespace = console, js_name = log)]\n    fn log_many(a: &str, b: &str);\n}\n\nlog(\"Hello from Rust!\");\nlog_u32(42);\nlog_many(\"Logging\", \"many values!\");\n```\n\n----------------------------------------\n\nTITLE: Accessing Document Object in Rust using web-sys\nDESCRIPTION: Shows how to access the document object from the window in Rust using web-sys crate. It includes error handling for undefined window or document.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/js.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::UnwrapThrowExt;\nuse web_sys::window;\n\nlet document = window()\n    .expect_throw(\"window is undefined\")\n    .document()\n    .expect_throw(\"document is undefined\");\n```\n\n----------------------------------------\n\nTITLE: Optional Typed Child in Yew\nDESCRIPTION: This code demonstrates how to define a component that can optionally have a single child component of a specific type. It defines a `PageSideBar` component and a `Page` component that accepts an optional `PageSideBar` as a child.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/children.mdx#2025-04-16_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nuse yew::{\n    html, html_nested, virtual_dom::VChild, Component,\n    Context, Html, Properties\n};\n\npub struct PageSideBar;\n\nimpl Component for PageSideBar {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"sidebar\" }\n        }\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct PageProps {\n    #[prop_or_default]\n    pub sidebar: Option<VChild<PageSideBar>>,\n}\n\nstruct Page;\n\nimpl Component for Page {\n    type Message = ();\n    type Properties = PageProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"page\">\n                { ctx.props().sidebar.clone().map(Html::from).unwrap_or_default() }\n                // ... page content\n            </div>\n        }\n    }\n}\n\n// The page component can be called either with the sidebar or without:\n\npub fn render_page(with_sidebar: bool) -> Html {\n    if with_sidebar {\n        // Page with sidebar\n        html! {\n            <Page sidebar={html_nested! {\n                <PageSideBar />\n            }} />\n        }\n    } else {\n        // Page without sidebar\n        html! {\n            <Page />\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling DOM Events with Callbacks in Yew\nDESCRIPTION: Demonstrates how to use callbacks to respond to DOM events like button clicks in Yew. The callback is triggered when the user interacts with the specified element.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/function-components/callbacks.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties, Callback};\n\n#[function_component]\nfn App() -> Html {\n    let onclick = Callback::from(move |_| {\n        let greeting = String::from(\"Hi there\");\n        // web_sys::console::log_1(&greeting.into()); // if uncommented will print\n    });\n\n    html! {\n        <button {onclick}>{ \"Click\" }</button>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Yew Mouse Event Handling with Callback\nDESCRIPTION: Demonstrates Yew-specific approach to mouse event handling using Callback and web-sys\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/wasm-bindgen/web-sys.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{console, HtmlElement, MouseEvent};\nuse yew::\n    html,\n    Callback, TargetCast,\n};\n\nlet onmousemove = Callback::from(|e: MouseEvent| {\n    if let Some(target) = e.target_dyn_into::<HtmlElement>() {\n        let rect = target.get_bounding_client_rect();\n        let x = (e.client_x() as f64) - rect.left();\n        let y = (e.client_y() as f64) - rect.top();\n        console::log_1(&format!(\"Left? : {} ; Top? : {}\", x, y).into());\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Using NodeRef with Input Elements in Yew\nDESCRIPTION: This code snippet showcases the use of NodeRef for direct access to an input element's value in a Yew functional component. The onchange handler retrieves the input value without referring to the event, allowing for cleaner state management.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/events.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::prelude::*;\n\n#[function_component]\nfn MyComponent() -> Html {\n    //highlight-next-line\n    let input_node_ref = use_node_ref();\n\n    let input_value_handle = use_state(String::default);\n    let input_value = (*input_value_handle).clone();\n\n    let onchange = {\n        let input_node_ref = input_node_ref.clone();\n\n        Callback::from(move |_| {\n            //highlight-next-line\n            let input = input_node_ref.cast::<HtmlInputElement>();\n\n            if let Some(input) = input {\n                input_value_handle.set(input.value());\n            }\n        })\n    };\n\n    html! {\n        <> \n            <label for=\"my-input\">\n                { \"My input:\" }\n                //highlight-next-line\n                <input ref={input_node_ref}\n                    {onchange}\n                    id=\"my-input\"\n                    type=\"text\"\n                    value={input_value}\n                />\n            </label>\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Typed Event Target Handling with JsCast in Yew\nDESCRIPTION: This code demonstrates how to handle typed event targets in Yew using the JsCast trait. It shows both cautious and dangerous approaches for casting event targets to specific HTML element types.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/events.mdx#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::JsCast;\nuse yew::\n    html,\n    web_sys::{EventTarget, HtmlInputElement},\n    Component, ComponentLink, Html, InputData,\n};\n\npub struct Comp {\n    link: ComponentLink<Self>,\n}\n\npub enum Msg {\n    InputValue(f64),\n}\n\nimpl Component for Comp {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_: Self::Properties, link: ComponentLink<Self>) -> Self {\n        Self { link }\n    }\n\n    fn update(&mut self, msg: Self::Message) -> yew::ShouldRender {\n        let Msg::InputValue(value) = msg;\n        // do something with value\n        todo!()\n    }\n\n    fn change(&mut self, _props: Self::Properties) -> yew::ShouldRender {\n        false\n    }\n\n    fn view(&self) -> Html {\n        let link = &self.link;\n\n        // Use batch_callback so if something unexpected happens we can return\n        // None and do nothing\n        let on_cautious_change = link.batch_callback(|e: InputData| {\n            let e = e.event;\n            // When events are created the target is undefined, it's only\n            // when dispatched does the target get added.\n            let target: Option<EventTarget> = e.target();\n            // Events can bubble so this listener might catch events from child\n            // elements which are not of type HtmlInputElement\n            let input = target.and_then(|t| t.dyn_into::<HtmlInputElement>().ok());\n\n            input.map(|input| Msg::InputValue(input.value_as_number()))\n        });\n\n        let on_dangerous_change = link.callback(|e: InputData| {\n            let e = e.event;\n            let target: EventTarget = e\n                .target()\n                .expect(\"Event should have a target when dispatched\");\n            // You must KNOW target is a HtmlInputElement, otherwise\n            // the call to value would be Undefined Behaviour (UB).\n            Msg::InputValue(\n                target\n                    .unchecked_into::<HtmlInputElement>()\n                    .value_as_number(),\n            )\n        });\n\n        html! {\n            <>\n                <label for=\"cautious-input\">\n                    { \"My cautious input:\" }\n                    <input oninput={on_cautious_change}\n                        id=\"cautious-input\"\n                        type=\"text\"\n                    />\n                </label>\n                <label for=\"dangerous-input\">\n                    { \"My dangerous input:\" }\n                    <input oninput={on_dangerous_change}\n                        id=\"dangerous-input\"\n                        type=\"text\"\n                    />\n                </label>\n            </>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Navigator API in Yew Function Components\nDESCRIPTION: Demonstrates how to use the Navigator API for programmatic navigation in Yew function components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/router.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew_router::prelude::*;\n\n#[function_component(NavItems)]\npub fn nav_items() -> Html {\n    let navigator = use_navigator().unwrap();\n\n    let go_home_button = {\n        let navigator = navigator.clone();\n        let onclick = Callback::from(move |_| navigator.push(&Route::Home));\n        html! {\n            <button {onclick}>{\"click to go home\"}</button>\n        }\n    };\n\n    let go_to_first_post_button = {\n        let navigator = navigator.clone();\n        let onclick = Callback::from(move |_| navigator.push(&Route::Post { id: \"first-post\".to_string() }));\n        html! {\n            <button {onclick}>{\"click to go the first post\"}</button>\n        }\n    };\n\n    let go_to_secure_button = {\n        let onclick = Callback::from(move |_| navigator.push(&Route::Secure));\n        html! {\n            <button {onclick}>{\"click to go to secure\"}</button>\n        }\n    };\n\n    html! {\n        <>\n            {go_home_button}\n            {go_to_first_post_button}\n            {go_to_secure_button}\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Typed Event Target Handling with NodeRef in Yew\nDESCRIPTION: This code snippet demonstrates how to handle typed event targets in Yew using NodeRef. It shows how to use NodeRef to directly access the input element without querying the event.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/events.mdx#2025-04-16_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, web_sys::HtmlInputElement, Component, ComponentLink, Html, NodeRef};\n\npub struct Comp {\n    link: ComponentLink<Self>,\n    my_input: NodeRef,\n}\n\npub enum Msg {\n    InputValue(f64),\n}\n\nimpl Component for Comp {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_: Self::Properties, link: ComponentLink<Self>) -> Self {\n        Self {\n            link,\n            my_input: NodeRef::default(),\n        }\n    }\n\n    fn update(&mut self, msg: Self::Message) -> yew::ShouldRender {\n        let Msg::InputValue(value) = msg;\n        // do something with value\n        todo!()\n    }\n\n    fn change(&mut self, _props: Self::Properties) -> yew::ShouldRender {\n        false\n    }\n\n    fn view(&self) -> Html {\n        let my_input_ref = self.my_input.clone();\n\n        let oninput = self.link.batch_callback(move |_| {\n            let input = my_input_ref.cast::<HtmlInputElement>();\n\n            input.map(|input| Msg::InputValue(input.value_as_number()))\n        });\n\n        html! {\n            <>\n                <label for=\"my-input\">\n                    { \"My input:\" }\n                    <input ref={self.my_input.clone()}\n                        oninput={oninput}\n                        id=\"my-input\"\n                        type=\"text\"\n                    />\n                </label>\n            </>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering Example in Yew\nDESCRIPTION: This code snippet demonstrates how to conditionally render HTML elements using an `if` statement within the `html!` macro in Yew. It shows rendering a paragraph element based on a boolean condition. It requires the `yew` crate to be included.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/introduction.mdx#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n  if true {\n      <p>{ \"True case\" }</p>\n  }\n};\n\n```\n\n----------------------------------------\n\nTITLE: Yew Hook Usage Example: After Migration (Rust)\nDESCRIPTION: This Rust code snippet shows the updated usage of the 'use_effect_with' hook in Yew 0.21.0. It demonstrates the new, more ergonomic syntax where dependencies are passed as the first argument.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/migration-guides/yew/from-0_20_0-to-0_21_0.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nimpl SomeLargeStruct {\n    fn id(&self) -> u32; // Only need to use the id as cache key\n}\nlet some_dep: SomeLargeStruct = todo!();\n\nuse_effect_with(some_dep.id(), move |_| { todo!(); drop(some_dep); });\n```\n\n----------------------------------------\n\nTITLE: Using classes! macro with multiple classes in Yew (Rust)\nDESCRIPTION: Shows how to use the classes! macro to apply multiple classes to an HTML element in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/classes.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(\"class-1\", \"class-2\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Message Enum for Input Value Updates in Rust\nDESCRIPTION: This code snippet defines a simple enum for updating input values in a Yew component. It represents the message type used for component updates.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/events.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\npub enum Msg {\n    InputValue(f64),\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Messages with Yew Component\nDESCRIPTION: This Rust code demonstrates a Yew component that subscribes to an EventBus agent and displays messages received. The component uses several Yew hooks such as use_state and use_effect to manage state and lifecycle events. Dependencies include yew and yew_agent libraries, and a user-defined EventBus agent. The function does not take parameters but iterates over collected messages and displays them in HTML paragraphs.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/function-components/custom-hooks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, use_effect, use_state, Callback};\nuse yew_agent::Bridged;\n// EventBus is an implementation yew_agent::Agent\nuse website_test::agents::EventBus;\n\n\n#[function_component(ShowMessages)]\npub fn show_messages() -> Html {\n    let state = use_state(Vec::new);\n\n    {\n        let state = state.clone();\n        use_effect(move || {\n            let producer = EventBus::bridge(Callback::from(move |msg| {\n                let mut messages = (*state).clone();\n                messages.push(msg);\n                state.set(messages)\n            }));\n\n            || drop(producer)\n        });\n    }\n\n    let output = state.iter().map(|it| html! { <p>{ it }</p> });\n    html! { <div>{ for output }</div> }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Yew Component\nDESCRIPTION: This code snippet demonstrates how to create a Yew component, implementing the `Component` trait and defining the `create` lifecycle method. The `create` method is called when the component is first initialized, and it receives the initial properties passed from the parent component through the context.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse yew::{Component, Context, html, Html, Properties};\n\n#[derive(PartialEq, Properties)]\npub struct Props;\n\npub struct MyComponent;\n\nimpl Component for MyComponent {\n    type Message = ();\n    type Properties = Props;\n\n    // highlight-start\n    fn create(ctx: &Context<Self>) -> Self {\n        MyComponent\n    }\n    // highlight-end\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            // 具体实现\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Mouse position tracking with Yew and web-sys\nDESCRIPTION: This example shows how to implement mouse position tracking using Yew's Callback system with web-sys, which is more idiomatic for Yew applications than the raw web-sys approach.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies.web-sys]\nversion = \"0.3\"\n# We need to enable the `DomRect` feature to use the\n# `get_bounding_client_rect` method.\nfeatures = [\n    \"console\",\n    \"HtmlElement\",\n    \"MouseEvent\",\n    \"DomRect\",\n]\n\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{console, HtmlElement, MouseEvent};\nuse yew:{\n    html,\n    Callback, TargetCast,\n};\n\nlet onmousemove = Callback::from(|e: MouseEvent| {\n    if let Some(target) = e.target_dyn_into::<HtmlElement>() {\n        let rect = target.get_bounding_client_rect();\n        let x = (e.client_x() as f64) - rect.left();\n        let y = (e.client_y() as f64) - rect.top();\n        console::log_1(&format!(\"Left? : {} ; Top? : {}\", x, y).into());\n    }\n});\n\nhtml! {\n    <div id=\"mousemoveme\" {onmousemove}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using yew-autoprops for Automatic Properties Generation\nDESCRIPTION: Example of using the #[autoprops] macro from yew-autoprops package to automatically generate Properties structures based on the function component parameters.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/function-components/properties.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew_autoprops::autoprops;\n\n// #[autoprops] 巨集必須出現在 #[function_component] 之前，順序很重要\n#[autoprops]\n#[function_component]\nfn Greetings(\n    #[prop_or_default]\n    is_loading: bool,\n    #[prop_or(AttrValue::Static(\"Hello\"))]\n    message: &AttrValue,\n    #[prop_or(AttrValue::Static(\"World\"))]\n    name: &AttrValue,\n) -> Html {\n    if is_loading {\n        html! { \"Loading\" }\n    } else {\n        html! { <>{message}{\" \"}{name}</> }\n    }\n}\n\n// 結構體 \"GreetingsProps\" 將會自動產生。\n//\n// `is_loading` 將作為值傳遞給元件，而 `message` 和 `name` 將使用引用，因為定義中有一個前導的 `&`。\n```\n\n----------------------------------------\n\nTITLE: Creating Video Instances in Yew - Rust\nDESCRIPTION: This snippet initializes a vector of Video structs to represent the video data for the application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nlet videos = vec![\n    Video {\n        id: 1,\n        title: \"Building and breaking things\".to_string(),\n        speaker: \"John Doe\".to_string(),\n        url: \"https://youtu.be/PsaFVLr8t4E\".to_string(),\n    },\n    Video {\n        id: 2,\n        title: \"The development process\".to_string(),\n        speaker: \"Jane Smith\".to_string(),\n        url: \"https://youtu.be/PsaFVLr8t4E\".to_string(),\n    },\n    Video {\n        id: 3,\n        title: \"The Web 7.0\".to_string(),\n        speaker: \"Matt Miller\".to_string(),\n        url: \"https://youtu.be/PsaFVLr8t4E\".to_string(),\n    },\n    Video {\n        id: 4,\n        title: \"Mouseless development\".to_string(),\n        speaker: \"Tom Jerry\".to_string(),\n        url: \"https://youtu.be/PsaFVLr8t4E\".to_string(),\n    },\n];\n```\n\n----------------------------------------\n\nTITLE: Defining Associated Types for Yew Components\nDESCRIPTION: This snippet illustrates how to define associated types in Yew components, specifically for messages and properties for effective communication and state management.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nimpl Component for MyComponent {\n    type Message = Msg;\n    type Properties = Props;\n\n    // ...\n}\n\nenum Msg {\n    Click,\n    FormInput(String)\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Element Properties in Yew\nDESCRIPTION: Shows how to set properties on elements using the tilde (~) syntax with the `html!` macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/introduction.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! { <my-element ~property=\"abc\" /> };\n```\n\n----------------------------------------\n\nTITLE: Defining Component Properties in Rust for Yew Framework\nDESCRIPTION: This code snippet demonstrates how to define properties for a component in the Yew framework. It includes examples of optional properties, default values, and using Rc for efficient cloning of large data.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.20/advanced-topics/struct-components/properties.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::rc::Rc;\nuse yew::Properties;\n\n#[derive(Clone, PartialEq)]\npub enum LinkColor {\n    Blue,\n    Red,\n    Green,\n    Black,\n    Purple,\n}\n\nimpl Default for LinkColor {\n    fn default() -> Self {\n        // The link color will be blue unless otherwise specified.\n        LinkColor::Blue\n    }\n}\n\n#[derive(Properties, Clone, PartialEq)]\npub struct LinkProps {\n    /// The link must have a target.\n    href: String,\n    /// If the link text is huge, this will make copying the string much cheaper.\n    /// This isn't usually recommended unless performance is known to be a problem.\n    text: Rc<String>,\n    /// Color of the link.\n    #[prop_or_default]\n    color: LinkColor,\n    /// The view function will not specify a size if this is None.\n    #[prop_or_default]\n    size: Option<u32>,\n    /// When the view function doesn't specify active, it defaults to true.\n    #[prop_or(true)]\n    active: bool,\n}\n```\n\n----------------------------------------\n\nTITLE: Yew Router with Path Segments\nDESCRIPTION: This code snippet shows how to define routes with dynamic path segments using yew-router. The `Post { id: String }` route captures the value of the `id` segment and makes it available in the `route` parameter within the `switch` function. The route also defines a catch-all route, using a wildcard.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/router.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew_router::prelude::*;\n\n#[derive(Clone, Routable, PartialEq)]\nenum Route {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/post/:id\")]\n    Post { id: String },\n    #[at(\"/*path\")]\n    Misc { path: String },\n}\n\nfn switch(route: Route) -> Html {\n    match route {\n        Route::Home => html! { <h1>{ \"Home\" }</h1> },\n        Route::Post { id } => html! {<p>{format!(\"You are looking at Post {}\", id)}</p>},\n        Route::Misc { path } => html! {<p>{format!(\"Matched some other path: {}\", path)}</p>},\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Component Usage in Yew\nDESCRIPTION: Demonstrates how to use the `html!` macro to render components in Yew, including components without properties, with explicit properties, and with the 'with props' syntax.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/components.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nhtml! {\n    <>\n        // No properties\n        <MyComponent />\n\n        // With Properties\n        <MyComponent prop1=\"lorem\" prop2=\"ipsum\" />\n\n        // With the whole set of props provided at once\n        <MyComponent with props />\n    </>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Component Update in Yew\nDESCRIPTION: Example demonstrating the update lifecycle method implementation which handles component messages and state updates.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Component, Context, html, Html};\n\npub enum Msg {\n    SetInputEnabled(bool)\n}\n\nstruct MyComponent {\n    input_enabled: bool,\n}\n\nimpl Component for MyComponent {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            input_enabled: false,\n        }\n    }\n\n    fn update(&mut self, _ctx: &Context<Self>, msg: Self::Message) -> bool {\n        match msg {\n            Msg::SetInputEnabled(enabled) => {\n                if self.input_enabled != enabled {\n                    self.input_enabled = enabled;\n                    true // Re-render\n                } else {\n                    false\n                }\n            }\n        }\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            // impl\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ConsoleService for logging in Rust\nDESCRIPTION: This snippet demonstrates how to use the `ConsoleService` from the Yew framework for logging information. It formats a message using `format!` and then logs it using `ConsoleService::info`.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.21/more/debugging.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// usage\nConsoleService::info(format!(\"Update: {:?}\", msg).as_ref());\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Lists from Iterators in Yew Using collect\nDESCRIPTION: Shows how to render a list from an iterator in Yew by mapping items to HTML and collecting the result into an Html type, which is then inserted into the html! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/lists.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Html};\n\nhtml! {\n    <ul class=\"item-list\">\n        { self.props.items.iter().map(renderItem).collect::<Html>() }\n    </ul>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Function Component Template for JetBrains IDEs in Rust\nDESCRIPTION: A template for creating Yew function components in JetBrains IDEs. This template includes a Properties struct and a function component that returns HTML. It can be added as a Live Template in JetBrains IDEs.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/getting-started/editor-setup.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(PartialEq, Properties)]\npub struct $Name$Props {\n}\n\n#[function_component]\npub fn $Name$(props: &$Name$Props) -> Html {\n    html! {\n        <$tag$>$END$</$tag$>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Constants as Text in Yew\nDESCRIPTION: This snippet demonstrates how to display constants (string literals and numeric literals) as text within a Yew component using the HTML macro. The constants are embedded within `{}` blocks, which are then converted to `Text` nodes in the DOM.  It requires the Yew framework to be setup.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.20/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet text = \"lorem ipsum\";\nhtml!{\n    <>\n        <div>{text}</div>\n        <div>{\"dolor sit\"}</div>\n        <span>{42}</span>\n    </>\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Nested HTML Structure in Yew\nDESCRIPTION: Illustrates creating a complex nested HTML layout using Yew's html! macro, including various form elements and attributes.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/introduction.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <div>\n        <div data-key=\"abc\"></div>\n        <div class=\"parent\">\n            <span class=\"child\" value=\"anything\"></span>\n            <label for=\"first-name\">{ \"First Name\" }</label>\n            <input type=\"text\" id=\"first-name\" value=\"placeholder\" />\n            <input type=\"checkbox\" checked=true />\n            <textarea value=\"write a story\" />\n            <select name=\"status\">\n                <option selected=true disabled=false value=\"\">{ \"Selected\" }</option>\n                <option selected=false disabled=true value=\"\">{ \"Unselected\" }</option>\n            </select>\n        </div>\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Video Data Structure\nDESCRIPTION: Creation of a Video struct to represent video data in a structured way, which will be used to generate the UI dynamically instead of hardcoding values.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nstruct Video {\n    id: usize,\n    title: String,\n    speaker: String,\n    url: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Typed Children Components with Props in Yew\nDESCRIPTION: Shows how to create components with typed children, allowing access and mutation of nested component properties. Demonstrates advanced parent-child component relationships with ChildrenWithProps.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/components.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::rc::Rc;\nuse yew::prelude::*;\n\n#[derive(Clone, PartialEq, Properties)]\npub struct ListItemProps {\n    value: String,\n}\n\n#[function_component]\nfn ListItem(props: &ListItemProps) -> Html {\n    let ListItemProps { value } = props.clone();\n    html! {\n        <span>\n            {value}\n        </span>\n    }\n}\n\n#[derive(PartialEq, Properties)]\npub struct Props {\n    pub children: ChildrenWithProps<ListItem>,\n}\n\n#[function_component]\nfn List(props: &Props) -> Html {\n    let modified_children = props.children.iter().map(|mut item| {\n            let mut props = Rc::make_mut(&mut item.props);\n            props.value = format!(\"item-{}\", props.value);\n            item\n    });\n    html! { for modified_children }\n}\n\nhtml! {\n    <List>\n        <ListItem value=\"a\" />\n        <ListItem value=\"b\" />\n        <ListItem value=\"c\" />\n    </List>\n};\n```\n\n----------------------------------------\n\nTITLE: Understanding Web API Inheritance with web-sys in Rust\nDESCRIPTION: Demonstrates how to navigate the inheritance hierarchy of Web API objects in web-sys using Deref trait. Shows the inheritance chain from HtmlTextAreaElement down to JsValue and how to utilize type conversion for function parameters.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/wasm-bindgen/web-sys.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ops::Deref;\nuse web_sys:{\n    Element,\n    EventTarget,\n    HtmlElement,\n    HtmlTextAreaElement,\n    Node,\n};\n\nfn inheritance_of_text_area(text_area: HtmlTextAreaElement) {\n    // HtmlTextAreaElement is <textarea> in html.\n    let html_element: &HtmlElement = text_area.deref();\n\n    let element: &Element = html_element.deref();\n\n    let node: &Node = element.deref();\n\n    let event_target: &EventTarget = node.deref();\n\n    // Notice we've moved from web-sys types now into built-in\n    // JavaScript types which are in the js-sys crate.\n    let object: &js_sys::Object = event_target.deref();\n\n    // Notice we've moved from js-sys type to the root JsValue from\n    // the wasm-bindgen crate.\n    let js_value: &wasm_bindgen::JsValue = object.deref();\n\n    // Using deref like this means we have to manually traverse\n    // the inheritance tree, however, you can call JsValue methods\n    // on the HtmlTextAreaElement type.\n    // The `is_string` method comes from JsValue.\n    assert!(!text_area.is_string());\n\n    // empty function just to prove we can pass HtmlTextAreaElement as a\n    // &EventTarget.\n    fn this_function_only_takes_event_targets(targets: &EventTarget) {};\n\n    // The compiler will walk down the deref chain in order to match the types here.\n    this_function_only_takes_event_targets(&text_area);\n\n    // The AsRef implementations allow you to treat the HtmlTextAreaElement\n    // as an &EventTarget.\n\n    let event_target: &EventTarget = text_area.as_ref();\n\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Component Callbacks in Rust using Yew Scope\nDESCRIPTION: Demonstrates how to create and use callbacks in a Yew component using the Scope API. Shows both verbose and simplified callback creation, message handling, and component structure.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/advanced-topics/struct-components/scope.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html};\n\nenum Msg {\n    Text(String),\n}\n\nstruct Comp;\n\nimpl Component for Comp {\n\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        // Create a callback that accepts some text and sends it\n        // to the component as the `Msg::Text` message variant.\n        // highlight-next-line\n        let cb = ctx.link().callback(|text: String| Msg::Text(text));\n\n        // The previous line is needlessly verbose to make it clearer.\n        // It can be simplified it to this:\n        // highlight-next-line\n        let cb = ctx.link().callback(Msg::Text);\n\n        // Will send `Msg::Text(\"Hello World!\")` to the component.\n        // highlight-next-line\n        cb.emit(\"Hello World!\".to_owned());\n\n        html! {\n            // html here\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Properties with Attributes in Yew\nDESCRIPTION: Example of creating a LinkProps struct with various property types and attribute options including required props, default values using different strategies, and performance optimization using Rc for large string values.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/components/properties.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::rc::Rc;\nuse yew::Properties;\n\n#[derive(Clone, PartialEq)]\npub enum LinkColor {\n    Blue,\n    Red,\n    Green,\n    Black,\n    Purple,\n}\n\nfn create_default_link_color() -> LinkColor {\n    LinkColor::Blue\n}\n\n#[derive(Properties, Clone, PartialEq)]\npub struct LinkProps {\n    /// The link must have a target.\n    href: String,\n    /// If the link text is huge, this will make copying the string much cheaper.\n    /// This isn't usually recommended unless performance is known to be a problem.\n    text: Rc<str>,\n    /// Color of the link. Defaults to `Blue`.\n    #[prop_or_else(create_default_link_color)]\n    color: LinkColor,\n    /// The view function will not specify a size if this is None.\n    #[prop_or_default]\n    size: Option<u32>,\n    /// When the view function doesn't specify active, it defaults to true.\n    #[prop_or(true)]\n    active: bool,\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Classes in Yew Component\nDESCRIPTION: Shows how to add multiple class names using the classes! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/classes.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(\"class-1\", \"class-2\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Component that Accepts Classes in Yew\nDESCRIPTION: Demonstrates how to create a function component that accepts classes as a property, combines them with its own classes, and conditionally applies additional classes based on props.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/classes.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    #[prop_or_default]\n    class: Classes,\n    fill: bool,\n    children: Html,\n}\n\n#[function_component]\nfn MyComponent(props: &Props) -> Html {\n    let Props {\n        class,\n        fill,\n        children,\n    } = props;\n    html! {\n        <div\n            class={classes!(\n                \"my-container-class\",\n                fill.then(|| Some(\"my-fill-class\")),\n                class.clone(),\n            )}\n        >\n            { children.clone() }\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Keyed List - Rust\nDESCRIPTION: This snippet demonstrates rendering a keyed list. The `key` attribute is used to provide a unique identifier for each element in the list, enabling Yew to optimize re-rendering when the list changes. Keys are required for all child elements within the keyed list.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/html/lists.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n```rust\nuse yew::prelude::*;\n\nlet names = vec![\"Sam\",\"Bob\",\"Ray\"]\n\nhtml! {\n    <div id=\"introductions\">\n        {\n            names.into_iter().map(|name| {\n                html!{<div key={name}>{ format!(\"Hello, I'am {}!\",name) }</div>}\n            }).collect::<Html>()\n        }\n    </div>\n};\n\n```\n```\n\n----------------------------------------\n\nTITLE: Using the Link Component for In-App Navigation\nDESCRIPTION: Demonstrates the Link component which renders as an anchor element but prevents the default behavior and instead uses the router to navigate within the application without page reload.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/router.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n<Link<Route> to={Route::Home}>{ \"click here to go home\" }</Link<Route>>\n```\n\n----------------------------------------\n\nTITLE: If-Else Conditional Rendering in Yew\nDESCRIPTION: Shows how to implement conditional rendering with both true and false cases using if-else blocks in Yew\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/conditional-rendering.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nlet some_condition = true;\n\nhtml! {\n    if some_condition {\n        <p>{ \"True case\" }</p>\n    } else {\n        <p>{ \"False case\" }</p>\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Function-Based Default Props Using prop_or_else in Yew\nDESCRIPTION: Example showing how to use prop_or_else attribute to set default values using a function.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/function-components/properties.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties};\n\nfn create_default_name() -> String {\n    \"Bob\".to_string()\n}\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    #[prop_or_else(create_default_name)]\n    pub name: String,\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n    html! {<>{\"Hello world\"}{props.name.clone()}</>}\n}\n\n#[function_component]\nfn Case1() -> Html {\n    html! {<HelloWorld />}\n}\n\n#[function_component]\nfn Case2() -> Html {\n    html! {<HelloWorld name={\"Sam\".to_string()} />}\n}\n```\n\n----------------------------------------\n\nTITLE: Component with Class Properties in Yew\nDESCRIPTION: Demonstrates creating a component that accepts and manages class properties, including default classes and conditional class application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/classes.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    #[prop_or_default]\n    class: Classes,\n    fill: bool,\n    children: Children,\n}\n\n#[function_component]\nfn MyComponent(props: &Props) -> Html {\n    let Props {\n        class,\n        fill,\n        children,\n    } = props;\n    html! {\n        <div\n            class={classes!(\n                \"my-container-class\",\n                fill.then(|| Some(\"my-fill-class\")),\n                class.clone(),\n            )}\n        >\n            { children.clone() }\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Video Struct and VideosList Component in Rust\nDESCRIPTION: This snippet defines a Video struct and creates a VideosList function component that renders a list of videos. It demonstrates how to define props for a component and use them to render dynamic content.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/tutorial/index.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nstruct Video {\n    id: usize,\n    title: String,\n    speaker: String,\n    url: String,\n}\n\n#[derive(Clone, Properties, PartialEq)]\nstruct VideosListProps {\n    videos: Vec<Video>,\n}\n\n#[function_component(VideosList)]\nfn videos_list(VideosListProps { videos }: &VideosListProps) -> Html {\n    videos.iter().map(|video| html! {\n        <p>{format!(\"{}: {}\", video.speaker, video.title)}</p>\n    }).collect()\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Keyboard Event Handling in Yew 0.19.0\nDESCRIPTION: How to handle keyboard events directly with Yew callbacks instead of using the deprecated KeyboardService.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/migration-guides/yew/from-0_18_0-to-0_19_0.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet onkeydown = Callback::from(|e| {\n    e.prevent_default();\n    todo!(\"use `e`, just like in service methods.\");\n});\nhtml! {\n    <input {onkeydown} />\n}\n```\n\n----------------------------------------\n\nTITLE: String-based Classes in Yew\nDESCRIPTION: Demonstrates using a String variable containing space-separated class names with the classes! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/classes.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nlet my_classes = String::from(\"class-1 class-2\");\n\nhtml! {\n  <div class={classes!(my_classes)}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Valid HTML Fragment Usage\nDESCRIPTION: Demonstrates the correct way to render multiple elements using fragments (<></>) as a wrapper, which allows multiple elements to be rendered without producing an additional HTML element.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/basic-web-technologies/html.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\n// fixed: using HTML fragments\nhtml! {\n    <>\n        <div></div>\n        <p></p>\n    </>\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Context-Based Higher-Order Component in Yew\nDESCRIPTION: A Rust example showing how to create a higher-order component that retrieves context and passes it to a structural component. The HOC wraps another component to provide context-related functionality.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/advanced-topics/struct-components/hoc.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(Clone, Debug, PartialEq)]\nstruct Theme {\n    foreground: String,\n    background: String,\n}\n\n#[function_component]\npub fn App() -> Html {\n    let ctx = use_state(|| Theme {\n        foreground: \"#000000\".to_owned(),\n        background: \"#eeeeee\".to_owned(),\n    });\n\n    html! {\n        <ContextProvider<Theme> context={(*ctx).clone()}>\n            <ThemedButtonHOC />\n        </ContextProvider<Theme>>\n    }\n}\n\n#[function_component]\npub fn ThemedButtonHOC() -> Html {\n    let theme = use_context::<Theme>().expect(\"no ctx found\");\n\n    html! {<ThemedButtonStructComponent {theme} />}\n}\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub theme: Theme,\n}\n\nstruct ThemedButtonStructComponent;\n\nimpl Component for ThemedButtonStructComponent {\n    type Message = ();\n    type Properties = Props;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let theme = &ctx.props().theme;\n        html! {\n            <button style={format!(\n                    \"background: {}; color: {};\",\n                    theme.background,\n                    theme.foreground\n                )}\n            >\n                { \"Click me!\" }\n            </button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using JsCast to Convert JavaScript Types\nDESCRIPTION: This snippet illustrates how the JsCast trait can be used for type casting between JavaScript types. It demonstrates obtaining an event target and conditionally casting it to specific HTML element types to call their methods.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/wasm-bindgen/introduction.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// need to import the trait.\nuse wasm_bindgen::JsCast;\nuse web_sys::{Event, EventTarget, HtmlInputElement, HtmlSelectElement};\n\nfn handle_event(event: Event) {\n    let target: EventTarget = event\n        .target()\n        .expect(\"I'm sure this event has a target!\");\n\n    // maybe the target is a select element?\n    if let Some(select_element) = target.dyn_ref::<HtmlSelectElement>() {\n        // do something amazing here\n        return;\n    }\n\n    // if it wasn't a select element then I KNOW it's a input element!\n    let input_element: HtmlInputElement = target.unchecked_into();\n}\n```\n\n----------------------------------------\n\nTITLE: Using Dynamic Tag Names in Yew\nDESCRIPTION: Shows how to set element tag names dynamically using @{name} syntax. This is useful for higher-order components that need to render different elements based on properties.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/elements.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet level = 5;\nlet text = \"Hello World!\".to_owned();\n\nhtml! {\n    <@{format!(\"h{}\", level)} class=\"title\">{ text }</@>\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Component that Accepts Classes in Yew (Rust)\nDESCRIPTION: Demonstrates how to create a Yew component that accepts classes as a prop, combines them with its own classes, and applies them to its root element. It also shows how to handle other props and children.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/html/classes.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    #[prop_or_default]\n    class: Classes,\n    fill: bool,\n    children: Html,\n}\n\n#[function_component]\nfn MyComponent(props: &Props) -> Html {\n    let Props {\n        class,\n        fill,\n        children,\n    } = props;\n    html! {\n        <div\n            class={classes!(\n                \"my-container-class\",\n                fill.then(|| Some(\"my-fill-class\")),\n                class.clone(),\n            )}\n        >\n            { children.clone() }\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Expressions into Functions for Yew Templates\nDESCRIPTION: Demonstrates how to improve readability by extracting complex conditional rendering logic into a separate function or closure in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet show_link = true;\nlet maybe_display_link = move || -> Html {\n  if show_link {\n    html! {\n      <a href=\"https://example.com\">{\"Link\"}</a>\n    }\n  } else {\n    html! {}\n  }\n};\n\nhtml! {\n     <div>{maybe_display_link()}</div>\n};\n```\n\n----------------------------------------\n\nTITLE: Rust Implementation of Mouse Move Event Handling with web-sys\nDESCRIPTION: This Rust snippet demonstrates how to handle mouse move events and calculate the position of the mouse within an element using web-sys.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::{prelude::Closure, JsCast};\nuse web_sys::{console, Document, HtmlElement, MouseEvent};\n\nlet mousemove = Closure::<dyn Fn(MouseEvent)>::wrap(Box::new(|e| {\n    let rect = e\n        .target()\n        .expect(\"mouse event doesn't have a target\")\n        .dyn_into::<HtmlElement>()\n        .expect(\"event target should be of type HtmlElement\")\n        .get_bounding_client_rect();\n    let x = (e.client_x() as f64) - rect.left();\n    let y = (e.client_y() as f64) - rect.top();\n    console::log_1(&format!(\"Left? : {} ; Top? : {}\", x, y).into());\n}));\n\nDocument::new()\n    .expect(\"global document not set\")\n    .get_element_by_id(\"mousemoveme\")\n    .expect(\"element with id `mousemoveme` not present\")\n    .unchecked_into::<HtmlElement>()\n    .set_onmousemove(mousemove.as_ref().dyn_ref());\n\n// 我们现在需要保存 `mousemove` 闭包，以便在事件触发时闭包仍然在内存中。\n```\n\n----------------------------------------\n\nTITLE: Modifying VideosList Component to Emit Video Selection (Yew/Rust)\nDESCRIPTION: This snippet modifies the `VideosList` component to use the `on_click` callback passed in through props.  When a video title is clicked, the `on_click` callback is emitted with the selected `Video` object as an argument, thus notifying the parent component of the selection.  This demonstrates event handling using callbacks in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[function_component(VideosList)]\n-fn videos_list(VideosListProps { videos }: &VideosListProps) -> Html {\n+fn videos_list(VideosListProps { videos, on_click }: &VideosListProps) -> Html {\n+    let on_click = on_click.clone();\n    videos.iter().map(|video| {\n+        let on_video_select = {\n+            let on_click = on_click.clone();\n+            let video = video.clone();\n+            Callback::from(move |_| {\n+                on_click.emit(video.clone())\n+            })\n+        };\n\n        html! {\n-            <p key={video.id}>{format!(\"{}: {}\", video.speaker, video.title)}</p>\n+            <p key={video.id} onclick={on_video_select}>{format!(\"{}: {}\", video.speaker, video.title)}</p>\n        }\n    }).collect()\n}\n```\n\n----------------------------------------\n\nTITLE: UseSubscribeState struct\nDESCRIPTION: This code defines a struct `UseSubscribeState` to hold the internal state of the `use_subscribe` hook. It contains a single field, `messages`, which is an `Rc<RefCell<Vec<String>>>` to hold the messages received. The `impl Hook for UseSubscribeState {}` line indicates that this struct implements the `Hook` trait, which is required when using `use_hook`.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.21/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n/// `use_subscribe` internal state\nstruct UseSubscribeState {\n    /// holds all the messages received\n    pub messages: Rc<RefCell<Vec<String>>>,\n}\n\nimpl Hook for UseSubscribeState {}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Redirect Component in Yew Router\nDESCRIPTION: Example showing how to use the Redirect component to handle conditional navigation based on user authentication state. The component redirects to a login page when user is not authenticated.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/router.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[function_component(SomePage)]\nfn some_page() -> Html {\n    // made-up hook `use_user`\n    let user = match use_user() {\n        Some(user) => user,\n        // an early return that redirects to the login page\n        // technicality: `Redirect` actually renders an empty html. But since it also pushes history, the target page\n        // shows up immediately. Consider it a \"side-effect\" component.\n        None => return html! {\n            <Redirect<Route> to={Route::Login}/>\n        },\n    };\n    // ... actual page content.\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing wasm-logger\nDESCRIPTION: This code snippet demonstrates how to initialize the `wasm-logger` crate for enabling logging in a Yew application. The `wasm_logger::init` function is called with a default configuration, setting up the logger to forward log messages to the browser's console.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.20/more/debugging.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// setup\nfn main() {\n    wasm_logger::init(wasm_logger::Config::default());\n}\n\n```\n\n----------------------------------------\n\nTITLE: Optimizing Cargo.toml for Smaller Release Builds\nDESCRIPTION: Configuration settings for Cargo.toml that optimize the release build profile for smaller binary sizes, including panic abort, single codegen unit, size optimizations, and link-time optimization.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/advanced-topics/optimizations.mdx#2025-04-16_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n[profile.release]\n# less code to include into binary\npanic = 'abort'\n# optimization over all codebase ( better optimization, slower build )\ncodegen-units = 1\n# optimization for size ( more aggressive )\nopt-level = 'z'\n# optimization for size\n# opt-level = 's'\n# link time optimization using using whole-program analysis\nlto = true\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering with if-let in Yew\nDESCRIPTION: Demonstrates pattern matching with if-let for conditional rendering in Yew, useful when working with Option types. This renders content only when the Option contains a value.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/conditional-rendering.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nlet some_text = Some(\"text\");\n\nhtml! {\n    if let Some(text) = some_text {\n        <p>{ text }</p>\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Complex Nested HTML Layouts in Yew\nDESCRIPTION: Demonstrates how to create complex nested HTML layouts using Yew's html! macro, including various form elements and attributes.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.18.0/concepts/html/elements.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n    <div>\n        <div data-key=\"abc\"></div>\n        <div class=\"parent\">\n            <span class=\"child\" value=\"anything\"></span>\n            <label for=\"first-name\">{ \"First Name\" }</label>\n            <input type=\"text\" id=\"first-name\" value=\"placeholder\" />\n            <input type=\"checkbox\" checked=true />\n            <textarea value=\"write a story\" />\n            <select name=\"status\">\n                <option selected=true disabled=false value=\"\">{ \"Selected\" }</option>\n                <option selected=false disabled=true value=\"\">{ \"Unselected\" }</option>\n            </select>\n        </div>\n    </div>\n}\n```\n\n----------------------------------------\n\nTITLE: Basic HTML Tag Structure in Yew\nDESCRIPTION: Demonstrates proper opening and closing of HTML tags using the html! macro in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n  <div id=\"my_div\"></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Conditional Callback Processing with batch_callback in Yew\nDESCRIPTION: Demonstrates using batch_callback to conditionally send messages based on input events. This example checks if the Enter key was pressed and only sends a Submit message in that case.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/components/callbacks.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nlet onkeypress = self.link.batch_callback(|event| {\n    if event.key() == \"Enter\" {\n        Some(Msg::Submit)\n    } else {\n        None\n    }\n});\n\nhtml! {\n    <input type=\"text\" onkeypress=onkeypress />\n}\n```\n\n----------------------------------------\n\nTITLE: Using #[wasm_bindgen] Macro to Bind JavaScript Console.log\nDESCRIPTION: This snippet demonstrates how to use the #[wasm_bindgen] macro to manually bind the JavaScript console.log function to Rust. It allows for logging strings and unsigned integers to the console by creating external functions.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/wasm-bindgen/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::prelude::*;\n\n// First up let's take a look of binding `console.log` manually, without the\n// help of `web_sys`. Here we're writing the `#[wasm_bindgen]` annotations\n// manually ourselves, and the correctness of our program relies on the\n// correctness of these annotations!\n#[wasm_bindgen]\nextern \"C\" {\n\n    // Use `js_namespace` here to bind `console.log(..)` instead of just\n    // `log(..)`\n    #[wasm_bindgen(js_namespace = console)]\n    fn log(s: &str);\n\n    // The `console.log` is quite polymorphic, so we can bind it with multiple\n    // signatures. Note that we need to use `js_name` to ensure we always call\n    // `log` in JS.\n    #[wasm_bindgen(js_namespace = console, js_name = log)]\n    fn log_u32(a: u32);\n\n    // Multiple arguments too!\n    #[wasm_bindgen(js_namespace = console, js_name = log)]\n    fn log_many(a: &str, b: &str);\n}\n\n// using the imported functions!\nlog(\"Hello from Rust!\");\nlog_u32(42);\nlog_many(\"Logging\", \"many values!\");\n```\n\n----------------------------------------\n\nTITLE: Yew Implementation of Mouse Move Event Handling\nDESCRIPTION: This Rust snippet demonstrates how to handle mouse move events and calculate the position of the mouse within an element using Yew and web-sys.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{console, HtmlElement, MouseEvent};\nuse yew::\n    html,\n    Callback, TargetCast,\n};\n\nlet onmousemove = Callback::from(|e: MouseEvent| {\n    if let Some(target) = e.target_dyn_into::<HtmlElement>() {\n        let rect = target.get_bounding_client_rect();\n        let x = (e.client_x() as f64) - rect.left();\n        let y = (e.client_y() as f64) - rect.top();\n        console::log_1(&format!(\"Left? : {} ; Top? : {}\", x, y).into());\n    }\n});\n\nhtml! {\n    <div id=\"mousemoveme\" {onmousemove}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Component Using NodeRef in Yew\nDESCRIPTION: This snippet defines a Yew component that uses a NodeRef to access the corresponding DOM element directly. It demonstrates how to initialize a NodeRef, attach it to a div in the view method, and check for attributes in the rendered lifecycle method.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/components/refs.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::Element;\nuse yew::{html, Component, Context, Html, NodeRef};\n\nstruct Comp {\n    node_ref: NodeRef,\n}\n\nimpl Component for Comp {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            // highlight-next-line\n            node_ref: NodeRef::default(),\n        }\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            // highlight-next-line\n            <div ref={self.node_ref.clone()}></div>\n        }\n    }\n\n    fn rendered(&mut self, _ctx: &Context<Self>, _first_render: bool) {\n        // highlight-start\n        let has_attributes = self.node_ref\n            .cast::<Element>()\n            .unwrap()\n            .has_attributes();\n        // highlight-end\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating New Link with Size Using Yew Macros in Rust\nDESCRIPTION: This Rust snippet demonstrates creating a new LinkProps instance using the yew::props! macro, allowing easy building of properties similarly to struct expressions. It highlights converting strings to AttrValue type while setting attributes like href and text. Dependencies include yew::{props, Properties, virtual_dom::AttrValue}, and it exemplifies using a function to encapsulate property setup with specific parameters.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/components/properties.mdx#2025-04-16_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nuse yew::{props, Properties, virtual_dom::AttrValue};\n\n#[derive(Clone, PartialEq)]\npub enum LinkColor {\n    Blue,\n    Red,\n    Green,\n    Black,\n    Purple,\n}\n\nfn create_default_link_color() -> LinkColor {\n    LinkColor::Blue\n}\n\n#[derive(Properties, PartialEq)]\npub struct LinkProps {\n    /// The link must have a target.\n    href: AttrValue,\n    /// Also notice that we\\'re using AttrValue instead of String\n    text: AttrValue,\n    /// Color of the link. Defaults to `Blue`.\n    #[prop_or_else(create_default_link_color)]\n    color: LinkColor,\n    /// The view function will not specify a size if this is None.\n    #[prop_or_default]\n    size: Option<u32>,\n    /// When the view function doesn\\'t specify active, it defaults to true.\n    #[prop_or(true)]\n    active: bool,\n}\n\nimpl LinkProps {\n    /// Notice that this function receives href and text as String\n    /// We can use `AttrValue::from` to convert it to a `AttrValue`\n    pub fn new_link_with_size(href: String, text: String, size: u32) -> Self {\n        // highlight-start\n        props! {LinkProps {\n            href: AttrValue::from(href),\n            text: AttrValue::from(text),\n            size,\n        }}\n        // highlight-end\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using classes! macro with Slice in Yew\nDESCRIPTION: Shows how to use an array slice with the classes! macro to apply multiple classes.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!([\"class-1\", \"class-2\"].as_ref())}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Optional Typed Child in Yew\nDESCRIPTION: Implementation of a Page component that accepts an optional sidebar child component. Shows how to handle both cases where the sidebar is present or absent.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/advanced-topics/children.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{\n    html, html_nested, virtual_dom::VChild, Component,\n    Context, Html, Properties\n};\n\npub struct PageSideBar;\n\nimpl Component for PageSideBar {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"sidebar\" }\n        }\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct PageProps {\n    #[prop_or_default]\n    pub sidebar: Option<VChild<PageSideBar>>,\n}\n\nstruct Page;\n\nimpl Component for Page {\n    type Message = ();\n    type Properties = PageProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"page\">\n                { ctx.props().sidebar.clone().map(Html::from).unwrap_or_default() }\n                // ... page content\n            </div>\n        }\n    }\n}\n\npub fn render_page(with_sidebar: bool) -> Html {\n    if with_sidebar {\n        html! {\n            <Page sidebar={html_nested! {\n                <PageSideBar />\n            }} />\n        }\n    } else {\n        html! {\n            <Page />\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Yew Components on the Server with ServerRenderer\nDESCRIPTION: This snippet demonstrates how to use ServerRenderer to render Yew components on the server side. It creates a simple App component and uses ServerRenderer to generate an HTML string.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/server-side-rendering.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew::ServerRenderer;\n\n#[function_component]\nfn App() -> Html {\n    html! {<div>{\"Hello, World!\"}</div>}\n}\n\n#[tokio::main(flavor = \"current_thread\")]\nasync fn no_main() {\n    let renderer = ServerRenderer::<App>::new();\n\n    let rendered = renderer.render().await;\n\n    // Prints: <div>Hello, World!</div>\n    println!(\"{}\", rendered);\n}\n```\n\n----------------------------------------\n\nTITLE: Logging with wasm-logger in Rust\nDESCRIPTION: This snippet demonstrates how to use the `wasm-logger` crate to send log messages, including log level, source line, and filename, to the browser console. It initializes the logger with a default configuration and logs a message containing a `JsValue` converted to a string.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/more/debugging.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse log::info;\nuse wasm_bindgen::JsValue;\n\nfn main() {\n    wasm_logger::init(wasm_logger::Config::default());\n\n    let object = JsValue::from(\"world\");\n    info!(\"Hello {}\", object.as_string().unwrap());\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Rendered Lifecycle Method in Yew\nDESCRIPTION: This snippet demonstrates how to use the `rendered` lifecycle method to perform actions after the component has rendered. It focuses on controlling an input's focus state.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::{Component, Context, html, Html, NodeRef};\n\npub struct MyComponent {\n    node_ref: NodeRef,\n}\n\nimpl Component for MyComponent {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            node_ref: NodeRef::default(),\n        }\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <input ref={self.node_ref.clone()} type=\"text\" />\n        }\n    }\n\n    // highlight-start\n    fn rendered(&mut self, _ctx: &Context<Self>, first_render: bool) {\n        if first_render {\n            if let Some(input) = self.node_ref.cast::<HtmlInputElement>() {\n                input.focus();\n            }\n        }\n    }\n    // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Navigation with Link Component in Yew\nDESCRIPTION: Shows how to use the Link component for navigation in a Yew application using the router.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/router.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n<Link<Route> to={Route::Home}>{ \"click here to go home\" }</Link<Route>>\n```\n\n----------------------------------------\n\nTITLE: Rendering List with Iterator - for keyword - Rust\nDESCRIPTION: This snippet demonstrates rendering a list of items using the `for` keyword within the `html!` macro. The `for` keyword is a Yew-specific syntax extension that simplifies the process of iterating over a collection and generating HTML elements.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/html/lists.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```rust\nuse yew::prelude::*;\n\nlet items = (1..=10).collect::<Vec<_>>();\n\nhtml! {\n    <ul class=\"item-list\">\n        { for items.iter() }\n    </ul>\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Replacing Hardcoded Video List with Dynamic Content\nDESCRIPTION: Updated HTML structure that replaces the hardcoded list of videos with dynamically generated HTML from the video data collection.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n    <>\n        <h1>{ \"RustConf Explorer\" }</h1>\n        <div>\n            <h3>{ \"Videos to watch\" }</h3>\n-           <p>{ \"John Doe: Building and breaking things\" }</p>\n-           <p>{ \"Jane Smith: The development process\" }</p>\n-           <p>{ \"Matt Miller: The Web 7.0\" }</p>\n-           <p>{ \"Tom Jerry: Mouseless development\" }</p>\n+           { videos }\n        </div>\n        // ...\n    </>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Optional Typed Child in Yew\nDESCRIPTION: This snippet shows how to create a Page component with an optional PageSideBar child component using Option<VChild<T>>.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/children.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::\n    html, html_nested, virtual_dom::VChild, Component,\n    Context, Html, Properties\n};\n\npub struct PageSideBar;\n\nimpl Component for PageSideBar {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"sidebar\" }\n        }\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct PageProps {\n    #[prop_or_default]\n    pub sidebar: Option<VChild<PageSideBar>>,\n}\n\nstruct Page;\n\nimpl Component for Page {\n    type Message = ();\n    type Properties = PageProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"page\">\n                { ctx.props().sidebar.clone().map(Html::from).unwrap_or_default() }\n                // ... page content\n            </div>\n        }\n    }\n}\n\npub fn render_page(with_sidebar: bool) -> Html {\n    if with_sidebar {\n        // Page with sidebar\n        html! {\n            <Page sidebar={html_nested! {\n                <PageSideBar />\n            }} />\n        }\n    } else {\n        // Page without sidebar\n        html! {\n            <Page />\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Video Struct in Rust - Rust\nDESCRIPTION: This snippet defines a struct in Rust to store details about videos for use in the Yew application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nstruct Video {\n    id: usize,\n    title: String,\n    speaker: String,\n    url: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Using classes! Macro with Multiple Classes in Yew (Rust)\nDESCRIPTION: Shows how to apply multiple CSS classes to a div element using the classes! macro in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(\"class-1\", \"class-2\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Manual DOM Node Creation in Yew\nDESCRIPTION: Demonstrates how to create and manage DOM nodes manually using web-sys in Yew, particularly useful when integrating with JS libraries that may conflict with managed components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/elements.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{Element, Node};\nuse yew::prelude::*;\nuse gloo::utils::document;\n\n#[function_component]\nfn MyComponent() -> Html {\n    // memoize as this only needs to be executed once\n    let node = use_memo(\n        |_| {\n            // Create a div element from the document\n            let div: Element = document().create_element(\"div\").unwrap();\n            // Add content, classes etc.\n            div.set_inner_html(\"Hello, World!\");\n            // Convert Element into a Node\n            let node: Node = div.into();\n            // Return that Node as a Html value\n            Html::VRef(node)\n        },\n        (),\n    );\n\n    // use_memo return Rc so we need to deref and clone\n    (*node).clone()\n}\n```\n\n----------------------------------------\n\nTITLE: Using the props! Macro in Yew for Rust\nDESCRIPTION: This snippet shows how to use the yew::props! macro to build properties for Yew components. It demonstrates creating a new method for LinkProps that uses the props! macro to construct the properties.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/advanced-topics/struct-components/properties.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{props, Properties, virtual_dom::AttrValue};\n\n#[derive(Clone, PartialEq)]\npub enum LinkColor {\n    Blue,\n    Red,\n    Green,\n    Black,\n    Purple,\n}\n\nfn create_default_link_color() -> LinkColor {\n    LinkColor::Blue\n}\n\n#[derive(Properties, PartialEq)]\npub struct LinkProps {\n    /// The link must have a target.\n    href: AttrValue,\n    /// Also notice that we're using AttrValue instead of String\n    text: AttrValue,\n    /// Color of the link. Defaults to `Blue`.\n    #[prop_or_else(create_default_link_color)]\n    color: LinkColor,\n    /// The view function will not specify a size if this is None.\n    #[prop_or_default]\n    size: Option<u32>,\n    /// When the view function doesn't specify active, it defaults to true.\n    #[prop_or(true)]\n    active: bool,\n}\n\nimpl LinkProps {\n    /// Notice that this function receives href and text as String\n    /// We can use `AttrValue::from` to convert it to a `AttrValue`\n    pub fn new_link_with_size(href: String, text: String, size: u32) -> Self {\n        // highlight-start\n        props! {LinkProps {\n            href: AttrValue::from(href),\n            text: AttrValue::from(text),\n            size,\n        }}\n        // highlight-end\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using String Class Names in Yew\nDESCRIPTION: Demonstrates how to use a String containing space-separated class names with the classes! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(String::from(\"class-1 class-2\"))}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing the Create Lifecycle Method in Rust for Yew Components\nDESCRIPTION: Example of implementing the create lifecycle method for a Yew component. This method is called when a component is created and receives properties from its parent component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Component, Context, html, Html, Properties};\n\n#[derive(PartialEq, Properties)]\npub struct Props;\n\npub struct MyComponent;\n\nimpl Component for MyComponent {\n    type Message = ();\n    type Properties = Props;\n\n    fn create(ctx: &Context<Self>) -> Self {\n        MyComponent\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            // impl\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested Router Configuration\nDESCRIPTION: Complete example of implementing nested routing with main and settings routes, including route definitions and switch handlers.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/router.mdx#2025-04-16_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew_router::prelude::*;\nuse gloo::utils::window;\nuse wasm_bindgen::UnwrapThrowExt;\n\n#[derive(Clone, Routable, PartialEq)]\nenum MainRoute {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/news\")]\n    News,\n    #[at(\"/contact\")]\n    Contact,\n    #[at(\"/settings\")]\n    SettingsRoot,\n    #[at(\"/settings/*\")]\n    Settings,\n    #[not_found]\n    #[at(\"/404\")]\n    NotFound,\n}\n\n#[derive(Clone, Routable, PartialEq)]\nenum SettingsRoute {\n    #[at(\"/settings\")]\n    Profile,\n    #[at(\"/settings/friends\")]\n    Friends,\n    #[at(\"/settings/theme\")]\n    Theme,\n    #[not_found]\n    #[at(\"/settings/404\")]\n    NotFound,\n}\n\nfn switch_main(route: MainRoute) -> Html {\n    match route {\n        MainRoute::Home => html! {<h1>{\"Home\"}</h1>},\n        MainRoute::News => html! {<h1>{\"News\"}</h1>},\n        MainRoute::Contact => html! {<h1>{\"Contact\"}</h1>},\n        MainRoute::SettingsRoot | MainRoute::Settings => html! { <Switch<SettingsRoute> render={switch_settings} /> },\n        MainRoute::NotFound => html! {<h1>{\"Not Found\"}</h1>},\n    }\n}\n\nfn switch_settings(route: SettingsRoute) -> Html {\n    match route {\n        SettingsRoute::Profile => html! {<h1>{\"Profile\"}</h1>},\n        SettingsRoute::Friends => html! {<h1>{\"Friends\"}</h1>},\n        SettingsRoute::Theme => html! {<h1>{\"Theme\"}</h1>},\n        SettingsRoute::NotFound => html! {<Redirect<MainRoute> to={MainRoute::NotFound}/>}\n    }\n}\n\n#[function_component(App)]\npub fn app() -> Html {\n    html! {\n        <BrowserRouter>\n            <Switch<MainRoute> render={switch_main} />\n        </BrowserRouter>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying App Component to Display VideoDetails (Yew/Rust)\nDESCRIPTION: This snippet modifies the `App` component to manage the selected video in its state and display the `VideoDetails` component when a video is selected.  It uses `use_state` to store the selected video and a callback to update the state when a video is clicked in the `VideosList`. The `VideoDetails` component is rendered conditionally based on whether a video is selected.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[function_component(App)]\nfn app() -> Html {\n    // ...\n+    let selected_video = use_state(|| None);\n\n+    let on_video_select = {\n+        let selected_video = selected_video.clone();\n+        Callback::from(move |video: Video| {\n+            selected_video.set(Some(video))\n+        })\n+    };\n\n+    let details = selected_video.as_ref().map(|video| html! {\n+        <VideoDetails video={video.clone()} />\n+    });\n\n    html! {\n        <>\n            <h1>{ \"RustConf Explorer\" }</h1>\n            <div>\n                <h3>{\"Videos to watch\"}</h3>\n-               <VideosList videos={videos} />\n+               <VideosList videos={videos} on_click={on_video_select.clone()} />\n            </div>\n+            { for details }\n-            <div>\n-                <h3>{ \"John Doe: Building and breaking things\" }</h3>\n-                <img src=\"https://placehold.co/640x360.png?text=Video+Player+Placeholder\" alt=\"video thumbnail\" />\n-            </div>\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Component Creation in Yew\nDESCRIPTION: Example showing how to implement the create lifecycle method for a Yew component. This method is called when a component is first created and receives properties from its parent component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Component, Context, html, Html, Properties};\n\n#[derive(PartialEq, Properties)]\npub struct Props;\n\npub struct MyComponent;\n\nimpl Component for MyComponent {\n    type Message = ();\n    type Properties = Props;\n\n    fn create(ctx: &Context<Self>) -> Self {\n        MyComponent\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            // impl\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Video Struct with Derive Macros in Rust\nDESCRIPTION: This snippet updates the Video struct to derive Clone and PartialEq traits, which are necessary for the struct to be used in component props.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/tutorial/index.mdx#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Clone, PartialEq)]\nstruct Video {\n    id: usize,\n    title: String,\n    speaker: String,\n    url: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a minimal HTML template for a Yew app\nDESCRIPTION: A basic HTML file that serves as the entry point for the Yew application. It defines the document structure with minimal head metadata including charset and title.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<!doctype html>\n<html>\n    <head>\n        <meta charset=\"utf-8\" />\n        <title>Yew App</title>\n    </head>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Configuring Nightly Cargo for Experimental Features in Rust\nDESCRIPTION: This snippet demonstrates how to configure unstable rustc features in .cargo/config.toml for nightly builds. It includes settings for build-std and build-std-features, which can provide additional optimization benefits.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/optimizations.mdx#2025-04-16_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[unstable]\n# Requires the rust-src component. `rustup +nightly component add rust-src`\nbuild-std = [\"std\", \"panic_abort\"]\nbuild-std-features = [\"panic_immediate_abort\"]\n```\n\n----------------------------------------\n\nTITLE: 创建DOM节点并转换为Yew组件 - Rust\nDESCRIPTION: 使用web-sys创建DOM元素，并将其转换为Yew的Html值。这个示例展示了如何在Yew中手动创建和管理DOM节点，以便与JavaScript库集成。\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/html/elements.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{Element, Node};\nuse yew::prelude::*;\nuse gloo::utils::document;\n\n#[function_component]\nfn MyComponent() -> Html {\n    // 带记忆能力的函数，只会执行一次\n    let node = use_memo(\n        (),\n        |_| {\n            // 从文档中创建一个 div 元素\n            let div: Element = document().create_element(\"div\").unwrap();\n            // 添加内容、类等\n            div.set_inner_html(\"Hello, World!\");\n            // 将 Element 转换为 Node\n            let node: Node = div.into();\n            // 将该 Node 作为 Html 值返回\n            Html::VRef(node)\n        },\n    );\n\n    // use_memo 返回的是 Rc 指针，所以我们需要解引用和克隆\n    (*node).clone()\n}\n```\n\n----------------------------------------\n\nTITLE: Complex HTML Structure in Yew\nDESCRIPTION: Example of creating nested HTML layouts with various form elements and attributes\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/introduction.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <div>\n        <div data-key=\"abc\"></div>\n        <div class=\"parent\">\n            <span class=\"child\" value=\"anything\"></span>\n            <label for=\"first-name\">{ \"First Name\" }</label>\n            <input type=\"text\" id=\"first-name\" value=\"placeholder\" />\n            <input type=\"checkbox\" checked=true />\n            <textarea value=\"write a story\" />\n            <select name=\"status\">\n                <option selected=true disabled=false value=\"\">{ \"Selected\" }</option>\n                <option selected=false disabled=true value=\"\">{ \"Unselected\" }</option>\n            </select>\n        </div>\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: HTML Open-Close Tag Example in Yew\nDESCRIPTION: This code snippet demonstrates the use of open and close tags in the `html!` macro within a Yew component. It showcases a simple `div` element with an `id` attribute.  It requires the `yew` crate to be included.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n  <div id=\"my_div\"></div>\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using Closures for Conditional Rendering in Yew\nDESCRIPTION: Illustrates the use of closures to manage conditional HTML rendering in Yew for improved readability. The example defines a closure that returns HTML based on a condition and is evaluated in the HTML macro. Requires the `yew` crate.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Html};\n\nlet show_link = true;\nlet maybe_display_link = move || -> Html {\n  if show_link {\n    html! {\n      <a href=\"https://example.com\">{\"Link\"}</a>\n    }\n  } else {\n    html! {}\n  }\n};\n\nhtml! {\n     <div>{maybe_display_link()}</div>\n};\n```\n\n----------------------------------------\n\nTITLE: Manual Event Listener Implementation in Yew\nDESCRIPTION: Demonstrates how to implement manual event listeners using Closure and web-sys in Yew components. Includes proper lifecycle management for event listeners.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/events.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::{prelude::Closure, JsCast};\nuse web_sys::HtmlElement;\nuse yew::{events::Event, html, Component, Context, Html, NodeRef};\n\npub struct Comp {\n    my_div: NodeRef,\n    custard_listener: Option<Closure<dyn Fn(Event)>>,\n}\n\npub enum Msg {\n    Custard,\n}\n\nimpl Component for Comp {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_: &Context<Self>) -> Self {\n        Self {\n            my_div: NodeRef::default(),\n            custard_listener: None,\n        }\n    }\n\n    fn update(&mut self, _: &Context<Self>, msg: Self::Message) -> bool {\n        match msg {\n            Msg::Custard => {\n                true\n            }\n        }\n    }\n\n    fn view(&self, _: &Context<Self>) -> Html {\n        html! {\n            <div ref={self.my_div.clone()} id=\"my-div\"></div>\n        }\n    }\n\n    fn rendered(&mut self, ctx: &Context<Self>, first_render: bool) {\n        if !first_render {\n            return;\n        }\n\n        if let Some(element) = self.my_div.cast::<HtmlElement>() {\n            let oncustard = ctx.link().callback(|_: Event| Msg::Custard);\n            let listener = Closure::<dyn Fn(Event)>::wrap(Box::new(move |e: Event| oncustard.emit(e)));\n            element.add_event_listener_with_callback(\"custard\", listener.as_ref().unchecked_ref()).unwrap();\n            self.custard_listener = Some(listener);\n        }\n    }\n\n    fn destroy(&mut self, _: &Context<Self>) {\n        if let (Some(element), Some(listener)) = (self.my_div.cast::<HtmlElement>(), self.custard_listener.take()) {\n            element.remove_event_listener_with_callback(\"custard\", listener.as_ref().unchecked_ref()).unwrap();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Yew Implementation of Mouse Move Handler\nDESCRIPTION: Refactored version of the mouse move handler using Yew and web-sys. Includes necessary Cargo.toml dependencies and Yew-specific code.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies.web-sys]\nversion = \"0.3\"\nfeatures = [\n    \"console\",\n    \"HtmlElement\",\n    \"MouseEvent\",\n    \"DomRect\",\n]\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{console, HtmlElement, MouseEvent};\nuse yew::{html, Callback, TargetCast};\n\nlet onmousemove = Callback::from(|e: MouseEvent| {\n    if let Some(target) = e.target_dyn_into::<HtmlElement>() {\n        let rect = target.get_bounding_client_rect();\n        let x = (e.client_x() as f64) - rect.left();\n        let y = (e.client_y() as f64) - rect.top();\n        console::log_1(&format!(\"Left? : {} ; Top? : {}\", x, y).into());\n    }\n});\n\nhtml! {\n    <div id=\"mousemoveme\" {onmousemove}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Logging to Browser Console with wasm-logger in Rust\nDESCRIPTION: Demonstrates how to use the wasm-logger crate to integrate with the log crate for sending log level, source line, and filename to the browser console. This snippet shows initializing the logger and creating a simple info log with a JavaScript value.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/more/debugging.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse log::info;\nuse wasm_bindgen::JsValue;\n\nfn main() {\n    wasm_logger::init(wasm_logger::Config::default());\n\n    let object = JsValue::from(\"world\");\n    info!(\"Hello {}\", object.as_string().unwrap());\n}\n```\n\n----------------------------------------\n\nTITLE: Spawning Async Tasks with spawn_local in Rust WebAssembly\nDESCRIPTION: Demonstrates how to use spawn_local to execute an async function and manipulate its result. The example shows creating an async function that returns a String, then modifying and logging the result to the console.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/wasm-bindgen/introduction.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::console;\nuse wasm_bindgen_futures::spawn_local;\n\nasync fn my_async_fn() -> String { String::from(\"Hello\") }\n\nspawn_local(async {\n    let mut string = my_async_fn().await;\n    string.push_str(\", world!\");\n    // console log \"Hello, world!\"\n    console::log_1(&string.into());\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Children Component in Yew\nDESCRIPTION: This snippet demonstrates how to create a basic List component that accepts children of any type using the Html type for children props.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/children.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html, Properties};\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: Html,\n}\n\npub struct List;\n\nimpl Component for List {\n    type Message = ();\n    type Properties = ListProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"list\">\n                {ctx.props().children.clone()}\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Context-Based Higher Order Component in Rust with Yew\nDESCRIPTION: A complete example showing how to create a Higher Order Component that provides theme context to a struct component. The implementation includes a theme context provider, a HOC function component that consumes the context, and a struct component that receives the theme as props.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/advanced-topics/struct-components/hoc.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(Clone, Debug, PartialEq)]\nstruct Theme {\n    foreground: String,\n    background: String,\n}\n\n#[function_component]\npub fn App() -> Html {\n    let ctx = use_state(|| Theme {\n        foreground: \"#000000\".to_owned(),\n        background: \"#eeeeee\".to_owned(),\n    });\n\n    html! {\n        <ContextProvider<Theme> context={(*ctx).clone()}>\n            <ThemedButtonHOC />\n        </ContextProvider<Theme>>\n    }\n}\n\n#[function_component]\npub fn ThemedButtonHOC() -> Html {\n    let theme = use_context::<Theme>().expect(\"no ctx found\");\n\n    html! {<ThemedButtonStructComponent {theme} />}\n}\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub theme: Theme,\n}\n\nstruct ThemedButtonStructComponent;\n\nimpl Component for ThemedButtonStructComponent {\n    type Message = ();\n    type Properties = Props;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let theme = &ctx.props().theme;\n        html! {\n            <button style={format!(\n                    \"background: {}; color: {};\",\n                    theme.background,\n                    theme.foreground\n                )}\n            >\n                { \"Click me!\" }\n            </button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Logging to Browser Console with gloo-console in Rust\nDESCRIPTION: Shows how to use the gloo-console crate from the Gloo collection to log messages to the browser console. The snippet demonstrates using the log! macro which can directly accept a JsValue.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/more/debugging.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse gloo_console::log;\nuse wasm_bindgen::JsValue;\n\nfn main() {\n    let object = JsValue::from(\"world\");\n    log!(\"Hello\", object)\n}\n```\n\n----------------------------------------\n\nTITLE: Using classes! macro with multiple literal strings in Yew\nDESCRIPTION: Shows how to apply multiple CSS classes to a div element by passing multiple literal string arguments to the classes! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(\"class-1\", \"class-2\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing NodeRef for Input Focus in Yew Components\nDESCRIPTION: Example of using the NodeRef feature to obtain a direct reference to a rendered input element in order to programmatically focus it after component mounting. This demonstrates the new `ref` keyword functionality introduced in Yew 0.10.\nSOURCE: https://github.com/yewstack/yew/blob/master/CHANGELOG.md#2025-04-16_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nuse stdweb::web::html_element::InputElement;\nuse stdweb::web::IHtmlElement;\nuse yew::prelude::*;\n\npub struct Input {\n    node_ref: NodeRef,\n}\n\nimpl Component for Input {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_: Self::Properties, _: ComponentLink<Self>) -> Self {\n        Input {\n            node_ref: NodeRef::default(),\n        }\n    }\n\n    fn mounted(&mut self) -> ShouldRender {\n        if let Some(input) = self.node_ref.try_into::<InputElement>() {\n            input.focus();\n        }\n        false\n    }\n\n    fn update(&mut self, _: Self::Message) -> ShouldRender {\n        false\n    }\n\n    fn view(&self) -> Html<Self> {\n        html! {\n            <input ref=self.node_ref.clone() type=\"text\" />\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using String Variable for Classes in Yew\nDESCRIPTION: This snippet illustrates the use of a string variable to manage multiple classes for an HTML element in Yew using the `classes!` macro. The variable should implement `Into<Classes>`.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/classes.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nlet my_classes = String::from(\"class-1 class-2\");\n\nhtml! {\n  <div class={classes!(my_classes)}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Dynamic Tag Name in Yew (Rust)\nDESCRIPTION: This snippet shows how to dynamically set HTML tag names in Yew based on a variable, allowing for flexible rendering of components depending on the level of a heading.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/elements.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet level = 5;\nlet text = \"Hello World!\".to_owned();\n\nhtml! {\n    <@{format!(\"h{}\", level)} class=\"title\">{ text }</@>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Manual Event Listeners with Closure in Yew\nDESCRIPTION: A verbose implementation of custom event listeners in Yew using web-sys and wasm-bindgen's Closure API. This approach requires careful memory management including storing the listener in the component and manually removing it when the component is destroyed.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/events.mdx#2025-04-16_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::{prelude::Closure, JsCast};\nuse yew:{\n    html,\n    web_sys::{Event, HtmlElement},\n    Component, ComponentLink, Html, NodeRef,\n};\n\npub struct Comp {\n    link: ComponentLink<Self>,\n    my_div: NodeRef,\n    custard_listener: Option<Closure<dyn Fn(Event)>>,\n}\n\npub enum Msg {\n    Custard,\n}\n\nimpl Component for Comp {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_: Self::Properties, link: ComponentLink<Self>) -> Self {\n        Self {\n            link,\n            my_div: NodeRef::default(),\n            custard_listener: None,\n        }\n    }\n\n    fn update(&mut self, msg: Self::Message) -> bool {\n        match msg {\n            Msg::Custard => {\n                // do something about custard..\n                true\n            }\n        }\n    }\n\n    fn change(&mut self, _props: Self::Properties) -> yew::ShouldRender {\n        false\n    }\n\n    fn view(&self) -> Html {\n        html! {\n            <div ref={self.my_div.clone()} id=\"my-div\"></div>\n        }\n    }\n\n    fn rendered(&mut self, first_render: bool) {\n        if !first_render {\n            return;\n        }\n\n        if let Some(element) = self.my_div.cast::<HtmlElement>() {\n            // Create your Callback as you normally would\n            let oncustard = self.link.callback(|_: Event| Msg::Custard);\n\n            // Create a Closure from a Box<dyn Fn> - this has to be 'static\n            let listener =\n                Closure::<dyn Fn(Event)>::wrap(\n                    Box::new(move |e: Event| oncustard.emit(e))\n                );\n            element\n                .add_event_listener_with_callback(\n                    \"custard\",\n                    listener.as_ref().unchecked_ref()\n                )\n                .unwrap();\n\n            // Need to save listener in the component otherwise when the\n            // event is fired it will try and call the listener that no longer\n            // exists in memory!\n            self.custard_listener = Some(listener);\n        }\n    }\n\n    fn destroy(&mut self) {\n        // All done with the component but need to remove\n        // the event listener before the custard_listener memory\n        // goes out of scope.\n        if let (Some(element), Some(listener)) = (\n            self.my_div.cast::<HtmlElement>(),\n            self.custard_listener.take(),\n        ) {\n            element\n                .remove_event_listener_with_callback(\n                    \"custard\",\n                    listener.as_ref().unchecked_ref()\n                )\n                .unwrap();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Trunk and WebAssembly tools\nDESCRIPTION: Command to install Trunk (a WASM web application bundler) and the wasm-bindgen-cli tool, which are required to build and serve Yew applications.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncargo install trunk wasm-bindgen-cli\n```\n\n----------------------------------------\n\nTITLE: Using the props! Macro for Building Properties in Yew\nDESCRIPTION: This snippet shows how to use the yew::props! macro to build properties for a Link component. It demonstrates creating a constructor method that uses the macro to set properties with default values and type conversions.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/struct-components/properties.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{props, Properties, virtual_dom::AttrValue};\n\n#[derive(Clone, PartialEq)]\npub enum LinkColor {\n    Blue,\n    Red,\n    Green,\n    Black,\n    Purple,\n}\n\nfn create_default_link_color() -> LinkColor {\n    LinkColor::Blue\n}\n\n#[derive(Properties, PartialEq)]\npub struct LinkProps {\n    /// The link must have a target.\n    href: AttrValue,\n    /// Also notice that we're using AttrValue instead of String\n    text: AttrValue,\n    /// Color of the link. Defaults to `Blue`.\n    #[prop_or_else(create_default_link_color)]\n    color: LinkColor,\n    /// The view function will not specify a size if this is None.\n    #[prop_or_default]\n    size: Option<u32>,\n    /// When the view function doesn't specify active, it defaults to true.\n    #[prop_or(true)]\n    active: bool,\n}\n\nimpl LinkProps {\n    /// Notice that this function receives href and text as String\n    /// We can use `AttrValue::from` to convert it to a `AttrValue`\n    pub fn new_link_with_size(href: String, text: String, size: u32) -> Self {\n        props! {LinkProps {\n            href: AttrValue::from(href),\n            text: AttrValue::from(text),\n            size,\n        }}\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Embedding Values in HTML with html! Macro\nDESCRIPTION: Shows how to embed Rust values into HTML using curly brackets within the html! macro. The example demonstrates embedding strings, numbers, and combining HTML elements together.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/basic-web-technologies/html.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet header_text = \"Hello world\".to_string();\nlet header_html: Html = html! {\n    <h1>{header_text}</h1>\n};\n\nlet count: usize = 5;\nlet counter_html: Html = html! {\n    <p>{\"My age is: \"}{count}</p>\n};\n\nlet combined_html: Html = html! {\n    <div>{header_html}{counter_html}</div>\n};\n```\n\n----------------------------------------\n\nTITLE: 使用动态标签名创建HTML元素 - Rust\nDESCRIPTION: 演示如何在Yew中使用动态标签名创建HTML元素。这对于构建高阶组件特别有用，可以根据属性动态选择要渲染的HTML标签。\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/html/elements.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet level = 5;\nlet text = \"Hello World!\".to_owned();\n\nhtml! {\n    <@{format!(\"h{}\", level)} class=\"title\">{ text }</@>\n};\n```\n\n----------------------------------------\n\nTITLE: Event Listeners in Yew Component\nDESCRIPTION: Shows multiple ways of handling event listeners using Callbacks in Yew components\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/elements.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Component, Context, html, Html};\n\nstruct MyComponent;\n\nenum Msg {\n    Click,\n}\n\nimpl Component for MyComponent {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn update(&mut self, _ctx: &Context<Self>, msg: Self::Message) -> bool {\n        match msg {\n            Msg::Click => {\n                // Handle Click\n            }\n        };\n        true\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let click_callback = ctx.link().callback(|_| Msg::Click);\n        html! {\n            <button onclick={click_callback}>\n                { \"Click me!\" }\n            </button>\n        }\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Callback, Context, Component, Html};\nuse weblog::console_log;\n\nstruct MyComponent;\n\nimpl Component for MyComponent {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        MyComponent\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        let click_callback = Callback::from(|_| {\n            console_log!(\"clicked!\");\n        });\n\n        html! {\n            <button onclick={click_callback}>\n                { \"Click me!\" }\n            </button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using VideosList Component\nDESCRIPTION: This snippet updates the `App` component to use the `VideosList` component. It passes the `videos` vector as a prop to the `VideosList` component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\n\"#[function_component(App)]\nfn app() -> Html {\n    // ...\n-    let videos = videos.iter().map(|video| html! {\n-        <p key={video.id}>{format!(\\\"{}: {}\\\", video.speaker, video.title)}</p>\n-    }).collect::<Html>();\n-\n    html! {\n        <>\n            <h1>{ \\\"RustConf Explorer\\\" }</h1>\n            <div>\n                <h3>{\\\"Videos to watch\\\"}</h3>\n-               { videos }\n+               <VideosList videos={videos} />\n            </div>\n            // ...\n        </>\n    }\n}\"\n```\n\n----------------------------------------\n\nTITLE: Evaluating Props Order in Yew\nDESCRIPTION: Shows that props in Yew are evaluated in the order they're specified, which can be important when using iterators or other stateful operations to set prop values.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/function-components/properties.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(yew::Properties, PartialEq)]\nstruct Props { first: usize, second: usize, last: usize }\n\nfn main() {\n    let mut g = 1..=3;\n    let props = yew::props!(Props { first: g.next().unwrap(), second: g.next().unwrap(), last: g.next().unwrap() });\n\n    assert_eq!(props.first, 1);\n    assert_eq!(props.second, 2);\n    assert_eq!(props.last, 3);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Suspense with Struct Components in Yew\nDESCRIPTION: Demonstrates how to use Suspense with struct components in Yew by creating a Higher-Order Component (HOC) function component. It includes a WithUser HOC, a BaseUserContent struct component, and a UserContent type alias combining both.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/suspense.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[function_component(WithUser)]\nfn with_user<T>() -> HtmlResult\nwhere T: BaseComponent\n{\n    let user = use_user()?;\n\n    Ok(html! {<T {user} />})\n}\n\n#[derive(Debug, PartialEq, Properties)]\npub struct UserContentProps {\n    pub user: User,\n}\n\npub struct BaseUserContent;\n\nimpl Component for BaseUserContent {\n    type Properties = UserContentProps;\n    type Message = ();\n\n    fn create(ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let name = ctx.props().user.name;\n\n        html! {<div>{\"Hello, \"}{name}{\"!\"}</div>}\n    }\n}\n\npub type UserContent = WithUser<BaseUserContent>;\n```\n\n----------------------------------------\n\nTITLE: Implementing Higher Order Component for Context in Yew (Rust)\nDESCRIPTION: This code snippet demonstrates how to create a Higher Order Component in Yew to pass context down to a struct component. It includes an App component that provides a Theme context, an HOC that consumes the context, and a struct component that receives the theme as a prop.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/struct-components/hoc.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(Clone, Debug, PartialEq)]\nstruct Theme {\n    foreground: String,\n    background: String,\n}\n\n#[function_component]\npub fn App() -> Html {\n    let ctx = use_state(|| Theme {\n        foreground: \"#000000\".to_owned(),\n        background: \"#eeeeee\".to_owned(),\n    });\n\n    html! {\n        <ContextProvider<Theme> context={(*ctx).clone()}>\n            <ThemedButtonHOC />\n        </ContextProvider<Theme>>\n    }\n}\n\n// highlight-start\n#[function_component]\npub fn ThemedButtonHOC() -> Html {\n    let theme = use_context::<Theme>().expect(\"no ctx found\");\n\n    html! {<ThemedButtonStructComponent {theme} />}\n}\n// highlight-end\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub theme: Theme,\n}\n\nstruct ThemedButtonStructComponent;\n\nimpl Component for ThemedButtonStructComponent {\n    type Message = ();\n    type Properties = Props;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let theme = &ctx.props().theme;\n        html! {\n            <button style={format!(\n                    \"background: {}; color: {};\",\n                    theme.background,\n                    theme.foreground\n                )}\n            >\n                { \"Click me!\" }\n            </button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Callbacks with ComponentLink\nDESCRIPTION: Demonstrates how to register callbacks that send messages to a component's update mechanism using different methods like callback, send_message, and send_message_batch\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.21/advanced-topics/struct-components/callbacks.mdx#2025-04-16_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Using classes! macro with Vector in Yew\nDESCRIPTION: This snippet illustrates how to use the `classes!` macro with a `Vec<String>` to set multiple CSS classes on a div element in Yew. This provides a mechanism for collecting classes in a vector and then applying them to an HTML element. It relies on the `yew` crate.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/classes.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(vec![\"class-1\", \"class-2\"])}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: VS Code Yew Component Snippets\nDESCRIPTION: JSON configuration for VS Code Rust snippets to quickly generate Yew function and struct components\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/getting-started/editor-setup.mdx#2025-04-16_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"New Yew function component\": {\n        \"prefix\": \"yewfc\",\n        \"body\": [\n            \"#[derive(PartialEq, Properties)]\",\n            \"pub struct ${1:ComponentName}Props {}\",\n            \"\",\n            \"#[function_component]\",\n            \"pub fn $1(props: &${1}Props) -> Html {\",\n            \"    let ${1}Props {} = props;\",\n            \"    html! {\",\n            \"        <${2:div}>$0</${2}>\",\n            \"    }\",\n            \"}\"\n        ],\n        \"description\": \"Create a minimal Yew function component\"\n    },\n    \"New Yew struct component\": {\n        \"prefix\": \"yewsc\",\n        \"body\": [\n            \"pub struct ${1:ComponentName};\",\n            \"\",\n            \"pub enum ${1}Msg {\",\n            \"}\",\n            \"\",\n            \"impl Component for ${1} {\",\n            \"    type Message = ${1}Msg;\",\n            \"    type Properties = ();\",\n            \"\",\n            \"    fn create(ctx: &Context<Self>) -> Self {\",\n            \"        Self\",\n            \"    }\",\n            \"\",\n            \"    fn view(&self, ctx: &Context<Self>) -> Html {\",\n            \"        html! {\",\n            \"            $0\",\n            \"        }\",\n            \"    }\",\n            \"}\"\n        ],\n        \"description\": \"Create a new Yew component with a message enum\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Web API Usage Between web-sys and stdweb Libraries\nDESCRIPTION: Demonstrates the differences in syntax and approach between web-sys and stdweb when accessing browser APIs. The example shows how to access the window object and display an alert using both libraries, highlighting that web-sys uses a more Result-oriented approach while stdweb offers a more concise API and includes a js! macro for direct JavaScript integration.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/choose-web-library.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// web-sys\nlet window: web_sys::Window = web_sys::window().expect(\"window not available\");\nwindow.alert_with_message(\"hello from wasm!\").expect(\"alert failed\");\n\n// stdweb\nlet window: stdweb::web::Window = stdweb::web::window();\nwindow.alert(\"hello from wasm!\");\n\n// stdweb with js! macro\nuse stdweb::js;\nuse stdweb::unstable::TryFrom;\nuse stdweb::web::Window;\n\nlet window_val: stdweb::Value = js!{ return window; }; // <- JS syntax inside!\nlet window = Window::try_from(window_val).expect(\"conversion to window failed\");\nwindow.alert(\"hello from wasm!\");\n```\n\n----------------------------------------\n\nTITLE: Yew Suspense Hook Implementation\nDESCRIPTION: This code defines a custom hook `use_user` that simulates fetching user data. It returns a `SuspensionResult<User>`. If the data is available, it returns `Ok(user)`. If the data is still loading, it creates a `Suspension` and returns `Err(s)`, pausing the component's rendering and displaying the fallback UI. When the data is loaded, `SuspensionHandle::resume` is called to re-render the component with the loaded data.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/suspense.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew::suspense::{Suspension, SuspensionResult};\n\nstruct User {\n    name: String,\n}\n\n#[hook]\nfn use_user() -> SuspensionResult<User> {\n    match load_user() {\n        // 当用户加载完成时，我们将其作为 Ok(user) 返回。\n        Some(m) => Ok(m),\n        None => {\n            // 当用户仍在加载时，我们创建一个 `Suspension`\n            // 并在数据加载完成时调用 `SuspensionHandle::resume`，\n            // 组件将自动重新渲染。\n            let (s, handle) = Suspension::new();\n            on_load_user_complete(move || {handle.resume();});\n            Err(s)\n        },\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Button Click Handler with Callbacks in Yew\nDESCRIPTION: Shows how to create a callback for handling button click events. The callback is attached to a button's onclick event and sends a Clicked message to the component when triggered.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/components/callbacks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nlet onclick = self.link.callback(|_| Msg::Clicked);\nhtml! {\n    <button onclick=onclick>{ \"Click\" }</button>\n}\n```\n\n----------------------------------------\n\nTITLE: Properties Evaluation Order in Yew\nDESCRIPTION: This example demonstrates that properties in Yew are evaluated in the order they are specified. This is important when the property initialization depends on side effects.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/function-components/properties.mdx#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(yew::Properties, PartialEq)]\nstruct Props { first: usize, second: usize, last: usize }\n\nfn main() {\n    let mut g = 1..=3;\n    let props = yew::props!(Props { first: g.next().unwrap(), second: g.next().unwrap(), last: g.next().unwrap() });\n\n    assert_eq!(props.first, 1);\n    assert_eq!(props.second, 2);\n    assert_eq!(props.last, 3);\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Rendering Logic into Functions in Yew\nDESCRIPTION: Demonstrates how to improve template readability by extracting complex rendering logic into separate functions or closures. The example moves conditional link rendering into a dedicated function.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet show_link = true;\nlet maybe_display_link = move || -> Html {\n  if show_link {\n    html! {\n      <a href=\"https://example.com\">{\"Link\"}</a>\n    }\n  } else {\n    html! {}\n  }\n};\n\nhtml! {\n     <div>{maybe_display_link()}</div>\n};\n```\n\n----------------------------------------\n\nTITLE: Type Conversion with JsCast for DOM Elements\nDESCRIPTION: Example demonstrating how to use JsCast to safely convert between different DOM element types when handling events. Shows both checked and unchecked conversions for HTML elements.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/basic-web-technologies/wasm-bindgen.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// 需要先導入這個 Trait\nuse wasm_bindgen::JsCast;\nuse web_sys::{Event, EventTarget, HtmlInputElement, HtmlSelectElement};\n\nfn handle_event(event: Event) {\n    let target: EventTarget = event\n        .target()\n        .expect(\"I'm sure this event has a target!\");\n\n    // 也許目標是一個選擇元素？\n    if let Some(select_element) = target.dyn_ref::<HtmlSelectElement>() {\n        // 做點別的\n        return;\n    }\n\n    // 如果它能確定不是一個選擇元素，那麼我可以肯定它是一個輸入元素！\n    let input_element: HtmlInputElement = target.unchecked_into();\n}\n```\n\n----------------------------------------\n\nTITLE: Mouse Position Tracking with web-sys Cargo Dependencies\nDESCRIPTION: Cargo.toml configuration for enabling specific web-sys features needed for the mouse position tracking example. Demonstrates how to selectively enable only the required Web API features to minimize bundle size.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/wasm-bindgen/web-sys.mdx#2025-04-16_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nwasm-bindgen = \"0.2\"\n\n[dependencies.web-sys]\nversion = \"0.3\"\n# We need to enable all the web-sys features we want to use!\nfeatures = [\n    \"console\",\n    \"Document\",\n    \"HtmlElement\",\n    \"MouseEvent\",\n    \"DomRect\",\n]\n```\n\n----------------------------------------\n\nTITLE: Nested Components with Children in Yew\nDESCRIPTION: Shows how to create components that can accept child components using the Children type in Properties. Demonstrates basic parent-child component relationships.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/components.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    id: String,\n    children: Children,\n}\n\n#[function_component]\nfn Container(props: &Props) -> Html {\n    html! {\n        <div id={props.id.clone()}>\n            { props.children.clone() }\n        </div>\n    }\n}\n\nhtml! {\n    <Container id=\"container\">\n        <h4>{ \"Hi\" }</h4>\n        <div>{ \"Hello\" }</div>\n    </Container>\n};\n```\n\n----------------------------------------\n\nTITLE: Accessing document object in Rust using web-sys\nDESCRIPTION: Shows how to access the document object from the window in Rust using web-sys. It includes error handling for undefined window and document objects.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/basic-web-technologies/js.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::UnwrapThrowExt;\nuse web_sys::window;\n\nlet document = window()\n    .expect_throw(\"window is undefined\")\n    .document()\n    .expect_throw(\"document is undefined\");\n```\n\n----------------------------------------\n\nTITLE: Props Macro Usage in Yew\nDESCRIPTION: Example demonstrating the use of the props! macro to build properties programmatically.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/function-components/properties.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties, props, virtual_dom::AttrValue};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    #[prop_or(AttrValue::from(\"Bob\"))]\n    pub name: AttrValue,\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n    html! {<>{\"Hello world\"}{props.name.clone()}</>}\n}\n\n#[function_component]\nfn App() -> Html {\n    let pre_made_props = props! {\n        Props {} // Notice we did not need to specify name prop\n    };\n    html! {<HelloWorld ..pre_made_props />}\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Location Listener in Struct Components\nDESCRIPTION: This code snippet shows how to add a location listener in struct components to react to route changes. It demonstrates using the add_location_listener() method and storing the listener handle in the component state.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/router.mdx#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nfn create(ctx: &Context<Self>) -> Self {\n    let listener = ctx.link()\n        .add_location_listener(ctx.link().callback(\n            // handle event\n        ))\n        .unwrap();\n    MyComponent {\n        _listener: listener\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Enum Typed Children in Yew\nDESCRIPTION: This example demonstrates how to create a List component that accepts multiple specific child component types using an enum and ChildrenRenderer.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/children.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::\n    html, html::ChildrenRenderer, virtual_dom::VChild, Component,\n    Context, Html, Properties,\n};\n\npub struct Primary;\n\nimpl Component for Primary {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"Primary\" }\n        }\n    }\n}\n\npub struct Secondary;\n\nimpl Component for Secondary {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"Secondary\" }\n        }\n    }\n}\n\n#[derive(Clone, derive_more::From, PartialEq)]\npub enum Item {\n    Primary(VChild<Primary>),\n    Secondary(VChild<Secondary>),\n}\n\n#[allow(clippy::from_over_into)]\nimpl Into<Html> for Item {\n    fn into(self) -> Html {\n        match self {\n            Self::Primary(child) => child.into(),\n            Self::Secondary(child) => child.into(),\n        }\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: ChildrenRenderer<Item>,\n}\n\npub struct List;\n\nimpl Component for List {\n    type Message = ();\n    type Properties = ListProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"list\">\n                { for ctx.props().children.iter() }\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering with if-else - Rust\nDESCRIPTION: Shows how to conditionally render elements using `if` and `else` blocks in Yew, demonstrating rendering different elements based on a boolean condition.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/introduction.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\\nlet some_condition = true;\\n\\nhtml! {\\n    if some_condition {\\n        <p>{ \\\"True case\\\" }</p>\\n    } else {\\n        <p>{ \\\"False case\\\" }</p>\\n    }\\n};\n```\n\n----------------------------------------\n\nTITLE: Using JsCast with NodeRef::get for Element Type Conversion\nDESCRIPTION: Demonstrates an alternative way to convert a NodeRef to a specific element type using the NodeRef::get method combined with JsCast's dyn_into for type conversion.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::JsCast;\nuse web_sys::HtmlInputElement;\nuse yew::NodeRef;\n\nfn with_jscast(node_ref: NodeRef) {\n    if let Some(input) = node_ref\n        .get()\n        .and_then(|node| node.dyn_into::<HtmlInputElement>().ok()) {\n        // do something with HtmlInputElement\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing Hardcoded HTML with Video Data - Rust\nDESCRIPTION: This snippet updates the `html!` macro to replace hardcoded video data with dynamically generated content.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n    <>\n        <h1>{ \"RustConf Explorer\" }</h1>\n        <div>\n            <h3>{ \"Videos to watch\" }</h3>\n-           <p>{ \"John Doe: Building and breaking things\" }</p>\n-           <p>{ \"Jane Smith: The development process\" }</p>\n-           <p>{ \"Matt Miller: The Web 7.0\" }</p>\n-           <p>{ \"Tom Jerry: Mouseless development\" }</p>\n+           { videos }\n        </div>\n        // ...\n    </>\n}\n```\n\n----------------------------------------\n\nTITLE: Using Optional Attributes for HTML Elements in Yew\nDESCRIPTION: Demonstrates how to use Option<T> for HTML attributes in Yew, allowing attributes to be conditionally included or omitted in the rendered DOM.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/elements.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet maybe_id = Some(\"foobar\");\n\nhtml! {\n    <div id={maybe_id}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Neovim LazyVim LSP Configuration for Yew\nDESCRIPTION: Configuration for Neovim's LSP setup using LazyVim to support various template languages including Rust with HTML.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/getting-started/editor-setup.mdx#2025-04-16_snippet_4\n\nLANGUAGE: json\nCODE:\n```\nreturn {\n  {\n    \"neovim/nvim-lspconfig\",\n    init_options = {\n      userLanguages = {\n        eelixir = \"html-eex\",\n        eruby = \"erb\",\n        rust = \"html\",\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Overwriting of Children Components Using Yew in Rust\nDESCRIPTION: This code snippet explores how to overwrite children components in Yew when a base props expression is used. It imports from 'yew' the necessary components and focuses on how expressions with 'children' fields work when passed through a base expression in the 'html!' macro. The output exhibits a rendered HTML component where specified children override props children.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/components.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Children, Component, Context, html, Html, props, Properties};\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    id: String,\n    children: Children,\n}\n\nstruct Container;\n\nimpl Component for Container {\n    type Message = ();\n    type Properties = Props;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div id={ctx.props().id.clone()}>\n                { ctx.props().children.clone() }\n            </div>\n        }\n    }\n}\n\nlet props = yew::props!(Container::Properties {\n    id: \"container-2\",\n    children: Children::default(),\n});\n\nhtml! {\n    <Container ..props>\n        // props.children will be overwritten with this\n        <span>{ \"I am a child, as you can see\" }</span>\n    </Container>\n};\n```\n\n----------------------------------------\n\nTITLE: Using Keyboard Events in Yew 0.19.0 (Rust)\nDESCRIPTION: Shows how to handle keyboard events in Yew 0.19.0 using the onkeydown event handler, replacing the previous KeyboardService.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/migration-guides/yew/from-0_18_0-to-0_19_0.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet onkeydown = Callback::from(|e| {\n    e.prevent_default();\n    todo!(\"use `e`, just like in service methods.\");\n});\nhtml! {\n    <input {onkeydown} />\n}\n```\n\n----------------------------------------\n\nTITLE: Optional Child Component with Conditional Rendering\nDESCRIPTION: Implementing optional child components with flexible sidebar rendering\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/advanced-topics/children.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, html_nested, virtual_dom::VChild, Component, Context, Html, Properties};\n\npub struct PageSideBar;\n\n#[derive(Properties, PartialEq)]\npub struct PageProps {\n    #[prop_or_default]\n    pub sidebar: Option<VChild<PageSideBar>>,\n}\n\nstruct Page;\n\nimpl Component for Page {\n    type Message = ();\n    type Properties = PageProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"page\">\n                { ctx.props().sidebar.clone().map(Html::from).unwrap_or_default() }\n            </div>\n        }\n    }\n}\n\npub fn render_page(with_sidebar: bool) -> Html {\n    if with_sidebar {\n        html! {\n            <Page sidebar={html_nested! { <PageSideBar /> }} />\n        }\n    } else {\n        html! { <Page /> }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Nested Components with Children in Yew\nDESCRIPTION: Shows how to create components that accept child elements by including a children field in the Properties struct. The Container component renders any children passed to it within a div element with a specified ID.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/components.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    id: String,\n    children: Html,\n}\n\n#[function_component]\nfn Container(props: &Props) -> Html {\n    html! {\n        <div id={props.id.clone()}>\n            { props.children.clone() }\n        </div>\n    }\n}\n\nhtml! {\n    <Container id=\"container\">\n        <h4>{ \"Hi\" }</h4>\n        <div>{ \"Hello\" }</div>\n    </Container>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Client-side Hydration in Yew\nDESCRIPTION: Shows how to implement client-side hydration for a server-side rendered Yew application. The code demonstrates creating a renderer and hydrating the application under the body element.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/advanced-topics/server-side-rendering.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew::Renderer;\n\n#[function_component]\nfn App() -> Html {\n    html! {<div>{\"Hello, World!\"}</div>}\n}\n\nfn main() {\n    let renderer = Renderer::<App>::new();\n\n    // hydrates everything under body element, removes trailing\n    // elements (if any).\n    renderer.hydrate();\n}\n```\n\n----------------------------------------\n\nTITLE: Importing JavaScript Console Functions with wasm-bindgen in Rust\nDESCRIPTION: This snippet demonstrates how to manually import and use different versions of the console.log JavaScript function using the wasm-bindgen macro. It shows how to handle JavaScript namespaces and polymorphic functions with different signatures.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/basic-web-technologies/wasm-bindgen.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::prelude::*;\n\n// First up let's take a look of binding `console.log` manually, without the\n// help of `web_sys`. Here we're writing the `#[wasm_bindgen]` annotations\n// manually ourselves, and the correctness of our program relies on the\n// correctness of these annotations!\n#[wasm_bindgen]\nextern \"C\" {\n    // Use `js_namespace` here to bind `console.log(..)` instead of just\n    // `log(..)`\n    #[wasm_bindgen(js_namespace = console)]\n    fn log(s: &str);\n\n    // The `console.log` is quite polymorphic, so we can bind it with multiple\n    // signatures. Note that we need to use `js_name` to ensure we always call\n    // `log` in JS.\n    #[wasm_bindgen(js_namespace = console, js_name = log)]\n    fn log_u32(a: u32);\n\n    // Multiple arguments too!\n    #[wasm_bindgen(js_namespace = console, js_name = log)]\n    fn log_many(a: &str, b: &str);\n}\n\n// using the imported functions!\nlog(\"Hello from Rust!\");\nlog_u32(42);\nlog_many(\"Logging\", \"many values!\");\n```\n\n----------------------------------------\n\nTITLE: Using 'with props' Syntax to Override Children in Yew\nDESCRIPTION: Demonstrates how to use the 'with props' syntax where children passed in the `html!` macro overwrite the ones already present in the props.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/components.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, props, Children};\n\nlet props = yew::props!(Container::Properties {\n    id: \"container-2\",\n    children: Children::default(),\n});\nhtml! {\n    <Container with props>\n        // props.children will be overwritten with this\n        <span>{ \"I am a child, as you can see\" }</span>\n    </Container>\n}\n```\n\n----------------------------------------\n\nTITLE: Prop Drilling Example in Yew Components\nDESCRIPTION: Demonstrates the problem of prop drilling where theme data needs to be passed through multiple component layers. Shows how props become cumbersome in deeply nested component structures.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/contexts.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html, Properties, function_component};\n\n#[derive(Clone, PartialEq)]\npub struct Theme {\n    foreground: String,\n    background: String,\n}\n\n#[derive(PartialEq, Properties)]\npub struct NavbarProps {\n    theme: Theme,\n}\n\n#[function_component]\nfn Navbar(props: &NavbarProps) -> Html {\n    html! {\n        <div>\n            <Title theme={props.theme.clone()}>\n                { \"App title\" }\n            </Title>\n            <NavButton theme={props.theme.clone()}>\n                { \"Somewhere\" }\n            </NavButton>\n        </div>\n    }\n}\n\n#[derive(PartialEq, Properties)]\npub struct ThemeProps {\n    theme: Theme,\n    children: Html,\n}\n\n#[function_component]\nfn Title(_props: &ThemeProps) -> Html {\n    html! {\n        // impl\n    }\n}\n\n#[function_component]\nfn NavButton(_props: &ThemeProps) -> Html {\n    html! {\n        // impl\n    }\n}\n\n/// App root\n#[function_component]\nfn App() -> Html {\n    let theme = Theme {\n        foreground: \"yellow\".to_owned(),\n        background: \"pink\".to_owned(),\n    };\n\n    html! {\n        <Navbar {theme} />\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Yew Component Template in Jetbrains IDEs\nDESCRIPTION: This Rust snippet provides a template for creating a new Yew component in Jetbrains IDEs. To use it, navigate to File | Settings | Editor | Live Templates, select Rust, and add this template. The structure includes the component, a message enum, and view implementation. No external dependencies other than Yew library assumed.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/more/development-tips.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nstruct $NAME$;\n\nenum Msg {\n}\n\nimpl Component for $NAME$ {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            $HTML$\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: 在 Yew 中使用函数生成条件 HTML (Rust)\nDESCRIPTION: 这个代码片段展示了如何在 Yew 中使用函数或闭包来生成条件 HTML。它将条件逻辑封装在一个函数中，以提高代码的可读性。\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet show_link = true;\nlet maybe_display_link = move || -> Html {\n  if show_link {\n    html! {\n      <a href=\"https://example.com\">{\"Link\"}</a>\n    }\n  } else {\n    html! {}\n  }\n};\n\nhtml! {\n     <div>{maybe_display_link()}</div>\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid Multiple Root Elements in Yew\nDESCRIPTION: Demonstrates invalid usage where multiple root elements are provided without a fragment wrapper, which will cause a compilation error in Yew's html! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/lists.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\n/* error: only one root html element allowed */\nhtml! {\n    <div></div>\n    <p></p>\n}\n```\n\n----------------------------------------\n\nTITLE: Value Interpolation in HTML Templates\nDESCRIPTION: Demonstrates how to embed Rust values into HTML templates using curly brackets interpolation. Shows multiple examples including string interpolation and combining HTML fragments.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/basic-web-technologies/html.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet header_text = \"Hello world\".to_string();\nlet header_html: Html = html! {\n    <h1>{header_text}</h1>\n};\n\nlet count: usize = 5;\nlet counter_html: Html = html! {\n    <p>{\"My age is: \"}{count}</p>\n};\n\nlet combined_html: Html = html! {\n    <div>{header_html}{counter_html}</div>\n};\n```\n\n----------------------------------------\n\nTITLE: Component Props with Children Override in Yew\nDESCRIPTION: Demonstrates how to use the base props expression with children, showing how children passed in the html! macro override existing children in props.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/components.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    id: String,\n    children: Children,\n}\n\n#[function_component]\nfn Container(props: &Props) -> Html {\n    html! {\n        <div id={props.id.clone()}>\n            { props.children.clone() }\n        </div>\n    }\n}\n\nlet props = yew::props!(Props {\n    id: \"container-2\",\n    children: Children::default(),\n});\n\nhtml! {\n    <Container ..props>\n        // props.children will be overwritten with this\n        <span>{ \"I am a child, as you can see\" }</span>\n    </Container>\n};\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Proper Tag Closure in Yew HTML Macros\nDESCRIPTION: Shows how to correctly close tags in Yew's html! macro. Includes examples of self-closing tags and tags with separate closing elements.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.20/concepts/html/elements.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n  <div id=\"my_div\"></div>\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n  <input id=\"my_input\" />\n}\n```\n\n----------------------------------------\n\nTITLE: Using #[prop_or_else(function)] for Computed Default Values in Yew\nDESCRIPTION: Example of using the #[prop_or_else(function)] attribute to compute a default value by calling a function when a property is not provided. The function is called when the property is constructed.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/function-components/properties.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nfn create_default_name() -> AttrValue {\n    AttrValue::Static(\"Bob\")\n}\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    #[prop_or_default]\n    pub is_loading: bool,\n    #[prop_or_else(create_default_name)]\n    pub name: AttrValue,\n}\n\n#[function_component]\nfn Hello(&Props { is_loading, ref name }: &Props) -> Html {\n    if is_loading {\n        html! { \"Loading\" }\n    } else {\n        html! { <>\"Hello \"{name}</> }\n    }\n}\n\n// 使用預設值\n#[function_component]\nfn Case1() -> Html {\n    html! { <Hello /> }\n}\n// 或不覆蓋預設值\n#[function_component]\nfn Case2() -> Html {\n    html! { <Hello name=\"Sam\" /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Yew Classes Macro Optional Value Example\nDESCRIPTION: This snippet demonstrates how to use an `Option<String>` with the `classes!` macro for conditionally applying a class to a div element in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/html/classes.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(Some(\"class\"))} />\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Generic Function Components in Rust with Yew\nDESCRIPTION: Demonstrates how to create a generic function component that can accept and display different types of data. The component requires the generic type T to implement PartialEq and Display traits. Shows usage examples with both integer and string types.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/function-components/generics.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt::Display;\nuse yew::{function_component, html, Properties, Html};\n\n#[derive(Properties, PartialEq)]\npub struct Props<T>\nwhere\n    T: PartialEq,\n{\n    data: T,\n}\n\n#[function_component]\npub fn MyGenericComponent<T>(props: &Props<T>) -> Html\nwhere\n    T: PartialEq + Display,\n{\n    html! {\n        <p>\n            { &props.data }\n        </p>\n    }\n}\n\n// then can be used like this\nhtml! {\n    <MyGenericComponent<i32> data=123 />\n};\n\n// or\nhtml! {\n    <MyGenericComponent<String> data={\"foo\".to_string()} />\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Typed Children in Yew\nDESCRIPTION: This example shows how to create a List component that only accepts Item components as children using ChildrenWithProps<T>.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/children.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, ChildrenWithProps, Component, Context, Html, Properties};\n\npub struct Item;\n\nimpl Component for Item {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"item\" }\n        }\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: ChildrenWithProps<Item>,\n}\n\npub struct List;\n\nimpl Component for List {\n    type Message = ();\n    type Properties = ListProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"list\">\n                { for ctx.props().children.iter() }\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using String Variable with classes! Macro in Yew\nDESCRIPTION: Demonstrates how to use a String variable containing space-separated class names with the classes! macro in Yew HTML templates.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/classes.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nlet my_classes = String::from(\"class-1 class-2\");\n\nhtml! {\n  <div class={classes!(my_classes)}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using String-like Attributes in Yew HTML\nDESCRIPTION: This snippet shows different ways to pass string-like values as attributes in Yew's html! macro. It demonstrates using str, String, and AttrValue types for the 'placeholder' attribute.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/elements.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, virtual_dom::AttrValue};\n\nlet str_placeholder = \"I'm a str!\";\nlet string_placeholder = String::from(\"I'm a String!\");\nlet attrvalue_placeholder = AttrValue::from(\"I'm an AttrValue!\");\n\nhtml! {\n    <div>\n        <input placeholder={str_placeholder} />\n        <input placeholder={string_placeholder} />\n        <input placeholder={attrvalue_placeholder} />\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using yew::props! Macro to Create Properties\nDESCRIPTION: Example of using the yew::props! macro to create properties with the same syntax as the html! macro. This allows creating props separately before passing them to a component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/function-components/properties.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    #[prop_or_default]\n    pub is_loading: bool,\n    #[prop_or(AttrValue::Static(\"Bob\"))]\n    pub name: AttrValue,\n}\n\n#[function_component]\nfn Hello(&Props { is_loading, ref name }: &Props) -> Html {\n    if is_loading {\n        html! { \"Loading\" }\n    } else {\n        html! { <>\"Hello \"{name}</> }\n    }\n}\n\n#[function_component]\nfn App() -> Html {\n    let pre_made_props = yew::props! {\n        Props {} // 注意我們不需要指定 name 屬性\n    };\n    html! { <Hello ..pre_made_props /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Event Listener Hook in Yew\nDESCRIPTION: This snippet shows the full implementation of the use_event custom hook. It uses use_effect_with to manage the lifecycle of the event listener, recreating it when dependencies change.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse web_sys::{Event, EventTarget};\nuse std::borrow::Cow;\nuse std::rc::Rc;\nuse gloo::events::EventListener;\n\n#[hook]\npub fn use_event<E, F>(target: &EventTarget, event_type: E, callback: F)\nwhere\n    E: Into<Cow<'static, str>>,\n    F: Fn(Event) + 'static,\n{\n    #[derive(PartialEq, Clone)]\n    struct EventDependents {\n        target: EventTarget,\n        event_type: Cow<'static, str>,\n        callback: Callback<Event>,\n    }\n\n    let deps = EventDependents {\n        target: target.clone(),\n        event_type: event_type.into(),\n        callback: Callback::from(callback),\n    };\n\n    use_effect_with(\n        deps,\n        |deps| {\n            let EventDependents {\n                target,\n                event_type,\n                callback,\n            } = deps.clone();\n\n            let listener = EventListener::new(&target, event_type, move |e| {\n                callback.emit(e.clone());\n            });\n\n            move || {\n                drop(listener);\n            }\n        },\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Navigating Using History API in Struct Components\nDESCRIPTION: This snippet presents how to obtain the history instance within struct components using the `ctx.link().history()` method to enable navigation to different routes.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/router.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn view(&self, ctx: &Context<Self>) -> Html {\n    let history = ctx.link().history().unwrap();\n    let onclick = Callback::once(move |_| history.push(MainRoute::Home));\n    html!{\n        <button {onclick}>{\"Go Home\"}</button>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Event Target Handling Component Implementation\nDESCRIPTION: A complete component implementation showing both cautious and dangerous approaches to handling event targets using JsCast.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/events.mdx#2025-04-16_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\n# need wasm-bindgen for JsCast\nwasm-bindgen = \"0.2\"\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::JsCast;\nuse web_sys::{EventTarget, HtmlInputElement};\nuse yew::prelude::*;\n\n#[function_component]\nfn MyComponent() -> Html {\n    let input_value_handle = use_state(String::default);\n    let input_value = (*input_value_handle).clone();\n\n    let on_cautious_change = {\n        let input_value_handle = input_value_handle.clone();\n\n        Callback::from(move |e: Event| {\n            let target: Option<EventTarget> = e.target();\n            let input = target.and_then(|t| t.dyn_into::<HtmlInputElement>().ok());\n\n            if let Some(input) = input {\n                input_value_handle.set(input.value());\n            }\n        })\n    };\n\n    let on_dangerous_change = Callback::from(move |e: Event| {\n        let target: EventTarget = e\n            .target()\n            .expect(\"Event should have a target when dispatched\");\n        input_value_handle.set(target.unchecked_into::<HtmlInputElement>().value());\n    });\n\n    html! {\n        <>\n            <label for=\"cautious-input\">\n                { \"My cautious input:\" }\n                <input onchange={on_cautious_change}\n                    id=\"cautious-input\"\n                    type=\"text\"\n                    value={input_value.clone()}\n                />\n            </label>\n            <label for=\"dangerous-input\">\n                { \"My dangerous input:\" }\n                <input onchange={on_dangerous_change}\n                    id=\"dangerous-input\"\n                    type=\"text\"\n                    value={input_value}\n                />\n            </label>\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering with if - Rust\nDESCRIPTION: Demonstrates using the `if` block for conditional rendering of elements in Yew, displaying content based on a simple boolean condition.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/introduction.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\\n\\nhtml! {\\n    if true {\\n        <p>{ \\\"True case\\\" }</p>\\n    }\\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Message Enum for Event Handling in Yew\nDESCRIPTION: Defines a message enum in Rust for handling input change events in a Yew component. It contains a single variant to capture the input value as a string.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/events.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub enum Msg {\n    InputValue(String),\n}\n```\n\n----------------------------------------\n\nTITLE: Using Yew's html! Macro in Rust\nDESCRIPTION: The html! macro in Yew allows writing UI code in an HTML-like syntax. It generates Rust code that interacts with Yew's public API. The macro handles DOM manipulation and provides a declarative way to define the UI structure.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/how-it-works.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n    // Your HTML-like syntax here\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Navigation in Struct Components\nDESCRIPTION: Shows how to obtain a navigator instance in struct components using the `ctx.link().navigator()` API, which can then be used to programmatically change routes.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/router.mdx#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nfn view(&self, ctx: &Context<Self>) -> Html {\n    let navigator = ctx.link().navigator().unwrap();\n    let onclick = Callback::from(move |_| navigator.push(&MainRoute::Home));\n    html!{\n        <button {onclick}>{\"Go Home\"}</button>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing History API with Navigator API in Yew 0.17.0\nDESCRIPTION: Yew 0.17.0 introduces the Navigator API as a replacement for the previous History API. This change affects how navigation and routing are handled in Yew applications.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/migration-guides/yew-router/from-0_16_0-to-0_17_0.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nnavigator\n```\n\n----------------------------------------\n\nTITLE: Basic Child Component Rendering in Yew\nDESCRIPTION: A simple implementation of a component that renders its children using the generic `Html` type\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/advanced-topics/children.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html, Properties};\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: Html,\n}\n\npub struct List;\n\nimpl Component for List {\n    type Message = ();\n    type Properties = ListProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"list\">\n                {ctx.props().children.clone()}\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the View Lifecycle Method in Rust for Yew Components\nDESCRIPTION: Example of implementing the view lifecycle method for a Yew component. This method describes how a component should be rendered to the DOM using the html! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Component, Context, html, Html, Properties};\n\nenum Msg {\n    Click,\n}\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    button_text: String,\n}\n\nstruct MyComponent;\n\nimpl Component for MyComponent {\n    type Message = Msg;\n    type Properties = Props;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let onclick = ctx.link().callback(|_| Msg::Click);\n        html! {\n            <button {onclick}>{ &ctx.props().button_text }</button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Typed Children Components in Yew\nDESCRIPTION: Implementation of a List component that only accepts children of a specific type (Item components) using ChildrenWithProps.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/advanced-topics/children.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, ChildrenWithProps, Component, Context, Html, Properties};\n\npub struct Item;\n\nimpl Component for Item {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"item\" }\n        }\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: ChildrenWithProps<Item>,\n}\n\npub struct List;\n\nimpl Component for List {\n    type Message = ();\n    type Properties = ListProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"list\">\n                { for ctx.props().children.iter() }\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Trunk WebAssembly Bundler\nDESCRIPTION: Installs Trunk, the recommended bundler for Yew applications, using cargo. Trunk is used for managing deployment and packaging of WebAssembly applications.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/getting-started/introduction.mdx#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n# note that this might take a while to install, because it compiles everything from scratch\n# Trunk also provides prebuilt binaries for a number of major package managers\n# See https://trunkrs.dev/#install for further details\ncargo install --locked trunk\n```\n\n----------------------------------------\n\nTITLE: Using NodeRef::get with JsCast in Yew\nDESCRIPTION: This snippet shows an alternative way to convert a Node reference to a specific HTML element type using NodeRef::get and JsCast::dyn_into.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::JsCast;\nuse web_sys::HtmlInputElement;\nuse yew::NodeRef;\n\nfn with_jscast(node_ref: NodeRef) {\n    if let Some(input) = node_ref\n        .get()\n        .and_then(|node| node.dyn_into::<HtmlInputElement>().ok()) {\n        // do something with HtmlInputElement\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Show Storage Changed Component\nDESCRIPTION: This component demonstrates listening for the 'storage' event on the window object using `use_effect`.  It uses a `use_state` hook to track whether the event has been fired and updates the UI accordingly.  The `gloo` crate is used for event handling.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse gloo::events::EventListener;\nuse gloo::utils::window;\nuse std::mem::drop;\n\n\n#[function_component(ShowStorageChanged)]\npub fn show_storage_changed() -> Html {\n    let state_storage_changed = use_state(|| false);\n\n    {\n        let state_storage_changed = state_storage_changed.clone();\n        use_effect(|| {\n            let listener = EventListener::new(&window(), \"storage\", move |_| state_storage_changed.set(true));\n\n            move || { drop(listener); }\n        });\n    }\n\n    html! { <div>{\"Storage Event Fired: \"}{*state_storage_changed}</div> }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Hook with use_hook in Yew\nDESCRIPTION: This snippet demonstrates the implementation of a custom hook `use_subscribe` using `use_hook`. It manages subscriptions and message storage, leveraging Yew's effect system.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.20/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn use_subscribe() -> Rc<RefCell<Vec<String>>> {\n    use_hook(\n        // hook's handler. all the logic goes in here\n        |state: &mut UseSubscribeState, hook_callback| {\n            // calling other Hooks inside a hook\n            use_effect(move || {\n                let producer = EventBus::bridge(Callback::from(move |msg| {\n                    hook_callback(\n                        // where the mutations of state are performed\n                        |state| {\n                            (*state.messages).borrow_mut().deref_mut().push(msg);\n                            true // should re-render\n                        }, false // run post-render\n                    )\n                }));\n\n                || drop(producer)\n            });\n\n            // return from hook\n            state.messages.clone()\n        },\n        // initial state producer\n        || UseSubscribeState { messages: Rc::new(RefCell::new(vec![])) },\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Expressions into Functions in Yew\nDESCRIPTION: Demonstrates how to extract complex expressions into functions or closures for improved readability in Yew components. This example uses a closure to conditionally render a link.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet show_link = true;\nlet maybe_display_link = move || -> Html {\n  if show_link {\n    html! {\n      <a href=\"https://example.com\">{\"Link\"}</a>\n    }\n  } else {\n    html! {}\n  }\n};\n\nhtml! {\n     <div>{maybe_display_link()}</div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using Link Component with Struct Variants\nDESCRIPTION: Shows how to use the Link component with struct variants of routes that require parameters, passing the necessary data for the route.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/router.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n<Link<Route> to={Route::Post { id: \"new-yew-release\".to_string() }}>{ \"Yew!\" }</Link<Route>>\n```\n\n----------------------------------------\n\nTITLE: Building HTML Structure with Yew's html! Macro\nDESCRIPTION: Converting HTML structure to Yew's html! macro syntax for rendering the application layout.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/tutorial/index.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n    <>\n        <h1>{ \"RustConf Explorer\" }</h1>\n        <div>\n            <h3>{\"Videos to watch\"}</h3>\n            <p>{ \"John Doe: Building and breaking things\" }</p>\n            <p>{ \"Jane Smith: The development process\" }</p>\n            <p>{ \"Matt Miller: The Web 7.0\" }</p>\n            <p>{ \"Tom Jerry: Mouseless development\" }</p>\n        </div>\n        <div>\n            <h3>{ \"John Doe: Building and breaking things\" }</h3>\n            <img src=\"https://placehold.co/640x360.png?text=Video+Player+Placeholder\" alt=\"video thumbnail\" />\n        </div>\n    </>\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Child Component Rendering in Rust with Yew\nDESCRIPTION: Simple implementation of a list component that renders children without type restrictions\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/advanced-topics/children.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html, Properties};\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: Html,\n}\n\npub struct List;\n\nimpl Component for List {\n    type Message = ();\n    type Properties = ListProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"list\">\n                {ctx.props().children.clone()}\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using wasm-bindgen to Import console.log Functions from JavaScript\nDESCRIPTION: Example of using the #[wasm_bindgen] macro to manually import and use various console.log functions from JavaScript with different signatures and parameter types.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/basic-web-technologies/wasm-bindgen.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::prelude::*;\n\n// 首先讓我們手動綁定 `console.log`，而不使用 `web_sys` 的幫助。\n// 在這裡，我們手動寫 `#[wasm_bindgen]` 註解，我們程式的正確性取決於這些註解的正確性！\n#[wasm_bindgen]\nextern \"C\" {\n    // 在這裡使用 `js_namespace` 來綁定 `console.log(..)` 而不是只有 `log(..)`\n    #[wasm_bindgen(js_namespace = console)]\n    fn log(s: &str);\n\n    // `console.log` 是多態的，所以我們可以使用多個簽章綁定它。\n    #[wasm_bindgen(js_namespace = console, js_name = log)]\n    fn log_u32(a: u32);\n\n    // 多個參數也是可以的！\n    #[wasm_bindgen(js_namespace = console, js_name = log)]\n    fn log_many(a: &str, b: &str);\n}\n\n// 使用導入的函數！\nlog(\"Hello from Rust!\");\nlog_u32(42);\nlog_many(\"Logging\", \"many values!\");\n```\n\n----------------------------------------\n\nTITLE: Using Batch Callback for Keyboard Events in Yew (Rust)\nDESCRIPTION: This snippet demonstrates how to use a batch callback in a Yew component to handle keyboard events, specifically checking for the 'Enter' key. It allows for conditional messaging without causing unnecessary updates.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/struct-components/callbacks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nuse yew::{events::KeyboardEvent, html, Component, Context, Html};\n\nenum Msg {\n    Submit,\n}\n\nstruct Comp;\n\nimpl Component for Comp {\n\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        // highlight-start\n        let onkeypress = ctx.link().batch_callback(|event: KeyboardEvent| {\n            if event.key() == \"Enter\" {\n                Some(Msg::Submit)\n            } else {\n                None\n            }\n        });\n\n        html! {\n            <input type=\"text\" {onkeypress} />\n        }\n        // highlight-end\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing DOM Nodes in Yew\nDESCRIPTION: Demonstrates how to manually create and manage DOM nodes using web-sys and convert them to Yew's Html values. This is useful for integrating with JS libraries that might conflict with managed components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/html/elements.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{Element, Node};\nuse yew::prelude::*;\nuse gloo::utils::document;\n\n#[function_component]\nfn MyComponent() -> Html {\n    // メモ化された関数、一度だけ実行されます\n    let node = use_memo(\n        (),\n        |_| {\n            // ドキュメントから div 要素を作成\n            let div: Element = document().create_element(\"div\").unwrap();\n            // コンテンツ、クラスなどを追加\n            div.set_inner_html(\"Hello, World!\");\n            // Element を Node に変換\n            let node: Node = div.into();\n            // その Node を Html 値として返す\n            Html::VRef(node)\n        },\n    );\n\n    // use_memo は Rc ポインタを返すので、参照解除とクローンが必要です\n    (*node).clone()\n}\n```\n\n----------------------------------------\n\nTITLE: Using Array of Classes with classes! Macro in Yew\nDESCRIPTION: Shows how to use an array of string literals with the classes! macro to set multiple classes on an HTML element in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/classes.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!([\"class-1\", \"class-2\"])}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for Yew Project\nDESCRIPTION: Updates the Cargo.toml file to include Yew as a dependency with the client-side rendering feature.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/tutorial/index.mdx#2025-04-16_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"yew-app\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nyew = { git = \"https://github.com/yewstack/yew/\", features = [\"csr\"] }\n```\n\n----------------------------------------\n\nTITLE: Optional Attributes in Yew\nDESCRIPTION: Demonstrates how to use optional attributes in Yew components using Some(x) or None values.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/elements.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet maybe_id = Some(\"foobar\");\n\nhtml! {\n    <div id={maybe_id}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Higher Order Components with Context in Yew\nDESCRIPTION: This code snippet demonstrates how to create a Higher Order Component in Yew to provide Context functionality to a struct component. It includes a function component that accesses the Context and passes it down to a struct component, showcasing the integration of different component types in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/struct-components/hoc.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(Clone, Debug, PartialEq)]\nstruct Theme {\n    foreground: String,\n    background: String,\n}\n\n#[function_component]\npub fn App() -> Html {\n    let ctx = use_state(|| Theme {\n        foreground: \"#000000\".to_owned(),\n        background: \"#eeeeee\".to_owned(),\n    });\n\n    html! {\n        <ContextProvider<Theme> context={(*ctx).clone()}>\n            <ThemedButtonHOC />\n        </ContextProvider<Theme>>\n    }\n}\n\n#[function_component]\npub fn ThemedButtonHOC() -> Html {\n    let theme = use_context::<Theme>().expect(\"no ctx found\");\n\n    html! {<ThemedButtonStructComponent {theme} />}\n}\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub theme: Theme,\n}\n\nstruct ThemedButtonStructComponent;\n\nimpl Component for ThemedButtonStructComponent {\n    type Message = ();\n    type Properties = Props;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let theme = &ctx.props().theme;\n        html! {\n            <button style={format!(\n                    \"background: {}; color: {};\",\n                    theme.background,\n                    theme.foreground\n                )}\n            >\n                { \"Click me!\" }\n            </button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using JsCast for type conversion in Rust with web-sys\nDESCRIPTION: Shows how to use the JsCast trait to safely convert between JavaScript types when working with web-sys events in Rust.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/basic-web-technologies/wasm-bindgen.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::JsCast;\nuse web_sys::{Event, EventTarget, HtmlInputElement, HtmlSelectElement};\n\nfn handle_event(event: Event) {\n    let target: EventTarget = event\n        .target()\n        .expect(\"I'm sure this event has a target!\");\n\n    if let Some(select_element) = target.dyn_ref::<HtmlSelectElement>() {\n        // do something amazing here\n        return;\n    }\n\n    let input_element: HtmlInputElement = target.unchecked_into();\n}\n```\n\n----------------------------------------\n\nTITLE: Using Optional Attributes for HTML Elements in Yew\nDESCRIPTION: This snippet demonstrates how to use optional attributes for HTML elements in Yew. It shows setting an optional 'id' attribute using Some(x) or None.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/elements.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet maybe_id = Some(\"foobar\");\n\nhtml! {\n    <div id={maybe_id}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: HTML Macro: Self-Closing Tag Example in Yew\nDESCRIPTION: This snippet demonstrates how to create a self-closing HTML element, specifically an `input` element, using the `html!` macro in Yew.  It shows the correct syntax for self-closing tags using `/>`. The `use yew::prelude::*;` statement imports necessary Yew functionalities.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/html/introduction.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n  <input id=\"my_input\" />\n};\n\n```\n\n----------------------------------------\n\nTITLE: Building a GET Request with Yew's Fetch Service\nDESCRIPTION: Example of creating a GET request using Yew's fetch service. This snippet demonstrates how to build a request with no body (Nothing) to retrieve data from an API endpoint.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/services/fetch.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::format::Nothing;\nuse yew::services::fetch::Request;\nlet get_request = Request::get(\"https://example.com/api/v1/get/something\")\n    .body(Nothing)\n    .expect(\"Could not build that request\");\n```\n\n----------------------------------------\n\nTITLE: Specifying Class Attributes in Yew\nDESCRIPTION: Demonstrates various ways to specify class attributes for elements in Yew, including constants, multiple classes, interpolation, expressions, tuples, and vectors.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.18.0/concepts/html/elements.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n  <div class=\"container\"></div>\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n  <div class=\"container center-align\"></div>\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n  <div class=format!(\"{}-container\", size)></div>\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n  <div class=self.classes()></div>\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n  <div class=(\"class-1\", \"class-2\")></div>\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n  <div class=vec![\"class-1\", \"class-2\"]></div>\n}\n```\n\n----------------------------------------\n\nTITLE: Event Target Handling with JsCast in Yew Components\nDESCRIPTION: A complete function component example demonstrating two approaches to handle event targets: a cautious approach using dyn_into with proper error handling and a faster but less safe approach using unchecked_into.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/events.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n//highlight-next-line\nuse wasm_bindgen::JsCast;\nuse web_sys::{EventTarget, HtmlInputElement};\nuse yew::prelude::*;\n\n#[function_component]\nfn MyComponent() -> Html {\n    let input_value_handle = use_state(String::default);\n    let input_value = (*input_value_handle).clone();\n\n    let on_cautious_change = {\n        let input_value_handle = input_value_handle.clone();\n\n        Callback::from(move |e: Event| {\n            // When events are created the target is undefined, it's only\n            // when dispatched does the target get added.\n            let target: Option<EventTarget> = e.target();\n            // Events can bubble so this listener might catch events from child\n            // elements which are not of type HtmlInputElement\n            //highlight-next-line\n            let input = target.and_then(|t| t.dyn_into::<HtmlInputElement>().ok());\n\n            if let Some(input) = input {\n                input_value_handle.set(input.value());\n            }\n        })\n    };\n\n    let on_dangerous_change = Callback::from(move |e: Event| {\n        let target: EventTarget = e\n            .target()\n            .expect(\"Event should have a target when dispatched\");\n        // You must KNOW target is a HtmlInputElement, otherwise\n        // the call to value would be Undefined Behaviour (UB).\n        // Here we are sure that this is input element so we can convert it to the appropriate type without checking\n        //highlight-next-line\n        input_value_handle.set(target.unchecked_into::<HtmlInputElement>().value());\n    });\n\n    html! {\n        <>\n            <label for=\"cautious-input\">\n                { \"My cautious input:\" }\n                <input onchange={on_cautious_change}\n                    id=\"cautious-input\"\n                    type=\"text\"\n                    value={input_value.clone()}\n                />\n            </label>\n            <label for=\"dangerous-input\">\n                { \"My dangerous input:\" }\n                <input onchange={on_dangerous_change}\n                    id=\"dangerous-input\"\n                    type=\"text\"\n                    value={input_value}\n                />\n            </label>\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Yew Components that Accept Classes as Properties\nDESCRIPTION: Demonstrates how to create a Yew component that accepts classes as properties, combining them with internal classes and conditional classes. Uses the boolinator crate for conditional class application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/classes.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse boolinator::Boolinator;\nuse yew::{classes, html, Children, Classes, Component, Html, Properties};\n\n#[derive(Clone, Properties)]\nstruct Props {\n    #[prop_or_default]\n    class: Classes,\n    fill: bool,\n    children: Children,\n}\n\nstruct MyComponent {\n    props: Props,\n}\n\nimpl Component for MyComponent {\n    type Properties = Props;\n\n    // ...\n\n    fn view(&self) -> Html {\n        let Props {\n            class,\n            fill,\n            children,\n        } = &self.props;\n        html! {\n            <div\n                class=classes!(\n                    \"my-container-class\",\n                    fill.as_some(\"my-fill-class\"),\n                    class.clone(),\n                )\n            >\n                { children.clone() }\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using classes! macro with an Optional value in Yew\nDESCRIPTION: Shows how to conditionally apply a CSS class using the Some variant of Option with the classes! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(Some(\"class\"))} />\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a VideoDetails Component in Rust with Yew\nDESCRIPTION: This code defines a VideoDetails component that displays information about a selected video. It includes properties for the video data and renders the video title and a placeholder image.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nuse website_test::tutorial::Video;\nuse yew::prelude::*;\n\n#[derive(Properties, PartialEq)]\nstruct VideosDetailsProps {\n    video: Video,\n}\n\n#[function_component(VideoDetails)]\nfn video_details(VideosDetailsProps { video }: &VideosDetailsProps) -> Html {\n    html! {\n        <div>\n            <h3>{ video.title.clone() }</h3>\n            <img src=\"https://placehold.co/640x360.png?text=Video+Player+Placeholder\" alt=\"video thumbnail\" />\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Recursion Limit for html! Macro in Rust\nDESCRIPTION: Shows how to set a higher recursion limit to avoid compiler errors when using complex `html!` macros in Yew. This attribute is typically added at the crate root.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.21/concepts/html/introduction.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![recursion_limit=\"1024\"]\n```\n\n----------------------------------------\n\nTITLE: Creating a VideoDetails Component in Yew\nDESCRIPTION: This code defines a new component, `VideoDetails`, that displays the details of a selected video. It takes a `Video` struct as props and renders the video's title and a placeholder image. Requires the `yew` crate.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nuse website_test::tutorial::Video;\nuse yew::prelude::*;\n\n#[derive(Properties, PartialEq)]\nstruct VideosDetailsProps {\n    video: Video,\n}\n\n#[function_component(VideoDetails)]\nfn video_details(VideosDetailsProps { video }: &VideosDetailsProps) -> Html {\n    html! {\n        <div>\n            <h3>{ video.title.clone() }</h3>\n            <img src=\"https://placehold.co/640x360.png?text=Video+Player+Placeholder\" alt=\"video thumbnail\" />\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Emmet Support for Yew in VS Code\nDESCRIPTION: This JSON snippet shows how to configure Emmet support for Rust files in VS Code, which is useful for working with Yew's html! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/getting-started/editor-setup.mdx#2025-04-16_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n\"emmet.includeLanguages\": {\n    \"rust\": \"html\",\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Prop Drilling in Yew Components\nDESCRIPTION: This code snippet shows an example of prop drilling, where a Theme struct is passed down through multiple components. It illustrates the problem that contexts aim to solve.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/contexts.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Children, Component, Context, Html, Properties, function_component};\n\n#[derive(Clone, PartialEq)]\npub struct Theme {\n    foreground: String,\n    background: String,\n}\n\n#[derive(PartialEq, Properties)]\npub struct NavbarProps {\n    theme: Theme,\n}\n\n#[function_component]\nfn Navbar(props: &NavbarProps) -> Html {\n    html! {\n        <div>\n            <Title theme={props.theme.clone()}>\n                { \"App title\" }\n            </Title>\n            <NavButton theme={props.theme.clone()}>\n                { \"Somewhere\" }\n            </NavButton>\n        </div>\n    }\n}\n\n#[derive(PartialEq, Properties)]\npub struct ThemeProps {\n    theme: Theme,\n    children: Children,\n}\n\n#[function_component]\nfn Title(_props: &ThemeProps) -> Html {\n    html! {\n        // impl\n    }\n}\n\n#[function_component]\nfn NavButton(_props: &ThemeProps) -> Html {\n    html! {\n        // impl\n    }\n}\n\n/// App root\n#[function_component]\nfn App() -> Html {\n    let theme = Theme {\n        foreground: \"yellow\".to_owned(),\n        background: \"pink\".to_owned(),\n    };\n\n    html! {\n        <Navbar {theme} />\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: HTML Macro: Conditional Rendering in Yew\nDESCRIPTION: This snippet demonstrates conditional rendering in Yew using Rust's `if` statement within the `html!` macro. The content within the `if` block is only rendered if the condition is true. The `use yew::prelude::*;` statement imports necessary Yew functionalities.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/html/introduction.mdx#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n  if true {\n      <p>{ \"True case\" }</p>\n  }\n};\n\n```\n\n----------------------------------------\n\nTITLE: Self-closing HTML Tags in Yew\nDESCRIPTION: Shows how to use self-closing tags in the html! macro\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/introduction.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n  <input id=\"my_input\" />\n};\n```\n\n----------------------------------------\n\nTITLE: Deriving Clone and PartialEq\nDESCRIPTION: This snippet adds `#[derive(Clone, PartialEq)]` to the `Video` struct.  This allows the `Video` struct to be cloned and compared, which is necessary for passing it as a prop to components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\n\"#[derive(Clone, PartialEq)]\nstruct Video {\n    id: usize,\n    title: String,\n    speaker: String,\n    url: String,\n}\"\n```\n\n----------------------------------------\n\nTITLE: Using NodeRef for DOM Element Access\nDESCRIPTION: Demonstrates how to use NodeRef to safely access and interact with DOM elements in a Yew component, providing an alternative to event-based element querying\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/events.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::prelude::*;\n\n#[function_component]\nfn MyComponent() -> Html {\n    let input_node_ref = use_node_ref();\n\n    let input_value_handle = use_state(String::default);\n    let input_value = (*input_value_handle).clone();\n\n    let onchange = {\n        let input_node_ref = input_node_ref.clone();\n\n        Callback::from(move |_| {\n            let input = input_node_ref.cast::<HtmlInputElement>();\n\n            if let Some(input) = input {\n                input_value_handle.set(input.value());\n            }\n        })\n    };\n\n    html! {\n        <>\n            <label for=\"my-input\">\n                { \"My input:\" }\n                <input ref={input_node_ref}\n                    {onchange}\n                    id=\"my-input\"\n                    type=\"text\"\n                    value={input_value}\n                />\n            </label>\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Inter-Component Communication with Callbacks\nDESCRIPTION: Illustrates how callbacks can be used to communicate between parent and child components, enabling message passing through the emit function and props\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.21/advanced-topics/struct-components/callbacks.mdx#2025-04-16_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Creating Yew Function Component Template in Rust\nDESCRIPTION: This snippet defines a template for creating Yew function components in Rust. It includes a Properties struct and a function component with html! macro usage.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/getting-started/editor-setup.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(PartialEq, Properties)]\npub struct $Name$Props {\n}\n\n#[function_component]\npub fn $Name$(props: &$Name$Props) -> Html {\n    html! {\n        <$tag$>$END$</$tag$>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Console Logging with wasm-logger in Rust\nDESCRIPTION: Demonstrates how to set up browser console logging using the wasm-logger crate integrated with the log crate. Shows initialization of the logger and basic logging functionality.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/more/debugging.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse log::info;\nuse wasm_bindgen::JsValue;\n\nfn main() {\n    wasm_logger::init(wasm_logger::Config::default());\n\n    let object = JsValue::from(\"world\");\n    info!(\"Hello {}\", object.as_string().unwrap());\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Local Development Server\nDESCRIPTION: Command to start a local development server that opens a browser window and reflects changes live. Note that this only builds for the English locale.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/README.md#2025-04-16_snippet_1\n\nLANGUAGE: console\nCODE:\n```\nnpm start\n```\n\n----------------------------------------\n\nTITLE: Logging with gloo-console in Rust\nDESCRIPTION: This snippet demonstrates how to use the `gloo-console` crate to log messages to the browser console. It uses the `log!` macro to directly log a `JsValue` along with a string, which is slightly easier than using `wasm_logger` for simple logging.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/more/debugging.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse gloo_console::log;\nuse wasm_bindgen::JsValue;\n\nfn main() {\n    let object = JsValue::from(\"world\");\n    log!(\"Hello\", object)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Listener Component in Rust using Yew\nDESCRIPTION: This snippet demonstrates a function component that listens for storage events using Yew hooks. It shows the basic structure but lacks reusability.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse gloo::events::EventListener;\nuse gloo::utils::window;\nuse std::mem::drop;\n\n\n#[function_component(ShowStorageChanged)]\npub fn show_storage_changed() -> Html {\n    let state_storage_changed = use_state(|| false);\n\n    {\n        let state_storage_changed = state_storage_changed.clone();\n        use_effect(|| {\n            let listener = EventListener::new(&window(), \"storage\", move |_| state_storage_changed.set(true));\n\n            move || { drop(listener); }\n        });\n    }\n\n    html! { <div>{\"Storage Event Fired: \"}{*state_storage_changed}</div> }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating SVG Elements in Yew\nDESCRIPTION: Shows how to create SVG elements within Yew's html! macro, including various SVG tags and attributes.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.18.0/concepts/html/elements.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n    <svg width=\"149\" height=\"147\" viewBox=\"0 0 149 147\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n        <path d=\"M60.5776 13.8268L51.8673 42.6431L77.7475 37.331L60.5776 13.8268Z\" fill=\"#DEB819\"/>\n        <path d=\"M108.361 94.9937L138.708 90.686L115.342 69.8642\" stroke=\"black\" stroke-width=\"4\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        <g filter=\"url(#filter0_d)\">\n            <circle cx=\"75.3326\" cy=\"73.4918\" r=\"55\" fill=\"#FDD630\"/>\n            <circle cx=\"75.3326\" cy=\"73.4918\" r=\"52.5\" stroke=\"black\" stroke-width=\"5\"/>\n        </g>\n        <circle cx=\"71\" cy=\"99\" r=\"5\" fill=\"white\" fill-opacity=\"0.75\" stroke=\"black\" stroke-width=\"3\"/>\n        <defs>\n            <filter id=\"filter0_d\" x=\"16.3326\" y=\"18.4918\" width=\"118\" height=\"118\" filterUnits=\"userSpaceOnUse\" color-interpolation-filters=\"sRGB\">\n                <feGaussianBlur stdDeviation=\"2\"/>\n                <feColorMatrix in=\"SourceAlpha\" type=\"matrix\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\"/>\n            </filter>\n        </defs>\n    </svg>\n}\n```\n\n----------------------------------------\n\nTITLE: Using classes! Macro with Vector in Yew (Rust)\nDESCRIPTION: Shows how to use a vector of class names with the classes! macro in Yew, allowing for dynamic class lists.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(vec![\"class-1\", \"class-2\"])}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Accessing DOM Element using NodeRef in Yew\nDESCRIPTION: This snippet shows how to access the DOM element referenced by the `NodeRef` within the `rendered` method. It first casts the `NodeRef` to a `web_sys::Element` using `cast::<Element>().unwrap()` and then calls `has_attributes()` on the element. This requires the `web_sys` crate to be included as a dependency.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/advanced-topics/struct-components/refs.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::Element;\nuse yew::{html, Component, Context, Html, NodeRef};\n\nstruct Comp {\n    node_ref: NodeRef,\n}\n\nimpl Component for Comp {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            // highlight-next-line\n            node_ref: NodeRef::default(),\n        }\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            // highlight-next-line\n            <div ref={self.node_ref.clone()}></div>\n        }\n    }\n\n    fn rendered(&mut self, _ctx: &Context<Self>, _first_render: bool) {\n        // highlight-start\n        let has_attributes = self.node_ref\n            .cast::<Element>()\n            .unwrap()\n            .has_attributes();\n        // highlight-end\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining VideoDetails Component (Yew/Rust)\nDESCRIPTION: This snippet defines a new `VideoDetails` component to display details of a selected video. It takes a `Video` object as a property and renders the video title and a placeholder image. This showcases a simple component that receives props and renders content based on them.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse website_test::tutorial::Video;\nuse yew::prelude::*;\n\n#[derive(Properties, PartialEq)]\nstruct VideosDetailsProps {\n    video: Video,\n}\n\n#[function_component(VideoDetails)]\nfn video_details(VideosDetailsProps { video }: &VideosDetailsProps) -> Html {\n    html! {\n        <div>\n            <h3>{ video.title.clone() }</h3>\n            <img src=\"https://placehold.co/640x360.png?text=Video+Player+Placeholder\" alt=\"video thumbnail\" />\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using #[prop_or_default] Attribute in Yew\nDESCRIPTION: Demonstrates the use of #[prop_or_default] attribute to initialize a prop with the default value of its type when not explicitly set by the parent component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/function-components/properties.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    #[prop_or_default]\n    pub is_loading: bool,\n}\n\n#[function_component]\nfn HelloWorld(&Props { is_loading }: &Props) -> Html {\n    if is_loading {\n        html! { \"Loading\" }\n    } else {\n        html! { \"Hello world\" }\n    }\n}\n\n// Then use like this with default\n#[function_component]\nfn Case1() -> Html {\n    html! { <HelloWorld /> }\n}\n// Or no override the default\n#[function_component]\nfn Case2() -> Html {\n    html! { <HelloWorld is_loading=true /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating DOM Nodes with web-sys\nDESCRIPTION: Demonstrates how to manually create and manipulate DOM elements using web-sys library in a Yew component\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/elements.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{Element, Node};\nuse yew::{Component, Context, html, Html};\nuse gloo_utils::document;\n\nstruct Comp;\n\nimpl Component for Comp {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        // Create a div element from the document\n        let div: Element = document().create_element(\"div\").unwrap();\n        // Add content, classes etc.\n        div.set_inner_html(\"Hello, World!\");\n        // Convert Element into a Node\n        let node: Node = div.into();\n        // Return that Node as a Html value\n        Html::VRef(node)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using NodeRef for Event Target Access\nDESCRIPTION: Demonstrates accessing input element value using NodeRef instead of event target casting, providing an alternative method for retrieving element values\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/events.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet input_node_ref = use_node_ref();\n\nlet onchange = {\n    let input_node_ref = input_node_ref.clone();\n\n    Callback::from(move |_| {\n        let input = input_node_ref.cast::<HtmlInputElement>();\n\n        if let Some(input) = input {\n            input_value_handle.set(input.value());\n        }\n    })\n};\n```\n\n----------------------------------------\n\nTITLE: Optional Classes in Yew\nDESCRIPTION: Shows how to use Option with the classes! macro for conditional class application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/classes.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(Some(\"class\"))} />\n};\n```\n\n----------------------------------------\n\nTITLE: Using Redirect Component in Yew Router\nDESCRIPTION: Example showing how to use the Redirect component to navigate to a different route conditionally. This pattern is useful for redirecting users when certain conditions are not met, such as authentication.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/router.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n#[function_component(SomePage)]\nfn some_page() -> Html {\n    // made-up hook `use_user`\n    let user = match use_user() {\n        Some(user) => user,\n        // Redirects to the login page when user is `None`.\n        None => return html! {\n            <Redirect<Route> to={Route::Login}/>\n        },\n    };\n    // ... actual page content.\n}\n```\n\n----------------------------------------\n\nTITLE: Component Mounted Lifecycle Method\nDESCRIPTION: Demonstrates using the mounted() method to perform operations after component rendering, such as focusing an input element\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.21/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub struct MyComponent {\n    node_ref: NodeRef,\n}\n\nimpl Component for MyComponent {\n    // ...\n\n    fn view(&self) -> Html {\n        html! {\n            <input ref={self.node_ref.clone()} type=\"text\" />\n        }\n    }\n\n    fn mounted(&mut self) -> ShouldRender {\n        if let Some(input) = self.node_ref.cast::<InputElement>() {\n            input.focus();\n        }\n        false\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using classes! macro with a Vector in Yew\nDESCRIPTION: Demonstrates applying multiple CSS classes to an element using a Vector of string literals with the classes! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(vec![\"class-1\", \"class-2\"])}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Custom Default Props Using prop_or in Yew\nDESCRIPTION: Example demonstrating the use of prop_or attribute to set custom default values for properties.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/function-components/properties.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    #[prop_or(\"Bob\".to_string())]\n    pub name: String,\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n    html! {<>{\"Hello world\"}{props.name.clone()}</>}\n}\n\n#[function_component]\nfn Case1() -> Html {\n    html! {<HelloWorld />}\n}\n\n#[function_component]\nfn Case2() -> Html {\n    html! {<HelloWorld name={\"Sam\".to_string()} />}\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Video Instances to HTML in Yew - Rust\nDESCRIPTION: This snippet shows how to convert the vector of Video instances into HTML format for rendering in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nlet videos = videos.iter().map(|video| html! {\n    <p key={video.id}>{format!(\"{}: {}\", video.speaker, video.title)}</p>\n}).collect::<Html>();\n```\n\n----------------------------------------\n\nTITLE: Installing Trunk for Yew Development - Rust\nDESCRIPTION: This snippet installs Trunk, which is required to build and serve Yew applications.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo install trunk\n```\n\n----------------------------------------\n\nTITLE: Configuring Yew Component Snippets in VS Code\nDESCRIPTION: This JSON snippet defines two VS Code snippets for creating Yew components: one for function components and one for struct components. These snippets can be added to the user's Rust snippets configuration in VS Code.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/getting-started/editor-setup.mdx#2025-04-16_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"New Yew function component\": {\n        \"prefix\": \"yewfc\",\n        \"body\": [\n            \"#[derive(PartialEq, Properties)]\",\n            \"pub struct ${1:ComponentName}Props {}\",\n            \"\",\n            \"#[function_component]\",\n            \"pub fn $1(props: &${1}Props) -> Html {\",\n            \"    let ${1}Props {} = props;\",\n            \"    html! {\",\n            \"        <${2:div}>$0</${2}>\",\n            \"    }\",\n            \"}\"\n        ],\n        \"description\": \"Create a minimal Yew function component\"\n    },\n    \"New Yew struct component\": {\n        \"prefix\": \"yewsc\",\n        \"body\": [\n            \"pub struct ${1:ComponentName};\",\n            \"\",\n            \"pub enum ${1}Msg {\",\n            \"}\",\n            \"\",\n            \"impl Component for ${1} {\",\n            \"    type Message = ${1}Msg;\",\n            \"    type Properties = ();\",\n            \"\",\n            \"    fn create(ctx: &Context<Self>) -> Self {\",\n            \"        Self\",\n            \"    }\",\n            \"\",\n            \"    fn view(&self, ctx: &Context<Self>) -> Html {\",\n            \"        html! {\",\n            \"            $0\",\n            \"        }\",\n            \"    }\",\n            \"}\"\n        ],\n        \"description\": \"Create a new Yew component with a message enum\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Yew Component with Event Handling\nDESCRIPTION: This code defines a Yew component that uses gloo's EventListener to respond to a custom 'custard' event. It involves state management, lifecycle methods, and callback handling for the event listener.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/events.mdx#2025-04-16_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\nuse web_sys::HtmlElement;\nuse yew::{\nevents::Event,\n    html,\n    Component, Context, Html, NodeRef,\n};\n\nuse gloo_events::EventListener;\n\npub struct Comp {\n    my_div: NodeRef,\n    custard_listener: Option<EventListener>,\n}\n\npub enum Msg {\n    Custard,\n}\n\nimpl Component for Comp {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_: &Context<Self>) -> Self {\n        Self {\n            my_div: NodeRef::default(),\n            custard_listener: None,\n        }\n    }\n\n    fn update(&mut self, _: &Context<Self>, msg: Self::Message) -> bool {\n        match msg {\n            Msg::Custard => {\n                // do something about custard..\n                true\n            }\n        }\n    }\n\n    fn view(&self, _: &Context<Self>) -> Html {\n        html! {\n            <div ref={self.my_div.clone()} id=\"my-div\"></div>\n        }\n    }\n\n    fn rendered(&mut self, ctx: &Context<Self>, first_render: bool) {\n        if !first_render {\n            return;\n        }\n\n        if let Some(element) = self.my_div.cast::<HtmlElement>() {\n            // Create your Callback as you normally would\n            let oncustard = ctx.link().callback(|_: Event| Msg::Custard);\n\n            let listener = EventListener::new(\n                &element,\n                \"custard\",\n                move |e| oncustard.emit(e.clone())\n            );\n\n            self.custard_listener = Some(listener);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering with if let - else - Rust\nDESCRIPTION: Demonstrates conditional rendering in Yew using `if let` with an `else` block, showing different elements based on the matched pattern.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/introduction.mdx#2025-04-16_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\\nlet some_text = Some(\\\"text\\\");\\n\\nhtml! {\\n    if let Some(text) = some_text {\\n        <p>{ text }</p>\\n    } else {\\n        <p>{ \\\"False case\\\" }</p>\\n    }\\n};\n```\n\n----------------------------------------\n\nTITLE: Using log crate for Console Logging in Rust\nDESCRIPTION: This snippet showcases how to use the `log` crate with the `wasm-logger` to output information to the console in a Rust/Wasm application. The `log::info!` macro is used as an example to print a message with a debug representation of the `msg` variable.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/more/debugging.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlog::info!(\"Update: {:?}\", msg);\n```\n\n----------------------------------------\n\nTITLE: JavaScript Mousemove Event Example\nDESCRIPTION: This is a simple JavaScript example that captures the mousemove event on an element with the ID 'mousemoveme'. It calculates the x and y coordinates of the mouse relative to the element and logs them to the console.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\ndocument.getElementById('mousemoveme').onmousemove = (e) => {\n    // e 為滑鼠事件對象\n    var rect = e.target.getBoundingClientRect()\n    var x = e.clientX - rect.left // 元素内的 x 位置。\n    var y = e.clientY - rect.top // 元素内的 y 位置。\n    console.log('Left? : ' + x + ' ; Top? : ' + y + '.')\n}\n\n```\n\n----------------------------------------\n\nTITLE: Basic Server-Side Rendering with Yew\nDESCRIPTION: Demonstrates creating a ServerRenderer to render a Yew component on the server and generate HTML as a string\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/advanced-topics/server-side-rendering.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew::ServerRenderer;\n\n#[function_component]\nfn App() -> Html {\n    html! {<div>{\"Hello, World!\"}</div>}\n}\n\n#[tokio::main(flavor = \"current_thread\")]\nasync fn no_main() {\n    let renderer = ServerRenderer::<App>::new();\n\n    let rendered = renderer.render().await;\n\n    // Print: <div>Hello, World!</div>\n    println!(\"{}\", rendered);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Properties with Derived Macros in Rust for Yew Components\nDESCRIPTION: Example code demonstrating how to implement Properties in Yew, including optional properties with default values, PartialEq derivation for optimization, and memory management techniques with Rc for large data. Shows configuration for required fields and default values.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.21/advanced-topics/struct-components/properties.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::rc::Rc;\nuse yew::Properties;\n\n#[derive(Clone, PartialEq)]\npub enum LinkColor {\n    Blue,\n    Red,\n    Green,\n    Black,\n    Purple,\n}\n\nimpl Default for LinkColor {\n    fn default() -> Self {\n        // 除非有指定，否則預設是藍色\n        LinkColor::Blue\n    }\n}\n\n#[derive(Properties, Clone, PartialEq)]\npub struct LinkProps {\n    /// 連結必須要有一個目標\n    href: String,\n    /// 如果連結文字很大，複製字串的參考可以減少記憶體的開銷\n    /// 但除非效能已經成為嚴重的問題，否則通常不建議這麼做\n    text: Rc<String>,\n    /// 連結的顏色\n    #[prop_or_default]\n    color: LinkColor,\n    /// 如果為 None，那 view 方法將不會指定 size\n    #[prop_or_default]\n    size: Option<u32>,\n    /// 當沒有指定 active，預設為 true\n    #[prop_or(true)]\n    active: bool,\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Event Listener in Yew HTML Macro\nDESCRIPTION: Basic example of adding an event listener with a callback in a Yew component's HTML macro, demonstrating the standard pattern for event handling\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/events.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n    <button onclick={Callback::from(|_| ())}>\n        { \"Click me!\" }\n    </button>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Switch Trait for AppRoute Enum in Rust\nDESCRIPTION: This code snippet demonstrates how to create an enum representing different routes in a Yew application and derive the Switch trait. It shows how to use the #[to] attribute to map enum variants to specific URL paths, including capturing dynamic segments.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.18.0/concepts/router.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Switch)]\nenum AppRoute {\n  #[to=\"/login\"]\n  Login,\n  #[to=\"/register\"]\n  Register,\n  #[to=\"/delete_account\"]\n  Delete,\n  #[to=\"/posts/{id}\"]\n  ViewPost(i32),\n  #[to=\"/posts/view\"]\n  ViewPosts,\n  #[to=\"/\"]\n  Home\n}\n```\n\n----------------------------------------\n\nTITLE: 处理HTML字符串属性 - Rust\nDESCRIPTION: 展示Yew中处理HTML字符串属性的不同方法，包括使用&str、String和AttrValue。推荐使用AttrValue，特别是在需要克隆或将属性传递给其他组件时。\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/html/elements.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, virtual_dom::AttrValue};\n\nlet str_placeholder = \"I'm a str!\";\nlet string_placeholder = String::from(\"I'm a String!\");\nlet attrvalue_placeholder = AttrValue::from(\"I'm an AttrValue!\");\n\nhtml! {\n    <div>\n        <input placeholder={str_placeholder} />\n        <input placeholder={string_placeholder} />\n        <input placeholder={attrvalue_placeholder} />\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Callbacks in Yew Components\nDESCRIPTION: This snippet demonstrates how to create and use callbacks in a Yew component. It shows how to create a callback that converts text input into a message, and how to emit a message using the callback.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.22/advanced-topics/struct-components/scope.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html};\n\nenum Msg {\n    Text(String),\n}\n\nstruct Comp;\n\nimpl Component for Comp {\n\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        // テキストを受け取り、それを `Msg::Text` メッセージバリアントとしてコンポーネントに送信するコールバックを作成します。\n        let cb = ctx.link().callback(|text: String| Msg::Text(text));\n\n        // 上の行は冗長であり、より明確にするために次のように簡略化できます：\n        let cb = ctx.link().callback(Msg::Text);\n\n        // `Msg::Text(\"Hello World!\")` をコンポーネントに送信します。\n        cb.emit(\"Hello World!\".to_owned());\n\n        html! {\n            // ここに HTML を配置\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized Typed Event Target Handling with NodeRef in Yew\nDESCRIPTION: This code snippet shows an optimized approach to handling typed event targets in Yew using NodeRef. It demonstrates how to avoid passing values through messages by utilizing the NodeRef stored in the component state.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/events.mdx#2025-04-16_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, web_sys::HtmlInputElement, Component, ComponentLink, Html, NodeRef};\n\npub struct Comp {\n    link: ComponentLink<Self>,\n    my_input: NodeRef,\n}\n\npub enum Msg {\n    // Signal the input element has changed\n    InputChanged,\n}\n\nimpl Component for Comp {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_: Self::Properties, link: ComponentLink<Self>) -> Self {\n        Self {\n            link,\n            my_input: NodeRef::default(),\n        }\n    }\n\n    fn change(&mut self, _props: Self::Properties) -> yew::ShouldRender {\n        false\n    }\n\n    fn update(&mut self, msg: Self::Message) -> bool {\n        match msg {\n            Msg::InputChanged => {\n                if let Some(input) = self.my_input.cast::<HtmlInputElement>() {\n                    let value = input.value_as_number();\n                    // do something with value\n\n                    true\n                } else {\n                    false\n                }\n            }\n        }\n    }\n\n    fn view(&self) -> Html {\n        let oninput = self.link.callback(|_| Msg::InputChanged);\n\n        html! {\n            <label for=\"my-input\">\n                { \"My input:\" }\n                <input ref={self.my_input.clone()}\n                    oninput={oninput}\n                    id=\"my-input\"\n                    type=\"text\"\n                />\n            </label>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Array for Classes in Yew\nDESCRIPTION: This snippet shows how to apply a list of classes from a Rust array to an HTML element in Yew using the `classes!` macro. It demonstrates the necessity of converting the array reference.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/classes.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nlet my_classes = [\"class-1\", \"class-2\"];\n\nhtml! {\n  <div class={classes!(my_classes.as_ref())}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a Modal Component with Portals in Rust\nDESCRIPTION: This code snippet demonstrates how to create a simple modal dialog component using Yew's create_portal function. It renders children to an element outside the Yew hierarchy, identified by id=\"modal_host\".\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/advanced-topics/portals.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(Properties, PartialEq)]\npub struct ModalProps {\n    #[prop_or_default]\n    pub children: Html,\n}\n\n#[function_component]\nfn Modal(props: &ModalProps) -> Html {\n    let modal_host = gloo::utils::document()\n        .get_element_by_id(\"modal_host\")\n        .expect(\"Expected to find a #modal_host element\");\n\n    create_portal(\n        props.children.clone(),\n        modal_host.into(),\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Emitting a Callback in Rust with Yew\nDESCRIPTION: Demonstrates how to create a callback function and emit a value. The callback takes a String input and returns a formatted String output.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/function-components/callbacks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html, Callback};\n\nlet cb: Callback<String, String> = Callback::from(move |name: String| {\n    format!(\"Bye {}\", name)\n});\n\nlet result = cb.emit(String::from(\"Bob\")); // call the callback\n// web_sys::console::log_1(&result.into()); // if uncommented will print \"Bye Bob\"\n```\n\n----------------------------------------\n\nTITLE: Creating Video Data in Yew Component\nDESCRIPTION: Initializes a vector of Video structs with sample data in the Yew component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/tutorial/index.mdx#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nlet videos = vec![\n    Video {\n        id: 1,\n        title: \"Building and breaking things\".to_string(),\n        speaker: \"John Doe\".to_string(),\n        url: \"https://youtu.be/PsaFVLr8t4E\".to_string(),\n    },\n    Video {\n        id: 2,\n        title: \"The development process\".to_string(),\n        speaker: \"Jane Smith\".to_string(),\n        url: \"https://youtu.be/PsaFVLr8t4E\".to_string(),\n    },\n    Video {\n        id: 3,\n        title: \"The Web 7.0\".to_string(),\n        speaker: \"Matt Miller\".to_string(),\n        url: \"https://youtu.be/PsaFVLr8t4E\".to_string(),\n    },\n    Video {\n        id: 4,\n        title: \"Mouseless development\".to_string(),\n        speaker: \"Tom Jerry\".to_string(),\n        url: \"https://youtu.be/PsaFVLr8t4E\".to_string(),\n    },\n];\n```\n\n----------------------------------------\n\nTITLE: Disabling Event Bubbling in Yew\nDESCRIPTION: Shows how to disable event bubbling in Yew applications. This should be called before starting the app and can improve performance but may break components that rely on event bubbling.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/events.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nyew::set_event_bubbling(false);\n```\n\n----------------------------------------\n\nTITLE: Using Optional Classes in Yew Components\nDESCRIPTION: Shows how to use Option types with the classes! macro to conditionally include classes in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/classes.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(Some(\"class\"))} />\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Custom DOM Nodes with web-sys in Yew\nDESCRIPTION: Demonstrates how to manually create DOM elements using web-sys and convert them to Yew's Html values using VRef. The example shows creating a div element with content that persists across renders using use_memo.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/html/elements.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{Element, Node};\nuse yew::prelude::*;\nuse gloo::utils::document;\n\n#[function_component]\nfn MyComponent() -> Html {\n    // 帶記憶能力的函數，只會執行一次\n    let node = use_memo(\n        (),\n        |_| {\n            // 從文件中建立一個 div 元素\n            let div: Element = document().create_element(\"div\").unwrap();\n            // 新增內容、類別等\n            div.set_inner_html(\"Hello, World!\");\n            // 將 Element 轉換為 Node\n            let node: Node = div.into();\n            // 將該 Node 作為 Html 值傳回\n            Html::VRef(node)\n        },\n    );\n\n    // use_memo 回傳的是 Rc 指針，所以我們需要解引用和克隆\n    (*node).clone()\n}\n```\n\n----------------------------------------\n\nTITLE: Vector-based Classes in Yew\nDESCRIPTION: Demonstrates using a vector of class names with the classes! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/classes.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(vec![\"class-1\", \"class-2\"])}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using classes! macro with multiple literal values in Yew\nDESCRIPTION: This snippet illustrates how to use the `classes!` macro with multiple literal strings to assign multiple CSS classes to a div element in Yew. This allows for combining several classes directly in the HTML template. It depends on the `yew` crate.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/classes.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(\"class-1\", \"class-2\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Adding Location Listener in Struct Components\nDESCRIPTION: Shows how to listen for route changes in struct components by adding a location listener to the component context. The listener handle must be stored in the component state to prevent it from being dropped.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/router.mdx#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nfn create(ctx: &Context<Self>) -> Self {\n    let listener = ctx.link()\n        .add_location_listener(ctx.link().callback(\n            // handle event\n        ))\n        .unwrap();\n    MyComponent {\n        _listener: listener\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Yew Component View Function Signature\nDESCRIPTION: This code snippet shows the function signature of the `view` function in a Yew component. The `view` function takes a reference to the component's state (`&self`) and returns an `Html` element, which represents the user interface of the component. The properties are owned values and cloning is needed when passing references to components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.21/advanced-topics/struct-components/properties.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn view(&self) -> Html\n```\n\n----------------------------------------\n\nTITLE: Implementing Struct Component Template for JetBrains IDEs in Rust\nDESCRIPTION: A template for creating Yew struct components in JetBrains IDEs. This template includes a struct, a message enum, and Component trait implementation with create and view methods.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/getting-started/editor-setup.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct $NAME$;\n\nenum $NAME$Msg {\n}\n\nimpl Component for $NAME$ {\n    type Message = $NAME$Msg;\n    type Properties = ();\n\n    fn create(ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            $HTML$\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Video Struct in Rust\nDESCRIPTION: Creates a Rust struct to represent video data for the application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/tutorial/index.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nstruct Video {\n    id: usize,\n    title: String,\n    speaker: String,\n    url: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Using JsCast to handle event targets in web-sys\nDESCRIPTION: This example shows how to use the JsCast trait to safely cast between JavaScript types in Rust. It demonstrates both checked casting with dyn_ref and unchecked casting with unchecked_into when handling DOM event targets.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/wasm-bindgen/wasm-bindgen.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// need to import the trait.\nuse wasm_bindgen::JsCast;\nuse web_sys::{Event, EventTarget, HtmlInputElement, HtmlSelectElement};\n\nfn handle_event(event: Event) {\n    let target: EventTarget = event\n        .target()\n        .expect(\"I'm sure this event has a target!\");\n\n    // maybe the target is a select element?\n    if let Some(select_element) = target.dyn_ref::<HtmlSelectElement>() {\n        // do something amazing here\n        return;\n    }\n\n    // if it wasn't a select element then I KNOW it's a input element!\n    let input_element: HtmlInputElement = target.unchecked_into();\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Trunk Server Settings\nDESCRIPTION: Trunk configuration file for specifying server address and port.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/tutorial/index.mdx#2025-04-16_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[serve]\naddress = \"127.0.0.1\"\nport = 8080\n```\n\n----------------------------------------\n\nTITLE: Updated 'changed' Method Signature in Rust\nDESCRIPTION: The 'changed' method for Components now includes an additional parameter for the old properties. This snippet shows the new method signature.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/migration-guides/yew/from-0_19_0-to-0_20_0.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn changed(&mut self, ctx: &Context<Self>, old_props: &Self::Properties) -> bool\n```\n\n----------------------------------------\n\nTITLE: Using Effect Hooks with Dependencies in Yew 0.21\nDESCRIPTION: Demonstrates the new signature for hooks with dependencies in Yew 0.21, where dependencies are now passed as the first argument before the closure instead of the second argument after it. This improves code readability and ergonomics in cases where the same value is needed for computing a dependency and in the closure.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/blog/2023-09-23-release-0-21.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse_effect_with_deps(deps, move |deps: Vec<i32>| {\n    // Do something with dependencies\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Simple HTML Elements with Yew\nDESCRIPTION: This snippet demonstrates how to use the `html!` macro to create a simple HTML element, specifically an image tag, within a Yew component. It illustrates the basic usage of Yew's HTML rendering capabilities.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/basic-web-technologies/html.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet my_header: Html = html! {\n    <img src=\"img_girl.jpg\" alt=\"Girl in a jacket\" width=\"500\" height=\"600\" />\n};\n```\n\n----------------------------------------\n\nTITLE: Configure Trunk Server Settings\nDESCRIPTION: Trunk configuration file for customizing server address and port\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\n[serve]\n# The address to serve on LAN.\naddress = \"127.0.0.1\"\n# The address to serve on WAN.\n# address = \"0.0.0.0\"\n# The port to serve on.\nport = 8000\n```\n\n----------------------------------------\n\nTITLE: Initializing wasm-logger for Rust Web Applications\nDESCRIPTION: Sets up wasm-logger to enable logging in Rust web applications. This snippet shows how to initialize the logger in the main function and demonstrates usage with the log macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.21/more/debugging.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// セットアップ\nfn main() {\n    wasm_logger::init(wasm_logger::Config::default());\n}\n\n// 使用方法\nlog::info!(\"Update: {:?}\", msg);\n```\n\n----------------------------------------\n\nTITLE: Video Data Initialization\nDESCRIPTION: Creating sample video data using the Video struct\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/tutorial/index.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet videos = vec![\n    Video {\n        id: 1,\n        title: \"Building and breaking things\".to_string(),\n        speaker: \"John Doe\".to_string(),\n        url: \"https://youtu.be/PsaFVLr8t4E\".to_string(),\n    },\n    Video {\n        id: 2,\n        title: \"The development process\".to_string(),\n        speaker: \"Jane Smith\".to_string(),\n        url: \"https://youtu.be/PsaFVLr8t4E\".to_string(),\n    },\n    Video {\n        id: 3,\n        title: \"The Web 7.0\".to_string(),\n        speaker: \"Matt Miller\".to_string(),\n        url: \"https://youtu.be/PsaFVLr8t4E\".to_string(),\n    },\n    Video {\n        id: 4,\n        title: \"Mouseless development\".to_string(),\n        speaker: \"Tom Jerry\".to_string(),\n        url: \"https://youtu.be/PsaFVLr8t4E\".to_string(),\n    },\n];\n```\n\n----------------------------------------\n\nTITLE: Manual Event Listener with Closures in Yew\nDESCRIPTION: This snippet demonstrates how to manually add an event listener using Closures for a custom event in Yew. It illustrates the use of wasm-bindgen to create a Closure that listens for the 'custard' event on a HTML element.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/events.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::{prelude::Closure, JsCast};\nuse web_sys::HtmlElement;\nuse yew::prelude::*;\n\n#[function_component]\nfn MyComponent() -> Html {\n    let div_node_ref = use_node_ref();\n\n    use_effect_with(\n        div_node_ref.clone(),\n        {\n            let div_node_ref = div_node_ref.clone();\n\n            move |_| {\n                let mut custard_listener = None;\n\n                if let Some(element) = div_node_ref.cast::<HtmlElement>() {\n                    // Create your Callback as you normally would\n                    let oncustard = Callback::from(move |_: Event| {\n                        // do something about custard..\n                    });\n\n                    // Create a Closure from a Box<dyn Fn> - this has to be 'static\n                    let listener =\n                        Closure::<dyn Fn(Event)>::wrap(\n                            Box::new(move |e: Event| oncustard.emit(e))\n                        );\n\n                    element\n                        .add_event_listener_with_callback(\n                            \"custard\",\n                            listener.as_ref().unchecked_ref()\n                        )\n                        .unwrap();\n\n                    custard_listener = Some(listener);\n                }\n\n                move || drop(custard_listener)\n            }\n        }\n    );\n\n    html! {\n        <div ref={div_node_ref} id=\"my-div\"></div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependencies for External API Integration\nDESCRIPTION: Adds required dependencies to Cargo.toml for implementing API calls, including gloo-net for fetching, serde for JSON serialization, and wasm-bindgen-futures for async operations.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/tutorial/index.mdx#2025-04-16_snippet_13\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ngloo-net = \"0.6\"\nserde = { version = \"1.0\", features = [\"derive\"] }\nwasm-bindgen-futures = \"0.4\"\n```\n\n----------------------------------------\n\nTITLE: Optional Attributes for HTML Elements in Yew (Rust)\nDESCRIPTION: Demonstrates how to use optional values for HTML attributes in Yew, allowing omission of the attribute if it's set to None.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/elements.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet maybe_id = Some(\"foobar\");\n\nhtml! {\n    <div id={maybe_id}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: HTML Output Example of Keyed List\nDESCRIPTION: Shows an example of HTML generation with key attributes for list items\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/lists.mdx#2025-04-16_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<div id=\"bob\">My name is Bob</div>\n<div id=\"sam\">My name is Sam</div>\n<div id=\"rob\">My name is rob</div>\n```\n\n----------------------------------------\n\nTITLE: Handling onchange event with Textarea in Yew\nDESCRIPTION: This example shows how to handle the `onchange` event for a `textarea` element in Yew. It uses `ChangeData::Value` to retrieve the string value of the textarea. The `batch_callback` function conditionally handles the `Value` variant, returning `None` if it's not a `Value` event.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/events.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Html, ChangeData};\n\nfn view(&self) -> Html {\n\n    let onchange = self.link.batch_callback(|e| {\n        if let ChangeData::Value(value) = e {\n            // do something with the String value\n        } else {\n            None\n        }\n    });\n\n    html! {\n        <div>\n            <textarea onchange={onchange} />\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Event Hook Logic - Rust\nDESCRIPTION: This snippet provides the implementation details of the 'use_event' hook. It defines a struct to hold event dependencies and uses 'use_effect_with' to create and manage event listeners effectively. The hook automatically updates and cleans up the listener as needed based on the dependencies.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse web_sys::{Event, EventTarget};\nuse std::borrow::Cow;\nuse std::rc::Rc;\nuse gloo::events::EventListener;\n\n#[hook]\npub fn use_event<E, F>(target: &EventTarget, event_type: E, callback: F)\nwhere\n    E: Into<Cow<'static, str>>, \n    F: Fn(Event) + 'static,\n{\n    #[derive(PartialEq, Clone)]\n    struct EventDependents {\n        target: EventTarget,\n        event_type: Cow<'static, str>,\n        callback: Callback<Event>,\n    }\n\n    let deps = EventDependents {\n        target: target.clone(),\n        event_type: event_type.into(),\n        callback: Callback::from(callback),\n    };\n\n    use_effect_with(\n        deps,\n        |deps| {\n            let EventDependents {\n                target,\n                event_type,\n                callback,\n            } = deps.clone();\n\n            let listener = EventListener::new(&target, event_type, move |e| {\n                callback.emit(e.clone());\n            });\n\n            move || {\n                drop(listener);\n            }\n        },\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the Change Method for Property Updates\nDESCRIPTION: Example of handling property changes from parent components by implementing the change lifecycle method.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/components/introduction.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Component, ShouldRender};\n\nimpl Component for MyComponent {\n    // ...\n\n    fn change(&mut self, props: Self::Properties) -> ShouldRender {\n        if self.props != props {\n            self.props = props;\n            true\n        } else {\n            false\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Array for Classes in Yew Components\nDESCRIPTION: Shows how to use an array of class names with the classes! macro in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/classes.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nlet my_classes = [\"class-1\", \"class-2\"];\n\nhtml! {\n  <div class={classes!(my_classes.as_ref())}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Yew Mousemove Event Implementation in Rust\nDESCRIPTION: This code implements the mousemove event using Yew's `Callback` and `html!` macro. It extracts the target element from the event, calculates the relative mouse coordinates, and logs them to the console. The `TargetCast` trait is used for easier type conversion.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{console, HtmlElement, MouseEvent};\nuse yew::{\n    html,\n    Callback, TargetCast,\n};\n\nlet onmousemove = Callback::from(|e: MouseEvent| {\n    if let Some(target) = e.target_dyn_into::<HtmlElement>() {\n        let rect = target.get_bounding_client_rect();\n        let x = (e.client_x() as f64) - rect.left();\n        let y = (e.client_y() as f64) - rect.top();\n        console::log_1(&format!(\"Left? : {} ; Top? : {}\", x, y).into());\n    }\n});\n\nhtml! {\n    <div id=\"mousemoveme\" {onmousemove}></div>\n};\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Prop Drilling in Yew Components\nDESCRIPTION: This snippet shows an example of prop drilling, where a theme prop is passed down through multiple components. It illustrates the problem that contexts aim to solve.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/contexts.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html, Properties, function_component};\n\n#[derive(Clone, PartialEq)]\npub struct Theme {\n    foreground: String,\n    background: String,\n}\n\n#[derive(PartialEq, Properties)]\npub struct NavbarProps {\n    theme: Theme,\n}\n\n#[function_component]\nfn Navbar(props: &NavbarProps) -> Html {\n    html! {\n        <div>\n            <Title theme={props.theme.clone()}>\n                { \"App title\" }\n            </Title>\n            <NavButton theme={props.theme.clone()}>\n                { \"Somewhere\" }\n            </NavButton>\n        </div>\n    }\n}\n\n#[derive(PartialEq, Properties)]\npub struct ThemeProps {\n    theme: Theme,\n    children: Html,\n}\n\n#[function_component]\nfn Title(_props: &ThemeProps) -> Html {\n    html! {\n        // impl\n    }\n}\n\n#[function_component]\nfn NavButton(_props: &ThemeProps) -> Html {\n    html! {\n        // impl\n    }\n}\n\n/// App root\n#[function_component]\nfn App() -> Html {\n    let theme = Theme {\n        foreground: \"yellow\".to_owned(),\n        background: \"pink\".to_owned(),\n    };\n\n    html! {\n        <Navbar {theme} />\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating App Component for Video Selection in Rust\nDESCRIPTION: Modifies the App component to handle video selection and display the VideoDetails component when a video is selected.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/tutorial/index.mdx#2025-04-16_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n#[function_component(App)]\nfn app() -> Html {\n    // ...\n    let selected_video = use_state(|| None);\n\n    let on_video_select = {\n        let selected_video = selected_video.clone();\n        Callback::from(move |video: Video| {\n            selected_video.set(Some(video))\n        })\n    };\n\n    let details = selected_video.as_ref().map(|video| html! {\n        <VideoDetails video={video.clone()} />\n    });\n\n    html! {\n        <>\n            <h1>{ \"RustConf Explorer\" }</h1>\n            <div>\n                <h3>{\"Videos to watch\"}</h3>\n                <VideosList videos={videos} on_click={on_video_select.clone()} />\n            </div>\n            { for details }\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Overwriting Children Props with HTML Macro\nDESCRIPTION: This code snippet shows how to use the `..props` syntax in the `html!` macro to pass a base expression for properties, including children.  It demonstrates that when a `children` field is passed in the base props expression and children are also specified within the `html!` macro, the children within the macro overwrite the ones in the base props.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/components.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    id: String,\n    children: Html,\n}\n\n#[function_component]\nfn Container(props: &Props) -> Html {\n    html! {\n        <div id={props.id.clone()}>\n            { props.children.clone() }\n        </div>\n    }\n}\n\nlet props = yew::props!(Props {\n    id: \"container-2\",\n    children: Html::default(),\n});\n\nhtml! {\n    <Container ..props>\n        // props.children will be overwritten with this\n        <span>{ \"I am a child, as you can see\" }</span>\n    </Container>\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using classes! Macro with Optional Class in Yew (Rust)\nDESCRIPTION: Demonstrates how to use an optional class with the classes! macro in Yew, which is useful for conditional class application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(Some(\"class\"))} />\n};\n```\n\n----------------------------------------\n\nTITLE: Using Conditional Logic for Attributes in Yew (Rust)\nDESCRIPTION: In this example, conditional logic is used to determine the visibility of a div based on a boolean expression, demonstrating how Yew handles logical attributes in the same manner as HTML.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/elements.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet no = 1 + 1 != 2;\n\nhtml! {\n    <div hidden={no}>\n        { \"This div is NOT hidden.\" }\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Array-based Classes in Yew\nDESCRIPTION: Shows how to use an array of class names with the classes! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/classes.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nlet my_classes = [\"class-1\", \"class-2\"];\n\nhtml! {\n  <div class={classes!(my_classes.as_ref())}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using classes! macro with a Vector in Yew (Rust)\nDESCRIPTION: Demonstrates how to use the classes! macro with a Vector of class strings in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/classes.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(vec![\"class-1\", \"class-2\"])}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Disabling Event Bubbling in Yew\nDESCRIPTION: Shows how to disable event bubbling in Yew applications by calling a specific function before starting the app.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/events.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nyew::set_event_bubbling(false);\n```\n\n----------------------------------------\n\nTITLE: Self-closing Tags in HTML using Yew - Rust\nDESCRIPTION: Shows the correct usage of self-closing tags in HTML with the Yew framework, which requires ending the tag with a slash to indicate closure.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/introduction.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\\n\\nhtml! {\\n  <input id=\\\"my_input\\\" />\\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing the Update Lifecycle Method in Rust for Yew Components\nDESCRIPTION: Example of implementing the update lifecycle method for a Yew component. This method handles messages sent to the component and determines if it needs to re-render.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Component, Context, html, Html};\n\npub enum Msg {\n    SetInputEnabled(bool)\n}\n\nstruct MyComponent {\n    input_enabled: bool,\n}\n\nimpl Component for MyComponent {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            input_enabled: false,\n        }\n    }\n\n    fn update(&mut self, _ctx: &Context<Self>, msg: Self::Message) -> bool {\n        match msg {\n            Msg::SetInputEnabled(enabled) => {\n                if self.input_enabled != enabled {\n                    self.input_enabled = enabled;\n                    true // Re-render\n                } else {\n                    false\n                }\n            }\n        }\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            // impl\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Inheritance in web-sys with Rust\nDESCRIPTION: This snippet shows how to traverse the inheritance chain of web-sys types using Rust's Deref trait. It demonstrates the relationships between various HTML element types and how to use them.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ops::Deref;\nuse web_sys::\n    Element,\n    EventTarget,\n    HtmlElement,\n    HtmlTextAreaElement,\n    Node,\n};\n\nfn inheritance_of_text_area(text_area: HtmlTextAreaElement) {\n    // HtmlTextAreaElement 是 HTML 中的 <textarea>。\n    let html_element: &HtmlElement = text_area.deref();\n\n    let element: &Element = html_element.deref();\n\n    let node: &Node = element.deref();\n\n    let event_target: &EventTarget = node.deref();\n\n    // 注意我们现在已经从 web-sys 类型转移到内置的 JavaScript 类型，\n    // 这些类型在 js-sys crate 中。\n    let object: &js_sys::Object = event_target.deref();\n\n    // 注意我们现在已经从 js-sys 类型转移到 wasm-bindgen crate 中的根 JsValue。\n    let js_value: &wasm_bindgen::JsValue = object.deref();\n\n    // 这样使用 deref 意味着我们必须手动遍历继承树。\n    // 但是，您可以在 HtmlTextAreaElement 类型上调用 JsValue 方法。\n    assert!(!text_area.is_string());\n\n    // 这个空函数只是为了证明我们可以将 HtmlTextAreaElement 作为 &EventTarget 传递。\n    fn this_function_only_takes_event_targets(targets: &EventTarget) {};\n\n    // 编译器将沿着 deref 链向下走，以匹配这里的类型。\n    this_function_only_takes_event_targets(&text_area);\n\n    // AsRef 实现允许您将 HtmlTextAreaElement 视为 &EventTarget。\n    let event_target: &EventTarget = text_area.as_ref();\n\n}\n```\n\n----------------------------------------\n\nTITLE: Using JsCast for DOM element conversion\nDESCRIPTION: This snippet shows an alternative approach to NodeRef::cast by using the JsCast trait directly to convert a Node to a specific element type through dynamic casting.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::JsCast;\nuse web_sys::HtmlInputElement;\nuse yew::NodeRef;\n\nfn with_jscast(node_ref: NodeRef) {\n    if let Some(input) = node_ref\n        .get()\n        .and_then(|node| node.dyn_into::<HtmlInputElement>().ok()) {\n        // do something with HtmlInputElement\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Mouse Movement Tracking in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to track mouse movement within an element and log the coordinates relative to the element's top-left corner.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\ndocument.getElementById('mousemoveme').onmousemove = (e) => {\n    // e = Mouse event.\n    var rect = e.target.getBoundingClientRect()\n    var x = e.clientX - rect.left //x position within the element.\n    var y = e.clientY - rect.top //y position within the element.\n    console.log('Left? : ' + x + ' ; Top? : ' + y + '.')\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Complex Nested HTML Layouts in Yew\nDESCRIPTION: Demonstrates how to create complex nested HTML layouts using Yew's html! macro, including various form elements and attributes.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.20/concepts/html/elements.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n    <div>\n        <div data-key=\"abc\"></div>\n        <div class=\"parent\">\n            <span class=\"child\" value=\"anything\"></span>\n            <label for=\"first-name\">{ \"First Name\" }</label>\n            <input type=\"text\" id=\"first-name\" value=\"placeholder\" />\n            <input type=\"checkbox\" checked=true />\n            <textarea value=\"write a story\" />\n            <select name=\"status\">\n                <option selected=true disabled=false value=\"\">{ \"Selected\" }</option>\n                <option selected=false disabled=true value=\"\">{ \"Unselected\" }</option>\n            </select>\n        </div>\n    </div>\n}\n```\n\n----------------------------------------\n\nTITLE: HTML Attribute Assignment in Yew\nDESCRIPTION: This code snippet shows how to assign an attribute to an HTML element using the `html!` macro in Yew. It demonstrates passing a variable `value` to the `attribute` of a `div` element.  It requires the `yew` crate to be included.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/introduction.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet value = \"something\";\nhtml! { <div attribute={value} /> };\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Error with Multiple Root Elements\nDESCRIPTION: This snippet exemplifies the error generated when attempting to return multiple root HTML elements from the `html!` macro. It serves as a warning about the important rule regarding single root nodes in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/basic-web-technologies/html.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\n// error: only one root HTML element allowed\nhtml! {\n\n    <div></div>\n    <p></p>\n\n};\n```\n\n----------------------------------------\n\nTITLE: Automated Refactoring Commands for Yew Hook Updates\nDESCRIPTION: A set of ast-grep commands to automatically refactor Yew hook usage patterns. These commands update the syntax for use_effect_with, use_callback, use_memo, and other hooks to match the new API where dependencies are the first argument.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/migration-guides/yew/from-0_20_0-to-next.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsg --pattern 'use_effect_with_deps($CALLBACK,$$$DEPENDENCIES)' --rewrite 'use_effect_with($$$DEPENDENCIES, $CALLBACK)' -l rs -i\nsg --pattern 'use_effect_with($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_effect_with($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n\nsg --pattern 'use_callback($CALLBACK,$$$DEPENDENCIES)' --rewrite 'use_callback($$$DEPENDENCIES, $CALLBACK)' -l rs -i\nsg --pattern 'use_callback($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_callback($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n\nsg --pattern 'use_memo($CALLBACK,$$$DEPENDENCIES)' --rewrite 'use_memo($$$DEPENDENCIES, $CALLBACK)' -l rs -i\nsg --pattern 'use_memo($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_memo($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n\nsg --pattern 'use_future_with_deps($CALLBACK,$$$DEPENDENCIES)' --rewrite 'use_effect_with($$$DEPENDENCIES, $CALLBACK)' -l rs -i\nsg --pattern 'use_future_with($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_effect_with($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n\nsg --pattern 'use_transitive_state!($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_transitive_state!($DEPENDENCIES,$$$CALLBACK)' -l rs -i\nsg --pattern 'use_transitive_state!($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_transitive_state!($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n\nsg --pattern 'use_prepared_state!($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_prepared_state!($DEPENDENCIES,$$$CALLBACK)' -l rs -i\nsg --pattern 'use_prepared_state!($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_prepared_state!($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n```\n\n----------------------------------------\n\nTITLE: Creating Yew Function Component Template for JetBrains IDEs\nDESCRIPTION: Template for generating a new Yew function component with properties in JetBrains IDEs using Live Templates\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/getting-started/editor-setup.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(PartialEq, Properties)]\npub struct $Name$Props {\n}\n\n#[function_component]\npub fn $Name$(props: &$Name$Props) -> Html {\n    html! {\n        <$tag$>$END$</$tag$>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Default Props Using prop_or_default in Yew\nDESCRIPTION: Example showing how to use the prop_or_default attribute to provide default values for properties.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/function-components/properties.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    #[prop_or_default]\n    pub is_loading: bool,\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n    if props.is_loading.clone() {\n        html! { \"Loading\" }\n    } else {\n        html! { \"Hello world\" }\n    }\n}\n\n#[function_component]\nfn Case1() -> Html {\n    html! {<HelloWorld />}\n}\n\n#[function_component]\nfn Case2() -> Html {\n    html! {<HelloWorld is_loading={true} />}\n}\n```\n\n----------------------------------------\n\nTITLE: Yew Component Accepting Classes\nDESCRIPTION: This snippet demonstrates how to define a Yew component that accepts a `Classes` property and uses it to apply CSS classes to a div element.  It shows how to combine static class names, conditional class names, and the provided `Classes` property.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/html/classes.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    #[prop_or_default]\n    class: Classes,\n    fill: bool,\n    children: Html,\n}\n\n#[function_component]\nfn MyComponent(props: &Props) -> Html {\n    let Props {\n        class,\n        fill,\n        children,\n    } = props;\n    html! {\n        <div\n            class={classes!(\n                \"my-container-class\",\n                fill.then(|| Some(\"my-fill-class\")),\n                class.clone(),\n            )}\n        >\n            { children.clone() }\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Mouse Position Tracking with Yew and web-sys\nDESCRIPTION: Implementation of mouse position tracking using Yew's Callback and html! macro. Demonstrates how to integrate web-sys calls within a Yew component by creating a mousemove event handler that calculates and logs relative cursor coordinates.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/wasm-bindgen/web-sys.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{console, HtmlElement, MouseEvent};\nuse yew:{\n    html,\n    Callback,\n};\n\nlet onmousemove = Callback::from(|e: MouseEvent| {\n    let rect = e\n        .target()\n        .expect(\"mouse event doesn't have a target\")\n        .dyn_into::<HtmlElement>()\n        .expect(\"event target should be of type HtmlElement\")\n        .get_bounding_client_rect();\n    let x = (e.client_x() as f64) - rect.left();\n    let y = (e.client_y() as f64) - rect.top();\n    console::log_1(&format!(\"Left? : {} ; Top? : {}\", x, y).into());\n});\n\nhtml! {\n    <div id=\"mousemoveme\" onmousemove={onmousemove}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Deriving Properties in Rust for Yew Components\nDESCRIPTION: Basic example of deriving the Properties trait for a struct to be used as component props in Yew. The struct must also implement PartialEq for Yew's data comparison capabilities.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/function-components/properties.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::Properties;\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub is_loading: bool,\n}\n```\n\n----------------------------------------\n\nTITLE: Event Target Casting with JsCast - Cautious Approach\nDESCRIPTION: Demonstrates safe event target conversion using JsCast's dyn_into method, with runtime type checking for event target extraction\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/events.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::JsCast;\nuse web_sys::{EventTarget, HtmlInputElement};\n\nlet on_cautious_change = Callback::from(move |e: Event| {\n    let target: Option<EventTarget> = e.target();\n    let input = target.and_then(|t| t.dyn_into::<HtmlInputElement>().ok());\n\n    if let Some(input) = input {\n        input_value_handle.set(input.value());\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Classes with classes! Macro in Yew\nDESCRIPTION: Shows how to apply multiple CSS classes to an HTML element using the classes! macro by passing multiple string literals.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/classes.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(\"class-1\", \"class-2\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: VS Code Snippets Configuration for Yew Components\nDESCRIPTION: JSON configuration for VS Code snippets to create Yew function and struct components with prefixes 'yewfc' and 'yewsc'.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/getting-started/editor-setup.mdx#2025-04-16_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"New Yew function component\": {\n        \"prefix\": \"yewfc\",\n        \"body\": [\n            \"#[derive(PartialEq, Properties)]\",\n            \"pub struct ${1:ComponentName}Props {}\",\n            \"\",\n            \"#[function_component]\",\n            \"pub fn $1(props: &${1}Props) -> Html {\",\n            \"    let ${1}Props {} = props;\",\n            \"    html! {\",\n            \"        <${2:div}>$0</${2}>\",\n            \"    }\",\n            \"}\"\n        ],\n        \"description\": \"Create a minimal Yew function component\"\n    },\n    \"New Yew struct component\": {\n        \"prefix\": \"yewsc\",\n        \"body\": [\n            \"pub struct ${1:ComponentName};\",\n            \"\",\n            \"pub enum ${1}Msg {\",\n            \"}\",\n            \"\",\n            \"impl Component for ${1} {\",\n            \"    type Message = ${1}Msg;\",\n            \"    type Properties = ();\",\n            \"\",\n            \"    fn create(ctx: &Context<Self>) -> Self {\",\n            \"        Self\",\n            \"    }\",\n            \"\",\n            \"    fn view(&self, ctx: &Context<Self>) -> Html {\",\n            \"        html! {\",\n            \"            $0\",\n            \"        }\",\n            \"    }\",\n            \"}\"\n        ],\n        \"description\": \"Create a new Yew component with a message enum\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering List with Iterator - collect::<Html>() - Rust\nDESCRIPTION: This snippet demonstrates rendering a list of items using the `collect::<Html>()` method on an iterator. The iterator is transformed into a `Vec<_>` and then iterated over to produce HTML elements which are collected into a single `Html` node.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/html/lists.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```rust\nuse yew::prelude::*;\n\nlet items = (1..=10).collect::<Vec<_>>();\n\nhtml! {\n    <ul class=\"item-list\">\n        { items.iter().collect::<Html>() }\n    </ul>\n};\n```\n```\n\n----------------------------------------\n\nTITLE: web-sys Mousemove Event Implementation in Rust\nDESCRIPTION: This snippet demonstrates how to implement the mousemove event handler using `web-sys` in Rust. It retrieves the target element, calculates the relative mouse coordinates, and logs them to the console.  The closure must be kept alive to prevent it from being garbage collected.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::{prelude::Closure, JsCast};\nuse web_sys::{console, Document, HtmlElement, MouseEvent};\n\nlet mousemove = Closure::<dyn Fn(MouseEvent)>::wrap(Box::new(|e| {\n    let rect = e\n        .target()\n        .expect(\"mouse event doesn't have a target\")\n        .dyn_into::<HtmlElement>()\n        .expect(\"event target should be of type HtmlElement\")\n        .get_bounding_client_rect();\n    let x = (e.client_x() as f64) - rect.left();\n    let y = (e.client_y() as f64) - rect.top();\n    console::log_1(&format!(\"Left? : {} ; Top? : {}\", x, y).into());\n}));\n\nDocument::new()\n    .expect(\"global document not set\")\n    .get_element_by_id(\"mousemoveme\")\n    .expect(\"element with id `mousemoveme` not present\")\n    .unchecked_into::<HtmlElement>()\n    .set_onmousemove(mousemove.as_ref().dyn_ref());\n\n// 我們現在需要保存 `mousemove` 閉包，以便在事件觸發時閉包仍然在記憶體中。\n\n```\n\n----------------------------------------\n\nTITLE: Basic HTML Tag Structure in Yew\nDESCRIPTION: Demonstrates proper open-close tag structure using the html! macro\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n  <div id=\"my_div\"></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Updating Video Struct for Deserialization in Rust\nDESCRIPTION: Modifies the Video struct to derive the Deserialize trait, enabling JSON deserialization for API responses.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/tutorial/index.mdx#2025-04-16_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nuse serde::Deserialize;\n\n#[derive(Clone, PartialEq, Deserialize)]\nstruct Video {\n    id: usize,\n    title: String,\n    speaker: String,\n    url: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Import Paths for yew-agents 0.1.0\nDESCRIPTION: The migration from yew-agents 0.0.0 to 0.1.0 requires changing the import statements from the yew namespace to the new yew_agents namespace.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/migration-guides/yew-agent/from-0_0_0-to-0_1_0.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Change from:\nyew::*\n\n// To:\nyew_agents::*\n```\n\n----------------------------------------\n\nTITLE: Using Literal Class with classes! Macro in Yew\nDESCRIPTION: Demonstrates how to use a literal string with the classes! macro to set the class attribute on a div element in Yew HTML templates.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/classes.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n    <div class={classes!(\"container\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using Boolean Attributes in Yew (Rust)\nDESCRIPTION: This snippet demonstrates how to properly use boolean attributes in Yew by setting them to true or false.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/elements.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <div hidden=true>\n        { \"This div is hidden.\" }\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using Optional HTML Attributes in Yew (Rust)\nDESCRIPTION: This example demonstrates how to use optional values for HTML attributes in Yew, allowing for clean attribute handling within components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/elements.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet maybe_id = Some(\"foobar\");\n\nhtml! {\n    <div id={maybe_id}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using NodeRef cast for DOM element access\nDESCRIPTION: This snippet demonstrates how to use Yew's NodeRef::cast method to convert a generic Node reference to a specific HTML element type like HtmlInputElement.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::NodeRef;\n\nfn with_node_ref_cast(node_ref: NodeRef) {\n    if let Some(input) = node_ref.cast::<HtmlInputElement>() {\n        // do something with HtmlInputElement\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating HTML Entry Point for Yew Application\nDESCRIPTION: Sets up a minimal HTML file that Yew will use as the entry point for the web application. The body tag is intentionally empty as Yew will mount the application there.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_6\n\nLANGUAGE: html\nCODE:\n```\n<!doctype html>\n<html>\n    <head>\n        <meta charset=\"utf-8\" />\n        <title>Yew App</title>\n    </head>\n    <body></body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Using #[autoprops] Macro in Yew\nDESCRIPTION: Demonstrates the use of the #[autoprops] macro from yew-autoprops to automatically generate the Properties struct for a function component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/function-components/properties.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew_autoprops::autoprops;\n\n// the #[autoprops] macro must appear BEFORE #[function_component], the order matters\n#[autoprops]\n#[function_component]\nfn Greetings(\n    #[prop_or_default]\n    is_loading: bool,\n    #[prop_or(AttrValue::Static(\"Hello\"))]\n    message: &AttrValue,\n    #[prop_or(AttrValue::Static(\"World\"))]\n    name: &AttrValue,\n) -> Html {\n    if is_loading {\n        html! { \"Loading\" }\n    } else {\n        html! { <>{{message}}{{\" \"}}{{name}}</> }\n    }\n}\n\n// The properties struct \"GreetingsProps\" will be generated automatically.\n//\n// `is_loading` will be passed as value to the components while `message` and\n// `name` will use references because of the leading `&` in the definition.\n```\n\n----------------------------------------\n\nTITLE: Function Component Without Props in Yew\nDESCRIPTION: Example of implementing a function component that doesn't require props in Yew. The component is then used in a parent component without providing any properties.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/function-components/properties.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html};\n\n#[function_component]\nfn HelloWorld() -> Html {\n    html! { \"Hello world\" }\n}\n\n// 沒有屬性需要提供\n#[function_component]\nfn App() -> Html {\n    html! { <HelloWorld /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Mouse Movement Tracking using Yew\nDESCRIPTION: This Rust snippet demonstrates how to implement mouse movement tracking using Yew, a modern web framework. It shows how to create a Callback for the onmousemove event and use it in Yew's html! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{console, HtmlElement, MouseEvent};\nuse yew::\n    html,\n    Callback, TargetCast,\n};\n\nlet onmousemove = Callback::from(|e: MouseEvent| {\n    if let Some(target) = e.target_dyn_into::<HtmlElement>() {\n        let rect = target.get_bounding_client_rect();\n        let x = (e.client_x() as f64) - rect.left();\n        let y = (e.client_y() as f64) - rect.top();\n        console::log_1(&format!(\"Left? : {} ; Top? : {}\", x, y).into());\n    }\n});\n\nhtml! {\n    <div id=\"mousemoveme\" {onmousemove}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Shorthand Prop Initialization in Yew 0.19.0\nDESCRIPTION: A new shorthand syntax for initializing props in Yew 0.19.0 when the variable name matches the prop name.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/migration-guides/yew/from-0_18_0-to-0_19_0.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet age = 1;\nhtml!{\n    <JapaneseYew\n        {age}\n    >\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Import Paths for Yew Agents in Rust\nDESCRIPTION: This snippet demonstrates the change in import paths required when migrating from Yew 0.0.0 to 0.1.0. Users need to update their import statements to use the new yew_agents crate instead of the yew crate for agent-related functionality.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/migration-guides/yew-agent/from-0_0_0-to-0_1_0.mdx#2025-04-16_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nyew::* // Old import path\nyew_agents::* // New import path\n```\n\n----------------------------------------\n\nTITLE: Using Html for Children in Yew\nDESCRIPTION: This code snippet demonstrates the basic usage of allowing a component to have children of any type using `Html`. It defines a `List` component that accepts children as an `Html` prop and renders them within a `div` element.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/children.mdx#2025-04-16_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse yew::{html, Component, Context, Html, Properties};\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: Html,\n}\n\npub struct List;\n\nimpl Component for List {\n    type Message = ();\n    type Properties = ListProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"list\">\n                {ctx.props().children.clone()}\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Fragments in Yew HTML Macro\nDESCRIPTION: Demonstrates the correct way to wrap multiple HTML elements using fragments in Yew. Fragments allow multiple elements to be grouped without adding an extra DOM node.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/fragments.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n    <>\n        <div></div>\n        <p></p>\n    </>\n};\n```\n\n----------------------------------------\n\nTITLE: Importing console.log with wasm-bindgen macro in Rust\nDESCRIPTION: Demonstrates using the #[wasm_bindgen] macro to import JavaScript's console.log function with multiple signatures into Rust code.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/basic-web-technologies/wasm-bindgen.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\nextern \"C\" {\n    #[wasm_bindgen(js_namespace = console)]\n    fn log(s: &str);\n\n    #[wasm_bindgen(js_namespace = console, js_name = log)]\n    fn log_u32(a: u32);\n\n    #[wasm_bindgen(js_namespace = console, js_name = log)]\n    fn log_many(a: &str, b: &str);\n}\n\nlog(\"Hello from Rust!\");\nlog_u32(42);\nlog_many(\"Logging\", \"many values!\");\n```\n\n----------------------------------------\n\nTITLE: Adding gloo-events Dependency to Cargo.toml\nDESCRIPTION: Adding the gloo-events crate as a dependency for a more concise event listener implementation in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/events.mdx#2025-04-16_snippet_12\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ngloo-events = \"0.1\"\n```\n\n----------------------------------------\n\nTITLE: Using Optional Classes in Yew\nDESCRIPTION: This code snippet demonstrates how to conditionally apply a class to an HTML element in Yew using the `Option` type within the `classes!` macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/classes.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(Some(\"class\"))} />\n};\n```\n\n----------------------------------------\n\nTITLE: Self-closing Tag Structure in Yew\nDESCRIPTION: Shows how to use self-closing tags with the `html!` macro for elements like input that don't require closing tags.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/introduction.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n  <input id=\"my_input\" />\n};\n```\n\n----------------------------------------\n\nTITLE: Creating an Infinite Loop with Yew Lifecycle Methods\nDESCRIPTION: An example demonstrating how Yew component lifecycle methods can create an infinite rendering loop when a component requests an update in its rendered method and always returns true in the update method.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Context, Component, Html};\n\nstruct Comp;\n\nimpl Component for Comp {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn update(&mut self, _ctx: &Context<Self>, _msg: Self::Message) -> bool {\n        // We are going to always request to re-render on any msg\n        true\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        // For this example it doesn't matter what is rendered\n        Html::default()\n    }\n\n    fn rendered(&mut self, ctx: &Context<Self>, _first_render: bool) {\n        // Request that the component is updated with this new msg\n        ctx.link().send_message(());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Class Names in Yew\nDESCRIPTION: Shows how to add multiple literal class names to a div element using the classes! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(\"class-1\", \"class-2\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using classes! macro with Literal in Yew\nDESCRIPTION: Demonstrates using the classes! macro with a literal string value to apply a CSS class to a div element.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(\"container\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Basic Class Usage with Literal in Yew\nDESCRIPTION: Demonstrates using the classes! macro with a single literal class string in a Yew component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/classes.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n    <div class={classes!(\"container\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Comparing State Management Options in Yew\nDESCRIPTION: A markdown table that compares different state management hooks and types in Yew. It outlines the hook name, associated type, rerender conditions, and scope for each option.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/function-components/state.mdx#2025-04-16_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Hook                     | Type                       | Rerender when?               | Scope               |\n| ------------------------ | -------------------------- | ---------------------------- | ------------------- |\n| [use_state]              | `T`                        | got set                      | component instance  |\n| [use_state_eq]           | `T: PartialEq`             | got set with diff. value     | component instance  |\n| [use_reducer]            | `T: Reducible`             | got reduced                  | component instance  |\n| [use_reducer_eq]         | `T: Reducible + PartialEq` | got reduced with diff. value | component instance  |\n| [use_memo]               | `Deps -> T`                | dependencies changed         | component instance  |\n| [use_callback]           | `Deps -> Callback<E>`      | dependencies changed         | component instance  |\n| [use_mut_ref]            | `T`                        | -                            | component instance  |\n| a static global variable | `T`                        | -                            | global, used by all |\n```\n\n----------------------------------------\n\nTITLE: Basic HTML Generation with html! Macro\nDESCRIPTION: Shows how to create a basic HTML element (img tag) using Yew's html! macro. The macro converts the HTML-like syntax into Rust code that generates the corresponding DOM elements.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/basic-web-technologies/html.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet my_header: Html = html! {\n    <img src=\"img_girl.jpg\" alt=\"Girl in a jacket\" width=\"500\" height=\"600\" />\n};\n```\n\n----------------------------------------\n\nTITLE: If-Let-Else Pattern Matching in Yew\nDESCRIPTION: Shows how to handle both the Some and None cases when pattern matching with if-let-else in Yew templates\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/conditional-rendering.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nlet some_text = Some(\"text\");\n\nhtml! {\n    if let Some(text) = some_text {\n        <p>{ text }</p>\n    } else {\n        <p>{ \"False case\" }</p>\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: NodeRef Casting with Yew and Web-Sys\nDESCRIPTION: Two methods for casting NodeRef to specific HTML element types using Yew's NodeRef::cast and JsCast::dyn_into\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/wasm-bindgen/web-sys.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::NodeRef;\n\nfn with_node_ref_cast(node_ref: NodeRef) {\n    if let Some(input) = node_ref.cast::<HtmlInputElement>() {\n        // do something with HtmlInputElement\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::JsCast;\nuse web_sys::HtmlInputElement;\nuse yew::NodeRef;\n\nfn with_jscast(node_ref: NodeRef) {\n    if let Some(input) = node_ref\n        .get()\n        .and_then(|node| node.dyn_into::<HtmlInputElement>().ok()) {\n        // do something with HtmlInputElement\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Text Literals in Yew HTML\nDESCRIPTION: Demonstrates how to render different types of text literals and numeric values in Yew's HTML template syntax. Shows usage of text variables, string literals, and numeric literals wrapped in curly braces.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet text = \"lorem ipsum\";\nhtml!{\n    <>\n        <div>{text}</div>\n        <div>{\"dolor sit\"}</div>\n        <span>{42}</span>\n    </>\n};\n```\n\n----------------------------------------\n\nTITLE: Updating Yew Component with Dynamic Video List\nDESCRIPTION: Replaces hardcoded video list with dynamically generated HTML in the Yew component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/tutorial/index.mdx#2025-04-16_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n    <>\n        <h1>{ \"RustConf Explorer\" }</h1>\n        <div>\n            <h3>{ \"Videos to watch\" }</h3>\n            { videos }\n        </div>\n        // ...\n    </>\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Properties in Yew HTML\nDESCRIPTION: Demonstrates how to set properties on elements using the '~' syntax in Yew's html! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/introduction.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! { <my-element ~property=\"abc\" /> };\n```\n\n----------------------------------------\n\nTITLE: Using classes! Macro with Slice in Yew (Rust)\nDESCRIPTION: Demonstrates how to use a slice of class names with the classes! macro in Yew, providing another way to handle multiple classes.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!([\"class-1\", \"class-2\"].as_ref())}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Dynamic Tag Names in Yew\nDESCRIPTION: Shows how to use dynamic tag names in Yew components using @{name} syntax, useful for building higher-order components with variable element types.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/elements.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet level = 5;\nlet text = \"Hello World!\".to_owned();\n\nhtml! {\n    <@{format!(\"h{}\", level)} class=\"title\">{ text }</@>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Listener in Yew Component\nDESCRIPTION: This snippet shows a Yew function component that listens for storage events on the window object. It uses the use_effect hook to set up and clean up the event listener.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse gloo::events::EventListener;\nuse gloo::utils::window;\nuse std::mem::drop;\n\n\n#[function_component(ShowStorageChanged)]\npub fn show_storage_changed() -> Html {\n    let state_storage_changed = use_state(|| false);\n\n    {\n        let state_storage_changed = state_storage_changed.clone();\n        use_effect(|| {\n            let listener = EventListener::new(&window(), \"storage\", move |_| state_storage_changed.set(true));\n\n            move || { drop(listener); }\n        });\n    }\n\n    html! { <div>{\"Storage Event Fired: \"}{*state_storage_changed}</div> }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Portal Modal Component in Rust with Yew\nDESCRIPTION: Demonstrates how to create a modal component using Yew's create_portal function to render children to an external DOM element with a specific ID\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/advanced-topics/portals.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(Properties, PartialEq)]\npub struct ModalProps {\n    #[prop_or_default]\n    pub children: Html,\n}\n\n#[function_component]\nfn Modal(props: &ModalProps) -> Html {\n    let modal_host = gloo::utils::document()\n        .get_element_by_id(\"modal_host\")\n        .expect(\"Expected to find a #modal_host element\");\n\n    create_portal(\n        props.children.clone(),\n        modal_host.into(),\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: NodeRef Usage with Cast Method\nDESCRIPTION: Demonstrates how to use NodeRef's cast method to convert a Node reference to a specific HTML element type.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::NodeRef;\n\nfn with_node_ref_cast(node_ref: NodeRef) {\n    if let Some(input) = node_ref.cast::<HtmlInputElement>() {\n        // do something with HtmlInputElement\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Dynamic Tag Names in Yew Components\nDESCRIPTION: Shows how to dynamically set HTML tag names in Yew components using the @{name} syntax, which accepts any expression that returns a string.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/elements.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nlet level = 5;\nlet text = \"Hello World!\".to_owned()\n\nhtml! {\n    <@{format!(\"h{}\", level)} class=\"title\">{ text }</@>\n}\n```\n\n----------------------------------------\n\nTITLE: Complex HTML Layout Example in Yew\nDESCRIPTION: This code snippet demonstrates a complex HTML layout created using the `html!` macro within a Yew component. It shows nested `div` elements with various attributes, including `data-key`, `class`, `for`, `type`, `checked`, and `value`. It also includes an example of using text nodes within the macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/introduction.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <div>\n        <div data-key=\"abc\"></div>\n        <div class=\"parent\">\n            <span class=\"child\" value=\"anything\"></span>\n            <label for=\"first-name\">{ \"First Name\" }</label>\n            <input type=\"text\" id=\"first-name\" value=\"placeholder\" />\n            <input type=\"checkbox\" checked=true />\n            <textarea value=\"write a story\" />\n            <select name=\"status\">\n                <option selected=true disabled=false value=\"\">{ \"Selected\" }</option>\n                <option selected=false disabled=true value=\"\">{ \"Unselected\" }</option>\n            </select>\n        </div>\n    </div>\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using Inline Styles in Yew\nDESCRIPTION: Demonstrates how to apply inline CSS styles directly as a string attribute in Yew HTML components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div style=\"color: red;\"></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Automatically Generating Properties with yew-autoprops\nDESCRIPTION: Shows how to use the #[autoprops] macro from yew-autoprops to automatically generate a Properties struct from function parameters, streamlining the development process.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/function-components/properties.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew_autoprops::autoprops;\n\n// the #[autoprops] macro must appear BEFORE #[function_component], the order matters\n#[autoprops]\n#[function_component]\nfn Greetings(\n    #[prop_or_default]\n    is_loading: bool,\n    #[prop_or(AttrValue::Static(\"Hello\"))]\n    message: &AttrValue,\n    #[prop_or(AttrValue::Static(\"World\"))]\n    name: &AttrValue,\n) -> Html {\n    if is_loading {\n        html! { \"Loading\" }\n    } else {\n        html! { <>{message}{\" \"}{name}</> }\n    }\n}\n\n// The properties struct \"GreetingsProps\" will be generated automatically.\n//\n// `is_loading` will be passed as value to the components while `message` and\n// `name` will use references because of the leading `&` in the definition.\n```\n\n----------------------------------------\n\nTITLE: SVG Layouts with Yew - Rust\nDESCRIPTION: Illustrates the creation of SVG elements using Yew, highlighting the handling of attributes like width, height, and paths. Mentions the necessity of using uppercase letters for some SVG tags.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/introduction.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\\n\\nhtml! {\\n    <svg width=\\\"149\\\" height=\\\"147\\\" viewBox=\\\"0 0 149 147\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n        <path d=\\\"M60.5776 13.8268L51.8673 42.6431L77.7475 37.331L60.5776 13.8268Z\\\" fill=\\\"#DEB819\\\"/>\\n        <path d=\\\"M108.361 94.9937L138.708 90.686L115.342 69.8642\\\" stroke=\\\"black\\\" stroke-width=\\\"4\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\"/>\\n        <g>\\n            <circle cx=\\\"75.3326\\\" cy=\\\"73.4918\\\" r=\\\"55\\\" fill=\\\"#FDD630\\\"/>\\n            <circle cx=\\\"75.3326\\\" cy=\\\"73.4918\\\" r=\\\"52.5\\\" stroke=\\\"black\\\" stroke-width=\\\"5\\\"/>\\n        </g>\\n        <circle cx=\\\"71\\\" cy=\\\"99\\\" r=\\\"5\\\" fill=\\\"white\\\" fill-opacity=\\\"0.75\\\" stroke=\\\"black\\\" stroke-width=\\\"3\\\"/>\\n    </svg>\\n};\n```\n\n----------------------------------------\n\nTITLE: Using classes! macro with Array in Yew\nDESCRIPTION: This snippet demonstrates how to use the `classes!` macro with an array to apply multiple CSS classes to a div element in Yew. This offers a compact way to manage a fixed set of classes. Requires the `yew` crate.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/classes.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!([\"class-1\", \"class-2\"])}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing WebAssembly Binary Size using wasm-opt\nDESCRIPTION: This command demonstrates how to use the wasm-opt tool to optimize the size of a WebAssembly binary. It applies size optimizations to the input file and outputs an optimized version.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/optimizations.mdx#2025-04-16_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nwasm-opt wasm_bg.wasm -Os -o wasm_bg_opt.wasm\n```\n\n----------------------------------------\n\nTITLE: Creating New Cargo Project\nDESCRIPTION: Initializes a new Rust project using Cargo, the Rust package manager.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncargo new yew-app\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Classes in Yew Components\nDESCRIPTION: Shows how to use the classes! macro to add multiple class names to an HTML element in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/classes.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(\"class-1\", \"class-2\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Attribute and Property Usage in Yew\nDESCRIPTION: Examples of setting attributes and properties on elements using the html! macro\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/introduction.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet value = \"something\";\nhtml! { <div attribute={value} /> };\n```\n\n----------------------------------------\n\nTITLE: Using classes! macro with Multiple Classes in Yew\nDESCRIPTION: Shows how to apply multiple CSS classes to an element by passing multiple string literals to the classes! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(\"class-1\", \"class-2\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo Dependencies\nDESCRIPTION: Adding Yew dependency to Cargo.toml configuration file\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/tutorial/index.mdx#2025-04-16_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"yew-app\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nyew = \"0.19\"\n```\n\n----------------------------------------\n\nTITLE: Using Literal Classes in Yew\nDESCRIPTION: This snippet demonstrates how to apply a static class string to an HTML element in Yew using the `classes!` macro. It requires the Yew framework for Rust.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/classes.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n    <div class={classes!(\"container\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Testing layout using yew::tests::layout_tests\nDESCRIPTION: This snippet demonstrates how to use the `yew::tests::layout_tests` module for snapshot testing in Yew applications. This module facilitates the comparison of component rendered output against stored snapshots, ensuring that components render as expected after changes.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/more/testing.mdx#2025-04-16_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nyew::tests::layout_tests\n```\n\n----------------------------------------\n\nTITLE: Using classes! Macro with Optional Class in Yew (Rust)\nDESCRIPTION: Demonstrates using the classes! macro with an optional class (Some) to conditionally set a class on a div element in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/html/classes.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(Some(\"class\"))} />\n};\n```\n\n----------------------------------------\n\nTITLE: 在 Yew 中使用条件表达式生成 HTML (Rust)\nDESCRIPTION: 这个代码片段演示了如何在 Yew 中使用条件表达式来动态生成 HTML。它使用一个布尔变量来决定是否显示一个链接。\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet show_link = true;\n\nhtml! {\n  <div>\n    {\n      if show_link {\n        html! {\n          <a href=\"https://example.com\">{\"Link\"}</a>\n        }\n      } else {\n        html! {}\n      }\n    }\n  </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using JsCast for DOM Element Type Conversion in Yew\nDESCRIPTION: Demonstrates how to use wasm_bindgen's JsCast trait to convert a generic DOM Node obtained from NodeRef.get() into a specific HTML element type. This approach is more verbose but provides the same functionality as NodeRef.cast.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/wasm-bindgen/web-sys.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::JsCast;\nuse web_sys::HtmlInputElement;\nuse yew::NodeRef;\n\nfn with_jscast(node_ref: NodeRef) {\n    if let Some(input) = node_ref\n        .get()\n        .and_then(|node| node.dyn_into::<HtmlInputElement>().ok()) {\n        // do something with HtmlInputElement\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Self-closing Tags with html! Macro in Rust\nDESCRIPTION: Demonstrates the proper syntax for using self-closing tags with the html! macro in Yew. This shows how to create an input element with an id attribute.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/introduction.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nhtml! {\n  <input id=\"my_input\" />\n};\n```\n\n----------------------------------------\n\nTITLE: Rendering List with collect::<Html>()\nDESCRIPTION: First method of rendering a list by converting an iterator to HTML using collect method in Yew\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/lists.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet items = (1..=10).collect::<Vec<_>>();\n\nhtml! {\n    <ul class=\"item-list\">\n        { items.iter().collect::<Html>() }\n    </ul>\n};\n```\n\n----------------------------------------\n\nTITLE: Using Docusaurus ThemedImage Component in JavaScript\nDESCRIPTION: This code snippet showcases the usage of the ThemedImage component from @docusaurus/theme to display different images based on the application's current theme. It leverages the useBaseUrl from @docusaurus to obtain the correct paths for the images.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/agents.mdx#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n<ThemedImage\n    alt=\\\"agent lifecycle diagram\\\"\n    sources={{\n        light: useBaseUrl('/img/agent-lifecycle-light.svg'),\n        dark: useBaseUrl('/img/agent-lifecycle-dark.svg'),\n    }}\n/>\n```\n\n----------------------------------------\n\nTITLE: Using classes! macro with Vector in Yew\nDESCRIPTION: Demonstrates using a vector of string literals with the classes! macro to apply multiple classes.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(vec![\"class-1\", \"class-2\"])}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Hook Structure in Yew\nDESCRIPTION: This snippet defines the structure of a custom hook called use_event. It takes an event target, event type, and callback as parameters. The #[hook] attribute is used to mark it as a hook function.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{Event, EventTarget};\nuse std::borrow::Cow;\nuse gloo::events::EventListener;\nuse yew::prelude::*;\n\n#[hook]\npub fn use_event<E, F>(target: &EventTarget, event_type: E, callback: F)\nwhere\n    E: Into<Cow<'static, str>>,\n    F: Fn(&Event) + 'static,\n{\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Generic Rust Function Component in Yew\nDESCRIPTION: Defines a generic function component that can work with different types, using trait bounds to ensure type compatibility and conversion to HTML\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/function-components/generics.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt::Display;\nuse yew::{function_component, html, Properties, Html};\n\n#[derive(Properties, PartialEq)]\npub struct Props<T>\nwhere\n    T: PartialEq,\n{\n    data: T,\n}\n\n#[function_component]\npub fn MyGenericComponent<T>(props: &Props<T>) -> Html\nwhere\n    T: PartialEq + Clone + Into<Html>,\n{\n    html! {\n        <p>\n            { props.data.clone().into() }\n        </p>\n    }\n}\n\n// 之後可以這樣使用\nhtml! {\n    <MyGenericComponent<i32> data=123 />\n};\n\n// 或者\nhtml! {\n    <MyGenericComponent<String> data={\"foo\".to_string()} />\n};\n```\n\n----------------------------------------\n\nTITLE: Mouse position tracking with web-sys in Rust\nDESCRIPTION: This example converts the JavaScript mouse position tracking code to Rust using web-sys. It requires configuring specific web-sys features and uses wasm-bindgen's Closure type to handle events.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nwasm-bindgen = \"0.2\"\n\n[dependencies.web-sys]\nversion = \"0.3\"\n# We need to enable all the web-sys features we want to use!\nfeatures = [\n    \"console\",\n    \"Document\",\n    \"HtmlElement\",\n    \"MouseEvent\",\n    \"DomRect\",\n]\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::{prelude::Closure, JsCast};\nuse web_sys::{console, Document, HtmlElement, MouseEvent};\n\nlet mousemove = Closure::<dyn Fn(MouseEvent)>::wrap(Box::new(|e| {\n    let rect = e\n        .target()\n        .expect(\"mouse event doesn't have a target\")\n        .dyn_into::<HtmlElement>()\n        .expect(\"event target should be of type HtmlElement\")\n        .get_bounding_client_rect();\n    let x = (e.client_x() as f64) - rect.left();\n    let y = (e.client_y() as f64) - rect.top();\n    console::log_1(&format!(\"Left? : {} ; Top? : {}\", x, y).into());\n}));\n\nDocument::new()\n    .expect(\"global document not set\")\n    .get_element_by_id(\"mousemoveme\")\n    .expect(\"element with id `mousemoveme` not present\")\n    .unchecked_into::<HtmlElement>()\n    .set_onmousemove(mousemove.as_ref().dyn_ref());\n\n// we now need to save the `mousemove` Closure so that when\n// this event fires the closure is still in memory.\n```\n\n----------------------------------------\n\nTITLE: Using String-like Attributes in Yew (Rust)\nDESCRIPTION: This snippet illustrates how to pass various types of string-like values (str, String, AttrValue) to input placeholders in Yew components, emphasizing the best practices for maintaining consistency.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/elements.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, virtual_dom::AttrValue};\n\nlet str_placeholder = \"I'm a str!\";\nlet string_placeholder = String::from(\"I'm a String!\");\nlet attrvalue_placeholder = AttrValue::from(\"I'm an AttrValue!\");\n\nhtml! {\n    <div>\n        <input placeholder={str_placeholder} />\n        <input placeholder={string_placeholder} />\n        <input placeholder={attrvalue_placeholder} />\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: HTML Macro: Setting Properties in Yew\nDESCRIPTION: This snippet demonstrates how to set properties on custom elements using the `html!` macro in Yew. Properties are specified with a tilde `~` before the property name. The `use yew::prelude::*;` statement imports necessary Yew functionalities.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/html/introduction.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! { <my-element ~property=\"abc\" /> };\n\n```\n\n----------------------------------------\n\nTITLE: Updating Yew Component State\nDESCRIPTION: This code snippet showcases the `update` lifecycle method, responsible for handling messages and updating the component's state. It defines a `Msg` enum and updates the component's `input_enabled` field based on the received message. The return value of `update` indicates whether the component should be re-rendered.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nuse yew::{Component, Context, html, Html};\n\n// highlight-start\npub enum Msg {\n    SetInputEnabled(bool)\n}\n// highlight-end\n\nstruct MyComponent {\n    input_enabled: bool,\n}\n\nimpl Component for MyComponent {\n    // highlight-next-line\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            input_enabled: false,\n        }\n    }\n\n    // highlight-start\n    fn update(&mut self, _ctx: &Context<Self>, msg: Self::Message) -> bool {\n        match msg {\n            Msg::SetInputEnabled(enabled) => {\n                if self.input_enabled != enabled {\n                    self.input_enabled = enabled;\n                    true // 重新渲染\n                } else {\n                    false\n                }\n            }\n        }\n    }\n    // highlight-end\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            // 具体实现\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Video struct instances\nDESCRIPTION: This snippet creates instances of the `Video` struct and stores them in a `Vec`. This `Vec` will be used to dynamically generate the video list in the Yew application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n\"use website_test::tutorial::Video; // 换成你自己的路径\n\nlet videos = vec![\n    Video {\n        id: 1,\n        title: \\\"Building and breaking things\\\".to_string(),\n        speaker: \\\"John Doe\\\".to_string(),\n        url: \\\"https://youtu.be/PsaFVLr8t4E\\\".to_string(),\n    },\n    Video {\n        id: 2,\n        title: \\\"The development process\\\".to_string(),\n        speaker: \\\"Jane Smith\\\".to_string(),\n        url: \\\"https://youtu.be/PsaFVLr8t4E\\\".to_string(),\n    },\n    Video {\n        id: 3,\n        title: \\\"The Web 7.0\\\".to_string(),\n        speaker: \\\"Matt Miller\\\".to_string(),\n        url: \\\"https://youtu.be/PsaFVLr8t4E\\\".to_string(),\n    },\n    Video {\n        id: 4,\n        title: \\\"Mouseless development\\\".to_string(),\n        speaker: \\\"Tom Jerry\\\".to_string(),\n        url: \\\"https://youtu.be/PsaFVLr8t4E\\\".to_string(),\n    },\n];\"\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with Cargo\nDESCRIPTION: Commands for installing trunk and adding WASM build target using Cargo and rustup\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/tutorial/index.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo install trunk\n```\n\nLANGUAGE: bash\nCODE:\n```\nrustup target add wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Single-Threaded Server-Side Rendering with LocalServerRenderer\nDESCRIPTION: This snippet demonstrates how to use LocalServerRenderer for single-threaded server-side rendering in Yew. It's designed for WASI environments and shows how to render a component and wrap it in a complete HTML body.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/server-side-rendering.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew::LocalServerRenderer;\n\n#[function_component]\nfn App() -> Html {\n    use yew_router::prelude::*;\n\n    html! {\n        <>\n            <h1>{\"Yew WASI SSR demo\"}</h1>\n        </>\n    }\n}\n\npub async fn render() -> String {\n    let renderer = LocalServerRenderer::<App>::new();\n    let html_raw = renderer.render().await;\n\n    let mut body = String::new();\n    body.push_str(\"<body>\");\n    body.push_str(\"<div id='app'>\");\n    body.push_str(&html_raw);\n    body.push_str(\"</div>\");\n    body.push_str(\"</body>\");\n\n    body\n}\n\n#[tokio::main(flavor = \"current_thread\")]\nasync fn main() {\n    println!(\"{}\", render().await);\n}\n```\n\n----------------------------------------\n\nTITLE: Inline styles in Yew components\nDESCRIPTION: Demonstrates how to apply inline CSS styles directly to an element using the style attribute in Yew HTML templates.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div style=\"color: red;\"></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Base URL for Relative Paths in Yew\nDESCRIPTION: HTML tag to be added to index.html for configuring the base URL when building for relative paths. Trunk rewrites this tag with the value passed to --public-url.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/more/deployment.mdx#2025-04-16_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<base data-trunk-public-url />\n```\n\n----------------------------------------\n\nTITLE: Nested Component with Callback Handling\nDESCRIPTION: Demonstrates improved nested component ergonomics and callback handling in Yew components\nSOURCE: https://github.com/yewstack/yew/blob/master/CHANGELOG.md#2025-04-16_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nfn view(&self) -> Html {\n    html! {\n        <Wrapper>\n            // This is now valid. (before #780, this would cause a lifetime\n            // compile error because children nodes were moved into a closure)\n            <Nested on_click=&self.nested_on_click />\n        </Wrapper>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Parent-to-Child Re-renders in Yew\nDESCRIPTION: This snippet illustrates the process for handling changes in properties from a parent component and the consequent re-rendering of a child component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// Example code showing handling of props changes is not provided directly\n```\n\n----------------------------------------\n\nTITLE: Using #[prop_or_default] Attribute in Yew Properties with Rust\nDESCRIPTION: Demonstrates the use of the #[prop_or_default] attribute to initialize a prop with the default value of its type when not set by the parent component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/function-components/properties.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    #[prop_or_default]\n    pub is_loading: bool,\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n    if props.is_loading.clone() {\n        html! { \"Loading\" }\n    } else {\n        html! { \"Hello world\" }\n    }\n}\n\n// Then use like this with default\n#[function_component]\nfn Case1() -> Html {\n    html! {<HelloWorld />}\n}\n// Or no override the default\n#[function_component]\nfn Case2() -> Html {\n    html! {<HelloWorld is_loading={true} />}\n}\n```\n\n----------------------------------------\n\nTITLE: Using wasm-logger for logging\nDESCRIPTION: This code snippet shows how to use the `log` crate in conjunction with `wasm-logger` to log messages from a Yew application. The `log::info!` macro is used to log an informational message containing the `msg` variable's value.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.20/more/debugging.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// usage\nlog::info!(\"Update: {:?}\", msg);\n\n```\n\n----------------------------------------\n\nTITLE: Using classes! macro with a String object in Yew\nDESCRIPTION: Demonstrates how to apply CSS classes using a String object that contains space-separated class names with the classes! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(String::from(\"class-1 class-2\"))}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running a Yew Application - Rust\nDESCRIPTION: This snippet compiles and runs the Yew application, checking the Rust environment setup.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncargo run\n```\n\n----------------------------------------\n\nTITLE: Using classes! macro with a literal string in Yew\nDESCRIPTION: Demonstrates how to apply a single CSS class to a div element using the classes! macro with a literal string value.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(\"container\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Advanced Logging with tracing-web in Rust\nDESCRIPTION: Demonstrates setup of advanced console logging using tracing-web and tracing-subscriber, including configuration of formatting, timing, and performance tracking layers.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/more/debugging.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing_subscriber::{\n    fmt::{\n        format::{FmtSpan, Pretty},\n        time::UtcTime,\n    },\n    prelude::*,\n};\nuse wasm_bindgen::JsValue;\n\nfn main() {\n    let fmt_layer = tracing_subscriber::fmt::layer()\n        .with_ansi(false)\n        .with_timer(UtcTime::rfc_3339())\n        .with_writer(tracing_web::MakeConsoleWriter)\n        .with_span_events(FmtSpan::ACTIVE);\n    let perf_layer = tracing_web::performance_layer().with_details_from_fields(Pretty::default());\n\n    tracing_subscriber::registry()\n        .with(fmt_layer)\n        .with(perf_layer)\n        .init();\n    let object = JsValue::from(\"world\");\n    tracing::info!(\"Hello {}\", object.as_string().unwrap());\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Message Batch in Yew ComponentLink\nDESCRIPTION: The 'send_message_batch' method registers a callback that sends a batch of messages when executed. It takes a closure of type Fn(IN) -> COMP::Message and returns a Callback<IN>.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.20/advanced-topics/struct-components/callbacks.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nsend_message_batch\n```\n\n----------------------------------------\n\nTITLE: Using String-like Attributes in Yew Components\nDESCRIPTION: Shows different ways to pass string-like values as HTML attributes in Yew. Demonstrates using str, String, and AttrValue types, with a recommendation to prefer AttrValue for better performance.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/html/elements.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, virtual_dom::AttrValue};\n\nlet str_placeholder = \"I'm a str!\";\nlet string_placeholder = String::from(\"I'm a String!\");\nlet attrvalue_placeholder = AttrValue::from(\"I'm an AttrValue!\");\n\nhtml! {\n    <div>\n        <input placeholder={str_placeholder} />\n        <input placeholder={string_placeholder} />\n        <input placeholder={attrvalue_placeholder} />\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using NodeRef::cast in Yew\nDESCRIPTION: This snippet demonstrates how to use NodeRef::cast in Yew to convert a Node reference to a specific HTML element type (HtmlInputElement in this case).\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::NodeRef;\n\nfn with_node_ref_cast(node_ref: NodeRef) {\n    if let Some(input) = node_ref.cast::<HtmlInputElement>() {\n        // do something with HtmlInputElement\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Boolean Attributes in Yew Components\nDESCRIPTION: Explains how to correctly implement boolean attributes (like hidden, checked, required) in Yew components by setting them to boolean values.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/elements.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nhtml! {\n    <div hidden=true>\n        { \"This div is hidden.\" }\n    </div>\n}\n```\n\nLANGUAGE: html\nCODE:\n```\n<div hidden>This div is hidden.</div>\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nlet no = 1 + 1 != 2;\n\nhtml! {\n    <div hidden=no>\n        { \"This div is NOT hidden.\" }\n    </div>\n}\n```\n\nLANGUAGE: html\nCODE:\n```\n<div>This div is NOT hidden.</div>\n```\n\n----------------------------------------\n\nTITLE: Collecting Iterators to HTML - Syntax 2\nDESCRIPTION: Shows alternative Yew-specific syntax for rendering iterators using the 'for' keyword\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/lists.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html};\n\nlet items = (1..=10).collect::<Vec<_>>();\n\nhtml! {\n    <ul class=\"item-list\">\n        { for items.iter() }\n    </ul>\n};\n```\n\n----------------------------------------\n\nTITLE: Adding yew-router Dependency in Cargo.toml\nDESCRIPTION: This snippet shows how to add the yew-router dependency to your Cargo.toml file for use in a Yew project.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/router.mdx#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\nyew-router = \"0.17\"\n```\n\n----------------------------------------\n\nTITLE: Accessing Environment Variables at Compile Time in Rust\nDESCRIPTION: Rust macro used to obtain the value of an environment variable at compile time. This is useful for customizing behavior in Yew applications since runtime access to environment variables is not possible in the browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/more/deployment.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nstd::env!\n```\n\n----------------------------------------\n\nTITLE: Event Handling with Callbacks – Rust\nDESCRIPTION: This snippet shows how to handle keydown events in Yew after the migration. The use of Callback and event prevention is demonstrated.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/migration-guides/yew/from-0_18_0-to-0_19_0.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet onkeydown = Callback::from(|e| {\n    e.prevent_default();\n    todo!(\"use `e`, just like in service methods.\");\n});\nhtml! {\n    <input {onkeydown} />\n}\n\n```\n\n----------------------------------------\n\nTITLE: Adding Interactivity to VideosList Component in Rust\nDESCRIPTION: Updates the VideosList component to handle click events and emit the selected video to its parent component using a callback.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/tutorial/index.mdx#2025-04-16_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Properties, PartialEq)]\nstruct VideosListProps {\n    videos: Vec<Video>,\n    on_click: Callback<Video>\n}\n\n#[function_component(VideosList)]\nfn videos_list(VideosListProps { videos, on_click }: &VideosListProps) -> Html {\n    let on_click = on_click.clone();\n    videos.iter().map(|video| {\n        let on_video_select = {\n            let on_click = on_click.clone();\n            let video = video.clone();\n            Callback::from(move |_| {\n                on_click.emit(video.clone())\n            })\n        };\n\n        html! {\n            <p key={video.id} onclick={on_video_select}>{format!(\"{}: {}\", video.speaker, video.title)}</p>\n        }\n    }).collect()\n}\n```\n\n----------------------------------------\n\nTITLE: Mouse Movement Implementation with web-sys\nDESCRIPTION: Rust implementation of mouse movement tracking using web-sys bindings.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::{prelude::Closure, JsCast};\nuse web_sys::{console, Document, HtmlElement, MouseEvent};\n\nlet mousemove = Closure::<dyn Fn(MouseEvent)>::wrap(Box::new(|e| {\n    let rect = e\n        .target()\n        .expect(\"mouse event doesn't have a target\")\n        .dyn_into::<HtmlElement>()\n        .expect(\"event target should be of type HtmlElement\")\n        .get_bounding_client_rect();\n    let x = (e.client_x() as f64) - rect.left();\n    let y = (e.client_y() as f64) - rect.top();\n    console::log_1(&format!(\"Left? : {} ; Top? : {}\", x, y).into());\n}));\n\nDocument::new()\n    .expect(\"global document not set\")\n    .get_element_by_id(\"mousemoveme\")\n    .expect(\"element with id `mousemoveme` not present\")\n    .unchecked_into::<HtmlElement>()\n    .set_onmousemove(mousemove.as_ref().dyn_ref());\n```\n\n----------------------------------------\n\nTITLE: Using Closures for Dynamic HTML in Yew\nDESCRIPTION: This example demonstrates using a closure to encapsulate the logic for conditionally rendering an HTML link in Yew. The closure, `maybe_display_link`, returns `Html` based on the `show_link` variable, improving code readability. It showcases the flexibility of embedding Rust expressions within Yew's HTML macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.20/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet show_link = true;\nlet maybe_display_link = move || -> Html {\n  if show_link {\n    html! {\n      <a href=\"https://example.com\">{\"Link\"}</a>\n    }\n  } else {\n    html! {}\n  }\n};\n\nhtml! {\n     <div>{maybe_display_link()}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: HTML Self-Closing Tag Example in Yew\nDESCRIPTION: This code snippet shows how to use self-closing tags in the `html!` macro within a Yew component.  It demonstrates a simple `input` element with an `id` attribute that is self-closing. It requires the `yew` crate to be included.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/introduction.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n  <input id=\"my_input\" />\n};\n\n```\n\n----------------------------------------\n\nTITLE: Creating an HTML Template for Yew Application - HTML\nDESCRIPTION: This snippet creates an HTML skeleton for the Yew application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_6\n\nLANGUAGE: html\nCODE:\n```\n<!doctype html>\n<html lang=\"en\">\n    <head></head>\n    <body></body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Adding WASM Target\nDESCRIPTION: This command adds the WebAssembly (WASM) target to the Rust toolchain. Yew compiles to WASM, which allows it to run in web browsers.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n\"rustup target add wasm32-unknown-unknown\"\n```\n\n----------------------------------------\n\nTITLE: Creating a Component with Lifecycle Methods - Rust\nDESCRIPTION: Demonstrates how to create a basic Yew component that implements the Component trait, focusing on the create lifecycle method and props handling.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/components/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Component, Context, html, Html, Properties};\n\n#[derive(PartialEq, Properties)]\npub struct Props;\n\npub struct MyComponent;\n\nimpl Component for MyComponent {\n    type Message = ();\n    type Properties = Props;\n\n    // highlight-start\n    fn create(ctx: &Context<Self>) -> Self {\n        MyComponent\n    }\n    // highlight-end\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            // impl\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Dependencies in Cargo.toml\nDESCRIPTION: Specifies the dependency on gloo-events for event handling in a Rust project. This is necessary to utilize the EventListener functionality in the Yew framework.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/events.mdx#2025-04-16_snippet_7\n\nLANGUAGE: TOML\nCODE:\n```\n[dependencies]\ngloo-events = \"0.1\"\n```\n\n----------------------------------------\n\nTITLE: Defining Properties for Yew Components in Rust\nDESCRIPTION: This snippet demonstrates how to define properties for a Yew component using the #[derive(Properties)] macro. It includes examples of various field attributes for default values and shows how to implement PartialEq for the properties.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/advanced-topics/struct-components/properties.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::Properties;\n/// Importing the AttrValue from virtual_dom\nuse yew::virtual_dom::AttrValue;\n\n#[derive(Clone, PartialEq)]\npub enum LinkColor {\n    Blue,\n    Red,\n    Green,\n    Black,\n    Purple,\n}\n\nfn create_default_link_color() -> LinkColor {\n    LinkColor::Blue\n}\n\n#[derive(Properties, PartialEq)]\npub struct LinkProps {\n    /// The link must have a target.\n    href: AttrValue,\n    /// Also notice that we're using AttrValue instead of String\n    text: AttrValue,\n    /// Color of the link. Defaults to `Blue`.\n    #[prop_or_else(create_default_link_color)]\n    color: LinkColor,\n    /// The view function will not specify a size if this is None.\n    #[prop_or_default]\n    size: Option<u32>,\n    /// When the view function doesn't specify active, it defaults to true.\n    #[prop_or(true)]\n    active: bool,\n}\n```\n\n----------------------------------------\n\nTITLE: Using #[prop_or_else(function)] Attribute in Yew Properties with Rust\nDESCRIPTION: Demonstrates the use of #[prop_or_else(function)] attribute to set a default value for a prop using a function when not explicitly provided by the parent component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/function-components/properties.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties};\n\nfn create_default_name() -> String {\n    \"Bob\".to_string()\n}\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    #[prop_or_else(create_default_name)]\n    pub name: String,\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n    html! {<>{\"Hello world\"}{props.name.clone()}</>}\n}\n\n// Then use like this with default\n#[function_component]\nfn Case1() -> Html {\n    html! {<HelloWorld />}\n}\n// Or no override the default\n#[function_component]\nfn Case2() -> Html {\n    html! {<HelloWorld name={\"Sam\".to_string()} />}\n}\n```\n\n----------------------------------------\n\nTITLE: Logging to Browser Console with wasm-logger in Rust\nDESCRIPTION: This snippet demonstrates how to use the wasm-logger crate to log messages to the browser console in a Yew application. It integrates with the log crate to provide log levels, source lines, and file names.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/more/debugging.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse log::info;\nuse wasm_bindgen::JsValue;\n\nfn main() {\n    wasm_logger::init(wasm_logger::Config::default());\n\n    let object = JsValue::from(\"world\");\n    info!(\"Hello {}\", object.as_string().unwrap());\n}\n```\n\n----------------------------------------\n\nTITLE: Boolean Attributes in Yew\nDESCRIPTION: Demonstrates the usage of boolean attributes in Yew components, showing both true and false cases and their HTML output.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/elements.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <div hidden=true>\n        { \"This div is hidden.\" }\n    </div>\n};\n```\n\nLANGUAGE: html\nCODE:\n```\n<div hidden>This div is hidden.</div>\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet no = 1 + 1 != 2;\n\nhtml! {\n    <div hidden={no}>\n        { \"This div is NOT hidden.\" }\n    </div>\n};\n```\n\nLANGUAGE: html\nCODE:\n```\n<div>This div is NOT hidden.</div>\n```\n\n----------------------------------------\n\nTITLE: Installing Cargo Web Command\nDESCRIPTION: This snippet shows how to install the 'cargo-web' subcommand which is essential for building web applications using Cargo. It runs using the cargo installer command.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/project-setup/using-cargo-web.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo install cargo-web\n```\n\n----------------------------------------\n\nTITLE: Open and Close Tags in HTML using Yew - Rust\nDESCRIPTION: Illustrates the use of open and close tags in HTML with the Yew framework. Ensures correct closure of HTML tags to avoid compilation errors due to missing close tags.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\\n\\nhtml! {\\n  <div id=\\\"my_div\\\"></div>\\n};\n```\n\n----------------------------------------\n\nTITLE: Cargo Dependencies for web-sys Mouse Event Example\nDESCRIPTION: Cargo.toml configuration showing the required dependencies and web-sys features needed for mouse event handling with the DomRect and console features enabled.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nwasm-bindgen = \"0.2\"\n\n[dependencies.web-sys]\nversion = \"0.3\"\n# We need to enable all the web-sys features we want to use!\nfeatures = [\n    \"console\",\n    \"Document\",\n    \"HtmlElement\",\n    \"MouseEvent\",\n    \"DomRect\",\n]\n```\n\n----------------------------------------\n\nTITLE: Using Fragments in Yew's html! Macro (Rust)\nDESCRIPTION: This snippet demonstrates the correct use of fragments in Yew's html! macro. It shows how to use an empty tag (<></>) to group multiple elements when the macro requires a single root node.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/fragments.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <>\n        <div></div>\n        <p></p>\n    </>\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Neovim's LSPConfig for Yew HTML Support in JSON\nDESCRIPTION: Configuration for Neovim's LSP to support HTML syntax in Rust files when using Yew. This can be added to a LazyVim configuration to improve the editing experience for Yew's html! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/getting-started/editor-setup.mdx#2025-04-16_snippet_3\n\nLANGUAGE: json\nCODE:\n```\nreturn {\n  {\n    \"neovim/nvim-lspconfig\",\n    init_options = {\n      userLanguages = {\n        eelixir = \"html-eex\",\n        eruby = \"erb\",\n        rust = \"html\",\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Inheritance in web-sys using Rust\nDESCRIPTION: This snippet shows how to traverse the inheritance chain of a HtmlTextAreaElement using Deref and AsRef traits. It demonstrates the relationship between web-sys types and core JavaScript types.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ops::Deref;\nuse web_sys::\n    Element,\n    EventTarget,\n    HtmlElement,\n    HtmlTextAreaElement,\n    Node,\n};\n\nfn inheritance_of_text_area(text_area: HtmlTextAreaElement) {\n    // HtmlTextAreaElement is <textarea> in html.\n    let html_element: &HtmlElement = text_area.deref();\n\n    let element: &Element = html_element.deref();\n\n    let node: &Node = element.deref();\n\n    let event_target: &EventTarget = node.deref();\n\n    // Notice we have moved from web-sys types now into built-in\n    // JavaScript types which are in the js-sys crate.\n    let object: &js_sys::Object = event_target.deref();\n\n    // Notice we have moved from js-sys type to the root JsValue from\n    // the wasm-bindgen crate.\n    let js_value: &wasm_bindgen::JsValue = object.deref();\n\n    // Using deref like this means we have to manually traverse\n    // the inheritance tree, however, you can call JsValue methods\n    // on the HtmlTextAreaElement type.\n    // The `is_string` method comes from JsValue.\n    assert!(!text_area.is_string());\n\n    // empty function just to prove we can pass HtmlTextAreaElement as a\n    // &EventTarget.\n    fn this_function_only_takes_event_targets(targets: &EventTarget) {};\n\n    // The compiler will walk down the deref chain in order to match the types here.\n    this_function_only_takes_event_targets(&text_area);\n\n    // The AsRef implementations allow you to treat the HtmlTextAreaElement\n    // as an &EventTarget.\n\n    let event_target: &EventTarget = text_area.as_ref();\n\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying CSS Classes in Yew Components\nDESCRIPTION: Demonstrates various ways to specify CSS classes for elements in Yew, including constant strings, multiple attributes, interpolation, expressions, tuples, and vectors.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.20/concepts/html/elements.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n  <div class=\"container\"></div>\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n  <div class=\"container center-align\"></div>\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n  <div class={format!(\"{}-container\", size)}></div>\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n  <div class={self.classes()}></div>\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n  <div class={(\"class-1\", \"class-2\")}></div>\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n  <div class={vec![\"class-1\", \"class-2\"]}></div>\n}\n```\n\n----------------------------------------\n\nTITLE: Keyed List Example with Names\nDESCRIPTION: Demonstrates adding unique keys to list items in Yew for performance optimization and accurate rendering\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/lists.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nlet names = vec![\"Sam\",\"Bob\",\"Ray\"]\n\nhtml! {\n    <div id=\"introductions\">\n        {\n            names.into_iter().map(|name| {\n                html!{<div key={name}>{ format!(\"Hello, I'am {}!\",name) }</div>}\n            }).collect::<Html>()\n        }\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Enum Typed Children in Yew\nDESCRIPTION: Advanced implementation showing how to restrict children to specific component types using an enum. Uses derive_more crate for better ergonomics.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/advanced-topics/children.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{\n    html, html::ChildrenRenderer, virtual_dom::VChild, Component,\n    Context, Html, Properties,\n};\n\npub struct Primary;\n\nimpl Component for Primary {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"Primary\" }\n        }\n    }\n}\n\npub struct Secondary;\n\nimpl Component for Secondary {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"Secondary\" }\n        }\n    }\n}\n\n#[derive(Clone, derive_more::From, PartialEq)]\npub enum Item {\n    Primary(VChild<Primary>),\n    Secondary(VChild<Secondary>),\n}\n\n#[allow(clippy::from_over_into)]\nimpl Into<Html> for Item {\n    fn into(self) -> Html {\n        match self {\n            Self::Primary(child) => child.into(),\n            Self::Secondary(child) => child.into(),\n        }\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: ChildrenRenderer<Item>,\n}\n\npub struct List;\n\nimpl Component for List {\n    type Message = ();\n    type Properties = ListProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"list\">\n                { for ctx.props().children.iter() }\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Web-sys Dependencies Configuration\nDESCRIPTION: Cargo.toml configuration for web-sys features required for mouse movement example.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nwasm-bindgen = \"0.2\"\n\n[dependencies.web-sys]\nversion = \"0.3\"\n# We need to enable all the web-sys features we want to use!\nfeatures = [\n    \"console\",\n    \"Document\",\n    \"HtmlElement\",\n    \"MouseEvent\",\n    \"DomRect\",\n]\n```\n\n----------------------------------------\n\nTITLE: Enum Typed Children in Yew\nDESCRIPTION: This example demonstrates restricting children to a few different component types using an enum. It defines `Primary` and `Secondary` components, an `Item` enum that can be either, and a `List` component that accepts `Item` children.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/children.mdx#2025-04-16_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nuse yew::{\n    html, html::ChildrenRenderer, virtual_dom::VChild, Component,\n    Context, Html, Properties,\n};\n\npub struct Primary;\n\nimpl Component for Primary {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"Primary\" }\n        }\n    }\n}\n\npub struct Secondary;\n\nimpl Component for Secondary {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"Secondary\" }\n        }\n    }\n}\n\n#[derive(Clone, derive_more::From, PartialEq)]\npub enum Item {\n    Primary(VChild<Primary>),\n    Secondary(VChild<Secondary>),\n}\n\n// Now, we implement `Into<Html>` so that yew knows how to render `Item`.\n#[allow(clippy::from_over_into)]\nimpl Into<Html> for Item {\n    fn into(self) -> Html {\n        match self {\n            Self::Primary(child) => child.into(),\n            Self::Secondary(child) => child.into(),\n        }\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: ChildrenRenderer<Item>,\n}\n\npub struct List;\n\nimpl Component for List {\n    type Message = ();\n    type Properties = ListProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"list\">\n                { for ctx.props().children.iter() }\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Event Target Casting with TargetCast in Yew\nDESCRIPTION: Demonstrates how to use TargetCast trait to safely cast event targets to specific HTML element types. Shows both cautious (safe) and dangerous (unchecked) approaches to handling input element events.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/events.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::{events::Event, html, Component, Context, Html, TargetCast};\n\npub struct Comp;\n\npub enum Msg {\n    InputValue(String),\n}\n\nimpl Component for Comp {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let link = ctx.link();\n\n        let on_cautious_change = link.batch_callback(|e: Event| {\n            let input = e.target_dyn_into::<HtmlInputElement>();\n\n            input.map(|input| Msg::InputValue(input.value()))\n        });\n\n        let on_dangerous_change = link.callback(|e: Event| {\n            Msg::InputValue(e.target_unchecked_into::<HtmlInputElement>().value())\n        });\n\n        html! {\n            <>\n                <label for=\"cautious-input\">\n                    { \"My cautious input:\" }\n                    <input onchange={on_cautious_change}\n                        id=\"cautious-input\"\n                        type=\"text\"\n                    />\n                </label>\n                <label for=\"dangerous-input\">\n                    { \"My dangerous input:\" }\n                    <input onchange={on_dangerous_change}\n                        id=\"dangerous-input\"\n                        type=\"text\"\n                    />\n                </label>\n            </>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering with if-else in Yew\nDESCRIPTION: Shows how to implement conditional rendering with both true and false cases using an if-else statement in Yew's html! macro. This allows different content to be rendered based on a condition.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/conditional-rendering.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nlet some_condition = true;\n\nhtml! {\n    if some_condition {\n        <p>{ \"True case\" }</p>\n    } else {\n        <p>{ \"False case\" }</p>\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Adding a Callback to VideosListProps in Yew\nDESCRIPTION: This code modifies the `VideosListProps` struct to include a callback function `on_click`. This callback is used to notify the parent component when a video is selected. Requires the `yew` crate.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Properties, PartialEq)]\nstruct VideosListProps {\n    videos: Vec<Video>,\n    on_click: Callback<Video>\n}\n```\n\n----------------------------------------\n\nTITLE: HTML Macro: SVG Example in Yew\nDESCRIPTION: This snippet demonstrates how to embed SVG elements within a Yew application using the `html!` macro. It showcases a basic SVG structure with different shapes and attributes. The `use yew::prelude::*;` statement imports necessary Yew functionalities.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/html/introduction.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <svg width=\"149\" height=\"147\" viewBox=\"0 0 149 147\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n        <path d=\"M60.5776 13.8268L51.8673 42.6431L77.7475 37.331L60.5776 13.8268Z\" fill=\"#DEB819\"/>\n        <path d=\"M108.361 94.9937L138.708 90.686L115.342 69.8642\" stroke=\"black\" stroke-width=\"4\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        <g filter=\"url(#filter0_d)\">\n            <circle cx=\"75.3326\" cy=\"73.4918\" r=\"55\" fill=\"#FDD630\"/>\n            <circle cx=\"75.3326\" cy=\"73.4918\" r=\"52.5\" stroke=\"black\" stroke-width=\"5\"/>\n        </g>\n        <circle cx=\"71\" cy=\"99\" r=\"5\" fill=\"white\" fill-opacity=\"0.75\" stroke=\"black\" stroke-width=\"3\"/>\n        <defs>\n            <filter id=\"filter0_d\" x=\"16.3326\" y=\"18.4918\" width=\"118\" height=\"118\" filterUnits=\"userSpaceOnUse\" color-interpolation-filters=\"sRGB\">\n                <@{\"feGaussianBlur\"} stdDeviation=\"2\"/>\n                <@{\"feColorMatrix\"} in=\"SourceAlpha\" type=\"matrix\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\"/>\n            </filter>\n        </defs>\n    </svg>\n};\n\n```\n\n----------------------------------------\n\nTITLE: Creating HTML Template for Yew Application\nDESCRIPTION: Adds an index.html file in the root directory of the app to serve as the entry point for the Yew application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_7\n\nLANGUAGE: html\nCODE:\n```\n<!doctype html>\n<html>\n    <head>\n        <meta charset=\"utf-8\" />\n        <title>Yew App</title>\n    </head>\n    <body></body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Installing Trunk and Adding WASM Target in Rust\nDESCRIPTION: Commands to install the Trunk build tool and add the WebAssembly target for Rust development.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/tutorial/index.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo install trunk\nrustup target add wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Infinite Loop Example in Yew Components\nDESCRIPTION: Example showing how infinite loops can occur in Yew components through improper lifecycle method implementation.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Context, Component, Html};\n\nstruct Comp;\n\nimpl Component for Comp {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn update(&mut self, _ctx: &Context<Self>, _msg: Self::Message) -> bool {\n        // We are going to always request to re-render on any msg\n        true\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        // For this example it doesn't matter what is rendered\n        Html::default()\n    }\n\n    fn rendered(&mut self, ctx: &Context<Self>, _first_render: bool) {\n        // Request that the component is updated with this new msg\n        ctx.link().send_message(());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Evaluation Order of Props in Yew with Rust\nDESCRIPTION: Illustrates the evaluation order of properties in Yew. Props are evaluated in the order they're specified, which is important when using iterators or other stateful operations to set prop values.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/function-components/properties.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(yew::Properties, PartialEq)]\nstruct Props { first: usize, second: usize, last: usize }\n\nfn main() {\n    let mut g = 1..=3;\n    let props = yew::props!(Props { first: g.next().unwrap(), second: g.next().unwrap(), last: g.next().unwrap() });\n\n    assert_eq!(props.first, 1);\n    assert_eq!(props.second, 2);\n    assert_eq!(props.last, 3);\n}\n```\n\n----------------------------------------\n\nTITLE: Valid Fragment Usage\nDESCRIPTION: Demonstrates the correct way to render multiple elements using fragments (<> </>) as a wrapper.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/basic-web-technologies/html.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\n// fixed: using html fragments\nhtml! {\n    <>\n        <div></div>\n        <p></p>\n    </>\n};\n```\n\n----------------------------------------\n\nTITLE: Basic Yew Application Setup\nDESCRIPTION: Initial Rust code for setting up a basic Yew web application with a Hello World component\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/tutorial/index.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[function_component(App)]\nfn app() -> Html {\n    html! {\n        <h1>{ \"Hello World\" }</h1>\n    }\n}\n\nfn main() {\n    yew::start_app::<App>();\n}\n```\n\n----------------------------------------\n\nTITLE: Using Functions for Complex Expressions in Yew HTML (Rust)\nDESCRIPTION: This snippet demonstrates how to use a function or closure to handle more complex expressions within Yew's HTML macro, improving readability.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.18.0/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nlet show_link = true;\nlet maybe_display_link = move || -> Html {\n  if show_link {\n    html! {\n      <a href=\"https://example.com\">{\"Link\"}</a>\n    }\n  } else {\n    html! {}\n  }\n};\n\nhtml! {\n     <div>{maybe_display_link()}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Handling String-like Attributes in Yew\nDESCRIPTION: Demonstrates different ways to pass string-like values to components in Yew, including using str, String, and Yew's custom AttrValue type. It recommends using AttrValue for better performance in certain scenarios.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/html/elements.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, virtual_dom::AttrValue};\n\nlet str_placeholder = \"I'm a str!\";\nlet string_placeholder = String::from(\"I'm a String!\");\nlet attrvalue_placeholder = AttrValue::from(\"I'm an AttrValue!\");\n\nhtml! {\n    <div>\n        <input placeholder={str_placeholder} />\n        <input placeholder={string_placeholder} />\n        <input placeholder={attrvalue_placeholder} />\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Yew Classes Macro Vector Example\nDESCRIPTION: This snippet showcases how to use a `Vec<String>` with the `classes!` macro to create a `Classes` instance from a vector of class names for a div element in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/html/classes.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(vec![\"class-1\", \"class-2\"])}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Component with Props Syntax in Yew\nDESCRIPTION: New syntax for setting the entire properties struct of a component in Yew 0.5.\nSOURCE: https://github.com/yewstack/yew/blob/master/CHANGELOG.md#2025-04-16_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\n<Component: with props />\n```\n\n----------------------------------------\n\nTITLE: Installing WebAssembly Target for Rust\nDESCRIPTION: Command to add the WebAssembly compilation target (wasm32-unknown-unknown) to your Rust development environment, which is required for compiling Rust code to run in browsers.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/getting-started/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nrustup target add wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Self-Closing Tags in Yew\nDESCRIPTION: Shows how to use self-closing tags in Yew's html! macro\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/introduction.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n  <input id=\"my_input\" />\n};\n```\n\n----------------------------------------\n\nTITLE: Using #[prop_or_default] Attribute for Optional Props in Yew\nDESCRIPTION: This snippet demonstrates how to make a property optional by using the #[prop_or_default] attribute. When the property is not provided, it will use the Default implementation for the field type.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/function-components/properties.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    #[prop_or_default]\n    pub is_loading: bool,\n}\n\n#[function_component]\nfn HelloWorld(&Props { is_loading }: &Props) -> Html {\n    if is_loading {\n        html! { \"Loading\" }\n    } else {\n        html! { \"Hello world\" }\n    }\n}\n\n// 這樣使用預設值\n#[function_component]\nfn Case1() -> Html {\n    html! { <HelloWorld /> }\n}\n// 或不覆蓋預設值\n#[function_component]\nfn Case2() -> Html {\n    html! { <HelloWorld is_loading=true /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Nested Components in Yew - Container Component (Rust)\nDESCRIPTION: Illustrates the implementation of a Container component that can accept and render child components. It uses the Children type to handle nested components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.18.0/concepts/html/components.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub struct Container(Props);\n\n#[derive(Properties)]\npub struct Props {\n    pub children: Children,\n}\n\nimpl Component for Container {\n    type Properties = Props;\n\n    // ...\n\n    fn view(&self) -> Html {\n       html! {\n           <div id=\"container\">\n               { self.0.children.clone() }\n           </div>\n       }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: VS Code Snippets Configuration for Yew Components\nDESCRIPTION: JSON configuration for VS Code snippets defining both function and struct component templates for Yew\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/getting-started/editor-setup.mdx#2025-04-16_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"New Yew function component\": {\n        \"prefix\": \"yewfc\",\n        \"body\": [\n            \"#[derive(PartialEq, Properties)]\",\n            \"pub struct ${1:ComponentName}Props {}\",\n            \"\",\n            \"#[function_component]\",\n            \"pub fn $1(props: &${1}Props) -> Html {\",\n            \"    let ${1}Props {} = props;\",\n            \"    html! {\",\n            \"        <${2:div}>$0</${2}>\",\n            \"    }\",\n            \"}\"\n        ],\n        \"description\": \"Create a minimal Yew function component\"\n    },\n    \"New Yew struct component\": {\n        \"prefix\": \"yewsc\",\n        \"body\": [\n            \"pub struct ${1:ComponentName};\",\n            \"\",\n            \"pub enum ${1}Msg {\",\n            \"}\",\n            \"\",\n            \"impl Component for ${1} {\",\n            \"    type Message = ${1}Msg;\",\n            \"    type Properties = ();\",\n            \"\",\n            \"    fn create(ctx: &Context<Self>) -> Self {\",\n            \"        Self\",\n            \"    }\",\n            \"\",\n            \"    fn view(&self, ctx: &Context<Self>) -> Html {\",\n            \"        html! {\",\n            \"            $0\",\n            \"        }\",\n            \"    }\",\n            \"}\"\n        ],\n        \"description\": \"Create a new Yew component with a message enum\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Event Handling: `ontouchstart` Event\nDESCRIPTION: This event handler is triggered when a touch point is placed on the touch surface. It relies on the `TouchEvent` struct from the `web-sys` crate, providing details about the starting touch.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/html/events.mdx#2025-04-16_snippet_10\n\nLANGUAGE: Rust\nCODE:\n```\n\"ontouchstart\"\n```\n\n----------------------------------------\n\nTITLE: Creating SVG Elements with html! Macro in Rust\nDESCRIPTION: Demonstrates how to create SVG graphics using the html! macro in Yew. This example creates a complex SVG with paths, circles, filters, and various attributes to render a custom graphic.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/introduction.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nhtml! {\n    <svg width=\"149\" height=\"147\" viewBox=\"0 0 149 147\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n        <path d=\"M60.5776 13.8268L51.8673 42.6431L77.7475 37.331L60.5776 13.8268Z\" fill=\"#DEB819\"/>\n        <path d=\"M108.361 94.9937L138.708 90.686L115.342 69.8642\" stroke=\"black\" stroke-width=\"4\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        <g filter=\"url(#filter0_d)\">\n            <circle cx=\"75.3326\" cy=\"73.4918\" r=\"55\" fill=\"#FDD630\"/>\n            <circle cx=\"75.3326\" cy=\"73.4918\" r=\"52.5\" stroke=\"black\" stroke-width=\"5\"/>\n        </g>\n        <circle cx=\"71\" cy=\"99\" r=\"5\" fill=\"white\" fill-opacity=\"0.75\" stroke=\"black\" stroke-width=\"3\"/>\n        <defs>\n            <filter id=\"filter0_d\" x=\"16.3326\" y=\"18.4918\" width=\"118\" height=\"118\" filterUnits=\"userSpaceOnUse\" color-interpolation-filters=\"sRGB\">\n                <feGaussianBlur stdDeviation=\"2\"/>\n                <feColorMatrix in=\"SourceAlpha\" type=\"matrix\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\"/>\n            </filter>\n        </defs>\n    </svg>\n};\n```\n\n----------------------------------------\n\nTITLE: Adding Location Listener in Yew Router (Rust)\nDESCRIPTION: Shows how to add a location listener in a struct component to react to route changes. The listener is stored in the component state to prevent it from being dropped.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/router.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn create(ctx: &Context<Self>) -> Self {\n    let listener = ctx.link()\n        .add_location_listener(ctx.link().callback(\n            // handle event\n        ))\n        .unwrap();\n    MyComponent {\n        _listener: listener\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SVG Rendering in Yew\nDESCRIPTION: Demonstrates rendering complex SVG content using Yew's html! macro, including paths, circles, and filters.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/introduction.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <svg width=\"149\" height=\"147\" viewBox=\"0 0 149 147\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n        <path d=\"M60.5776 13.8268L51.8673 42.6431L77.7475 37.331L60.5776 13.8268Z\" fill=\"#DEB819\"/>\n        <path d=\"M108.361 94.9937L138.708 90.686L115.342 69.8642\" stroke=\"black\" stroke-width=\"4\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        <g filter=\"url(#filter0_d)\">\n            <circle cx=\"75.3326\" cy=\"73.4918\" r=\"55\" fill=\"#FDD630\"/>\n            <circle cx=\"75.3326\" cy=\"73.4918\" r=\"52.5\" stroke=\"black\" stroke-width=\"5\"/>\n        </g>\n        <circle cx=\"71\" cy=\"99\" r=\"5\" fill=\"white\" fill-opacity=\"0.75\" stroke=\"black\" stroke-width=\"3\"/>\n        <defs>\n            <filter id=\"filter0_d\" x=\"16.3326\" y=\"18.4918\" width=\"118\" height=\"118\" filterUnits=\"userSpaceOnUse\" color-interpolation-filters=\"sRGB\">\n                <@{\"feGaussianBlur\"} stdDeviation=\"2\"/>\n                <@{\"feColorMatrix\"} in=\"SourceAlpha\" type=\"matrix\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\"/>\n            </filter>\n        </defs>\n    </svg>\n};\n```\n\n----------------------------------------\n\nTITLE: Using NodeRef.cast for DOM Element Type Conversion in Yew\nDESCRIPTION: Demonstrates how to use Yew's NodeRef.cast method to convert a generic DOM Node into a specific HTML element type. This approach simplifies the type conversion compared to using the JsCast trait directly.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/wasm-bindgen/web-sys.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::NodeRef;\n\nfn with_node_ref_cast(node_ref: NodeRef) {\n    if let Some(input) = node_ref.cast::<HtmlInputElement>() {\n        // do something with HtmlInputElement\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the Change Method in Yew (Rust)\nDESCRIPTION: Example showing how to implement the change lifecycle method to handle property updates from parent components and decide whether to re-render.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.18.0/concepts/components/introduction.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nimpl Component for MyComponent {\n    // ...\n\n    fn change(&mut self, props: Self::Properties) -> ShouldRender {\n        if self.props != props {\n            self.props = props;\n            true\n        } else {\n            false\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Callback in Yew ComponentLink\nDESCRIPTION: The 'callback' method registers a callback that sends messages to the component's update mechanism when executed. It takes a closure of type Fn(IN) -> Vec<COMP::Message> and returns a Callback<IN>.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.20/advanced-topics/struct-components/callbacks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ncallback\n```\n\n----------------------------------------\n\nTITLE: Complex Nested HTML Structure in Yew\nDESCRIPTION: Demonstrates creation of complex nested HTML layouts with various form elements and attributes\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/introduction.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <div>\n        <div data-key=\"abc\"></div>\n        <div class=\"parent\">\n            <span class=\"child\" value=\"anything\"></span>\n            <label for=\"first-name\">{ \"First Name\" }</label>\n            <input type=\"text\" id=\"first-name\" value=\"placeholder\" />\n            <input type=\"checkbox\" checked=true />\n            <textarea value=\"write a story\" />\n            <select name=\"status\">\n                <option selected=true disabled=false value=\"\">{ \"Selected\" }</option>\n                <option selected=false disabled=true value=\"\">{ \"Unselected\" }</option>\n            </select>\n        </div>\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a Suspending Hook in Rust\nDESCRIPTION: This snippet shows how to create a hook that suspends component rendering. It demonstrates the use of SuspensionResult and Suspension to handle asynchronous data loading.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/suspense.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew::suspense::{Suspension, SuspensionResult};\n\nstruct User {\n    name: String,\n}\n\n#[hook]\nfn use_user() -> SuspensionResult<User> {\n    match load_user() {\n        // If a user is loaded, then we return it as Ok(user).\n        Some(m) => Ok(m),\n        None => {\n            // When user is still loading, then we create a `Suspension`\n            // and call `SuspensionHandle::resume` when data loading\n            // completes, the component will be re-rendered\n            // automatically.\n            let (s, handle) = Suspension::new();\n            on_load_user_complete(move || {handle.resume();});\n            Err(s)\n        },\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Inheritance in web-sys with HtmlTextAreaElement\nDESCRIPTION: This snippet illustrates the inheritance chain in web-sys by using Deref and AsRef traits to navigate from HtmlTextAreaElement down to JsValue, showing how type conversion works in the browser DOM API bindings.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ops::Deref;\nuse web_sys:{\n    Element,\n    EventTarget,\n    HtmlElement,\n    HtmlTextAreaElement,\n    Node,\n};\n\nfn inheritance_of_text_area(text_area: HtmlTextAreaElement) {\n    // HtmlTextAreaElement is <textarea> in html.\n    let html_element: &HtmlElement = text_area.deref();\n\n    let element: &Element = html_element.deref();\n\n    let node: &Node = element.deref();\n\n    let event_target: &EventTarget = node.deref();\n\n    // Notice we have moved from web-sys types now into built-in\n    // JavaScript types which are in the js-sys crate.\n    let object: &js_sys::Object = event_target.deref();\n\n    // Notice we have moved from js-sys type to the root JsValue from\n    // the wasm-bindgen crate.\n    let js_value: &wasm_bindgen::JsValue = object.deref();\n\n    // Using deref like this means we have to manually traverse\n    // the inheritance tree, however, you can call JsValue methods\n    // on the HtmlTextAreaElement type.\n    // The `is_string` method comes from JsValue.\n    assert!(!text_area.is_string());\n\n    // empty function just to prove we can pass HtmlTextAreaElement as a\n    // &EventTarget.\n    fn this_function_only_takes_event_targets(targets: &EventTarget) {};\n\n    // The compiler will walk down the deref chain in order to match the types here.\n    this_function_only_takes_event_targets(&text_area);\n\n    // The AsRef implementations allow you to treat the HtmlTextAreaElement\n    // as an &EventTarget.\n    let event_target: &EventTarget = text_area.as_ref();\n\n}\n```\n\n----------------------------------------\n\nTITLE: Yew Classes Macro Multiple Strings Example\nDESCRIPTION: This snippet showcases how to pass multiple string literals to the `classes!` macro, creating a `Classes` instance with multiple class names for a div element in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/html/classes.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(\"class-1\", \"class-2\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Event Handling: `ontransitioncancel` Event\nDESCRIPTION: This event handler is triggered when a CSS transition is cancelled. It uses the `TransitionEvent` struct from the `web-sys` crate to provide information about the cancelled transition.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/html/events.mdx#2025-04-16_snippet_11\n\nLANGUAGE: Rust\nCODE:\n```\n\"ontransitioncancel\"\n```\n\n----------------------------------------\n\nTITLE: String-like Attributes in Yew\nDESCRIPTION: Shows different ways to handle string-like attributes in Yew, including using str, String, and AttrValue types.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/elements.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, virtual_dom::AttrValue};\n\nlet str_placeholder = \"I'm a str!\";\nlet string_placeholder = String::from(\"I'm a String!\");\nlet attrvalue_placeholder = AttrValue::from(\"I'm an AttrValue!\");\n\nhtml! {\n    <div>\n        <input placeholder={str_placeholder} />\n        <input placeholder={string_placeholder} />\n        <input placeholder={attrvalue_placeholder} />\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Rendering with Yew LocalServerRenderer for WASI in Rust\nDESCRIPTION: Demonstrates the use of Yew's LocalServerRenderer to perform server-side rendering in a WASI (WebAssembly System Interface) environment. This example is suitable for single-threaded execution contexts. The program sets up a Yew app for rendering using LocalServerRenderer, and depends on a suitable WASI target environment. It outputs the rendered HTML as a string wrapped in body tags.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/server-side-rendering.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// Build it by `wasm32-wasip1` target or `wasm32-wasip2` target (after rustc 1.78).\\n// You can still use `wasm32-wasi` target to build if you are using older version of rustc (before 1.84).\\n// See https://blog.rust-lang.org/2024/04/09/updates-to-rusts-wasi-targets.html for more information.\\n\\nuse yew::prelude::*;\\nuse yew::LocalServerRenderer;\\n\\n#[function_component]\\nfn App() -> Html {\\n    use yew_router::prelude::*;\\n\\n    html! {\\n        <>\\n            <h1>{\"Yew WASI SSR demo\"}</h1>\\n        </>\\n    }\\n}\\n\\npub async fn render() -> String {\\n    let renderer = LocalServerRenderer::<App>::new();\\n    let html_raw = renderer.render().await;\\n\\n    let mut body = String::new();\\n    body.push_str(\"<body>\");\\n    body.push_str(\"<div id='app'>\");\\n    body.push_str(&html_raw);\\n    body.push_str(\"</div>\");\\n    body.push_str(\"</body>\");\\n\\n    body\\n}\\n\\n#[tokio::main(flavor = \"current_thread\")]\\nasync fn main() {\\n    println!(\"{}\", render().await);\\n}\n```\n\n----------------------------------------\n\nTITLE: Using Vector of Class Names in Yew\nDESCRIPTION: Demonstrates how to use a Vector of class names with the classes! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(vec![\"class-1\", \"class-2\"])}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Event Handling: `ontouchmove` Event\nDESCRIPTION: This event handler is triggered when a touch point is moved along the touch surface. It uses the `TouchEvent` struct from the `web-sys` crate to provide details about the touch movement.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/html/events.mdx#2025-04-16_snippet_9\n\nLANGUAGE: Rust\nCODE:\n```\n\"ontouchmove\"\n```\n\n----------------------------------------\n\nTITLE: Example of Infinite Loop in Yew Component Lifecycle\nDESCRIPTION: This example demonstrates how an infinite loop can occur in a Yew component's lifecycle methods. It shows a component that always requests a re-render in the update method and sends a new message in the rendered method.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Context, Component, Html};\n\nstruct Comp;\n\nimpl Component for Comp {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn update(&mut self, _ctx: &Context<Self>, _msg: Self::Message) -> bool {\n        // We are going to always request to re-render on any msg\n        true\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        // For this example it doesn't matter what is rendered\n        Html::default()\n    }\n\n    fn rendered(&mut self, ctx: &Context<Self>, _first_render: bool) {\n        // Request that the component is updated with this new msg\n        ctx.link().send_message(());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using #[prop_or(value)] Attribute for Custom Default Values in Yew\nDESCRIPTION: Example of using the #[prop_or(value)] attribute to specify a custom default value for an optional property. The value expression is evaluated when the property is constructed without an explicit value.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/function-components/properties.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    #[prop_or_default]\n    pub is_loading: bool,\n    #[prop_or(AttrValue::Static(\"Bob\"))]\n    pub name: AttrValue,\n}\n\n#[function_component]\nfn Hello(&Props { is_loading, ref name }: &Props) -> Html {\n    if is_loading {\n        html! { \"Loading\" }\n    } else {\n        html! { <>\"Hello \"{name} </> }\n    }\n}\n\n// 這樣使用預設值\n#[function_component]\nfn Case1() -> Html {\n    html! { <Hello /> }\n}\n// 或不覆蓋預設值\n#[function_component]\nfn Case2() -> Html {\n    html! { <Hello name=\"Sam\" /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Optional Attributes for HTML Elements in Yew\nDESCRIPTION: This snippet shows how to use optional attributes for HTML elements in Yew. It demonstrates setting an optional id attribute using Some(x) or None.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.22/concepts/html/elements.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet maybe_id = Some(\"foobar\");\n\nhtml! {\n    <div id={maybe_id}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using classes! Macro with Vector of Classes in Yew (Rust)\nDESCRIPTION: Shows how to use the classes! macro with a vector of class strings to set multiple classes on a div element in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/html/classes.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(vec![\"class-1\", \"class-2\"])}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using Option-Wrapped Class Names in HTML Templates (Rust)\nDESCRIPTION: Shows how to use Option-wrapped class names in Yew's html! macro for conditional styling.\nSOURCE: https://github.com/yewstack/yew/blob/master/CHANGELOG.md#2025-04-16_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nlet color: &Option<String> = &self.color;\nhtml! { <div class=(\"btn\", color)></div> }\n```\n\n----------------------------------------\n\nTITLE: Navigating to the Project Directory\nDESCRIPTION: Changes the current directory to the newly created project directory.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd yew-app\n```\n\n----------------------------------------\n\nTITLE: Incorrect Multiple Element Rendering\nDESCRIPTION: Shows an invalid approach to rendering multiple elements in Yew's html! macro. This code will fail to compile due to the requirement of a single root node.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/fragments.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n    <div></div>\n    <p></p>\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Associated Types in a Yew Component - Rust\nDESCRIPTION: Explains the associated types 'Message' and 'Properties' within the Yew Component trait, discussing practical naming conventions and their roles in the component lifecycle.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/components/introduction.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nimpl Component for MyComponent {\n    type Message = Msg;\n    type Properties = Props;\n\n    // ...\n}\n\nenum Msg {\n    Click,\n    FormInput(String)\n}\n```\n\n----------------------------------------\n\nTITLE: Using Event Callbacks as Alternative to KeyboardService in Yew\nDESCRIPTION: This snippet demonstrates how to replace the deprecated KeyboardService with event callbacks directly on HTML elements. It shows setting up a keyboard event handler that prevents default behavior and can process keyboard events.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/services/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet callback = Callback::from(|e| {\n    e.prevent_default();\n    todo!(\"use `e`, like you would in service methods.\");\n});\nhtml! {\n    <input onkeydown={callback} />\n}\n```\n\n----------------------------------------\n\nTITLE: Event Handling: `onpointerup` Event\nDESCRIPTION: This event handler is triggered when a pointer button is released while the pointer is over an element. It uses the `PointerEvent` struct from the `web-sys` crate to provide information about the pointer event.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/html/events.mdx#2025-04-16_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n\"onpointerup\"\n```\n\n----------------------------------------\n\nTITLE: Invalid HTML Tags - Rust\nDESCRIPTION: Demonstrates an example of incorrect HTML tag usage in Yew, specifically a missing close tag, resulting in a compilation failure.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/introduction.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\\n\\nhtml! {\\n  <div id=\\\"my_div\\\"> // <- MISSING CLOSE TAG\\n};\n```\n\n----------------------------------------\n\nTITLE: Hydrating Server-side Rendered Yew Components in Rust\nDESCRIPTION: This example shows how to hydrate a server-side rendered Yew application on the client-side. It creates a Renderer for the App component and calls the hydrate method to connect the Yew application to the server-generated HTML.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/server-side-rendering.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew::Renderer;\n\n#[function_component]\nfn App() -> Html {\n    html! {<div>{\"Hello, World!\"}</div>}\n}\n\nfn main() {\n    let renderer = Renderer::<App>::new();\n\n    // hydrates everything under body element, removes trailing\n    // elements (if any).\n    renderer.hydrate();\n}\n```\n\n----------------------------------------\n\nTITLE: Mouse position tracking with JavaScript\nDESCRIPTION: This JavaScript example shows how to track mouse position relative to an element, which will be converted to Rust in the following examples.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\ndocument.getElementById('mousemoveme').onmousemove = (e) => {\n    // e = Mouse event.\n    var rect = e.target.getBoundingClientRect()\n    var x = e.clientX - rect.left //x position within the element.\n    var y = e.clientY - rect.top //y position within the element.\n    console.log('Left? : ' + x + ' ; Top? : ' + y + '.')\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested Children with Props in Yew\nDESCRIPTION: This snippet illustrates how to access and mutate nested component properties by typing the children in a List component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/children.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::rc::Rc;\nuse yew::prelude::*;\n\n#[derive(Clone, PartialEq, Properties)]\npub struct ListItemProps {\n    value: String,\n}\n\n#[function_component]\nfn ListItem(props: &ListItemProps) -> Html {\n    let ListItemProps { value } = props.clone();\n    html! {\n        <span>\n            {value}\n        </span>\n    }\n}\n\n#[derive(PartialEq, Properties)]\npub struct Props {\n    pub children: ChildrenWithProps<ListItem>,\n}\n\n#[function_component]\nfn List(props: &Props) -> Html {\n    let modified_children = props.children.iter().map(|mut item| {\n            let mut props = Rc::make_mut(&mut item.props);\n            props.value = format!(\"item-{}\", props.value);\n            item\n    });\n    html! { for modified_children }\n}\n\nhtml! {\n    <List>\n        <ListItem value=\"a\" />\n        <ListItem value=\"b\" />\n        <ListItem value=\"c\" />\n    </List>\n};\n```\n\n----------------------------------------\n\nTITLE: Yew Hook Usage Example After Migration\nDESCRIPTION: An example of how Yew hooks are used after the 0.21.0 update. It shows the more ergonomic approach where dependencies are the first argument, allowing for inline usage of struct methods.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/migration-guides/yew/from-0_20_0-to-0_21_0.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nimpl SomeLargeStruct {\n    fn id(&self) -> u32; // Only need to use the id as cache key\n}\nlet some_dep: SomeLargeStruct = todo!();\n\nuse_effect_with(some_dep.id(), move |_| { todo!(); drop(some_dep); });\n```\n\n----------------------------------------\n\nTITLE: Using String Variables for Classes in Yew\nDESCRIPTION: Demonstrates how to use a String variable containing space-separated class names with the classes! macro in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/classes.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nlet my_classes = String::from(\"class-1 class-2\");\n\nhtml! {\n  <div class={classes!(my_classes)}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Rendering Constants in Yew HTML (Rust)\nDESCRIPTION: This snippet demonstrates how to render constant values within Yew's HTML macro. It shows that text, string literals, and numbers can be inserted using curly braces {}.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.18.0/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nlet text = \"lorem ipsum\";\nhtml!{\n    <>\n        <div>{text}</div>\n        <div>{\"dolor sit\"}</div>\n        <span>{42}</span>\n    </>\n}\n```\n\n----------------------------------------\n\nTITLE: Building HTML from Iterator using 'for' keyword in Yew\nDESCRIPTION: This snippet shows an alternative syntax for rendering iterators in Yew using the 'for' keyword within the HTML macro. It creates a list of items from a range and renders them as an unordered list.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/lists.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet items = (1..=10).collect::<Vec<_>>();\n\nhtml! {\n    <ul class=\"item-list\">\n        { for items.iter() }\n    </ul>\n};\n```\n\n----------------------------------------\n\nTITLE: Using JsCast::dyn_into with NodeRef::get in Yew\nDESCRIPTION: This code snippet shows how to access the `Node` from a `NodeRef` using `NodeRef::get` and then cast it to a specific HTML element type (`HtmlInputElement`) using `JsCast::dyn_into`. This approach requires importing the `wasm_bindgen::JsCast` trait.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::JsCast;\nuse web_sys::HtmlInputElement;\nuse yew::NodeRef;\n\nfn with_jscast(node_ref: NodeRef) {\n    if let Some(input) = node_ref\n        .get()\n        .and_then(|node| node.dyn_into::<HtmlInputElement>().ok()) {\n        // 在這裡處理 HtmlInputElement\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Accessing document object in JavaScript and Rust comparison\nDESCRIPTION: This snippet compares how to access the document object in JavaScript versus the equivalent Rust code using web-sys. The Rust version demonstrates error handling with expect_throw to handle cases where window or document might be undefined.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/basic-web-technologies/js.mdx#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nlet document = window.document\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::UnwrapThrowExt;\nuse web_sys::window;\n\nlet document = window()\n    .expect_throw(\"window is undefined\")\n    .document()\n    .expect_throw(\"document is undefined\");\n```\n\n----------------------------------------\n\nTITLE: Working with Boolean Attributes in Yew\nDESCRIPTION: Explains how to use boolean attributes in Yew, which should be set to boolean values. It demonstrates both true and false cases, as well as using boolean expressions.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/html/elements.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <div hidden=true>\n        { \"This div is hidden.\" }\n    </div>\n};\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet no = 1 + 1 != 2;\n\nhtml! {\n    <div hidden={no}>\n        { \"This div is NOT hidden.\" }\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Adding Yew Component Snippets for VS Code in JSON\nDESCRIPTION: JSON configuration for VS Code snippets that provide templates for creating Yew function and struct components. These snippets include placeholders for component names and HTML tags with predefined structure.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/getting-started/editor-setup.mdx#2025-04-16_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"New Yew function component\": {\n        \"prefix\": \"yewfc\",\n        \"body\": [\n            \"#[derive(PartialEq, Properties)]\",\n            \"pub struct ${1:ComponentName}Props {}\",\n            \"\",\n            \"#[function_component]\",\n            \"pub fn $1(props: &${1}Props) -> Html {\",\n            \"    let ${1}Props {} = props;\",\n            \"    html! {\",\n            \"        <${2:div}>$0</${2}>\",\n            \"    }\",\n            \"}\"\n        ],\n        \"description\": \"Create a minimal Yew function component\"\n    },\n    \"New Yew struct component\": {\n        \"prefix\": \"yewsc\",\n        \"body\": [\n            \"pub struct ${1:ComponentName};\",\n            \"\",\n            \"pub enum ${1}Msg {\",\n            \"}\",\n            \"\",\n            \"impl Component for ${1} {\",\n            \"    type Message = ${1}Msg;\",\n            \"    type Properties = ();\",\n            \"\",\n            \"    fn create(ctx: &Context<Self>) -> Self {\",\n            \"        Self\",\n            \"    }\",\n            \"\",\n            \"    fn view(&self, ctx: &Context<Self>) -> Html {\",\n            \"        html! {\",\n            \"            $0\",\n            \"        }\",\n            \"    }\",\n            \"}\"\n        ],\n        \"description\": \"Create a new Yew component with a message enum\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating New Yew Project\nDESCRIPTION: Commands for creating and initializing a new Yew project\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/tutorial/index.mdx#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo new yew-app\ncd yew-app\n```\n\n----------------------------------------\n\nTITLE: Importing JavaScript console.log with wasm-bindgen in Rust\nDESCRIPTION: This snippet demonstrates how to manually import different variations of the console.log JavaScript function using the wasm-bindgen macro. It shows how to use js_namespace and js_name attributes to bind to specific JavaScript functions with different signatures.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/wasm-bindgen/wasm-bindgen.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::prelude::*;\n\n// First up let's take a look of binding `console.log` manually, without the\n// help of `web_sys`. Here we're writing the `#[wasm_bindgen]` annotations\n// manually ourselves, and the correctness of our program relies on the\n// correctness of these annotations!\n#[wasm_bindgen]\nextern \"C\" {\n\n    // Use `js_namespace` here to bind `console.log(..)` instead of just\n    // `log(..)`\n    #[wasm_bindgen(js_namespace = console)]\n    fn log(s: &str);\n\n    // The `console.log` is quite polymorphic, so we can bind it with multiple\n    // signatures. Note that we need to use `js_name` to ensure we always call\n    // `log` in JS.\n    #[wasm_bindgen(js_namespace = console, js_name = log)]\n    fn log_u32(a: u32);\n\n    // Multiple arguments too!\n    #[wasm_bindgen(js_namespace = console, js_name = log)]\n    fn log_many(a: &str, b: &str);\n}\n\n// using the imported functions!\nlog(\"Hello from Rust!\");\nlog_u32(42);\nlog_many(\"Logging\", \"many values!\");\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid HTML Syntax in Yew 0.19.0\nDESCRIPTION: An example of HTML macro syntax that is no longer valid in Yew 0.19.0, where props are not enclosed with braces.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/migration-guides/yew/from-0_18_0-to-0_19_0.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet super_age = 1;\nhtml!{\n    <JapaneseYew\n        age=super_age // ! Will throw an error\n    >\n}\n```\n\n----------------------------------------\n\nTITLE: Properties Evaluation Order in Yew\nDESCRIPTION: Example demonstrating that props in Yew are evaluated in the order they're specified, which can be important when the property values depend on sequential operations.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/function-components/properties.mdx#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(yew::Properties, PartialEq)]\nstruct Props { first: usize, second: usize, last: usize }\n\nfn main() {\n    let mut g = 1..=3;\n    let props = yew::props!(Props { first: g.next().unwrap(), second: g.next().unwrap(), last: g.next().unwrap() });\n\n    assert_eq!(props.first, 1);\n    assert_eq!(props.second, 2);\n    assert_eq!(props.last, 3);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Link Component for Navigation in Yew Router\nDESCRIPTION: Examples of using the Link component for in-app navigation in Yew. It shows how to create links to different routes, including those with parameters.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/router.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n<Link<Route> to={Route::Home}>{ \"click here to go home\" }</Link<Route>>\n\n<Link<Route> to={Route::Post { id: \"new-yew-release\".to_string() }}>{ \"Yew!\" }</Link<Route>>\n```\n\n----------------------------------------\n\nTITLE: HTML Macro: Invalid Open-Close Tag in Yew (Compile Fail)\nDESCRIPTION: This snippet showcases an example of invalid HTML structure using the `html!` macro in Yew, where the closing tag for the `div` element is missing. As a result, this code will fail to compile. The `use yew::prelude::*;` statement imports necessary Yew functionalities.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/html/introduction.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n  <div id=\"my_div\"> // <- 缺少閉合標籤\n};\n\n```\n\n----------------------------------------\n\nTITLE: Updated Component HTML Syntax in Yew\nDESCRIPTION: Example of the new HTML macro syntax in Yew 0.5 that supports multiple classes in a single string attribute.\nSOURCE: https://github.com/yewstack/yew/blob/master/CHANGELOG.md#2025-04-16_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\n<a class=\"button is-primary\",>\n```\n\n----------------------------------------\n\nTITLE: Running tests with wasm_bindgen_test\nDESCRIPTION: The `wasm_bindgen_test` crate allows developers to run tests in a browser environment, mirroring the behavior of Rust's built-in `#[test]` procedural macro. This functionality is integral for testing WebAssembly (WASM) applications built with Rust, enabling quick feedback on component integration and functionality.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/more/testing.mdx#2025-04-16_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nwasm_bindgen_test\n```\n\n----------------------------------------\n\nTITLE: Creating an Infinite Loop with Lifecycle Methods\nDESCRIPTION: Example demonstrating how improper implementation of rendered and update methods can create an infinite rendering loop.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/components/introduction.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Component, ComponentLink, Html};\n\nstruct Comp {\n    link: ComponentLink<Self>,\n}\n\nimpl Component for Comp {\n    type Message = ();\n    type Properties = ();\n\n    fn create(props: Self::Properties, link: ComponentLink<Self>) -> Self {\n        Self { link }\n    }\n\n    fn update(&mut self, _msg: Self::Message) -> bool {\n        // We are going to always request to re-render on any msg\n        true\n    }\n\n    fn view(&self) -> Html {\n        // For this example it doesn't matter what is rendered\n        Html::default()\n    }\n\n    fn rendered(&mut self, _first_render: bool) {\n        // Request that the component is updated with this new msg\n        self.link.send_message(());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for Yew\nDESCRIPTION: Updates the Cargo.toml file to include Yew as a dependency, specifically using the development version from GitHub with client-side rendering support.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"yew-app\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\n# this is the development version of Yew\nyew = { git = \"https://github.com/yewstack/yew/\", features = [\"csr\"] }\n```\n\n----------------------------------------\n\nTITLE: Console Logging with gloo-console in Rust\nDESCRIPTION: This example shows how to use the gloo-console crate, part of Gloo, to log messages to the browser console. The log! macro can directly accept JsValue, making it easier to use than wasm_logger.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/more/debugging.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse gloo_console::log;\nuse wasm_bindgen::JsValue;\n\nfn main() {\n    let object = JsValue::from(\"world\");\n    log!(\"Hello\", object)\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Trunk and Adding WASM Build Target\nDESCRIPTION: Commands to install Trunk, a build tool for Yew applications, and add the WebAssembly build target to Rust.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/tutorial/index.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo install trunk\nrustup target add wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: JavaScript Mouse Move Event Handler\nDESCRIPTION: Original JavaScript code for handling mouse move events and logging mouse position relative to an element.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\ndocument.getElementById('mousemoveme').onmousemove = (e) => {\n    var rect = e.target.getBoundingClientRect()\n    var x = e.clientX - rect.left\n    var y = e.clientY - rect.top\n    console.log('Left? : ' + x + ' ; Top? : ' + y + '.')\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Properties for a Link Component in Rust with Yew\nDESCRIPTION: Example implementation of Properties for a Link component using Yew framework, demonstrating required fields, optional properties with default values, and performance considerations for data passing between components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.18.0/concepts/components/properties.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::rc::Rc;\nuse yew::Properties;\n\n#[derive(Clone, PartialEq)]\npub enum LinkColor {\n    Blue,\n    Red,\n    Green,\n    Black,\n    Purple,\n}\n\nimpl Default for LinkColor {\n    fn default() -> Self {\n        // 除非有指定，否則預設是藍色\n        LinkColor::Blue\n    }\n}\n\n#[derive(Properties, Clone, PartialEq)]\npub struct LinkProps {\n    /// 連結必須要有一個目標\n    href: String,\n    /// 如果連結文字很大，複製字串的參考可以減少記憶體的開銷\n    /// 但除非效能已經成為嚴重的問題，否則通常不建議這麼做\n    text: Rc<String>,\n    /// 連結的顏色\n    #[prop_or_default]\n    color: LinkColor,\n    /// 如果為 None，那 view 方法將不會指定 size\n    #[prop_or_default]\n    size: Option<u32>,\n    /// 當沒有指定 active，預設為 true\n    #[prop_or(true)]\n    active: bool,\n}\n```\n\n----------------------------------------\n\nTITLE: Using NodeRef::cast in Yew\nDESCRIPTION: This snippet demonstrates how to use the NodeRef::cast method in Yew to convert a Node reference to a specific HTML element type.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::NodeRef;\n\nfn with_node_ref_cast(node_ref: NodeRef) {\n    if let Some(input) = node_ref.cast::<HtmlInputElement>() {\n        // 在这里处理 HtmlInputElement\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Yew Application for Production\nDESCRIPTION: Command to build a Yew application in release mode for production deployment. This creates optimized files in the dist directory that can be served by an HTTP server.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/more/deployment.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk build --release\n```\n\n----------------------------------------\n\nTITLE: Importing Snapshot Testing Module in Rust for Yew\nDESCRIPTION: This snippet shows how to import the layout_tests module from Yew for snapshot testing of components. It's a basic import statement that provides access to snapshot testing functionality.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/more/testing.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nyew::tests::layout_tests\n```\n\n----------------------------------------\n\nTITLE: Using Functional Update Syntax with Children in Yew Components\nDESCRIPTION: Demonstrates using the Rust-like functional update syntax (..props) with components that have children. Shows how children passed in the html! macro overwrite any existing children in the props.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/components.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    id: String,\n    children: Html,\n}\n\n#[function_component]\nfn Container(props: &Props) -> Html {\n    html! {\n        <div id={props.id.clone()}>\n            { props.children.clone() }\n        </div>\n    }\n}\n\nlet props = yew::props!(Props {\n    id: \"container-2\",\n    children: Html::default(),\n});\n\nhtml! {\n    <Container ..props>\n        // props.children will be overwritten with this\n        <span>{ \"I am a child, as you can see\" }</span>\n    </Container>\n};\n```\n\n----------------------------------------\n\nTITLE: Using classes! Macro with Array of Classes in Yew (Rust)\nDESCRIPTION: Illustrates using the classes! macro with an array of class strings to set multiple classes on a div element in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/html/classes.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!([\"class-1\", \"class-2\"])}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Enum-Based Child Components in Yew\nDESCRIPTION: Demonstrates how to create a component that accepts children of multiple specific types using an enum. This approach allows for more flexibility in child component types while maintaining type safety.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/advanced-topics/children.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew:{\n    html, html::ChildrenRenderer, virtual_dom::VChild, Component,\n    Context, Html, Properties,\n};\n\npub struct Primary;\n\nimpl Component for Primary {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"Primary\" }\n        }\n    }\n}\n\npub struct Secondary;\n\nimpl Component for Secondary {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"Secondary\" }\n        }\n    }\n}\n\n#[derive(Clone, derive_more::From, PartialEq)]\npub enum Item {\n    Primary(VChild<Primary>),\n    Secondary(VChild<Secondary>),\n}\n\n#[allow(clippy::from_over_into)]\nimpl Into<Html> for Item {\n    fn into(self) -> Html {\n        match self {\n            Self::Primary(child) => child.into(),\n            Self::Secondary(child) => child.into(),\n        }\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: ChildrenRenderer<Item>,\n}\n\npub struct List;\n\nimpl Component for List {\n    type Message = ();\n    type Properties = ListProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"list\">\n                { for ctx.props().children.iter() }\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Video List to HTML Elements\nDESCRIPTION: Code that transforms a collection of Video structs into HTML elements using Yew's html! macro, iterating over each video and creating a paragraph element with the video information.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nlet videos = videos.iter().map(|video| html! {\n    <p key={video.id}>{format!(\"{}: {}\", video.speaker, video.title)}</p>\n}).collect::<Html>();\n```\n\n----------------------------------------\n\nTITLE: Using NodeRef::cast in Yew\nDESCRIPTION: This snippet demonstrates how to use NodeRef::cast to convert a NodeRef to a specific HTML element type in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::NodeRef;\n\nfn with_node_ref_cast(node_ref: NodeRef) {\n    if let Some(input) = node_ref.cast::<HtmlInputElement>() {\n        // Handle HtmlInputElement here\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing and Using console.log with wasm-bindgen in Rust\nDESCRIPTION: This example demonstrates how to manually bind JavaScript's console.log function with different signatures using the #[wasm_bindgen] macro, allowing Rust code to log messages to the browser console.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/basic-web-technologies/wasm-bindgen.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::prelude::*;\n\n// First up let's take a look of binding `console.log` manually, without the\n// help of `web_sys`. Here we're writing the `#[wasm_bindgen]` annotations\n// manually ourselves, and the correctness of our program relies on the\n// correctness of these annotations!\n#[wasm_bindgen]\nextern \"C\" {\n    // Use `js_namespace` here to bind `console.log(..)` instead of just\n    // `log(..)`\n    #[wasm_bindgen(js_namespace = console)]\n    fn log(s: &str);\n\n    // The `console.log` is quite polymorphic, so we can bind it with multiple\n    // signatures. Note that we need to use `js_name` to ensure we always call\n    // `log` in JS.\n    #[wasm_bindgen(js_namespace = console, js_name = log)]\n    fn log_u32(a: u32);\n\n    // Multiple arguments too!\n    #[wasm_bindgen(js_namespace = console, js_name = log)]\n    fn log_many(a: &str, b: &str);\n}\n\n// using the imported functions!\nlog(\"Hello from Rust!\");\nlog_u32(42);\nlog_many(\"Logging\", \"many values!\");\n```\n\n----------------------------------------\n\nTITLE: Installing Trunk with Cargo\nDESCRIPTION: This command installs the Trunk tool, which is used for building and serving Yew applications. Trunk handles tasks like bundling and hot reloading during development.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n\"cargo install trunk\"\n```\n\n----------------------------------------\n\nTITLE: String-like Attributes in Yew\nDESCRIPTION: Shows different ways of setting string attributes using str, String, and AttrValue types\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/elements.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, virtual_dom::AttrValue};\n\nlet str_placeholder = \"I'm a str!\";\nlet string_placeholder = String::from(\"I'm a String!\");\nlet attrvalue_placeholder = AttrValue::from(\"I'm an AttrValue!\");\n\nhtml! {\n    <div>\n        <input placeholder={str_placeholder} />\n        <input placeholder={string_placeholder} />\n        <input placeholder={attrvalue_placeholder} />\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Installing Trunk and wasm-bindgen-cli\nDESCRIPTION: This snippet provides the commands necessary to install Trunk and wasm-bindgen-cli, which are required to build and serve Yew applications. Both tools are installed via Cargo, the Rust package manager, with the --locked flag ensuring version consistency.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/getting-started/project-setup/using-trunk.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo install --locked trunk\ncargo install wasm-bindgen-cli\n```\n\n----------------------------------------\n\nTITLE: Demonstrating web-sys Inheritance in Rust\nDESCRIPTION: This snippet shows how to use Deref to traverse the inheritance chain of web-sys types, from HtmlTextAreaElement down to JsValue.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ops::Deref;\nuse web_sys::{Element, EventTarget, HtmlElement, HtmlTextAreaElement, Node};\n\nfn inheritance_of_text_area(text_area: HtmlTextAreaElement) {\n    let html_element: &HtmlElement = text_area.deref();\n    let element: &Element = html_element.deref();\n    let node: &Node = element.deref();\n    let event_target: &EventTarget = node.deref();\n    let object: &js_sys::Object = event_target.deref();\n    let js_value: &wasm_bindgen::JsValue = object.deref();\n    assert!(!text_area.is_string());\n    fn this_function_only_takes_event_targets(targets: &EventTarget) {};\n    this_function_only_takes_event_targets(&text_area);\n    let event_target: &EventTarget = text_area.as_ref();\n}\n```\n\n----------------------------------------\n\nTITLE: Automatic Code Migration Script\nDESCRIPTION: Bash script using perl to automatically update the changed method signature in Rust files.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/migration-guides/yew/from-0_19_0-to-0_20_0.mdx#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nperl -p -i -e  's/fn changed\\(&mut self, (\\w+): &Context<Self>\\)/fn changed(&mut self, $1: &Context<Self>, _old_props: &Self::Properties)/g' $(find . -name \\*.rs)\n```\n\n----------------------------------------\n\nTITLE: use_subscribe Hook Implementation\nDESCRIPTION: This code implements the `use_subscribe` custom hook using `use_hook`. It subscribes to an `EventBus` within a `use_effect` hook and updates the state with incoming messages. The `hook_callback` is used to update the internal state, and the function returns a clone of the messages.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.21/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n```rust\nfn use_subscribe() -> Rc<RefCell<Vec<String>>> {\n    use_hook(\n        // hook's handler. all the logic goes in here\n        |state: &mut UseSubscribeState, hook_callback| {\n            // calling other Hooks inside a hook\n            use_effect(move || {\n                let producer = EventBus::bridge(Callback::from(move |msg| {\n                    hook_callback(\n                        // where the mutations of state are performed\n                        |state| {\n                            (*state.messages).borrow_mut().deref_mut().push(msg);\n                            true // should re-render\n                        }, false // run post-render\n                    )\n                }));\n\n                || drop(producer)\n            });\n\n            // return from hook\n            state.messages.clone()\n        },\n        // initial state producer\n        || UseSubscribeState { messages: Rc::new(RefCell::new(vec![])) },\n    )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Location Listener in Struct Components\nDESCRIPTION: Demonstrates how to set up a location listener in struct components to react to route changes using add_location_listener method.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/router.mdx#2025-04-16_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nfn create(ctx: &Context<Self>) -> Self {\n    let listener = ctx.link()\n        .add_location_listener(ctx.link().callback(\n            // handle event\n        ))\n        .unwrap();\n    MyComponent {\n        _listener: listener\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Emitting Callback in Yew\nDESCRIPTION: Callbacks have an 'emit' function that takes its <IN> type as an argument and converts it to the expected message for the target. This is used in child components to send messages back to parent components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.20/advanced-topics/struct-components/callbacks.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nemit\n```\n\n----------------------------------------\n\nTITLE: New Component Changed Method Signature\nDESCRIPTION: Updated implementation of the component changed lifecycle method that receives both context and old properties.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/migration-guides/yew/from-0_19_0-to-0_20_0.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn changed(&mut self, ctx: &Context<Self>, old_props: &Self::Properties) -> bool\n```\n\n----------------------------------------\n\nTITLE: Using Inline Styles in Yew\nDESCRIPTION: Demonstrates how to apply inline styles directly to an element using the style attribute.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div style=\"color: red;\"></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using Braces with Props in HTML Macro – Rust\nDESCRIPTION: This code snippet demonstrates the requirement for braces around props when using the html! macro in Yew 0.19.0. It highlights incorrect and correct usage examples.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/migration-guides/yew/from-0_18_0-to-0_19_0.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet super_age = 1;\nhtml!{\n    <JapaneseYew\n        age=super_age // ! Will throw an error\n    >\n}\n\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet super_age = 1;\nhtml!{\n    <JapaneseYew\n        age={super_age} // Correct\n    >\n}\n\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet age = 1;\nhtml!{\n    <JapaneseYew\n        {age}\n    >\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Efficient Change Detection with ShouldRender in Yew\nDESCRIPTION: This snippet demonstrates how to optimize component re-rendering by implementing the change method to only re-render when props actually change, using PartialEq to compare the old and new props.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/advanced-topics/optimizations.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::ShouldRender;\n\n#[derive(PartialEq)]\nstruct ExampleProps;\n\nstruct Example {\n    props: ExampleProps,\n}\n\nimpl Example {\n    fn change(&mut self, props: ExampleProps) -> ShouldRender {\n        if self.props != props {\n            self.props = props;\n            true\n        } else {\n            false\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Tracing to Browser Console with tracing-web in Rust\nDESCRIPTION: This snippet illustrates how to use tracing-web with tracing-subscriber to output messages to the browser console. It configures various formatting options and initializes both a formatting layer and a performance layer.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/more/debugging.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing_subscriber::{\n    fmt::{\n        format::{FmtSpan, Pretty},\n        time::UtcTime,\n    },\n    prelude::*,\n};\nuse wasm_bindgen::JsValue;\n\nfn main() {\n    let fmt_layer = tracing_subscriber::fmt::layer()\n        .with_ansi(false)\n        .with_timer(UtcTime::rfc_3339())\n        .with_writer(tracing_web::MakeConsoleWriter)\n        .with_span_events(FmtSpan::ACTIVE);\n    let perf_layer = tracing_web::performance_layer().with_details_from_fields(Pretty::default());\n\n    tracing_subscriber::registry()\n        .with(fmt_layer)\n        .with(perf_layer)\n        .init();\n    let object = JsValue::from(\"world\");\n    tracing::info!(\"Hello {}\", object.as_string().unwrap());\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Default Implementation for Enum in Rust\nDESCRIPTION: This code implements the `Default` trait for the `LinkColor` enum in Rust. It sets the default value to `LinkColor::Blue`, ensuring that the link color will be blue unless otherwise specified.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.21/advanced-topics/struct-components/properties.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nimpl Default for LinkColor {\n    fn default() -> Self {\n        // 除非另有说明，否则链接的颜色将为蓝色\n        LinkColor::Blue\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Children Components in Yew\nDESCRIPTION: Shows how to implement a component that accepts any children without type restrictions using the Children type from Yew. The List component renders all children inside a div with a 'list' class.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/components/children.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Children, Component, Html, Properties};\n\n#[derive(Properties, Clone)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: Children,\n}\n\npub struct List {\n    props: ListProps,\n}\n\nimpl Component for List {\n    type Properties = ListProps;\n    // ...\n\n    fn view(&self) -> Html {\n        html! {\n            <div class=\"list\">\n                { for self.props.children.iter() }\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using yew::props! Macro in Yew\nDESCRIPTION: Shows how to use the yew::props! macro to build properties in a similar way to the html! macro. It allows creating properties outside of the html! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/function-components/properties.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    #[prop_or_default]\n    pub is_loading: bool,\n    #[prop_or(AttrValue::Static(\"Bob\"))]\n    pub name: AttrValue,\n}\n\n#[function_component]\nfn Hello(&Props { is_loading, ref name }: &Props) -> Html {\n    if is_loading {\n        html! { \"Loading\" }\n    } else {\n        html! { <>{{\"Hello \"}}{{name}}</> }\n    }\n}\n\n#[function_component]\nfn App() -> Html {\n    let pre_made_props = yew::props! {\n        Props {} // Notice we did not need to specify name prop\n    };\n    html! { <Hello ..pre_made_props /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing yew-router Dependency in Rust Project\nDESCRIPTION: Command to add the yew-router crate as a dependency to a Rust project using Cargo.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/router.mdx#2025-04-16_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncargo add yew-router\n```\n\n----------------------------------------\n\nTITLE: Expanding html! Macro in Rust with cargo-expand\nDESCRIPTION: To see the expanded code generated by the html! macro, you can use the cargo-expand command. This tool needs to be installed separately and allows developers to inspect the actual Rust code produced by macros.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/how-it-works.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo install cargo-expand\n```\n\n----------------------------------------\n\nTITLE: Creating Video Instances and Rendering Dynamic Content\nDESCRIPTION: Generating Video instances and using Rust iterators to dynamically render content in the Yew application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/tutorial/index.mdx#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nlet videos = vec![\n    Video {\n        id: 1,\n        title: \"Building and breaking things\".to_string(),\n        speaker: \"John Doe\".to_string(),\n        url: \"https://youtu.be/PsaFVLr8t4E\".to_string(),\n    },\n    // ... other video instances ...\n];\n\nlet videos = videos.iter().map(|video| html! {\n    <p key={video.id}>{format!(\"{}: {}\", video.speaker, video.title)}</p>\n}).collect::<Html>();\n```\n\n----------------------------------------\n\nTITLE: Optional Single Child Component in Yew\nDESCRIPTION: Implementation of a page component with an optional sidebar\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/advanced-topics/children.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, html_nested, virtual_dom::VChild, Component, Context, Html, Properties};\n\n#[derive(Properties, PartialEq)]\npub struct PageProps {\n    #[prop_or_default]\n    pub sidebar: Option<VChild<PageSideBar>>,\n}\n\nimpl Component for Page {\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"page\">\n                { ctx.props().sidebar.clone().map(Html::from).unwrap_or_default() }\n            </div>\n        }\n    }\n}\n\npub fn render_page(with_sidebar: bool) -> Html {\n    if with_sidebar {\n        html! {\n            <Page sidebar={html_nested! {<PageSideBar />}} />\n        }\n    } else {\n        html! { <Page /> }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using classes! macro with Optional Values in Yew\nDESCRIPTION: Shows how to conditionally apply a class using Option with the classes! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(Some(\"class\"))} />\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Nightly Cargo for Advanced Optimizations in Rust\nDESCRIPTION: This snippet demonstrates how to configure unstable rustc features in .cargo/config.toml for additional optimization benefits. It includes settings for build-std and build-std-features, which require the nightly toolchain.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/optimizations.mdx#2025-04-16_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[unstable]\n# Requires the rust-src component. `rustup +nightly component add rust-src`\nbuild-std = [\"std\", \"panic_abort\"]\nbuild-std-features = [\"panic_immediate_abort\"]\n```\n\n----------------------------------------\n\nTITLE: Setting Element Attributes in Yew\nDESCRIPTION: Demonstrates how to set attributes on HTML elements using variables in the `html!` macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/introduction.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet value = \"something\";\nhtml! { <div attribute={value} /> };\n```\n\n----------------------------------------\n\nTITLE: Event Target Casting with JsCast - Dangerous Approach\nDESCRIPTION: Shows unchecked event target conversion using JsCast's unchecked_into method, which assumes the correct type without runtime checks\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/events.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet on_dangerous_change = Callback::from(move |e: Event| {\n    let target: EventTarget = e.target().expect(\"Event should have a target\");\n    input_value_handle.set(target.unchecked_into::<HtmlInputElement>().value());\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Infinite Loops in Components - Rust\nDESCRIPTION: Demonstrates a Yew component that may enter an infinite loop due to its update and rendered methods triggering each other, illustrating a common pitfall.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/components/introduction.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Context, Component, Html};\n\nstruct Comp;\n\nimpl Component for Comp {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn update(&mut self, _ctx: &Context<Self>, _msg: Self::Message) -> bool {\n        // We are going to always request to re-render on any msg\n        true\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        // For this example it doesn't matter what is rendered\n        Html::default()\n    }\n\n    fn rendered(&mut self, ctx: &Context<Self>, _first_render: bool) {\n        // Request that the component is updated with this new msg\n        ctx.link().send_message(());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing wasm-pack with cargo\nDESCRIPTION: This command installs the wasm-pack tool using cargo, the Rust package manager. Wasm-pack is used for building and packaging Rust code into WebAssembly modules for use in web applications.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/project-setup/using-wasm-pack.mdx#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n\"cargo install wasm-pack\"\n```\n\n----------------------------------------\n\nTITLE: Using Fully Qualified Syntax in Yew Macro Output\nDESCRIPTION: To avoid trait method name conflicts, the macro output uses fully qualified syntax like `<Type as Trait>` to ensure the correct trait member is used.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/advanced-topics/how-it-works.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n<Type as Trait>\n```\n\n----------------------------------------\n\nTITLE: Basic HTML Structure for Yew App\nDESCRIPTION: This snippet creates a basic `index.html` file for a Yew application. It serves as the entry point for the web application and will be populated by Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_6\n\nLANGUAGE: html\nCODE:\n```\n\"<!doctype html>\n<html lang=\\\"en\\\">\n    <head></head>\n    <body></body>\n</html>\"\n```\n\n----------------------------------------\n\nTITLE: Simulating Inheritance in Web-Sys with Rust Deref\nDESCRIPTION: Demonstrates how to traverse type inheritance in web-sys by using Deref trait to move through different web API types down to JsValue\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/wasm-bindgen/web-sys.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ops::Deref;\nuse web_sys::{\n    Element,\n    EventTarget,\n    HtmlElement,\n    HtmlTextAreaElement,\n    Node,\n};\n\nfn inheritance_of_text_area(text_area: HtmlTextAreaElement) {\n    let html_element: &HtmlElement = text_area.deref();\n    let element: &Element = html_element.deref();\n    let node: &Node = element.deref();\n    let event_target: &EventTarget = node.deref();\n    let object: &js_sys::Object = event_target.deref();\n    let js_value: &wasm_bindgen::JsValue = object.deref();\n\n    assert!(!text_area.is_string());\n}\n```\n\n----------------------------------------\n\nTITLE: Setting crate-type in Cargo.toml for wasm-pack\nDESCRIPTION: This snippet shows how to modify the crate-type in the Cargo.toml file to include `cdylib`. This is a requirement for wasm-pack to correctly build the Rust code into a WebAssembly module that can be used in a web application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/project-setup/using-wasm-pack.mdx#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n\"[lib]\\ncrate-type = [\"rlib\", \"cdylib\"]\"\n```\n\n----------------------------------------\n\nTITLE: Invalid Usage Without Fragments in Yew's html! Macro (Rust)\nDESCRIPTION: This snippet illustrates an invalid use of the html! macro in Yew, where multiple root elements are provided without a fragment. This results in a compilation error due to the single root element requirement.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/fragments.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n// error: only one root html element allowed\n\nhtml! {\n    <div></div>\n    <p></p>\n};\n```\n\n----------------------------------------\n\nTITLE: Event Handling: `ontouchcancel` Event\nDESCRIPTION: This event handler is triggered when a touch event is interrupted, such as when the touch is disrupted by a system event. It uses the `TouchEvent` struct from the `web-sys` crate to provide details about the cancelled touch.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/html/events.mdx#2025-04-16_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\n\"ontouchcancel\"\n```\n\n----------------------------------------\n\nTITLE: Installing Trunk for Yew Application Management\nDESCRIPTION: This command installs Trunk, the recommended tool for managing deployment and packaging of Yew applications. It compiles from scratch, which may take some time.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/getting-started/introduction.mdx#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo install --locked trunk\n```\n\n----------------------------------------\n\nTITLE: Applying Inline Styles in Yew (Rust)\nDESCRIPTION: Shows how to apply inline styles to a div element in Yew using the style attribute. This method doesn't use any special Yew features for styling.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div style=\"color: red;\"></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Old Changed Method Signature in Yew Components - Rust\nDESCRIPTION: This snippet displays the previous method signature of 'changed' in Yew components before the update. Understanding the previous state helps developers in transitioning to the new method signature.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/migration-guides/yew/from-0_19_0-to-0_20_0.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn changed(&mut self, ctx: &Context<Self>) -> bool\n```\n\n----------------------------------------\n\nTITLE: Yew Classes Macro String Variable Example\nDESCRIPTION: This snippet illustrates how to use a `String` variable with the `classes!` macro to apply dynamically generated classes to a div element in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/html/classes.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nlet my_classes = String::from(\"class-1 class-2\");\n\nhtml! {\n  <div class={classes!(my_classes)}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Text and Binary Type Aliases for Fetch Operations in Rust\nDESCRIPTION: Type aliases that define the format for text and binary data handling in Yew's fetch service. These are Result types that contain either the data (String or Vec<u8>) or an Error.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/services/fetch.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub type Text = Result<String, Error>;\npub type Binary = Result<Vec<u8>, Error>;\n```\n\n----------------------------------------\n\nTITLE: Configuring Relative Path Build with Base Tag\nDESCRIPTION: HTML configuration for customizing public URL handling in Trunk build process, allowing for non-root deployments\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/more/deployment.mdx#2025-04-16_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<base data-trunk-public-url />\n```\n\n----------------------------------------\n\nTITLE: Enum-Based Child Component Restrictions in Yew\nDESCRIPTION: Advanced technique for restricting child components to specific enum variants\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/advanced-topics/children.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, html::ChildrenRenderer, virtual_dom::VChild, Component, Context, Html, Properties};\n\n#[derive(Clone, derive_more::From, PartialEq)]\npub enum Item {\n    Primary(VChild<Primary>),\n    Secondary(VChild<Secondary>),\n}\n\n#[impl_into_html] // Optional derive macro equivalent\nimpl Into<Html> for Item {\n    fn into(self) -> Html {\n        match self {\n            Self::Primary(child) => child.into(),\n            Self::Secondary(child) => child.into(),\n        }\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: ChildrenRenderer<Item>,\n}\n```\n\n----------------------------------------\n\nTITLE: Attaching NodeRef to HTML Element in Yew\nDESCRIPTION: This snippet shows how to attach a `NodeRef` to an HTML element using the `ref` attribute in the `html!` macro. The `node_ref.clone()` method is used to create a new `NodeRef` pointing to the same DOM element. This allows the component to maintain a reference to the DOM element after it has been rendered.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/advanced-topics/struct-components/refs.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::Element;\nuse yew::{html, Component, Context, Html, NodeRef};\n\nstruct Comp {\n    node_ref: NodeRef,\n}\n\nimpl Component for Comp {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            // highlight-next-line\n            node_ref: NodeRef::default(),\n        }\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            // highlight-next-line\n            <div ref={self.node_ref.clone()}></div>\n        }\n    }\n\n    fn rendered(&mut self, _ctx: &Context<Self>, _first_render: bool) {\n        // highlight-start\n        let has_attributes = self.node_ref\n            .cast::<Element>()\n            .unwrap()\n            .has_attributes();\n        // highlight-end\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Yew Agents Import Paths\nDESCRIPTION: Example showing how to update import paths after yew-agents was separated into its own crate. Developers need to change imports from the yew namespace to the dedicated yew_agents namespace.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/migration-guides/yew-agent/from-0_0_0-to-0_1_0.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Old import\nyew::*\n\n// New import\nyew_agents::*\n```\n\n----------------------------------------\n\nTITLE: Updating Switch Component Usage in Yew 0.17.0\nDESCRIPTION: In Yew 0.17.0, the Switch component has been simplified. The render function is now passed directly to the component, eliminating the need for a separate Switch::render method.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/migration-guides/yew-router/from-0_16_0-to-0_17_0.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n<Switch />\n```\n\n----------------------------------------\n\nTITLE: Creating VideoDetails Component in Rust\nDESCRIPTION: This snippet defines a new VideoDetails component that displays details of a selected video. It shows how to create a simple presentational component in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/tutorial/index.mdx#2025-04-16_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nuse website_test::tutorial::Video;\nuse yew::prelude::*;\n\n#[derive(Clone, Properties, PartialEq)]\nstruct VideosDetailsProps {\n    video: Video,\n}\n\n#[function_component(VideoDetails)]\nfn video_details(VideosDetailsProps { video }: &VideosDetailsProps) -> Html {\n    html! {\n        <div>\n            <h3>{ video.title.clone() }</h3>\n            <img src=\"https://placehold.co/640x360.png?text=Video+Player+Placeholder\" alt=\"video thumbnail\" />\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting HTML to Yew Markup - Rust\nDESCRIPTION: This snippet demonstrates how to use Yew's HTML-like syntax to represent a simple layout for the application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n    <>\n        <h1>{ \"RustConf Explorer\" }</h1>\n        <div>\n            <h3>{ \"Videos to watch\" }</h3>\n            <p>{ \"John Doe: Building and breaking things\" }</p>\n            <p>{ \"Jane Smith: The development process\" }</p>\n            <p>{ \"Matt Miller: The Web 7.0\" }</p>\n            <p>{ \"Tom Jerry: Mouseless development\" }</p>\n        </div>\n        <div>\n            <h3>{ \"John Doe: Building and breaking things\" }</h3>\n            <img src=\"https://placehold.co/640x360.png?text=Video+Player+Placeholder\" alt=\"video thumbnail\" />\n        </div>\n    </>\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing NodeRef in Yew Component\nDESCRIPTION: This code snippet shows how to create a `NodeRef` instance within a Yew component's `create` method. `NodeRef::default()` is used to initialize an empty `NodeRef`. The `NodeRef` will be used to hold a reference to a DOM node.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/advanced-topics/struct-components/refs.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::Element;\nuse yew::{html, Component, Context, Html, NodeRef};\n\nstruct Comp {\n    node_ref: NodeRef,\n}\n\nimpl Component for Comp {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            // highlight-next-line\n            node_ref: NodeRef::default(),\n        }\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            // highlight-next-line\n            <div ref={self.node_ref.clone()}></div>\n        }\n    }\n\n    fn rendered(&mut self, _ctx: &Context<Self>, _first_render: bool) {\n        // highlight-start\n        let has_attributes = self.node_ref\n            .cast::<Element>()\n            .unwrap()\n            .has_attributes();\n        // highlight-end\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Working with Boolean Attributes in Yew\nDESCRIPTION: Demonstrates how to use boolean attributes in Yew templates. Boolean attributes need a boolean value and setting them to false is equivalent to omitting them entirely.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/elements.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <div hidden=true>\n        { \"This div is hidden.\" }\n    </div>\n};\n```\n\nLANGUAGE: html\nCODE:\n```\n<div hidden>This div is hidden.</div>\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet no = 1 + 1 != 2;\n\nhtml! {\n    <div hidden={no}>\n        { \"This div is NOT hidden.\" }\n    </div>\n};\n```\n\nLANGUAGE: html\nCODE:\n```\n<div>This div is NOT hidden.</div>\n```\n\n----------------------------------------\n\nTITLE: Changed Method Signature Update in Yew Components - Rust\nDESCRIPTION: This snippet shows the updated signature of the 'changed' method in Yew components, which now accepts an additional argument for old properties. This change aids in maintaining and comparing previous states of component properties.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/migration-guides/yew/from-0_19_0-to-0_20_0.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn changed(&mut self, ctx: &Context<Self>, old_props: &Self::Properties) -> bool\n```\n\n----------------------------------------\n\nTITLE: Basic Server-Side Rendering with Yew\nDESCRIPTION: Demonstrates how to create a ServerRenderer and render a simple Yew component on the server-side using Tokio runtime\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/advanced-topics/server-side-rendering.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew::ServerRenderer;\n\n#[function_component]\nfn App() -> Html {\n    html! {<div>{\"Hello, World!\"}</div>}\n}\n\n#[tokio::main(flavor = \"current_thread\")]\nasync fn no_main() {\n    let renderer = ServerRenderer::<App>::new();\n    let rendered = renderer.render().await;\n    println!(\"{}\", rendered);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml with Yew dependency\nDESCRIPTION: Cargo configuration file that defines the project metadata and adds Yew as a dependency. The configuration specifies the project name, version, edition, and includes the Yew framework dependency.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"yew-app\"\nversion = \"0.1.0\"\nedition = \"2018\"\n\n[dependencies]\n# you can check the latest version here: https://crates.io/crates/yew\nyew = \"0.18\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Release Builds in Cargo.toml\nDESCRIPTION: This snippet demonstrates how to optimize release builds in a Rust project's Cargo.toml file by defining settings that reduce binary size and increase optimization. It includes different optimization levels and configurations to improve build performance.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/advanced-topics/optimizations.mdx#2025-04-16_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n[profile.release]\n# less code to include into binary\npanic = 'abort'\n# optimization over all codebase ( better optimization, slower build )\ncodegen-units = 1\n# optimization for size ( more aggressive )\nopt-level = 'z'\n# optimization for size\n# opt-level = 's'\n# link time optimization using using whole-program analysis\nlto = true\n\n```\n\n----------------------------------------\n\nTITLE: Build and Serve with Trunk\nDESCRIPTION: This command builds and serves the Yew application using Trunk, which is a build tool for Rust-based web applications. It automatically rebuilds when source files are modified, streamlining development.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve\n```\n\n----------------------------------------\n\nTITLE: Installing Yew with Selected Web Library in Cargo Dependencies\nDESCRIPTION: Shows how to include Yew in your Cargo.toml file with either web-sys (default) or stdweb as the web binding library. The web-sys option uses the standard yew package, while stdweb requires specifying a different package name.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/choose-web-library.mdx#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n# Choose `web-sys`\nyew = \"0.17\"\n\n# Choose `stdweb`\nyew = { version = \"0.17\", package = \"yew-stdweb\" }\n```\n\n----------------------------------------\n\nTITLE: Adding Dependencies for API Requests in Cargo.toml\nDESCRIPTION: This Cargo.toml snippet shows the dependencies needed for making HTTP requests and handling JSON data in a Yew application. It includes gloo-net for fetching data, serde for JSON serialization, and wasm-bindgen-futures for handling asynchronous code.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_22\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ngloo-net = \"0.6\"\nserde = { version = \"1.0\", features = [\"derive\"] }\nwasm-bindgen-futures = \"0.4\"\n```\n\n----------------------------------------\n\nTITLE: Creating HTML Template for Yew Application\nDESCRIPTION: Provides a minimal HTML template for the Yew application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/tutorial/index.mdx#2025-04-16_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<!doctype html>\n<html lang=\"en\">\n    <head></head>\n    <body></body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Serving Yew application\nDESCRIPTION: The command builds and serves the application locally. The '--open' option automatically opens the application in the default browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n\"trunk serve --open\"\n```\n\n----------------------------------------\n\nTITLE: VS Code Emmet Configuration for Yew\nDESCRIPTION: JSON configuration to enable Emmet support for HTML in Rust files when using Yew\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/getting-started/editor-setup.mdx#2025-04-16_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n\"emmet.includeLanguages\": {\n    \"rust\": \"html\",\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Threaded Agent Import in Rust for Yew 0.2.0\nDESCRIPTION: This snippet demonstrates how to update the import statement for Threaded agents in Yew 0.2.0. The Threaded type has been replaced with PublicAgent.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/migration-guides/yew-agent/from-0_1_0-to-0_2_0.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew_agent::PublicAgent;\n```\n\n----------------------------------------\n\nTITLE: Creating Yew Component Snippet in VS Code\nDESCRIPTION: A JSON snippet for VS Code that helps in creating a boilerplate for Yew components. Add it to the User Snippets under the Rust language in VS Code to quickly scaffold a new component structure. It includes a component class, message enum, and a view method, tailored for Rust Yew components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/more/development-tips.mdx#2025-04-16_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"Create new Yew component\": {\n        \"prefix\": \"YOUR PREFIX OF CHOICE\",\n        \"body\": [\n            \"use yew::prelude::*;\",\n            \"\",\n            \"pub struct ${1};\",\n            \"\",\n            \"pub enum Msg {\",\n            \"}\",\n            \"\",\n            \"impl Component for ${1} {\",\n            \"    type Message = Msg;\",\n            \"    type Properties = ();\",\n            \"\",\n            \"    fn create(ctx: &Context<Self>) -> Self {\",\n            \"        Self\",\n            \"    }\",\n            \"\",\n            \"    fn view(&self, ctx: &Context<Self>) -> Html {\",\n            \"        html! {\",\n            \"            ${0}\",\n            \"        }\",\n            \"    }\",\n            \"}\"\n        ],\n        \"description\": \"Create a new Yew component without properties but with a message enum\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Dynamic Tag Names in HTML Templates (Rust)\nDESCRIPTION: Demonstrates how to use dynamic tag names in Yew's html! macro by wrapping an expression with @{..}.\nSOURCE: https://github.com/yewstack/yew/blob/master/CHANGELOG.md#2025-04-16_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nlet tag_name = \"input\";\nhtml! { <@{tag_name} value=\"Hello\" /> }\n```\n\n----------------------------------------\n\nTITLE: Building Yew Application in Release Mode\nDESCRIPTION: Command to build a Yew application for production deployment using Trunk build tool\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/more/deployment.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk build --release\n```\n\n----------------------------------------\n\nTITLE: Handling String-like Attributes in Yew\nDESCRIPTION: This example shows different ways to pass string-like values as attributes in Yew components. It demonstrates using str, String, and AttrValue types for the placeholder attribute.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.22/concepts/html/elements.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, virtual_dom::AttrValue};\n\nlet str_placeholder = \"I'm a str!\";\nlet string_placeholder = String::from(\"I'm a String!\");\nlet attrvalue_placeholder = AttrValue::from(\"I'm an AttrValue!\");\n\nhtml! {\n    <div>\n        <input placeholder={str_placeholder} />\n        <input placeholder={string_placeholder} />\n        <input placeholder={attrvalue_placeholder} />\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing the Update Method in Yew (Rust)\nDESCRIPTION: Code example showing how to implement the update lifecycle method to handle component messages and determine when re-rendering is needed.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.18.0/concepts/components/introduction.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub enum Msg {\n    SetInputEnabled(bool)\n}\n\nimpl Component for MyComponent {\n    type Message = Msg;\n\n    // ...\n\n    fn update(&mut self, msg: Self::Message) -> ShouldRender {\n       match msg {\n           Msg::SetInputEnabled(enabled) => {\n               if self.input_enabled != enabled {\n                   self.input_enabled = enabled;\n                   true // 重新渲染\n               } else {\n                   false\n               }\n           }\n       }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Threaded Agent Import in Rust for Yew 0.2.0\nDESCRIPTION: This code snippet shows how to update the import statement for Threaded agents in Yew 0.2.0. The Threaded type has been replaced with PublicAgent.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/migration-guides/yew-agent/from-0_1_0-to-0_2_0.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew_agent::PublicAgent;\n```\n\n----------------------------------------\n\nTITLE: Using TargetCast for Event Target Type Conversion\nDESCRIPTION: Demonstrates safe and unsafe methods of converting event targets to specific HTML element types using TargetCast methods in a Yew component\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/events.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::prelude::*;\n\n#[function_component]\nfn MyComponent() -> Html {\n    let input_value_handle = use_state(String::default);\n    let input_value = (*input_value_handle).clone();\n\n    let on_cautious_change = {\n        let input_value_handle = input_value_handle.clone();\n\n        Callback::from(move |e: Event| {\n            let input = e.target_dyn_into::<HtmlInputElement>();\n\n            if let Some(input) = input {\n                input_value_handle.set(input.value());\n            }\n        })\n    };\n\n    let on_dangerous_change = Callback::from(move |e: Event| {\n        input_value_handle.set(e.target_unchecked_into::<HtmlInputElement>().value());\n    });\n\n    html! {\n        <>\n            <label for=\"cautious-input\">\n                { \"My cautious input:\" }\n                <input onchange={on_cautious_change}\n                    id=\"cautious-input\"\n                    type=\"text\"\n                    value={input_value.clone()}\n                />\n            </label>\n            <label for=\"dangerous-input\">\n                { \"My dangerous input:\" }\n                <input onchange={on_dangerous_change}\n                    id=\"dangerous-input\"\n                    type=\"text\"\n                    value={input_value}\n                />\n            </label>\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building Yew Application for Release\nDESCRIPTION: Command to build a Yew application in release mode using Trunk. This generates optimized assets in the dist directory for deployment.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/more/deployment.mdx#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ntrunk build --release\n```\n\n----------------------------------------\n\nTITLE: Creating Yew Struct Component Template in Rust\nDESCRIPTION: This snippet defines a template for creating Yew struct components in Rust. It includes a component struct, message enum, and implementation of the Component trait.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/getting-started/editor-setup.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct $NAME$;\n\nenum $NAME$Msg {\n}\n\nimpl Component for $NAME$ {\n    type Message = $NAME$Msg;\n    type Properties = ();\n\n    fn create(ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            $HTML$\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a New Yew Project - Rust\nDESCRIPTION: This snippet creates a new Rust project for a Yew application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo new yew-app\ncd yew-app\n```\n\n----------------------------------------\n\nTITLE: Initializing NodeRef in Yew\nDESCRIPTION: This code snippet demonstrates how to initialize a `NodeRef` in a Yew component. The `NodeRef::default()` method creates an empty `NodeRef` that can later be attached to a DOM element.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/advanced-topics/struct-components/refs.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::Element;\nuse yew::{html, Component, Context, Html, NodeRef};\n\nstruct Comp {\n    node_ref: NodeRef,\n}\n\nimpl Component for Comp {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            // highlight-next-line\n            node_ref: NodeRef::default(),\n        }\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            // highlight-next-line\n            <div ref={self.node_ref.clone()}></div>\n        }\n    }\n\n    fn rendered(&mut self, _ctx: &Context<Self>, _first_render: bool) {\n        // highlight-start\n        let has_attributes = self.node_ref\n            .cast::<Element>()\n            .unwrap()\n            .has_attributes();\n        // highlight-end\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Trunk Server Settings\nDESCRIPTION: Optional Trunk configuration file that allows customizing the development server address and port for the Yew application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[serve]\n# The address to serve on LAN.\naddress = \"127.0.0.1\"\n# The address to serve on WAN.\n# address = \"0.0.0.0\"\n# The port to serve on.\nport = 8000\n```\n\n----------------------------------------\n\nTITLE: Yew Hook Usage Example Before Migration\nDESCRIPTION: An example of how Yew hooks were used before the 0.21.0 update. It demonstrates the need to extract dependencies in advance due to the callback being the first argument.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/migration-guides/yew/from-0_20_0-to-0_21_0.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nimpl SomeLargeStruct {\n    fn id(&self) -> u32; // Only need to use the id as cache key\n}\nlet some_dep: SomeLargeStruct = todo!();\n\n{\n    let id = some_dep.id(); // Have to extract it in advance, some_dep is moved already in the second argument\n    use_effect_with_dep(move |_| { todo!(); drop(some_dep); }, id);\n}\n```\n\n----------------------------------------\n\nTITLE: Adding WASM Target for Rust - Rust\nDESCRIPTION: This snippet adds the WASM build target to your Rust installation, necessary for compiling Yew applications.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nrustup target add wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Incorrect Switch Implementation Example in Rust\nDESCRIPTION: This snippet shows an incorrect implementation of the Switch trait where the order of routes can lead to unexpected behavior. The more general '/' route will match all requests, preventing other routes from being reached.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.18.0/concepts/router.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Switch)]\nenum AppRoute {\n  #[to=\"/\"]\n  Home,\n  #[to=\"/login\"]\n  Login,\n  #[to=\"/register\"]\n  Register,\n  #[to=\"/delete_account\"]\n  Delete,\n  #[to=\"/posts/{id}\"]\n  ViewPost(i32),\n  #[to=\"/posts/view\"]\n  ViewPosts,\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Yew Agents Import Path\nDESCRIPTION: Example showing the required import path change when migrating from embedded yew agents to the separate yew-agents crate.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/migration-guides/yew-agent/from-0_0_0-to-0_1_0.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Old import\nyew::*\n\n// New import\nyew_agents::*\n```\n\n----------------------------------------\n\nTITLE: Installing Rust Wasm Target Command\nDESCRIPTION: Command to add the WebAssembly target to the Rust toolchain using rustup. This is required to compile Rust code to WebAssembly for Yew applications.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustup target add wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Event Handling: `onpointermove` Event\nDESCRIPTION: This event handler is triggered when the pointer moves while it is over an element. It utilizes the `PointerEvent` struct from the `web-sys` crate to provide information about the pointer event.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/html/events.mdx#2025-04-16_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n\"onpointermove\"\n```\n\n----------------------------------------\n\nTITLE: Boolean Attributes in Yew\nDESCRIPTION: Demonstrates how to handle boolean attributes like hidden, checked, and required in Yew HTML rendering\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/elements.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nhtml! {\n    <div hidden=true>\n        { \"This div is hidden.\" }\n    </div>\n};\n\nlet no = 1 + 1 != 2;\n\nhtml! {\n    <div hidden={no}>\n        { \"This div is NOT hidden.\" }\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Updating Video struct to derive Deserialize (Yew/Rust)\nDESCRIPTION: This snippet updates the `Video` struct to derive the `Deserialize` trait from `serde`.  This allows the struct to be automatically populated from JSON data received from the API. The `Deserialize` trait is required for deserializing the JSON response into a `Vec<Video>`.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n+ use serde::Deserialize;\n\n- #[derive(Clone, PartialEq)]\n+ #[derive(Clone, PartialEq, Deserialize)]\nstruct Video {\n    id: usize,\n    title: String,\n    speaker: String,\n    url: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Rust Toolchain Version Command\nDESCRIPTION: Command to verify the active Rust toolchain version. Yew requires a minimum Rust version of 1.49.0 to function properly.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/introduction.mdx#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nrustup show\n```\n\n----------------------------------------\n\nTITLE: Configuring LSP for Yew in Neovim with LazyVim\nDESCRIPTION: This Lua snippet configures the Neovim LSP client to treat Rust files as HTML when working with Yew. It's specifically for use with the LazyVim configuration and lazy.vim plugin.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/getting-started/editor-setup.mdx#2025-04-16_snippet_4\n\nLANGUAGE: json\nCODE:\n```\nreturn {\n  {\n    \"neovim/nvim-lspconfig\",\n    init_options = {\n      userLanguages = {\n        eelixir = \"html-eex\",\n        eruby = \"erb\",\n        rust = \"html\",\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Video Struct for Data Representation\nDESCRIPTION: Creating a Rust struct to represent video data in the application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/tutorial/index.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nstruct Video {\n    id: usize,\n    title: String,\n    speaker: String,\n    url: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependencies in Cargo.toml for Yew Application\nDESCRIPTION: Specifies required dependencies for a Yew application including gloo-net for API calls, serde for JSON serialization, and wasm-bindgen-futures for async operations.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_14\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ngloo-net = \"0.6\"\nserde = { version = \"1.0\", features = [\"derive\"] }\nwasm-bindgen-futures = \"0.4\"\n```\n\n----------------------------------------\n\nTITLE: Iterator Rendering in Yew HTML Macro\nDESCRIPTION: Shows how to render iterators directly in the HTML macro without using the 'for' keyword\nSOURCE: https://github.com/yewstack/yew/blob/master/CHANGELOG.md#2025-04-16_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n// Before\nhtml! {{\n  for self.props.items.iter().map(renderItem)\n}}\n```\n\nLANGUAGE: rust\nCODE:\n```\n// After\nhtml! {{\n  self.props.items.iter().map(renderItem).collect::<Html<Self>>()\n}}\n```\n\n----------------------------------------\n\nTITLE: Implementing Translatable Headings with JSX\nDESCRIPTION: Example of how to wrap text in Translate tags for localization. This helps Docusaurus extract the text and compile it to JSON files for translation in GitLocalize.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/README.md#2025-04-16_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport Translate from '@docusaurus/Translate'\n\n<h2>\n    <Translate id=\"header.translation.id\" description=\"the heading description\">\n        This heading will be translated\n    </Translate>\n</h2>\n```\n\n----------------------------------------\n\nTITLE: Using Optional Attributes for HTML Elements in Yew\nDESCRIPTION: Shows how to use optional values (Some(x) or None) for most HTML attributes in Yew. This allows omitting the attribute when it's marked as optional.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/html/elements.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet maybe_id = Some(\"foobar\");\n\nhtml! {\n    <div id={maybe_id}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: NodeRef Usage with JsCast\nDESCRIPTION: Shows alternative approach using NodeRef with JsCast trait for type conversion.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::JsCast;\nuse web_sys::HtmlInputElement;\nuse yew::NodeRef;\n\nfn with_jscast(node_ref: NodeRef) {\n    if let Some(input) = node_ref\n        .get()\n        .and_then(|node| node.dyn_into::<HtmlInputElement>().ok()) {\n        // do something with HtmlInputElement\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Automatic Migration Script for 'changed' Method in Bash\nDESCRIPTION: This Bash script using Perl can automatically update the 'changed' method signature in Rust files to match the new 0.20.0 requirements.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/migration-guides/yew/from-0_19_0-to-0_20_0.mdx#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nperl -p -i -e  's/fn changed\\(&mut self, (\\w+): &Context<Self>\\)/fn changed(&mut self, $1: &Context<Self>, _old_props: &Self::Properties)/g' $(find . -name \\*.rs)\n```\n\n----------------------------------------\n\nTITLE: Creating HTML Template for Yew Application\nDESCRIPTION: Basic HTML template for the Yew application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/tutorial/index.mdx#2025-04-16_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<!doctype html>\n<html lang=\"en\">\n    <head></head>\n    <body></body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Dynamic HTML Tag Names in Yew\nDESCRIPTION: Shows how to dynamically generate HTML tag names using string interpolation and expressions\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/elements.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nlet level = 5;\nlet text = \"Hello World!\".to_owned();\n\nhtml! {\n    <@{format!(\"h{}\", level)} class=\"title\">{ text }</@>\n};\n```\n\n----------------------------------------\n\nTITLE: Using JsCast for type casting in Rust with web-sys\nDESCRIPTION: This example shows how to use the JsCast trait to perform type casting between different web-sys types. It demonstrates both checked (dyn_ref) and unchecked (unchecked_into) casting methods when handling event targets.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/basic-web-technologies/wasm-bindgen.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::JsCast;\nuse web_sys::{Event, EventTarget, HtmlInputElement, HtmlSelectElement};\n\nfn handle_event(event: Event) {\n    let target: EventTarget = event\n        .target()\n        .expect(\"I'm sure this event has a target!\");\n\n    if let Some(select_element) = target.dyn_ref::<HtmlSelectElement>() {\n        // do something amazing here\n        return;\n    }\n\n    let input_element: HtmlInputElement = target.unchecked_into();\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Minimal HTML Template\nDESCRIPTION: Basic HTML document structure needed as a template for the Yew application, which will be used by Trunk to inject the compiled WebAssembly code.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<!doctype html>\n<html lang=\"en\">\n    <head></head>\n    <body></body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Hook Structure in Rust for Yew\nDESCRIPTION: This code snippet shows the basic structure of a custom hook in Yew. It defines a use_event function that takes an event target, event type, and callback as parameters.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{Event, EventTarget};\nuse std::borrow::Cow;\nuse gloo::events::EventListener;\nuse yew::prelude::*;\n\n#[hook]\npub fn use_event<E, F>(target: &EventTarget, event_type: E, callback: F)\nwhere\n    E: Into<Cow<'static, str>>,\n    F: Fn(&Event) + 'static,\n{\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Bundling JavaScript modules with Rollup.js\nDESCRIPTION: This command uses Rollup.js to bundle the `main.js` file into a single JavaScript file named `bundle.js` located in the `./pkg` directory. The `--format iife` flag specifies that the output should be in the Immediately Invoked Function Expression (IIFE) format.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/getting-started/project-setup/using-wasm-pack.mdx#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nrollup ./main.js --format iife --file ./pkg/bundle.js\n```\n\n----------------------------------------\n\nTITLE: Yew Classes Macro Literal Example\nDESCRIPTION: This snippet demonstrates how to use the `classes!` macro with a string literal to create a `Classes` instance and apply it to a div element in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/html/classes.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n    <div class={classes!(\"container\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing wasm-logger in Rust\nDESCRIPTION: This snippet demonstrates how to initialize the `wasm-logger` crate to integrate with the Rust `log` crate. It sets up the logger with default configurations, enabling logging within the Wasm application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.21/more/debugging.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// setup\nfn main() {\n    wasm_logger::init(wasm_logger::Config::default());\n}\n\n```\n\n----------------------------------------\n\nTITLE: VS Code Emmet Configuration for Rust-Yew\nDESCRIPTION: JSON configuration to enable Emmet support for Rust files in VS Code when working with Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/getting-started/editor-setup.mdx#2025-04-16_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n\"emmet.includeLanguages\": {\n    \"rust\": \"html\",\n}\n```\n\n----------------------------------------\n\nTITLE: Component Implementation Before and After Yew 0.10 Changes\nDESCRIPTION: Comparison of component implementation before and after the breaking changes in Yew 0.10 where the Component trait now requires a view method instead of implementing the separate Renderable trait.\nSOURCE: https://github.com/yewstack/yew/blob/master/CHANGELOG.md#2025-04-16_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n// Before:\nimpl Component for MyComponent {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_: Self::Properties, _: ComponentLink<Self>) -> Self {\n        MyComponent {}\n    }\n\n    fn update(&mut self, msg: Self::Message) -> ShouldRender {\n        true\n    }\n}\n\nimpl Renderable<MyComponent> for MyComponent {\n    fn view(&self) -> Html<Self> {\n        html! { \"hello\" }\n    }\n}\n\n// After:\nimpl Component for MyComponent {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_: Self::Properties, _: ComponentLink<Self>) -> Self {\n        MyComponent {}\n    }\n\n    fn update(&mut self, msg: Self::Message) -> ShouldRender {\n        true\n    }\n\n    fn view(&self) -> Html<Self> {\n        html! { \"hello\" }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Component Properties in Rust with Yew\nDESCRIPTION: This example demonstrates how to define properties for Yew components using the #[derive(Properties)] macro. It shows required and optional fields, default values, and optimization with PartialEq. The example includes a custom enum with a default implementation and a properties struct with various field configurations.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.20/advanced-topics/struct-components/properties.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::rc::Rc;\nuse yew::Properties;\n\n#[derive(Clone, PartialEq)]\npub enum LinkColor {\n    Blue,\n    Red,\n    Green,\n    Black,\n    Purple,\n}\n\nimpl Default for LinkColor {\n    fn default() -> Self {\n        // 除非有指定，否則預設是藍色\n        LinkColor::Blue\n    }\n}\n\n#[derive(Properties, Clone, PartialEq)]\npub struct LinkProps {\n    /// 連結必須要有一個目標\n    href: String,\n    /// 如果連結文字很大，複製字串的參考可以減少記憶體的開銷\n    /// 但除非效能已經成為嚴重的問題，否則通常不建議這麼做\n    text: Rc<String>,\n    /// 連結的顏色\n    #[prop_or_default]\n    color: LinkColor,\n    /// 如果為 None，那 view 方法將不會指定 size\n    #[prop_or_default]\n    size: Option<u32>,\n    /// 當沒有指定 active，預設為 true\n    #[prop_or(true)]\n    active: bool,\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Trunk Server Settings\nDESCRIPTION: Creates a Trunk.toml file to customize the server address and port.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/tutorial/index.mdx#2025-04-16_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[serve]\naddress = \"127.0.0.1\"\nport = 8000\n```\n\n----------------------------------------\n\nTITLE: Configuring Trunk Server Settings\nDESCRIPTION: Creates a Trunk.toml configuration file to customize the serving behavior of Trunk, including the address and port for the development server.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\n[serve]\n# The address to serve on LAN.\naddress = \"127.0.0.1\"\n# The address to serve on WAN.\n# address = \"0.0.0.0\"\n# The port to serve on.\nport = 8000\n```\n\n----------------------------------------\n\nTITLE: Using Optional Class Names in Yew\nDESCRIPTION: Shows how to use an Option type for conditional class application using the classes! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(Some(\"class\"))} />\n};\n```\n\n----------------------------------------\n\nTITLE: Installing Trunk Build Tool\nDESCRIPTION: Command to install Trunk, the recommended tool for managing deployment and packaging of Yew applications. Installation may take time as it compiles from source.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/getting-started/introduction.mdx#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo install --locked trunk\n```\n\n----------------------------------------\n\nTITLE: Running Yew Application with Trunk Development Server\nDESCRIPTION: Command to serve and open the Yew application using the Trunk development server. This allows developers to run and view the Inner HTML example in their browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/inner_html/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for wasm-pack\nDESCRIPTION: This TOML snippet demonstrates how to configure the `Cargo.toml` file for a Yew application built with `wasm-pack`. It specifies the crate type as \"cdylib\", which is required for `wasm-pack`, and includes dependencies for Yew and wasm-bindgen.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/starter-templates.mdx#2025-04-16_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n\"[package]\\nname = \\\"yew-app\\\"\\nversion = \\\"0.1.0\\\"\\nauthors = [\\\"Yew App Developer <name@example.com>\\\"]\\nedition = \\\"2018\\\"\\n\\n[lib]\\n# You should include \\\"rlib\\\" (the default crate type) otherwise your crate can't be used as a Rust library\n# which, among other things, breaks unit testing\ncrate-type = [\\\"rlib\\\", \\\"cdylib\\\"]\\n\\n[dependencies]\\n# for web_sys\\nyew = \\\"0.17\\\"\\n# or for stdweb\\n# yew = { version = \\\"0.17\\\", package = \\\"yew-stdweb\\\" }\\nwasm-bindgen = \\\"0.2\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Updating Video Struct for Derive in Rust\nDESCRIPTION: Modifies the Video struct to derive Clone and PartialEq traits, which are necessary for its use in the VideosList component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/tutorial/index.mdx#2025-04-16_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Clone, PartialEq)]\nstruct Video {\n    id: usize,\n    title: String,\n    speaker: String,\n    url: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Using ConsoleService for Logging in Yew\nDESCRIPTION: This code snippet demonstrates how to use the `ConsoleService` in Yew to log information messages to the browser's console. The `ConsoleService` is part of the Yew framework and requires the `\"services\"` feature to be enabled. It logs a formatted string containing the value of `msg`.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.21/more/debugging.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// 使用\nConsoleService::info(format!(\"Update: {:?}\", msg).as_ref());\n\n```\n\n----------------------------------------\n\nTITLE: Simplified Custom Hook Implementation in Yew\nDESCRIPTION: This snippet presents a simpler implementation of the `use_subscribe` hook without using `use_hook`. It directly uses `use_state` and `use_effect` hooks, which is often preferred for simpler custom hooks.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.20/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn use_subscribe() -> Rc<Vec<String>> {\n    let (state, set_state) = use_state(Vec::new);\n\n    use_effect(move || {\n        let producer = EventBus::bridge(Callback::from(move |msg| {\n            let mut messages = (*state).clone();\n            messages.push(msg);\n            set_state(messages)\n        }));\n        || drop(producer)\n    });\n\n    state\n}\n```\n\n----------------------------------------\n\nTITLE: Running TodoMVC Yew Application with Trunk Server\nDESCRIPTION: Command to start the trunk development server and launch the TodoMVC application in the browser. The --open flag automatically opens the application in the default web browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/todomvc/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Implementing Optional Attributes for HTML Elements in Yew\nDESCRIPTION: Shows how to use Option<T> for HTML attributes in Yew. When the value is Some(x), the attribute is set; when it's None, the attribute is omitted from the DOM.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/html/elements.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet maybe_id = Some(\"foobar\");\n\nhtml! {\n    <div id={maybe_id}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Updating Html Return Type in Yew Components (Rust)\nDESCRIPTION: Demonstrates the removal of the generic type parameter from the Html return type in Yew component view methods.\nSOURCE: https://github.com/yewstack/yew/blob/master/CHANGELOG.md#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nimpl Component for MyComponent {\n    // ...\n\n    fn view(&self) -> Html {\n        html! { /* ... */ }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running the Initial Rust Project\nDESCRIPTION: This command compiles and runs the newly created Rust project, verifying the setup of the Rust environment. Expected output includes build information followed by 'Hello World'.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo run\n```\n\n----------------------------------------\n\nTITLE: Nested Components in Yew - Parent Component (Rust)\nDESCRIPTION: Shows how to create a parent component that contains child components in Yew. This example demonstrates passing children to a Container component.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.18.0/concepts/html/components.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n    <Container>\n        <h4>{ \"Hi\" }</h4>\n        <div>{ \"Hello\" }</div>\n    </Container>\n}\n```\n\n----------------------------------------\n\nTITLE: Router Implementation with Path Priority Warning Example\nDESCRIPTION: Example demonstrating incorrect route ordering where more specific routes are placed after generic ones, causing potential matching issues.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.20/concepts/router.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Switch)]\nenum AppRoute {\n  #[to=\"/\"]\n  Home,\n  #[to=\"/login\"]\n  Login,\n  #[to=\"/register\"]\n  Register,\n  #[to=\"/delete_account\"]\n  Delete,\n  #[to=\"/posts/{id}\"]\n  ViewPost(i32),\n  #[to=\"/posts/view\"]\n  ViewPosts,\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a New Yew Project\nDESCRIPTION: Commands to create a new Cargo project for a Yew application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/tutorial/index.mdx#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo new yew-app\ncd yew-app\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Library Types and Dependencies with Cargo\nDESCRIPTION: The code snippet provides a basic configuration for a project using Yew and wasm-bindgen. It specifies the package information, including name, version, and authors, and sets the types of libraries as 'rlib' and 'cdylib'. This configuration is necessary for projects that intend to compile to WebAssembly using wasm-pack. The dependencies on the 'yew' and 'wasm-bindgen' crates are declared with their respective versions. It requires Cargo and Rust programming environment to be set up.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/getting-started/starter-templates.mdx#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"yew-app\"\nversion = \"0.1.0\"\nauthors = [\"Yew App Developer <name@example.com>\"]\nedition = \"2018\"\n\n[lib]\n# You should include \"rlib\" (the default crate type) otherwise your crate can\\'t be used as a Rust library\n# which, among other things, breaks unit testing\ncrate-type = [\"rlib\", \"cdylib\"]\n\n[dependencies]\nyew = \"0.17\"\nwasm-bindgen = \"0.2\"\n```\n\n----------------------------------------\n\nTITLE: Adding External Dependencies in Cargo.toml\nDESCRIPTION: This snippet shows how to add external dependencies to the Cargo.toml file for fetching data from an external API in a Yew application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/tutorial/index.mdx#2025-04-16_snippet_13\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ngloo-net = \"0.2\"\nserde = { version = \"1.0\", features = [\"derive\"] }\nwasm-bindgen-futures = \"0.4\"\n```\n\n----------------------------------------\n\nTITLE: Using classes! Macro with Multiple Classes in Yew (Rust)\nDESCRIPTION: Shows how to use the classes! macro with multiple literal strings to set multiple classes on a div element in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/html/classes.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(\"class-1\", \"class-2\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Future Handling with ComponentLink\nDESCRIPTION: Shows how to use ComponentLink with futures and send messages asynchronously using wasm_bindgen\nSOURCE: https://github.com/yewstack/yew/blob/master/CHANGELOG.md#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::JsValue;\nuse wasm_bindgen_futures::future_to_promise;\n\n// future must implement `Future<Output = Component::Message> + 'static`\nlet link = self.link.clone();\nlet js_future = async move {\n    link.send_message(future.await);\n    Ok(JsValue::NULL)\n};\n\nfuture_to_promise(js_future);\n```\n\n----------------------------------------\n\nTITLE: Configuring Base URL for Relative Paths in Yew\nDESCRIPTION: HTML tag to set the base URL for relative paths in a Yew application. This is used when the app is not served from the root directory.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/more/deployment.mdx#2025-04-16_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<base data-trunk-public-url />\n```\n\n----------------------------------------\n\nTITLE: Adding yew-router dependency in Cargo.toml\nDESCRIPTION: This code snippet demonstrates how to add the yew-router crate as a dependency to your project's Cargo.toml file. This allows you to use the routing functionality provided by the crate in your Yew application.  It fetches the dependency directly from the git repository.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/router.mdx#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n\"yew-router = { git = \\\"https://github.com/yewstack/yew.git\\\" }\"\n```\n\n----------------------------------------\n\nTITLE: Video Data Structure Definition\nDESCRIPTION: Rust struct definition for video data model\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/tutorial/index.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nstruct Video {\n    id: usize,\n    title: String,\n    speaker: String,\n    url: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Trunk Development Server\nDESCRIPTION: Command to build and serve the Yew application using Trunk.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/tutorial/index.mdx#2025-04-16_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Navigating to Project Directory\nDESCRIPTION: After creating a new project, this step involves navigating into the project's directory with 'cd yew-app', allowing for further development and execution commands to be run from the project root.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd yew-app\n```\n\n----------------------------------------\n\nTITLE: Using Vector for Classes in Yew Components\nDESCRIPTION: Demonstrates how to use a vector of class names with the classes! macro in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/classes.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(vec![\"class-1\", \"class-2\"])}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Installing Trunk and wasm-bindgen-cli Bash Script\nDESCRIPTION: This Bash script installs the Trunk build tool along with the wasm-bindgen CLI. The command should be run in a terminal to set up the development environment for building Yew applications. Dependencies include Cargo, which is required for executing this installation.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/project-setup/using-trunk.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo install trunk wasm-bindgen-cli\n```\n\n----------------------------------------\n\nTITLE: Running the Web Worker Fibonacci Demo with Trunk Development Server\nDESCRIPTION: Command to run the web worker Fibonacci calculation demo using Trunk development server. The '--open' flag automatically opens the application in your default web browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/web_worker_fib/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Using html! Macro for Empty Rendering in Rust\nDESCRIPTION: Demonstrates how to use the html! macro without content, which is valid but renders nothing.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.18.0/concepts/html/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nhtml! {}\n```\n\n----------------------------------------\n\nTITLE: Updating Video Struct to Derive Deserialize in Yew\nDESCRIPTION: This code updates the `Video` struct to derive the `Deserialize` trait from the `serde` crate. This allows the struct to be automatically de-serialized from a JSON response.  Requires the `serde` crate with the `derive` feature to be enabled.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\nuse serde::Deserialize;\n\n#[derive(Clone, PartialEq, Deserialize)]\nstruct Video {\n    id: usize,\n    title: String,\n    speaker: String,\n    url: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Event Handling: `onpointerout` Event\nDESCRIPTION: This event handler is triggered when the pointer is moved out of the element. It uses the `PointerEvent` struct from the `web-sys` crate, providing details about the pointer leaving the element's boundaries.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/html/events.mdx#2025-04-16_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n\"onpointerout\"\n```\n\n----------------------------------------\n\nTITLE: HTML Macro: Invalid Self-Closing Tag in Yew (Compile Fail)\nDESCRIPTION: This snippet shows an incorrect way of writing a self-closing HTML element using the `html!` macro in Yew. It demonstrates what happens when the closing slash `/` is omitted, leading to a compilation error. The `use yew::prelude::*;` statement imports necessary Yew functionalities.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/html/introduction.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n  <input id=\"my_input\"> // <- 缺少閉合標籤\n};\n\n```\n\n----------------------------------------\n\nTITLE: Running the Futures Example with Trunk Development Server\nDESCRIPTION: Command to serve the Yew futures example application using the trunk development server. The --open flag automatically opens the application in a browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/futures/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Working with Logical Value Attributes in Yew\nDESCRIPTION: Demonstrates how to use logical value attributes like 'hidden', 'checked', or 'required' in Yew components. These attributes require boolean values and can be controlled with logical expressions.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/html/elements.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <div hidden=true>\n        { \"This div is hidden.\" }\n    </div>\n};\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet no = 1 + 1 != 2;\n\nhtml! {\n    <div hidden={no}>\n        { \"This div is NOT hidden.\" }\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Yew Component\nDESCRIPTION: This snippet demonstrates how to create a Yew component by implementing the `create` lifecycle method. The component initializes its state using properties passed from its parent.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Component, Context, html, Html, Properties};\n\n#[derive(PartialEq, Properties)]\npub struct Props;\n\npub struct MyComponent;\n\nimpl Component for MyComponent {\n    type Message = ();\n    type Properties = Props;\n\n    // highlight-start\n    fn create(ctx: &Context<Self>) -> Self {\n        MyComponent\n    }\n    // highlight-end\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            // impl\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Yew Package in Macro-Generated Code\nDESCRIPTION: To ensure correct referencing of the Yew package, macro-generated code uses `::yew::<module>` instead of directly using `yew::<module>`. This approach follows hygiene rules for proc macros.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/advanced-topics/how-it-works.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n::yew::<module>\n```\n\n----------------------------------------\n\nTITLE: Serving the Yew Application with Trunk\nDESCRIPTION: Uses the Trunk build tool to compile, bundle, and serve the Yew application locally for development purposes. Trunk will automatically rebuild the application when source files change.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve\n```\n\n----------------------------------------\n\nTITLE: Implementing the Update Method for Message Handling\nDESCRIPTION: Example of implementing the update method that handles component messages and determines if the component should re-render.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/components/introduction.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Component, ShouldRender};\n\npub enum Msg {\n    SetInputEnabled(bool)\n}\n\nimpl Component for MyComponent {\n    type Message = Msg;\n\n    // ...\n\n    fn update(&mut self, msg: Self::Message) -> ShouldRender {\n       match msg {\n           Msg::SetInputEnabled(enabled) => {\n               if self.input_enabled != enabled {\n                   self.input_enabled = enabled;\n                   true // Re-render\n               } else {\n                   false\n               }\n           }\n       }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Virtual DOM representation of Yew components\nDESCRIPTION: This snippet represents the virtual DOM structure that Yew builds from the defined components. It illustrates how the components are nested within each other and how the final HTML is rendered. This is a conceptual representation and not actual code to be executed.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/function-components/introduction.mdx#2025-04-16_snippet_1\n\nLANGUAGE: xhtml\nCODE:\n```\n<App>\n  <HelloWorld>\n    <p>\"Hello world\"</p>\n  </HelloWord>\n</App>\n```\n\n----------------------------------------\n\nTITLE: Create HTML Template\nDESCRIPTION: Basic HTML template for the Yew application\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_7\n\nLANGUAGE: html\nCODE:\n```\n<!doctype html>\n<html>\n    <head>\n        <meta charset=\"utf-8\" />\n        <title>Yew App</title>\n    </head>\n    <body></body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Required Properties with Derive Macro\nDESCRIPTION: Demonstrates defining required properties using the #[derive(Properties)] macro in Yew\nSOURCE: https://github.com/yewstack/yew/blob/master/CHANGELOG.md#2025-04-16_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::Properties;\n\n#[derive(Properties)]\npub struct Props {\n    #[props(required)]\n    pub value: MyStruct,\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(PartialEq, Properties)]\npub struct Props {\n    #[props(required)]\n    on_click: Callback<()>,\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Video Struct for Deserialization in Rust\nDESCRIPTION: This snippet updates the Video struct to derive the Deserialize trait, allowing it to be deserialized from JSON responses.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/tutorial/index.mdx#2025-04-16_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nuse serde::Deserialize;\n\n#[derive(Clone, PartialEq, Deserialize)]\nstruct Video {\n    id: usize,\n    title: String,\n    speaker: String,\n    url: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Building a WebAssembly application with wasm-pack\nDESCRIPTION: This command builds the Rust project into a WebAssembly module using `wasm-pack`. The `--target web` flag specifies that the build should be optimized for the web, generating a JavaScript wrapper in the `./pkg` directory.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/getting-started/project-setup/using-wasm-pack.mdx#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nwasm-pack build --target web\n```\n\n----------------------------------------\n\nTITLE: Using ConsoleService for logging\nDESCRIPTION: This snippet demonstrates how to use Yew's built-in `ConsoleService` to log messages to the browser's console. The `ConsoleService::info` function is called with a formatted string containing the `msg` variable's value.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.20/more/debugging.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// usage\nConsoleService::info(format!(\"Update: {:?}\", msg).as_ref());\n\n```\n\n----------------------------------------\n\nTITLE: Importing Snapshot Testing Module in Rust\nDESCRIPTION: This snippet demonstrates how to import the layout_tests module from Yew for snapshot testing of components. It's a basic setup for enabling snapshot tests in a Yew application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/more/testing.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nyew::tests::layout_tests\n```\n\n----------------------------------------\n\nTITLE: Updating Rust Toolchain Command\nDESCRIPTION: Command to update the Rust toolchain to the latest version. This ensures compatibility with Yew's minimum supported Rust version requirements.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/introduction.mdx#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nrustup update\n```\n\n----------------------------------------\n\nTITLE: Cargo Dependencies for Yew Mouse Event Example\nDESCRIPTION: Cargo.toml configuration showing the required web-sys features for mouse event handling within a Yew application, focusing on the minimal required features.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies.web-sys]\nversion = \"0.3\"\n# We need to enable the `DomRect` feature to use the\n# `get_bounding_client_rect` method.\nfeatures = [\n    \"console\",\n    \"HtmlElement\",\n    \"MouseEvent\",\n    \"DomRect\",\n]\n\n```\n\n----------------------------------------\n\nTITLE: Installing Yew Router Dependency in Cargo.toml\nDESCRIPTION: Adds the yew-router dependency to a Yew project. Currently points to the GitHub repository version until a new release is published.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/router.mdx#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\nyew-router = { git = \"https://github.com/yewstack/yew.git\" }\n```\n\n----------------------------------------\n\nTITLE: Rust web-sys Implementation of Mouse Move Handler\nDESCRIPTION: Refactored version of the JavaScript mouse move handler using web-sys in Rust. Includes necessary Cargo.toml dependencies.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nwasm-bindgen = \"0.2\"\n\n[dependencies.web-sys]\nversion = \"0.3\"\nfeatures = [\n    \"console\",\n    \"Document\",\n    \"HtmlElement\",\n    \"MouseEvent\",\n    \"DomRect\",\n]\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::{prelude::Closure, JsCast};\nuse web_sys::{console, Document, HtmlElement, MouseEvent};\n\nlet mousemove = Closure::<dyn Fn(MouseEvent)>::wrap(Box::new(|e| {\n    let rect = e\n        .target()\n        .expect(\"mouse event doesn't have a target\")\n        .dyn_into::<HtmlElement>()\n        .expect(\"event target should be of type HtmlElement\")\n        .get_bounding_client_rect();\n    let x = (e.client_x() as f64) - rect.left();\n    let y = (e.client_y() as f64) - rect.top();\n    console::log_1(&format!(\"Left? : {} ; Top? : {}\", x, y).into());\n}));\n\nDocument::new()\n    .expect(\"global document not set\")\n    .get_element_by_id(\"mousemoveme\")\n    .expect(\"element with id `mousemoveme` not present\")\n    .unchecked_into::<HtmlElement>()\n    .set_onmousemove(mousemove.as_ref().dyn_ref());\n```\n\n----------------------------------------\n\nTITLE: HTML Macro: Setting HTML Attributes in Yew\nDESCRIPTION: This snippet demonstrates how to set HTML attributes dynamically using the `html!` macro in Yew. The value of the attribute is assigned from a Rust variable. The `use yew::prelude::*;` statement imports necessary Yew functionalities.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/html/introduction.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet value = \"something\";\nhtml! { <div attribute={value} /> };\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Trunk Server Settings\nDESCRIPTION: Trunk configuration file for customizing server address and port settings\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[serve]\n# The address to serve on LAN.\naddress = \"127.0.0.1\"\n# The address to serve on WAN.\n# address = \"0.0.0.0\"\n# The port to serve on.\nport = 8000\n```\n\n----------------------------------------\n\nTITLE: Running Yew Application with Trunk Development Server\nDESCRIPTION: This command starts the trunk development server and opens the application in the default web browser. It's used to run and test the Yew application locally during development.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/communication_child_to_parent/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Explicit Trait Implementation Reference\nDESCRIPTION: Example showing how the html! macro explicitly specifies trait implementations using the fully qualified syntax to avoid method name collisions.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/how-it-works.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n<Type as Trait>\n```\n\n----------------------------------------\n\nTITLE: Defining Project Dependencies in Cargo.toml - TOML\nDESCRIPTION: This snippet updates the Cargo.toml file to include Yew as a dependency, enabling client-side rendering.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"yew-app\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nyew = { git = \"https://github.com/yewstack/yew/\", features = [\"csr\"] }\n```\n\n----------------------------------------\n\nTITLE: Automated Refactoring Commands for Yew 0.21.0 Migration (Bash)\nDESCRIPTION: These bash commands use the ast-grep tool to automatically refactor Rust code for the Yew 0.21.0 migration. They update the syntax of various hook functions, including use_effect_with, use_callback, use_memo, and others.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/migration-guides/yew/from-0_20_0-to-0_21_0.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsg --pattern 'use_effect_with_deps($CALLBACK,$$$DEPENDENCIES)' --rewrite 'use_effect_with($$$DEPENDENCIES, $CALLBACK)' -l rs -i\nsg --pattern 'use_effect_with($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_effect_with($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n\nsg --pattern 'use_callback($CALLBACK,$$$DEPENDENCIES)' --rewrite 'use_callback($$$DEPENDENCIES, $CALLBACK)' -l rs -i\nsg --pattern 'use_callback($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_callback($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n\nsg --pattern 'use_memo($CALLBACK,$$$DEPENDENCIES)' --rewrite 'use_memo($$$DEPENDENCIES, $CALLBACK)' -l rs -i\nsg --pattern 'use_memo($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_memo($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n\nsg --pattern 'use_future_with_deps($CALLBACK,$$$DEPENDENCIES)' --rewrite 'use_effect_with($$$DEPENDENCIES, $CALLBACK)' -l rs -i\nsg --pattern 'use_future_with($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_effect_with($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n\nsg --pattern 'use_transitive_state!($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_transitive_state!($DEPENDENCIES,$$$CALLBACK)' -l rs -i\nsg --pattern 'use_transitive_state!($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_transitive_state!($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n\nsg --pattern 'use_prepared_state!($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_prepared_state!($DEPENDENCIES,$$$CALLBACK)' -l rs -i\nsg --pattern 'use_prepared_state!($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_prepared_state!($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n```\n\n----------------------------------------\n\nTITLE: Mouse Position Tracking with Yew Cargo Dependencies\nDESCRIPTION: Cargo.toml configuration for the Yew implementation of mouse position tracking. Enables only the specific web-sys features needed for the Yew example, demonstrating how to minimize dependencies.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/wasm-bindgen/web-sys.mdx#2025-04-16_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nwasm-bindgen = \"0.2\"\n\n[dependencies.web-sys]\nversion = \"0.3\"\n# We need to enable the `DomRect` feature in order to use the\n# `get_bounding_client_rect` method.\nfeatures = [\n    \"console\",\n    \"HtmlElement\",\n    \"MouseEvent\",\n    \"DomRect\",\n]\n```\n\n----------------------------------------\n\nTITLE: Running Yew Counter Example with Trunk Development Server\nDESCRIPTION: Command to serve the counter application locally using the Trunk development server. The --open flag automatically opens the application in the default web browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/counter/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Boolean Attributes in Yew (Rust)\nDESCRIPTION: Demonstrates how to use boolean attributes in Yew, which need to be set to a bool value.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/elements.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <div hidden=true>\n        { \"This div is hidden.\" }\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Release Profile in Cargo.toml for Optimization\nDESCRIPTION: This snippet demonstrates how to configure the release profile settings in Cargo.toml to reduce the binary size of Rust applications. It includes settings for panic behavior, optimization levels, and link-time optimizations.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/optimizations.mdx#2025-04-16_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n[profile.release]\n# less code to include into binary\npanic = 'abort'\n# optimization over all codebase ( better optimization, slower build )\ncodegen-units = 1\n# optimization for size ( more aggressive )\nopt-level = 'z'\n# optimization for size\n# opt-level = 's'\n# link time optimization using using whole-program analysis\nlto = true\n```\n\n----------------------------------------\n\nTITLE: Optimizing Wasm Code with wasm-opt\nDESCRIPTION: This code snippet provides an example of using wasm-opt to optimize WebAssembly binaries generated from Rust code. It includes the command to optimize the wasm file for size, ensuring smaller and more efficient WebAssembly output.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/advanced-topics/optimizations.mdx#2025-04-16_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\nwasm-opt wasm_bg.wasm -Os -o wasm_bg_opt.wasm\n\n```\n\n----------------------------------------\n\nTITLE: Vector Initialization with Full Path\nDESCRIPTION: Example of how the macro uses fully qualified paths for standard library types to ensure correct resolution.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/how-it-works.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n::alloc::vec::Vec::new()\n```\n\n----------------------------------------\n\nTITLE: Disabling Event Bubbling in Yew Application\nDESCRIPTION: Method to disable event bubbling before starting the Yew application, which can improve event handling performance but may disrupt some component behaviors\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/events.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nyew::set_event_bubbling(false);\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Tag Names in Yew\nDESCRIPTION: Shows how to use dynamic tag names in Yew components using the @{name} syntax. This is useful for higher-order components where the tag name depends on a property or condition.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/html/elements.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet level = 5;\nlet text = \"Hello World!\".to_owned();\n\nhtml! {\n    <@{format!(\"h{}\", level)} class=\"title\">{ text }</@>\n};\n```\n\n----------------------------------------\n\nTITLE: Event Handling: `onselectionchange` Event\nDESCRIPTION: This event handler is triggered when the selection in a document changes. It utilizes the generic `Event` struct from the `web-sys` crate, signaling that the selected portion of the document has been altered.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/html/events.mdx#2025-04-16_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\n\"onselectionchange\"\n```\n\n----------------------------------------\n\nTITLE: Automated Hook Refactoring Commands using ast-grep\nDESCRIPTION: A set of bash commands that use ast-grep to automatically refactor Yew hooks to match the new API pattern where dependencies are passed as the first argument instead of the second. This covers use_effect_with, use_callback, use_memo, use_future_with, and other hooks.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/migration-guides/yew/from-0_20_0-to-0_21_0.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsg --pattern 'use_effect_with_deps($CALLBACK,$$$DEPENDENCIES)' --rewrite 'use_effect_with($$$DEPENDENCIES, $CALLBACK)' -l rs -i\nsg --pattern 'use_effect_with($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_effect_with($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n\nsg --pattern 'use_callback($CALLBACK,$$$DEPENDENCIES)' --rewrite 'use_callback($$$DEPENDENCIES, $CALLBACK)' -l rs -i\nsg --pattern 'use_callback($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_callback($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n\nsg --pattern 'use_memo($CALLBACK,$$$DEPENDENCIES)' --rewrite 'use_memo($$$DEPENDENCIES, $CALLBACK)' -l rs -i\nsg --pattern 'use_memo($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_memo($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n\nsg --pattern 'use_future_with_deps($CALLBACK,$$$DEPENDENCIES)' --rewrite 'use_future_with($$$DEPENDENCIES, $CALLBACK)' -l rs -i\nsg --pattern 'use_future_with($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_future_with($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n\nsg --pattern 'use_transitive_state!($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_transitive_state!($DEPENDENCIES,$$$CALLBACK)' -l rs -i\nsg --pattern 'use_transitive_state!($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_transitive_state!($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n\nsg --pattern 'use_prepared_state!($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_prepared_state!($DEPENDENCIES,$$$CALLBACK)' -l rs -i\nsg --pattern 'use_prepared_state!($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_prepared_state!($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n```\n\n----------------------------------------\n\nTITLE: Running the Initial Rust Project\nDESCRIPTION: Executes the default 'Hello World!' Rust program to verify the Rust environment is correctly set up.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncargo run\n# output: Hello World!\n```\n\n----------------------------------------\n\nTITLE: Rendering Child Components in Yew HTML Macro\nDESCRIPTION: Demonstrates how to render child components with the Yew HTML macro, including passing children and defining component properties\nSOURCE: https://github.com/yewstack/yew/blob/master/CHANGELOG.md#2025-04-16_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n  <MyList name=\"Grocery List\">\n    <MyListItem text=\"Apples\" />\n  </MyList>\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\npub struct MyList(Props);\n\n#[derive(Properties)]\npub struct Props {\n    #[props(required)]\n    pub name: String,\n    pub children: Children<MyListItem>,\n}\n\nimpl Renderable<MyList> for MyList {\n  fn view(&self) -> Html<Self> {\n    html! {{\n      self.props.children.iter().collect::<Html<Self>>()\n    }}\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Yew Hook Usage Example After Migration\nDESCRIPTION: An example of how the use_effect_with hook is used after the migration. It shows the more ergonomic usage where dependencies are passed as the first argument, eliminating the need for separate extraction.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/migration-guides/yew/from-0_20_0-to-next.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nimpl SomeLargeStruct {\n    fn id(&self) -> u32; // Only need to use the id as cache key\n}\nlet some_dep: SomeLargeStruct = todo!();\n\nuse_effect_with(some_dep.id(), move |_| { todo!(); drop(some_dep); });\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested Routing in Yew with yew-router\nDESCRIPTION: This code snippet demonstrates how to implement nested routing in a Yew application using yew-router. It defines main and settings routes, implements switch functions for both routers, and sets up the main App component with BrowserRouter.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/router.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew_router::prelude::*;\nuse gloo::utils::window;\nuse wasm_bindgen::UnwrapThrowExt;\n\n#[derive(Clone, Routable, PartialEq)]\nenum MainRoute {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/news\")]\n    News,\n    #[at(\"/contact\")]\n    Contact,\n    #[at(\"/settings\")]\n    SettingsRoot,\n    #[at(\"/settings/*\")]\n    Settings,\n    #[not_found]\n    #[at(\"/404\")]\n    NotFound,\n}\n\n#[derive(Clone, Routable, PartialEq)]\nenum SettingsRoute {\n    #[at(\"/settings\")]\n    Profile,\n    #[at(\"/settings/friends\")]\n    Friends,\n    #[at(\"/settings/theme\")]\n    Theme,\n    #[not_found]\n    #[at(\"/settings/404\")]\n    NotFound,\n}\n\nfn switch_main(route: MainRoute) -> Html {\n    match route {\n        MainRoute::Home => html! {<h1>{\"Home\"}</h1>},\n        MainRoute::News => html! {<h1>{\"News\"}</h1>},\n        MainRoute::Contact => html! {<h1>{\"Contact\"}</h1>},\n        MainRoute::SettingsRoot | MainRoute::Settings => html! { <Switch<SettingsRoute> render={switch_settings} /> },\n        MainRoute::NotFound => html! {<h1>{\"Not Found\"}</h1>},\n    }\n}\n\nfn switch_settings(route: SettingsRoute) -> Html {\n    match route {\n        SettingsRoute::Profile => html! {<h1>{\"Profile\"}</h1>},\n        SettingsRoute::Friends => html! {<h1>{\"Friends\"}</h1>},\n        SettingsRoute::Theme => html! {<h1>{\"Theme\"}</h1>},\n        SettingsRoute::NotFound => html! {<Redirect<MainRoute> to={MainRoute::NotFound}/>}\n    }\n}\n\n#[function_component(App)]\npub fn app() -> Html {\n    html! {\n        <BrowserRouter>\n            <Switch<MainRoute> render={switch_main} />\n        </BrowserRouter>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing wasm-pack using Cargo\nDESCRIPTION: This command installs `wasm-pack` from crates.io using Cargo, Rust's package manager.  `wasm-pack` is a tool for building, testing, and publishing Rust-generated WebAssembly.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/getting-started/project-setup/using-wasm-pack.mdx#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo install wasm-pack\n```\n\n----------------------------------------\n\nTITLE: Incorrect Route Order Example in Rust\nDESCRIPTION: This code snippet illustrates an incorrect order of route definitions that can lead to matching issues. It demonstrates how the order of routes in the Switch implementation affects matching, with more general routes potentially overshadowing more specific ones.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.21/concepts/router.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Switch)]\nenum AppRoute {\n  #[to=\"/\"]\n  Home,\n  #[to=\"/login\"]\n  Login,\n  #[to=\"/register\"]\n  Register,\n  #[to=\"/delete_account\"]\n  Delete,\n  #[to=\"/posts/{id}\"]\n  ViewPost(i32),\n  #[to=\"/posts/view\"]\n  ViewPosts,\n}\n```\n\n----------------------------------------\n\nTITLE: Enable HTML IntelliSense for Yew in VS Code\nDESCRIPTION: This configuration snippet enables HTML IntelliSense for the Rust language in VS Code, enhancing the development experience by allowing default HTML features in Yew applications. It requires adding the snippet to the VS Code settings.json file under emmet.includeLanguages.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/more/development-tips.mdx#2025-04-16_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n\"emmet.includeLanguages\": {\n    \"rust\": \"html\",\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Infinite Loops in Yew Lifecycle Methods\nDESCRIPTION: This snippet demonstrates a common pitfall where infinite loops can occur in Yew's lifecycle methods, specifically during continuous updates that trigger re-renders.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Context, Component, Html};\n\nstruct Comp;\n\nimpl Component for Comp {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn update(&mut self, _ctx: &Context<Self>, _msg: Self::Message) -> bool {\n        // We are going to always request to re-render on any msg\n        true\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        // For this example it doesn't matter what is rendered\n        Html::default()\n    }\n\n    fn rendered(&mut self, ctx: &Context<Self>, _first_render: bool) {\n        // Request that the component is updated with this new msg\n        ctx.link().send_message(());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding WebAssembly target to Rust toolchain\nDESCRIPTION: Command to add the WebAssembly compilation target to the Rust toolchain using Rustup, which is necessary for compiling Rust code to WebAssembly.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nrustup target add wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Running a Yew WebGL application with Trunk development server\nDESCRIPTION: Command to start the Trunk development server for the WebGL example. This launches the application and automatically opens it in a browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/webgl/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Bash Script for Refactoring Changed Method Signatures - Bash\nDESCRIPTION: This bash script can be used to automatically refactor the signatures of the 'changed' method in Rust source files to comply with the new requirements in Yew. Make sure to save your code before running this script, as it performs inline modifications.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/migration-guides/yew/from-0_19_0-to-0_20_0.mdx#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nperl -p -i -e 's/fn changed\\(&mut self, (\\w+): &Context<Self>\\)/fn changed(&mut self, $1: &Context<Self>, _old_props: &Self::Properties)/g' $(find . -name \\*.rs)\n```\n\n----------------------------------------\n\nTITLE: Creating Yew Struct Component Template in Rust\nDESCRIPTION: Template for generating a new Yew struct component with message enum and Component trait implementation\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/getting-started/editor-setup.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct $NAME$;\n\nenum $NAME$Msg {\n}\n\nimpl Component for $NAME$ {\n    type Message = $NAME$Msg;\n    type Properties = ();\n\n    fn create(ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            $HTML$\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing Cargo Release Profile Configuration\nDESCRIPTION: Configuration settings for cargo.toml to optimize release builds for smaller binary size. Includes settings for panic handling, code generation, optimization levels, and link-time optimization.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/advanced-topics/optimizations.mdx#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[profile.release]\n# less code to include into binary\npanic = 'abort'\n# optimization over all codebase ( better optimization, slower build )\ncodegen-units = 1\n# optimization for size ( more aggressive )\nopt-level = 'z'\n# optimization for size\n# opt-level = 's'\n# link time optimization using using whole-program analysis\nlto = true\n```\n\n----------------------------------------\n\nTITLE: Event Handling: `onpointerover` Event\nDESCRIPTION: This event handler is triggered when the pointer is moved onto an element. It relies on the `PointerEvent` struct from the `web-sys` crate to supply information about the pointer as it enters the element's boundaries.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/html/events.mdx#2025-04-16_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n\"onpointerover\"\n```\n\n----------------------------------------\n\nTITLE: Event Handling: `ontransitionstart` Event\nDESCRIPTION: This event handler is triggered when a CSS transition has actually started, after any delay has occurred. It employs the `TransitionEvent` struct from the `web-sys` crate to signal the definitive start of the transition.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/html/events.mdx#2025-04-16_snippet_14\n\nLANGUAGE: Rust\nCODE:\n```\n\"ontransitionstart\"\n```\n\n----------------------------------------\n\nTITLE: Yew Hook Usage Example: Before Migration (Rust)\nDESCRIPTION: This Rust code snippet demonstrates the usage of the 'use_effect_with_dep' hook in Yew 0.20.0. It shows how dependencies had to be extracted in advance and passed as separate arguments.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/migration-guides/yew/from-0_20_0-to-0_21_0.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nimpl SomeLargeStruct {\n    fn id(&self) -> u32; // Only need to use the id as cache key\n}\nlet some_dep: SomeLargeStruct = todo!();\n\n{\n    let id = some_dep.id(); // Have to extract it in advance, some_dep is moved already in the second argument\n    use_effect_with_dep(move |_| { todo!(); drop(some_dep); }, id);\n}\n```\n\n----------------------------------------\n\nTITLE: Updating App Component to Use VideosList in Rust\nDESCRIPTION: This code updates the App component to use the newly created VideosList component, demonstrating how to compose components in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/tutorial/index.mdx#2025-04-16_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n#[function_component(App)]\nfn app() -> Html {\n    // ...\n    html! {\n        <>\n            <h1>{ \"RustConf Explorer\" }</h1>\n            <div>\n                <h3>{\"Videos to watch\"}</h3>\n                <VideosList videos={videos} />\n            </div>\n            // ...\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ConsoleService for Console Logging in Yew\nDESCRIPTION: This snippet shows how to use the ConsoleService provided by Yew for console logging. This service is available when the \"services\" feature is enabled in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.18.0/more/debugging.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// usage\nConsoleService::info(format!(\"Update: {:?}\", msg).as_ref());\n```\n\n----------------------------------------\n\nTITLE: If-Let Pattern Matching in Yew\nDESCRIPTION: Demonstrates conditional rendering using if-let pattern matching for Option types in Yew's html! macro\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/conditional-rendering.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nlet some_text = Some(\"text\");\n\nhtml! {\n    if let Some(text) = some_text {\n        <p>{ text }</p>\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid Root Elements in Yew's html! Macro\nDESCRIPTION: Shows an invalid example that fails to compile because multiple root elements are defined without being wrapped in a fragment. The Yew html! macro requires a single root element or a fragment.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/fragments.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n// error: only one root html element allowed\n\nhtml! {\n    <div></div>\n    <p></p>\n};\n```\n\n----------------------------------------\n\nTITLE: Yew Event Handler Type Mappings Table\nDESCRIPTION: Markdown table showing the mapping between Yew event handler names and their corresponding web-sys event types. Includes handlers for pointer events, touch events, selection events, and transition events with links to their web-sys documentation.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.21/concepts/html/elements.mdx#2025-04-16_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| `onpointerlockchange`       | [Event](https://docs.rs/web-sys/latest/web_sys/struct.Event.html)                     |\n| `onpointerlockerror`        | [Event](https://docs.rs/web-sys/latest/web_sys/struct.Event.html)                     |\n| `onpointermove`             | [PointerEvent](https://docs.rs/web-sys/latest/web_sys/struct.PointerEvent.html)       |\n| `onpointerout`              | [PointerEvent](https://docs.rs/web-sys/latest/web_sys/struct.PointerEvent.html)       |\n| `onpointerover`             | [PointerEvent](https://docs.rs/web-sys/latest/web_sys/struct.PointerEvent.html)       |\n| `onpointerup`               | [PointerEvent](https://docs.rs/web-sys/latest/web_sys/struct.PointerEvent.html)       |\n| `onselectionchange`         | [Event](https://docs.rs/web-sys/latest/web_sys/struct.Event.html)                     |\n| `onselectstart`             | [Event](https://docs.rs/web-sys/latest/web_sys/struct.Event.html)                     |\n| `onshow`                    | [Event](https://docs.rs/web-sys/latest/web_sys/struct.Event.html)                     |\n| `ontouchcancel`             | [TouchEvent](https://docs.rs/web-sys/latest/web_sys/struct.TouchEvent.html)           |\n| `ontouchend`                | [TouchEvent](https://docs.rs/web-sys/latest/web_sys/struct.TouchEvent.html)           |\n| `ontouchmove`               | [TouchEvent](https://docs.rs/web-sys/latest/web_sys/struct.TouchEvent.html)           |\n| `ontouchstart`              | [TouchEvent](https://docs.rs/web-sys/latest/web_sys/struct.TouchEvent.html)           |\n| `ontransitioncancel`        | [TransitionEvent](https://docs.rs/web-sys/latest/web_sys/struct.TransitionEvent.html) |\n| `ontransitionend`           | [TransitionEvent](https://docs.rs/web-sys/latest/web_sys/struct.TransitionEvent.html) |\n| `ontransitionrun`           | [TransitionEvent](https://docs.rs/web-sys/latest/web_sys/struct.TransitionEvent.html) |\n| `ontransitionstart`         | [TransitionEvent](https://docs.rs/web-sys/latest/web_sys/struct.TransitionEvent.html) |\n```\n\n----------------------------------------\n\nTITLE: Using wasm-logger to Log Information in Rust\nDESCRIPTION: This code snippet shows how to use the `log` crate to log information messages in a Rust Wasm application. It relies on the `wasm-logger` crate being initialized to redirect the log messages to the browser's console. The `info!` macro logs a formatted string containing the value of `msg`.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.21/more/debugging.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// 使用\nlog::info!(\"Update: {:?}\", msg);\n\n```\n\n----------------------------------------\n\nTITLE: Using Dynamic Tag Names in Yew\nDESCRIPTION: This example shows how to use dynamic tag names in Yew using the @{name} syntax. It creates a heading element with a dynamic level based on a variable.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.22/concepts/html/elements.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet level = 5;\nlet text = \"Hello World!\".to_owned();\n\nhtml! {\n    <@{format!(\"h{}\", level)} class=\"title\">{ text }</@>\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing Yew Renderer with Client-Side Rendering\nDESCRIPTION: Example of using the new Yew::Renderer API for client-side rendering of an App component. Requires the 'csr' feature to be enabled.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/migration-guides/yew/from-0_19_0-to-0_20_0.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nyew::Renderer::<App>::new().render();\n```\n\n----------------------------------------\n\nTITLE: Start Trunk Development Server\nDESCRIPTION: Launches the development server for the Yew application\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ntrunk serve\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Event Hook Function Signature in Yew\nDESCRIPTION: The initial definition of a custom hook for event handling in Yew, showing the function signature with appropriate parameter types and constraints. This demonstrates the structure of a custom hook before implementation.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{Event, EventTarget};\nuse std::borrow::Cow;\nuse gloo::events::EventListener;\nuse yew::prelude::*;\n\n#[hook]\npub fn use_event<E, F>(target: &EventTarget, event_type: E, callback: F)\nwhere\n    E: Into<Cow<'static, str>>,\n    F: Fn(&Event) + 'static,\n{\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Self-closing HTML Tags in Yew\nDESCRIPTION: Shows how to use self-closing tags for elements like input in Yew's html! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/introduction.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n  <input id=\"my_input\" />\n};\n```\n\n----------------------------------------\n\nTITLE: Running Yew Application with Trunk Development Server\nDESCRIPTION: Command to serve and open the Yew application using the trunk development server. This allows developers to run and view the grandparent-to-grandchild communication example in a browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/communication_grandparent_to_grandchild/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Using Fragments for Multiple Root Elements in Yew\nDESCRIPTION: Shows how to use empty fragment tags (<></>) to wrap multiple elements when working with Yew's html! macro, which otherwise requires a single root node.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/lists.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nhtml! {\n    <>\n        <div></div>\n        <p></p>\n    </>\n}\n```\n\n----------------------------------------\n\nTITLE: Running Trunk with Proxy Backend for CORS\nDESCRIPTION: This command runs the Trunk development server with a proxy backend configured to `https://yew.rs/tutorial`. This allows the application to bypass CORS restrictions when fetching data from the external API.  The proxy forwards requests from the application to the specified backend.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --proxy-backend=https://yew.rs/tutorial\n```\n\n----------------------------------------\n\nTITLE: Invalid HTML Self-Closing Tag Example in Yew\nDESCRIPTION: This code snippet illustrates an invalid self-closing HTML structure within the `html!` macro. The `input` element is missing the closing `/>` tag, resulting in a compilation error. This example requires the `yew` crate to be included.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/introduction.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n  <input id=\"my_input\"> // <- 缺少闭合标签\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using NodeRef::get with JsCast in Yew\nDESCRIPTION: This snippet shows an alternative approach to converting a NodeRef to a specific HTML element type using NodeRef::get and JsCast.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::JsCast;\nuse web_sys::HtmlInputElement;\nuse yew::NodeRef;\n\nfn with_jscast(node_ref: NodeRef) {\n    if let Some(input) = node_ref\n        .get()\n        .and_then(|node| node.dyn_into::<HtmlInputElement>().ok()) {\n        // Handle HtmlInputElement here\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building Hydration Bundle with Trunk\nDESCRIPTION: Command to build the hydration bundle using Trunk bundler. This generates the necessary client-side assets in the dist directory.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/simple_ssr/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ntrunk build index.html\n```\n\n----------------------------------------\n\nTITLE: Running Yew Application with Trunk Development Server\nDESCRIPTION: Command to serve and automatically open the web worker prime example using the Trunk development server.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/web_worker_prime/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Automated Refactoring Commands for Yew Hook Functions using ast-grep\nDESCRIPTION: A series of ast-grep commands to automatically refactor Yew hook function calls. These commands update the order of arguments in functions like use_effect_with, use_callback, and use_memo to place dependencies as the first argument.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/migration-guides/yew/from-0_20_0-to-0_21_0.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsg --pattern 'use_effect_with_deps($CALLBACK,$$$DEPENDENCIES)' --rewrite 'use_effect_with($$$DEPENDENCIES, $CALLBACK)' -l rs -i\nsg --pattern 'use_effect_with($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_effect_with($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n\nsg --pattern 'use_callback($CALLBACK,$$$DEPENDENCIES)' --rewrite 'use_callback($$$DEPENDENCIES, $CALLBACK)' -l rs -i\nsg --pattern 'use_callback($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_callback($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n\nsg --pattern 'use_memo($CALLBACK,$$$DEPENDENCIES)' --rewrite 'use_memo($$$DEPENDENCIES, $CALLBACK)' -l rs -i\nsg --pattern 'use_memo($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_memo($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n\nsg --pattern 'use_future_with_deps($CALLBACK,$$$DEPENDENCIES)' --rewrite 'use_future_with($$$DEPENDENCIES, $CALLBACK)' -l rs -i\nsg --pattern 'use_future_with($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_future_with($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n\nsg --pattern 'use_transitive_state!($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_transitive_state!($DEPENDENCIES,$$$CALLBACK)' -l rs -i\nsg --pattern 'use_transitive_state!($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_transitive_state!($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n\nsg --pattern 'use_prepared_state!($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_prepared_state!($DEPENDENCIES,$$$CALLBACK)' -l rs -i\nsg --pattern 'use_prepared_state!($DEPENDENCIES,,$$$CALLBACK)' --rewrite 'use_prepared_state!($DEPENDENCIES,$$$CALLBACK)' -l rs -i\n```\n\n----------------------------------------\n\nTITLE: Creating Yew Struct Component Template in Rust\nDESCRIPTION: Template for creating Yew struct components with Component trait implementation, including message enum and required methods.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/getting-started/editor-setup.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct $NAME$;\n\nenum $NAME$Msg {\n}\n\nimpl Component for $NAME$ {\n    type Message = $NAME$Msg;\n    type Properties = ();\n\n    fn create(ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            $HTML$\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a New Cargo Project\nDESCRIPTION: This snippet demonstrates how to initialize a new Rust project using Cargo, which is the package manager and build system for Rust. The command 'cargo new yew-app' creates a new directory named 'yew-app' with all necessary files to start a Rust project.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo new yew-app\n```\n\n----------------------------------------\n\nTITLE: Nested Child Component with Modifiable Properties\nDESCRIPTION: Advanced technique for accessing and modifying child component properties dynamically\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/advanced-topics/children.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::rc::Rc;\nuse yew::prelude::*;\n\n#[derive(Clone, PartialEq, Properties)]\npub struct ListItemProps {\n    value: String,\n}\n\n#[function_component]\nfn ListItem(props: &ListItemProps) -> Html {\n    let ListItemProps { value } = props.clone();\n    html! {\n        <span>\n            {value}\n        </span>\n    }\n}\n\n#[derive(PartialEq, Properties)]\npub struct Props {\n    pub children: ChildrenWithProps<ListItem>,\n}\n\n#[function_component]\nfn List(props: &Props) -> Html {\n    let modified_children = props.children.iter().map(|mut item| {\n            let mut props = Rc::make_mut(&mut item.props);\n            props.value = format!(\"item-{}\", props.value);\n            item\n    });\n    html! { for modified_children }\n}\n\nhtml! {\n    <List>\n        <ListItem value=\"a\" />\n        <ListItem value=\"b\" />\n        <ListItem value=\"c\" />\n    </List>\n};\n```\n\n----------------------------------------\n\nTITLE: Running Yew Linting Checks\nDESCRIPTION: Performs code quality checks using Rustfmt and Clippy on the Yew codebase\nSOURCE: https://github.com/yewstack/yew/blob/master/CONTRIBUTING.md#2025-04-16_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncargo make lint\n```\n\n----------------------------------------\n\nTITLE: Navigator API Replacement\nDESCRIPTION: The History API has been deprecated and replaced with the new Navigator API for handling navigation and routing in Yew applications.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/migration-guides/yew-router/from-0_16_0-to-0_17_0.mdx#2025-04-16_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Typed Child Components with Specific Type\nDESCRIPTION: Implementation of a component that accepts only specific child component types using `ChildrenWithProps`\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/advanced-topics/children.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, ChildrenWithProps, Component, Context, Html, Properties};\n\npub struct Item;\n\nimpl Component for Item {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! { { \"item\" } }\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: ChildrenWithProps<Item>,\n}\n\npub struct List;\n\nimpl Component for List {\n    type Message = ();\n    type Properties = ListProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"list\">\n                { for ctx.props().children.iter() }\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Console Logging with gloo-console in Rust\nDESCRIPTION: Shows how to use the gloo-console crate, part of the Gloo collection, to log messages to the browser console. It provides an ergonomic wrapper for browser APIs and can handle JsValue directly.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/more/debugging.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse gloo_console::log;\nuse wasm_bindgen::JsValue;\n\nfn main() {\n    let object = JsValue::from(\"world\");\n    log!(\"Hello\", object)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Yew Dependencies in Cargo.toml\nDESCRIPTION: Updates the Cargo.toml file to include Yew as a dependency with the 'csr' feature for client-side rendering.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"yew-app\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\n# this is the development version of Yew\nyew = { git = \"https://github.com/yewstack/yew/\", features = [\"csr\"] }\n```\n\n----------------------------------------\n\nTITLE: Running the Yew Router Example with Trunk\nDESCRIPTION: Command to serve the Yew router example application using the Trunk development server with browser auto-opening functionality. This launches the development server and opens the application in the default browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/router/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Installing WebAssembly Target for Rust\nDESCRIPTION: Adds the wasm32-unknown-unknown target to Rust toolchain for compiling WebAssembly code that runs in browsers.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/getting-started/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nrustup target add wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Inspecting web-sys Inheritance with Deref in Rust\nDESCRIPTION: This snippet demonstrates how to traverse the inheritance hierarchy of a `HtmlTextAreaElement` in `web-sys` using `Deref::deref`.  It shows how to move from a specific HTML element type up to the base `JsValue` type, highlighting the relationships between different `web-sys` types and the underlying JavaScript types.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ops::Deref;\nuse web_sys::{\n    Element,\n    EventTarget,\n    HtmlElement,\n    HtmlTextAreaElement,\n    Node,\n};\n\nfn inheritance_of_text_area(text_area: HtmlTextAreaElement) {\n    // HtmlTextAreaElement 是 HTML 中的 <textarea>。\n    let html_element: &HtmlElement = text_area.deref();\n\n    let element: &Element = html_element.deref();\n\n    let node: &Node = element.deref();\n\n    let event_target: &EventTarget = node.deref();\n\n    // 注意我們現在已經從 web-sys 類型轉移到內建的 JavaScript 類型，\n    // 這些類型在 js-sys crate 中。\n    let object: &js_sys::Object = event_target.deref();\n\n    // 注意我們現在已經從 js-sys 類型轉移到 wasm-bindgen crate 中的根 JsValue。\n    let js_value: &wasm_bindgen::JsValue = object.deref();\n\n    // 這樣使用 deref 意味著我們必須手動遍歷繼承樹。\n    // 但是，您可以在 HtmlTextAreaElement 類型上呼叫 JsValue 方法。\n    assert!(!text_area.is_string());\n\n    // 這個空函數只是為了證明我們可以將 HtmlTextAreaElement 作為 &EventTarget 傳遞。\n    fn this_function_only_takes_event_targets(targets: &EventTarget) {};\n\n    // 編譯器將沿著 deref 鏈向下走，以符合這裡的類型。\n    this_function_only_takes_event_targets(&text_area);\n\n    // AsRef 實作可讓您將 HtmlTextAreaElement 視為 &EventTarget。\n    let event_target: &EventTarget = text_area.as_ref();\n\n}\n\n```\n\n----------------------------------------\n\nTITLE: Invalid Self-closing Tags - Rust\nDESCRIPTION: Presents an example of an invalid self-closing tag in Yew, where the self-closing slash is omitted, causing a compilation failure.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/introduction.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\\n\\nhtml! {\\n  <input id=\\\"my_input\\\"> // <- MISSING SELF-CLOSE\\n};\n```\n\n----------------------------------------\n\nTITLE: Adding yew-router Dependency in Cargo.toml\nDESCRIPTION: Demonstrates how to add the yew-router dependency to a Yew project's Cargo.toml file.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/router.mdx#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\nyew-router = { git = \"https://github.com/yewstack/yew.git\" }\n```\n\n----------------------------------------\n\nTITLE: Starting Trunk Development Server for Yew Application\nDESCRIPTION: Command to run the trunk development server and automatically open the application in a browser. Trunk handles serving the WebAssembly application and associated JavaScript files.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/js_callback/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Event Hook Structure in Yew\nDESCRIPTION: This snippet shows the initial structure of a custom hook for event handling in Yew. The hook is designed to take an event target, event type, and callback function, but its implementation is still pending.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{Event, EventTarget};\nuse std::borrow::Cow;\nuse gloo::events::EventListener;\nuse yew::prelude::*;\n\n#[hook]\npub fn use_event<E, F>(target: &EventTarget, event_type: E, callback: F)\nwhere\n    E: Into<Cow<'static, str>>,\n    F: Fn(&Event) + 'static,\n{\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: JavaScript Example of Mouse Move Event Handling\nDESCRIPTION: This JavaScript snippet demonstrates how to handle mouse move events and calculate the position of the mouse within an element.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\ndocument.getElementById('mousemoveme').onmousemove = (e) => {\n    // e 为鼠标事件对象\n    var rect = e.target.getBoundingClientRect()\n    var x = e.clientX - rect.left // 元素内的 x 位置。\n    var y = e.clientY - rect.top // 元素内的 y 位置。\n    console.log('Left? : ' + x + ' ; Top? : ' + y + '.')\n}\n```\n\n----------------------------------------\n\nTITLE: 在 Yew 中使用字面量和表达式生成 HTML (Rust)\nDESCRIPTION: 这个代码片段展示了如何在 Yew 中使用字面量和表达式来生成 HTML 内容。它演示了如何插入文本变量、字符串字面量和数字。\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet text = \"lorem ipsum\";\nhtml!{\n    <>\n        <div>{text}</div>\n        <div>{\"dolor sit\"}</div>\n        <span>{42}</span>\n    </>\n};\n```\n\n----------------------------------------\n\nTITLE: Tracing with tracing-web and tracing-subscriber in Rust\nDESCRIPTION: Illustrates how to use tracing-web with tracing-subscriber to output messages to the browser console. It sets up formatting layers and a performance layer for detailed tracing information.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/more/debugging.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing_subscriber::{\n    fmt::{\n        format::{FmtSpan, Pretty},\n        time::UtcTime,\n    },\n    prelude::*,\n};\nuse wasm_bindgen::JsValue;\n\nfn main() {\n    let fmt_layer = tracing_subscriber::fmt::layer()\n        .with_ansi(false)\n        .with_timer(UtcTime::rfc_3339())\n        .with_writer(tracing_web::MakeConsoleWriter)\n        .with_span_events(FmtSpan::ACTIVE);\n    let perf_layer = tracing_web::performance_layer().with_details_from_fields(Pretty::default());\n\n    tracing_subscriber::registry()\n        .with(fmt_layer)\n        .with(perf_layer)\n        .init();\n    let object = JsValue::from(\"world\");\n    tracing::info!(\"Hello {}\", object.as_string().unwrap());\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Nightly Features in .cargo/config.toml\nDESCRIPTION: This snippet shows how to configure experimental nightly features in Rust using the .cargo/config.toml file. It specifies the build-std features needed for optimizing the standard library for size and enabling immediate abort on panic.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/optimizations.mdx#2025-04-16_snippet_1\n\nLANGUAGE: TOML\nCODE:\n```\n[unstable]\n# Requires the rust-src component. `rustup +nightly component add rust-src`\nbuild-std = [\"std\", \"panic_abort\"]\nbuild-std-features = [\"panic_immediate_abort\"]\n```\n\n----------------------------------------\n\nTITLE: Optimizing WebAssembly Binary Size using wasm-opt\nDESCRIPTION: This command demonstrates how to use the wasm-opt tool to further reduce the size of WebAssembly binaries. It applies size optimizations to the input wasm file and outputs an optimized version.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/optimizations.mdx#2025-04-16_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nwasm-opt wasm_bg.wasm -Os -o wasm_bg_opt.wasm\n```\n\n----------------------------------------\n\nTITLE: Creating HTML Elements with html! Macro in Yew\nDESCRIPTION: Demonstrates how to create an HTML image element using Yew's html! macro. The macro converts the HTML-like syntax into Rust code that generates the corresponding DOM structure.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/basic-web-technologies/html.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet my_header: Html = html! {\n    <img src=\"img_girl.jpg\" alt=\"Girl in a jacket\" width=\"500\" height=\"600\" />\n};\n```\n\n----------------------------------------\n\nTITLE: Running Yew Application with Trunk Development Server\nDESCRIPTION: Command to start the Trunk development server and automatically open the application in a browser. Trunk is the recommended build tool for Yew applications.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/communication_grandchild_with_grandparent/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Running Yew Application with Trunk Server\nDESCRIPTION: Command to start the trunk development server and automatically open the application in a browser. The trunk serve command compiles and serves the Yew application, while the --open flag launches it in the default browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/immutable/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Switch Component Changes in Yew 0.17.0\nDESCRIPTION: The Switch component has been simplified to directly accept a closure of type Fn(Routable) -> Html as the render function, eliminating the need for Switch::render.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/migration-guides/yew-router/from-0_16_0-to-0_17_0.mdx#2025-04-16_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Creating a New Rust Project with Cargo\nDESCRIPTION: Creates a new Rust project named 'yew-app' using Cargo, which will be converted to a Yew application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo new yew-app\n```\n\n----------------------------------------\n\nTITLE: Bash Script for Automatic 'changed' Method Update\nDESCRIPTION: This bash script uses perl to automatically update the 'changed' method signature in Rust files. It adds the new 'old_props' parameter to existing method declarations.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/migration-guides/yew/from-0_19_0-to-0_20_0.mdx#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nperl -p -i -e  's/fn changed\\(&mut self, (\\w+): &Context<Self>\\)/fn changed(&mut self, $1: &Context<Self>, _old_props: &Self::Properties)/g' $(find . -name \\*.rs)\n```\n\n----------------------------------------\n\nTITLE: Creating New Rust Project\nDESCRIPTION: Commands to create and navigate to a new Rust project directory\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo new yew-app\n```\n\nLANGUAGE: bash\nCODE:\n```\ncd yew-app\n```\n\nLANGUAGE: bash\nCODE:\n```\ncargo run\n# output: Hello World!\n```\n\n----------------------------------------\n\nTITLE: Installing Cargo Make Build Tool\nDESCRIPTION: Installs cargo-make, a task runner and build tool used for Yew development workflows\nSOURCE: https://github.com/yewstack/yew/blob/master/CONTRIBUTING.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo install cargo-make\n```\n\n----------------------------------------\n\nTITLE: Updating API Endpoint for Proxy in Yew\nDESCRIPTION: This code updates the API endpoint in the `Request::get` call to use a relative URL (`/tutorial/data.json`) instead of an absolute URL (`https://yew.rs/tutorial/data.json`). This is required when using a proxy server like the one provided by Trunk to avoid CORS issues.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\n// ...\nlet fetched_videos: Vec<Video> = Request::get(\"/tutorial/data.json\")\n// ...\n```\n\n----------------------------------------\n\nTITLE: Configuring wee_alloc as Global Allocator for Smaller Wasm Binaries\nDESCRIPTION: This code sets up wee_alloc as the global memory allocator to reduce Wasm binary size at the expense of slight performance overhead, which is beneficial for faster page loading times.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/advanced-topics/optimizations.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Use `wee_alloc` as the global allocator.\n#[global_allocator]\nstatic ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;\n```\n\n----------------------------------------\n\nTITLE: Configuring wasm-bindgen Dependency in Cargo.toml\nDESCRIPTION: Adds the wasm-bindgen dependency in Cargo.toml to use JsCast for type conversion in Rust. This is essential for casting event targets to specific HTML elements when handling events in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/events.mdx#2025-04-16_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\n# need wasm-bindgen for JsCast\nwasm-bindgen = \"0.2\"\n```\n\n----------------------------------------\n\nTITLE: Destroying a Yew Component\nDESCRIPTION: This snippet describes the `destroy` lifecycle method, which Yew calls when a component is unmounted from the DOM and allows for cleanup activities.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n// Example code showing operations on component destruction is not provided directly\n```\n\n----------------------------------------\n\nTITLE: Running Yew Nested List Example with Trunk\nDESCRIPTION: Command to serve the nested list application using the Trunk development server with automatic browser opening\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/nested_list/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing DOM Nodes in Yew\nDESCRIPTION: This snippet demonstrates how to manually create and manage DOM nodes in Yew using web-sys. It creates a div element, sets its content, and converts it to a Node that can be used as an Html value.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.22/concepts/html/elements.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{Element, Node};\nuse yew::prelude::*;\nuse gloo::utils::document;\n\n#[function_component]\nfn MyComponent() -> Html {\n    // メモ化された関数、一度だけ実行されます\n    let node = use_memo(\n        (),\n        |_| {\n            // ドキュメントから div 要素を作成\n            let div: Element = document().create_element(\"div\").unwrap();\n            // コンテンツ、クラスなどを追加\n            div.set_inner_html(\"Hello, World!\");\n            // Element を Node に変換\n            let node: Node = div.into();\n            // その Node を Html 値として返す\n            Html::VRef(node)\n        },\n    );\n\n    // use_memo は Rc ポインタを返すので、参照解除とクローンが必要です\n    (*node).clone()\n}\n```\n\n----------------------------------------\n\nTITLE: SVG Rendering in Yew\nDESCRIPTION: Demonstrates SVG element creation with complex paths and filters\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/introduction.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <svg width=\"149\" height=\"147\" viewBox=\"0 0 149 147\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n        <path d=\"M60.5776 13.8268L51.8673 42.6431L77.7475 37.331L60.5776 13.8268Z\" fill=\"#DEB819\"/>\n        <path d=\"M108.361 94.9937L138.708 90.686L115.342 69.8642\" stroke=\"black\" stroke-width=\"4\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        <g filter=\"url(#filter0_d)\">\n            <circle cx=\"75.3326\" cy=\"73.4918\" r=\"55\" fill=\"#FDD630\"/>\n            <circle cx=\"75.3326\" cy=\"73.4918\" r=\"52.5\" stroke=\"black\" stroke-width=\"5\"/>\n        </g>\n        <circle cx=\"71\" cy=\"99\" r=\"5\" fill=\"white\" fill-opacity=\"0.75\" stroke=\"black\" stroke-width=\"3\"/>\n        <defs>\n            <filter id=\"filter0_d\" x=\"16.3326\" y=\"18.4918\" width=\"118\" height=\"118\" filterUnits=\"userSpaceOnUse\" color-interpolation-filters=\"sRGB\">\n                <@{\"feGaussianBlur\"} stdDeviation=\"2\"/>\n                <@{\"feColorMatrix\"} in=\"SourceAlpha\" type=\"matrix\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\"/>\n            </filter>\n        </defs>\n    </svg>\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid Usage of Multiple Root Elements in Yew's html! Macro (Rust)\nDESCRIPTION: This code snippet illustrates an invalid use of Yew's html! macro where multiple root elements are used without a fragment. This will result in a compilation error as only one root HTML element is allowed.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/fragments.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n// error: only one root html element allowed\n\nhtml! {\n    <div></div>\n    <p></p>\n};\n```\n\n----------------------------------------\n\nTITLE: Running Debug Version of Yew Timer Application with Trunk\nDESCRIPTION: This command uses Trunk to serve a debug version of the Yew timer application and automatically opens it in the default browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/timer_functional/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Event Handling: `ontransitionrun` Event\nDESCRIPTION: This event handler is triggered when a CSS transition is first started. It makes use of the `TransitionEvent` struct from `web-sys` to provide details about the initiated transition.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/html/events.mdx#2025-04-16_snippet_13\n\nLANGUAGE: Rust\nCODE:\n```\n\"ontransitionrun\"\n```\n\n----------------------------------------\n\nTITLE: Cargo.toml Configuration for web-sys Example\nDESCRIPTION: This TOML snippet shows the necessary dependencies and feature flags for the web-sys example in Rust.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nwasm-bindgen = \"0.2\"\n\n[dependencies.web-sys]\nversion = \"0.3\"\n# 需要启用所有我们想要使用的 web-sys 特性！\nfeatures = [\n    \"console\",\n    \"Document\",\n    \"HtmlElement\",\n    \"MouseEvent\",\n    \"DomRect\",\n]\n```\n\n----------------------------------------\n\nTITLE: Implementing the View Method in Yew (Rust)\nDESCRIPTION: Demonstrates how to implement the view method to define component layout using Yew's html! macro, including event binding.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.18.0/concepts/components/introduction.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nimpl Component for MyComponent {\n    // ...\n\n    fn view(&self) -> Html {\n        let onclick = self.link.callback(|_| Msg::Click);\n        html! {\n            <button onclick=onclick>{ self.props.button_text }</button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested Router in Yew (Rust)\nDESCRIPTION: Demonstrates how to implement a nested router structure in Yew. It defines two sets of routes (MainRoute and SettingsRoute) and implements switch functions to handle routing between them.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/router.mdx#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew_router::prelude::*;\nuse gloo::utils::window;\nuse wasm_bindgen::UnwrapThrowExt;\n\n#[derive(Clone, Routable, PartialEq)]\nenum MainRoute {\n    #[at(\"/\")]\n    Home,\n    #[at(\"/news\")]\n    News,\n    #[at(\"/contact\")]\n    Contact,\n    #[at(\"/settings\")]\n    SettingsRoot,\n    #[at(\"/settings/*\")]\n    Settings,\n    #[not_found]\n    #[at(\"/404\")]\n    NotFound,\n}\n\n#[derive(Clone, Routable, PartialEq)]\nenum SettingsRoute {\n    #[at(\"/settings\")]\n    Profile,\n    #[at(\"/settings/friends\")]\n    Friends,\n    #[at(\"/settings/theme\")]\n    Theme,\n    #[not_found]\n    #[at(\"/settings/404\")]\n    NotFound,\n}\n\nfn switch_main(route: MainRoute) -> Html {\n    match route {\n        MainRoute::Home => html! {<h1>{\"Home\"}</h1>},\n        MainRoute::News => html! {<h1>{\"News\"}</h1>},\n        MainRoute::Contact => html! {<h1>{\"Contact\"}</h1>},\n        MainRoute::SettingsRoot | MainRoute::Settings => html! { <Switch<SettingsRoute> render={switch_settings} /> },\n        MainRoute::NotFound => html! {<h1>{\"Not Found\"}</h1>},\n    }\n}\n\nfn switch_settings(route: SettingsRoute) -> Html {\n    match route {\n        SettingsRoute::Profile => html! {<h1>{\"Profile\"}</h1>},\n        SettingsRoute::Friends => html! {<h1>{\"Friends\"}</h1>},\n        SettingsRoute::Theme => html! {<h1>{\"Theme\"}</h1>},\n        SettingsRoute::NotFound => html! {<Redirect<MainRoute> to={MainRoute::NotFound}/>}\n    }\n}\n\n#[function_component(App)]\npub fn app() -> Html {\n    html! {\n        <BrowserRouter>\n            <Switch<MainRoute> render={switch_main} />\n        </BrowserRouter>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating html! Macro Prop Syntax in Yew 0.19.0 (Rust)\nDESCRIPTION: Demonstrates the new requirement to enclose props with braces in the html! macro. Shows invalid and valid syntax, as well as a new shorthand initialization feature.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/migration-guides/yew/from-0_18_0-to-0_19_0.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet super_age = 1;\nhtml!{\n    <JapaneseYew\n        age=super_age // ! Will throw an error\n    >\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet super_age = 1;\nhtml!{\n    <JapaneseYew\n        age={super_age} // Correct\n    >\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet age = 1;\nhtml!{\n    <JapaneseYew\n        {age}\n    >\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing WebAssembly Code with wasm-opt\nDESCRIPTION: This snippet provides a command to optimize WebAssembly (.wasm) binaries using wasm-opt. It demonstrates how to optimize the size of a wasm file for production.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/optimizations.mdx#2025-04-16_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nwasm-opt wasm_bg.wasm -Os -o wasm_bg_opt.wasm\n```\n\n----------------------------------------\n\nTITLE: Initializing wasm-logger for Console Logging in Rust\nDESCRIPTION: This snippet demonstrates how to initialize the `wasm-logger` crate for logging messages to the browser's console in a Rust/Wasm application. It sets up the logger with a default configuration, allowing you to use the `log` crate's macros like `info!`, `warn!`, `error!`, etc.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/more/debugging.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    wasm_logger::init(wasm_logger::Config::default());\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Serving a Yew Example with Trunk\nDESCRIPTION: This snippet demonstrates how to navigate to an example directory and use Trunk to build and serve a Yew example. The --open flag automatically opens the example in your default browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# move into the directory of the example you want to run\n# In this case it's the todomvc example\ncd examples/todomvc\n\n# build and serve the example\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Running WASI SSR Module with Wasmtime\nDESCRIPTION: Command to execute the compiled WebAssembly module using Wasmtime runtime. This runs the server-side rendering application through the WASI preview2 compatibility layer.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/wasi_ssr_module/README.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nwasmtime target/wasm32-wasip1/release/wasi_ssr_module.wasm\n```\n\n----------------------------------------\n\nTITLE: Running TodoMVC Example with Trunk Server\nDESCRIPTION: Command to start the trunk development server and open the TodoMVC application in the browser. Trunk is used as the development server for serving the Yew application.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/function_todomvc/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Setting Up index.html for Yew App\nDESCRIPTION: Sets up the basic HTML structure for the Yew app. This file is generally placed in the root directory and serves as the entry point for the web application, providing the basic meta and title elements.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_5\n\nLANGUAGE: html\nCODE:\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>Yew App</title>\n  </head>\n</html>\n```\n\n----------------------------------------\n\nTITLE: WebAssembly MIME Type Error Example\nDESCRIPTION: An example error message that occurs when WebAssembly files are not served with the correct MIME type. The server must be configured to serve .wasm files with the 'application/wasm' Content-Type header.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/more/deployment.mdx#2025-04-16_snippet_1\n\nLANGUAGE: ignore\nCODE:\n```\n`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n TypeError: WebAssembly: Response has unsupported MIME type 'text/plain' expected 'application/wasm'\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for Yew\nDESCRIPTION: Cargo manifest configuration for a Yew web application with CSR feature enabled\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"yew-app\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\n# this is the development version of Yew\nyew = { git = \"https://github.com/yewstack/yew/\", features = [\"csr\"] }\n```\n\n----------------------------------------\n\nTITLE: Using wasm-opt to Reduce WebAssembly Binary Size\nDESCRIPTION: Command for using the wasm-opt tool to optimize WebAssembly binary size through post-compilation optimization, showing how to apply size optimizations to an existing wasm file.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/advanced-topics/optimizations.mdx#2025-04-16_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nwasm-opt wasm_bg.wasm -Os -o wasm_bg_opt.wasm\n```\n\n----------------------------------------\n\nTITLE: Event Handling: `ontouchend` Event\nDESCRIPTION: This event handler is triggered when a touch point is removed from the touch surface. It utilizes the `TouchEvent` struct from the `web-sys` crate, containing information about the ending touch.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/html/events.mdx#2025-04-16_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\n\"ontouchend\"\n```\n\n----------------------------------------\n\nTITLE: Building WebAssembly with wasm-pack\nDESCRIPTION: This command builds the Rust project into a WebAssembly module and generates JavaScript wrapper code. The `--target web` flag specifies that the output should be compatible with web browsers. The resulting files are placed in the `./pkg` directory.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/project-setup/using-wasm-pack.mdx#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n\"wasm-pack build --target web\"\n```\n\n----------------------------------------\n\nTITLE: Comparison of Yew Hook Usage Before the API Change\nDESCRIPTION: Example Rust code showing how hooks were used before the API change. It demonstrates the less ergonomic pattern where the callback function is passed first, requiring extracting dependencies in advance.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/migration-guides/yew/from-0_20_0-to-0_21_0.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nimpl SomeLargeStruct {\n    fn id(&self) -> u32; // Only need to use the id as cache key\n}\nlet some_dep: SomeLargeStruct = todo!();\n\n{\n    let id = some_dep.id(); // Have to extract it in advance, some_dep is moved already in the second argument\n    use_effect_with_dep(move |_| { todo!(); drop(some_dep); }, id);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Yew Function Component Template in Rust\nDESCRIPTION: Template for generating a new Yew function component with Properties struct and HTML template support\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/getting-started/editor-setup.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(PartialEq, Properties)]\npub struct $Name$Props {\n}\n\n#[function_component]\npub fn $Name$(props: &$Name$Props) -> Html {\n    html! {\n        <$tag$>$END$</$tag$>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Expanding 'html!' Macro Rust Code\nDESCRIPTION: Illustrates the transformation performed by the 'html!' macro within the Yew framework, enabling declarative UI development by converting custom syntax into valid Rust code. It leverages the Yew library API, requiring 'cargo expand' for macro inspection which necessitates installation via 'cargo install cargo-expand' if not pre-installed.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/advanced-topics/how-it-works.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"html! { ... }\"\n```\n\n----------------------------------------\n\nTITLE: Updated 'changed' Method Signature in Rust\nDESCRIPTION: The 'changed' method for components now includes an additional parameter for old properties. This snippet shows the new method signature that developers should use when updating their components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/migration-guides/yew/from-0_19_0-to-0_20_0.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn changed(&mut self, ctx: &Context<Self>, old_props: &Self::Properties) -> bool\n```\n\n----------------------------------------\n\nTITLE: Accessing document object in JavaScript\nDESCRIPTION: Demonstrates how to access the document object from the window in JavaScript.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/basic-web-technologies/js.mdx#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nlet document = window.document\n```\n\n----------------------------------------\n\nTITLE: Function Component Without Props in Yew\nDESCRIPTION: Example of a Yew function component that doesn't accept any properties, showing the simpler function signature and how to render it without passing props.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/function-components/properties.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html};\n\n#[function_component]\nfn HelloWorld() -> Html {\n    html! { \"Hello world\" }\n}\n\n// No props to supply\n#[function_component]\nfn App() -> Html {\n    html! { <HelloWorld /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Yew Context Example with Trunk in Bash\nDESCRIPTION: Command to run the Yew Context API example application using the trunk development server with the --open flag to automatically open it in a browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/contexts/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Defining Component Message and Properties Types\nDESCRIPTION: Demonstrates how to define associated types for Message and Properties in a Yew component implementation\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.21/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nimpl Component for MyComponent {\n    type Message = Msg;\n    type Properties = Props;\n\n    // ...\n}\n\nenum Msg {\n    Click,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Basic Yew Components with and without Props\nDESCRIPTION: This code snippet demonstrates the creation of a simple Yew component without properties and a component that accepts properties. It shows how to define properties using the `Properties` derive macro and how to access them within the component's function.  It illustrates different ways to pass props, including explicit values, clones, and overrides.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/components.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[function_component]\nfn MyComponent() -> Html {\n    html! {\n        { \"This component has no properties!\" }\n    }\n}\n\n#[derive(Clone, PartialEq, Properties)]\nstruct Props {\n    user_first_name: String,\n    user_last_name: String,\n}\n\n#[function_component]\nfn MyComponentWithProps(props: &Props) -> Html {\n    let Props { user_first_name, user_last_name } = props;\n    html! {\n        <>{\"user_first_name: \"}{user_first_name}{\" and user_last_name: \"}{user_last_name}</>\n    }\n}\n\nlet props = Props {\n    user_first_name: \"Bob\".to_owned(),\n    user_last_name: \"Smith\".to_owned(),\n};\n\nhtml!{\n    <>\n        // No properties\n        <MyComponent />\n\n        // With Properties\n        <MyComponentWithProps user_first_name=\"Sam\" user_last_name=\"Idle\" />\n\n        // With the whole set of props provided at once\n        <MyComponentWithProps ..props.clone() />\n\n        // With Properties from a variable and specific values overridden\n        <MyComponentWithProps user_last_name=\"Elm\" ..props />\n    </>\n};\n\n```\n\n----------------------------------------\n\nTITLE: Installing WebAssembly Target for Rust\nDESCRIPTION: Adds the WebAssembly target to the Rust toolchain for Yew development\nSOURCE: https://github.com/yewstack/yew/blob/master/CONTRIBUTING.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustup target add wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Building a POST Request with JSON Body in Yew\nDESCRIPTION: Example of creating a POST request with a JSON body using Yew's fetch service. This snippet shows how to set the content type header and include JSON data in the request body.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/services/fetch.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse serde_json::json;\nuse yew::format::Json;\nuse yew::services::fetch::Request;\nlet post_request = Request::post(\"https://example.com/api/v1/post/something\")\n    .header(\"Content-Type\", \"application/json\")\n    .body(Json(&json!({\"key\": \"value\"})))\n    .expect(\"Could not build that request.\");\n```\n\n----------------------------------------\n\nTITLE: Yew Callback with DOM Event\nDESCRIPTION: This snippet demonstrates how to connect a Yew callback function to a DOM event (specifically, a button click). When the button is clicked, the associated callback is executed, which in this case logs a greeting to the console (if uncommented).\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/function-components/callbacks.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html, Properties, Callback};\n\n#[function_component]\nfn App() -> Html {\n    let onclick = Callback::from(move |_| {\n        let greeting = String::from(\"Hi there\");\n        // web_sys::console::log_1(&greeting.into()); // 如果取消注释，这里会打印文本\n    });\n\n    html! {\n        <button {onclick}>{ \"Click\" }</button>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing wasm-logger for Console Logging in Rust\nDESCRIPTION: This code snippet demonstrates how to initialize the wasm-logger crate for enabling console logging in a Rust Wasm application. It configures the logger with default settings, allowing log messages from the Rust code to be displayed in the browser's console. This crate integrates with the Rust `log` crate.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.21/more/debugging.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// 設定\nfn main() {\n    wasm_logger::init(wasm_logger::Config::default());\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering with Simple If Block in Yew (Rust)\nDESCRIPTION: Demonstrates how to use a simple if block for conditional rendering in Yew. This snippet shows rendering a paragraph element when the condition is true.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/conditional-rendering.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    if true {\n        <p>{ \"True case\" }</p>\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Accessing Environment Variables at Compile Time in Rust\nDESCRIPTION: Rust macro to obtain the value of an environment variable at compile time, useful for customizing build behavior in Yew applications.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/more/deployment.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nstd::env!\n```\n\n----------------------------------------\n\nTITLE: Event Handling: `ontransitionend` Event\nDESCRIPTION: This event handler is triggered when a CSS transition has completed. It utilizes the `TransitionEvent` struct from the `web-sys` crate to signal that the transition has finished.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/html/events.mdx#2025-04-16_snippet_12\n\nLANGUAGE: Rust\nCODE:\n```\n\"ontransitionend\"\n```\n\n----------------------------------------\n\nTITLE: Running Yew Project with Trunk\nDESCRIPTION: Serves the Yew application using Trunk, a WASM web application bundler for Rust.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ntrunk serve\n```\n\n----------------------------------------\n\nTITLE: Rendering Literal String with html! Macro in Rust\nDESCRIPTION: Shows how to render a literal string using the html! macro, which requires quotation marks and braces.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.18.0/concepts/html/introduction.mdx#2025-04-16_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nhtml! { \"Hello, World\" }\n```\n\n----------------------------------------\n\nTITLE: Using Navigator in Function Components for Multiple Routes\nDESCRIPTION: Shows how to use the Navigator API in function components to create multiple navigation buttons for different routes, demonstrating how to clone the navigator for reuse.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/router.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew_router::prelude::*;\n\n#[function_component(NavItems)]\npub fn nav_items() -> Html {\n    let navigator = use_navigator().unwrap();\n\n    let go_home_button = {\n        let navigator = navigator.clone();\n        let onclick = Callback::from(move |_| navigator.push(&Route::Home));\n        html! {\n            <button {onclick}>{\"click to go home\"}</button>\n        }\n    };\n\n    let go_to_first_post_button = {\n        let navigator = navigator.clone();\n        let onclick = Callback::from(move |_| navigator.push(&Route::Post { id: \"first-post\".to_string() }));\n        html! {\n            <button {onclick}>{\"click to go the first post\"}</button>\n        }\n    };\n\n    let go_to_secure_button = {\n        let onclick = Callback::from(move |_| navigator.push(&Route::Secure));\n        html! {\n            <button {onclick}>{\"click to go to secure\"}</button>\n        }\n    };\n\n    html! {\n        <>\n            {go_home_button}\n            {go_to_first_post_button}\n            {go_to_secure_button}\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Hook - use_event (initial)\nDESCRIPTION: This snippet defines the initial structure of a custom hook named `use_event`. This hook is intended to handle event listening. It accepts an `EventTarget`, an event type, and a callback function as parameters, but the implementation is incomplete (`todo!()`).\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{Event, EventTarget};\nuse std::borrow::Cow;\nuse gloo::events::EventListener;\nuse yew::prelude::*;\n\n#[hook]\npub fn use_event<E, F>(target: &EventTarget, event_type: E, callback: F)\nwhere\n    E: Into<Cow<'static, str>>,\n    F: Fn(&Event) + 'static,\n{\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Yew App Configuration with HTML\nDESCRIPTION: This HTML snippet serves as a basic configuration file for a Yew app. The `index.html` file is required at the project's root and contains essential metadata such as character set and page title. The file acts as a configuration guide for the Trunk tool to build the application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/project-setup/using-trunk.mdx#2025-04-16_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<!doctype html>\n<html>\n    <head>\n        <meta charset=\\\"utf-8\\\" />\n        <title>Yew App</title>\n    </head>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Using Navigator API in Yew Struct Components\nDESCRIPTION: Shows how to use the Navigator API for programmatic navigation in Yew struct components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/router.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfn view(&self, ctx: &Context<Self>) -> Html {\n    let navigator = ctx.link().navigator().unwrap();\n    let onclick = Callback::from(move |_| navigator.push(&MainRoute::Home));\n    html!{\n        <button {onclick}>{\"Go Home\"}</button>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding WebAssembly Target using Rustup\nDESCRIPTION: This shell snippet adds the WebAssembly target 'wasm32-unknown-unknown' to your Rust toolchain. This is necessary for compiling Rust code to WebAssembly for browser environments. Prerequisite is an installed Rust development environment.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/getting-started/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nrustup target add wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Neovim LazyVim Language Server Configuration\nDESCRIPTION: Configuration for adding Rust and HTML language support in Neovim using LazyVim\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/getting-started/editor-setup.mdx#2025-04-16_snippet_3\n\nLANGUAGE: json\nCODE:\n```\nreturn {\n  {\n    \"neovim/nvim-lspconfig\",\n    init_options = {\n      userLanguages = {\n        eelixir = \"html-eex\",\n        eruby = \"erb\",\n        rust = \"html\",\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Yew Struct Component Template for JetBrains IDEs\nDESCRIPTION: Template for generating a new Yew struct component with message enum in JetBrains IDEs\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/getting-started/editor-setup.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct $NAME$;\n\nenum $NAME$Msg {\n}\n\nimpl Component for $NAME$ {\n    type Message = $NAME$Msg;\n    type Properties = ();\n\n    fn create(ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            $HTML$\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Yew Dependencies for Mousemove Example\nDESCRIPTION: This TOML snippet defines the `web-sys` dependencies required for the Yew-based mousemove example. It includes the `DomRect` feature, which is needed for the `get_bounding_client_rect` method.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies.web-sys]\nversion = \"0.3\"\n# 我們需要啟用 `DomRect` 特性以使用 `get_bounding_client_rect` 方法。\nfeatures = [\n    \"console\",\n    \"HtmlElement\",\n    \"MouseEvent\",\n    \"DomRect\",\n]\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Yew Components on the Server-side with ServerRenderer in Rust\nDESCRIPTION: This snippet demonstrates how to use the ServerRenderer to render Yew components on the server-side. It creates a simple App component and uses tokio to asynchronously render it into a String.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/server-side-rendering.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew::ServerRenderer;\n\n#[function_component]\nfn App() -> Html {\n    html! {<div>{\"Hello, World!\"}</div>}\n}\n\n#[tokio::main(flavor = \"current_thread\")]\nasync fn no_main() {\n    let renderer = ServerRenderer::<App>::new();\n\n    let rendered = renderer.render().await;\n\n    // Prints: <div>Hello, World!</div>\n    println!(\"{}\", rendered);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Functional Yew Component Template in Jetbrains IDEs\nDESCRIPTION: This Rust template assists in creating functional Yew components. It allows customization of component name and HTML tags, the set-up further involves editing variable expressions for automatic conversion to snake case. Dependencies include Yew's Preludes for properties and functional components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/more/development-tips.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Properties, PartialEq, Clone)]\npub struct $Name$Props {\n}\n\n#[function_component($Name$)]\npub fn $func_name$(props: &$Name$Props) -> Html {\n\n\n    html! {\n        <$tag$>$END$</$tag$>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Event Handling in Yew with oninput and onchange\nDESCRIPTION: This code snippet demonstrates an incorrect way of applying `oninput` and `onchange` handlers in Yew.  Specifically, it attaches the handlers to a `div` element instead of the intended `input` element, leading to unexpected behavior and potential panics because `InputData` and `ChangeData` expect the event target to be the current target.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/events.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, ChangeData, Html, InputData};\n\nenum Msg {\n    InputValue(String),\n}\n\n\nfn view(&self) -> Html {\n\n    let oninput = self.link.callback(|e: InputData| Msg::InputValue(e.value));\n    let onchange = self.link.batch_callback(|e: ChangeData| {\n        if let ChangeData::Value(value) = e {\n            Some(Msg::InputValue(value))\n        } else {\n            None\n        }\n    });\n\n    html! {\n        <div\n            // The `InputEvent` can bubble and then will read the text content\n            // of the div as the value in `InputData` which is not what you'd\n            // expect!\n            //highlight-next-line\n            oninput={oninput}\n            // The `Event` can bubble and will cause a panic when it tries\n            // to create the `ChangeData` enum.\n            //highlight-next-line\n            onchange={onchange}\n        >\n            { \"hi\" }\n            <input type=\"text\" />\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Agent System Documentation Structure in Markdown\nDESCRIPTION: Markdown structure defining the documentation layout for Yew's Agent system, including imports for themed images and section organization.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/agents.mdx#2025-04-16_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\ntitle: 'Agents'\ndescription: \"Yew's Actor System\"\n---\n\nimport useBaseUrl from '@docusaurus/useBaseUrl'\nimport ThemedImage from '@theme/ThemedImage'\n\nAgents are a way to offload tasks to web workers.\n```\n\n----------------------------------------\n\nTITLE: Creating and Mutating Nested Components in Yew Using Rust\nDESCRIPTION: This snippet illustrates the creation and mutation of nested components in Yew with the Rust programming language. It demonstrates a 'List' component with 'ListItem' children, showcasing how properties of nested children can be modified. The snippet requires the 'yew' crate and components like 'ChildrenWithProps'. It outputs individual 'ListItem' components with transformed properties.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/components.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::rc::Rc;\nuse yew::{html, ChildrenWithProps, Component, Context, Html, Properties};\n\n#[derive(Clone, PartialEq, Properties)]\npub struct ListItemProps {\n    value: String,\n}\n\npub struct ListItem;\n\nimpl Component for ListItem {\n    type Message = ();\n    type Properties = ListItemProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <span>\n                { ctx.props().value.clone() }\n            </span>\n        }\n    }\n}\n\n#[derive(PartialEq, Properties)]\npub struct Props {\n    pub children: ChildrenWithProps<ListItem>,\n}\n\npub struct List;\nimpl Component for List {\n    type Message = ();\n    type Properties = Props;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {{\n            for ctx.props().children.iter().map(|mut item| {\n                let mut props = Rc::make_mut(&mut item.props);\n                props.value = format!(\"item-{}\", props.value);\n                item\n            })\n        }}\n    }\n}\nhtml! {\n    <List>\n        <ListItem value=\"a\" />\n        <ListItem value=\"b\" />\n        <ListItem value=\"c\" />\n    </List>\n};\n```\n\n----------------------------------------\n\nTITLE: Installing Trunk WebAssembly Bundler\nDESCRIPTION: Command to install Trunk, the recommended tool for managing deployment and packaging of Yew applications. Trunk is installed via cargo and compiles from source, though prebuilt binaries are available through package managers.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/getting-started/introduction.mdx#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n# note that this might take a while to install because it compiles everything from scratch\n# Trunk also provides prebuilt binaries for a number of major package managers\n# See https://trunkrs.dev/#install for further details\ncargo install --locked trunk\n```\n\n----------------------------------------\n\nTITLE: Initializing wasm-logger for Console Logging in Rust\nDESCRIPTION: This snippet demonstrates how to set up and use the wasm-logger crate for console logging in a Rust web application. It integrates with the standard Rust log crate.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.18.0/more/debugging.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// setup\nfn main() {\n    wasm_logger::init(wasm_logger::Config::default());\n}\n\n// usage\nlog::info!(\"Update: {:?}\", msg);\n```\n\n----------------------------------------\n\nTITLE: Defining a Video struct\nDESCRIPTION: This snippet defines a `Video` struct in Rust, representing video data with fields for ID, title, speaker, and URL.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n\"struct Video {\n    id: usize,\n    title: String,\n    speaker: String,\n    url: String,\n}\"\n```\n\n----------------------------------------\n\nTITLE: Listing Available Cargo Make Tasks\nDESCRIPTION: Shows all available development tasks configured for the Yew project\nSOURCE: https://github.com/yewstack/yew/blob/master/CONTRIBUTING.md#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo make --list-all-steps\n```\n\n----------------------------------------\n\nTITLE: Invalid HTML Open Tag Example in Yew\nDESCRIPTION: This code snippet illustrates an invalid HTML structure within the `html!` macro. The `div` element lacks a closing tag, resulting in a compilation error due to incomplete HTML structure. This example requires the `yew` crate to be included.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/introduction.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n  <div id=\"my_div\"> // <- 缺少闭合标签\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Hook Structure in Yew\nDESCRIPTION: This snippet defines the internal state structure for a custom hook named `use_subscribe`. It includes a messages field to hold received messages and implements the `Hook` trait.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.20/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n/// `use_subscribe` internal state\nstruct UseSubscribeState {\n    /// holds all the messages received\n    pub messages: Rc<RefCell<Vec<String>>>,\n}\n\nimpl Hook for UseSubscribeState {}\n```\n\n----------------------------------------\n\nTITLE: Serving the built application with Python\nDESCRIPTION: This command starts a simple HTTP server using Python to serve the built application. The server listens on port 8000 and serves files from the current directory.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/getting-started/project-setup/using-wasm-pack.mdx#2025-04-16_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npython -m http.server 8000\n```\n\n----------------------------------------\n\nTITLE: Adding WebAssembly Target in Rust\nDESCRIPTION: This command adds the WebAssembly compilation target to the Rust development environment. It enables compiling Rust code for browser-based WebAssembly.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/getting-started/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nrustup target add wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Running Web Applications with Cargo Web\nDESCRIPTION: This command starts a local development server to run the web application using 'cargo web'. It's useful for testing and development purposes.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/project-setup/using-cargo-web.mdx#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo web start\n```\n\n----------------------------------------\n\nTITLE: Logging to Browser Console with tracing-web in Rust\nDESCRIPTION: Demonstrates using tracing-web with tracing-subscriber to configure and output messages to the browser console. This approach provides more advanced features including span events, timing, and performance layer support.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/more/debugging.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing_subscriber::\n    fmt::\n        format::{FmtSpan, Pretty},\n        time::UtcTime,\n    },\n    prelude::*,\n};\nuse wasm_bindgen::JsValue;\n\nfn main() {\n    let fmt_layer = tracing_subscriber::fmt::layer()\n        .with_ansi(false)\n        .with_timer(UtcTime::rfc_3339())\n        .with_writer(tracing_web::MakeConsoleWriter)\n        .with_span_events(FmtSpan::ACTIVE);\n    let perf_layer = tracing_web::performance_layer().with_details_from_fields(Pretty::default());\n\n    tracing_subscriber::registry()\n        .with(fmt_layer)\n        .with(perf_layer)\n        .init();\n    let object = JsValue::from(\"world\");\n    tracing::info!(\"Hello {}\", object.as_string().unwrap());\n}\n```\n\n----------------------------------------\n\nTITLE: Nightly Cargo Configuration for Build Optimization\nDESCRIPTION: Configuration for enabling experimental nightly features in .cargo/config.toml to further optimize build size using build-std and build-std-features.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/advanced-topics/optimizations.mdx#2025-04-16_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[unstable]\n# Requires the rust-src component. `rustup +nightly component add rust-src`\nbuild-std = [\"std\", \"panic_abort\"]\nbuild-std-features = [\"panic_immediate_abort\"]\n```\n\n----------------------------------------\n\nTITLE: Checking Rust Compiler Version Command\nDESCRIPTION: Alternative command to check the installed Rust compiler version. This helps ensure compatibility with the minimum supported Rust version for Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/introduction.mdx#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nrustc --version\n```\n\n----------------------------------------\n\nTITLE: Serving files with Python's http.server\nDESCRIPTION: This command starts a simple HTTP server using Python's built-in `http.server` module. This allows you to serve the built application from your local machine. The server listens on port 8000.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/project-setup/using-wasm-pack.mdx#2025-04-16_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n\"python -m http.server 8000\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Event Hook Interface in Yew\nDESCRIPTION: Initial blueprint for a custom hook named use_event that will handle event listeners. This defines the function signature with appropriate parameters for handling various types of events.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{Event, EventTarget};\nuse std::borrow::Cow;\nuse gloo::events::EventListener;\nuse yew::prelude::*;\n\n#[hook]\npub fn use_event<E, F>(target: &EventTarget, event_type: E, callback: F)\nwhere\n    E: Into<Cow<'static, str>>,\n    F: Fn(&Event) + 'static,\n{\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo.toml Dependencies Update (TOML)\nDESCRIPTION: This snippet shows the updated dependencies in the `Cargo.toml` file. It adds `gloo-net` for making HTTP requests, `serde` for deserializing JSON, and `wasm-bindgen-futures` for working with asynchronous tasks.  These dependencies are necessary to fetch data from an external API.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ngloo-net = \"0.6\"\nserde = { version = \"1.0\", features = [\"derive\"] }\nwasm-bindgen-futures = \"0.4\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Rust Path Resolution in html! Macro\nDESCRIPTION: Examples of how the html! macro resolves paths to prevent naming collisions. The macro uses fully qualified paths like ::yew:: instead of yew:: and explicit trait implementations with <Type as Trait> syntax.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/advanced-topics/how-it-works.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n::yew::<module>\n::alloc::vec::Vec::new()\n<Type as Trait>\n```\n\n----------------------------------------\n\nTITLE: Incorrect Route Order Example in Rust\nDESCRIPTION: This code snippet illustrates an incorrect implementation of the Switch trait where the order of routes can lead to unexpected matching. It demonstrates why more specific routes should be placed before more general ones to ensure proper routing.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.18.0/concepts/router.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Switch)]\nenum AppRoute {\n  #[to=\"/\"]\n  Home,\n  #[to=\"/login\"]\n  Login,\n  #[to=\"/register\"]\n  Register,\n  #[to=\"/delete_account\"]\n  Delete,\n  #[to=\"/posts/{id}\"]\n  ViewPost(i32),\n  #[to=\"/posts/view\"]\n  ViewPosts,\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Event Listener with Closure\nDESCRIPTION: Demonstrates how to manually add a custom event listener using Closure from wasm-bindgen, showing low-level DOM event handling in a Yew component\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/events.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::{prelude::Closure, JsCast};\nuse web_sys::HtmlElement;\nuse yew::prelude::*;\n\n#[function_component]\nfn MyComponent() -> Html {\n    let div_node_ref = use_node_ref();\n\n    use_effect_with_deps(\n        {\n            let div_node_ref = div_node_ref.clone();\n\n            move |_| {\n                let mut custard_listener = None;\n\n                if let Some(element) = div_node_ref.cast::<HtmlElement>() {\n                    let oncustard = Callback::from(move |_: Event| {\n                        // do something about custard..\n                    });\n\n                    let listener =\n                        Closure::<dyn Fn(Event)>::wrap(\n                            Box::new(move |e: Event| oncustard.emit(e))\n                        );\n\n                    element\n                        .add_event_listener_with_callback(\n                            \"custard\",\n                            listener.as_ref().unchecked_ref()\n                        )\n                        .unwrap();\n\n                    custard_listener = Some(listener);\n                }\n\n                move || drop(custard_listener)\n            }\n        },\n        div_node_ref.clone()\n    );\n\n    html! {\n        <div ref={div_node_ref} id=\"my-div\"></div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Trunk with Cargo\nDESCRIPTION: This shell command installs Trunk, a tool for managing deployment and packaging of Yew applications, via Cargo. This includes compiling necessary binaries. Ensure Cargo, the Rust package manager, is installed beforehand.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/getting-started/introduction.mdx#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo install trunk\n```\n\n----------------------------------------\n\nTITLE: Components with Class Properties in Yew\nDESCRIPTION: This snippet defines a Yew component that accepts class properties. It includes a struct for properties, with classes managed using the `Classes` struct from Yew. It initializes component properties and binds them to the class attribute of an HTML element.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/classes.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{\n    classes, html, Children, Classes, Component,\n    Context, Html, Properties\n};\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    #[prop_or_default]\n    class: Classes,\n    fill: bool,\n    children: Children,\n}\n\nstruct MyComponent;\n\nimpl Component for MyComponent {\n    type Message = ();\n    type Properties = Props;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let Props {\n            class,\n            fill,\n            children,\n        } = &ctx.props();\n        html! {\n            <div\n                class={classes!(\n                    \"my-container-class\",\n                    fill.then(|| Some(\"my-fill-class\")),\n                    class.clone(),\n                )}\n            >\n                { children.clone() }\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SVG Example in Yew\nDESCRIPTION: This code snippet demonstrates the use of the `html!` macro to create an SVG graphic within a Yew component. It shows various SVG elements, including `svg`, `path`, `circle`, `g`, `defs`, and `filter`, along with their attributes for styling and positioning. It also showcases the use of dynamic tag names.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/introduction.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <svg width=\"149\" height=\"147\" viewBox=\"0 0 149 147\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n        <path d=\"M60.5776 13.8268L51.8673 42.6431L77.7475 37.331L60.5776 13.8268Z\" fill=\"#DEB819\"/>\n        <path d=\"M108.361 94.9937L138.708 90.686L115.342 69.8642\" stroke=\"black\" stroke-width=\"4\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        <g filter=\"url(#filter0_d)\">\n            <circle cx=\"75.3326\" cy=\"73.4918\" r=\"55\" fill=\"#FDD630\"/>\n            <circle cx=\"75.3326\" cy=\"73.4918\" r=\"52.5\" stroke=\"black\" stroke-width=\"5\"/>\n        </g>\n        <circle cx=\"71\" cy=\"99\" r=\"5\" fill=\"white\" fill-opacity=\"0.75\" stroke=\"black\" stroke-width=\"3\"/>\n        <defs>\n            <filter id=\"filter0_d\" x=\"16.3326\" y=\"18.4918\" width=\"118\" height=\"118\" filterUnits=\"userSpaceOnUse\" color-interpolation-filters=\"sRGB\">\n                <@{\"feGaussianBlur\"} stdDeviation=\"2\"/>\n                <@{\"feColorMatrix\"} in=\"SourceAlpha\" type=\"matrix\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\"/>\n            </filter>\n        </defs>\n    </svg>\n};\n\n```\n\n----------------------------------------\n\nTITLE: SSR Hydration with Yew Renderer\nDESCRIPTION: Illustrates how to hydrate a server-side rendered HTML string with a Yew application on the client-side\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/advanced-topics/server-side-rendering.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew::Renderer;\n\n#[function_component]\nfn App() -> Html {\n    html! {<div>{\"Hello, World!\"}</div>}\n}\n\nfn main() {\n    let renderer = Renderer::<App>::new();\n    renderer.hydrate();\n}\n```\n\n----------------------------------------\n\nTITLE: Running Yew Password Strength Application with Trunk\nDESCRIPTION: Command to start the Trunk development server and launch the password strength estimator application in a browser. The --open flag automatically opens the application in the default web browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/password_strength/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Creating VideoDetails Component in Rust\nDESCRIPTION: Defines a new VideoDetails component to display detailed information about a selected video.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/tutorial/index.mdx#2025-04-16_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nuse website_test::tutorial::Video;\nuse yew::prelude::*;\n\n#[derive(Properties, PartialEq)]\nstruct VideosDetailsProps {\n    video: Video,\n}\n\n#[function_component(VideoDetails)]\nfn video_details(VideosDetailsProps { video }: &VideosDetailsProps) -> Html {\n    html! {\n        <div>\n            <h3>{ video.title.clone() }</h3>\n            <img src=\"https://placehold.co/640x360.png?text=Video+Player+Placeholder\" alt=\"video thumbnail\" />\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Trunk Server Settings\nDESCRIPTION: Creates a Trunk.toml file to customize the server address and port for the Yew application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\n[serve]\n# The address to serve on LAN.\naddress = \"127.0.0.1\"\n# The address to serve on WAN.\n# address = \"0.0.0.0\"\n# The port to serve on.\nport = 8000\n```\n\n----------------------------------------\n\nTITLE: Using `use_reducer` Hook in Yew\nDESCRIPTION: This code demonstrates the usage of the `use_reducer` hook in a Yew function component. The hook manages complex state transitions using a reducer function and a dispatch function. In this example, it manages a counter that can be doubled or squared.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/function-components/pre-defined-hooks.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse std::rc::Rc;\n\n/// reducer's Action\nenum CounterAction {\n    Double,\n    Square,\n}\n\n/// reducer's State\nstruct CounterState {\n    counter: i32,\n}\n\nimpl Default for CounterState {\n    fn default() -> Self {\n        Self { counter: 1 }\n    }\n}\n\nimpl Reducible for CounterState {\n    /// Reducer Action Type\n    type Action = CounterAction;\n\n    /// Reducer Function\n    fn reduce(self: Rc<Self>, action: Self::Action) -> Rc<Self> {\n        let next_ctr = match action {\n            CounterAction::Double => self.counter * 2,\n            CounterAction::Square => self.counter.pow(2)\n        };\n\n        Self { counter: next_ctr }.into()\n    }\n}\n\n#[function_component(UseReducer)]\nfn reducer() -> Html {\n    // The use_reducer hook takes an initialization function which will be called only once.\n    let counter = use_reducer(CounterState::default);\n\n   let double_onclick = {\n        let counter = counter.clone();\n        Callback::from(move |_| counter.dispatch(CounterAction::Double))\n    };\n    let square_onclick = {\n        let counter = counter.clone();\n        Callback::from(move |_| counter.dispatch(CounterAction::Square))\n    };\n\n    html! {\n        <>\n            <div id=\"result\">{ counter.counter }</div>\n\n            <button onclick={double_onclick}>{ \"Double\" }</button>\n            <button onclick={square_onclick}>{ \"Square\" }</button>\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Boids Example with Trunk Development Server in Bash\nDESCRIPTION: This command runs the Boids application using the trunk development server. It sets the RUSTFLAGS environment variable to configure the getrandom backend and opens the application in the default browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/boids/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nRUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"' trunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Accessing Document Object in JavaScript\nDESCRIPTION: Demonstrates how to access the document object from the window in JavaScript.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/js.mdx#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nlet document = window.document\n```\n\n----------------------------------------\n\nTITLE: Running a Yew Application with Trunk Development Server\nDESCRIPTION: Command to launch a Yew application using the Trunk development server with automatic browser opening. This is used to run the async clock example application locally for development.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/async_clock/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Creating a Function Component with Props in Yew\nDESCRIPTION: This code defines a function component `VideosList` in Yew that takes a vector of `Video` structs as props. It iterates through the videos and renders each video's speaker and title in a paragraph element.  The `VideosListProps` struct defines the type of data expected by the component. Requires `yew` crate to be imported.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nstruct Video {\n    id: usize,\n    title: String,\n    speaker: String,\n    url: String,\n}\n\n#[derive(Properties, PartialEq)]\nstruct VideosListProps {\n    videos: Vec<Video>,\n}\n\n#[function_component(VideosList)]\nfn videos_list(VideosListProps { videos }: &VideosListProps) -> Html {\n    videos.iter().map(|video| html! {\n        <p key={video.id}>{format!(\"{}: {}\", video.speaker, video.title)}</p>\n    }).collect()\n}\n```\n\n----------------------------------------\n\nTITLE: Running the Yew application with Trunk\nDESCRIPTION: Command to serve the Yew application using Trunk. This starts a development server that watches for changes and automatically rebuilds the application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve\n```\n\n----------------------------------------\n\nTITLE: Navigate to Project Directory\nDESCRIPTION: Changes directory to the newly created project\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd yew-app\n```\n\n----------------------------------------\n\nTITLE: Using classes! macro with String in Yew\nDESCRIPTION: Demonstrates passing a String object containing multiple classes to the classes! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(String::from(\"class-1 class-2\"))}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Changing to Project Directory\nDESCRIPTION: Navigates to the newly created project directory.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncd yew-app\n```\n\n----------------------------------------\n\nTITLE: Event Handling: `onselectstart` Event\nDESCRIPTION: This event handler is triggered when the user starts a selection. It uses the generic `Event` struct from `web-sys` to indicate the start of the selection process.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/html/events.mdx#2025-04-16_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\n\"onselectstart\"\n```\n\n----------------------------------------\n\nTITLE: Updating Agent Import in Rust/Yew\nDESCRIPTION: Shows how to update the import statement for threaded agents after the separation into PublicAgent and PrivateAgent types. This change affects web worker-based agents which are now classified as Public Agents.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/migration-guides/yew-agent/from-0_1_0-to-0_2_0.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew_agent::PublicAgent;\n```\n\n----------------------------------------\n\nTITLE: Themed Image Component Implementation\nDESCRIPTION: React/JSX code for displaying a themed image component that shows the agent lifecycle diagram with light and dark mode support.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/agents.mdx#2025-04-16_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<ThemedImage\n    alt=\"agent lifecycle diagram\"\n    sources={{\n        light: useBaseUrl('/img/agent-lifecycle-light.svg'),\n        dark: useBaseUrl('/img/agent-lifecycle-dark.svg'),\n    }}\n/>\n```\n\n----------------------------------------\n\nTITLE: If-Let-Else Pattern Matching in Yew\nDESCRIPTION: Shows how to use if-let-else pattern matching for Option types with a fallback case in Yew's html! macro\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/conditional-rendering.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nlet some_text = Some(\"text\");\n\nhtml! {\n    if let Some(text) = some_text {\n        <p>{ text }</p>\n    } else {\n        <p>{ \"False case\" }</p>\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a List Component with Typed Children in Yew - Rust\nDESCRIPTION: This snippet illustrates how to create a List component that only accepts child components of a specific type using 'ChildrenWithProps<Item>'. It defines an Item component as well.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/components/children.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, ChildrenWithProps, Component, Context, Html, Properties};\n\npub struct Item;\n\nimpl Component for Item {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            { \"item\" }\n        }\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: ChildrenWithProps<Item>,\n}\n\npub struct List;\n\nimpl Component for List {\n    type Message = ();\n    type Properties = ListProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"list\">\n                { for ctx.props().children.iter() }\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Yew Application with Trunk Server\nDESCRIPTION: Command to start the trunk development server and automatically open the application in a browser. Trunk is the recommended development server for Yew applications.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/communication_parent_to_child/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Using the html! Macro in Rust for Yew\nDESCRIPTION: Demonstrates basic usage of the `html!` macro in Yew for generating HTML. It shows how to include literal text within the macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.21/concepts/html/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nhtml! { \"Hello, World\" }\n```\n\n----------------------------------------\n\nTITLE: Rendering a Yew Component\nDESCRIPTION: This code snippet demonstrates the `view` lifecycle method, which is responsible for rendering the component's HTML.  It uses the `html!` macro to define the structure and content of the component, and the context to access properties and define event handlers. The snippet shows how to create a button with an onclick event.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nuse yew::{Component, Context, html, Html, Properties};\n\nenum Msg {\n    Click,\n}\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    button_text: String,\n}\n\nstruct MyComponent;\n\nimpl Component for MyComponent {\n    type Message = Msg;\n    type Properties = Props;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    // highlight-start\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let onclick = ctx.link().callback(|_| Msg::Click);\n        html! {\n            <button {onclick}>{ &ctx.props().button_text }</button>\n        }\n    }\n    // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Using the props! Macro in Yew\nDESCRIPTION: Demonstration of Yew's props! macro which provides a concise way to build component properties with the same syntax as struct expressions. The example shows creating LinkProps directly and accessing a component's associated Properties.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/components/properties.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::rc::Rc;\nuse yew::props;\n\nlet props = yew::props!(LinkProps {\n    href: \"/\",\n    text: Rc::from(\"imagine this text being really long\"),\n    size: 64,\n});\n\n// build the associated properties of a component\nlet props = yew::props!(Model::Properties {\n    href: \"/book\",\n    text: Rc::from(\"my bestselling novel\"),\n});\n```\n\n----------------------------------------\n\nTITLE: HTML Property Assignment in Yew\nDESCRIPTION: This code snippet illustrates how to assign a property to an HTML element using the `html!` macro in Yew. Properties are specified using the tilde (`~`) symbol before the property name.  It requires the `yew` crate to be included.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/introduction.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! { <my-element ~property=\"abc\" /> };\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Pure Component in Yew Rust\nDESCRIPTION: Demonstrates how to create a pure function component in Yew that renders different HTML based on a loading prop. The component is pure because it deterministically derives its output from props without side effects.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/function-components/pure-components.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Properties, function_component, Html, html};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub is_loading: bool,\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n    if props.is_loading {\n        html! { \"Loading\" }\n    } else {\n        html! { \"Hello world\" }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Yew Counter Application with Trunk Server\nDESCRIPTION: Command to start the Trunk development server and launch the counter application in a browser. The --open flag automatically opens the application in the default web browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/counter_functional/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Running Yew Two Apps Example with Trunk\nDESCRIPTION: Command to run the Yew Two Apps example using the Trunk development server. This will start the server and open the application in the default web browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/two_apps/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Running Yew Keyed List Example with Trunk\nDESCRIPTION: Command to run the application using the trunk development server with specific Rust flags for WebAssembly random number generation.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/keyed_list/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nRUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"' trunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Building Yew App for Release with Trunk\nDESCRIPTION: Command to build a Yew application in release mode using Trunk. This prepares the app for production deployment.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/more/deployment.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk build --release\n```\n\n----------------------------------------\n\nTITLE: Starting the Development Server for Yew - Bash\nDESCRIPTION: This snippet runs the Trunk command to build and serve the Yew application locally.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Running Game of Life Example in Release Mode\nDESCRIPTION: Command to serve the Game of Life example in release mode for better performance due to its resource-intensive nature.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/game_of_life/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nRUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"' trunk serve --release\n```\n\n----------------------------------------\n\nTITLE: Adding wasm-bindgen Dependency for JsCast in Cargo.toml\nDESCRIPTION: The Cargo.toml configuration showing how to add the wasm-bindgen dependency, which is required for using the JsCast trait when working with event targets in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/events.mdx#2025-04-16_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\n# need wasm-bindgen for JsCast\nwasm-bindgen = \"0.2\"\n```\n\n----------------------------------------\n\nTITLE: Missing Libraries in Yew Ecosystem\nDESCRIPTION: Identifies component wrappers for common CSS frameworks like Bootstrap and Material UI as missing but needed libraries in the Yew ecosystem. This highlights a gap in available tools for Yew developers.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/more/external-libs.mdx#2025-04-16_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\n## Looking For\n\nLibraries that the ecosystem needs, but doesn't have yet.\n\nBootstrap/MaterialUi/arbitrary css framework component wrappers.\n```\n\n----------------------------------------\n\nTITLE: Event Handling: `onshow` Event\nDESCRIPTION: This event handler is triggered when a `<menu>` element is shown. It utilizes the `Event` struct from the `web-sys` crate, indicating when the menu element becomes visible.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/html/events.mdx#2025-04-16_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\n\"onshow\"\n```\n\n----------------------------------------\n\nTITLE: Mouse Movement Example in JavaScript\nDESCRIPTION: JavaScript implementation of mouse movement tracking within an element.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\ndocument.getElementById('mousemoveme').onmousemove = (e) => {\n    // e = Mouse event.\n    var rect = e.target.getBoundingClientRect()\n    var x = e.clientX - rect.left //x position within the element.\n    var y = e.clientY - rect.top //y position within the element.\n    console.log('Left? : ' + x + ' ; Top? : ' + y + '.')\n}\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Instantiation Error Due to Incorrect MIME-Type\nDESCRIPTION: Error message displayed when the server does not serve WebAssembly files with the correct MIME-type (application/wasm). This can lead to slower instantiation or failure to load the WebAssembly module.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/more/deployment.mdx#2025-04-16_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n TypeError: WebAssembly: Response has unsupported MIME type 'text/plain' expected 'application/wasm'\n```\n\n----------------------------------------\n\nTITLE: Implementing Typed Children Components in Yew\nDESCRIPTION: Demonstrates how to create a component that only accepts a specific type of component (Item) as children using ChildrenWithProps<T>. This provides type safety for child components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/components/children.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, ChildrenWithProps, Component, Html, Properties};\n\n// ...\n\n#[derive(Properties, Clone)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: ChildrenWithProps<Item>,\n}\n\npub struct List {\n    props: ListProps,\n}\n\nimpl Component for List {\n    type Properties = ListProps;\n    // ...\n\n    fn view(&self) -> Html {\n        html! {\n            <div class=\"list\">\n                { for self.props.children.iter() }\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Yew Mount Point Example with Trunk Server\nDESCRIPTION: Command to run the mount point example application using the trunk development server, which will open the application in a web browser automatically.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/mount_point/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Implementing Enum-Typed Children in Yew\nDESCRIPTION: Shows how to restrict children to multiple specific component types using an enum. Uses derive_more crate for automatic From implementations and implements Into<Html> for rendering the enum variants.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/components/children.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew:{\n    html, html::ChildrenRenderer, virtual_dom::VChild,\n    Component, Html, Properties\n};\n\n// `derive_more::From` implements `From<VChild<Primary>>` and\n// `From<VChild<Secondary>>` for `Item` automatically!\n#[derive(Clone, derive_more::From)]\npub enum Item {\n    Primary(VChild<Primary>),\n    Secondary(VChild<Secondary>),\n}\n\n// Now, we implement `Into<Html>` so that yew knows how to render `Item`.\nimpl Into<Html> for Item {\n    fn into(self) -> Html {\n        match self {\n            Self::Primary(child) => child.into(),\n            Self::Secondary(child) => child.into(),\n        }\n    }\n}\n\n#[derive(Properties, Clone)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: ChildrenRenderer<Item>,\n}\n\npub struct List {\n    props: ListProps,\n}\n\nimpl Component for List {\n    type Properties = ListProps;\n    // ...\n\n    fn view(&self) -> Html {\n        html! {\n            <div class=\"list\">\n                { for self.props.children.iter() }\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Yew Timer Example with Trunk Development Server\nDESCRIPTION: This command uses the trunk development server to run the Yew Timer Example application and automatically open it in the default web browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/timer/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Component Change Method for Props Update\nDESCRIPTION: Shows how to implement the change() method to handle updates to component properties from parent components\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.21/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nimpl Component for MyComponent {\n    // ...\n\n    fn change(&mut self, props: Self::Properties) -> ShouldRender {\n       self.props = props;\n       true // Always re-render when new props are provided\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Old Component Changed Method Signature\nDESCRIPTION: Previous implementation of the component changed lifecycle method that receives context only.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/migration-guides/yew/from-0_19_0-to-0_20_0.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn changed(&mut self, ctx: &Context<Self>) -> bool\n```\n\n----------------------------------------\n\nTITLE: Generating a Yew Project from Template with Cargo Generate\nDESCRIPTION: Uses cargo-generate to create a new Yew project from a minimal template that includes all the necessary boilerplate for a Yew application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo generate --git https://github.com/yewstack/yew-trunk-minimal-template\n```\n\n----------------------------------------\n\nTITLE: Removing Transferable Trait Implementation in Yew 0.10\nDESCRIPTION: Example demonstrating the removal of the Transferable trait in Yew 0.10, which was replaced with direct usage of serde's Serialize and Deserialize traits.\nSOURCE: https://github.com/yewstack/yew/blob/master/CHANGELOG.md#2025-04-16_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n// Before:\nimpl Transferable for Input {}\n#[derive(Serialize, Deserialize)]\npub enum Input {\n  Connect,\n}\n\n// After:\n#[derive(Serialize, Deserialize)]\npub enum Input {\n  Connect,\n}\n```\n\n----------------------------------------\n\nTITLE: Running Yew Test Suite\nDESCRIPTION: Executes the complete test flow for the Yew framework including browser and fetch service tests\nSOURCE: https://github.com/yewstack/yew/blob/master/CONTRIBUTING.md#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncargo make test-flow\n```\n\n----------------------------------------\n\nTITLE: Example HTML Structure\nDESCRIPTION: This code shows an example HTML structure that the tutorial will convert to compatible code with the `html!` macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_9\n\nLANGUAGE: html\nCODE:\n```\n\"<h1>RustConf Explorer</h1>\n<div>\n    <h3>Videos to watch</h3>\n    <p>John Doe: Building and breaking things</p>\n    <p>Jane Smith: The development process</p>\n    <p>Matt Miller: The Web 7.0</p>\n    <p>Tom Jerry: Mouseless development</p>\n</div>\n<div>\n    <h3>John Doe: Building and breaking things</h3>\n    <img\n        src=\\\"https://placehold.co/640x360.png?text=Video+Player+Placeholder\\\"\n        alt=\\\"video thumbnail\\\"\n    />\n</div>\"\n```\n\n----------------------------------------\n\nTITLE: Running the Yew Portals Example with Trunk Development Server in Bash\nDESCRIPTION: Command to run the Yew portals application using the Trunk development server with automatic browser opening. Trunk is a WASM web application bundler for Rust.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/portals/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Bundling JavaScript with rollup.js\nDESCRIPTION: This command uses rollup.js to bundle the JavaScript wrapper code generated by wasm-pack. The `--format iife` flag specifies that the output should be an immediately invoked function expression. The bundled JavaScript is placed in the `./pkg/bundle.js` file.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/project-setup/using-wasm-pack.mdx#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n\"rollup ./main.js --format iife --file ./pkg/bundle.js\"\n```\n\n----------------------------------------\n\nTITLE: Adding wasm-bindgen Dependency for JsCast in Cargo.toml\nDESCRIPTION: This snippet shows how to add the wasm-bindgen dependency to the Cargo.toml file. It's necessary for using the JsCast trait in the Rust code.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/events.mdx#2025-04-16_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\n# need wasm-bindgen for JsCast\nwasm-bindgen = \"0.2\"\n```\n\n----------------------------------------\n\nTITLE: Running a Yew Application with Trunk Development Server\nDESCRIPTION: Command to run the Yew application using the Trunk development server. The --open flag automatically opens the application in the default browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/dyn_create_destroy_apps/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering with Expressions in Yew\nDESCRIPTION: Shows how to use conditional expressions within Yew HTML templates using if statements. Demonstrates rendering different HTML content based on a boolean condition.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet show_link = true;\n\nhtml! {\n  <div>\n    {\n      if show_link {\n        html! {\n          <a href=\"https://example.com\">{\"Link\"}</a>\n        }\n      } else {\n        html! {}\n      }\n    }\n  </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Simple Yew Component\nDESCRIPTION: This snippet defines a simple Yew component that renders a \"Hello World\" heading. It uses the `yew` crate for creating the component and the `html!` macro for defining the UI.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n\"use yew::prelude::*;\n\n#[function_component(App)]\nfn app() -> Html {\n    html! {\n        <h1>{ \\\"Hello World\\\" }</h1>\n    }\n}\n\nfn main() {\n    yew::Renderer::<App>::new().render();\n}\"\n```\n\n----------------------------------------\n\nTITLE: Removing Threaded Agent in Yew\nDESCRIPTION: This snippet explains the necessary change for users migrating from the old Threaded agent to the new PublicAgent. It mentions that the existing web worker-based agents are Public Agents, clarifying that Private Agents were never supported.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/migration-guides/yew-agent/from-0_1_0-to-0_2_0.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew_agent::PublicAgent;\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Router Configuration in Rust using Yew\nDESCRIPTION: Example showing how to define application routes using an enum with the Switch derive macro. Each route is annotated with a path pattern that can include dynamic segments.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.20/concepts/router.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Switch)]\nenum AppRoute {\n  #[to=\"/login\"]\n  Login,\n  #[to=\"/register\"]\n  Register,\n  #[to=\"/delete_account\"]\n  Delete,\n  #[to=\"/posts/{id}\"]\n  ViewPost(i32),\n  #[to=\"/posts/view\"]\n  ViewPosts,\n  #[to=\"/\"]\n  Home\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing Hardcoded Values with Dynamic Data\nDESCRIPTION: This snippet replaces the hardcoded list of videos with the dynamically generated `Html` from the `videos` vector.  This allows the content of the page to be driven by data.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n\"html! {\n    <>\n        <h1>{ \\\"RustConf Explorer\\\" }</h1>\n        <div>\n            <h3>{ \\\"Videos to watch\\\" }</h3>\n-           <p>{ \\\"John Doe: Building and breaking things\\\" }</p>\n-           <p>{ \\\"Jane Smith: The development process\\\" }</p>\n-           <p>{ \\\"Matt Miller: The Web 7.0\\\" }</p>\n-           <p>{ \\\"Tom Jerry: Mouseless development\\\" }</p>\n+           { videos }\n        </div>\n        // ...\n    </>\n}\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Component Rendered Lifecycle in Yew\nDESCRIPTION: Example showing the rendered lifecycle method implementation which is called after the view has been rendered to the DOM. Demonstrates focus handling on first render.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::{\n    Component, Context, html, Html, NodeRef,\n};\n\npub struct MyComponent {\n    node_ref: NodeRef,\n}\n\nimpl Component for MyComponent {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            node_ref: NodeRef::default(),\n        }\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <input ref={self.node_ref.clone()} type=\"text\" />\n        }\n    }\n\n    fn rendered(&mut self, _ctx: &Context<Self>, first_render: bool) {\n        if first_render {\n            if let Some(input) = self.node_ref.cast::<HtmlInputElement>() {\n                input.focus();\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding History Listener in Yew Struct Components\nDESCRIPTION: Example demonstrating how to add a history listener to struct components to react to route changes. The listener needs to be stored in component state to prevent automatic unregistration.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/router.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn create(ctx: &Context<Self>) -> Self {\n    let listener = ctx.link()\n        .add_history_listener(ctx.link().callback(\n            // handle event\n        ))\n        .unwrap();\n    MyComponent {\n        _listener: listener\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Initial Rust Project\nDESCRIPTION: Compiles and runs the initial 'Hello World' Rust project to verify the environment setup.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncargo run\n# output: Hello World!\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Children Components in Yew\nDESCRIPTION: Basic implementation of a List component that accepts generic children. Uses the Children type from Yew to allow any valid child components to be rendered.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/advanced-topics/children.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Children, Component, Context, Html, Properties};\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: Children,\n}\n\npub struct List;\n\nimpl Component for List {\n    type Message = ();\n    type Properties = ListProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"list\">\n                { for ctx.props().children.iter() }\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using NodeRefs for DOM Access in Rust with Yew\nDESCRIPTION: This code snippet demonstrates the complete lifecycle of using refs in Yew: creating a NodeRef, attaching it to a DOM element in the view method, and then accessing the DOM element to check its attributes.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.20/advanced-topics/struct-components/refs.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// 建立\nself.node_ref = NodeRef::default();\n\n// 在 view 裡\nhtml! {\n    <div ref={self.node_ref.clone()}></div>\n}\n\n// 更新\nlet has_attributes = self.node_ref.cast::<Element>().unwrap().has_attributes();\n```\n\n----------------------------------------\n\nTITLE: Using the props! Macro in Yew for Creating Component Properties\nDESCRIPTION: This example shows how to use the yew::props! macro to build properties with the same syntax as struct expressions. It includes a utility method that creates LinkProps with specific values while using the props! macro to simplify property initialization.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/struct-components/properties.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{props, Properties, virtual_dom::AttrValue};\n\n#[derive(Clone, PartialEq)]\npub enum LinkColor {\n    Blue,\n    Red,\n    Green,\n    Black,\n    Purple,\n}\n\nfn create_default_link_color() -> LinkColor {\n    LinkColor::Blue\n}\n\n#[derive(Properties, PartialEq)]\npub struct LinkProps {\n    /// The link must have a target.\n    href: AttrValue,\n    /// Also notice that we're using AttrValue instead of String\n    text: AttrValue,\n    /// Color of the link. Defaults to `Blue`.\n    #[prop_or_else(create_default_link_color)]\n    color: LinkColor,\n    /// The view function will not specify a size if this is None.\n    #[prop_or_default]\n    size: Option<u32>,\n    /// When the view function doesn't specify active, it defaults to true.\n    #[prop_or(true)]\n    active: bool,\n}\n\nimpl LinkProps {\n    /// Notice that this function receives href and text as String\n    /// We can use `AttrValue::from` to convert it to a `AttrValue`\n    pub fn new_link_with_size(href: String, text: String, size: u32) -> Self {\n        // highlight-start\n        props! {LinkProps {\n            href: AttrValue::from(href),\n            text: AttrValue::from(text),\n            size,\n        }}\n        // highlight-end\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Switch implementation showing route order importance\nDESCRIPTION: This example demonstrates how route order matters in the Switch implementation. Since routes are matched in order, more specific routes should come before more general routes to avoid shadowing.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/router.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew_router::Switch;\n\n#[derive(Switch)]\nenum AppRoute {\n  #[to=\"/\"]\n  Home,\n  #[to=\"/login\"]\n  Login,\n  #[to=\"/register\"]\n  Register,\n  #[to=\"/delete_account\"]\n  Delete,\n  #[to=\"/posts/{id}\"]\n  ViewPost(i32),\n  #[to=\"/posts/view\"]\n  ViewPosts,\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Yew Component with Callback\nDESCRIPTION: Demonstrates creating a Yew component with an onclick callback and handling component lifecycle events\nSOURCE: https://github.com/yewstack/yew/blob/master/CHANGELOG.md#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyComponent {\n    onclick: Callback<ClickEvent>,\n}\n\nenum Msg {\n    Click,\n}\n\nimpl Component for MyComponent {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_: Self::Properties, link: ComponentLink<Self>) -> Self {\n        MyComponent {\n            onclick: link.callback(|_| Msg::Click),\n        }\n    }\n\n    fn update(&mut self, msg: Self::Message) -> ShouldRender {\n        match msg {\n            Msg::Click => true,\n        }\n    }\n\n    fn view(&self) -> Html {\n        html! {\n            <button onclick=&self.onclick>{ \"Click me!\" }</button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Yew Template Using Cargo Generate\nDESCRIPTION: Command to generate a new Yew project using the minimal template\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo generate --git https://github.com/yewstack/yew-trunk-minimal-template\n```\n\n----------------------------------------\n\nTITLE: Gloo Dependency Configuration\nDESCRIPTION: Cargo.toml configuration for adding gloo-events library to project dependencies\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/html/events.mdx#2025-04-16_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ngloo-events = \"0.1\"\n```\n\n----------------------------------------\n\nTITLE: Running Cargo Project\nDESCRIPTION: This command runs the initial project created by Cargo. It is used to verify that the Rust environment is set up correctly.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n\"cargo run\"\n```\n\n----------------------------------------\n\nTITLE: Running SSR Server with Cargo\nDESCRIPTION: Command to start the server with SSR features enabled. The server is run with the --features=ssr flag and takes a --dir parameter pointing to the dist directory containing built assets.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/simple_ssr/README.md#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo run --features=ssr --bin simple_ssr_server -- --dir dist\n```\n\n----------------------------------------\n\nTITLE: Single-Threaded SSR with LocalServerRenderer for WASI\nDESCRIPTION: Demonstrates server-side rendering using LocalServerRenderer, specifically designed for single-threaded environments like WASI\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/advanced-topics/server-side-rendering.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew::LocalServerRenderer;\n\n#[function_component]\nfn App() -> Html {\n    html! {\n        <>\n            <h1>{\"Yew WASI SSR demo\"}</h1>\n        </>\n    }\n}\n\npub async fn render() -> String {\n    let renderer = LocalServerRenderer::<App>::new();\n    let html_raw = renderer.render().await;\n\n    let mut body = String::new();\n    body.push_str(\"<body>\");\n    body.push_str(\"<div id='app'>\");\n    body.push_str(&html_raw);\n    body.push_str(\"</div>\");\n    body.push_str(\"</body>\");\n\n    body\n}\n\n#[tokio::main(flavor = \"current_thread\")]\nasync fn main() {\n    println!(\"{}\", render().await);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Trunk Server Options - TOML\nDESCRIPTION: This snippet configures the Trunk server settings such as address and port in Trunk.toml.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/tutorial/index.mdx#2025-04-16_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\n[serve]\n# The address to serve on LAN.\naddress = \"127.0.0.1\"\n# The address to serve on WAN.\n# address = \"0.0.0.0\"\n# The port to serve on.\nport = 8000\n```\n\n----------------------------------------\n\nTITLE: Defining Props with Derive Macro in Rust for Yew\nDESCRIPTION: Demonstrates how to define a properties struct using the #[derive(Properties)] macro in Yew. It shows various field attributes for default values and optional props, and implements PartialEq for efficient change detection.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/advanced-topics/struct-components/properties.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::Properties;\n/// 从 virtual_dom 中导入 AttrValue\nuse yew::virtual_dom::AttrValue;\n\n#[derive(Clone, PartialEq)]\npub enum LinkColor {\n    Blue,\n    Red,\n    Green,\n    Black,\n    Purple,\n}\n\nfn create_default_link_color() -> LinkColor {\n    LinkColor::Blue\n}\n\n#[derive(Properties, PartialEq)]\npub struct LinkProps {\n    /// 链接必须有一个目标\n    href: AttrValue,\n    /// 还要注意我们使用的是 AttrValue 而不是 String\n    text: AttrValue,\n    /// 链接的颜色，默认为 `Blue`\n    #[prop_or_else(create_default_link_color)]\n    color: LinkColor,\n    /// 如果值为 None，则视图函数不会指定大小\n    #[prop_or_default]\n    size: Option<u32>,\n    /// 当视图函数没有指定活动时，默认为 true\n    #[prop_or(true)]\n    active: bool,\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional HTML Rendering in Yew using Rust Expressions\nDESCRIPTION: Shows how to conditionally render HTML elements using Rust expressions with `{}` blocks in Yew. It presents a basic control flow mechanism to show an anchor tag based on a boolean flag, useful for creating dynamic views. Requires `yew` crate for HTML rendering.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nlet show_link = true;\n\nhtml! {\n  <div>\n    {\n      if show_link {\n        html! {\n          <a href=\"https://example.com\">{\"Link\"}</a>\n        }\n      } else {\n        html! {}\n      }\n    }\n  </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Create New Rust Project\nDESCRIPTION: Initializes a new Rust project using cargo\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo new yew-app\n```\n\n----------------------------------------\n\nTITLE: Creating DOM Nodes Manually in Yew using web-sys\nDESCRIPTION: Demonstrates how to create DOM elements using web-sys, convert them to Nodes, and use them in Yew components. This is useful when integrating with JS libraries that might conflict with Yew's managed components.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/elements.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::{Element, Node};\nuse yew::prelude::*;\nuse gloo::utils::document;\n\n#[function_component]\nfn MyComponent() -> Html {\n    // memoize as this only needs to be executed once\n    let node = use_memo(\n        (),\n        |_| {\n            // Create a div element from the document\n            let div: Element = document().create_element(\"div\").unwrap();\n            // Add content, classes etc.\n            div.set_inner_html(\"Hello, World!\");\n            // Convert Element into a Node\n            let node: Node = div.into();\n            // Return that Node as a Html value\n            Html::VRef(node)\n        },\n    );\n\n    // use_memo return Rc so we need to deref and clone\n    (*node).clone()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Run Initial Project\nDESCRIPTION: Verifies the Rust environment setup by running the default project\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncargo run\n# output: Hello World!\n```\n\n----------------------------------------\n\nTITLE: 处理HTML逻辑值属性 - Rust\nDESCRIPTION: 展示如何在Yew中处理HTML的逻辑值属性（如checked、hidden、required）。这些属性需要设置为布尔值，并且可以使用逻辑表达式。\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/html/elements.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <div hidden=true>\n        { \"This div is hidden.\" }\n    </div>\n};\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet no = 1 + 1 != 2;\n\nhtml! {\n    <div hidden={no}>\n        { \"This div is NOT hidden.\" }\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Complex Callback Reformation in Yew Component\nDESCRIPTION: Shows advanced callback usage with reform method for transforming event types in a Yew component\nSOURCE: https://github.com/yewstack/yew/blob/master/CHANGELOG.md#2025-04-16_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\npub struct ListHeader {\n    props: Props,\n}\n\n#[derive(Properties, Clone)]\npub struct Props {\n    #[props(required)]\n    pub on_hover: Callback<Hovered>,\n    #[props(required)]\n    pub text: String,\n}\n\nimpl Component for ListHeader {\n    type Message = ();\n    type Properties = Props;\n\n    fn create(props: Self::Properties, _: ComponentLink<Self>) -> Self {\n        ListHeader { props }\n    }\n\n    fn update(&mut self, _: Self::Message) -> ShouldRender {\n        false\n    }\n\n    fn view(&self) -> Html {\n        let onmouseover = self.props.on_hover.reform(|_| Hovered::Header);\n        html! {\n            <div class=\"list-header\" onmouseover=onmouseover>\n                { &self.props.text }\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Yew Development Server with Trunk\nDESCRIPTION: Command to run the application using the Trunk development server with automatic browser opening. Note that content generation may be slower in debug builds, so release mode is recommended for better performance.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/function_router/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Updating Callback Syntax in Yew Components (Rust)\nDESCRIPTION: Demonstrates the changes required to update callback syntax in Yew components. The new approach requires explicitly creating callbacks using ComponentLink.\nSOURCE: https://github.com/yewstack/yew/blob/master/CHANGELOG.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyComponent {\n  link: ComponentLink<Self>,\n}\n\nenum Msg {\n    Click,\n}\n\nimpl Component for MyComponent {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_: Self::Properties, link: ComponentLink<Self>) -> Self {\n        MyComponent { link }\n    }\n\n    fn update(&mut self, msg: Self::Message) -> ShouldRender {\n        match msg {\n            Msg::Click => true,\n        }\n    }\n\n    fn view(&self) -> Html {\n        // AFTER: Callbacks need to be explicitly created now\n        let onclick = self.link.callback(|_| Msg::Click);\n        html! {\n            <button onclick=onclick>{ \"Click me!\" }</button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building WASI SSR Module with Cargo\nDESCRIPTION: Command to build the WASI SSR Module example targeting WebAssembly System Interface (WASI). This compiles the Rust code to wasm32-wasip1 target with release optimization.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/wasi_ssr_module/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo build --manifest-path examples/wasi_ssr_module/Cargo.toml --target wasm32-wasip1 --release\n```\n\n----------------------------------------\n\nTITLE: Yew App Dependencies in Cargo.toml\nDESCRIPTION: This snippet defines the dependencies for a Yew application in the `Cargo.toml` file. It specifies the `yew` crate with the `csr` feature enabled, which enables client-side rendering.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n\"[package]\nname = \\\"yew-app\\\"\nversion = \\\"0.1.0\\\"\nedition = \\\"2021\\\"\n\n[dependencies]\nyew = { git = \\\"https://github.com/yewstack/yew/\\\", features = [\\\"csr\\\"] }\"\n```\n\n----------------------------------------\n\nTITLE: Adding yew-router Dependency in Cargo.toml\nDESCRIPTION: Shows how to add the yew-router crate as a dependency in your Cargo.toml file using git reference.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/router.mdx#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\nyew-router = { git = \"https://github.com/yewstack/yew.git\" }\n```\n\n----------------------------------------\n\nTITLE: Using NodeRef::get with JsCast in Yew\nDESCRIPTION: This snippet shows an alternative way to convert a Node reference to a specific HTML element type using NodeRef::get and JsCast in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::JsCast;\nuse web_sys::HtmlInputElement;\nuse yew::NodeRef;\n\nfn with_jscast(node_ref: NodeRef) {\n    if let Some(input) = node_ref\n        .get()\n        .and_then(|node| node.dyn_into::<HtmlInputElement>().ok()) {\n        // 在这里处理 HtmlInputElement\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Yew Dependencies in Cargo.toml\nDESCRIPTION: Shows how to specify Yew dependencies with either 'web_sys' or 'std_web' features in Cargo.toml.\nSOURCE: https://github.com/yewstack/yew/blob/master/CHANGELOG.md#2025-04-16_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n# Choose `stdweb`\nyew = { version = \"0.13\", features = [\"std_web\"] }\n\n# Choose `web-sys`\nyew = { version = \"0.13\", features = [\"web_sys\"] }\n```\n\n----------------------------------------\n\nTITLE: Gloo Event Listener Configuration\nDESCRIPTION: Demonstrates a more concise method of adding custom event listeners using the gloo-events library in a Yew function component, with simplified event handling\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/html/events.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlElement;\nuse yew::prelude::*;\n\nuse gloo::events::EventListener;\n\n#[function_component]\nfn MyComponent() -> Html {\n    let div_node_ref = use_node_ref();\n\n    use_effect_with(\n        div_node_ref.clone(),\n        {\n            let div_node_ref = div_node_ref.clone();\n\n            move |_| {\n                let mut custard_listener = None;\n\n                if let Some(element) = div_node_ref.cast::<HtmlElement>() {\n                    let oncustard = Callback::from(move |_: Event| {\n                        // 對 custard 做點什麼..\n                    });\n\n                    let listener = EventListener::new(\n                        &element,\n                        \"custard\",\n                        move |e| oncustard.emit(e.clone())\n                    );\n\n                    custard_listener = Some(listener);\n                }\n\n                move || drop(custard_listener)\n            }\n        }\n    );\n\n    html! {\n        <div ref={div_node_ref} id=\"my-div\"></div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Yew Suspense Example with Trunk Development Server\nDESCRIPTION: Command to serve and open the Yew Suspense example application using the Trunk development server. This will compile and run the project, automatically opening it in the default web browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/suspense/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Creating a New Yew Project with Cargo\nDESCRIPTION: Commands to create a new Cargo project for a Yew application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/tutorial/index.mdx#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo new yew-app\ncd yew-app\n```\n\n----------------------------------------\n\nTITLE: Updating Cargo.toml for yew-stdweb Compatibility (TOML)\nDESCRIPTION: Demonstrates how to update the Cargo.toml file to use the yew-stdweb package for stdweb compatibility.\nSOURCE: https://github.com/yewstack/yew/blob/master/CHANGELOG.md#2025-04-16_snippet_2\n\nLANGUAGE: TOML\nCODE:\n```\nyew = { version = \"0.15\", package = \"yew-stdweb\" }\n```\n\n----------------------------------------\n\nTITLE: Restarting Trunk Server with Proxy Backend (Bash)\nDESCRIPTION: This snippet shows the command to restart the `trunk` development server with a proxy backend.  The `--proxy-backend` option tells `trunk` to forward requests to the specified URL. This is used to avoid CORS issues during development by proxying requests to the external API.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --proxy-backend=https://yew.rs/tutorial\n```\n\n----------------------------------------\n\nTITLE: Using spawn_local with async functions in WebAssembly\nDESCRIPTION: Demonstrates how to execute an async function in WebAssembly using spawn_local from wasm-bindgen-futures. The example shows creating an async function, awaiting its result, modifying the result, and logging it to the console.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/basic-web-technologies/wasm-bindgen.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::console;\nuse wasm_bindgen_futures::spawn_local;\n\nasync fn my_async_fn() -> String { String::from(\"Hello\") }\n\nspawn_local(async {\n    let mut string = my_async_fn().await;\n    string.push_str(\", world!\");\n    // console log \"Hello, world!\"\n    console::log_1(&string.into());\n});\n```\n\n----------------------------------------\n\nTITLE: Conditional HTML Rendering in Yew\nDESCRIPTION: This snippet shows how to use Rust's `if` statement within the Yew HTML macro to conditionally render HTML elements. The `show_link` variable determines whether the link is rendered, showcasing dynamic HTML generation based on runtime conditions. It relies on the Yew framework and a boolean variable.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.20/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nhtml! {\n  <div>\n    {\n      if show_link {\n        html! {\n          <a href=\"https://example.com\">{\"Link\"}</a>\n        }\n      } else {\n        html! {}\n      }\n    }\n  </div>\n}\n```\n\n----------------------------------------\n\nTITLE: Building Web Applications with Cargo Web\nDESCRIPTION: This command is used to build client web applications using 'cargo web'. It ensures that the project is compiled and ready for deployment.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/project-setup/using-cargo-web.mdx#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo web build\n```\n\n----------------------------------------\n\nTITLE: Yew Hook Usage Example Before Migration\nDESCRIPTION: An example of how the use_effect_with_dep hook was used before the migration. It demonstrates the need to extract the id in advance due to ownership issues.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/migration-guides/yew/from-0_20_0-to-next.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nimpl SomeLargeStruct {\n    fn id(&self) -> u32; // Only need to use the id as cache key\n}\nlet some_dep: SomeLargeStruct = todo!();\n\n{\n    let id = some_dep.id(); // Have to extract it in advance, some_dep is moved already in the second argument\n    use_effect_with_dep(move |_| { todo!(); drop(some_dep); }, id);\n}\n```\n\n----------------------------------------\n\nTITLE: Running Yew Examples with the rand Crate\nDESCRIPTION: This command shows how to run Yew examples that use the rand crate, which requires setting a special Rust flag to enable the correct random number generation backend for WebAssembly.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/README.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nRUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"' trunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Adding Yew to Cargo Dependencies\nDESCRIPTION: The snippet shows how to add the Yew library as a dependency in the Cargo.toml file. Yew is a modern Rust framework for creating multi-threaded front-end web apps with WebAssembly. No additional setup is required.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"yew-app\"\nversion = \"0.1.0\"\nedition = \"2018\"\n\n[dependencies]\n# you can check the latest version here: https://crates.io/crates/yew\nyew = \"0.19\"\n```\n\n----------------------------------------\n\nTITLE: Yewtil Library Description\nDESCRIPTION: Describes the Yewtil library and its various utilities for Yew development, including NeqAssign, PureComponents, Lrc, Mrc/Irc, History, Futures, and Fetch. This highlights common tools and patterns useful in Yew applications.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/more/external-libs.mdx#2025-04-16_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n### Yewtil\n\nYewtil is a collection of common utilities that help you build applications using Yew. It includes:\n\n- NeqAssign - This is described in more detail in the section on\n  [optimizations and best practices](../advanced-topics/optimizations.mdx) and ensures that identical\n  sets of props don't cause a component to re-render.\n\n- PureComponents - Components that don't update any of their state. Using NeqAssign under the hood, they act as memoized\n  functions that are called from inside the `html!` macro like normal components are.\n\n- Lrc - linked list reference counted smart pointer functions like `Rc` does, but allows for novel data update patterns.\n- Mrc/Irc - Mutable/Immutable reference counted smart pointers that function like `Rc` but are more ergonomic to use\n\n    within Yew, because they implement `DerefMut` and `BorrowMut`for `Mrc`. This allows `Mrc` to be used with `NeqAssign`.\n\n    `Irc` acts as an immutable view of the data, which makes this ideal for holding data used in display-only tasks.\n\n- History - A history tracking wrapper that uses a `VecDeque` to hold on to previous values that it\n  has represented.\n- Futures - Support for running futures that send messages to component update loops.\n- Fetch - A wrapper around `web_sys` to make HTTP requests.\n```\n\n----------------------------------------\n\nTITLE: Using Yew's props! Macro to Build Properties\nDESCRIPTION: Demonstrates how to use the props! macro to build properties with the same syntax as the html! macro, allowing for pre-made props that can be reused.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/function-components/properties.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    #[prop_or_default]\n    pub is_loading: bool,\n    #[prop_or(AttrValue::Static(\"Bob\"))]\n    pub name: AttrValue,\n}\n\n#[function_component]\nfn Hello(&Props { is_loading, ref name }: &Props) -> Html {\n    if is_loading {\n        html! { \"Loading\" }\n    } else {\n        html! { <>\"Hello \"{name}</> }\n    }\n}\n\n#[function_component]\nfn App() -> Html {\n    let pre_made_props = yew::props! {\n        Props {} // Notice we did not need to specify name prop\n    };\n    html! { <Hello ..pre_made_props /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the use_event Hook\nDESCRIPTION: This snippet provides a complete implementation of the `use_event` custom hook using `use_effect_with`. The hook takes an `EventTarget`, an event type, and a callback function. It creates an event listener and ensures proper cleanup by dropping the listener when the component is unmounted or the dependencies change.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/function-components/hooks/custom-hooks.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse web_sys::{Event, EventTarget};\nuse std::borrow::Cow;\nuse std::rc::Rc;\nuse gloo::events::EventListener;\n\n#[hook]\npub fn use_event<E, F>(target: &EventTarget, event_type: E, callback: F)\nwhere\n    E: Into<Cow<'static, str>>,\n    F: Fn(Event) + 'static,\n{\n    #[derive(PartialEq, Clone)]\n    struct EventDependents {\n        target: EventTarget,\n        event_type: Cow<'static, str>,\n        callback: Callback<Event>,\n    }\n\n    let deps = EventDependents {\n        target: target.clone(),\n        event_type: event_type.into(),\n        callback: Callback::from(callback),\n    };\n\n    use_effect_with(\n        deps,\n        |deps| {\n            let EventDependents {\n                target,\n                event_type,\n                callback,\n            } = deps.clone();\n\n            let listener = EventListener::new(&target, event_type, move |e| {\n                callback.emit(e.clone());\n            });\n\n            move || {\n                drop(listener);\n            }\n        },\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Running Memory Game with Trunk Development Server\nDESCRIPTION: Command to run the Memory Game application using the trunk development server with specific Rust flags for wasm compatibility.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/function_memory_game/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nRUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"' trunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Configure Cargo Dependencies\nDESCRIPTION: Cargo.toml configuration adding Yew as a dependency with CSR feature\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"yew-app\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nyew = { version = \"0.20.0\", features = [\"csr\"] }\n```\n\n----------------------------------------\n\nTITLE: Building Website for Production\nDESCRIPTION: Command to generate static content into the build directory which can then be served using any static contents hosting service.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/README.md#2025-04-16_snippet_2\n\nLANGUAGE: console\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Listeners in Yew Components\nDESCRIPTION: Shows different approaches to implementing event listeners in Yew components, including component handlers, agent handlers, and callbacks.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.20/concepts/html/elements.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyComponent {\n    link: ComponentLink<Self>,\n}\n\nenum Msg {\n    Click,\n}\n\nimpl Component for MyComponent {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_: Self::Properties, link: ComponentLink<Self>) -> Self {\n        MyComponent { link }\n    }\n\n    fn update(&mut self, msg: Self::Message) -> ShouldRender {\n        match msg {\n            Msg::Click => {\n                // 处理 Click\n            }\n        }\n    }\n\n    fn view(&self) -> Html {\n        // 从组件 link 中创建回调来在组件中处理它\n        let click_callback = self.link.callback(|_: ClickEvent| Msg::Click);\n        html! {\n            <button onclick={click_callback}>\n                { \"Click me!\" }\n            </button>\n        }\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyComponent {\n    worker: Dispatcher<MyWorker>,\n}\n\nimpl Component for MyComponent {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_: Self::Properties, _: ComponentLink<Self>) -> Self {\n        MyComponent {\n            worker: MyWorker::dispatcher()\n        }\n    }\n\n    fn update(&mut self, _: Self::Message) -> ShouldRender {\n        false\n    }\n\n    fn view(&self) -> Html {\n        // 从 worker 中创建回调来在另一个上下文中处理它\n        let click_callback = self.worker.callback(|_: ClickEvent| WorkerMsg::Process);\n        html! {\n            <button onclick={click_callback}>\n                { \"Click me!\" }\n            </button>\n        }\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyComponent;\n\nimpl Component for MyComponent {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_: Self::Properties, _: ComponentLink<Self>) -> Self {\n        MyComponent\n    }\n\n    fn update(&mut self, _: Self::Message) -> ShouldRender {\n        false\n    }\n\n    fn view(&self) -> Html {\n        // 创建一个短暂的回调\n        let click_callback = Callback::from(|| {\n            ConsoleService::log(\"clicked!\");\n        });\n\n        html! {\n            <button onclick={click_callback}>\n                { \"Click me!\" }\n            </button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting the Development Server\nDESCRIPTION: Command to build and serve the Yew application locally using Trunk, with the --open flag to automatically open the application in a browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Running Yew File Upload Example with Trunk\nDESCRIPTION: This command uses the Trunk development server to run and open the Yew file upload example application in a web browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/file_upload/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: HTML Template Setup\nDESCRIPTION: Basic HTML template for the Yew application\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/tutorial/index.mdx#2025-04-16_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<!doctype html>\n<html lang=\"en\">\n    <head> </head>\n    <body></body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Initializing wasm-logger for Rust Logging in Yew\nDESCRIPTION: Sets up the wasm-logger crate to enable logging in Yew applications. This integrates with Rust's log crate for consistent logging across the application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.18.0/more/debugging.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// セットアップ\nfn main() {\n    wasm_logger::init(wasm_logger::Config::default());\n}\n\n// 使用方法\nlog::info!(\"Update: {:?}\", msg);\n```\n\n----------------------------------------\n\nTITLE: Mouse Position Tracking with web-sys in Rust\nDESCRIPTION: Rust implementation of the mouse position tracking example using web-sys directly. Uses Closure to create an event handler, accesses DOM elements, and calculates relative mouse coordinates by manipulating Web API objects from Rust.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/wasm-bindgen/web-sys.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::{prelude::Closure, JsCast};\nuse web_sys::{console, Document, HtmlElement, MouseEvent};\n\nlet mousemove = Closure::<dyn Fn(MouseEvent)>::wrap(Box::new(|e| {\n    let rect = e\n        .target()\n        .expect(\"mouse event doesn't have a target\")\n        .dyn_into::<HtmlElement>()\n        .expect(\"event target should be of type HtmlElement\")\n        .get_bounding_client_rect();\n    let x = (e.client_x() as f64) - rect.left();\n    let y = (e.client_y() as f64) - rect.top();\n    console::log_1(&format!(\"Left? : {} ; Top? : {}\", x, y).into());\n}));\n\nDocument::new()\n    .expect(\"global document not set\")\n    .get_element_by_id(\"mousemoveme\")\n    .expect(\"element with id `mousemoveme` not present\")\n    .unchecked_into::<HtmlElement>()\n    .set_onmousemove(mousemove.as_ref().dyn_ref());\n\n// we now need to save the `mousemove` Closure so that when\n// this event fires the closure is still in memory.\n```\n\n----------------------------------------\n\nTITLE: Using `use_ref` Hook in Yew\nDESCRIPTION: This code demonstrates the usage of the `use_ref` hook in a Yew function component.  The hook allows the component to bridge an agent using `yew_agent` and update a greeting message when a new message is received.  The `EventBus::bridge` method returns a Bridged object that is stored in the `use_ref` hook, thus keeping it alive as long as the component lives.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/function-components/pre-defined-hooks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// EventBus is an implementation of yew_agent::Agent\nuse website_test::agents::EventBus;\nuse yew::{function_component, html, use_ref, use_state, Callback};\nuse yew_agent::Bridged;\n\n#[function_component(UseRef)]\nfn ref_hook() -> Html {\n    let greeting = use_state(|| \"No one has greeted me yet!\".to_owned());\n\n    {\n        let greeting = greeting.clone();\n        use_ref(|| EventBus::bridge(Callback::from(move |msg| {\n            greeting.set(msg);\n        })));\n    }\n\n    html! {\n        <div>\n            <span>{ (*greeting).clone() }</span>\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Website Dependencies\nDESCRIPTION: Command to install the necessary npm dependencies for the Yew website.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/README.md#2025-04-16_snippet_0\n\nLANGUAGE: console\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Running Yew Project with Trunk\nDESCRIPTION: Command to serve the Yew application using Trunk development server\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ntrunk serve\n```\n\n----------------------------------------\n\nTITLE: Overriding Children with `..props`\nDESCRIPTION: This code demonstrates how to use the `..props` syntax to pass properties to a component, including overriding the `children` property.  A base set of properties is created, and then the `..props` syntax is used to apply them to the `Container` component, while also specifying a new set of children that will override the original `children` in `props`.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/components.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    id: String,\n    children: Html,\n}\n\n#[function_component]\nfn Container(props: &Props) -> Html {\n    html! {\n        <div id={props.id.clone()}>\n            { props.children.clone() }\n        </div>\n    }\n}\n\nlet props = yew::props!(Props {\n    id: \"container-2\",\n    children: Html::default(),\n});\n\nhtml! {\n    <Container ..props>\n        // 子元素将覆盖 props.children\n        <span>{ \"I am a child, as you can see\" }</span>\n    </Container>\n};\n```\n\n----------------------------------------\n\nTITLE: Incorrect Route Definition\nDESCRIPTION: This code snippet highlights a common mistake when defining routes using the `Switch` derive macro in Yew.  Due to the order of route definitions, the `AppRoute::Home` variant, which matches the root path (\"/\"), will always be matched first, preventing any subsequent routes from being reached. This is because the macro attempts to match each variable in order.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.21/concepts/router.mdx#2025-04-16_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n```rust\n#[derive(Switch)]\nenum AppRoute {\n  #[to=\"/\"]\n  Home,\n  #[to=\"/login\"]\n  Login,\n  #[to=\"/register\"]\n  Register,\n  #[to=\"/delete_account\"]\n  Delete,\n  #[to=\"/posts/{id}\"]\n  ViewPost(i32),\n  #[to=\"/posts/view\"]\n  ViewPosts,\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Yew Component Infinite Loop\nDESCRIPTION: This code snippet demonstrates how an infinite loop can occur in Yew's lifecycle methods. The `rendered` method sends a message to the component, which triggers an update, causing the component to re-render, and thus calling the `rendered` method again. This creates a loop if not handled carefully.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nuse yew::{Context, Component, Html};\n\nstruct Comp;\n\nimpl Component for Comp {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn update(&mut self, _ctx: &Context<Self>, _msg: Self::Message) -> bool {\n        // 我们总是请求在任何消息上重新渲染\n        true\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        // 无论渲染什么都不重要\n        Html::default()\n    }\n\n    fn rendered(&mut self, ctx: &Context<Self>, _first_render: bool) {\n        // 请求使用此新消息更新组件\n        ctx.link().send_message(());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Yew Suspense Component Usage with Function Components\nDESCRIPTION: This snippet demonstrates the basic usage of the `Suspense` component with function components in Yew. It defines a `Content` component that uses a `use_user` hook to fetch user data, and an `App` component that wraps `Content` with `Suspense`, providing a fallback UI while the user data is loading. The `fallback` property defines the HTML to display while the `Content` component is suspended.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/suspense.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[function_component(Content)]\nfn content() -> HtmlResult {\n    let user = use_user()?;\n\n    Ok(html! {<div>{\"Hello, \"}{&user.name}</div>})\n}\n\n#[function_component(App)]\nfn app() -> Html {\n    let fallback = html! {<div>{\"Loading...\"}</div>};\n\n    html! {\n        <Suspense {fallback}>\n            <Content />\n        </Suspense>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Properties for a Link Component in Rust\nDESCRIPTION: This code snippet demonstrates how to implement properties for a link component using the Yew framework. It includes custom types, default implementations, and various property attributes to control behavior and default values.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.21/advanced-topics/struct-components/properties.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::rc::Rc;\nuse yew::Properties;\n\n#[derive(Clone, PartialEq)]\npub enum LinkColor {\n    Blue,\n    Red,\n    Green,\n    Black,\n    Purple,\n}\n\nimpl Default for LinkColor {\n    fn default() -> Self {\n        // The link color will be blue unless otherwise specified.\n        LinkColor::Blue\n    }\n}\n\n#[derive(Properties, Clone, PartialEq)]\npub struct LinkProps {\n    /// The link must have a target.\n    href: String,\n    /// If the link text is huge, this will make copying the string much cheaper.\n    /// This isn't usually recommended unless performance is known to be a problem.\n    text: Rc<String>,\n    /// Color of the link.\n    #[prop_or_default]\n    color: LinkColor,\n    /// The view function will not specify a size if this is None.\n    #[prop_or_default]\n    size: Option<u32>,\n    /// When the view function doesn't specify active, it defaults to true.\n    #[prop_or(true)]\n    active: bool,\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Event Listener with Closure and Web-Sys\nDESCRIPTION: Demonstrates creating a custom event listener using Closure from wasm-bindgen and web-sys APIs for handling unsupported or custom events in a Yew function component\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/html/events.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::{prelude::Closure, JsCast};\nuse web_sys::HtmlElement;\nuse yew::prelude::*;\n\n#[function_component]\nfn MyComponent() -> Html {\n    let div_node_ref = use_node_ref();\n\n    use_effect_with(\n        div_node_ref.clone(),\n        {\n            let div_node_ref = div_node_ref.clone();\n\n            move |_| {\n                let mut custard_listener = None;\n\n                if let Some(element) = div_node_ref.cast::<HtmlElement>() {\n                    let oncustard = Callback::from(move |_: Event| {\n                        // 對 custard 做點什麼..\n                    });\n\n                    let listener =\n                        Closure::<dyn Fn(Event)>::wrap(\n                            Box::new(move |e: Event| oncustard.emit(e))\n                        );\n\n                    element\n                        .add_event_listener_with_callback(\n                            \"custard\",\n                            listener.as_ref().unchecked_ref()\n                        )\n                        .unwrap();\n\n                    custard_listener = Some(listener);\n                }\n\n                move || drop(custard_listener)\n            }\n        }\n    );\n\n    html! {\n        <div ref={div_node_ref} id=\"my-div\"></div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Batch Callback with Yew\nDESCRIPTION: This snippet illustrates how to create a batch callback in Yew. It allows the closure to return either a batch of messages or a single message and utilizes the `send_message_batch` function to process them.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/struct-components/scope.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n### `batch_callback`\n\nCreate a callback that will send a batch of messages to the component when it is executed.\nThe difference to `callback` is that the closure passed to this method doesn't have to return a message.\nInstead, the closure can return either `Vec<Msg>` or `Option<Msg>` where `Msg` is the component's message type.\n\n`Vec<Msg>` is treated as a batch of messages and uses `send_message_batch` under the hood.\n\n`Option<Msg>` calls `send_message` if it is `Some`. If the value is `None`, nothing happens.\nThis can be used in cases where, depending on the situation, an update isn't required.\n\nThis is achieved using the `SendAsMessage` trait which is only implemented for these types.\nYou can implement `SendAsMessage` for your own types which allows you to use them in `batch_callback`.\n```\n\n----------------------------------------\n\nTITLE: Nesting Yew Components with Children\nDESCRIPTION: This example shows how to nest Yew components using the `children` property.  The parent component, `Container`, accepts `children` as a property and renders them within a `div`. This allows for creating reusable layout components that can contain arbitrary content.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/components.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    id: String,\n    children: Html,\n}\n\n#[function_component]\nfn Container(props: &Props) -> Html {\n    html! {\n        <div id={props.id.clone()}>\n            { props.children.clone() }\n        </div>\n    }\n}\n\nhtml! {\n    <Container id=\"container\">\n        <h4>{ \"Hi\" }</h4>\n        <div>{ \"Hello\" }</div>\n    </Container>\n};\n```\n\n----------------------------------------\n\nTITLE: Passing Base Props with Children Overrides in Yew\nDESCRIPTION: Demonstrates how to use the functional update syntax (..props) to pass a base properties object while overriding the children. When children are provided in both the props object and the html! macro, the children in the macro take precedence.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/components.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(PartialEq, Properties)]\nstruct Props {\n    id: String,\n    children: Html,\n}\n\n#[function_component]\nfn Container(props: &Props) -> Html {\n    html! {\n        <div id={props.id.clone()}>\n            { props.children.clone() }\n        </div>\n    }\n}\n\nlet props = yew::props!(Props {\n    id: \"container-2\",\n    children: Html::default(),\n});\n\nhtml! {\n    <Container ..props>\n        // props.children will be overwritten with this\n        <span>{ \"I am a child, as you can see\" }</span>\n    </Container>\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Callback with Yew\nDESCRIPTION: This snippet demonstrates how to create a callback in Yew that sends a message to the component when executed, utilizing the `callback` method provided by the component's context.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/struct-components/scope.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html};\n\nenum Msg {\n    Text(String),\n}\n\nstruct Comp;\n\nimpl Component for Comp {\n\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        // Create a callback that accepts some text and sends it\n        // to the component as the `Msg::Text` message variant.\n        // highlight-next-line\n        let cb = ctx.link().callback(|text: String| Msg::Text(text));\n\n        // The previous line is needlessly verbose to make it clearer.\n        // It can be simplified it to this:\n        // highlight-next-line\n        let cb = ctx.link().callback(Msg::Text);\n\n        // Will send `Msg::Text(\"Hello World!\")` to the component.\n        // highlight-next-line\n        cb.emit(\"Hello World!\".to_owned());\n\n        html! {\n            // html here\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using spawn_local with async functions in WebAssembly\nDESCRIPTION: This example demonstrates how to use the spawn_local function from wasm-bindgen-futures to execute an asynchronous function. It creates an async block that awaits a simple async function, modifies its result, and logs it to the console. This pattern is useful for handling asynchronous operations in Yew applications.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/basic-web-technologies/wasm-bindgen.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::console;\nuse wasm_bindgen_futures::spawn_local;\n\nasync fn my_async_fn() -> String { String::from(\"Hello\") }\n\nspawn_local(async {\n    let mut string = my_async_fn().await;\n    string.push_str(\", world!\");\n    // console log \"Hello, world!\"\n    console::log_1(&string.into());\n});\n```\n\n----------------------------------------\n\nTITLE: 在 Yew 组件中使用 NodeRef 访问 DOM 元素 (Rust)\nDESCRIPTION: 这段代码演示了如何在 Yew 组件中创建和使用 NodeRef 来访问 DOM 元素。它展示了如何在 create 方法中初始化 NodeRef，在 view 方法中将其附加到 HTML 元素，以及在 rendered 方法中使用它来检查元素属性。\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/advanced-topics/struct-components/refs.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::Element;\nuse yew::{html, Component, Context, Html, NodeRef};\n\nstruct Comp {\n    node_ref: NodeRef,\n}\n\nimpl Component for Comp {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            node_ref: NodeRef::default(),\n        }\n    }\n\n    fn view(&self, _ctx: &Context<Self>) -> Html {\n        html! {\n            <div ref={self.node_ref.clone()}></div>\n        }\n    }\n\n    fn rendered(&mut self, _ctx: &Context<Self>, _first_render: bool) {\n        let has_attributes = self.node_ref\n            .cast::<Element>()\n            .unwrap()\n            .has_attributes();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Rendered Lifecycle Method - Rust\nDESCRIPTION: Shows how to utilize the rendered lifecycle method in Yew for performing actions right after the component has been rendered to the DOM, including focusing an input element.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/components/introduction.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::{Component, Context, html, Html, NodeRef};\n\npub struct MyComponent {\n    node_ref: NodeRef,\n}\n\nimpl Component for MyComponent {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            node_ref: NodeRef::default(),\n        }\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <input ref={self.node_ref.clone()} type=\"text\" />\n        }\n    }\n\n    // highlight-start\n    fn rendered(&mut self, _ctx: &Context<Self>, first_render: bool) {\n        if first_render {\n            if let Some(input) = self.node_ref.cast::<HtmlInputElement>() {\n                input.focus();\n            }\n        }\n    }\n    // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Correct MIME-Type for Web Assembly Asset\nDESCRIPTION: This example outlines the importance of serving WASM files with the correct MIME-type. If your server does not default to `application/wasm`, manual configuration is necessary to avoid errors during WebAssembly instantiation. An incorrect MIME type results in a TypeError.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/more/deployment.mdx#2025-04-16_snippet_0\n\nLANGUAGE: ignore\nCODE:\n```\n`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n TypeError: WebAssembly: Response has unsupported MIME type 'text/plain' expected 'application/wasm'\n```\n\n----------------------------------------\n\nTITLE: Creating a Pure Component in Yew\nDESCRIPTION: This code snippet demonstrates how to create a pure component in the Yew framework. The component takes a boolean property `is_loading` and returns either \"Loading\" or \"Hello world\" based on its value. The `#[derive(Properties, PartialEq)]` is important for Yew to perform efficient comparisons and updates.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/function-components/pure-components.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{Properties, function_component, Html, html};\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    pub is_loading: bool,\n}\n\n#[function_component]\nfn HelloWorld(props: &Props) -> Html {\n    if props.is_loading {\n        html! { \"Loading\" }\n    } else {\n        html! { \"Hello world\" }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for Optimized Release Builds in Rust\nDESCRIPTION: This snippet shows how to configure the release profile in Cargo.toml to optimize for smaller binary sizes. It includes settings for panic behavior, code generation units, optimization level, and link-time optimization.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/optimizations.mdx#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[profile.release]\n# less code to include into binary\npanic = 'abort'\n# optimization over all codebase ( better optimization, slower build )\ncodegen-units = 1\n# optimization for size ( more aggressive )\nopt-level = 'z'\n# optimization for size\n# opt-level = 's'\n# link time optimization using using whole-program analysis\nlto = true\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Listeners in Yew Components\nDESCRIPTION: Shows how to implement event listeners in Yew components using callbacks. Includes examples for component handlers, agent handlers, and other scenarios.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.18.0/concepts/html/elements.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyComponent {\n    link: ComponentLink<Self>,\n}\n\nenum Msg {\n    Click,\n}\n\nimpl Component for MyComponent {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_: Self::Properties, link: ComponentLink<Self>) -> Self {\n        MyComponent { link }\n    }\n\n    fn update(&mut self, msg: Self::Message) -> ShouldRender {\n        match msg {\n            Msg::Click => {\n                // 处理 Click\n            }\n        }\n    }\n\n    fn view(&self) -> Html {\n        // 从组件 link 中创建回调来在组件中处理它\n        let click_callback = self.link.callback(|_: ClickEvent| Msg::Click);\n        html! {\n            <button onclick=click_callback>\n                { \"Click me!\" }\n            </button>\n        }\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyComponent {\n    worker: Dispatcher<MyWorker>,\n}\n\nimpl Component for MyComponent {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_: Self::Properties, _: ComponentLink<Self>) -> Self {\n        MyComponent {\n            worker: MyWorker::dispatcher()\n        }\n    }\n\n    fn update(&mut self, _: Self::Message) -> ShouldRender {\n        false\n    }\n\n    fn view(&self) -> Html {\n        // 从 worker 中创建回调来在另一个上下文中处理它\n        let click_callback = self.worker.callback(|_: ClickEvent| WorkerMsg::Process);\n        html! {\n            <button onclick=click_callback>\n                { \"Click me!\" }\n            </button>\n        }\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyComponent;\n\nimpl Component for MyComponent {\n    type Message = ();\n    type Properties = ();\n\n    fn create(_: Self::Properties, _: ComponentLink<Self>) -> Self {\n        MyComponent\n    }\n\n    fn update(&mut self, _: Self::Message) -> ShouldRender {\n        false\n    }\n\n    fn view(&self) -> Html {\n        // 创建一个短暂的回调\n        let click_callback = Callback::from(|| {\n            ConsoleService::log(\"clicked!\");\n        });\n\n        html! {\n            <button onclick=click_callback>\n                { \"Click me!\" }\n            </button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using NodeRef::cast in Yew with web-sys\nDESCRIPTION: This snippet demonstrates using `NodeRef::cast` to cast a `NodeRef` to a specific HTML element type (`HtmlInputElement`).  It shows how to safely obtain a typed reference to the underlying DOM element managed by the `NodeRef`, allowing for type-specific operations.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::HtmlInputElement;\nuse yew::NodeRef;\n\nfn with_node_ref_cast(node_ref: NodeRef) {\n    if let Some(input) = node_ref.cast::<HtmlInputElement>() {\n        // 在這裡處理 HtmlInputElement\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a Simple Callback in Yew Component (Rust)\nDESCRIPTION: This snippet demonstrates how to create a basic callback for a button click event in a Yew component. It shows the component structure, message enum, and the use of ctx.link().callback() to handle clicks.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/advanced-topics/struct-components/callbacks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html};\n\nenum Msg {\n    Clicked,\n}\n\nstruct Comp;\n\nimpl Component for Comp {\n\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let onclick = ctx.link().callback(|_| Msg::Clicked);\n        html! {\n            <button {onclick}>{ \"Click\" }</button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Emitting Yew Callback\nDESCRIPTION: This snippet demonstrates how to create and emit a Yew callback. The `Callback::from` method creates a callback that formats a string when called. The `emit` function is then used to invoke the callback with a string argument, producing a result.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/function-components/callbacks.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, Component, Context, Html, Callback};\n\nlet cb: Callback<String, String> = Callback::from(move |name: String| {\n    format!(\"Bye {}\", name)\n});\n\nlet result = cb.emit(String::from(\"Bob\"));  // 调用回调函数\n// web_sys::console::log_1(&result.into()); // 如果取消注释，将打印 \"Bye Bob\"\n```\n\n----------------------------------------\n\nTITLE: web-sys Dependencies for Mousemove Example\nDESCRIPTION: This TOML snippet defines the dependencies required to implement the mousemove example using `web-sys`. It includes `wasm-bindgen` and `web-sys`, with specific features enabled for console logging, DOM manipulation, and event handling.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/basic-web-technologies/web-sys.mdx#2025-04-16_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nwasm-bindgen = \"0.2\"\n\n[dependencies.web-sys]\nversion = \"0.3\"\n# 需要啟用所有我們想要使用的 web-sys 功能！\nfeatures = [\n    \"console\",\n    \"Document\",\n    \"HtmlElement\",\n    \"MouseEvent\",\n    \"DomRect\",\n]\n\n```\n\n----------------------------------------\n\nTITLE: VideosList Function Component\nDESCRIPTION: This snippet defines a `VideosList` function component. It takes a `VideosListProps` struct as an argument, which contains a `videos` field. The component renders a list of videos based on the data provided in the props.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n\"use yew::prelude::*;\n\nstruct Video {\n    id: usize,\n    title: String,\n    speaker: String,\n    url: String,\n}\n\n#[derive(Properties, PartialEq)]\nstruct VideosListProps {\n    videos: Vec<Video>,\n}\n\n#[function_component(VideosList)]\nfn videos_list(VideosListProps { videos }: &VideosListProps) -> Html {\n    videos.iter().map(|video| html! {\n        <p key={video.id}>{format!(\\\"{}: {}\\\", video.speaker, video.title)}</p>\n    }).collect()\n}\"\n```\n\n----------------------------------------\n\nTITLE: Comparison of Yew Hook Usage After the API Change\nDESCRIPTION: Example Rust code showing the new hook usage pattern where dependencies are passed as the first argument. This more ergonomic approach allows directly passing dependencies in-line without needing to extract them in advance.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/migration-guides/yew/from-0_20_0-to-0_21_0.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nimpl SomeLargeStruct {\n    fn id(&self) -> u32; // Only need to use the id as cache key\n}\nlet some_dep: SomeLargeStruct = todo!();\n\nuse_effect_with(some_dep.id(), move |_| { todo!(); drop(some_dep); });\n```\n\n----------------------------------------\n\nTITLE: Using classes! macro with String in Yew\nDESCRIPTION: This snippet demonstrates how to use the `classes!` macro with a `String` variable to dynamically set the class attribute of a div element in Yew. This allows for classes to be generated or modified at runtime. Requires the `yew` crate.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/classes.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nlet my_classes = String::from(\"class-1 class-2\");\n\nhtml! {\n  <div class={classes!(my_classes)}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using #[prop_or(value)] Attribute in Yew\nDESCRIPTION: Shows how to use the #[prop_or(value)] attribute to set a default value for a prop. The value can be any expression that returns the field's type.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/function-components/properties.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[derive(Properties, PartialEq)]\npub struct Props {\n    #[prop_or_default]\n    pub is_loading: bool,\n    #[prop_or(AttrValue::Static(\"Bob\"))]\n    pub name: AttrValue,\n}\n\n#[function_component]\nfn Hello(&Props { is_loading, ref name }: &Props) -> Html {\n    if is_loading {\n        html! { \"Loading\" }\n    } else {\n        html! { <>{{\"Hello \"}}{{name}} </> }\n    }\n}\n\n// Then use like this with default\n#[function_component]\nfn Case1() -> Html {\n    html! { <Hello /> }\n}\n// Or no override the default\n#[function_component]\nfn Case2() -> Html {\n    html! { <Hello name=\"Sam\" /> }\n}\n```\n\n----------------------------------------\n\nTITLE: Enum-Based Child Component Rendering\nDESCRIPTION: Complex child component handling using an enum to restrict child types with `derive_more`\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/advanced-topics/children.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, html::ChildrenRenderer, virtual_dom::VChild, Component, Context, Html, Properties};\n\npub struct Primary;\npub struct Secondary;\n\n#[derive(Clone, derive_more::From, PartialEq)]\npub enum Item {\n    Primary(VChild<Primary>),\n    Secondary(VChild<Secondary>),\n}\n\n#[allow(clippy::from_over_into)]\nimpl Into<Html> for Item {\n    fn into(self) -> Html {\n        match self {\n            Self::Primary(child) => child.into(),\n            Self::Secondary(child) => child.into(),\n        }\n    }\n}\n\n#[derive(Properties, PartialEq)]\npub struct ListProps {\n    #[prop_or_default]\n    pub children: ChildrenRenderer<Item>,\n}\n\npub struct List;\n\nimpl Component for List {\n    type Message = ();\n    type Properties = ListProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        html! {\n            <div class=\"list\">\n                { for ctx.props().children.iter() }\n            </div>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining VideosList Component in Rust\nDESCRIPTION: Creates a VideosList function component that renders a list of videos. It demonstrates how to define props, use the #[function_component] attribute, and render child elements.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/tutorial/index.mdx#2025-04-16_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nstruct Video {\n    id: usize,\n    title: String,\n    speaker: String,\n    url: String,\n}\n\n#[derive(Properties, PartialEq)]\nstruct VideosListProps {\n    videos: Vec<Video>,\n}\n\n#[function_component(VideosList)]\nfn videos_list(VideosListProps { videos }: &VideosListProps) -> Html {\n    videos.iter().map(|video| html! {\n        <p key={video.id}>{format!(\"{}: {}\", video.speaker, video.title)}</p>\n    }).collect()\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Text Literals in Yew HTML Templates\nDESCRIPTION: Demonstrates how to render text content in Yew by using curly braces {} to enclose strings and values that implement the Display trait. The example shows rendering both literal strings and variables in div and span elements.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/literals-and-expressions.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nlet text = \"lorem ipsum\";\nhtml!{\n    <>\n        <div>{text}</div>\n        <div>{\"dolor sit\"}</div>\n        <span>{42}</span>\n    </>\n}\n```\n\n----------------------------------------\n\nTITLE: Mouse Position Tracking with JavaScript\nDESCRIPTION: JavaScript example that tracks mouse position relative to an element. Sets up a mousemove event handler, calculates the cursor position relative to the element's bounds, and logs the coordinates to the console.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/wasm-bindgen/web-sys.mdx#2025-04-16_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\ndocument.getElementById('mousemoveme').onmousemove = (e) => {\n    // e = Mouse event.\n    var rect = e.target.getBoundingClientRect()\n    var x = e.clientX - rect.left //x position within the element.\n    var y = e.clientY - rect.top //y position within the element.\n    console.log('Left? : ' + x + ' ; Top? : ' + y + '.')\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Switch Trait for AppRoute Enum in Rust\nDESCRIPTION: This snippet demonstrates how to define an AppRoute enum and implement the Switch trait for routing in a Yew application. It shows how to use the #[to] attribute to specify URL patterns for each route variant.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.18.0/concepts/router.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Switch)]\nenum AppRoute {\n  #[to=\"/login\"]\n  Login,\n  #[to=\"/register\"]\n  Register,\n  #[to=\"/delete_account\"]\n  Delete,\n  #[to=\"/posts/{id}\"]\n  ViewPost(i32),\n  #[to=\"/posts/view\"]\n  ViewPosts,\n  #[to=\"/\"]\n  Home\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Yew Application HTML Structure\nDESCRIPTION: This HTML template serves as the initial setup for a Yew application using Trunk. It contains the basic structure with a UTF-8 meta charset and a title, 'Yew App'. This file acts as the entry point for Trunk to build the application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/getting-started/project-setup/using-trunk.mdx#2025-04-16_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<!doctype html>\n<html>\n    <head>\n        <meta charset=\"utf-8\" />\n        <title>Yew App</title>\n    </head>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Implementing NodeRef for DOM Access in Rust with Yew\nDESCRIPTION: This code snippet demonstrates how to use NodeRef in Yew to access and manipulate DOM elements. It shows the initialization in the create method, usage in the view method, and how to access the element's properties in the update method.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.20/advanced-topics/struct-components/refs.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// 在 create 中\nself.node_ref = NodeRef::default();\n\n// 在 view 中\nhtml! {\n    <div ref={self.node_ref.clone()}></div>\n}\n\n// 在 update 中\nlet has_attributes = self.node_ref.cast::<Element>().unwrap().has_attributes();\n```\n\n----------------------------------------\n\nTITLE: Using String-like Attributes in Yew\nDESCRIPTION: Shows different ways to pass string-like values to HTML attributes in Yew, including using str, String, and Yew's AttrValue type, with a recommendation to prefer AttrValue.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/html/elements.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{html, virtual_dom::AttrValue};\n\nlet str_placeholder = \"I'm a str!\";\nlet string_placeholder = String::from(\"I'm a String!\");\nlet attrvalue_placeholder = AttrValue::from(\"I'm an AttrValue!\");\n\nhtml! {\n    <div>\n        <input placeholder={str_placeholder} />\n        <input placeholder={string_placeholder} />\n        <input placeholder={attrvalue_placeholder} />\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring crate-type in Cargo.toml for wasm-pack\nDESCRIPTION: This configuration is required for `wasm-pack` to correctly build the project as a `cdylib` (C dynamic library), which is necessary for WebAssembly interoperation.  The `crate-type` field in `Cargo.toml` specifies the type of output crate to produce.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/getting-started/project-setup/using-wasm-pack.mdx#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n\n[lib]\ncrate-type = [\"rlib\", \"cdylib\"]\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Suspense with Yew Function Components in Rust\nDESCRIPTION: This snippet demonstrates how to use Suspense with function components in Yew. It shows the basic structure of using a Suspense component with a fallback UI while content is loading.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/suspense.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[function_component(Content)]\nfn content() -> HtmlResult {\n    let user = use_user()?;\n\n    Ok(html! {<div>{\"Hello, \"}{&user.name}</div>})\n}\n\n#[function_component(App)]\nfn app() -> Html {\n    let fallback = html! {<div>{\"Loading...\"}</div>};\n\n    html! {\n        <Suspense {fallback}>\n            <Content />\n        </Suspense>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using spawn_local for Asynchronous Operations in Yew\nDESCRIPTION: Example showing how to use spawn_local from wasm-bindgen-futures to execute asynchronous code in a Yew application, including handling promises and awaiting async functions.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.22/concepts/basic-web-technologies/wasm-bindgen.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse web_sys::console;\nuse wasm_bindgen_futures::spawn_local;\n\nasync fn my_async_fn() -> String { String::from(\"Hello\") }\n\nspawn_local(async {\n    let mut string = my_async_fn().await;\n    string.push_str(\", world!\");\n    // 列印 \"Hello, world!\"\n    console::log_1(&string.into());\n});\n```\n\n----------------------------------------\n\nTITLE: Creating DOM Nodes Manually in Yew\nDESCRIPTION: Demonstrates how to create DOM elements manually using web-sys and integrate them into Yew's component rendering pipeline.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/concepts/html/elements.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{utils::document, web_sys::{Element, Node}, Html};\n// ...\nfn view(&self) -> Html {\n    // Create a div element from the document\n    let div: Element = document().create_element(\"div\").unwrap();\n    // Add content, classes etc.\n    div.set_inner_html(\"Hello, World!\");\n    // Convert Element into a Node\n    let node: Node = div.into();\n    // Return that Node as a Html value\n    Html::VRef(node)\n}\n```\n\n----------------------------------------\n\nTITLE: Using wasm-logger for logging in Rust\nDESCRIPTION: This snippet shows how to use the `log` crate, after `wasm-logger` is initialized, to log information. The `log::info!` macro is used to log a message with the INFO level, including the `msg` variable.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.21/more/debugging.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// usage\nlog::info!(\"Update: {:?}\", msg);\n\n```\n\n----------------------------------------\n\nTITLE: Expanding html! Macro in Rust for Yew\nDESCRIPTION: The `cargo expand` command allows developers to view the expanded form of Rust macros, including the `html!` macro used in Yew. This can be useful for understanding how the macro transforms HTML-like syntax into Rust code.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/advanced-topics/how-it-works.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo expand\n```\n\n----------------------------------------\n\nTITLE: Rendering Lists Using For Keyword in Yew\nDESCRIPTION: Shows an alternative syntax for rendering lists using Yew's special 'for' keyword in the HTML macro. This approach provides a more declarative way to iterate over items.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/lists.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet items = (1..=10).collect::<Vec<_>>();\n\nhtml! {\n    <ul class=\"item-list\">\n        { for items.iter() }\n    </ul>\n};\n```\n\n----------------------------------------\n\nTITLE: Console Logging with gloo-console in Rust\nDESCRIPTION: Shows how to use the gloo-console crate for browser console logging, which provides a more ergonomic wrapper for browser APIs and simplified handling of JsValue objects.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/more/debugging.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse gloo_console::log;\nuse wasm_bindgen::JsValue;\n\nfn main() {\n    let object = JsValue::from(\"world\");\n    log!(\"Hello\", object)\n}\n```\n\n----------------------------------------\n\nTITLE: Component Update Method with Message Handling\nDESCRIPTION: Illustrates how to implement the update() method to handle component messages and decide whether to re-render\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.21/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub enum Msg {\n    SetInputEnabled(bool)\n}\n\nimpl Component for MyComponent {\n    type Message = Msg;\n\n    // ...\n\n    fn update(&mut self, msg: Self::Message) -> ShouldRender {\n       match msg {\n           Msg::SetInputEnabled(enabled) => {\n               if self.input_enabled != enabled {\n                   self.input_enabled = enabled;\n                   true // Re-render\n               } else {\n                   false\n               }\n           }\n       }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Client-Side Hydration of Server-Rendered Yew App\nDESCRIPTION: Shows how to hydrate a server-rendered Yew application on the client side, connecting the pre-rendered HTML with the interactive Yew component\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/advanced-topics/server-side-rendering.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\nuse yew::Renderer;\n\n#[function_component]\nfn App() -> Html {\n    html! {<div>{\"Hello, World!\"}</div>}\n}\n\nfn main() {\n    let renderer = Renderer::<App>::new();\n\n    // Hydrate directly under the body element, removing any trailing elements\n    renderer.hydrate();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Yew Counter Component\nDESCRIPTION: Implementation of a basic Yew application with a counter component using function components and hooks\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\n#[function_component]\nfn App() -> Html {\n    let counter = use_state(|| 0);\n    let onclick = {\n        let counter = counter.clone();\n        move |_| {\n            let value = *counter + 1;\n            counter.set(value);\n        }\n    };\n\n    html! {\n        <div>\n            <button {onclick}>{ \"+1\" }</button>\n            <p>{ *counter }</p>\n        </div>\n    }\n}\n\nfn main() {\n    yew::Renderer::<App>::new().render();\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving Yew Module References in Macro Generated Code\nDESCRIPTION: Example of how the html! macro generates fully qualified paths to avoid naming conflicts. Instead of using relative paths like yew::<module>, the macro generates absolute paths like ::yew::<module>.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/advanced-topics/how-it-works.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n::yew::<module>\n```\n\n----------------------------------------\n\nTITLE: Invalid HTML Fragment Example\nDESCRIPTION: Shows an invalid example of html! macro usage where multiple root elements are used without a fragment wrapper, which will result in a compilation error.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/basic-web-technologies/html.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\n// error: only one root HTML element allowed\nhtml! {\n\n    <div></div>\n    <p></p>\n\n};\n```\n\n----------------------------------------\n\nTITLE: Updating Video Struct for JSON Deserialization\nDESCRIPTION: This code modifies the Video struct to implement Serde's Deserialize trait, which allows it to be automatically created from JSON data received from an API.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\nuse serde::Deserialize;\n\n#[derive(Clone, PartialEq, Deserialize)]\nstruct Video {\n    id: usize,\n    title: String,\n    speaker: String,\n    url: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Classes in Yew\nDESCRIPTION: This snippet shows how to assign multiple classes to a single HTML element in Yew using the `classes!` macro which accepts a comma separated list of class names.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/classes.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(\"class-1\", \"class-2\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Rendering HTML with Yew html! Macro\nDESCRIPTION: Shows how to define a component's view method using the html! macro to create interactive HTML elements with event handlers\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.21/advanced-topics/struct-components/lifecycle.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nimpl Component for MyComponent {\n    // ...\n\n    fn view(&self) -> Html {\n        let onclick = self.link.callback(|_| Msg::Click);\n        html! {\n            <button {onclick}>{ self.props.button_text }</button>\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Instantiation Error Due to Incorrect MIME Type\nDESCRIPTION: Error message displayed when the server does not serve WebAssembly files with the correct MIME type (application/wasm).\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/more/deployment.mdx#2025-04-16_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n TypeError: WebAssembly: Response has unsupported MIME type 'text/plain' expected 'application/wasm'\n```\n\n----------------------------------------\n\nTITLE: Invalid Multiple Root Elements in html! Macro\nDESCRIPTION: Shows an invalid example where multiple root HTML elements are used in the html! macro. Yew requires a single wrapping node to be returned from the html! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/concepts/basic-web-technologies/html.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\n// error: only one root HTML element allowed\nhtml! {\n\n    <div></div>\n    <p></p>\n\n};\n```\n\n----------------------------------------\n\nTITLE: Updating App Component to Use VideosList in Rust\nDESCRIPTION: Modifies the App component to use the newly created VideosList component, replacing the inline video rendering logic.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/tutorial/index.mdx#2025-04-16_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n#[function_component(App)]\nfn app() -> Html {\n    // ...\n    html! {\n        <>\n            <h1>{ \"RustConf Explorer\" }</h1>\n            <div>\n                <h3>{\"Videos to watch\"}</h3>\n                <VideosList videos={videos} />\n            </div>\n            // ...\n        </>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Trunk configuration file\nDESCRIPTION: This snippet defines the configuration for the Trunk development server. It allows specifying the address and port the server listens on.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\n\"[serve]\n# 局域网上的监听地址\naddress = \\\"127.0.0.1\\\"\n# 广域网上的监听地址\n# address = \\\"0.0.0.0\\\"\n# 监听的端口\nport = 8000\"\n```\n\n----------------------------------------\n\nTITLE: WebAssembly MIME Type Error Message\nDESCRIPTION: Example error message when WASM file is served with incorrect MIME type, highlighting the importance of proper server configuration\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/more/deployment.mdx#2025-04-16_snippet_2\n\nLANGUAGE: ignore\nCODE:\n```\n`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n TypeError: WebAssembly: Response has unsupported MIME type 'text/plain' expected 'application/wasm'\n```\n\n----------------------------------------\n\nTITLE: Props Evaluation Order Example in Yew\nDESCRIPTION: Example showing the order in which properties are evaluated when using the props! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/function-components/properties.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(yew::Properties, PartialEq)]\nstruct Props { first: usize, second: usize, last: usize }\n\nfn main() {\n    let mut g = 1..=3;\n    let props = yew::props!(Props { first: g.next().unwrap(), second: g.next().unwrap(), last: g.next().unwrap() });\n\n    assert_eq!(props.first, 1);\n    assert_eq!(props.second, 2);\n    assert_eq!(props.last, 3);\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Keyboard Events in Yew 0.19.0 (Rust)\nDESCRIPTION: Shows how to handle keyboard events directly using Yew's event handlers, replacing the now-removed KeyboardService.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/migration-guides/yew/from-0_18_0-to-0_19_0.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet onkeydown = Callback::from(|e| {\n    e.prevent_default();\n    todo!(\"use `e`, just like in service methods.\");\n});\nhtml! {\n    <input {onkeydown} />\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Closure Parameter Types in Yew Event Handlers (Rust)\nDESCRIPTION: Shows how to specify parameter types for closures in Yew event handlers, which is now required in the new version.\nSOURCE: https://github.com/yewstack/yew/blob/master/CHANGELOG.md#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet onkeydown = self.link.callback(|e: KeyDownEvent| {\n    // ...\n});\n\nhtml! {\n    <button onkeydown=onkeydown type=\"button\">\n        { \"button\" }\n    </button>\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Valid HTML Syntax in Yew 0.19.0\nDESCRIPTION: The correct way to declare props in Yew 0.19.0's HTML macro, where props must be enclosed with braces.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/migration-guides/yew/from-0_18_0-to-0_19_0.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet super_age = 1;\nhtml!{\n    <JapaneseYew\n        age={super_age} // Correct\n    >\n}\n```\n\n----------------------------------------\n\nTITLE: Working with Boolean Attributes in Yew\nDESCRIPTION: This snippet demonstrates how to use boolean attributes in Yew. It shows examples of setting a boolean attribute to true and using a boolean expression.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.22/concepts/html/elements.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <div hidden=true>\n        { \"This div is hidden.\" }\n    </div>\n};\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet no = 1 + 1 != 2;\n\nhtml! {\n    <div hidden={no}>\n        { \"This div is NOT hidden.\" }\n    </div>\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Component in Yew (Rust)\nDESCRIPTION: Example of creating a component in Yew by implementing the required props and link storage pattern in the create method.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/version-0.18.0/concepts/components/introduction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub struct MyComponent {\n    props: Props,\n    link: ComponentLink<Self>,\n}\n\nimpl Component for MyComponent {\n    type Properties = Props;\n    // ...\n\n    fn create(props: Self::Properties, link: ComponentLink<Self>) -> Self {\n        MyComponent { props, link }\n    }\n\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using ConsoleService for Logging in Yew Applications\nDESCRIPTION: Demonstrates how to use Yew's built-in ConsoleService for logging in Rust web applications. This service is available when the \"services\" feature is enabled in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.21/more/debugging.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// 使用方法\nConsoleService::info(format!(\"Update: {:?}\", msg).as_ref());\n```\n\n----------------------------------------\n\nTITLE: Creating a new Cargo Project\nDESCRIPTION: These commands create a new Cargo project named 'yew-app' and navigate into the newly created directory. Cargo is Rust's package manager and build tool.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/tutorial/index.mdx#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n\"cargo new yew-app\ncd yew-app\"\n```\n\n----------------------------------------\n\nTITLE: Macro Hygiene Example with Explicit Package References\nDESCRIPTION: Illustrates how the Yew macro ensures correct package references and prevents naming conflicts through explicit module and trait references\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.22/advanced-topics/how-it-works.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Explicit package and trait referencing\n::yew::module::function()\n<Type as Trait>::method()\n```\n\n----------------------------------------\n\nTITLE: Yew Classes Macro Array Example\nDESCRIPTION: This snippet demonstrates how to use an array of strings with the `classes!` macro to apply a set of classes to a div element in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hant/docusaurus-plugin-content-docs/current/concepts/html/classes.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!([\"class-1\", \"class-2\"])}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Using ConsoleService for Logging in Yew\nDESCRIPTION: Demonstrates how to use Yew's built-in ConsoleService for logging. This service is available when the \"services\" feature is enabled in Yew.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.18.0/more/debugging.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// 使用方法\nConsoleService::info(format!(\"Update: {:?}\", msg).as_ref());\n```\n\n----------------------------------------\n\nTITLE: Rendering List with for Keyword\nDESCRIPTION: Alternative method of rendering a list using the for keyword in Yew's HTML macro for iterator display\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.22/concepts/html/lists.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet items = (1..=10).collect::<Vec<_>>();\n\nhtml! {\n    <ul class=\"item-list\">\n        { for items.iter() }\n    </ul>\n};\n```\n\n----------------------------------------\n\nTITLE: Using classes! macro with an Optional class in Yew (Rust)\nDESCRIPTION: Shows how to use the classes! macro with an Optional class in Yew, which can be useful for conditional class application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/docs/concepts/html/classes.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(Some(\"class\"))} />\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Component View Function Signature in Rust\nDESCRIPTION: Shows the signature of a component's view function, which takes a reference to self and returns Html.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.20/advanced-topics/struct-components/properties.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn view(&self) -> Html\n```\n\n----------------------------------------\n\nTITLE: Invalid Multiple Root Elements\nDESCRIPTION: Example showing invalid usage of html! macro with multiple root elements, which will fail to compile.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/basic-web-technologies/html.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\n// error: only one root html element allowed\nhtml! {\n\n    <div></div>\n    <p></p>\n\n};\n```\n\n----------------------------------------\n\nTITLE: Running Game of Life Example in Development Mode\nDESCRIPTION: Command to serve the Game of Life example in development mode with the browser automatically opening. Uses trunk development server with specific Rust flags.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/game_of_life/README.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nRUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"' trunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Using Literal Class Names in Yew\nDESCRIPTION: Demonstrates how to add a single literal class name to a div element using the classes! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!(\"container\")}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Setting Recursion Limit for html! Macro in Rust\nDESCRIPTION: Demonstrates how to set a higher recursion limit to avoid compiler errors when using complex html! macro structures.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/version-0.18.0/concepts/html/introduction.mdx#2025-04-16_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n#![recursion_limit=\"1024\"]\n```\n\n----------------------------------------\n\nTITLE: Sending Message in Yew ComponentLink\nDESCRIPTION: The 'send_message' method sends a message to the component immediately after the current loop ends, triggering another update cycle.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/version-0.20/advanced-topics/struct-components/callbacks.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nsend_message\n```\n\n----------------------------------------\n\nTITLE: Running Yew Node Refs Example with Trunk in Bash\nDESCRIPTION: Command to run the Node Refs example application using the Trunk development server with the --open flag to automatically open the application in a browser.\nSOURCE: https://github.com/yewstack/yew/blob/master/examples/node_refs/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Using Slice of Class Names in Yew\nDESCRIPTION: Shows how to use a slice of class names with the classes! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/basic-web-technologies/css.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{classes, html};\n\nhtml! {\n  <div class={classes!([\"class-1\", \"class-2\"].as_ref())}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Function Component Without Props in Yew\nDESCRIPTION: Example of a simple function component that doesn't require any properties.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/function-components/properties.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::{function_component, html, Html};\n\n#[function_component]\nfn HelloWorld() -> Html {\n    html! { \"Hello world\" }\n}\n\n#[function_component]\nfn App() -> Html {\n    html! {<HelloWorld />}\n}\n```\n\n----------------------------------------\n\nTITLE: WASM Optimization Command\nDESCRIPTION: Command line instruction for optimizing WebAssembly binary size using wasm-opt tool with size optimization flag.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/advanced-topics/optimizations.mdx#2025-04-16_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nwasm-opt wasm_bg.wasm -Os -o wasm_bg_opt.wasm\n```\n\n----------------------------------------\n\nTITLE: Basic Event Callback Implementation in Yew\nDESCRIPTION: Demonstrates how to implement a basic onclick event callback in Yew using the html! macro.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/events.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n    <button onclick={Callback::from(|_| ())}>\n        { \"Click me!\" }\n    </button>\n};\n```\n\n----------------------------------------\n\nTITLE: Setting Attributes in Yew HTML\nDESCRIPTION: Shows how to set attributes on elements in Yew's html! macro, including dynamic values.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/concepts/html/introduction.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nlet value = \"something\";\nhtml! { <div attribute={value} /> };\n```\n\n----------------------------------------\n\nTITLE: Creating a new Cargo project for Yew\nDESCRIPTION: Command to create a new Rust project using Cargo which will be used for the Yew application.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.18.0/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo new yew-app\n```\n\n----------------------------------------\n\nTITLE: Generating Yew Project from Template\nDESCRIPTION: Uses cargo-generate to create a new Yew project from a minimal template.\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.21/getting-started/build-a-sample-app.mdx#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo generate --git https://github.com/yewstack/yew-trunk-minimal-template\n```\n\n----------------------------------------\n\nTITLE: Optional HTML Attributes\nDESCRIPTION: Demonstrates how to handle optional attributes using Option type in Yew\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.19.0/concepts/html/elements.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::html;\n\nlet maybe_id = Some(\"foobar\");\n\nhtml! {\n    <div id={maybe_id}></div>\n};\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering in Yew\nDESCRIPTION: Demonstrates conditional rendering using if statements within the html! macro\nSOURCE: https://github.com/yewstack/yew/blob/master/website/versioned_docs/version-0.20/concepts/html/introduction.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse yew::prelude::*;\n\nhtml! {\n  if true {\n      <p>{ \"True case\" }</p>\n  }\n};\n```"
  }
]