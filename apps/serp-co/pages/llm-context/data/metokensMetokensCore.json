[
  {
    "owner": "metokens",
    "repo": "metokens-core",
    "content": "TITLE: Reentrancy in UniswapSingleTransferMigration.finishMigration\nDESCRIPTION: Critical vulnerability where state variables are written after external calls, potentially enabling reentrancy attacks. The function makes multiple external calls before updating state variables including token transfers and swaps.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_11\n\nLANGUAGE: Solidity\nCODE:\n```\nISingleAssetVault(hub_.vault).startMigration(_meToken);\namountOut = _swap(_meToken);\nIERC20(targetHub_.asset).transfer(targetHub_.vault,amountOut);\ndelete _uniswapSingleTransfers[_meToken];\n```\n\n----------------------------------------\n\nTITLE: Potential Reentrancy in SameAssetTransferMigration.finishMigration Function\nDESCRIPTION: The finishMigration function in SameAssetTransferMigration contract may be vulnerable to reentrancy attacks. It makes external calls before updating state variables.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_10\n\nLANGUAGE: Solidity\nCODE:\n```\nISingleAssetVault(hub_.vault).startMigration(_meToken);\nusts_.started = true;\n// ... other code ...\ndelete _sameAssetMigration[_meToken];\n```\n\n----------------------------------------\n\nTITLE: Potential Reentrancy in UniswapSingleTransferMigration._swap Function\nDESCRIPTION: The _swap function in UniswapSingleTransferMigration contract may be vulnerable to reentrancy attacks. It makes an external call before updating the state variable.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_9\n\nLANGUAGE: Solidity\nCODE:\n```\nIERC20(hub_.asset).approve(address(_router),amountIn);\n// ... other code ...\nusts_.swapped = true;\n```\n\n----------------------------------------\n\nTITLE: Reentrancy Vulnerabilities in Vault Methods (Solidity)\nDESCRIPTION: The handleDeposit and handleWithdrawal functions in the Vault contract make external calls before updating state variables, potentially exposing them to reentrancy attacks.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_17\n\nLANGUAGE: solidity\nCODE:\n```\nReentrancy in Vault.handleDeposit(address,address,uint256,uint256) (contracts/vaults/Vault.sol#40-52):\n\tExternal calls:\n\t- IERC20(_asset).safeTransferFrom(_from,address(this),_depositAmount) (contracts/vaults/Vault.sol#47)\n\tState variables written after the call(s):\n\t- accruedFees[_asset] += _feeAmount (contracts/vaults/Vault.sol#49)\nReentrancy in Vault.handleWithdrawal(address,address,uint256,uint256) (contracts/vaults/Vault.sol#54-66):\n\tExternal calls:\n\t- IERC20(_asset).safeTransfer(_to,_withdrawalAmount) (contracts/vaults/Vault.sol#61)\n\tState variables written after the call(s):\n\t- accruedFees[_asset] += _feeAmount (contracts/vaults/Vault.sol#63)\n```\n\n----------------------------------------\n\nTITLE: Ignoring Return Value of ERC20 Transfer in Migration Contracts\nDESCRIPTION: Slither detected that several functions are ignoring return values from ERC20 transfer calls, which is considered unsafe as transfer failures might not be properly handled.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_0\n\nLANGUAGE: solidity\nCODE:\n```\nSameAssetTransferMigration.finishMigration(address) (contracts/migrations/SameAssetTransferMigration.sol#62-89) ignores return value by IERC20(targetHub_.asset).transfer(targetHub_.vault,amountOut) (contracts/migrations/SameAssetTransferMigration.sol#85)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nUniswapSingleTransferMigration.finishMigration(address) (contracts/migrations/UniswapSingleTransferMigration.sol#92-123) ignores return value by IERC20(targetHub_.asset).transfer(targetHub_.vault,amountOut) (contracts/migrations/UniswapSingleTransferMigration.sol#119)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nVault.claim(address,bool,uint256) (contracts/vaults/Vault.sol#68-83) ignores return value by IERC20(_asset).transfer(dao,_amount) (contracts/vaults/Vault.sol#81)\n```\n\n----------------------------------------\n\nTITLE: Reentrancy in MeTokenRegistryFacet.subscribe\nDESCRIPTION: Potential reentrancy vulnerability in token subscription process where state variables are modified after external calls to transfer tokens and mint new tokens.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_12\n\nLANGUAGE: Solidity\nCODE:\n```\nIERC20(hub_.asset).transferFrom(msg.sender,hub_.vault,_assetsDeposited);\nmeTokenAddr = IMeTokenFactory(s.meTokenFactory).create(_name,_symbol,address(this));\nIMeToken(meTokenAddr).mint(msg.sender,_meTokensMinted);\ns.meTokenOwners[msg.sender] = meTokenAddr;\nmeToken_.owner = msg.sender;\nmeToken_.hubId = _hubId;\nmeToken_.balancePooled = _assetsDeposited;\n```\n\n----------------------------------------\n\nTITLE: Events Emitted After External Calls Across Multiple Contracts (Solidity)\nDESCRIPTION: Multiple functions emit events after making external calls, creating reentrancy vulnerabilities where malicious contracts could execute before events are properly logged.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_18\n\nLANGUAGE: solidity\nCODE:\n```\nReentrancy in FoundryFacet.burn(address,uint256,address) (contracts/facets/FoundryFacet.sol#135-218):\n\tExternal calls:\n\t- hub_ = LibHub.finishUpdate(meToken_.hubId) (contracts/facets/FoundryFacet.sol#144)\n\t- meToken_ = LibMeToken.finishResubscribe(_meToken) (contracts/facets/FoundryFacet.sol#149)\n\t- IMeToken(_meToken).burn(msg.sender,_meTokensBurned) (contracts/facets/FoundryFacet.sol#174)\n\t- vault.handleWithdrawal(_recipient,asset,assetsReturned,fee) (contracts/facets/FoundryFacet.sol#208)\n\tEvent emitted after the call(s):\n\t- Burn(_meToken,asset,msg.sender,_recipient,_meTokensBurned,assetsReturned) (contracts/facets/FoundryFacet.sol#210-217)\n```\n\n----------------------------------------\n\nTITLE: Missing Zero-Address Validation in Multiple Constructors (Solidity)\nDESCRIPTION: Several contracts lack zero-address validation when setting critical address values in their constructors, which could lead to contracts becoming unusable if zero addresses are passed.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_16\n\nLANGUAGE: solidity\nCODE:\n```\nMeToken.constructor(string,string,address)._diamond (contracts/MeToken.sol#16) lacks a zero-check on :\n\t\t- diamond = _diamond (contracts/MeToken.sol#19)\nBancorABDK.constructor(address)._hub (contracts/curves/BancorABDK.sol#32) lacks a zero-check on :\n\t\t- hub = _hub (contracts/curves/BancorABDK.sol#33)\nBancorPower.constructor(address)._hub (contracts/curves/BancorPower.sol#37) lacks a zero-check on :\n\t\t- hub = _hub (contracts/curves/BancorPower.sol#38)\nStepwiseCurve.constructor(address)._hub (contracts/curves/StepwiseCurve.sol#27) lacks a zero-check on :\n\t\t- hub = _hub (contracts/curves/StepwiseCurve.sol#28)\nStepwiseCurveABDK.constructor(address)._hub (contracts/curves/StepwiseCurveABDK.sol#30) lacks a zero-check on :\n\t\t- hub = _hub (contracts/curves/StepwiseCurveABDK.sol#31)\n```\n\n----------------------------------------\n\nTITLE: Uninitialized State Variable Modifiers.s in Details Contract\nDESCRIPTION: Slither identified that Modifiers.s (contracts/libs/Details.sol#71) is never initialized but is used in several functions in the FoundryFacet contract, which could lead to unexpected behavior.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_1\n\nLANGUAGE: solidity\nCODE:\n```\nModifiers.s (contracts/libs/Details.sol#71) is never initialized. It is used in:\n\t- FoundryFacet.mint(address,uint256,address) (contracts/facets/FoundryFacet.sol#39-100)\n\t- FoundryFacet.burn(address,uint256,address) (contracts/facets/FoundryFacet.sol#135-218)\n\t- FoundryFacet.donate(address,uint256) (contracts/facets/FoundryFacet.sol#220-236)\n\t- FoundryFacet._calculateMeTokensMinted(address,uint256) (contracts/facets/FoundryFacet.sol#239-302)\n\t- FoundryFacet._calculateRawAssetsReturned(address,uint256) (contracts/facets/FoundryFacet.sol#304-369)\n\t- FoundryFacet._calculateActualAssetsReturned(address,address,uint256,uint256) (contracts/facets/FoundryFacet.sol#372-422)\n```\n\n----------------------------------------\n\nTITLE: Dangerous Strict Equality Checks in Various Functions\nDESCRIPTION: Several functions use strict equality checks (==) which can be dangerous in certain contexts, especially when comparing addresses or checking for specific values.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_8\n\nLANGUAGE: Solidity\nCODE:\n```\nrequire(bool,string)(msg.sender == s.pendingMeTokenOwners[_oldOwner],!_pendingOwner)\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nrequire(bool,string)(msg.sender == address(s.curveRegistry),!curveRegistry)\n```\n\n----------------------------------------\n\nTITLE: Timestamp-Based Comparisons in HubFacet (Solidity)\nDESCRIPTION: The initUpdate and cancelUpdate functions in HubFacet rely on block.timestamp for critical timing controls, which can be manipulated to a limited extent by miners, potentially affecting contract behavior.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_20\n\nLANGUAGE: solidity\nCODE:\n```\nHubFacet.initUpdate(uint256,address,uint256,bytes) (contracts/facets/HubFacet.sol#98-166) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool,string)(msg.sender == hub_.owner,!owner) (contracts/facets/HubFacet.sol#105)\n\t- hub_.updating && block.timestamp > hub_.endTime (contracts/facets/HubFacet.sol#106)\n\t- require(bool,string)(! hub_.updating,already updating) (contracts/facets/HubFacet.sol#109)\n\t- require(bool,string)(block.timestamp >= hub_.endCooldown,Still cooling down) (contracts/facets/HubFacet.sol#111)\n\t- require(bool,string)(_targetRefundRatio != hub_.refundRatio,_targetRefundRatio == refundRatio) (contracts/facets/HubFacet.sol#123-126)\n\t- require(bool,string)(_targetCurve != hub_.curve,targetCurve==curve) (contracts/facets/HubFacet.sol#140)\nHubFacet.cancelUpdate(uint256) (contracts/facets/HubFacet.sol#172-187) uses timestamp for comparisons\n```\n\n----------------------------------------\n\nTITLE: Minting meTokens\nDESCRIPTION: Hardhat task for minting new meTokens using the Diamond contract on the specified network.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/README.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nyarn hardhat mint --diamond <Diamond address>  --network <\"mainnet\" or \"goerli\">\n```\n\n----------------------------------------\n\nTITLE: Unsafe Timestamp Comparisons in FoundryFacet (Solidity)\nDESCRIPTION: The mint and burn functions in FoundryFacet use block.timestamp for critical timing comparisons, which can be manipulated to a limited extent by miners, potentially affecting contract logic.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_19\n\nLANGUAGE: solidity\nCODE:\n```\nFoundryFacet.mint(address,uint256,address) (contracts/facets/FoundryFacet.sol#39-100) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- hub_.updating && block.timestamp > hub_.endTime (contracts/facets/FoundryFacet.sol#48)\n\t- block.timestamp > meToken_.endTime (contracts/facets/FoundryFacet.sol#51)\n\t- block.timestamp > meToken_.startTime (contracts/facets/FoundryFacet.sol#55)\n\t- meToken_.migration != address(0) && block.timestamp > meToken_.startTime (contracts/facets/FoundryFacet.sol#75-76)\nFoundryFacet.burn(address,uint256,address) (contracts/facets/FoundryFacet.sol#135-218) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- hub_.updating && block.timestamp > hub_.endTime (contracts/facets/FoundryFacet.sol#143)\n\t- meToken_.targetHubId != 0 && block.timestamp > meToken_.endTime (contracts/facets/FoundryFacet.sol#146)\n\t- meToken_.migration != address(0) && block.timestamp > meToken_.startTime (contracts/facets/FoundryFacet.sol#201-202)\n```\n\n----------------------------------------\n\nTITLE: Timestamp Dependencies in MeTokenRegistryFacet\nDESCRIPTION: Multiple functions in MeTokenRegistryFacet.sol that rely on block.timestamp for critical comparisons, which could be vulnerable to minor manipulation by miners.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_22\n\nLANGUAGE: solidity\nCODE:\n```\nrequire(bool,string)(block.timestamp >= meToken_.endCooldown,Cooldown not complete)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nrequire(bool,string)(block.timestamp < meToken_.startTime,Resubscription has started)\n```\n\n----------------------------------------\n\nTITLE: Timestamp Comparisons in LibHub and LibMeToken\nDESCRIPTION: Functions in the library contracts that use block.timestamp for state transition logic, potentially allowing miners to manipulate the timing of certain operations.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_23\n\nLANGUAGE: solidity\nCODE:\n```\nrequire(bool,string)(block.timestamp > hub_.endTime,Still updating)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nrequire(bool,string)(block.timestamp > meToken_.endTime,block.timestamp < endTime)\n```\n\n----------------------------------------\n\nTITLE: Timestamp Dependency in HubFacet Contract\nDESCRIPTION: A require statement in HubFacet.sol that uses block.timestamp for validation, which could be manipulated by miners within a small time window.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_21\n\nLANGUAGE: solidity\nCODE:\n```\nrequire(bool,string)(block.timestamp < hub_.startTime,Update has started)\n```\n\n----------------------------------------\n\nTITLE: Timestamp Dependencies in Weighted Average Calculations\nDESCRIPTION: Two implementations of weighted average calculations that use block.timestamp to determine the current position in a time-based transition.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_24\n\nLANGUAGE: solidity\nCODE:\n```\nblock.timestamp < startTime\n```\n\nLANGUAGE: solidity\nCODE:\n```\nblock.timestamp > endTime\n```\n\n----------------------------------------\n\nTITLE: Subscribing meToken to a Hub\nDESCRIPTION: Hardhat task for subscribing a meToken to a specific hub identified by its ID.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/README.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nyarn hardhat subscribe --diamond <Diamond address> --id 2  --network <\"mainnet\" or \"goerli\">\n```\n\n----------------------------------------\n\nTITLE: Division followed by Multiplication in optimalLog Function (Solidity)\nDESCRIPTION: The optimalLog function performs multiplication operations on the results of previous divisions, potentially causing precision loss. It uses fixed-point arithmetic with FIXED_1 as the denominator for division operations.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_5\n\nLANGUAGE: Solidity\nCODE:\n```\nw = (y * y) / FIXED_1\nz = (z * w) / FIXED_1\nres += (z * (0x089d89d89d89d89d89d89d89d89d89d89 - y)) / 0x700000000000000000000000000000000\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nw = (y * y) / FIXED_1\nz = (z * w) / FIXED_1\nz = (z * w) / FIXED_1\nres += (z * (0x088888888888888888888888888888888 - y)) / 0x800000000000000000000000000000000\n```\n\n----------------------------------------\n\nTITLE: Multiplication After Division in BancorABDK Contract\nDESCRIPTION: Slither identified potential precision loss where multiplications are performed on results of divisions in the BancorABDK contract. This can lead to rounding errors and unexpected behavior in calculations.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_2\n\nLANGUAGE: solidity\nCODE:\n```\nBancorABDK._viewMeTokensMinted(uint256,uint32,uint256,uint256) (contracts/curves/BancorABDK.sol#213-245) performs a multiplication on the result of a division:\n\t-exponent = uint256(_reserveWeight).fromUInt().div(_maxWeight) (contracts/curves/BancorABDK.sol#234)\n\t-res = _supply.fromUInt().mul((part1.ln().mul(exponent)).exp().sub(_one)) (contracts/curves/BancorABDK.sol#241-243)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nBancorABDK._viewMeTokensMintedFromZero(uint256,uint256,uint256) (contracts/curves/BancorABDK.sol#265-288) performs a multiplication on the result of a division:\n\t-numerator = _assetsDeposited.fromUInt().mul(_baseX.ln().mul(_one.div(reserveWeight)).exp()) (contracts/curves/BancorABDK.sol#272-274)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nBancorABDK._viewMeTokensMintedFromZero(uint256,uint256,uint256) (contracts/curves/BancorABDK.sol#265-288) performs a multiplication on the result of a division:\n\t-reserveWeight = _reserveWeight.fromUInt().div(_maxWeight) (contracts/curves/BancorABDK.sol#270)\n\t-denominator = reserveWeight.mul(_baseY.fromUInt()) (contracts/curves/BancorABDK.sol#277)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nBancorABDK._viewMeTokensMintedFromZero(uint256,uint256,uint256) (contracts/curves/BancorABDK.sol#265-288) performs a multiplication on the result of a division:\n\t-reserveWeight = _reserveWeight.fromUInt().div(_maxWeight) (contracts/curves/BancorABDK.sol#270)\n\t-res = (numerator.div(denominator)).ln().mul(reserveWeight).exp() (contracts/curves/BancorABDK.sol#283-286)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nBancorABDK._viewAssetsReturned(uint256,uint32,uint256,uint256) (contracts/curves/BancorABDK.sol#309-350) performs a multiplication on the result of a division:\n\t-exponent = _one.div(uint256(_reserveWeight).fromUInt().div(_maxWeight)) (contracts/curves/BancorABDK.sol#337-339)\n\t-res = _balancePooled.fromUInt().sub(_balancePooled.fromUInt().mul(s.ln().mul(exponent).exp())) (contracts/curves/BancorABDK.sol#346-348)\n```\n\n----------------------------------------\n\nTITLE: Multiplication After Division in BancorPower Contract\nDESCRIPTION: Slither identified potential precision loss where multiplications are performed on results of divisions in the BancorPower contract. This can lead to rounding errors and incorrect calculations.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_3\n\nLANGUAGE: solidity\nCODE:\n```\nBancorPower._viewMeTokensMintedFromZero(uint256,uint256,uint256) (contracts/curves/BancorPower.sol#228-252) performs a multiplication on the result of a division:\n\t-numerator = _assetsDeposited.fromUInt().mul(_baseX.ln().mul(_one.div(reserveWeight)).exp()) (contracts/curves/BancorPower.sol#235-237)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nBancorPower._viewMeTokensMintedFromZero(uint256,uint256,uint256) (contracts/curves/BancorPower.sol#228-252) performs a multiplication on the result of a division:\n\t-reserveWeight = _reserveWeight.fromUInt().div(_maxWeight) (contracts/curves/BancorPower.sol#233)\n\t-denominator = reserveWeight.mul(_baseY.fromUInt()) (contracts/curves/BancorPower.sol#240)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nBancorPower._viewMeTokensMintedFromZero(uint256,uint256,uint256) (contracts/curves/BancorPower.sol#228-252) performs a multiplication on the result of a division:\n\t-reserveWeight = _reserveWeight.fromUInt().div(_maxWeight) (contracts/curves/BancorPower.sol#233)\n\t-res = (numerator.div(denominator)).ln().mul(reserveWeight).exp() (contracts/curves/BancorPower.sol#246-249)\n```\n\n----------------------------------------\n\nTITLE: Multiplication After Division in Power Contract's optimalLog Function\nDESCRIPTION: Slither identified numerous cases in the Power contract's optimalLog function where multiplications are performed on results of divisions, which can lead to precision loss and calculation errors.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_4\n\nLANGUAGE: solidity\nCODE:\n```\nPower.optimalLog(uint256) (contracts/curves/Power.sol#384-459) performs a multiplication on the result of a division:\n\t-x = (x * FIXED_1) / 0xd3094c70f034de4b96ff7d5b6f99fcd8 (contracts/curves/Power.sol#393)\n\t-x = (x * FIXED_1) / 0xa45af1e1f40c333b3de1db4dd55f29a7 (contracts/curves/Power.sol#397)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nPower.optimalLog(uint256) (contracts/curves/Power.sol#384-459) performs a multiplication on the result of a division:\n\t-x = (x * FIXED_1) / 0xa45af1e1f40c333b3de1db4dd55f29a7 (contracts/curves/Power.sol#397)\n\t-x = (x * FIXED_1) / 0x910b022db7ae67ce76b441c27035c6a1 (contracts/curves/Power.sol#401)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nPower.optimalLog(uint256) (contracts/curves/Power.sol#384-459) performs a multiplication on the result of a division:\n\t-x = (x * FIXED_1) / 0x910b022db7ae67ce76b441c27035c6a1 (contracts/curves/Power.sol#401)\n\t-x = (x * FIXED_1) / 0x88415abbe9a76bead8d00cf112e4d4a8 (contracts/curves/Power.sol#405)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nPower.optimalLog(uint256) (contracts/curves/Power.sol#384-459) performs a multiplication on the result of a division:\n\t-x = (x * FIXED_1) / 0x88415abbe9a76bead8d00cf112e4d4a8 (contracts/curves/Power.sol#405)\n\t-x = (x * FIXED_1) / 0x84102b00893f64c705e841d5d4064bd3 (contracts/curves/Power.sol#409)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nPower.optimalLog(uint256) (contracts/curves/Power.sol#384-459) performs a multiplication on the result of a division:\n\t-x = (x * FIXED_1) / 0x84102b00893f64c705e841d5d4064bd3 (contracts/curves/Power.sol#409)\n\t-x = (x * FIXED_1) / 0x8204055aaef1c8bd5c3259f4822735a2 (contracts/curves/Power.sol#413)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nPower.optimalLog(uint256) (contracts/curves/Power.sol#384-459) performs a multiplication on the result of a division:\n\t-x = (x * FIXED_1) / 0x8204055aaef1c8bd5c3259f4822735a2 (contracts/curves/Power.sol#413)\n\t-x = (x * FIXED_1) / 0x810100ab00222d861931c15e39b44e99 (contracts/curves/Power.sol#417)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nPower.optimalLog(uint256) (contracts/curves/Power.sol#384-459) performs a multiplication on the result of a division:\n\t-x = (x * FIXED_1) / 0x810100ab00222d861931c15e39b44e99 (contracts/curves/Power.sol#417)\n\t-x = (x * FIXED_1) / 0x808040155aabbbe9451521693554f733 (contracts/curves/Power.sol#421)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nPower.optimalLog(uint256) (contracts/curves/Power.sol#384-459) performs a multiplication on the result of a division:\n\t-w = (y * y) / FIXED_1 (contracts/curves/Power.sol#425)\n\t-z = (z * w) / FIXED_1 (contracts/curves/Power.sol#429)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nPower.optimalLog(uint256) (contracts/curves/Power.sol#384-459) performs a multiplication on the result of a division:\n\t-z = (z * w) / FIXED_1 (contracts/curves/Power.sol#429)\n\t-res += (z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y)) / 0x200000000000000000000000000000000 (contracts/curves/Power.sol#430-432)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nPower.optimalLog(uint256) (contracts/curves/Power.sol#384-459) performs a multiplication on the result of a division:\n\t-w = (y * y) / FIXED_1 (contracts/curves/Power.sol#425)\n\t-z = (z * w) / FIXED_1 (contracts/curves/Power.sol#429)\n\t-z = (z * w) / FIXED_1 (contracts/curves/Power.sol#433)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nPower.optimalLog(uint256) (contracts/curves/Power.sol#384-459) performs a multiplication on the result of a division:\n\t-z = (z * w) / FIXED_1 (contracts/curves/Power.sol#433)\n\t-res += (z * (0x099999999999999999999999999999999 - y)) / 0x300000000000000000000000000000000 (contracts/curves/Power.sol#434-436)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nPower.optimalLog(uint256) (contracts/curves/Power.sol#384-459) performs a multiplication on the result of a division:\n\t-w = (y * y) / FIXED_1 (contracts/curves/Power.sol#425)\n\t-z = (z * w) / FIXED_1 (contracts/curves/Power.sol#433)\n\t-z = (z * w) / FIXED_1 (contracts/curves/Power.sol#437)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nPower.optimalLog(uint256) (contracts/curves/Power.sol#384-459) performs a multiplication on the result of a division:\n\t-z = (z * w) / FIXED_1 (contracts/curves/Power.sol#437)\n\t-res += (z * (0x092492492492492492492492492492492 - y)) / 0x400000000000000000000000000000000 (contracts/curves/Power.sol#438-440)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nPower.optimalLog(uint256) (contracts/curves/Power.sol#384-459) performs a multiplication on the result of a division:\n\t-w = (y * y) / FIXED_1 (contracts/curves/Power.sol#425)\n\t-z = (z * w) / FIXED_1 (contracts/curves/Power.sol#437)\n\t-z = (z * w) / FIXED_1 (contracts/curves/Power.sol#441)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nPower.optimalLog(uint256) (contracts/curves/Power.sol#384-459) performs a multiplication on the result of a division:\n\t-z = (z * w) / FIXED_1 (contracts/curves/Power.sol#441)\n\t-res += (z * (0x08e38e38e38e38e38e38e38e38e38e38e - y)) / 0x500000000000000000000000000000000 (contracts/curves/Power.sol#442-444)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nPower.optimalLog(uint256) (contracts/curves/Power.sol#384-459) performs a multiplication on the result of a division:\n\t-w = (y * y) / FIXED_1 (contracts/curves/Power.sol#425)\n\t-z = (z * w) / FIXED_1 (contracts/curves/Power.sol#441)\n\t-z = (z * w) / FIXED_1 (contracts/curves/Power.sol#445)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nPower.optimalLog(uint256) (contracts/curves/Power.sol#384-459) performs a multiplication on the result of a division:\n\t-z = (z * w) / FIXED_1 (contracts/curves/Power.sol#445)\n\t-res += (z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y)) / 0x600000000000000000000000000000000 (contracts/curves/Power.sol#446-448)\n```\n\n----------------------------------------\n\nTITLE: Division followed by Multiplication in optimalExp Function (Solidity)\nDESCRIPTION: The optimalExp function performs multiplication operations on the results of previous divisions, which may cause precision loss. It uses fixed-point arithmetic with FIXED_1 as the denominator and calculates exponential approximations through Taylor series terms.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_6\n\nLANGUAGE: Solidity\nCODE:\n```\nz = (z * y) / FIXED_1\nres += z * 0x10e1b3be415a0000\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nz = (z * y) / FIXED_1\nz = (z * y) / FIXED_1\nres += z * 0x05a0913f6b1e0000\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nz = (z * y) / FIXED_1\nz = (z * y) / FIXED_1\nres += z * 0x0168244fdac78000\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nz = (z * y) / FIXED_1\nz = (z * y) / FIXED_1\nres += z * 0x004807432bc18000\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nz = (z * y) / FIXED_1\nz = (z * y) / FIXED_1\nres += z * 0x000c0135dca04000\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nz = (z * y) / FIXED_1\nz = (z * y) / FIXED_1\nres += z * 0x0001b707b1cdc000\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nz = (z * y) / FIXED_1\nz = (z * y) / FIXED_1\nres += z * 0x000036e0f639b800\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nz = (z * y) / FIXED_1\nz = (z * y) / FIXED_1\nres += z * 0x00000618fee9f800\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nz = (z * y) / FIXED_1\nz = (z * y) / FIXED_1\nres += z * 0x0000009c197dcc00\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nz = (z * y) / FIXED_1\nz = (z * y) / FIXED_1\nres += z * 0x0000000e30dce400\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nz = (z * y) / FIXED_1\nz = (z * y) / FIXED_1\nres += z * 0x000000012ebd1300\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nz = (z * y) / FIXED_1\nz = (z * y) / FIXED_1\nres += z * 0x0000000017499f00\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nz = (z * y) / FIXED_1\nz = (z * y) / FIXED_1\nres += z * 0x0000000001a9d480\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nz = (z * y) / FIXED_1\nz = (z * y) / FIXED_1\nres += z * 0x00000000001c6380\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nz = (z * y) / FIXED_1\nz = (z * y) / FIXED_1\nres += z * 0x000000000001c638\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nz = (z * y) / FIXED_1\nz = (z * y) / FIXED_1\nres += z * 0x0000000000001ab8\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nz = (z * y) / FIXED_1\nz = (z * y) / FIXED_1\nres += z * 0x000000000000017c\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nz = (z * y) / FIXED_1\nz = (z * y) / FIXED_1\nres += z * 0x0000000000000014\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nz = (z * y) / FIXED_1\nz = (z * y) / FIXED_1\nres += z * 0x0000000000000001\n```\n\n----------------------------------------\n\nTITLE: Ignored Return Values\nDESCRIPTION: Several function calls ignore their return values, which could lead to silent failures and unexpected behavior in the contract execution.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_14\n\nLANGUAGE: Solidity\nCODE:\n```\nLibHub.finishUpdate(_id);\nLibHub.finishUpdate(id);\nIMigration(meToken_.migration).finishMigration(_meToken);\nIERC20(hub_.asset).approve(address(_router),amountIn);\n```\n\n----------------------------------------\n\nTITLE: Multiplication After Division in Power.optimalExp Function\nDESCRIPTION: The Power.optimalExp function performs multiplications on the results of divisions, which could lead to precision loss. This occurs in multiple instances within the function.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_7\n\nLANGUAGE: Solidity\nCODE:\n```\nres = (res * 0x1c3d6a24ed82218787d624d3e5eba95f9) / 0x18ebef9eac820ae8682b9793ac6d1e776\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nres = (res * 0x18ebef9eac820ae8682b9793ac6d1e778) / 0x1368b2fc6f9609fe7aceb46aa619baed4\n```\n\n----------------------------------------\n\nTITLE: Variable Shadowing in MeToken Constructor (Solidity)\nDESCRIPTION: The _symbol parameter in MeToken's constructor shadows a state variable with the same name defined in the parent ERC20 contract, which could lead to confusion and potential bugs.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_15\n\nLANGUAGE: solidity\nCODE:\n```\nMeToken.constructor(string,string,address)._symbol (contracts/MeToken.sol#15) shadows:\n\t- ERC20._symbol (node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol#43) (state variable)\n```\n\n----------------------------------------\n\nTITLE: Uninitialized Local Variables\nDESCRIPTION: Multiple instances of local variables being used without proper initialization across different contracts, which could lead to unexpected behavior.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_13\n\nLANGUAGE: Solidity\nCODE:\n```\nMeTokenRegistryFacet.subscribe(string,string,uint256,uint256)._meTokensMinted\nDiamondLoupeFacet.facets().i\nLibDiamond.removeFunctions(address,bytes4[]).selectorIndex\nLibDiamond.replaceFunctions(address,bytes4[]).selectorIndex\nLibDiamond.diamondCut(IDiamondCut.FacetCut[],address,bytes).facetIndex\nLibDiamond.addFunctions(address,bytes4[]).selectorIndex\nHubFacet.initUpdate(uint256,address,uint256,bytes).reconfigure\nPower.optimalExp(uint256).y\nPower.optimalLog(uint256).y\n```\n\n----------------------------------------\n\nTITLE: Registering a Hub in meTokens\nDESCRIPTION: Hardhat task for registering a new hub with specified parameters including the Diamond address, Vault address, ERC20 asset address, base-y value, and reserve weight.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/README.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyarn hardhat register-hub --diamond <Diamond address> --vault <Vault address> --asset <ERC20 asset address> --base-y \"224\" --reserve-weight 32  --network <\"mainnet\" or \"goerli\">\n```\n\n----------------------------------------\n\nTITLE: Adding and Approving Vault in Registry\nDESCRIPTION: Hardhat task for adding a new vault and approving it in the vault registry. Requires Diamond address, VaultRegistry address, new Vault address, and network specification.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn hardhat add-vault --diamond <Diamond address>  --registry <VaultRegistry address> --vault <new Vault address>  --network <\"mainnet\" or \"goerli\">\n```\n\n----------------------------------------\n\nTITLE: Function Visibility Recommendations for OpenZeppelin Contracts in Solidity\nDESCRIPTION: A list of functions from OpenZeppelin contracts (Ownable, ERC20, ERC20Burnable) that should be declared as external instead of public for gas optimization. External functions are slightly more efficient when function parameters are memory variables.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_58\n\nLANGUAGE: solidity\nCODE:\n```\nrenounceOwnership() should be declared external:\n\t- Ownable.renounceOwnership() (node_modules/@openzeppelin/contracts/access/Ownable.sol#54-56)\n```\n\nLANGUAGE: solidity\nCODE:\n```\ntransferOwnership(address) should be declared external:\n\t- Ownable.transferOwnership(address) (node_modules/@openzeppelin/contracts/access/Ownable.sol#62-65)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nname() should be declared external:\n\t- ERC20.name() (node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol#62-64)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nsymbol() should be declared external:\n\t- ERC20.symbol() (node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol#70-72)\n```\n\nLANGUAGE: solidity\nCODE:\n```\ndecimals() should be declared external:\n\t- ERC20.decimals() (node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol#87-89)\n```\n\nLANGUAGE: solidity\nCODE:\n```\ntotalSupply() should be declared external:\n\t- ERC20.totalSupply() (node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol#94-96)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nbalanceOf(address) should be declared external:\n\t- ERC20.balanceOf(address) (node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol#101-103)\n```\n\nLANGUAGE: solidity\nCODE:\n```\ntransfer(address,uint256) should be declared external:\n\t- ERC20.transfer(address,uint256) (node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol#113-117)\n```\n\nLANGUAGE: solidity\nCODE:\n```\napprove(address,uint256) should be declared external:\n\t- ERC20.approve(address,uint256) (node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol#136-140)\n```\n\nLANGUAGE: solidity\nCODE:\n```\ntransferFrom(address,address,uint256) should be declared external:\n\t- ERC20.transferFrom(address,address,uint256) (node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol#158-167)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nincreaseAllowance(address,uint256) should be declared external:\n\t- ERC20.increaseAllowance(address,uint256) (node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol#181-185)\n```\n\nLANGUAGE: solidity\nCODE:\n```\ndecreaseAllowance(address,uint256) should be declared external:\n\t- ERC20.decreaseAllowance(address,uint256) (node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol#201-210)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nburn(uint256) should be declared external:\n\t- ERC20Burnable.burn(uint256) (node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol#20-22)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nburnFrom(address,uint256) should be declared external:\n\t- ERC20Burnable.burnFrom(address,uint256) (node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol#35-38)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Hub Information\nDESCRIPTION: Hardhat task for retrieving information about a specific hub by its ID.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/README.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nyarn hardhat hub-info --diamond <Diamond address> --id 2  --network <\"mainnet\" or \"goerli\">\n```\n\n----------------------------------------\n\nTITLE: Low Level Contract Calls\nDESCRIPTION: Implementation of low-level calls in Address library and LibDiamond for various contract interactions including value transfers and delegate calls.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_32\n\nLANGUAGE: solidity\nCODE:\n```\nAddress.sendValue(address,uint256) (node_modules/@openzeppelin/contracts/utils/Address.sol#60-65)\nAddress.functionCallWithValue(address,bytes,uint256,string) (node_modules/@openzeppelin/contracts/utils/Address.sol#128-139)\nAddress.functionStaticCall(address,bytes,string) (node_modules/@openzeppelin/contracts/utils/Address.sol#157-166)\nAddress.functionDelegateCall(address,bytes,string) (node_modules/@openzeppelin/contracts/utils/Address.sol#184-193)\nLibDiamond.initializeDiamondCut(address,bytes) (contracts/libs/LibDiamond.sol#271-300)\n```\n\n----------------------------------------\n\nTITLE: Assembly Usage in Diamond Contract Fallback Function\nDESCRIPTION: The Diamond contract's fallback function uses inline assembly for delegatecall functionality, which is a core part of the Diamond pattern implementation.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_27\n\nLANGUAGE: solidity\nCODE:\n```\nINLINE ASM (contracts/Diamond.sol#40-42)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nINLINE ASM (contracts/Diamond.sol#47-62)\n```\n\n----------------------------------------\n\nTITLE: Assembly Usage in OpenZeppelin Address Contract\nDESCRIPTION: The Address utility contract uses inline assembly for result verification, which bypasses Solidity's safety checks but is necessary for specific low-level operations.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_26\n\nLANGUAGE: solidity\nCODE:\n```\nINLINE ASM (node_modules/@openzeppelin/contracts/utils/Address.sol#213-216)\n```\n\n----------------------------------------\n\nTITLE: Assembly Usage for Chain ID and Sender Metadata\nDESCRIPTION: Library functions using assembly to retrieve chain ID and determine the message sender, particularly important for meta-transactions and cross-chain functionality.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_29\n\nLANGUAGE: solidity\nCODE:\n```\nINLINE ASM (contracts/libs/LibMeta.sol#29-31)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nINLINE ASM (contracts/libs/LibMeta.sol#38-44)\n```\n\n----------------------------------------\n\nTITLE: Timestamp Dependencies in UniswapSingleTransferMigration\nDESCRIPTION: Migration contract that uses block.timestamp for migration status checks and completion validation, which could be potentially manipulated by miners.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_25\n\nLANGUAGE: solidity\nCODE:\n```\nusts_.soonest != 0 && block.timestamp > usts_.soonest && ! usts_.started\n```\n\nLANGUAGE: solidity\nCODE:\n```\nrequire(bool,string)(usts_.soonest < block.timestamp,timestamp < soonest)\n```\n\nLANGUAGE: solidity\nCODE:\n```\namountIn == 0 || ! usts_.started || usts_.swapped || usts_.soonest == 0 || usts_.soonest > block.timestamp\n```\n\n----------------------------------------\n\nTITLE: Solidity Version Inconsistency\nDESCRIPTION: The project uses multiple Solidity compiler versions including >=0.5.0, >=0.7.5, ^0.8, ^0.8.0, and ^0.8.1, which could lead to inconsistent behavior or compatibility issues between contracts.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_30\n\nLANGUAGE: solidity\nCODE:\n```\nDifferent versions of Solidity is used:\n\t- Version used: ['>=0.5.0', '>=0.7.5', '^0.8', '^0.8.0', '^0.8.1']\n```\n\n----------------------------------------\n\nTITLE: Unused Library Functions in LibHub and LibMeta\nDESCRIPTION: Several unused functions identified in LibHub and LibMeta libraries that should be removed for code optimization.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_31\n\nLANGUAGE: solidity\nCODE:\n```\nLibHub.count() (contracts/libs/LibHub.sol#74-77)\nLibMeta.domainSeparator(string,string) (contracts/libs/LibMeta.sol#12-26)\nLibMeta.getChainID() (contracts/libs/LibMeta.sol#28-32)\nLibMeta.msgSender() (contracts/libs/LibMeta.sol#34-48)\n```\n\n----------------------------------------\n\nTITLE: Compiling meTokens-Core Smart Contracts\nDESCRIPTION: Command to compile the smart contracts using the CI compiler configuration.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn compileCI\n```\n\n----------------------------------------\n\nTITLE: Assembly Usage in Storage Management Functions\nDESCRIPTION: Library functions that use assembly to manage diamond storage patterns, accessing specific storage slots directly for efficiency and upgradability.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_28\n\nLANGUAGE: solidity\nCODE:\n```\nINLINE ASM (contracts/libs/Details.sol#54-56)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nINLINE ASM (contracts/libs/LibDiamond.sol#319-321)\n```\n\n----------------------------------------\n\nTITLE: Running meTokens-Core Test Suite\nDESCRIPTION: Command to execute the test suite for the smart contracts using Hardhat.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn hardhat test\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for meTokens-Core\nDESCRIPTION: Command to install project dependencies using Yarn package manager.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn install\n```\n\n----------------------------------------\n\nTITLE: Non-Standard Parameter Naming\nDESCRIPTION: Multiple instances of parameters not following mixedCase naming convention in various contract functions.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_33\n\nLANGUAGE: solidity\nCODE:\n```\nDiamondInit.init(DiamondInit.Args)._args\nMeTokenFactory.create(string,string,address)._name\nMeTokenFactory.create(string,string,address)._symbol\nMeTokenFactory.create(string,string,address)._diamond\nBancorABDK.register(uint256,bytes)._hubId\nBancorABDK.register(uint256,bytes)._encodedDetails\nBancorABDK.initReconfigure(uint256,bytes)._hubId\n```\n\n----------------------------------------\n\nTITLE: Variable Naming Similarity in Solidity Smart Contracts\nDESCRIPTION: Identifies variables with names that are too similar, which could lead to confusion or errors. This includes variables in different contracts and functions.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_35\n\nLANGUAGE: Solidity\nCODE:\n```\nStepwiseCurveABDK._viewAssetsReturned(uint256,uint256,uint256,uint256,uint256)._meTokensBurned\nStepwiseCurveABDK._viewAssetsReturned(uint256,uint256,uint256,uint256,uint256).meTokensBurned_\nICurve.viewTargetAssetsReturned(uint256,uint256,uint256,uint256)._meTokensBurned\nStepwiseCurveABDK.initReconfigure(uint256,bytes).targetStepX\nStepwiseCurveABDK.initReconfigure(uint256,bytes).targetStepY\n```\n\n----------------------------------------\n\nTITLE: Non-compliant Parameter Names in Solidity Smart Contracts\nDESCRIPTION: List of function parameters that violate Solidity naming conventions by using underscore prefix (_) instead of mixedCase. These parameters are found across multiple contract files including curves implementations.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_34\n\nLANGUAGE: solidity\nCODE:\n```\n// Example of non-compliant parameter names:\nBancorABDK.initReconfigure(uint256,bytes)._encodedDetails\nBancorABDK.finishReconfigure(uint256)._hubId\nPower.power(uint256,uint256,uint32,uint32)._baseN\n```\n\n----------------------------------------\n\nTITLE: ABDKMathQuad Constant Definitions in Solidity\nDESCRIPTION: Definitions of important mathematical constants in the ABDKMathQuad library including positive/negative zero, positive/negative infinity, and NaN. These constants are represented as 32-character hexadecimal literals.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_56\n\nLANGUAGE: solidity\nCODE:\n```\n_POSITIVE_ZERO = 0x00000000000000000000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\n_NEGATIVE_ZERO = 0x80000000000000000000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\n_POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\n_NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\nNaN = 0x7FFF8000000000000000000000000000\n```\n\n----------------------------------------\n\nTITLE: ABDKMathQuad Addition Implementation\nDESCRIPTION: Addition operation for IEEE 754 quadruple precision values in the ABDKMathQuad library. This complex implementation handles sign bits, exponents, and significands separately with bit manipulation using large hexadecimal constants.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_42\n\nLANGUAGE: solidity\nCODE:\n```\n// From add function\nxSign = uint128(x) >= 0x80000000000000000000000000000000;\nxSignifier |= 0x10000000000000000000000000000;\nySign = uint128(y) >= 0x80000000000000000000000000000000;\nySignifier |= 0x10000000000000000000000000000;\nxSignifier >= 0x20000000000000000000000000000;\nxSignifier < 0x10000000000000000000000000000;\nbytes16(uint128((0x80000000000000000000000000000000) | (xExponent << 112) | xSignifier));\nbytes16(uint128((0x80000000000000000000000000000000) | (xExponent << 112) | xSignifier));\n```\n\n----------------------------------------\n\nTITLE: ABDKMathQuad Subtraction Implementation\nDESCRIPTION: Subtraction function for IEEE 754 quadruple precision values in the ABDKMathQuad library. It leverages the add function by flipping the sign bit of the second operand using XOR with a large hexadecimal constant.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_43\n\nLANGUAGE: solidity\nCODE:\n```\n// From sub function\nadd(x,y ^ 0x80000000000000000000000000000000);\n```\n\n----------------------------------------\n\nTITLE: Power Contract Version Variable in Solidity\nDESCRIPTION: The Power contract contains a 'version' state variable that should be declared as constant according to the static analyzer. This would optimize gas usage by not storing the variable in contract storage.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_57\n\nLANGUAGE: solidity\nCODE:\n```\nPower.version (contracts/curves/Power.sol#13) should be constant\n```\n\n----------------------------------------\n\nTITLE: ABDKMathQuad Comparison Operations\nDESCRIPTION: Comparison function from ABDKMathQuad library that handles IEEE 754 quadruple precision values. The implementation uses bit manipulation and large hexadecimal constants to handle special floating-point cases.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_41\n\nLANGUAGE: solidity\nCODE:\n```\n// From cmp function\nrequire(bool)(absoluteX <= 0x7FFF0000000000000000000000000000);\nrequire(bool)(absoluteY <= 0x7FFF0000000000000000000000000000);\nrequire(bool)(x != y || absoluteX < 0x7FFF0000000000000000000000000000);\nnegativeX = uint128(x) >= 0x80000000000000000000000000000000;\nnegativeY = uint128(y) >= 0x80000000000000000000000000000000;\n```\n\n----------------------------------------\n\nTITLE: Large Numeric Literals in Solidity Power Contract's optimalLog Function\nDESCRIPTION: Identifies the use of large numeric literals in the Power contract's optimalLog function. These literals are used for bitwise operations and mathematical calculations in logarithm computation.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_37\n\nLANGUAGE: Solidity\nCODE:\n```\nPower.optimalLog(uint256) (contracts/curves/Power.sol#384-459) uses literals with too many digits:\n\tres += 0x40000000000000000000000000000000\n\tres += 0x20000000000000000000000000000000\n\t// ... (additional similar lines omitted for brevity)\n\tres += (z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y)) / 0x600000000000000000000000000000000\n```\n\n----------------------------------------\n\nTITLE: Excessive Digit Literals in ABDKMathQuad.div() Function\nDESCRIPTION: This section shows where the div() function uses large numeric literals for bit manipulation, signifier operations, and boundary checks when implementing quad-precision floating-point division.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_46\n\nLANGUAGE: solidity\nCODE:\n```\nx ^ (y & 0x80000000000000000000000000000000)\n```\n\nLANGUAGE: solidity\nCODE:\n```\n_POSITIVE_ZERO | ((x ^ y) & 0x80000000000000000000000000000000)\n```\n\nLANGUAGE: solidity\nCODE:\n```\n_POSITIVE_INFINITY | ((x ^ y) & 0x80000000000000000000000000000000)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nySignifier |= 0x10000000000000000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier = (xSignifier | 0x10000000000000000000000000000) << 114\n```\n\nLANGUAGE: solidity\nCODE:\n```\nassert(bool)(xSignifier >= 0x1000000000000000000000000000)\n```\n\nLANGUAGE: solidity\nCODE:\n```\nbytes16(uint128(uint128((x ^ y) & 0x80000000000000000000000000000000) | (xExponent << 112) | xSignifier))\n```\n\nLANGUAGE: solidity\nCODE:\n```\n(x ^ y) & 0x80000000000000000000000000000000 > 0\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier >= 0x80000000000000000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier >= 0x40000000000000000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier >= 0x20000000000000000000000000000\n```\n\n----------------------------------------\n\nTITLE: Excessive Digit Literals in ABDKMathQuad.sqrt() Function\nDESCRIPTION: This section highlights where the sqrt() function uses large numeric literals for implementing quad-precision floating-point square root calculations, including bit comparisons and initialization values.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_47\n\nLANGUAGE: solidity\nCODE:\n```\nuint128(x) > 0x80000000000000000000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier |= 0x10000000000000000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier >= 0x10000000000000000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\nr = 0x10000000000000000000000000000\n```\n\n----------------------------------------\n\nTITLE: Excessive Digit Literals in ABDKMathQuad.pow_2() Function\nDESCRIPTION: This section identifies multiple instances where the pow_2() function uses large numeric literals for bit masking, comparison operations, and signifier manipulation when calculating 2 raised to the power of a quad-precision value.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_49\n\nLANGUAGE: solidity\nCODE:\n```\nxNegative = uint128(x) > 0x80000000000000000000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\n0x3FFF0000000000000000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier |= 0x10000000000000000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxNegative && xSignifier > 0x406E00000000000000000000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\nresultSignifier = 0x80000000000000000000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier & 0x80000000000000000000000000000000 > 0\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier & 0x40000000000000000000000000000000 > 0\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier & 0x20000000000000000000000000000000 > 0\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier & 0x10000000000000000000000000000000 > 0\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier & 0x8000000000000000000000000000000 > 0\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier & 0x4000000000000000000000000000000 > 0\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier & 0x2000000000000000000000000000000 > 0\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier & 0x1000000000000000000000000000000 > 0\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier & 0x800000000000000000000000000000 > 0\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier & 0x400000000000000000000000000000 > 0\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier & 0x200000000000000000000000000000 > 0\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier & 0x100000000000000000000000000000 > 0\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier & 0x80000000000000000000000000000 > 0\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier & 0x40000000000000000000000000000 > 0\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier & 0x20000000000000000000000000000 > 0\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier & 0x10000000000000000000000000000 > 0\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier & 0x8000000000000000000000000000 > 0\n```\n\n----------------------------------------\n\nTITLE: Power Contract Mathematical Operations with Large Hexadecimal Literals\nDESCRIPTION: This code contains implementations of optimalLog and optimalExp functions in the Power contract, which use high-precision hexadecimal literals for mathematical calculations. These functions are optimized implementations for logarithm and exponentiation in Solidity.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_38\n\nLANGUAGE: solidity\nCODE:\n```\n// From optimalLog function\nres += (z * (0x089d89d89d89d89d89d89d89d89d89d89 - y)) / 0x700000000000000000000000000000000;\nres += (z * (0x088888888888888888888888888888888 - y)) / 0x800000000000000000000000000000000;\n\n// From optimalExp function\nz = y = x % 0x10000000000000000000000000000000;\nres += z * 0x00000618fee9f800;\nres += z * 0x0000009c197dcc00;\nres += z * 0x0000000e30dce400;\nres += z * 0x000000012ebd1300;\nres += z * 0x0000000017499f00;\nres += z * 0x0000000001a9d480;\nres += z * 0x00000000001c6380;\nres += z * 0x000000000001c638;\nres += z * 0x0000000000001ab8;\nres += z * 0x000000000000017c;\nres += z * 0x0000000000000014;\nres += z * 0x0000000000000001;\n\n(x & 0x010000000000000000000000000000000) != 0;\n(x & 0x020000000000000000000000000000000) != 0;\n(x & 0x040000000000000000000000000000000) != 0;\n(x & 0x080000000000000000000000000000000) != 0;\n(x & 0x100000000000000000000000000000000) != 0;\n(x & 0x200000000000000000000000000000000) != 0;\n(x & 0x400000000000000000000000000000000) != 0;\n\nres = (res * 0x0002bf84208204f5977f9a8cf01fdc307) / 0x0000003c6ab775dd0b95b4cbee7e65d11;\n```\n\n----------------------------------------\n\nTITLE: Analyzing Bitwise Operations in ABDKMathQuad.pow_2 Function\nDESCRIPTION: These snippets show various bitwise operations in the pow_2 function using large hexadecimal literals. The function uses bitwise AND operations to check specific bits and performs multiplication with large hex constants for precise calculations.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_50\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x4000000000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x2000000000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x1000000000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x100000B1721BCFC99D9F890EA06911763) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x800000000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x400000000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x200000000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x100000162E430E5A18F6119E3C02282A5) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x100000000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x80000000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x40000000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x20000000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x10000000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x8000000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x4000000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x2000000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x1000000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x100000000B17217F80F4EF5AADDA45554) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x800000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x400000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x200000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x100000000162E42FEFB2FED257559BDAA) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x100000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x80000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x40000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x20000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x1000000000162E42FEFA494F1478FDE05) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x10000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x10000000000B17217F7D20CF927C8E94C) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x8000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D) >> 128\n```\n\n----------------------------------------\n\nTITLE: Bitwise Operations and Large Literals in ABDKMathQuad.pow_2 Function\nDESCRIPTION: This code snippet shows portions of the ABDKMathQuad.pow_2 function implementation where large numeric literals are used for bitwise operations and mathematical calculations. The function appears to be performing binary exponentiation with high precision fixed-point math.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_51\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x4000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x100000000002C5C85FDF477B662B26945) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x2000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x10000000000162E42FEFA3AE53369388C) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x1000000000000000000000 > 0\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x100000000000B17217F7D1D351A389D40) >> 128\n```\n\n----------------------------------------\n\nTITLE: Large Literals in ABDKMathQuad pow_2 Function\nDESCRIPTION: Implementation of pow_2 function in ABDKMathQuad contract showing usage of large hexadecimal literals for bit manipulation and mathematical calculations. The function uses bitwise operations and right shifts to compute powers.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_53\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x8000000000 > 0\nresultSignifier = (resultSignifier * 0x1000000000000000000000058B90BFBE7) >> 128\nxSignifier & 0x4000000000 > 0\nresultSignifier = (resultSignifier * 0x100000000000000000000002C5C85FDF3) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x2000000000 > 0\nresultSignifier = (resultSignifier * 0x10000000000000000000000162E42FEF9) >> 128\nxSignifier & 0x1000000000 > 0\nresultSignifier = (resultSignifier * 0x100000000000000000000000B17217F7C) >> 128\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nxSignifier & 0x800000000 > 0\nresultSignifier = (resultSignifier * 0x10000000000000000000000058B90BFBD) >> 128\nxSignifier & 0x400000000 > 0\nresultSignifier = (resultSignifier * 0x1000000000000000000000002C5C85FDE) >> 128\n```\n\n----------------------------------------\n\nTITLE: ABDKMathQuad pow_2 Function Using Large Numeric Literals in Solidity\nDESCRIPTION: The pow_2 function in ABDKMathQuad library contains multiple operations with very large hexadecimal literals (too many digits) for calculating power operations on bytes16 values. These operations perform binary arithmetic shifts for precise mathematical calculations.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_54\n\nLANGUAGE: solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x100000000000000000000000000000B16) >> 128\n```\n\nLANGUAGE: solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x10000000000000000000000000000058A) >> 128\n```\n\nLANGUAGE: solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x1000000000000000000000000000002C4) >> 128\n```\n\nLANGUAGE: solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x100000000000000000000000000000161) >> 128\n```\n\nLANGUAGE: solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x1000000000000000000000000000000B0) >> 128\n```\n\nLANGUAGE: solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x100000000000000000000000000000057) >> 128\n```\n\nLANGUAGE: solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x10000000000000000000000000000002B) >> 128\n```\n\nLANGUAGE: solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x100000000000000000000000000000015) >> 128\n```\n\nLANGUAGE: solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x10000000000000000000000000000000A) >> 128\n```\n\nLANGUAGE: solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x100000000000000000000000000000004) >> 128\n```\n\nLANGUAGE: solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x100000000000000000000000000000001) >> 128\n```\n\n----------------------------------------\n\nTITLE: ABDKMathQuad mostSignificantBit Function with Large Literals in Solidity\nDESCRIPTION: The mostSignificantBit function in ABDKMathQuad contains conditionals with large hexadecimal literals to determine bit positions in uint256 values. This function is used for finding the position of the most significant bit in a number.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_55\n\nLANGUAGE: solidity\nCODE:\n```\nx >= 0x100000000000000000000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\nx >= 0x10000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\nx >= 0x100000000\n```\n\n----------------------------------------\n\nTITLE: BancorPower Contract Constants Definition\nDESCRIPTION: Constants defined in the BancorPower contract for mathematical operations. These large hexadecimal literals are used as fixed-point precision constants for power and logarithm calculations in the Bancor protocol.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_39\n\nLANGUAGE: solidity\nCODE:\n```\nFIXED_1 = 0x080000000000000000000000000000000;\nFIXED_2 = 0x100000000000000000000000000000000;\nMAX_NUM = 0x200000000000000000000000000000000;\nOPT_EXP_MAX_VAL = 0x800000000000000000000000000000000;\n```\n\n----------------------------------------\n\nTITLE: ABDKMathQuad Integer Conversion Operations\nDESCRIPTION: Functions from ABDKMathQuad library for converting IEEE 754 quadruple precision values to unsigned integers. The code handles edge cases and applies bit masking operations with precise hexadecimal constants.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_40\n\nLANGUAGE: solidity\nCODE:\n```\n// From toUInt function\nrequire(bool)(uint128(x) < 0x80000000000000000000000000000000);\nresult = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | 0x10000000000000000000000000000;\n```\n\n----------------------------------------\n\nTITLE: ABDKMathQuad Multiplication Implementation\nDESCRIPTION: Multiplication function for IEEE 754 quadruple precision values in the ABDKMathQuad library. This implementation handles sign bits, exponents, and significands with bit manipulation operations using large hexadecimal constants.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_44\n\nLANGUAGE: solidity\nCODE:\n```\n// From mul function\nx ^ (y & 0x80000000000000000000000000000000);\nx ^ y == 0x80000000000000000000000000000000;\nx ^ (y & 0x80000000000000000000000000000000);\ny ^ (x & 0x80000000000000000000000000000000);\nxSignifier |= 0x10000000000000000000000000000;\nySignifier |= 0x10000000000000000000000000000;\nbytes16(uint128(uint128((x ^ y) & 0x80000000000000000000000000000000) | (xExponent << 112) | xSignifier));\n```\n\n----------------------------------------\n\nTITLE: Excessive Digit Literals in ABDKMathQuad.mul() Function\nDESCRIPTION: This section identifies instances in the mul() function where numeric literals with excessive digits are used for bit manipulation and comparison operations, typically for handling quad-precision floating-point numbers.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_45\n\nLANGUAGE: solidity\nCODE:\n```\n(x ^ y) & 0x80000000000000000000000000000000 > 0\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier >= 0x200000000000000000000000000000000000000000000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier >= 0x100000000000000000000000000000000000000000000000000000000\n```\n\n----------------------------------------\n\nTITLE: Excessive Digit Literals in ABDKMathQuad.log_2() Function\nDESCRIPTION: This section shows instances where the log_2() function uses literals with too many digits for bit manipulation and value comparison when calculating binary logarithms in quad-precision.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_48\n\nLANGUAGE: solidity\nCODE:\n```\nuint128(x) > 0x80000000000000000000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\nx == 0x3FFF0000000000000000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier |= 0x10000000000000000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier >= 0x10000000000000000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\nxSignifier == 0x80000000000000000000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\nresultSignifier < 0x10000000000000000000000000000\n```\n\nLANGUAGE: solidity\nCODE:\n```\nbytes16(uint128((0x80000000000000000000000000000000) | (resultExponent << 112) | (resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF)))\n```\n\n----------------------------------------\n\nTITLE: ABDKMathQuad Pow2 Function Bitwise Operations\nDESCRIPTION: Implementation of pow_2 function showing bitwise operations and large number calculations. The function performs power of 2 calculations using bit manipulation and multiplication with precise hexadecimal constants.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_52\n\nLANGUAGE: solidity\nCODE:\n```\nresultSignifier = (resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5) >> 128;\nxSignifier & 0x4000000000000000 > 0;\nresultSignifier = (resultSignifier * 0x100000000000000002C5C85FDF473DE6A) >> 128;\nxSignifier & 0x2000000000000000 > 0;\nresultSignifier = (resultSignifier * 0x10000000000000000162E42FEFA39EF34) >> 128;\n```\n\n----------------------------------------\n\nTITLE: Large Numeric Literals in Solidity Power Contract\nDESCRIPTION: Highlights the use of large numeric literals in the Power contract's generalExp function. These literals are used in complex mathematical calculations but may be difficult to read and maintain.\nSOURCE: https://github.com/metokens/metokens-core/blob/main/slither-output.md#2025-04-23_snippet_36\n\nLANGUAGE: Solidity\nCODE:\n```\nPower.generalExp(uint256,uint8) (contracts/curves/Power.sol#302-377) uses literals with too many digits:\n\tres += xi * 0x3442c4e6074a82f1797f72ac0000000\n\tres += xi * 0x116b96f757c380fb287fd0e40000000\n\tres += xi * 0x045ae5bdd5f0e03eca1ff4390000000\n\t// ... (additional similar lines omitted for brevity)\n\tres / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision)\n```"
  }
]