[
  {
    "owner": "beartype",
    "repo": "beartype",
    "content": "TITLE: Using the Beartype Decorator for Function Type Checking\nDESCRIPTION: Basic example demonstrating how to use the @beartype decorator to enforce type hints on individual functions, showing both valid and invalid function calls.\nSOURCE: https://github.com/beartype/beartype/blob/main/README.rst#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# ....................{ RAISE THE PAW                   }.....................\n# Manually enforce type hints across individual classes and callables.\n# Do this only if you want a(nother) repetitive stress injury.\n\n# Import the @beartype decorator.\n>>> from beartype import beartype      # <-- eponymous import; it's eponymous\n\n# Annotate @beartype-decorated classes and callables with type hints.\n>>> @beartype                          # <-- you too will believe in magic\n... def quote_wiggum(lines: list[str]) -> None:\n...     print('\"{}\"\\n\\t— Police Chief Wiggum'.format(\"\\n \".join(lines)))\n\n# Call those callables with valid parameters.\n>>> quote_wiggum([\"Okay, folks. Show's over!\", \" Nothing to see here. Show's…\",])\n\"Okay, folks. Show's over!\\n Nothing to see here. Show's…\"\n   — Police Chief Wiggum\n\n# Call those callables with invalid parameters.\n>>> quote_wiggum([b\"Oh, my God! A horrible plane crash!\", b\"Hey, everybody! Get a load of this flaming wreckage!\",])\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<string>\", line 30, in quote_wiggum\n  File \"/home/springfield/beartype/lib/python3.9/site-packages/beartype/_decor/_code/_pep/_error/errormain.py\", line 220, in get_beartype_violation\n    raise exception_cls(\nbeartype.roar.BeartypeCallHintParamViolation: @beartyped\nquote_wiggum() parameter lines=[b'Oh, my God! A horrible plane\ncrash!', b'Hey, everybody! Get a load of thi...'] violates type hint\nlist[str], as list item 0 value b'Oh, my God! A horrible plane crash!'\nnot str.\n```\n\n----------------------------------------\n\nTITLE: Basic Beartype Decorator Example\nDESCRIPTION: Demonstrates basic usage of @beartype decorator for runtime type-checking of function parameters and return values. Shows how type violations are caught and how to access the original unwrapped function.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_decor.rst#2025-04-16_snippet_0\n\nLANGUAGE: pycon\nCODE:\n```\n# Import the requisite machinery.\n>>> from beartype import beartype\n\n# Decorate a function with @beartype.\n>>> @beartype\n... def bother_free_is_no_bother_to_me(bothersome_string: str) -> str:\n...     return f'Oh, bother. {bothersome_string}'\n\n# Call that function with runtime type-checking enabled.\n>>> bother_free_is_no_bother_to_me(b'Could you spare a small smackerel?')\nBeartypeCallHintParamViolation: @beartyped bother_free_is_no_bother_to_me()\nparameter bothersome_string=b'Could you spare a small smackerel?' violates\ntype hint <class 'str'>, as bytes b'Could you spare a small smackerel?' not\ninstance of str.\n\n# Call that function with runtime type-checking disabled. WHY YOU DO THIS!?\n>>> bother_free_is_no_bother_to_me.__wrapped__(\n...     b'Could you spare a small smackerel?')\n\"Oh, bother. b'Could you spare a small smackerel?'\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Type Checking with Beartype Decorator in Python\nDESCRIPTION: Demonstrates comprehensive usage of @beartype decorator for type checking across various scenarios including function parameters, return types, classes, coroutines, and generators. Shows integration with different typing approaches like PEP 484, 585, 604, and custom Beartype types.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/tldr.rst#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Import the core @beartype decorator.\nfrom beartype import beartype\n\n# Import type hint factories from \"beartype.typing\", a stand-in replacement\n# for the standard \"typing\" module providing improved forward compatibility\nfrom beartype import typing\n\nimport typing\nfrom collections import abc\nimport typing_extensions\nfrom beartype.cave import NoneType, NoneTypeOr, RegexTypes, ScalarTypes\nfrom numbers import Integral, Real\nfrom my_package.my_module import MyClass\n\nT = typing.TypeVar('T')\n\n@beartype\ndef my_function(\n    param_must_satisfy_builtin_type: str,\n    param_must_satisfy_user_type: MyClass,\n    param_must_satisfy_pep604_union: dict | tuple | None,\n    param_must_satisfy_pep484_union: typing.Union[\n        dict, T, tuple[MyClass, ...]],\n    param_must_satisfy_pep593: typing.Annotated[\n        typing.Set[int], range(5), True],\n    param_must_satisfy_pep586: typing.Literal[\n        'This parameter must equal this string.'],\n    param_must_satisfy_pep585_builtin: list[str],\n    param_must_satisfy_pep585_collection: abc.MutableSequence[str],\n    param_must_satisfy_pep544: typing.SupportsRound[T],\n    param_must_satisfy_pep484_typing: typing.List[int],\n    param_must_satisfy_pep484_relative_forward_ref: 'MyOtherClass',\n    param_must_satisfy_pep484_indexed_relative_forward_ref: (\n        typing.Union['MyPep484Generic', set['MyPep585Generic']]),\n    param_must_satisfy_beartype_type_from_cave: NoneType,\n    param_must_satisfy_beartype_union: (dict, MyClass, int),\n    param_must_satisfy_beartype_union_from_cave: ScalarTypes,\n    param_must_satisfy_beartype_union_concatenated: (\n        abc.Iterator,) + ScalarTypes,\n    param_must_satisfy_beartype_absolute_forward_ref: (\n        'my_package.my_module.MyClass'),\n    param_must_satisfy_beartype_union_with_forward_ref: (\n        abc.Iterable, 'my_package.my_module.MyOtherClass', NoneType),\n    param_must_satisfy_pep604_optional: float | bytes | None = None,\n    param_must_satisfy_pep484_optional: typing.Optional[float, bytes] = None,\n    param_must_satisfy_beartype_type_optional: NoneTypeOr[float] = None,\n    param_must_satisfy_beartype_tuple_optional: NoneTypeOr[float, int] = None,\n    *args: ScalarTypes + (Real, 'my_package.my_module.MyScalarType'),\n    param_must_be_passed_by_keyword_only: abc.Sequence[\n        typing.Union[bool, list[str]]],\n) -> Union[Integral, 'MyPep585Generic', bool]:\n    return 0xDEADBEEF\n\n@beartype\nasync def my_coroutine() -> abc.Coroutine[None, None, int]:\n    from async import sleep\n    await sleep(0)\n    return 0xDEFECA7E\n\n@beartype\ndef my_sync_generator() -> abc.Generator[int, None, None]:\n    yield from range(0xBEEFBABE, 0xCAFEBABE)\n\n@beartype\nasync def my_async_generator() -> abc.AsyncGenerator[int, None]:\n    from async import sleep\n    await sleep(0)\n    yield 0x8BADF00D\n\n@beartype\nclass MyOtherClass:\n    def __init__(self, scalar: ScalarTypes) -> None:\n        self._scalar = scalar\n\n    @classmethod\n    def my_classmethod(cls, regex: RegexTypes, wut: str) -> (\n        Callable[(), str]):\n        import re\n        return lambda: re.sub(regex, 'unbearable', str(cls._scalar) + wut)\n\n    @staticmethod\n    def my_staticmethod(callable: abc.Callable[[str], T], text: str) -> T:\n        return callable(text)\n\n    @property\n    def my_gettermethod(self) -> abc.Iterator[int]:\n        return range(0x0B00B135 + int(self._scalar), 0xB16B00B5)\n\n    @my_gettermethod.setter\n    def my_settermethod(self, bad: Integral = 0xBAAAAAAD) -> None:\n        self._scalar = bad if bad else 0xBADDCAFE\n\n    def my_selfreferential_method(self) -> list['MyOtherClass']:\n        return [self] * 42\n\n@beartype\nclass MyPep585Generic(tuple[int, float]):\n    def __new__(cls, integer: int, real: float) -> tuple[int, float]:\n        return tuple.__new__(cls, (integer, real))\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Validation with Beartype Validators\nDESCRIPTION: More advanced example showing how to create and use custom validators with Beartype to enforce constraints beyond standard type hints, such as ensuring lists are non-empty.\nSOURCE: https://github.com/beartype/beartype/blob/main/README.rst#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# ....................{ MAKE IT SO                      }.....................\n# Squash bugs by refining type hints with @beartype validators.\n>>> from beartype.vale import Is  # <---- validator factory\n>>> from typing import Annotated  # <---------------- if Python ≥ 3.9.0\n# >>> from typing_extensions import Annotated   # <-- if Python < 3.9.0\n\n# Validators are type hints constrained by lambda functions.\n>>> ListOfStrings = Annotated[  # <----- type hint matching non-empty list of strings\n...     list[str],  # <----------------- type hint matching possibly empty list of strings\n...     Is[lambda lst: bool(lst)]  # <-- lambda matching non-empty object\n... ]\n\n# Annotate @beartype-decorated callables with validators.\n>>> @beartype\n... def quote_wiggum_safer(lines: ListOfStrings) -> None:\n...     print('\"{}\"\\n\\t— Police Chief Wiggum'.format(\"\\n \".join(lines)))\n\n# Call those callables with invalid parameters.\n>>> quote_wiggum_safer([])\nbeartype.roar.BeartypeCallHintParamViolation: @beartyped\nquote_wiggum_safer() parameter lines=[] violates type hint\ntyping.Annotated[list[str], Is[lambda lst: bool(lst)]], as value []\nviolates validator Is[lambda lst: bool(lst)].\n```\n\n----------------------------------------\n\nTITLE: Configuring @beartype with Custom Options in Python\nDESCRIPTION: Shows how to create a custom configuration for @beartype using BeartypeConf. The example demonstrates setting options for color output, debugging, PEP 484 numeric tower support, and choosing type-checking strategy.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/tldr.rst#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom beartype import BeartypeConf, BeartypeStrategy\n\n# Dynamically create your own @beartype decorator, configured for your needs.\nbugbeartype = beartype(conf=BeartypeConf(\n    # Optionally disable or enable output of colors (i.e., ANSI escape\n    # sequences) in type-checking violations via this tri-state boolean:\n    # * \"None\" conditionally enables colors when standard output is attached\n    #   to an interactive terminal. [DEFAULT]\n    # * \"True\" unconditionally enables colors.\n    # * \"False\" unconditionally disables colors.\n    is_color=False,  # <-- disable color entirely\n\n    # Optionally enable developer-friendly debugging.\n    is_debug=True,\n\n    # Optionally enable PEP 484's implicit numeric tower by:\n    # * Expanding all \"float\" type hints to \"float | int\".\n    # * Expanding all \"complex\" type hints to \"complex | float | int\".\n    is_pep484_tower=True,\n\n    # Optionally switch to a different type-checking strategy:\n    # * \"BeartypeStrategy.O1\" type-checks in O(1) constant time. [DEFAULT]\n    # * \"BeartypeStrategy.On\" type-checks in O(n) linear time.\n    #   (Currently unimplemented but roadmapped for a future release.)\n    # * \"BeartypeStrategy.Ologn\" type-checks in O(log n) logarithmic time.\n    #   (Currently unimplemented but roadmapped for a future release.)\n    # * \"strategy=BeartypeStrategy.O0\" disables type-checking entirely.\n    strategy=BeartypeStrategy.On,  # <-- enable linear-time type-checking\n))\n\n# Decorate with your decorator instead of the vanilla @beartype decorator.\n@bugbeartype\ndef muh_configured_func(list_checked_in_On_time: list[float]) -> set[str]:\n    return set(str(item) for item in list_checked_in_On_time)\n```\n\n----------------------------------------\n\nTITLE: Validating All Integers in a List Using Beartype in Python\nDESCRIPTION: This snippet demonstrates how to use Beartype validators to check all integers in a list in O(n) time, creating a custom IntList type and using it in a function annotation.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom beartype import beartype\nfrom beartype.vale import Is\nfrom typing import Annotated\n\nIntList = Annotated[list[int], Is[lambda lst: all(\n    isinstance(item, int) for item in lst)]]\n\n@beartype\ndef sum_intlist(my_list: IntList) -> int:\n    return sum(my_list)\n```\n\n----------------------------------------\n\nTITLE: On-Demand Type Checking with Beartype's Door API\nDESCRIPTION: Example showing how to use Beartype's Door API (is_bearable and die_if_unbearable) to check types on arbitrary objects at any point in your code, not just in function calls.\nSOURCE: https://github.com/beartype/beartype/blob/main/README.rst#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# ....................{ AT ANY TIME                     }.....................\n# Type-check anything against any type hint – anywhere at anytime.\n>>> from beartype.door import (\n...     is_bearable,  # <-------- like \"isinstance(...)\"\n...     die_if_unbearable,  # <-- like \"assert isinstance(...)\"\n... )\n>>> is_bearable(['The', 'goggles', 'do', 'nothing.'], list[str])\nTrue\n>>> die_if_unbearable([0xCAFEBEEF, 0x8BADF00D], ListOfStrings)\nbeartype.roar.BeartypeDoorHintViolation: Object [3405692655, 2343432205]\nviolates type hint typing.Annotated[list[str], Is[lambda lst: bool(lst)]],\nas list index 0 item 3405692655 not instance of str.\n```\n\n----------------------------------------\n\nTITLE: Implementing Package-Wide Type Checking with Beartype\nDESCRIPTION: Python code example showing how to enable type checking for all annotated elements across your package using beartype_this_package().\nSOURCE: https://github.com/beartype/beartype/blob/main/README.rst#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom beartype.claw import beartype_this_package       # <-- hype comes\nbeartype_this_package()                               # <-- hype goes\n```\n\n----------------------------------------\n\nTITLE: Validating Non-String Sequences with Beartype\nDESCRIPTION: Creates custom type definitions for non-string sequences using Beartype validators. This addresses Python's counter-intuitive behavior where strings are considered sequences, allowing more precise type checking.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype import beartype\nfrom beartype.vale import IsInstance\nfrom collections.abc import Sequence\nfrom typing import Annotated   # <--------------- if Python ≥ 3.9.0\n#from typing_extensions import Annotated   # <--- if Python < 3.9.0\n\n# Type hint matching any non-string sequence. Your day has finally come.\nSequenceNonstr = Annotated[Sequence, ~IsInstance[str]]   # <--- we doin this\n\n# Type hint matching any non-string sequence *WHOSE ITEMS ARE ALL STRINGS.*\nSequenceNonstrOfStr = Annotated[Sequence[str], ~IsInstance[str]]\n\n# Type-check a non-string sequence of arbitrary items coerced into strings\n# and then joined on newline to a new string. (Beartype got your back, bro.)\n@beartype\ndef join_objects(my_sequence: SequenceNonstr) -> str:\n    '''\n    Your tide of disease ends here, :class:`str` class!\n    '''\n\n    return '\\n'.join(map(str, my_sequence))  # <-- no idea how that works\n\n# Type-check a non-string sequence whose items are all strings joined on\n# newline to a new string. It isn't much, but it's all you ask.\n@beartype\ndef join_strs(my_sequence: SequenceNonstrOfStr) -> str:\n    '''\n    I expectorate thee up, sequence of strings.\n    '''\n\n    return '\\n'.join(my_sequence)  # <-- do *NOT* do this to a string\n```\n\n----------------------------------------\n\nTITLE: Creating Class and Generator Function with Beartype in Python\nDESCRIPTION: Demonstrates using beartype with a custom class and a generator function, using cave's IterableType and GeneratorType for more abstract type annotations.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/eli5.rst#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom beartype import beartype\nfrom beartype.cave import GeneratorType, IterableType, NoneType\n\n@beartype\nclass MaximsOfBaloo(object):\n    def __init__(self, sayings: IterableType):\n        self.sayings = sayings\n\n@beartype\ndef inform_baloo(maxims: MaximsOfBaloo) -> GeneratorType:\n    for saying in maxims.sayings:\n        yield saying\n```\n\n----------------------------------------\n\nTITLE: Using Beartype for Runtime Type Checking in Python\nDESCRIPTION: This example shows how to use the @beartype decorator to enforce type hints at runtime. When the function returns a string instead of the annotated integer type, Beartype raises an exception with a detailed error message.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/faq.rst#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ python3 - <<EOL\nfrom beartype import beartype\n@beartype\ndef main() -> int:\n    print(\"Hello, world!\");\n    return \"Goodbye, world.\";  # <-- pretty sure that's not an \"int\".\nmain()\nEOL\n\nHello, world!\nTraceback (most recent call last):\n  File \"<stdin>\", line 6, in <module>\n  File \"<string>\", line 17, in main\n  File \"/home/leycec/py/beartype/beartype/_decor/_code/_pep/_error/errormain.py\", line 218, in get_beartype_violation\n    raise exception_cls(\nbeartype.roar.BeartypeCallHintPepReturnException: @beartyped main() return\n'Goodbye, world.' violates type hint <class 'int'>, as value 'Goodbye,\nworld.' not int.\n```\n\n----------------------------------------\n\nTITLE: Initializing Beartype Import Hooks in Python\nDESCRIPTION: Examples of how to initialize beartype import hooks in a Python package's __init__ module. Shows three different methods with varying levels of performance and flexibility.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_claw.rst#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Add *ONE* of the following semantically equivalent two-liners to the very\n# top of your \"{your_package}.__init__\" submodule. Start with *THE FAST WAY*.\n\n# ....................{ THE FAST WAY                    }.....................\nfrom beartype.claw import beartype_this_package  # <-- this is boring, but...\nbeartype_this_package()                          # <-- the fast way\n\n# ....................{ THE LESS FAST WAY               }.....................\nfrom beartype.claw import beartype_package       # <-- still boring, but...\nbeartype_package('{your_package}')               # <-- the less fast way\n\n# ....................{ THE MORE SLOW WAY               }.....................\nfrom beartype.claw import beartype_packages      # <-- boring intensifies\nbeartype_packages(('{your_package}',))           # <-- the more slow way\n```\n\n----------------------------------------\n\nTITLE: Validating Non-Boolean Integers with Beartype\nDESCRIPTION: Creates a custom type definition for non-boolean integers using Beartype validators with the Annotated type hint. This code demonstrates how to exclude booleans when validating integer inputs.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype import beartype\nfrom beartype.vale import IsInstance\nfrom typing import Annotated   # <--------------- if Python ≥ 3.9.0\n#from typing_extensions import Annotated   # <--- if Python < 3.9.0\n\n# Type hint matching any non-boolean integer. This day all errata die.\nIntNonbool = Annotated[int, ~IsInstance[bool]]   # <--- bruh\n\n# Type-check zero or more non-boolean integers summing to a non-boolean\n# integer. Beartype wills it. So it shall be.\n@beartype\ndef sum_ints(*args: IntNonbool) -> IntNonbool:\n    '''\n    I cast thee out, mangy booleans!\n\n    You plague these shores no more.\n    '''\n\n    return sum(args)\n```\n\n----------------------------------------\n\nTITLE: Implementing Constant-Time Nested List Type Checking in Python\nDESCRIPTION: This snippet shows how beartype efficiently type-checks deeply nested list structures by randomly sampling items rather than checking every element. It uses Python 3.8+ assignment expressions (:=) to optimize repeated access to randomly selected elements.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/code.rst#2025-04-16_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n__beartype_random_int = __beartype_getrandbits(32)\n__beartype_args_len = len(args)\n__beartype_pith_0 = (\n    args[0] if __beartype_args_len > 0 else\n    kwargs.get('pull_thorns_from_all_wolves_paws', __beartypistry)\n)\n\nif __beartype_pith_0 is not __beartypistry:\n    if not (\n        isinstance(__beartype_pith_0, list) and\n        (not __beartype_pith_0 or (\n            isinstance(__beartype_pith_1 := __beartype_pith_0[__beartype_random_int % len(__beartype_pith_0)], list) and\n            (not __beartype_pith_1 or (\n                isinstance(__beartype_pith_2 := __beartype_pith_1[__beartype_random_int % len(__beartype_pith_1)], list) and\n                (not __beartype_pith_2 or isinstance(__beartype_pith_2[__beartype_random_int % len(__beartype_pith_2)], str))\n            ))\n        ))\n    ):\n        __beartype_get_beartype_violation(\n            func=__beartype_func,\n            pith_name='pull_thorns_from_all_wolves_paws',\n            pith_value=__beartype_pith_0,\n        )\n\nreturn __beartype_func(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Calling a Beartyped Function with Invalid Type\nDESCRIPTION: Example showing what happens when a beartyped function is called with a parameter of the wrong type. The function expects a Union of Integral or Mapping but receives a string, resulting in a BeartypeCallHintPepParamException.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/eli5.rst#2025-04-16_snippet_8\n\nLANGUAGE: pycon\nCODE:\n```\n>>> toomai_of_the_elephants(\n...     'Shiv, who poured the harvest and made the winds to blow,')\nBeartypeCallHintPepParamException: @beartyped toomai_of_the_elephants()\nparameter memory='Shiv, who poured the harvest and made the winds to blow,'\nviolates type hint typing.Union[numbers.Integral, collections.abc.Mapping],\nas 'Shiv, who poured the harvest and made the winds to blow,' not <protocol\nABC \"collections.abc.Mapping\"> or <protocol \"numbers.Integral\">.\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Beartype for Basic Type Checking in Python\nDESCRIPTION: A simple example demonstrating how to use the beartype decorator to type-check a function accepting a string and dictionary while returning a tuple.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/eli5.rst#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom beartype import beartype\n\n@beartype\ndef law_of_the_jungle(wolf: str, pack: dict) -> tuple:\n    return (wolf, pack[wolf]) if wolf in pack else None\n```\n\n----------------------------------------\n\nTITLE: Implementing NumPy Array Validation with Beartype Validators\nDESCRIPTION: A complete example showing how to validate 2D NumPy float arrays using beartype validators with the Annotated type and a custom lambda function. The example demonstrates validation of array dimensions and data type.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype import beartype\nfrom beartype.vale import Is\nfrom typing import Annotated   # <--------------- if Python ≥ 3.9.0\n#from typing_extensions import Annotated   # <--- if Python < 3.9.0\n\n# Type hint matching any two-dimensional NumPy array of floats of arbitrary\n# precision. Aye, typing matey. Beartype validators a-hoy!\nimport numpy as np\nNumpy2DFloatArray = Annotated[np.ndarray, Is[lambda array:\n    array.ndim == 2 and np.issubdtype(array.dtype, np.floating)]]\n\n# Annotate @beartype-decorated callables with beartype validators.\n@beartype\ndef polygon_area(polygon: Numpy2DFloatArray) -> float:\n    '''\n    Area of a two-dimensional polygon of floats defined as a set of\n    counter-clockwise points, calculated via Green's theorem.\n\n    *Don't ask.*\n    '''\n\n    # Calculate and return the desired area. Pretend we understand this.\n    polygon_rolled = np.roll(polygon, -1, axis=0)\n    return np.abs(0.5*np.sum(\n        polygon[:,0]*polygon_rolled[:,1] -\n        polygon_rolled[:,0]*polygon[:,1]))\n```\n\n----------------------------------------\n\nTITLE: Using is_bearable method of TypeHint with Python Union types\nDESCRIPTION: This example shows how to use the is_bearable method of TypeHint to check if an object satisfies a type hint. It compares the object-oriented approach using TypeHint with the equivalent procedural approach using the is_bearable function.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_door.rst#2025-04-16_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# This object-oriented approach...\n>>> from beartype.door import TypeHint\n>>> TypeHint(int | float).is_bearable(\n...     \"It's like a party in my mouth and everyone's throwing up.\")\nFalse\n\n# ...is equivalent to this procedural approach.\n>>> from beartype.door import is_bearable\n>>> is_bearable(\n...     obj=\"It's like a party in my mouth and everyone's throwing up.\",\n...     hint=int | float,\n... )\nFalse\n```\n\n----------------------------------------\n\nTITLE: Defining a SentenceFragment Type Using Beartype Validators in Python\nDESCRIPTION: This snippet demonstrates how to create a custom type hint for a sentence fragment using Beartype validators. It uses the Is and ~ operators to define a string that is non-empty and does not contain periods.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nSentenceFragment = Annotated[str, (\n    Is[lambda text: bool(text)] &\n   ~Is[lambda text: '.' in text]\n)]\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Optional Types Using typing.Optional\nDESCRIPTION: Implementation of a beartyped function that accepts and returns optional types using typing.Optional. The function accepts either an EnumType or None and returns either an EnumMemberType or None.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/eli5.rst#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom beartype import beartype\nfrom beartype.cave import EnumType, EnumMemberType\nfrom typing import Optional\n\n@beartype\ndef tell_the_deep_sea_viceroys(story: Optional[EnumType] = None) -> (\n    Optional[EnumMemberType]):\n    return story if story is None else list(story.__members__.values())[-1]\n```\n\n----------------------------------------\n\nTITLE: Using Beartype with Complex Type Hints in Python\nDESCRIPTION: Shows an example of using Beartype with more complex type hints, including Optional, Union, and numpy-specific types. The function wraps numpy's empty_like function with runtime type checking.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/eli5.rst#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom beartype import beartype\nfrom collections.abc import Sequence\nfrom typing import Optional, Union\nimport numpy as np\n\n@beartype\ndef empty_like_bear(\n    prototype: object,\n    dtype: Optional[np.dtype] = None,\n    order: str = 'K',\n    subok: bool = True,\n    shape: Optional[Union[int, Sequence[int]]] = None,\n) -> np.ndarray:\n    return np.empty_like(prototype, dtype, order, subok, shape)\n```\n\n----------------------------------------\n\nTITLE: Using die_if_unbearable for Runtime Type-Checking\nDESCRIPTION: Example demonstrating how to use the die_if_unbearable function to check if objects violate type hints. If an object violates a hint, it raises a BeartypeDoorHintViolation exception.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_door.rst#2025-04-16_snippet_0\n\nLANGUAGE: pycon\nCODE:\n```\n# Import the requisite machinery.\n>>> from beartype.door import die_if_unbearable\n>>> from beartype.typing import List, Sequence\n\n# Type-check an object violating a type hint.\n>>> die_if_unbearable(\"My people ate them all!\", List[int] | None])\nBeartypeDoorHintViolation: Object 'My people ate them all!' violates type\nhint list[int] | None, as str 'My people ate them all!' not list or <class\n\"builtins.NoneType\">.\n\n# Type-check multiple objects satisfying multiple type hints.\n>>> die_if_unbearable(\"I'm swelling with patriotic mucus!\", str | None)\n>>> die_if_unbearable(\"I'm not on trial here.\", Sequence[str])\n```\n\n----------------------------------------\n\nTITLE: Creating a No-Type-Checking Decorator with Beartype in Python\nDESCRIPTION: Shows how to create a custom decorator that disables type checking for specific classes or functions using the BeartypeStrategy.O0 configuration, useful for excluding problematic code from type checking.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/faq.rst#2025-04-16_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype import beartype, BeartypeConf, BeartypeStrategy\n\n# Dynamically create a new @nobeartype decorator disabling type-checking.\nnobeartype = beartype(conf=BeartypeConf(strategy=BeartypeStrategy.O0))\n\n# Avoid type-checking *ANY* methods or attributes of this class.\n@nobeartype\nclass UncheckedDangerClassIsDangerous(object):\n    # This method raises *NO* type-checking violation despite returning a\n    # non-\"None\" value.\n    def unchecked_danger_method_is_dangerous(self) -> None:\n```\n\n----------------------------------------\n\nTITLE: Creating Runtime-Checkable Protocols with @beartype in Python\nDESCRIPTION: Demonstrates defining a PEP 544 Protocol class that can be used with @beartype. The @typing.runtime_checkable decorator is required to make the protocol usable with @beartype in runtime type checking.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/tldr.rst#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@typing.runtime_checkable   # <---- mandatory boilerplate line. it is sad.\nclass MyProtocol(typing.Protocol):\n    def my_method(self) -> str:\n        return (\n            'Objects satisfy this protocol only if their classes '\n            'define a method with the same signature as this method.'\n        )\n```\n\n----------------------------------------\n\nTITLE: Using PEP 593 Validators with @beartype in Python\nDESCRIPTION: Demonstrates creating and using validators with @beartype to enforce complex constraints on parameters. The example shows validating NumPy arrays with various constraints on dimensions, types, and other properties.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/tldr.rst#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom beartype.vale import Is, IsAttr, IsEqual\nfrom typing import Annotated   # <--------------- if Python ≥ 3.9.0\n#from typing_extensions import Annotated   # <--- if Python < 3.9.0\n\n# Import third-party packages to validate.\nimport numpy as np\n\n# Validator matching only two-dimensional NumPy arrays of 64-bit floats,\n# specified with a single caller-defined lambda function.\nNumpyArray2DFloat = Annotated[np.ndarray, Is[\n    lambda arr: arr.ndim == 2 and arr.dtype == np.dtype(np.float64)]]\n\n# Validator matching only one-dimensional NumPy arrays of 64-bit floats,\n# specified with two declarative expressions. Although verbose, this\n# approach generates optimal reusable code that avoids function calls.\nIsNumpyArray1D = IsAttr['ndim', IsEqual[1]]\nIsNumpyArrayFloat = IsAttr['dtype', IsEqual[np.dtype(np.float64)]]\nNumpyArray1DFloat = Annotated[np.ndarray, IsNumpyArray1D, IsNumpyArrayFloat]\n\n# Validator matching only empty NumPy arrays, equivalent to but faster than:\n#     NumpyArrayEmpty = Annotated[np.ndarray, Is[lambda arr: arr.size != 0]]\nIsNumpyArrayEmpty = IsAttr['size', IsEqual[0]]\nNumpyArrayEmpty = Annotated[np.ndarray, IsNumpyArrayEmpty]\n\n# Validator composed with standard operators from the above validators,\n# permissively matching all of the following:\n# * Empty NumPy arrays of any dtype *except* 64-bit floats.\n# * Non-empty one- and two-dimensional NumPy arrays of 64-bit floats.\nNumpyArrayEmptyNonFloatOrNonEmptyFloat1Or2D = Annotated[np.ndarray,\n    # \"&\" creates a new validator matching when both operands match, while\n    # \"|\" creates a new validator matching when one or both operands match;\n    # \"~\" creates a new validator matching when its operand does not match.\n    # Group operands to enforce semantic intent and avoid precedence woes.\n    (IsNumpyArrayEmpty & ~IsNumpyArrayFloat) | (\n        ~IsNumpyArrayEmpty & IsNumpyArrayFloat (\n            IsNumpyArray1D | IsAttr['ndim', IsEqual[2]]\n        )\n    )\n]\n\n# Decorate functions accepting validators like usual and...\n@beartype\ndef my_validated_function(\n    # Annotate validators just like standard type hints.\n    param_must_satisfy_validator: NumpyArrayEmptyOrNonemptyFloat1Or2D,\n# Combine validators with standard type hints, too.\n) -> list[NumpyArrayEmptyNonFloatOrNonEmptyFloat1Or2D]:\n    return (\n        [param_must_satisfy_validator] * 0xFACEFEED\n        if bool(param_must_satisfy_validator) else\n        [np.array([i], np.dtype=np.float64) for i in range(0xFEEDFACE)]\n    )\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Beartype in Python\nDESCRIPTION: Demonstrates how to use beartype.door.is_bearable for type narrowing to eliminate false positives from static type-checkers. Shows a practical example of narrowing a list that could contain either integers or strings.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/faq.rst#2025-04-16_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype.door import is_bearable\n\ndef narrow_types_like_a_boss_with_beartype(lst: list[int | str]):\n    '''\n    This function eliminates false positives from static type-checkers like\n    mypy and pyright by narrowing types with ``is_bearable()``.\n\n    Note that decorating this function with ``@beartype`` is *not* required\n    to inform static type-checkers of type narrowing. Of course, you should\n    still do that anyway. Trust is a fickle thing.\n    '''\n\n    # If this list contains integers rather than strings, call another\n    # function accepting only a list of integers.\n    if is_bearable(lst, list[int]):\n        # \"lst\" has been though a lot. Let's celebrate its courageous story.\n        munch_on_list_of_integers(lst)  # mypy/pyright: OK!\n    # If this list contains strings rather than integers, call another\n    # function accepting only a list of strings.\n    elif is_bearable(lst, list[str]):\n        # \"lst\": The Story of \"lst.\" The saga of false positives ends now.\n        munch_on_list_of_strings(lst)  # mypy/pyright: OK!\n\ndef munch_on_list_of_strings(lst: list[str]): ...\ndef munch_on_list_of_integers(lst: list[int]): ...\n```\n\n----------------------------------------\n\nTITLE: Implementing NumPy Array Type Hints with Concrete Scalar Dtype\nDESCRIPTION: Demonstrates how to create type hints for NumPy arrays with specific scalar dtypes, using float64 as an example. Shows how to validate exact scalar precision of an array using NDArray type hints.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype import beartype\nfrom numpy import float64\nfrom numpy.typing import NDArray\n\n# NumPy type hint matching all NumPy arrays of 64-bit floats, semantically\n# equivalent to this beartype validator:\n#     NumpyFloat64Array = Annotated[\n#         np.ndarray, IsAttr['dtype', IsAttr['type', IsEqual[float64]]]]\nNumpyFloat64Array = NDArray[float64]\n```\n\n----------------------------------------\n\nTITLE: Using @beartype with Dataclasses in Python\nDESCRIPTION: Shows how to integrate @beartype with Python's dataclasses. When decorating a dataclass with @beartype, all methods including the auto-generated __init__() constructor are type-checked. Note that decoration order is important.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/tldr.rst#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass, InitVar\n\n# Decorate dataclasses with @beartype, which then automatically decorates all\n# methods and properties of those dataclasses with @beartype – including the\n# __init__() constructors created by @dataclass. Fields are type-checked only\n# at instantiation time. Fields are *NOT* type-checked when reassigned.\n#\n# Decoration order is significant. List @beartype before @dataclass, please.\n@beartype\n@dataclass\nclass MyDataclass(object):\n    # Annotate fields with type hints.\n    field_must_satisfy_builtin_type: InitVar[str]\n    field_must_satisfy_pep604_union: str | None = None\n\n    # Annotate methods as above.\n    def __post_init__(self, field_must_satisfy_builtin_type: str) -> None:\n        if self.field_must_satisfy_pep604_union is None:\n            self.field_must_satisfy_pep604_union = (\n                field_must_satisfy_builtin_type)\n```\n\n----------------------------------------\n\nTITLE: Using beartype_all Import Hook with Python\nDESCRIPTION: Shows how to use the beartype_all import hook which type-checks all callables, classes, and variable assignments across all submodules of all packages. This is the most extreme type-checking option and should be used cautiously.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_claw.rst#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# At the top of your \"{your_package}.__init__\" submodule,\nfrom beartype import BeartypeConf       # <-- @beartype seemed so innocent, once\nfrom beartype.claw import beartype_all  # <-- where did it all go wrong?\nbeartype_all(conf=BeartypeConf(claw_is_pep526=False))  # <-- U WILL BE ASSIMILATE\n```\n\n----------------------------------------\n\nTITLE: Handling BeartypeCallHintViolation in Python\nDESCRIPTION: This code demonstrates how to use and handle BeartypeCallHintViolation, which is raised when an object violates its type hint during type-checking. It includes class definitions and a decorated function to illustrate the exception's usage.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_roar.rst#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype import beartype\nfrom beartype.roar import BeartypeCallHintViolation\n\n# Arbitrary user-defined classes.\nclass SpiritBearIGiveYouSalmonToGoAway(object): pass\nclass SpiritBearIGiftYouHoneyNotToStay(object): pass\n\n# Arbitrary instance of one of these classes.\nSPIRIT_BEAR_REFUSE_TO_GO_AWAY = SpiritBearIGiftYouHoneyNotToStay()\n\n# Callable annotated to accept instances of the *OTHER* class.\n@beartype\ndef when_spirit_bear_hibernates_in_your_bed(\n    best_bear_den: SpiritBearIGiveYouSalmonToGoAway) -> None: pass\n```\n\n----------------------------------------\n\nTITLE: Conditional Type Hint Imports in Python\nDESCRIPTION: This code snippet demonstrates how to conditionally import type hints based on the Python version. For Python 3.9 and above, it uses built-in types, while for earlier versions it imports from the typing module. This approach ensures compatibility across different Python versions.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_roar.rst#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# In \"{your_package}._typing\":\nfrom sys import version_info\n\nif version_info >= (3, 9):\n    List = list\n    Tuple = tuple\n    ...\nelse:\n    from typing import List, Tuple, ...\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Complex Optional Types\nDESCRIPTION: Implementation of a beartyped function that uses typing.Optional with typing.Union to accept more complex combinations of types. This function accepts either an EnumType, EnumMemberType, or None.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/eli5.rst#2025-04-16_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom beartype import beartype\nfrom beartype.cave import EnumType, EnumMemberType, NoneType\nfrom typing import Optional, Union\n\n@beartype\ndef sang_them_up_the_beach(\n    woe: Optional[Union[EnumType, EnumMemberType]] = None) -> (\n    Optional[Union[EnumType, EnumMemberType]]):\n    return woe if isinstance(woe, (EnumMemberType, NoneType)) else (\n        list(woe.__members__.values())[-1])\n```\n\n----------------------------------------\n\nTITLE: Decorating Dataclasses with Beartype\nDESCRIPTION: Demonstrates the correct order for applying @beartype and @dataclass decorators to dataclasses, ensuring that generated methods like __init__() are properly type-checked.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_decor.rst#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype import beartype\nfrom dataclasses import dataclass\n\n# Decorate a dataclass first with @beartype and then with @dataclass. If you\n# accidentally reverse this order of decoration, methods added by @dataclass\n# like __init__() will *NOT* be type-checked by @beartype. (Blame Guido.)\n@beartype\n@dataclass\nclass SoTheyWentOffTogether(object):\n    a_little_boy_and_his_bear: str | bytes\n    will_always_be_playing:    str | None = None\n```\n\n----------------------------------------\n\nTITLE: Beartype Decorator Usage Example\nDESCRIPTION: Interactive example showing how to use the @beartype decorator for function type checking, including error handling.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/index.rst#2025-04-16_snippet_4\n\nLANGUAGE: pycon\nCODE:\n```\n>>> from beartype import beartype\n>>> @beartype\n... def quote_wiggum(lines: list[str]) -> None:\n...     print('\"{}\"\\n\\t— Police Chief Wiggum'.format(\"\\n \".join(lines)))\n\n>>> quote_wiggum([\"Okay, folks. Show's over!\", \" Nothing to see here. Show's…\",])\n```\n\n----------------------------------------\n\nTITLE: Demonstrating BeartypeCallHintForwardRefException in Python\nDESCRIPTION: This snippet shows how to handle a BeartypeCallHintForwardRefException, which is raised when a forward reference type hint erroneously references a non-existent attribute or a non-class attribute.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_roar.rst#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from beartype import beartype\n>>> from beartype.roar import BeartypeCallHintForwardRefException\n>>> @beartype\n... def i_am_spirit_bear(favourite_foodstuff: 'salmon.of.course') -> None: pass\n>>> try:\n...     i_am_spirit_bear('Why do you eat all my salmon, Spirit Bear?')\n... except BeartypeCallHintForwardRefException as exception:\n...     print(exception)\n```\n\n----------------------------------------\n\nTITLE: Using Self-reference in Class Methods with typing.Self in Python\nDESCRIPTION: Demonstrates the recommended way to type-check methods that reference their own class using the typing.Self type hint introduced in PEP 673 (Python 3.11+).\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/faq.rst#2025-04-16_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# Import important stuff. Boilerplate: it's the stuff we make.\nfrom beartype import beartype\nfrom typing import Self  # <---------------- if Python ≥ 3.11.0\n# from typing_extensions import Self   # <-- if Python < 3.11.0\n\n# Decorate classes – not methods. It's rough.\n@beartype  # <-- Yesss. Good. Feel the force. It flows like sweet honey.\nclass ClassFactory(object):\n   def __init__(self, *args: Sequence) -> None:\n       self._args = args\n\n   # @beartype  # <-- No... Oh, Gods. *NO*! The dark side grows stronger.\n   def make_class(self, other: Self) -> Self:  # <-- We are all one self.\n       return ClassFactory(self._args + other._args)\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Configured Beartype Decorator\nDESCRIPTION: Shows how to create a custom-configured beartype decorator with specific settings, like disabling color output and enabling PEP 484 numeric tower support.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_decor.rst#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype import beartype, BeartypeConf, BeartypeStrategy\n\n# Dynamically create a new @monotowertype decorator configured to:\n# * Avoid outputting colors in type-checking violations.\n# * Enable support for the implicit numeric tower standardized by PEP 484.\nmonotowertype = beartype(conf=BeartypeConf(\n    is_color=False, is_pep484_tower=True))\n\n# Decorate with this decorator rather than @beartype everywhere.\n@monotowertype\ndef muh_colorless_permissive_func(int_or_float: float) -> float:\n    return int_or_float ** int_or_float ^ round(int_or_float)\n```\n\n----------------------------------------\n\nTITLE: Using NumPy Type Hints with @beartype in Python\nDESCRIPTION: Shows how to use NumPy-specific type hints with @beartype to validate NumPy array constraints. This example demonstrates validating array dtypes using numpy.typing.NDArray, which requires NumPy version 1.21.0 or newer.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/tldr.rst#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom numpy.typing import NDArray\n\n# NumPy type hint matching all NumPy arrays of 64-bit floats. Internally,\n# beartype reduces this to the equivalent validator:\n#     NumpyArrayFloat = Annotated[\n#         np.ndarray, IsAttr['dtype', IsEqual[np.dtype(np.float64)]]]\nNumpyArrayFloat = NDArray[np.float64]\n\n# Decorate functions accepting NumPy type hints like usual and...\n@beartype\ndef my_numerical_function(\n    # Annotate NumPy type hints just like standard type hints.\n    param_must_satisfy_numpy: NumpyArrayFloat,\n# Combine NumPy type hints with standard type hints, too.\n) -> tuple[NumpyArrayFloat, int]:\n    return (param_must_satisfy_numpy, len(param_must_satisfy_numpy))\n```\n\n----------------------------------------\n\nTITLE: Validating NumPy Array Data Type with Nested IsAttr\nDESCRIPTION: Example demonstrating nested IsAttr validators to check properties of nested attributes, specifically validating that a NumPy array has a float64 data type.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Type hint matching only NumPy arrays of 64-bit floating-point numbers.\n# From this, @beartype generates an efficient expression resembling:\n#     isinstance(array, np.ndarray) and array.dtype.type == np.float64\nNumpyFloat64Array = Annotated[np.ndarray,\n    IsAttr['dtype', IsAttr['type', IsEqual[np.float64]]]]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Protocol behavior in Python type checking\nDESCRIPTION: This code example shows how the typing.Protocol class imposes no constraints by itself, making it functionally equivalent to the object class. All objects satisfy the Protocol superclass regardless of their actual type.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_door.rst#2025-04-16_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing as Protocol\n>>> isinstance(object(), Protocol)\nTrue  # <-- uhh...\n>>> isinstance('wtfbro', Protocol)\nTrue  # <-- pretty sure you lost me there.\n>>> isinstance(0x696969, Protocol)\nTrue  # <-- so i'll just be leaving then, shall i?\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug Mode with BeartypeConf in Python\nDESCRIPTION: Shows how to create a custom beartype decorator with debugging enabled using BeartypeConf. This allows introspection of the generated type-checking wrapper functions, including caching function bodies and printing function definitions.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_decor.rst#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\n>>> from beartype import beartype, BeartypeConf\n\n# Dynamically create a new @bugbeartype decorator enabling debugging.\n# Insider D&D jokes in my @beartype? You'd better believe. It's happening.\n>>> bugbeartype = beartype(conf=BeartypeConf(is_debug=True))\n\n# Decorate with this decorator rather than @beartype everywhere.\n>>> @bugbeartype\n... def muh_bugged_func() -> str:\n...     return b'Consistency is the bugbear that frightens little minds.'\n(line 0001) def muh_bugged_func(\n(line 0002)     *args,\n(line 0003)     __beartype_func=__beartype_func, # is <function muh_bugged_func at 0x7f52733bad40>\n(line 0004)     __beartype_conf=__beartype_conf, # is \"BeartypeConf(is_color=None, is_debug=True, is_pep484_tower=False, strategy=<BeartypeStrategy...\n(line 0005)     __beartype_get_violation=__beartype_get_violation, # is <function get_beartype_violation at 0x7f5273081d80>\n(line 0006)     **kwargs\n(line 0007) ):\n(line 0008)     # Call this function with all passed parameters and localize the value\n(line 0009)     # returned from this call.\n(line 0010)     __beartype_pith_0 = __beartype_func(*args, **kwargs)\n(line 0011)\n(line 0012)     # Noop required to artificially increase indentation level. Note that\n(line 0013)     # CPython implicitly optimizes this conditional away. Isn't that nice?\n(line 0014)     if True:\n(line 0015)         # Type-check this passed parameter or return value against this\n(line 0016)         # PEP-compliant type hint.\n(line 0017)         if not isinstance(__beartype_pith_0, str):\n(line 0018)             raise __beartype_get_violation(\n(line 0019)                 func=__beartype_func,\n(line 0020)                 conf=__beartype_conf,\n(line 0021)                 pith_name='return',\n(line 0022)                 pith_value=__beartype_pith_0,\n(line 0023)             )\n(line 0024)\n(line 0025)     return __beartype_pith_0\n```\n\n----------------------------------------\n\nTITLE: Combining NumPy Type Hints with Beartype Validators\nDESCRIPTION: Shows how to combine NumPy's built-in type hints with Beartype validators for more expressive type checking. This approach offers both portability and flexible validation of NumPy arrays.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype import beartype\nfrom beartype.vale import IsAttr, IsEqual\nfrom numpy import floating\nfrom numpy.typing import NDArray\nfrom typing import Annotated   # <--------------- if Python ≥ 3.9.0\n#from typing_extensions import Annotated   # <--- if Python < 3.9.0\n\n# Beartype validator + NumPy type hint matching all two-dimensional NumPy\n# arrays of floating-point numbers of any arbitrary precision.\nNumpyFloat64Array = Annotated[NDArray[floating], IsAttr['ndim', IsEqual[2]]]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Beartype Import Hook Effects in Python\nDESCRIPTION: Shows how beartype_this_package() transforms a module with type errors. It adds runtime type checking to functions, classes, and variable assignments without manual decoration.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_claw.rst#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# This is \"{your_package}.{buggy_submodule}\". It is bad, but you never knew.\nimport typing as t\n\nbad_global: int = 'My eyes! The goggles do nothing.'  # <-- no exception\n\ndef bad_function() -> str:\n    return b\"I could've been somebody, instead of a bum byte string.\"\nbad_function()  # <-- no exception\n\nclass BadClass(object):\n    def bad_method(self) -> t.NoReturn:\n        return 'Nobody puts BadClass in the corner.'\nBadClass().bad_method()  # <-- no exception\n```\n\nLANGUAGE: python\nCODE:\n```\n# This is \"{your_package}.{buggy_submodule}\" on beartype_this_package().\n# Any questions? Actually, that was rhetorical. No questions, please.\nfrom beartype import beartype\nfrom beartype.door import die_if_unbearable\nimport typing as t\n\nbad_global: int = 'My eyes! The goggles do nothing.'\ndie_if_unbearable(bad_global, int)  # <-- raises exception\n\n@beartype\ndef bad_function() -> str:\n    return b\"I could've been somebody, instead of a bum byte string.\"\nbad_function()  # <-- raises exception\n\n@beartype\nclass BadClass(object):\n    def bad_method(self) -> t.NoReturn:\n        return 'Nobody puts BadClass in the corner.'\nBadClass().bad_method()  # <-- raises exception\n```\n\n----------------------------------------\n\nTITLE: Using is_subhint method of TypeHint with Python tuple types\nDESCRIPTION: This example demonstrates the is_subhint method of TypeHint to check if a type hint is a subhint of another type hint. It compares both the object-oriented approach using TypeHint and the equivalent procedural approach using the is_subhint function.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_door.rst#2025-04-16_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# This object-oriented approach...\n>>> from beartype.door import TypeHint\n>>> TypeHint(tuple[bool]).is_subhint(tuple[int])\nTrue\n\n# ...is equivalent to this procedural approach.\n>>> from beartype.door import is_subhint\n>>> is_subhint(subhint=tuple[bool], superhint=tuple[int])\nTrue\n```\n\n----------------------------------------\n\nTITLE: Function with Nested List Type Hint in Python\nDESCRIPTION: Example showing a function decorated with @beartype using a deeply nested list[list[list[str]]] type hint.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/code.rst#2025-04-16_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom beartype import beartype\n\n@beartype\ndef law_of_the_jungle_8(pull_thorns_from_all_wolves_paws: (\n    list[list[list[str]]])): \n    return pull_thorns_from_all_wolves_paws\n```\n\n----------------------------------------\n\nTITLE: Creating Length-Constrained String Validator\nDESCRIPTION: Example of creating a functional validator using the Is class to validate string length. The validator enforces that strings must have lengths between 4 and 40 characters.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype.vale import Is\nfrom typing import Annotated   # <--------------- if Python ≥ 3.9.0\n#from typing_extensions import Annotated   # <--- if Python < 3.9.0\n\n# Type hint matching only strings with lengths ranging [4, 40].\nLengthyString = Annotated[str, Is[lambda text: 4 <= len(text) <= 40]]\n```\n\n----------------------------------------\n\nTITLE: Decorating a Function with Beartype in Python\nDESCRIPTION: Demonstrates how to use the beartype decorator on a function with type annotations. The function prints 'Hello, Jungle!' with various optional parameters.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/eli5.rst#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom sys import stderr, stdout\nfrom typing import TextIO\n\n@beartype\ndef hello_jungle(\n    sep: str = ' ',\n    end: str = '\\n',\n    file: TextIO = stdout,\n    flush: bool = False,\n):\n    '''\n    Print \"Hello, Jungle!\" to a stream, or to sys.stdout by default.\n\n    Optional keyword arguments:\n    file:  a file-like object (stream); defaults to the current sys.stdout.\n    sep:   string inserted between values, default a space.\n    end:   string appended after the last value, default a newline.\n    flush: whether to forcibly flush the stream.\n    '''\n\n    print('Hello, Jungle!', sep, end, file, flush)\n```\n\n----------------------------------------\n\nTITLE: Configuring Beartype with No-Time Strategy for Type-Check Avoidance\nDESCRIPTION: Demonstrates how to configure beartype with BeartypeStrategy.O0 to avoid type-checking any methods or attributes of a class, allowing violations to pass silently.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_decor.rst#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype import beartype, BeartypeConf, BeartypeStrategy\n\n# Avoid type-checking *ANY* methods or attributes of this class.\n@beartype(conf=BeartypeConf(strategy=BeartypeStrategy.O0))\nclass UncheckedDangerClassIsDangerous(object):\n    # This method raises *NO* type-checking violation despite returning a\n    # non-\"None\" value.\n    def unchecked_danger_method_is_dangerous(self) -> None:\n        return 'This string is not \"None\". Sadly, nobody cares anymore.'\n```\n\n----------------------------------------\n\nTITLE: Using IsSubclass Validator in Beartype\nDESCRIPTION: Shows how to use the IsSubclass validator to enforce that values are subclasses of specific classes. This example creates a type hint that accepts classes that are subclasses of either str or bytes.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype.vale import IsSubclass\nfrom typing import Annotated   # <--------------- if Python ≥ 3.9.0\n#from typing_extensions import Annotated   # <--- if Python < 3.9.0\n\n# Type hint matching only string and byte string subclasses.\nStrOrBytesSubclass = Annotated[type, IsSubclass[str, bytes]]\n```\n\n----------------------------------------\n\nTITLE: Handling Type Violations with Culprits in Python\nDESCRIPTION: Demonstrates how to catch and inspect BeartypeCallHintViolation exceptions and access violation culprits. Shows basic violation handling with a single culprit.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_roar.rst#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    when_spirit_bear_hibernates_in_your_bed(\n        SPIRIT_BEAR_REFUSE_TO_GO_AWAY)\nexcept BeartypeCallHintViolation as violation:\n    assert len(violation.culprits) == 1\n    culprit = violation.culprits[0]\n    assert culprit is SPIRIT_BEAR_REFUSE_TO_GO_AWAY\n```\n\n----------------------------------------\n\nTITLE: Validating NumPy Array Dimensionality with IsAttr\nDESCRIPTION: Example of creating a declarative validator using IsAttr and IsEqual to validate that a NumPy array has exactly 2 dimensions. This generates more efficient validation code than using a lambda function.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype.vale import IsAttr, IsEqual\nfrom typing import Annotated   # <--------------- if Python ≥ 3.9.0\n#from typing_extensions import Annotated   # <--- if Python < 3.9.0\n\n# Type hint matching only two-dimensional NumPy arrays. Given this,\n# @beartype generates efficient validation code resembling:\n#     isinstance(array, np.ndarray) and array.ndim == 2\nimport numpy as np\nNumpy2DArray = Annotated[np.ndarray, IsAttr['ndim', IsEqual[2]]]\n```\n\n----------------------------------------\n\nTITLE: Comparing is_bearable with isinstance\nDESCRIPTION: Example comparing is_bearable with Python's built-in isinstance function, showing how is_bearable is a strict superset of isinstance that can handle both simple class checks and complex type hints.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_door.rst#2025-04-16_snippet_2\n\nLANGUAGE: pycon\nCODE:\n```\n# Requisite machinery: I import you.\n>>> from beartype.door import is_bearable\n\n# These two statements are semantically equivalent.\n>>> is_bearable('I surrender and volunteer for treason.', str)\nTrue\n>>> isinstance('I surrender and volunteer for treason.', str)\nTrue\n\n# These two statements are semantically equivalent, too.\n>>> is_bearable(b'A moment of weakness is all it takes.', (str, bytes))\nTrue\n>>> isinstance(b'A moment of weakness is all it takes.', (str, bytes))\nTrue\n\n# These two statements are semantically equivalent, yet again. *shockface*\n>>> is_bearable('Comets: the icebergs of the sky.', bool | None)\nFalse\n>>> isinstance('Comets: the icebergs of the sky.', bool | None)\nTrue\n```\n\n----------------------------------------\n\nTITLE: Installing Beartype Package\nDESCRIPTION: Shows how to install Beartype using pip and set up initial configuration in a package's __init__.py file.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/index.rst#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Install beartype.\n$ pip3 install beartype\n\n# Edit the \"{your_package}.__init__\" submodule with your favourite IDE.\n$ vim {your_package}/__init__.py      # <-- so, i see that you too vim\n```\n\n----------------------------------------\n\nTITLE: Comparing IsSubclass with typing.Type and type\nDESCRIPTION: Compares the semantics of Beartype's IsSubclass validator with PEP 484's typing.Type and PEP 585's type type hint factories. All three check for subclassing, but IsSubclass provides more flexibility.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# This beartype validator enforces the same semantics as...\nIsStringSubclassWithBeartype = Annotated[type, IsSubclass[str]]\n\n# ...this PEP 484-compliant type hint as well as...\nIsStringSubclassWithPep484 = Type[str]\n\n# ...this PEP 585-compliant type hint.\nIsStringSubclassWithPep585 = type[str]\n```\n\n----------------------------------------\n\nTITLE: Using IsEqual Validator with Beartype\nDESCRIPTION: Demonstrates how to use the IsEqual validator to match lists equal to a specific value. This validator generalizes typing.Literal but works with any arbitrary type, not just the six predefined types supported by Literal.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype.vale import IsEqual\nfrom typing import Annotated   # <--------------- if Python ≥ 3.9.0\n#from typing_extensions import Annotated   # <--- if Python < 3.9.0\n\n# Type hint matching only lists equal to [0, 1, 2, ..., 40, 41, 42].\nAnswerToTheUltimateQuestion = Annotated[list, IsEqual[list(range(42))]]\n```\n\n----------------------------------------\n\nTITLE: Comparing Class Decoration vs Method Decoration with Beartype\nDESCRIPTION: Illustrates the equivalence between decorating an entire class with @beartype versus decorating each method individually, showing the syntactic convenience of class-level decoration.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_decor.rst#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype import beartype\n\n# Decorate a class with @beartype.\n@beartype\nclass IAmABearOfNoBrainAtAll(object):\n    def i_have_been_foolish(self) -> str:\n        return 'A fly can't bird, but a bird can fly.'\n\n    def and_deluded(self) -> str:\n        return 'Ask me a riddle and I reply.'\n\n# ...or just decorate class methods directly with @beartype.\n# The class above is *EXACTLY* equivalent to the class below.\nclass IAmABearOfNoBrainAtAll(object):\n    @beartype\n    def i_have_been_foolish(self) -> str:\n        return 'A fly can't bird, but a bird can fly.'\n\n    @beartype\n    def and_deluded(self) -> str:\n        return 'Ask me a riddle and I reply.'\n```\n\n----------------------------------------\n\nTITLE: Using IsInstance Validator in Beartype\nDESCRIPTION: Shows how to use the IsInstance validator to enforce that values are instances of specific classes. This example demonstrates creating a type hint that accepts both strings and byte strings using the IsInstance validator.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype.vale import IsInstance\nfrom typing import Annotated   # <--------------- if Python ≥ 3.9.0\n#from typing_extensions import Annotated   # <--- if Python < 3.9.0\n\n# Type hint matching only string and byte strings, equivalent to:\n#     StrOrBytesInstance = Union[str, bytes]\nStrOrBytesInstance = Annotated[object, IsInstance[str, bytes]]\n```\n\n----------------------------------------\n\nTITLE: TypeHint Args Property Usage in Python\nDESCRIPTION: Demonstrates how to access the original child type hints through the args property of a TypeHint wrapper. Shows the behavior for various kinds of nested type hints.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_door.rst#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> from beartype.door import TypeHint\n>>> TypeHint(list).args\n()  # <-- i believe this\n>>> TypeHint(list[int]).args\n(int,)  # <-- fair play to you, beartype!\n>>> TypeHint(tuple[int, complex]).args\n(int, complex)  # <-- the mind is willing, but the code is weak.\n```\n\n----------------------------------------\n\nTITLE: TypeHint Factory Class Implementation in Python\nDESCRIPTION: Demonstrates how TypeHint acts as a factory class that returns different concrete subclasses based on the type hint being wrapped. Shows examples of caching behavior and how to access the properties of TypeHint wrappers.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_door.rst#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> from beartype.door import TypeHint\n>>> from beartype.typing import Optional, Union\n\n>>> type(TypeHint(str | list))\nbeartype.door.UnionTypeHint  # <-- UnionTypeHint, I am your father.\n\n>>> type(TypeHint(Union[str, list]))\nbeartype.door.UnionTypeHint  # <-- NOOOOOOOOOOOOOOOOOOOOOOO!!!!!!!!\n\n>>> type(TypeHint(Optional[str]))\nbeartype.door.UnionTypeHint  # <-- Search your MRO. You know it to be true.\n```\n\n----------------------------------------\n\nTITLE: Comparing IsInstance with Standard Python Type Hints\nDESCRIPTION: Compares the semantics of Beartype's IsInstance validator with standard PEP 484 type hints. Both check for instances of classes, but IsInstance offers more flexibility and can be combined with other validators.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# This beartype validator enforces the same semantics as...\nIsUnicodeStrWithBeartype = Annotated[object, IsInstance[str]]\n\n# ...this PEP 484-compliant type hint.\nIsUnicodeStrWithPep484 = str\n\n# Likewise, this beartype validator enforces the same semantics as...\nIsStrWithWithBeartype = Annotated[object, IsInstance[str, bytes]]\n\n# ...this PEP 484-compliant type hint.\nIsStrWithWithPep484 = Union[str, bytes]\n```\n\n----------------------------------------\n\nTITLE: Using NumPy Array Type Hints with Array Dtype\nDESCRIPTION: Demonstrates how to use NumPy's NDArray type hints with array dtypes for validating NumPy arrays with specific data types. This approach is more portable and supported by mypy.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype import beartype\nfrom numpy import dtype\nfrom numpy.typing import NDArray\n\n# NumPy type hint matching all NumPy arrays of 32-bit big-endian integers,\n# semantically equivalent to this beartype validator:\n#     NumpyInt32BigEndianArray = Annotated[\n#         np.ndarray, IsAttr['dtype', IsEqual[dtype('>i4')]]]\nNumpyInt32BigEndianArray = NDArray[dtype('>i4')]\n```\n\n----------------------------------------\n\nTITLE: Using Negation Operator with Validators\nDESCRIPTION: Shows how to use the negation operator (~) with validators to create a new validator that returns True when the original returns False. This example creates a validator for strings that don't contain periods.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# Type hint matching only strings containing *no* periods, semantically\n# equivalent to this type hint:\n#     PeriodlessString = Annotated[str, Is[lambda text: '.' not in text]]\nPeriodlessString = Annotated[str, ~Is[lambda text: '.' in text]]\n```\n\n----------------------------------------\n\nTITLE: Decorating PEP 484 Generics with @beartype in Python\nDESCRIPTION: Example of using @beartype to decorate a class inheriting from a PEP 484 generic type (typing.Tuple). This allows runtime type checking of a custom tuple class that accepts string arguments.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/tldr.rst#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@beartype\nclass MyPep484Generic(typing.Tuple[str, ...]):\n    def __new__(cls, *args: str) -> typing.Tuple[str, ...]:\n        return tuple.__new__(cls, args)\n```\n\n----------------------------------------\n\nTITLE: Using Negation with IsInstance for Non-Boolean Integers\nDESCRIPTION: Demonstrates type hint arithmetic by creating a validator that matches non-boolean integers. This uses the negation operator with IsInstance to exclude boolean values while accepting other integers.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Type hint matching any non-boolean integer. Never fear integers again.\nIntNonbool = Annotated[int, ~IsInstance[bool]]   # <--- bruh\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Beartype's Performance with Large Data Structures\nDESCRIPTION: Example showing Beartype's high-performance type checking capabilities, verifying a list of one million 2-tuples of NumPy arrays in microseconds.\nSOURCE: https://github.com/beartype/beartype/blob/main/README.rst#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# ....................{ GO TO PLAID                     }.....................\n# Type-check anything in around 1µs (one millionth of a second) – including\n# this list of one million 2-tuples of NumPy arrays.\n>>> from beartype.door import is_bearable\n>>> from numpy import array, ndarray\n>>> data = [(array(i), array(i)) for i in range(1000000)]\n>>> %time is_bearable(data, list[tuple[ndarray, ndarray]])\n    CPU times: user 31 µs, sys: 2 µs, total: 33 µs\n    Wall time: 36.7 µs\nTrue\n```\n\n----------------------------------------\n\nTITLE: Detecting API Breakage Using Type Hints\nDESCRIPTION: Implementation of a function that detects breaking API changes between newer and older versions of a callable by comparing their type hints using beartype utilities.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_door.rst#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom beartype import beartype\nfrom beartype.door import is_subhint\nfrom beartype.peps import resolve_pep563\nfrom collections.abc import Callable\n\n@beartype\ndef is_func_api_preserved(func_new: Callable, func_old: Callable) -> bool:\n    '''\n    ``True`` only if the signature of the first passed callable (presumably\n    the newest version of some callable to be released) preserves backward\n    API compatibility with the second passed callable (presumably an older\n    previously released version of the first passed callable) according to\n    the PEP-compliant type hints annotating these two callables.\n\n    Parameters\n    ----------\n    func_new: Callable\n        Newest version of a callable to test for API breakage.\n    func_old: Callable\n        Older version of that same callable.\n\n    Returns\n    ----------\n    bool\n        ``True`` only if the ``func_new`` API preserves the ``func_old`` API.\n    '''\n\n    # Resolve all PEP 563-postponed type hints annotating these two callables\n    # *BEFORE* reasoning with these type hints.\n    resolve_pep563(func_new)\n    resolve_pep563(func_old)\n\n    # For the name of each annotated parameter (or \"return\" for an annotated\n    # return) and the hint annotating that parameter or return for this newer\n    # callable...\n    for func_arg_name, func_new_hint in func_new.__annotations__.items():\n        # Corresponding hint annotating this older callable if any or \"None\".\n        func_old_hint = func_old.__annotations__.get(func_arg_name)\n\n        # If no corresponding hint annotates this older callable, silently\n        # continue to the next hint.\n        if func_old_hint is None:\n            continue\n        # Else, a corresponding hint annotates this older callable.\n\n        # If this older hint is *NOT* a subhint of this newer hint, this\n        # parameter or return breaks backward compatibility.\n        if not is_subhint(func_old_hint, func_new_hint):\n            return False\n        # Else, this older hint is a subhint of this newer hint. In this case,\n        # this parameter or return preserves backward compatibility.\n\n    # All annotated parameters and returns preserve backward compatibility.\n    return True\n```\n\n----------------------------------------\n\nTITLE: Testing a Function with Complex Optional Types\nDESCRIPTION: Example showing successful calls to the sang_them_up_the_beach function with both an Enum type and None as arguments. The function correctly handles both cases.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/eli5.rst#2025-04-16_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> sang_them_up_the_beach(Lukannon)\n<Lukannon.SEALERS: 'And still we sing Lukannon—before the sealers came.'>\n>>> sang_them_up_the_beach()\nNone\n```\n\n----------------------------------------\n\nTITLE: Comparing IsEqual with typing.Literal\nDESCRIPTION: Illustrates the semantic equivalence between Beartype's IsEqual validator and PEP 586's typing.Literal. Both enforce equality checks, but IsEqual works with any object type while Literal is limited to six predefined types.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# This beartype validator enforces the same semantics as...\nIsStringEqualsWithBeartype = Annotated[str,\n    IsEqual['Don't you envy our pranceful bands?'] |\n    IsEqual['Don't you wish you had extra hands?']\n]\n\n# This PEP 586-compliant type hint.\nIsStringEqualsWithPep586 = Literal[\n    'Don't you envy our pranceful bands?',\n    'Don't you wish you had extra hands?',\n]\n```\n\n----------------------------------------\n\nTITLE: Advanced Usage of IsSubclass with NumPy Arrays\nDESCRIPTION: Demonstrates a complex validator that validates NumPy arrays by checking the type of a deeply nested attribute. This example shows how IsSubclass can be combined with IsAttr to create powerful validators.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# Type hint matching only NumPy arrays of reals (i.e., either integers\n# or floats) of arbitrary precision, generating code resembling:\n#    (isinstance(array, np.ndarray) and\n#     issubclass(array.dtype.type, (np.floating, np.integer)))\nNumpyRealArray = Annotated[\n    np.ndarray, IsAttr['dtype', IsAttr['type', IsSubclass[\n        np.floating, np.integer]]]]\n```\n\n----------------------------------------\n\nTITLE: Applying @beartype to Named Tuples in Python\nDESCRIPTION: Example of using @beartype with typing.NamedTuple classes. This enables runtime type checking for the fields of the named tuple, enforcing field types when instances are created.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/tldr.rst#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import NamedTuple\n\n# Decorate named tuples with @beartype.\n@beartype\nclass MyNamedTuple(NamedTuple):\n    # Annotate fields with type hints.\n    field_must_satisfy_builtin_type: str\n```\n\n----------------------------------------\n\nTITLE: Disabling PEP 526 Support in Beartype Import Hooks\nDESCRIPTION: Shows how to disable PEP 526 variable annotation type-checking in beartype import hooks by setting the claw_is_pep526 parameter to False in the BeartypeConf configuration.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_claw.rst#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# In your \"{your_package}.__init__\" submodule, disable PEP 526 support out\n# of spite. You cackle disturbingly as you do. Sanity crumbles. Python shrugs.\nfrom beartype import BeartypeConf            # <-- boiling boilerplate...\nfrom beartype.claw import beartype_packages  # <-- ...boils plates, what?\nbeartype_packages(\n    ('your.subpackage', 'your.submodule'),   # <-- pretend this makes sense\n    conf=BeartypeConf(claw_is_pep526=False)  # <-- *GAH!*\n)\n```\n\n----------------------------------------\n\nTITLE: Examples of Type Checking Violations in Python\nDESCRIPTION: Shows examples of function calls that would raise type checking violations, demonstrating how beartype and pandera catch invalid parameter types.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/faq.rst#2025-04-16_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# All of the following raise type-checking violations. Feels bad, man.\nconvert_dataframe_column_to_series(\n    dataframe=muh_dataframe, column_name_or_index=['y u done me dirty']))\nconvert_dataframe_column_to_series(\n    dataframe=DataFrame(), column_name_or_index=0))\n```\n\n----------------------------------------\n\nTITLE: Creating Complex String Validators with Beartype in Python\nDESCRIPTION: This example shows how to create and combine multiple string validators using Beartype, including checks for length, sentence structure, and quotation marks.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom beartype import beartype\nfrom beartype.vale import Is\nfrom typing import Annotated\n\nIsLengthy = Is[lambda text: len(text) >= 80]\nIsSentence = Is[lambda text: text and text[-1] == '.']\ndef _is_quoted(text): return text.count('\"') >= 2 or text.count(\"'\") >= 2\nIsQuoted = Is[_is_quoted]\n\n@beartype\ndef desentence_lengthy_quoted_sentence(\n    text: Annotated[str, IsLengthy, IsSentence, IsQuoted]) -> str:\n    return text[:-1]\n\n@beartype\ndef strip_lengthy_or_quoted_sentence(\n    text: Annotated[str, IsLengthy | (IsSentence & ~IsQuoted)]) -> str:\n    return text[:-1]\n```\n\n----------------------------------------\n\nTITLE: Implementing NumPy Array Type Hints with Scalar Dtype ABC\nDESCRIPTION: Shows how to create type hints for NumPy arrays using scalar dtype ABCs, which validate the kind of scalars without specific precision requirements. Uses the floating ABC as an example.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype import beartype\nfrom numpy import floating\nfrom numpy.typing import NDArray\n\n# NumPy type hint matching all NumPy arrays of floats of arbitrary\n# precision, equivalent to this beartype validator:\n#     NumpyFloatArray = Annotated[\n#         np.ndarray, IsAttr['dtype', IsAttr['type', IsSubclass[floating]]]]\nNumpyFloatArray = NDArray[floating]\n```\n\n----------------------------------------\n\nTITLE: Using Conjunction Operator with Validators\nDESCRIPTION: Demonstrates how to use the conjunction operator (&) to combine multiple validators. This creates a new validator that returns True only when all component validators return True.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# Type hint matching only non-empty strings containing *no* periods,\n# semantically equivalent to this type hint:\n#     NonemptyPeriodlessString = Annotated[\n#         str, Is[lambda text: text and '.' not in text]]\n```\n\n----------------------------------------\n\nTITLE: Basic Beartype Package Configuration\nDESCRIPTION: Demonstrates how to enable type checking for an entire package using beartype_this_package().\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/index.rst#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# At the very top of your \"{your_package}.__init__\" submodule:\nfrom beartype.claw import beartype_this_package  # <-- boilerplate for victory\nbeartype_this_package()                          # <-- yay! your team just won\n```\n\n----------------------------------------\n\nTITLE: Validating 2D NumPy Arrays with Beartype Validators\nDESCRIPTION: Demonstrates how to validate two-dimensional NumPy arrays of floating-point numbers using Beartype's declarative validators. This approach allows for efficient property-based validation of NumPy arrays.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype import beartype\nfrom beartype.vale import IsAttr, IsEqual, IsSubclass\nfrom typing import Annotated   # <--------------- if Python ≥ 3.9.0\n#from typing_extensions import Annotated   # <--- if Python < 3.9.0\n\n# Type hint matching only two-dimensional NumPy arrays of floats of\n# arbitrary precision. This time, do it faster than anyone has ever\n# type-checked NumPy arrays before. (Cue sonic boom, Chuck Yeager.)\nimport numpy as np\nNumpy2DFloatArray = Annotated[np.ndarray,\n    IsAttr['ndim', IsEqual[2]] &\n    IsAttr['dtype', IsAttr['type', IsSubclass[np.floating]]]\n]\n\n# Annotate @beartype-decorated callables with beartype validators.\n@beartype\ndef polygon_area(polygon: Numpy2DFloatArray) -> float:\n    '''\n    Area of a two-dimensional polygon of floats defined as a set of\n    counter-clockwise points, calculated via Green's theorem.\n\n    *Don't ask.*\n    '''\n\n    # Calculate and return the desired area. Pretend we understand this.\n    polygon_rolled = np.roll(polygon, -1, axis=0)\n    return np.abs(0.5*np.sum(\n        polygon[:,0]*polygon_rolled[:,1] -\n        polygon_rolled[:,0]*polygon[:,1]))\n```\n\n----------------------------------------\n\nTITLE: Using is_subhint with Python Type Hints\nDESCRIPTION: Demonstrates how to use the is_subhint function to determine whether one type hint is a subhint of another, showing examples with callables, primitive types, and inheritance relationships.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_door.rst#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Import us up the machinery.\n>>> from beartype.door import is_subhint\n>>> from beartype.typing import Any\n>>> from collections.abc import Callable, Sequence\n\n# A type hint matching any callable accepting no arguments and returning\n# a list is a subhint of a type hint matching any callable accepting any\n# arguments and returning a sequence of any types.\n>>> is_subhint(Callable[[], list], Callable[..., Sequence[Any]])\nTrue\n\n# A type hint matching any callable accepting no arguments and returning\n# a list, however, is *NOT* a subhint of a type hint matching any\n# callable accepting any arguments and returning a sequence of integers.\n>>> is_subhint(Callable[[], list], Callable[..., Sequence[int]])\nFalse\n\n# Booleans are subclasses and thus subhints of integers.\n>>> is_subhint(bool, int)\nTrue\n\n# The converse, however, is *NOT* true.\n>>> is_subhint(int, bool)\nFalse\n\n# All classes are subclasses and thus subhints of themselves.\n>>> is_subhint(int, int)\nTrue\n```\n\n----------------------------------------\n\nTITLE: Creating an EmptyOrPeriodfullString Type with Beartype Validators in Python\nDESCRIPTION: This example shows how to use the | (or) operator with Beartype validators to create a type hint for strings that are either empty or contain at least one period.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nEmptyOrPeriodfullString = Annotated[str, (\n    ~Is[lambda text: bool(text)] |\n     Is[lambda text: '.' in text]\n)]\n```\n\n----------------------------------------\n\nTITLE: Using is_bearable for Type Compatibility Testing\nDESCRIPTION: Example showing how to use the is_bearable function to test if objects satisfy type hints. The function returns True if an object satisfies the hint, False otherwise.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_door.rst#2025-04-16_snippet_1\n\nLANGUAGE: pycon\nCODE:\n```\n# Import the requisite machinery.\n>>> from beartype.door import is_bearable\n>>> from beartype.typing import List, Sequence\n\n# Type-check an object violating a type hint.\n>>> is_bearable('Stop exploding, you cowards.', List[bool] | None)\nFalse\n\n# Type-check multiple objects satisfying multiple type hints.\n>>> is_bearable(\"Kif, I'm feeling the 'Captain's itch.'\", str | None)\nTrue\n>>> is_bearable('I hate these filthy Neutrals, Kif.', Sequence[str])\nTrue\n```\n\n----------------------------------------\n\nTITLE: Creating a Combined Decorator for Beartype and Pandera in Python\nDESCRIPTION: Defines a custom decorator that combines both beartype and pandera.check_types decorators to reduce boilerplate and ensure both type checking systems are always applied together.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/faq.rst#2025-04-16_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# Never again suffer for the sins of others.\ndef bearpanderatype(*args, **kwargs):\n    return beartype(pa.check_types(*args, **kwargs))\n\n# Knowledge is power. Clench it with your iron fist until it pops.\n@bearpanderatype  # <-- less boilerplate means more power\ndef convert_dataframe_column_to_series(...) -> ...: ...\n```\n\n----------------------------------------\n\nTITLE: Basic Function with ArgumentParser Type Hint in Python\nDESCRIPTION: Example showing a function decorated with @beartype using ArgumentParser as a type hint parameter.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/code.rst#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom argparse import ArgumentParser\nfrom beartype import beartype\n\n@beartype\ndef law_of_the_jungle_5(a_cub_may_be_bought_at_a_price: ArgumentParser):\n    return a_cub_may_be_bought_at_a_price\n```\n\n----------------------------------------\n\nTITLE: TypeHint Caching Behavior in Python\nDESCRIPTION: Shows how TypeHint implements singleton caching for efficiency, returning the same instance when wrapping identical type hints.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_door.rst#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> from beartype.door import TypeHint\n>>> TypeHint(list[int]) is TypeHint(list[int])\nTrue  # <-- you caching monster. how could you? we trusted you!\n```\n\n----------------------------------------\n\nTITLE: Accessing TypeHint Child Wrappers in Python\nDESCRIPTION: Shows how to access child TypeHint wrappers using Python container functions, demonstrating that TypeHint supports standard container operations.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_door.rst#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> from beartype.door import TypeHint\n>>> tuple(TypeHint(list))\n()  # <-- is this the real life? is this just fantasy? ...why not both?\n>>> tuple(TypeHint(list[int]))\n(TypeHint(<class 'int'>),)  # <-- the abyss is staring back at us here.\n>>> tuple(TypeHint(tuple[int, complex]))\n(TypeHint(<class 'int'>), TypeHint(<class 'complex'>))  # <-- make the bad documentation go away, beartype\n```\n\n----------------------------------------\n\nTITLE: Beartype with Class Methods Example\nDESCRIPTION: Shows how to use @beartype with class methods and demonstrates proper decorator ordering when combining with other decorators like @classmethod.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_decor.rst#2025-04-16_snippet_1\n\nLANGUAGE: pycon\nCODE:\n```\n# Import the requisite machinery.\n>>> from beartype import beartype\n\n# Decorate class methods with @beartype in either order.\n>>> class BlastItAll(object):\n...     @classmethod\n...     @beartype  # <-- GOOD. this is the best of all possible worlds.\n...     def good_idea(cls, we_will_dynamite: str) -> str:\n...         return we_will_dynamite\n...\n...     @beartype  # <-- BAD. technically, fine. pragmatically, slower.\n...     @classmethod\n...     def save_time(cls, whats_the_charge: str) -> str:\n...         return whats_the_charge\n```\n\n----------------------------------------\n\nTITLE: Function with List[str] Type Hint in Python\nDESCRIPTION: Example showing a function decorated with @beartype using a PEP 585-compliant list[str] type hint.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/code.rst#2025-04-16_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom beartype import beartype\n\n@beartype\ndef law_of_the_jungle_7(kill_everything_that_thou_canst: list[str]):\n    return kill_everything_that_thou_canst\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Optional Types Using Union and NoneType\nDESCRIPTION: Alternative implementation of the same function using typing.Union with NoneType instead of typing.Optional. This approach is semantically equivalent but more verbose.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/eli5.rst#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom beartype import beartype\nfrom beartype.cave import EnumType, EnumMemberType, NoneType\nfrom typing import Union\n\n@beartype\ndef tell_the_deep_sea_viceroys(story: Union[EnumType, NoneType] = None) -> (\n    Union[EnumMemberType, NoneType]):\n    return list(story.__members__.values())[-1] if story is not None else None\n```\n\n----------------------------------------\n\nTITLE: TypeHint Hint Property in Python\nDESCRIPTION: Shows how to access the original type hint that was wrapped by a TypeHint instance using the hint property.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_door.rst#2025-04-16_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> from beartype.door import TypeHint\n>>> TypeHint(list[int]).hint\nlist[int]\n```\n\n----------------------------------------\n\nTITLE: Defining Function with Builtin Type Hint in Python\nDESCRIPTION: Illustrates a function annotated with a builtin type (int), which beartype will generate a constant-time check for.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/code.rst#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom beartype import beartype\n\n@beartype\ndef law_of_the_jungle_4(he_must_be_spoken_for_by_at_least_two: int):\n    return he_must_be_spoken_for_by_at_least_two\n```\n\n----------------------------------------\n\nTITLE: Using TypeHint with Union Types in Python\nDESCRIPTION: Demonstrates how to use the TypeHint wrapper to introspect a PEP 604-compliant type union. Shows how to check the type of the wrapper, test if values match the type hint, iterate over child hints, and perform other operations not normally possible with standard type hints.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_door.rst#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# This is DOOR. It's a Pythonic API providing an object-oriented interface\n# to low-level type hints that *OFFICIALLY* have no API whatsoever.\n>>> from beartype.door import TypeHint\n\n# DOOR hint wrapping a PEP 604-compliant type union.\n>>> union_hint = TypeHint(int | str | None)  # <-- so. it begins.\n\n# DOOR hints have Pythonic public classes -- unlike normal type hints.\n>>> type(union_hint)\nbeartype.door.UnionTypeHint  # <-- what madness is this?\n\n# DOOR hints can be detected Pythonically -- unlike normal type hints.\n>>> from beartype.door import UnionTypeHint\n>>> isinstance(union_hint, UnionTypeHint)  # <-- *shocked face*\nTrue\n\n# DOOR hints can be type-checked Pythonically -- unlike normal type hints.\n>>> union_hint.is_bearable('The unbearable lightness of type-checking.')\nTrue\n>>> union_hint.die_if_unbearable(b'The @beartype that cannot be named.')\nbeartype.roar.BeartypeDoorHintViolation: Object b'The @beartype that cannot\nbe named.' violates type hint int | str | None, as bytes b'The @beartype\nthat cannot be named.' not str, <class \"builtins.NoneType\">, or int.\n\n# DOOR hints can be iterated Pythonically -- unlike normal type hints.\n>>> for child_hint in union_hint: print(child_hint)\nTypeHint(<class 'int'>)\nTypeHint(<class 'str'>)\nTypeHint(<class 'NoneType'>)\n\n# DOOR hints can be indexed Pythonically -- unlike normal type hints.\n>>> union_hint[0]\nTypeHint(<class 'int'>)\n>>> union_hint[-1]\nTypeHint(<class 'str'>)\n\n# DOOR hints can be sliced Pythonically -- unlike normal type hints.\n>>> union_hint[0:2]\n(TypeHint(<class 'int'>), TypeHint(<class 'str'>))\n\n# DOOR hints supports \"in\" Pythonically -- unlike normal type hints.\n>>> TypeHint(int) in union_hint  # <-- it's all true.\nTrue\n>>> TypeHint(bool) in union_hint  # <-- believe it.\nFalse\n\n# DOOR hints are sized Pythonically -- unlike normal type hints.\n>>> len(union_hint)  # <-- woah.\n3\n\n# DOOR hints test as booleans Pythonically -- unlike normal type hints.\n>>> if union_hint: print('This type hint has children.')\nThis type hint has children.\n>>> if not TypeHint(tuple[()]): print('But this other type hint is empty.')\nBut this other type hint is empty.\n\n# DOOR hints support equality Pythonically -- unlike normal type hints.\n>>> from typing import Union\n>>> union_hint == TypeHint(Union[int, str, None])\nTrue  # <-- this is madness.\n\n# DOOR hints support comparisons Pythonically -- unlike normal type hints.\n>>> union_hint <= TypeHint(int | str | bool | None)\nTrue  # <-- madness continues.\n\n# DOOR hints publish the low-level type hints they wrap.\n>>> union_hint.hint\nint | str | None  # <-- makes sense.\n\n# DOOR hints publish tuples of the original child type hints subscripting\n# (indexing) the original parent type hints they wrap -- unlike normal type\n# hints, which unreliably publish similar tuples under differing names.\n>>> union_hint.args\n(int, str, NoneType)  # <-- sense continues to be made.\n\n# DOOR hints are semantically self-caching.\n>>> TypeHint(int | str | bool | None) is TypeHint(None | bool | str | int)\nTrue  # <-- blowing minds over here.\n```\n\n----------------------------------------\n\nTITLE: Function with List[object] Type Hint in Python\nDESCRIPTION: Example showing a function decorated with @beartype using a PEP 585-compliant list[object] type hint.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/code.rst#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom beartype import beartype\n\n@beartype\ndef law_of_the_jungle_6(all_the_jungle_is_thine: list[object]):\n    return all_the_jungle_is_thine\n```\n\n----------------------------------------\n\nTITLE: Using beartype_packages Import Hook with Python\nDESCRIPTION: Demonstrates how to apply the beartype_packages import hook to type-check specific packages and modules. This hook should be called before the target packages are imported, typically as the first statement in a package's __init__ module.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_claw.rst#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# At the top of your \"{your_package}.__init__\" submodule:\nfrom beartype import BeartypeConf            # <-- copy-pasta\nfrom beartype.claw import beartype_packages  # <-- copy-pasta intensifies\nbeartype_packages((\n    'your_package',\n    'some_package.published_by.the_rogue_ai.Johnny_Twobits',  # <-- seems trustworthy\n    'numpy',  # <-- ...heh. no one knows what will happen here!\n    'scipy',  # <-- ...but we can guess, can't we? *sigh*\n), conf=BeartypeConf(is_pep484_tower=True))  # <-- so. u 2 h8 precision.\n```\n\n----------------------------------------\n\nTITLE: Comparing is_bearable with issubclass\nDESCRIPTION: Example demonstrating how is_bearable can be used as a spiritual superset of issubclass by using Type[] hints to check subclass relationships with more complex type expressions.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_door.rst#2025-04-16_snippet_3\n\nLANGUAGE: pycon\nCODE:\n```\n# Machinery. It is requisite.\n>>> from beartype.door import is_bearable\n>>> from beartype.typing import Type\n>>> from collections.abc import Awaitable, Collection, Iterable\n\n# These two statements are semantically equivalent.\n>>> is_bearable(str, Type[Iterable])\nTrue\n>>> issubclass(str, Iterable)\nTrue\n\n# These two statements are semantically equivalent, too.\n>>> is_bearable(bytes, Type[Collection] | Type[Awaitable])\nTrue\n>>> issubclass(bytes, (Collection, Awaitable))\nTrue\n\n# These two statements are semantically equivalent, yet again. *ohbygods*\n>>> is_bearable(bool, Type[str] | Type[float])\nFalse\n>>> issubclass(bool, (str, float))\nTrue\n```\n\n----------------------------------------\n\nTITLE: Using die_if_unbearable method of TypeHint with Python Union types\nDESCRIPTION: This example demonstrates how to use the die_if_unbearable method of TypeHint to check if an object violates a type hint. It shows both the object-oriented approach using TypeHint and the equivalent procedural approach using the die_if_unbearable function.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_door.rst#2025-04-16_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# This object-oriented approach...\n>>> from beartype.door import TypeHint\n>>> TypeHint(bytes | None).die_if_unbearable(\n...     \"You can't lose hope when it's hopeless.\")\nBeartypeDoorHintViolation: Object \"You can't lose hope when it's hopeless.\" violates type hint bytes | None, as str \"You can't lose hope when it's hopeless.\" not bytes or <class \"builtins.NoneType\">.\n\n# ...is equivalent to this procedural approach.\n>>> from beartype.door import die_if_unbearable\n>>> die_if_unbearable(\n...     obj=\"You can't lose hope when it's hopeless.\", hint=bytes | None)\nBeartypeDoorHintViolation: Object \"You can't lose hope when it's hopeless.\" violates type hint bytes | None, as str \"You can't lose hope when it's hopeless.\" not bytes or <class \"builtins.NoneType\">.\n```\n\n----------------------------------------\n\nTITLE: Configuring Import Hooks with BeartypeConf in Python\nDESCRIPTION: Demonstrates how to configure beartype import hooks using BeartypeConf parameters, enabling options like the PEP 484-compliant implicit numeric tower for more flexible type checking.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_claw.rst#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# In your \"{your_package}.__init__\" submodule, enable @beartype's support for\n# the PEP 484-compliant implicit numeric tower (i.e., expand \"int\" to \"int |\n# float\" and \"complex\" to \"int | float | complex\"):\nfrom beartype import BeartypeConf           # <-- it all seems so familiar\nfrom beartype.claw import beartype_package  # <-- boil it up, boilerplate\nbeartype_package('your_package', conf=BeartypeConf(is_pep484_tower=True))  # <-- *UGH.*\n```\n\n----------------------------------------\n\nTITLE: Showing Python's Default Type Safety Behavior\nDESCRIPTION: This example demonstrates Python's default duck-typed behavior where type annotations are not enforced at runtime. The function returns a string despite being annotated to return an integer, with no errors raised.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/faq.rst#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ python3 - <<EOL\ndef main() -> int:\n    print(\"Hello, world!\");\n    return \"Goodbye, world.\";  # <-- pretty sure that's not an \"int\".\nmain()\nEOL\n\nHello, world!\n```\n\n----------------------------------------\n\nTITLE: Type-checking PyTorch Tensors with Beartype and Custom Validators\nDESCRIPTION: This example shows how to use Beartype validators to type-check PyTorch tensors without additional dependencies. It defines custom type hints for floating-point and integral PyTorch tensors using lambda functions.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/faq.rst#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype import beartype\nfrom beartype.vale import Is\nfrom typing import Annotated   # <--------------- if Python ≥ 3.9.0\n# from typing_extensions import Annotated   # <-- if Python < 3.9.0\n\n# Import PyTorch (d)types of interest.\nfrom torch import (\n    float as torch_float,\n    int as torch_int,\n    tensor,\n)\n\n# PEP-compliant type hint matching only a floating-point PyTorch tensor.\nTorchTensorFloat = Annotated[tensor, Is[\n    lambda tens: tens.type() is torch_float]]\n\n# PEP-compliant type hint matching only an integral PyTorch tensor.\nTorchTensorInt = Annotated[tensor, Is[\n    lambda tens: tens.type() is torch_int]]\n\n# Type-check everything like an NLP babelfish.\n@beartype\ndef deep_dream(dreamy_tensor: TorchTensorFloat) -> TorchTensorInt:\n    return dreamy_tensor.type(dtype=torch_int)\n```\n\n----------------------------------------\n\nTITLE: Defining Function with Complex Ignorable Type Hint in Python\nDESCRIPTION: Demonstrates a function with a complex type hint that is ultimately ignorable after deep analysis.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/code.rst#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, NewType, Union\n\nhint = Union[str, list[int], NewType('MetaType', Annotated[object, 53])]\ndef law_of_the_jungle_3(bring_them_to_the_pack_council: hint) -> hint:\n    return bring_them_to_the_pack_council\n```\n\n----------------------------------------\n\nTITLE: Configuring Exception Handling in Beartype Import Hooks\nDESCRIPTION: Demonstrates how to configure beartype import hooks to raise exceptions instead of warnings when decoration fails, useful for stricter type checking enforcement and debugging.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_claw.rst#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# In your \"{your_package}.__init__\" submodule, raise exceptions because you\n# hate worky. The CI pipeline you break over your knee may just be your own.\nfrom beartype import BeartypeConf                # <-- boiling boilerplate...\nfrom beartype.claw import beartype_this_package  # <-- ...ain't even lukewarm\nbeartype_this_package(conf=BeartypeConf(warning_cls_on_decorator_exception=None))  # <-- *ohboy*\n```\n\n----------------------------------------\n\nTITLE: Using Union Types with Beartype in Python\nDESCRIPTION: Shows how to use Union type hints to accept or return multiple possible types. This example accepts either an integer or mapping and returns either an integer or callable.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/eli5.rst#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom beartype import beartype\nfrom collections.abc import Callable, Mapping\nfrom numbers import Integral\nfrom typing import Any, Union\n\n@beartype\ndef toomai_of_the_elephants(memory: Union[Integral, Mapping[Any, Any]]) -> (\n    Union[Integral, Callable[(Any,), Any]]):\n    return memory if isinstance(memory, Integral) else lambda key: memory[key]\n```\n\n----------------------------------------\n\nTITLE: Conditionally Disabling Type-Checking Based on Build Type in Python\nDESCRIPTION: Shows how to create a custom @maybebeartype decorator that conditionally disables type-checking based on a build-specific constant.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_decor.rst#2025-04-16_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype import beartype, BeartypeConf, BeartypeStrategy\n\n# Let us pretend you know what you are doing for a hot moment.\nfrom your_app import I_AM_RELEASE_BUILD\n\n# Dynamically create a new @maybebeartype decorator disabling\n# type-checking when \"I_AM_RELEASE_BUILD\" is enabled.\nmaybebeartype = beartype(conf=BeartypeConf(strategy=(\n    BeartypeStrategy.O0\n    if I_AM_RELEASE_BUILD else\n    BeartypeStrategy.O1\n)))\n\n# Decorate with this decorator rather than @beartype everywhere.\n@maybebeartype\ndef muh_performance_critical_func(big_list: list[int]) -> int:\n    return sum(big_list)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Errors in C Compilation\nDESCRIPTION: This example shows how statically-typed languages like C catch type errors at compile time, contrasting with Python's behavior. The code attempts to return a string from a function declared to return an integer, causing a compilation error.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/faq.rst#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc -Werror=int-conversion -xc - <<EOL\n#include <stdio.h>\nint main() {\n    printf(\"Hello, world!\");\n    return \"Goodbye, world.\";\n}\nEOL\n<stdin>: In function 'main':\n<stdin>:4:11: error: returning 'char *' from a function with return type\n'int' makes integer from pointer without a cast [-Werror=int-conversion]\ncc1: some warnings being treated as errors\n```\n\n----------------------------------------\n\nTITLE: Type-checking Boto3 Resources with Beartype and Custom Validators\nDESCRIPTION: This snippet demonstrates how to use Beartype with Boto3 resources by combining PEP 484 type aliases, TYPE_CHECKING, and custom Beartype validators. It allows for both static and runtime type-checking of Boto3 types.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/faq.rst#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype import beartype\nfrom boto3 import resource\nfrom boto3.resources.base import ServiceResource\nfrom typing import TYPE_CHECKING\n\n# If performing static type-checking (e.g., mypy, pyright), import boto3\n# stub types safely usable *ONLY* by static type-checkers.\nif TYPE_CHECKING:\n    from mypy_boto3_s3.service_resource import Bucket\n# Else, @beartime-based runtime type-checking is being performed. Alias the\n# same boto3 stub types imported above to their semantically equivalent\n# beartype validators accessible *ONLY* to runtime type-checkers.\nelse:\n    # Import even more requisite machinery. Can't have enough, I say!\n    from beartype.vale import IsAttr, IsEqual\n    from typing import Annotated   # <--------------- if Python ≥ 3.9.0\n    # from typing_extensions import Annotated   # <-- if Python < 3.9.0\n\n    # Generalize this to other boto3 types by copy-and-pasting this and\n    # replacing the base type and \"s3.Bucket\" with the wonky runtime names\n    # of those types. Sadly, there is no one-size-fits all common base class,\n    # but you should find what you need in the following places:\n    # * \"boto3.resources.base.ServiceResource\".\n    # * \"boto3.resources.collection.ResourceCollection\".\n    # * \"botocore.client.BaseClient\".\n    # * \"botocore.paginate.Paginator\".\n    # * \"botocore.waiter.Waiter\".\n    Bucket = Annotated[ServiceResource,\n        IsAttr['__class__', IsAttr['__name__', IsEqual[\"s3.Bucket\"]]]]\n\n# Do this for the good of the gross domestic product, @beartype.\n@beartype\ndef get_s3_bucket_example() -> Bucket:\n    s3 = resource('s3')\n    return s3.Bucket('example')\n```\n\n----------------------------------------\n\nTITLE: Generated Wrapper Function for Builtin Type Check in Python\nDESCRIPTION: Shows the dynamically generated wrapper function that beartype creates for a function annotated with a builtin type hint. This wrapper performs efficient constant-time type checking.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/code.rst#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef law_of_the_jungle_4(\n    *args,\n    __beartype_func=__beartype_func,\n    __beartypistry=__beartypistry,\n    **kwargs\n):\n    # Localize the number of passed positional arguments for efficiency.\n    __beartype_args_len = len(args)\n    # Localize this positional or keyword parameter if passed *OR* to the\n    # sentinel value \"__beartypistry\" guaranteed to never be passed otherwise.\n    __beartype_pith_0 = (\n        args[0] if __beartype_args_len > 0 else\n        kwargs.get('he_must_be_spoken_for_by_at_least_two', __beartypistry)\n    )\n\n    # If this parameter was passed...\n    if __beartype_pith_0 is not __beartypistry:\n        # Type-check this passed parameter or return value against this\n        # PEP-compliant type hint.\n        if not isinstance(__beartype_pith_0, int):\n            __beartype_get_beartype_violation(\n                func=__beartype_func,\n                pith_name='he_must_be_spoken_for_by_at_least_two',\n                pith_value=__beartype_pith_0,\n            )\n\n    # Call this function with all passed parameters and return the value\n    # returned from this call.\n    return __beartype_func(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Refactoring Type Hint Imports in Python\nDESCRIPTION: This code snippet shows how to refactor type hint imports to use a custom typing module. Instead of importing directly from the typing module, it imports from a package-specific _typing module. This approach allows for version-specific type hint handling.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_roar.rst#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Instead of this...\nfrom typing import List, Tuple\n\n# ...just do this.\nfrom {your_package}._typing import List, Tuple\n```\n\n----------------------------------------\n\nTITLE: Verifying Identity Decoration for Any-annotated Function in Python\nDESCRIPTION: Shows how beartype reduces to an identity decorator for functions annotated with typing.Any.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/code.rst#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from beartype import beartype\n>>> beartype(law_of_the_jungle_2) is law_of_the_jungle_2\nTrue\n```\n\n----------------------------------------\n\nTITLE: Creating a DataFrame with Sample Data in Python\nDESCRIPTION: Creates a pandas DataFrame with hexadecimal values, string quotes, and datetime values to serve as sample data for type checking examples.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/faq.rst#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nmuh_dataframe = pd.DataFrame({\n    'Hexspeak': (\n        0xCAFED00D,\n        0xCAFEBABE,\n        0x1337BABE,\n    ),\n    'OdeToTheWestWind': (\n        'Angels of rain and lightning: there are spread',\n        'On the blue surface of thine aery surge,',\n        'Like the bright hair uplifted from the head',\n    ),\n    'PercyByssheShelley': pd.to_datetime((\n        '1792-08-04',\n        '1822-07-08',\n        '1851-02-01',\n    )),\n})\n```\n\n----------------------------------------\n\nTITLE: Generated Type Checking Code for List[str]\nDESCRIPTION: The wrapper function dynamically generated by beartype to perform deep type checking for list[str] parameter.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/code.rst#2025-04-16_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndef law_of_the_jungle_7(\n    *args,\n    __beartype_func=__beartype_func,\n    __beartypistry=__beartypistry,\n    **kwargs\n):\n    __beartype_random_int = __beartype_getrandbits(64)\n    __beartype_args_len = len(args)\n    __beartype_pith_0 = (\n        args[0] if __beartype_args_len > 0 else\n        kwargs.get('kill_everything_that_thou_canst', __beartypistry)\n    )\n\n    if __beartype_pith_0 is not __beartypistry:\n        if not (\n            isinstance(__beartype_pith_0, list) and\n            (not __beartype_pith_0 or isinstance(__beartype_pith_0[__beartype_random_int % len(__beartype_pith_0)], str))\n        ):\n            __beartype_get_beartype_violation(\n                func=__beartype_func,\n                pith_name='kill_everything_that_thou_canst',\n                pith_value=__beartype_pith_0,\n            )\n\n    return __beartype_func(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Advanced Beartype Validation\nDESCRIPTION: Demonstrates advanced type checking using Beartype validators and Annotated types.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/index.rst#2025-04-16_snippet_5\n\nLANGUAGE: pycon\nCODE:\n```\n>>> from beartype.vale import Is\n>>> from typing import Annotated\n>>> ListOfStrings = Annotated[\n...     list[str],\n...     Is[lambda lst: bool(lst)]\n... ]\n\n>>> @beartype\n... def quote_wiggum_safer(lines: ListOfStrings) -> None:\n...     print('\"{}\"\\n\\t— Police Chief Wiggum'.format(\"\\n \".join(lines)))\n```\n\n----------------------------------------\n\nTITLE: Defining Function with Any Type Hint in Python\nDESCRIPTION: Illustrates a function annotated with the typing.Any type hint, which beartype considers shallowly ignorable.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/code.rst#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\ndef law_of_the_jungle_2(never_order_anything_without_a_reason: Any) -> Any:\n    return never_order_anything_without_a_reason\n```\n\n----------------------------------------\n\nTITLE: Defining a Pandera DataFrameModel for Validation in Python\nDESCRIPTION: Creates a Pandera DataFrameModel class that validates the structure and types of the previously defined DataFrame, specifying that columns should be of Int64, String, and Timestamp types respectively.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/faq.rst#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nclass MuhDataFrameModel(pa.DataFrameModel):\n    Hexspeak: Series[Int64]\n    OdeToTheWestWind: Series[String]\n    PercyByssheShelley: Series[Timestamp]\n```\n\n----------------------------------------\n\nTITLE: Enabling PEP 484 Numeric Tower Support in Python with BeartypeConf\nDESCRIPTION: Demonstrates how to create a custom beartype decorator that supports PEP 484's implicit numeric tower, allowing integers to be accepted for float parameters and both integers and floats for complex parameters.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_decor.rst#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype import beartype, BeartypeConf\n\n# Dynamically create a new @beartowertype decorator enabling the tower.\nbeartowertype = beartype(conf=BeartypeConf(is_pep484_tower=True))\n\n# Decorate with this decorator rather than @beartype everywhere.\n@beartowertype\ndef crunch_numbers(numbers: list[float]) -> float:\n    return sum(numbers)\n\n# This is now fine.\ncrunch_numbers([3, 1, 4, 1, 5, 9])\n\n# This is still fine, too.\ncrunch_numbers([3.1, 4.1, 5.9])\n```\n\n----------------------------------------\n\nTITLE: Setting Beartype Color Configuration via Environment Variable\nDESCRIPTION: Demonstrates how to disable color output in Beartype by setting the BEARTYPE_IS_COLOR environment variable before running a Python application. This environment variable controls color output across all Beartype configurations in all Python processes.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_decor.rst#2025-04-16_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nBEARTYPE_IS_COLOR=False python3 -m monochrome_retro_app.its_srsly_cool\n```\n\n----------------------------------------\n\nTITLE: Creating a Type-checked DataFrame Column Extractor Function in Python\nDESCRIPTION: Defines a function that extracts a column from a pandas DataFrame as a Series, using both beartype and pandera decorators to validate the input DataFrame and return types.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/faq.rst#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n@beartype\n@pa.check_types\ndef convert_dataframe_column_to_series(\n    # Annotate pandas data frames with pandera type hints.\n    dataframe: pa.typing.DataFrame[MuhDataFrameModel],\n    # Annotate everything else with standard PEP-compliant type hints. \\o/\n    column_name_or_index: str | int,\n# Annotate pandas series with pandera type hints, too.\n) -> Series[Int64 | String | Timestamp]:\n    '''\n    Convert the column of the passed pandas data frame (identified by the\n    passed column name or index) into a pandas series.\n    '''\n\n    # This is guaranteed to be safe. Since type-checks passed, this does too.\n    return (\n        dataframe.loc[:,column_name_or_index]\n        if isinstance(column_name_or_index, str) else\n        dataframe.iloc[:,column_name_or_index]\n    )\n```\n\n----------------------------------------\n\nTITLE: Using the Type-checked DataFrame Function with Examples in Python\nDESCRIPTION: Demonstrates using the type-checked function to extract columns by both index and name, showing successful usage examples that pass type validation.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/faq.rst#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nprint('[Series from data frame column by *NUMBER*]')\nprint(convert_dataframe_column_to_series(\n    dataframe=muh_dataframe, column_name_or_index=0))\nprint()\nprint('[Series from data frame column by *NAME*]')\nprint(convert_dataframe_column_to_series(\n    dataframe=muh_dataframe, column_name_or_index='OdeToTheWestWind'))\n```\n\n----------------------------------------\n\nTITLE: Using no_type_check Decorator with Beartype in Python\nDESCRIPTION: This snippet demonstrates how to use the typing.no_type_check decorator to disable type checking for an entire class when using Beartype. The example shows a method that returns a string despite being annotated to return None, which would normally cause a type checking violation but doesn't because of the decorator.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/faq.rst#2025-04-16_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n# Import more requisite machinery. It is requisite.\nfrom beartype import beartype\nfrom typing import no_type_check\n\n# Avoid type-checking *ANY* methods or attributes of this class.\n@no_type_check\nclass UncheckedRiskyClassRisksOurEntireHistoricalTimeline(object):\n    # This method raises *NO* type-checking violation despite returning a\n    # non-\"None\" value.\n    def unchecked_risky_method_which_i_am_squinting_at(self) -> None:\n        return 'This string is not \"None\". Why does nobody care? Why?'\n```\n\n----------------------------------------\n\nTITLE: Importing Beartype Decorator in Python\nDESCRIPTION: Shows how to import the beartype decorator, which is used to add runtime type checking to functions and methods.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/eli5.rst#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom beartype import beartype\n```\n\n----------------------------------------\n\nTITLE: Alternative Decorator Order for Type Checking in Python\nDESCRIPTION: Shows that the order of decorators doesn't matter when combining beartype and pandera.check_types, as both are permissive about decoration order.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/faq.rst#2025-04-16_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# Everyone is fine with this. That's what they say. But can we trust them?\n@pa.check_types\n@beartype\ndef convert_dataframe_column_to_series(...) -> ...: ...\n```\n\n----------------------------------------\n\nTITLE: Using NoneType with Beartype to Allow None Return Values in Python\nDESCRIPTION: This example shows how to modify a function to allow it to return either a tuple or None by importing NoneType from beartype.cave.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/eli5.rst#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom beartype.cave import NoneType\n@beartype\ndef law_of_the_jungle(wolf: str, pack: dict) -> (tuple, NoneType):\n    return (wolf, pack[wolf]) if wolf in pack else None\n```\n\n----------------------------------------\n\nTITLE: Using typing.no_type_check to Disable Beartype Checking\nDESCRIPTION: Shows how to use the typing.no_type_check decorator to prevent beartype from type-checking any methods or attributes of a class, which makes beartype behave as a noop.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_decor.rst#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Import more requisite machinery. It is requisite.\nfrom beartype import beartype\nfrom typing import no_type_check\n\n# Avoid type-checking *ANY* methods or attributes of this class.\n@no_type_check\nclass UncheckedRiskyClassRisksOurEntireHistoricalTimeline(object):\n    # This method raises *NO* type-checking violation despite returning a\n    # non-\"None\" value.\n    def unchecked_risky_method_which_i_am_squinting_at(self) -> None:\n        return 'This string is not \"None\". Why does nobody care? Why?'\n```\n\n----------------------------------------\n\nTITLE: Verifying Identity Decoration for Unannotated Function in Python\nDESCRIPTION: Demonstrates how beartype reduces to an identity decorator for functions without type annotations.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/code.rst#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from beartype import beartype\n>>> beartype(law_of_the_jungle) is law_of_the_jungle\nTrue\n```\n\n----------------------------------------\n\nTITLE: Configuring Cross-Package Type Checking with Beartype\nDESCRIPTION: Example showing how to type-check your code with exceptions and other packages with warnings, giving you control over type checking severity levels.\nSOURCE: https://github.com/beartype/beartype/blob/main/README.rst#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# ....................{ BIG BEAR                        }.....................\n# Warn about type hint violations in *OTHER* packages outside your control;\n# only raise exceptions from violations in your package under your control.\n# Again, at the very top of your \"{your_package}.__init__\" submodule:\nfrom beartype import BeartypeConf                              # <-- this isn't your fault\nfrom beartype.claw import beartype_all, beartype_this_package  # <-- you didn't sign up for this\nbeartype_this_package()                                        # <-- raise exceptions in your code\nbeartype_all(conf=BeartypeConf(violation_type=UserWarning))     # <-- emit warnings from other code\n```\n\n----------------------------------------\n\nTITLE: Complex Type Violation Handling with Container Types\nDESCRIPTION: Shows how Beartype handles type violations with nested container types, demonstrating culprit tracking limitations with builtin containers and repr strings.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_roar.rst#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom beartype import beartype\nfrom beartype.roar import BeartypeCallHintViolation\nfrom beartype.typing import List\n\n@beartype\ndef we_are_all_spirit_bear(\n    best_bear_dens: List[List[str]]) -> None: pass\n\nSPIRIT_BEAR_DO_AS_HE_PLEASE = [\n    [b'Why do you sleep in my pinball room, Spirit Bear?']]\n\ntry:\n    we_are_all_spirit_bear(SPIRIT_BEAR_DO_AS_HE_PLEASE)\nexcept BeartypeCallHintViolation as violation:\n    assert len(violation.culprits) == 2\n    root_culprit = violation.culprits[0]\n    leaf_culprit = violation.culprits[1]\n    assert root_culprit == repr(SPIRIT_BEAR_DO_AS_HE_PLEASE)\n    assert leaf_culprit == repr(SPIRIT_BEAR_DO_AS_HE_PLEASE[0][0])\n```\n\n----------------------------------------\n\nTITLE: Warning Suppression Examples in Python\nDESCRIPTION: Shows two approaches for suppressing Beartype's PEP 585 deprecation warnings - globally and locally scoped.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_roar.rst#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Global suppression\nfrom beartype.roar import BeartypeDecorHintPep585DeprecationWarning\nfrom warnings import filterwarnings\nfilterwarnings(\"ignore\", category=BeartypeDecorHintPep585DeprecationWarning)\n\n# Local suppression\nfrom beartype.roar import BeartypeDecorHintPep585DeprecationWarning\nfrom warnings import catch_warnings, filterwarnings\nwith catch_warnings():\n    filterwarnings(\"ignore\", category=BeartypeDecorHintPep585DeprecationWarning)\n```\n\n----------------------------------------\n\nTITLE: Defining Function with No Type Hints in Python\nDESCRIPTION: Shows a simple function definition without any type hints, which beartype will treat as an identity decoration case.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/code.rst#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef law_of_the_jungle(strike_first_and_then_give_tongue):\n    return strike_first_and_then_give_tongue\n```\n\n----------------------------------------\n\nTITLE: Extended Beartype Configuration with Warnings\nDESCRIPTION: Shows how to configure Beartype to handle type violations differently for your code versus external packages.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/index.rst#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom beartype import BeartypeConf\nfrom beartype.claw import beartype_all, beartype_this_package\nbeartype_this_package()\nbeartype_all(conf=BeartypeConf(violation_type=UserWarning))\n```\n\n----------------------------------------\n\nTITLE: Defining SentenceFragment Using Enumeration in Beartype Validators for Python\nDESCRIPTION: This snippet demonstrates an alternative syntax for combining validators using enumeration (commas) instead of the & operator, creating a type hint for non-empty strings without periods.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nSentenceFragment = Annotated[str,\n     Is[lambda text: bool(text)],\n    ~Is[lambda text: '.' in text],\n]\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Beartype's O(1) Type Checking with Complex Nested Lists\nDESCRIPTION: A bash script that uses Python's timeit module to benchmark the performance of Beartype when checking a triply-nested list of integers. The example demonstrates how Beartype achieves constant-time type checking even with deeply nested structures.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/faq.rst#2025-04-16_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ python3 -m timeit -n 1024 -r 4 -s '\nfrom beartype import beartype\n@beartype\ndef behold(the_great_destroyer_of_apps: list[list[list[int]]]) -> int:\n   return len(the_great_destroyer_of_apps)\n' 'behold([[[0]*1000]*1000]*1000)'\n\n1024 loops, best of 4: 13.8 usec per loop\n```\n\n----------------------------------------\n\nTITLE: Installing Beartype with pip\nDESCRIPTION: Command to install Beartype using pip package manager.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/install.rst#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip3 install beartype\n```\n\n----------------------------------------\n\nTITLE: Verifying Identity Decoration for Complex Ignorable Type Hint in Python\nDESCRIPTION: Shows how beartype reduces to an identity decorator even for functions with complex but ultimately ignorable type hints.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/code.rst#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from beartype import beartype\n>>> beartype(law_of_the_jungle_3) is law_of_the_jungle_3\nTrue\n```\n\n----------------------------------------\n\nTITLE: Interoperability of Beartype Validators with Union Types in Python\nDESCRIPTION: This example illustrates how Beartype validators can be used with standard type hints like Union, creating a type hint for sentence fragments in both Unicode and byte strings.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_vale.rst#2025-04-16_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nSentenceFragment = Union[\n    Annotated[bytes, Is[lambda text: b'.' in text]],\n    Annotated[str,   Is[lambda text: u'.' in text]],\n]\n```\n\n----------------------------------------\n\nTITLE: Implementing a Minimal Overhead Python Decorator\nDESCRIPTION: This code defines the fastest possible meaningful Python decorator, which simply wraps a function with a closure that passes through all arguments to the original function. This is used to establish a baseline for decorator overhead.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/math.rst#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef fastest_decorator(func):\n    def fastest_wrapper(*args, **kwargs): return func(*args, **kwargs)\n    return fastest_wrapper\n```\n\n----------------------------------------\n\nTITLE: Generated Type Checking Code for ArgumentParser\nDESCRIPTION: The wrapper function dynamically generated by beartype to perform runtime type checking for the ArgumentParser parameter.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/code.rst#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef law_of_the_jungle_5(\n    *args,\n    __beartype_func=__beartype_func,\n    __beartypistry=__beartypistry,\n    **kwargs\n):\n    __beartype_args_len = len(args)\n    __beartype_pith_0 = (\n        args[0] if __beartype_args_len > 0 else\n        kwargs.get('a_cub_may_be_bought_at_a_price', __beartypistry)\n    )\n\n    if __beartype_pith_0 is not __beartypistry:\n        if not isinstance(__beartype_pith_0, __beartypistry['argparse.ArgumentParser']):\n            __beartype_get_beartype_violation(\n                func=__beartype_func,\n                pith_name='a_cub_may_be_bought_at_a_price',\n                pith_value=__beartype_pith_0,\n            )\n\n    return __beartype_func(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Beartype Decorator with O(n) Strategy in Python\nDESCRIPTION: Shows how to create a custom @slowmobeartype decorator that enables O(n) type-checking strategy using BeartypeConf and BeartypeStrategy.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_decor.rst#2025-04-16_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype import beartype, BeartypeConf, BeartypeStrategy\n\n# Dynamically create a new @slowmobeartype decorator enabling \"full fat\"\n# O(n) type-checking.\nslowmobeartype = beartype(conf=BeartypeConf(strategy=BeartypeStrategy.On))\n\n# Type-check all items of the passed list. Do this only when you pretend\n# to know in your guts that this list will *ALWAYS* be ignorably small.\n@bslowmobeartype\ndef type_check_like_maple_syrup(liquid_gold: list[int]) -> str:\n    return 'The slowest noop yet envisioned? You're not wrong.'\n```\n\n----------------------------------------\n\nTITLE: Implementing Identity Decorator in Python\nDESCRIPTION: Demonstrates the concept of an identity decorator, which returns the decorated callable unmodified. This is the fastest possible decorator at both decoration and call time.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/code.rst#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\n\ndef identity_decorator(func: Callable): -> Callable:\n    return func\n```\n\n----------------------------------------\n\nTITLE: Implementing PEP Compliance in Beartype\nDESCRIPTION: Instructions for implementing support for new Python Enhancement Proposals (PEPs) in the beartype runtime type checker. This involves creating utility modules, data modules, and test modules in the appropriate package structure.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/code.rst#2025-04-16_snippet_18\n\nLANGUAGE: text\nCODE:\n```\n* Define a new utility submodule for this PEP residing under the\n  `\"beartype._util.hint.pep.proposal\" subpackage <beartype util pep_>`__\n  implementing general-purpose validators, testers, getters, and other\n  ancillary utility functions required to detect and handle *all* type hints\n  compliant with this PEP. For efficiency, utility functions performing\n  iteration or other expensive operations should be memoized via our internal\n  `@callable_cached`_ decorator.\n* Define a new data utility submodule for this PEP residing under the\n  `\"beartype._util.data.hint.pep.proposal\" subpackage <beartype util data\n  pep_>`__ adding various signs (i.e., arbitrary objects uniquely identifying\n  type hints compliant with this PEP) to various global variables defined by the\n  parent `\"beartype._util.data.hint.pep.utilhintdatapep\" submodule <_beartype\n  util data pep parent>`__.\n* Define a new test data submodule for this PEP residing under the\n  `\"beartype_test.unit.data.hint.pep.proposal\" subpackage <beartype test data\n  pep_>`__.\n```\n\n----------------------------------------\n\nTITLE: Testing API Compatibility with Different Function Versions\nDESCRIPTION: Example demonstrating how to use the is_func_api_preserved function to check backward compatibility between different versions of a function based on their type hints.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_door.rst#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from numbers import Real\n\n# New and successively older APIs of the same example function.\n>>> def new_func(text: str | None, ints: list[Real]) -> int: ...\n>>> def old_func(text: str, ints: list[int]) -> bool: ...\n>>> def older_func(text: str, ints: list) -> bool: ...\n\n# Does the newest version of that function preserve backward compatibility\n# with the next older version?\n>>> is_func_api_preserved(new_func, old_func)\nTrue  # <-- good. this is good.\n\n# Does the newest version of that function preserve backward compatibility\n# with the oldest version?\n>>> is_func_api_preserved(new_func, older_func)\nFalse  # <-- OH. MY. GODS.\n```\n\n----------------------------------------\n\nTITLE: Testing a Function with Optional Types\nDESCRIPTION: Example showing successful calls to the tell_the_deep_sea_viceroys function with both an Enum type and None as arguments. The function correctly returns the last enum member or None respectively.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/eli5.rst#2025-04-16_snippet_10\n\nLANGUAGE: pycon\nCODE:\n```\n>>> from enum import Enum\n>>> class Lukannon(Enum):\n...     WINTER_WHEAT = 'The Beaches of Lukannon—the winter wheat so tall—'\n...     SEA_FOG      = 'The dripping, crinkled lichens, and the sea-fog drenching all!'\n...     PLAYGROUND   = 'The platforms of our playground, all shining smooth and worn!'\n...     HOME         = 'The Beaches of Lukannon—the home where we were born!'\n...     MATES        = 'I met my mates in the morning, a broken, scattered band.'\n...     CLUB         = 'Men shoot us in the water and club us on the land;'\n...     DRIVE        = 'Men drive us to the Salt House like silly sheep and tame,'\n...     SEALERS      = 'And still we sing Lukannon—before the sealers came.'\n>>> tell_the_deep_sea_viceroys(Lukannon)\n<Lukannon.SEALERS: 'And still we sing Lukannon—before the sealers came.'>\n>>> tell_the_deep_sea_viceroys()\nNone\n```\n\n----------------------------------------\n\nTITLE: Adding Test Cases for PEP Compliance in Beartype\nDESCRIPTION: Instructions for adding test cases for new PEP-compliant type hints in Beartype. This requires adding a PepHintMetadata object to the appropriate test data submodule with valid and invalid examples for type checking.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/code.rst#2025-04-16_snippet_19\n\nLANGUAGE: text\nCODE:\n```\n* A new ``PepHintMetadata`` object in the existing tuple passed to the\n  ``data_module.HINTS_PEP_META.extend(...)`` call in the existing test data\n  submodule for this PEP residing under the\n  `\"beartype_test.unit.data.hint.pep.proposal\" subpackage <beartype test data\n  pep_>`__. For example, if this is a :pep:`484`\\ -compliant type hint, add that\n  hint and associated metadata to the\n  `\"beartype_test.unit.data.hint.pep.proposal.data_hintpep484\" submodule\n  <beartype test data pep 484_>`__.\n```\n\n----------------------------------------\n\nTITLE: Implementing Class Factory with Beartype in Python\nDESCRIPTION: Example showing how to use the @beartype decorator on a class, demonstrating potential issues with type annotations for a class factory method that returns instances of its own class.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/faq.rst#2025-04-16_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom beartype import beartype\n\n@beartype\nclass TerribadClassFactory(object):\n   def __init__(self, *args: Sequence) -> None:\n       self._args = args\n\n   def make_class(self, other: TerribadClassFactory) -> (  # <-- NO, NO, GODS, NO\n       TerribadClassFactory):  # <------------------------------ PLEASE, GODS, NO\n       return TerribadClassFactory(self._args + other._args)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Performance Issues with Typeguard\nDESCRIPTION: This benchmark illustrates the performance impact of typeguard's exhaustive type checking approach. When checking a large nested list structure, typeguard examines every nested element, resulting in extremely long execution times (over 1.7 hours for a single check).\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/faq.rst#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ python3 -m timeit -n 1 -r 1 -s '\nfrom typeguard import typechecked\n@typechecked\ndef behold(the_great_destroyer_of_apps: list[list[list[int]]]) -> int:\n    return len(the_great_destroyer_of_apps)\n' 'behold([[[0]*1000]*1000]*1000)'\n\n1 loop, best of 1: 6.42e+03 sec per loop\n```\n\n----------------------------------------\n\nTITLE: Beartype as Function Example\nDESCRIPTION: Demonstrates using beartype as a function call for monkey-patching existing functions with runtime type-checking capabilities.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_decor.rst#2025-04-16_snippet_2\n\nLANGUAGE: pycon\nCODE:\n```\n# Import the requisite machinery.\n>>> from beartype import beartype\n\n# A function somebody else defined. Note the bad lack of @beartype.\n>>> def oh_bother_free_where_art_thou(botherfull_string: str) -> str:\n...     return f'Oh, oh! Help and bother! {botherfull_string}'\n\n# Monkey-patch that function with runtime type-checking. *MUHAHAHA.*\n>>> oh_bother_free_where_art_thou = beartype(oh_bother_free_where_art_thou)\n\n# Call that function with runtime type-checking enabled.\n>>> oh_bother_free_where_art_thou(b\"I'm stuck!\")\nBeartypeCallHintParamViolation: @beartyped oh_bother_free_where_art_thou()\nparameter botherfull_string=b\"I'm stuck!\" violates type hint <class 'str'>,\nas bytes b\"I'm stuck!\" not instance of str.\n```\n\n----------------------------------------\n\nTITLE: Generated Type Checking Code for List[object]\nDESCRIPTION: The wrapper function dynamically generated by beartype to perform runtime type checking for list[object] parameter.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/code.rst#2025-04-16_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef law_of_the_jungle_6(\n    *args,\n    __beartype_func=__beartype_func,\n    __beartypistry=__beartypistry,\n    **kwargs\n):\n    __beartype_args_len = len(args)\n    __beartype_pith_0 = (\n        args[0] if __beartype_args_len > 0 else\n        kwargs.get('all_the_jungle_is_thine', __beartypistry)\n    )\n\n    if __beartype_pith_0 is not __beartypistry:\n        if not isinstance(__beartype_pith_0, list):\n            __beartype_get_beartype_violation(\n                func=__beartype_func,\n                pith_name='all_the_jungle_is_thine',\n                pith_value=__beartype_pith_0,\n            )\n\n    return __beartype_func(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Typing Support Matrix (RST Table)\nDESCRIPTION: ReStructuredText formatted table documenting Beartype's support for Python typing features, showing version compatibility for each typing construct.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/pep.rst#2025-04-16_snippet_2\n\nLANGUAGE: restructuredtext\nCODE:\n```\n|                        | :obj:`~typing.Final`                                      | **0.13.0**\\ —\\ *current* | *none*                    |\n+------------------------+-----------------------------------------------------------+--------------------------+---------------------------+\n|                        | :obj:`~typing.ForwardRef`                                 | —                        | **0.16.0**\\ —\\ *current*  |\n+------------------------+-----------------------------------------------------------+--------------------------+---------------------------+\n|                        | :obj:`~typing.FrozenSet`                                  | —                        | **0.19.0**\\ —\\ *current*  |\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Beartype Decorator with Disabled Colors in Python\nDESCRIPTION: Demonstrates how to create a custom @monobeartype decorator that disables color output in type-checking violations using BeartypeConf.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_decor.rst#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype import beartype, BeartypeConf\n\n# Dynamically create a new @monobeartype decorator disabling colour.\nmonobeartype = beartype(conf=BeartypeConf(is_color=False))\n\n# Decorate with this decorator rather than @beartype everywhere.\n@monobeartype\ndef muh_colorless_func() -> str:\n    return b'In the kingdom of the blind, you are now king.'\n```\n\n----------------------------------------\n\nTITLE: Creating and Accessing BeartypeConf Instance Properties in Python\nDESCRIPTION: Demonstrates how to create a BeartypeConf instance and access its read-only properties. The properties maintain the same values as provided during initialization.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_decor.rst#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> BeartypeConf().is_color\nNone\n>>> BeartypeConf().strategy\n<BeartypeStrategy.O1: 2>\n```\n\n----------------------------------------\n\nTITLE: Type Support Version Table in RST\nDESCRIPTION: A ReStructuredText formatted table documenting supported Python typing features with their corresponding version ranges for both static and runtime type checking.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/pep.rst#2025-04-16_snippet_3\n\nLANGUAGE: rst\nCODE:\n```\n|                        | :obj:`~typing.Sequence`                                   | —                        | **0.3.0**\\ —\\ *current*   |\n+------------------------+-----------------------------------------------------------+--------------------------+---------------------------+\n|                        | :obj:`~typing.Set`                                        | —                        | **0.190**\\ —\\ *current*   |\n+------------------------+-----------------------------------------------------------+--------------------------+---------------------------+\n|                        | :obj:`~typing.Sized`                                      | —                        | **0.2.0**\\ —\\ *current*   |\n+------------------------+-----------------------------------------------------------+--------------------------+---------------------------+\n|                        | :obj:`~typing.SupportsAbs`                                | —                        | **0.4.0**\\ —\\ *current*   |\n```\n\n----------------------------------------\n\nTITLE: Selectively Disabling Type-Checking for Methods in Python\nDESCRIPTION: Demonstrates how to use the BeartypeStrategy.O0 strategy to selectively disable type-checking for specific methods within a class decorated with @beartype.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_decor.rst#2025-04-16_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# Import the requisite machinery.\nfrom beartype import beartype, BeartypeConf, BeartypeStrategy\n\n# Dynamically create a new @nobeartype decorator disabling type-checking.\nnobeartype = beartype(conf=BeartypeConf(strategy=BeartypeStrategy.O0))\n\n# Automatically decorate all methods of this class...\n@beartype\nclass TypeCheckedClass(object):\n    # Including this method, which raises a type-checking violation\n    # due to returning a non-\"None\" value.\n    def type_checked_method(self) -> None:\n        return 'This string is not \"None\". Apparently, that is a problem.'\n\n    # Excluding this method, which raises *NO* type-checking\n    # violation despite returning a non-\"None\" value.\n    @nobeartype\n    def non_type_checked_method(self) -> None:\n        return 'This string is not \"None\". Thankfully, no one cares.'\n```\n\n----------------------------------------\n\nTITLE: Installing Beartype via pip\nDESCRIPTION: Command-line instructions for installing Beartype using pip and opening your package's __init__.py file for editing.\nSOURCE: https://github.com/beartype/beartype/blob/main/README.rst#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Install beartype.\n$ pip3 install beartype\n# Edit the \"{your_package}.__init__\" submodule with your favourite IDE.\n$ vim {your_package}/__init__.py      # <-- so, i see that you too vim\n```\n\n----------------------------------------\n\nTITLE: Installing Beartype with Homebrew on macOS\nDESCRIPTION: Command to install Beartype using Homebrew package manager on macOS.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/install.rst#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbrew install beartype/beartype/beartype\n```\n\n----------------------------------------\n\nTITLE: Running the Beartype Performance Benchmark Script\nDESCRIPTION: This bash script runs a comprehensive performance benchmark comparing beartype against typeguard and undecorated functions across various type checking scenarios. The benchmark measures both decoration time and execution time.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/math.rst#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ bin/profile.bash\n\nbeartype profiler [version]: 0.0.2\n\npython    [basename]: python3.9\npython    [version]: Python 3.9.0\nbeartype  [version]: 0.6.0\ntypeguard [version]: 2.9.1\n\n===================================== str =====================================\nprofiling regime:\n   number of meta-loops:      3\n   number of loops:           100\n   number of calls each loop: 100\ndecoration         [none     ]: 100 loops, best of 3: 359 nsec per loop\ndecoration         [beartype ]: 100 loops, best of 3: 389 usec per loop\ndecoration         [typeguard]: 100 loops, best of 3: 13.5 usec per loop\ndecoration + calls [none     ]: 100 loops, best of 3: 14.8 usec per loop\ndecoration + calls [beartype ]: 100 loops, best of 3: 514 usec per loop\ndecoration + calls [typeguard]: 100 loops, best of 3: 6.34 msec per loop\n\n=============================== Union[int, str] ===============================\nprofiling regime:\n   number of meta-loops:      3\n   number of loops:           100\n   number of calls each loop: 100\ndecoration         [none     ]: 100 loops, best of 3: 1.83 usec per loop\ndecoration         [beartype ]: 100 loops, best of 3: 433 usec per loop\ndecoration         [typeguard]: 100 loops, best of 3: 15.6 usec per loop\ndecoration + calls [none     ]: 100 loops, best of 3: 17.7 usec per loop\ndecoration + calls [beartype ]: 100 loops, best of 3: 572 usec per loop\ndecoration + calls [typeguard]: 100 loops, best of 3: 10 msec per loop\n\n=========================== List[int] of 1000 items ===========================\nprofiling regime:\n   number of meta-loops:      1\n   number of loops:           1\n   number of calls each loop: 7485\ndecoration         [none     ]: 1 loop, best of 1: 10.1 usec per loop\ndecoration         [beartype ]: 1 loop, best of 1: 1.3 msec per loop\ndecoration         [typeguard]: 1 loop, best of 1: 41.1 usec per loop\ndecoration + calls [none     ]: 1 loop, best of 1: 1.24 msec per loop\ndecoration + calls [beartype ]: 1 loop, best of 1: 18.3 msec per loop\ndecoration + calls [typeguard]: 1 loop, best of 1: 104 sec per loop\n\n============ List[Sequence[MutableSequence[int]]] of 10 items each ============\nprofiling regime:\n   number of meta-loops:      1\n   number of loops:           1\n   number of calls each loop: 7485\ndecoration         [none     ]: 1 loop, best of 1: 11.8 usec per loop\ndecoration         [beartype ]: 1 loop, best of 1: 1.77 msec per loop\ndecoration         [typeguard]: 1 loop, best of 1: 48.9 usec per loop\ndecoration + calls [none     ]: 1 loop, best of 1: 1.19 msec per loop\ndecoration + calls [beartype ]: 1 loop, best of 1: 81.2 msec per loop\ndecoration + calls [typeguard]: 1 loop, best of 1: 17.3 sec per loop\n```\n\n----------------------------------------\n\nTITLE: PEP 585 Deprecation Warning Example\nDESCRIPTION: Example of a PEP 585 deprecation warning message shown by Beartype when using deprecated typing syntax.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api_roar.rst#2025-04-16_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n/home/kumamon/beartype/_util/hint/pep/utilpeptest.py:377: BeartypeDecorHintPep585DeprecationWarning: PEP 484 type hint typing.List[int] deprecated by PEP 585 scheduled for removal in the first Python version released after October 5th, 2025. To resolve this, import this hint from \"beartype.typing\" rather than \"typing\".\n```\n\n----------------------------------------\n\nTITLE: Installing Beartype with Anaconda\nDESCRIPTION: Commands to install Beartype using Anaconda package manager, including adding the conda-forge channel.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/install.rst#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nconda config --add channels conda-forge\nconda install beartype\n```\n\n----------------------------------------\n\nTITLE: Type Compatibility Table in RST Format\nDESCRIPTION: A RestructuredText formatted table showing module compatibility with version ranges for Beartype library support. Includes built-in Python typing modules and third-party libraries.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/pep.rst#2025-04-16_snippet_1\n\nLANGUAGE: restructuredtext\nCODE:\n```\n   | nuitka_                | *all*                                                     | —                        | **0.12.0**\\ —\\ *current*  |\n   +------------------------+-----------------------------------------------------------+--------------------------+---------------------------+\n   | numba_                 | `@njit <numba.njit_>`__                                   | —                        | **0.19.0**\\ —\\ *current*  |\n   +------------------------+-----------------------------------------------------------+--------------------------+---------------------------+\n```\n\n----------------------------------------\n\nTITLE: Mocking Types with Beartype\nDESCRIPTION: This snippet demonstrates how to create a mock type that can fool Beartype's type-checking by defining a custom __class__ property. This allows instances of the mock type to be treated as instances of the original type.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/faq.rst#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> class OriginalType: pass\n>>> class MockType:\n...     @property\n...     def __class__(self) -> type: return OriginalType\n...     @__class__.setter\n...     def __class__(self, value: type) -> None:\n...         super.__class__ = value\n\n>>> from beartype import beartype\n>>> @beartype\n... def muh_func(muh_arg: OriginalType): print('Yolo, bro.')\n>>> muh_func(MockType())\nYolo, bro.\n```\n\n----------------------------------------\n\nTITLE: Installing Beartype with MacPorts on macOS\nDESCRIPTION: Command to install Beartype using MacPorts package manager on macOS.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/install.rst#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo port install py-beartype\n```\n\n----------------------------------------\n\nTITLE: Using Postponed Annotations for Self-reference (Anti-pattern) in Python\nDESCRIPTION: Demonstrates a strongly discouraged approach using postponed annotations with __future__ import, which causes inefficiency and fragility in the type checking system.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/faq.rst#2025-04-16_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# Breaking the Python interpreter: feels bad, because it is bad.\n# *PLEASE DON'T DO THIS ANYWHERE.* Do you want @beartype to be a shambling wreck?\nfrom __future__ import annotations\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Decorator Performance in Python\nDESCRIPTION: This code snippet demonstrates a performance comparison between a decorated function using the fastest possible decorator and an undecorated function. It uses the timeit module to measure execution time over 100,000 iterations.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/math.rst#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ python3.7 <<EOF\nfrom timeit import timeit\ndef fastest_decorator(func):\n    def fastest_wrapper(*args, **kwargs): return func(*args, **kwargs)\n    return fastest_wrapper\n\n@fastest_decorator\ndef main_decorated(arg01: str=\"__undefined__\", arg02: int=0) -> tuple:\n    \"\"\"Proof of concept code implenting bear-typed args\"\"\"\n    assert isinstance(arg01, str)\n    assert isinstance(arg02, int)\n\n    str_len = len(arg01) + arg02\n    assert isinstance(str_len, int)\n    return (\"bear_bar\", str_len,)\n\ndef main_undecorated(arg01=\"__undefined__\", arg02=0):\n    \"\"\"Proof of concept code implenting duck-typed args\"\"\"\n    assert isinstance(arg01, str)\n    assert isinstance(arg02, int)\n\n    str_len = len(arg01) + arg02\n    assert isinstance(str_len, int)\n    return (\"duck_bar\", str_len,)\n\nif __name__==\"__main__\":\n    num_loops = 100000\n\n    decorated_result = timeit('main_decorated(\"foo\", 1)', setup=\"from __main__ import main_decorated\", number=num_loops)\n    print(\"timeit decorated time:  \", round(decorated_result, 4), \"seconds\")\n\n    undecorated_result = timeit('main_undecorated(\"foo\", 1)', setup=\"from __main__ import main_undecorated\", number=num_loops)\n    print(\"timeit undecorated time:\", round(undecorated_result, 4), \"seconds\")\nEOF\ntimeit decorated time:   0.1185 seconds\ntimeit undecorated time: 0.0889 seconds\n```\n\n----------------------------------------\n\nTITLE: Validating PyPI Documentation Compatibility\nDESCRIPTION: Runs checkdocs to verify README.rst compatibility with PyPI's renderer.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/RELEASE.rst#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ python3 setup.py checkdocs\n```\n\n----------------------------------------\n\nTITLE: Starting Python Interactive Shell\nDESCRIPTION: Command to launch Python interactive shell for Beartype examples.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/index.rst#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# So let's do this.\n$ python3\n```\n\n----------------------------------------\n\nTITLE: Beartype Development Workflow with Git\nDESCRIPTION: This bash commands sequence demonstrates the recommended git workflow for contributing to the beartype project. It includes forking the repository, cloning locally, setting up development environment, making changes, and creating pull requests.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/code.rst#2025-04-16_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\ngit clone {URL}\ngit remote add upstream https://github.com/beartype/beartype.git\npip uninstall beartype\npip3 install -e .[dev]\ngit checkout -b {branch_name}\n./tox\ngit add -a\ngit commit\ngit push\ngit checkout main && git pull upstream main\n```\n\n----------------------------------------\n\nTITLE: Installing Hatch Build Tool\nDESCRIPTION: Installs Hatch package manager for building source distributions and wheels.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/RELEASE.rst#2025-04-16_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ sudo pip3 install hatch\n```\n\n----------------------------------------\n\nTITLE: Adding Beartype Badge in reStructuredText\nDESCRIPTION: reStructuredText code to add a Beartype badge to project documentation.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/install.rst#2025-04-16_snippet_7\n\nLANGUAGE: rst\nCODE:\n```\nYummySoft is now |bear-ified|!\n\n.. |bear-ified| image:: https://raw.githubusercontent.com/beartype/beartype-assets/main/badge/bear-ified.svg\n   :align: top\n   :target: https://beartype.readthedocs.io\n   :alt: bear-ified\n```\n\n----------------------------------------\n\nTITLE: Testing Wheel Installation\nDESCRIPTION: Creates virtual environment and installs wheel distribution for testing.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/RELEASE.rst#2025-04-16_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n$ python3 -m venv --clear /tmp/beartype-wheel\n$ /tmp/beartype-wheel/bin/pip3 install dist/beartype-${version}-py3-none-any.whl\n$ cd /tmp && /tmp/beartype-wheel/bin/beartype try\n$ rm -rf /tmp/beartype-wheel /tmp/sample_sim && cd -\n```\n\n----------------------------------------\n\nTITLE: Installing Documentation Validator for PyPI\nDESCRIPTION: Installs the collective.checkdocs package to validate README.rst compatibility with PyPI's reStructuredText renderer.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/RELEASE.rst#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ sudo pip3 install collective.checkdocs\n```\n\n----------------------------------------\n\nTITLE: Listing Git Tags\nDESCRIPTION: Displays existing Git tags before creating new release tag.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/RELEASE.rst#2025-04-16_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n$ git tag\n```\n\n----------------------------------------\n\nTITLE: Inspecting Source Distribution Contents\nDESCRIPTION: Lists contents of the source tarball to verify packaging.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/RELEASE.rst#2025-04-16_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ tar -tvzf dist/beartype-${version}.tar.gz | less\n```\n\n----------------------------------------\n\nTITLE: Defining External References in RST Format\nDESCRIPTION: A structured collection of external URL references in reStructuredText format, organized into sections for Beartype, Python, conda, packaging, and service links.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/RELEASE.rst#2025-04-16_snippet_9\n\nLANGUAGE: rst\nCODE:\n```\n.. # ------------------( LINKS ~ beartype                    )------------------\n.. _readme:\n   https://github.com/beartype/beartype/blob/main/README.rst\n.. _tarballs:\n   https://github.com/beartype/beartype/releases\n.. _PyPI beartype:\n   https://pypi.org/project/beartype\n\n.. # ------------------( LINKS ~ beartype : conda            )------------------\n.. _Anaconda package:\n   https://anaconda.org/conda-forge/beartype\n.. _conda recipe:\n   https://github.com/leycec/beartype-feedstock/blob/master/recipe/meta.yaml\n.. _conda-forge feedstock:\n.. _feedstock repository:\n   https://github.com/leycec/beartype-feedstock\n\n.. # ------------------( LINKS ~ py                          )------------------\n.. _Semantic Versioning:\n   http://semver.org\n.. _twine:\n   https://pypi.python.org/pypi/twine\n.. _wheel:\n   https://wheel.readthedocs.io\n\n.. # ------------------( LINKS ~ py : conda                  )------------------\n.. _conda-forge:\n   https://conda-forge.org\n.. _conda-forge FAQ:\n   https://conda-forge.org/docs/conda-forge_gotchas.html\n.. _conda-forge update recipe:\n   https://conda-forge.org/docs/conda-forge_gotchas.html#using-a-fork-vs-a-branch-when-updating-a-recipe\n\n.. # ------------------( LINKS ~ py : package                )------------------\n.. _BETSE:\n   https://github.com/betsee/betse\n.. _BETSEE:\n   https://github.com/betsee/betsee\n.. _Hatch:\n   https://hatch.pypa.io\n\n.. # ------------------( LINKS ~ py : pypi                   )------------------\n.. _Test PyPI:\n   https://testpypi.python.org/pypi\n.. _Test PyPI instructions:\n   https://wiki.python.org/moin/TestPyPI\n.. _Test PyPI user:\n   https://testpypi.python.org/pypi?%3Aaction=register_form\n.. _PyPI:\n   https://pypi.python.org/pypi\n.. _PyPI user:\n   https://pypi.python.org/pypi?%3Aaction=register_form\n\n.. # ------------------( LINKS ~ service                     )------------------\n.. _GitHub:\n   https://github.com\n```\n\n----------------------------------------\n\nTITLE: Testing Source Distribution Installation\nDESCRIPTION: Creates virtual environment and installs source distribution for testing.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/RELEASE.rst#2025-04-16_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ python3 -m venv --clear /tmp/beartype-sdist\n$ /tmp/beartype-sdist/bin/pip3 install wheel\n$ /tmp/beartype-sdist/bin/pip3 install dist/beartype-${version}.tar.gz\n$ cd /tmp && /tmp/beartype-sdist/bin/beartype try\n$ rm -rf /tmp/beartype-sdist && cd -\n```\n\n----------------------------------------\n\nTITLE: Defining ReStructuredText Hyperlinks for Python Standard Library Modules\nDESCRIPTION: This snippet defines hyperlinks in reStructuredText format for various Python standard library modules and their components. It includes links for collections, collections.abc, contextlib, dataclasses, enum, io, os, random, re, and typing modules.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/_links.rst#2025-04-16_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _collections:\n   https://docs.python.org/3/library/collections.html\n.. _collections.ChainMap:\n   https://docs.python.org/3/library/collections.html#collections.ChainMap\n.. _collections.Counter:\n   https://docs.python.org/3/library/collections.html#collections.Counter\n.. _collections.OrderedDict:\n   https://docs.python.org/3/library/collections.html#collections.OrderedDict\n.. _collections.defaultdict:\n   https://docs.python.org/3/library/collections.html#collections.defaultdict\n.. _collections.deque:\n   https://docs.python.org/3/library/collections.html#collections.deque\n\n.. _collections.abc:\n   https://docs.python.org/3/library/collections.abc.html\n.. _collections.abc.AsyncGenerator:\n   https://docs.python.org/3/library/collections.abc.html#collections.abc.AsyncGenerator\n.. _collections.abc.AsyncIterable:\n   https://docs.python.org/3/library/collections.abc.html#collections.abc.AsyncIterable\n.. _collections.abc.AsyncIterator:\n   https://docs.python.org/3/library/collections.abc.html#collections.abc.AsyncIterator\n.. _collections.abc.Awaitable:\n   https://docs.python.org/3/library/collections.abc.html#collections.abc.Awaitable\n.. _collections.abc.ByteString:\n   https://docs.python.org/3/library/collections.abc.html#collections.abc.ByteString\n.. _collections.abc.Callable:\n   https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable\n.. _collections.abc.Collection:\n   https://docs.python.org/3/library/collections.abc.html#collections.abc.Collection\n.. _collections.abc.Container:\n   https://docs.python.org/3/library/collections.abc.html#collections.abc.Container\n.. _collections.abc.Coroutine:\n   https://docs.python.org/3/library/collections.abc.html#collections.abc.Coroutine\n.. _collections.abc.Generator:\n   https://docs.python.org/3/library/collections.abc.html#collections.abc.Generator\n.. _collections.abc.ItemsView:\n   https://docs.python.org/3/library/collections.abc.html#collections.abc.ItemsView\n.. _collections.abc.Iterable:\n   https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable\n.. _collections.abc.Iterator:\n   https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterator\n.. _collections.abc.KeysView:\n   https://docs.python.org/3/library/collections.abc.html#collections.abc.KeysView\n.. _collections.abc.Mapping:\n   https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping\n.. _collections.abc.MappingView:\n   https://docs.python.org/3/library/collections.abc.html#collections.abc.MappingView\n.. _collections.abc.MutableMapping:\n   https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableMapping\n.. _collections.abc.MutableSequence:\n   https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSequence\n.. _collections.abc.MutableSet:\n   https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSet\n.. _collections.abc.Reversible:\n   https://docs.python.org/3/library/collections.abc.html#collections.abc.Reversible\n.. _collections.abc.Sequence:\n   https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence\n.. _collections.abc.Set:\n   https://docs.python.org/3/library/collections.abc.html#collections.abc.Set\n.. _collections.abc.ValuesView:\n   https://docs.python.org/3/library/collections.abc.html#collections.abc.ValuesView\n\n.. _contextlib:\n   https://docs.python.org/3/library/contextlib.html\n.. _contextlib.AbstractAsyncContextManager:\n   https://docs.python.org/3/library/contextlib.html#contextlib.AbstractAsyncContextManager\n.. _contextlib.AbstractContextManager:\n   https://docs.python.org/3/library/contextlib.html#contextlib.AbstractContextManager\n\n.. _dataclasses:\n   https://docs.python.org/3/library/dataclasses.html\n.. _dataclasses.InitVar:\n   https://docs.python.org/3/library/dataclasses.html#init-only-variables\n.. _dataclasses.dataclass:\n   https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass\n\n.. _enum.Enum:\n   https://docs.python.org/3/library/enum.html#enum.Enum\n\n.. _io:\n   https://docs.python.org/3/library/io.html\n\n.. _os:\n   https://docs.python.org/3/library/os.html\n.. _os.walk:\n   https://docs.python.org/3/library/os.html#os.walk\n\n.. _random:\n   https://docs.python.org/3/library/random.html\n.. _random.getrandbits:\n   https://docs.python.org/3/library/random.html#random.getrandbits\n.. _random twister:\n   https://stackoverflow.com/a/11704178/2809027\n\n.. _re:\n   https://docs.python.org/3/library/re.html\n.. _re.Match:\n   https://docs.python.org/3/library/re.html#match-objects\n.. _re.Pattern:\n   https://docs.python.org/3/library/re.html#regular-expression-objects\n\n.. _typing:\n   https://docs.python.org/3/library/typing.html\n.. _typing.AbstractSet:\n   https://docs.python.org/3/library/typing.html#typing.AbstractSet\n.. _typing.Annotated:\n   https://docs.python.org/3/library/typing.html#typing.Annotated\n.. _typing.Any:\n   https://docs.python.org/3/library/typing.html#typing.Any\n.. _typing.AnyStr:\n   https://docs.python.org/3/library/typing.html#typing.AnyStr\n.. _typing.AsyncContextManager:\n   https://docs.python.org/3/library/typing.html#typing.AsyncContextManager\n.. _typing.AsyncGenerator:\n   https://docs.python.org/3/library/typing.html#typing.AsyncGenerator\n.. _typing.AsyncIterable:\n   https://docs.python.org/3/library/typing.html#typing.AsyncIterable\n.. _typing.AsyncIterator:\n   https://docs.python.org/3/library/typing.html#typing.AsyncIterator\n.. _typing.Awaitable:\n   https://docs.python.org/3/library/typing.html#typing.Awaitable\n.. _typing.BinaryIO:\n   https://docs.python.org/3/library/typing.html#typing.BinaryIO\n.. _typing.ByteString:\n   https://docs.python.org/3/library/typing.html#typing.ByteString\n.. _typing.Callable:\n   https://docs.python.org/3/library/typing.html#typing.Callable\n.. _typing.ChainMap:\n   https://docs.python.org/3/library/typing.html#typing.ChainMap\n.. _typing.ClassVar:\n   https://docs.python.org/3/library/typing.html#typing.ClassVar\n.. _typing.Collection:\n   https://docs.python.org/3/library/typing.html#typing.Collection\n.. _typing.Concatenate:\n   https://docs.python.org/3/library/typing.html#typing.Concatenate\n.. _typing.Container:\n   https://docs.python.org/3/library/typing.html#typing.Container\n.. _typing.ContextManager:\n   https://docs.python.org/3/library/typing.html#typing.ContextManager\n.. _typing.Coroutine:\n   https://docs.python.org/3/library/typing.html#typing.Coroutine\n.. _typing.Counter:\n   https://docs.python.org/3/library/typing.html#typing.Counter\n.. _typing.DefaultDict:\n   https://docs.python.org/3/library/typing.html#typing.DefaultDict\n.. _typing.Deque:\n   https://docs.python.org/3/library/typing.html#typing.Deque\n.. _typing.Dict:\n   https://docs.python.org/3/library/typing.html#typing.Dict\n.. _typing.Final:\n   https://docs.python.org/3/library/typing.html#typing.Final\n.. _typing.ForwardRef:\n   https://docs.python.org/3/library/typing.html#typing.ForwardRef\n.. _typing.FrozenSet:\n   https://docs.python.org/3/library/typing.html#typing.FrozenSet\n.. _typing.Generator:\n   https://docs.python.org/3/library/typing.html#typing.Generator\n.. _typing.Generic:\n   https://docs.python.org/3/library/typing.html#typing.Generic\n.. _typing.Hashable:\n   https://docs.python.org/3/library/typing.html#typing.Hashable\n.. _typing.IO:\n   https://docs.python.org/3/library/typing.html#typing.IO\n.. _typing.ItemsView:\n   https://docs.python.org/3/library/typing.html#typing.ItemsView\n.. _typing.Iterable:\n   https://docs.python.org/3/library/typing.html#typing.Iterable\n.. _typing.Iterator:\n   https://docs.python.org/3/library/typing.html#typing.Iterator\n.. _typing.KeysView:\n   https://docs.python.org/3/library/typing.html#typing.KeysView\n.. _typing.List:\n   https://docs.python.org/3/library/typing.html#typing.List\n.. _typing.Literal:\n   https://docs.python.org/3/library/typing.html#typing.Literal\n.. _typing.Mapping:\n   https://docs.python.org/3/library/typing.html#typing.Mapping\n.. _typing.MappingView:\n   https://docs.python.org/3/library/typing.html#typing.MappinViewg\n.. _typing.Match:\n   https://docs.python.org/3/library/typing.html#typing.Match\n.. _typing.MutableMapping:\n   https://docs.python.org/3/library/typing.html#typing.MutableMapping\n.. _typing.MutableSequence:\n   https://docs.python.org/3/library/typing.html#typing.MutableSequence\n.. _typing.MutableSet:\n   https://docs.python.org/3/library/typing.html#typing.MutableSet\n.. _typing.NamedTuple:\n   https://docs.python.org/3/library/typing.html#typing.NamedTuple\n.. _typing.NewType:\n   https://docs.python.org/3/library/typing.html#typing.NewType\n.. _typing.NoReturn:\n   https://docs.python.org/3/library/typing.html#typing.NoReturn\n.. _typing.Optional:\n   https://docs.python.org/3/library/typing.html#typing.Optional\n.. _typing.OrderedDict:\n   https://docs.python.org/3/library/typing.html#typing.OrderedDict\n.. _typing.ParamSpec:\n   https://docs.python.org/3/library/typing.html#typing.ParamSpec\n.. _typing.ParamSpecArgs:\n   https://docs.python.org/3/library/typing.html#typing.ParamSpecArgs\n.. _typing.ParamSpecKwargs:\n   https://docs.python.org/3/library/typing.html#typing.ParamSpecKwargs\n.. _typing.Pattern:\n   https://docs.python.org/3/library/typing.html#typing.Pattern\n```\n\n----------------------------------------\n\nTITLE: Adding Sphinx search and index pages\nDESCRIPTION: This snippet defines the standard Sphinx documentation indices and search functionality references that will be included in the documentation.\nSOURCE: https://github.com/beartype/beartype/blob/main/beartype_test/a90_func/data/lib/sphinx/index.rst#2025-04-16_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n* :ref:`genindex`\n* :ref:`modindex`\n* :ref:`search`\n```\n\n----------------------------------------\n\nTITLE: Installing Beartype on Arch Linux\nDESCRIPTION: Commands to install Beartype on Arch Linux using the Arch User Repository (AUR).\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/install.rst#2025-04-16_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://aur.archlinux.org/python-beartype.git\ncd python-beartype\nmakepkg -si\n```\n\n----------------------------------------\n\nTITLE: Setting up Sphinx documentation structure for beartype_sphinx module\nDESCRIPTION: This is a reStructuredText (rst) file that defines the structure of Sphinx documentation for the beartype_sphinx module. It includes the table of contents tree directive and automodule directive to generate documentation from the module docstrings.\nSOURCE: https://github.com/beartype/beartype/blob/main/beartype_test/a90_func/data/lib/sphinx/index.rst#2025-04-16_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n\n.. automodule:: beartype_sphinx\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Creating a Local Table of Contents in reStructuredText\nDESCRIPTION: This snippet creates a local table of contents using the 'contents' directive in reStructuredText. It sets the title of the table to 'Bear with Us' and uses the 'local' option to limit the scope to the current document.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api.rst#2025-04-16_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. contents:: **Bear with Us**\n   :local:\n```\n\n----------------------------------------\n\nTITLE: Installing Beartype on Gentoo Linux\nDESCRIPTION: Command to install Beartype on Gentoo Linux using the emerge package manager.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/install.rst#2025-04-16_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nemerge beartype\n```\n\n----------------------------------------\n\nTITLE: Defining Local Table of Contents in ReStructuredText\nDESCRIPTION: This snippet creates a local table of contents for the current document using the ReStructuredText 'contents' directive.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/index.rst#2025-04-16_snippet_7\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. contents:: **Bear with Us**\n   :local:\n```\n\n----------------------------------------\n\nTITLE: Creating Release Announcement Commit\nDESCRIPTION: Creates empty commit with release announcement and changelog.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/RELEASE.rst#2025-04-16_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n$ git commit --allow-empty\n```\n\n----------------------------------------\n\nTITLE: Building Source and Wheel Distributions\nDESCRIPTION: Creates both source tarball and wheel distributions using Hatch.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/RELEASE.rst#2025-04-16_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ hatch build -t sdist -t wheel\n```\n\n----------------------------------------\n\nTITLE: Adding Beartype Badge in Markdown\nDESCRIPTION: Markdown code to add a Beartype badge to project documentation.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/install.rst#2025-04-16_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\nYummySoft is now [![bear-ified](https://raw.githubusercontent.com/beartype/beartype-assets/main/badge/bear-ified.svg)](https://beartype.readthedocs.io)!\n```\n\n----------------------------------------\n\nTITLE: Adding Beartype Badge in HTML\nDESCRIPTION: HTML code to add a Beartype badge to project documentation.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/install.rst#2025-04-16_snippet_8\n\nLANGUAGE: html\nCODE:\n```\nYummySoft is now <a href=\"https://beartype.readthedocs.io\"><img\n  src=\"https://raw.githubusercontent.com/beartype/beartype-assets/main/badge/bear-ified.svg\"\n  alt=\"bear-ified\"\n  style=\"vertical-align: middle;\"></a>!\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents in reStructuredText for Beartype API\nDESCRIPTION: This snippet defines a hidden table of contents using the 'toctree' directive in reStructuredText. It lists various sections of the Beartype API documentation, including import hooks, decorators, validators, introspectors, and errors.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/api.rst#2025-04-16_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n   :hidden:\n   :caption: Bear with Us\n\n   Beartype Import Hooks <api_claw>\n   Beartype Decorator <api_decor>\n   Beartype Validators <api_vale>\n   Beartype Introspectors <api_door>\n   Beartype Errors <api_roar>\n```\n\n----------------------------------------\n\nTITLE: Defining ReStructuredText Table of Contents for Beartype Documentation\nDESCRIPTION: This snippet defines the table of contents for the Beartype documentation using ReStructuredText directives. It includes various sections such as installation, API, FAQ, and more.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/index.rst#2025-04-16_snippet_6\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. toctree::\n   :caption: Bear with Us\n\n   Bearpedia <self>\n   Install <install>\n   tl;dr <tldr>\n   ELI5 <eli5>\n   API <api>\n   FAQ <faq>\n   BigData™ <pep>\n   Code <code>\n   Math <math>\n   Moar <moar>\n```\n\n----------------------------------------\n\nTITLE: RestructuredText Link References\nDESCRIPTION: A collection of link references for Python-related resources organized in categorized sections using RestructuredText format.\nSOURCE: https://github.com/beartype/beartype/blob/main/README.rst#2025-04-16_snippet_7\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. _-O:\n   https://docs.python.org/3/using/cmdline.html#cmdoption-o\n.. _PYTHONOPTIMIZE:\n   https://docs.python.org/3/using/cmdline.html#envvar-PYTHONOPTIMIZE\n\n.. _Brython:\n   https://brython.info\n.. _CPython:\n   https://github.com/python/cpython\n.. _Nuitka:\n   https://nuitka.net\n.. _Numba:\n   https://numba.pydata.org\n.. _PyPy:\n   https://www.pypy.org\n```\n\n----------------------------------------\n\nTITLE: ASCII Art - Beartype Theme Text\nDESCRIPTION: An ASCII art text block with a humorous bear-themed message, used for stylistic purposes in the Beartype documentation.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/pep.rst#2025-04-16_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nIt's a big bear AAAAAAAAFTER all!\nIt's a big bear AAAAAAAAFTER all!\nIt's a big b——— *squelching sound, then blessed silence*\n```\n\n----------------------------------------\n\nTITLE: Using Forward References for Self-reference (Not Recommended) in Python\nDESCRIPTION: Shows a deprecated approach for self-referential type hints using string-based forward references, which is less efficient and reliable than using typing.Self.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/faq.rst#2025-04-16_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# The bad old days when @beartype had to bathe in the gutter.\n# *PLEASE DON'T DO THIS ANYMORE.* Do you want @beartype to cry?\nfrom beartype import beartype\n\n@beartype\nclass BadClassFactory(object):\n   def __init__(self, *args: Sequence) -> None:\n       self._args = args\n\n   def make_class(self, other: 'BadClassFactory') -> (  # <-- no, no, Gods, no\n       'BadClassFactory'):  # <------------------------------ please, Gods, no\n       return BadClassFactory(self._args + other._args)\n```\n\n----------------------------------------\n\nTITLE: Using type(None) Alternative for None Return Type in Python\nDESCRIPTION: An alternative way to specify None as a valid return type using the built-in type() function rather than importing from beartype.cave.\nSOURCE: https://github.com/beartype/beartype/blob/main/doc/src/eli5.rst#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@beartype\ndef law_of_the_jungle(wolf: str, pack: dict) -> (tuple, type(None)):\n    return (wolf, pack[wolf]) if wolf in pack else None\n```"
  }
]