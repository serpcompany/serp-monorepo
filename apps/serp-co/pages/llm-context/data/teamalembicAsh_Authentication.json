[
  {
    "owner": "team-alembic",
    "repo": "ash_authentication",
    "content": "TITLE: Configuring AshAuthentication in a User Resource in Elixir\nDESCRIPTION: Example of how to configure the AshAuthentication extension on a User resource, setting up password authentication with email identity and hashed password fields. This demonstrates the basic setup required to implement authentication in an Ash application.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  use Ash.Resource,\n    extensions: [AshAuthentication],\n    domain: MyApp.Accounts\n\n  attributes do\n    uuid_primary_key :id\n    attribute :email, :ci_string, allow_nil?: false\n    attribute :hashed_password, :string, allow_nil?: false, sensitive?: true\n  end\n\n  authentication do\n    strategies do\n      password :password do\n        identity_field :email\n        hashed_password_field :hashed_password\n      end\n    end\n  end\n\n  identities do\n    identity :unique_email, [:email]\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring an Ash Resource with Password Authentication\nDESCRIPTION: Example showing how to configure an Ash resource to use password authentication, with email as the identity field and storage for hashed passwords.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.Strategy.Password.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  use Ash.Resource,\n    extensions: [AshAuthentication],\n    domain: MyApp.Accounts\n\n  attributes do\n    uuid_primary_key :id\n    attribute :email, :ci_string, allow_nil?: false\n    attribute :hashed_password, :string, allow_nil?: false, sensitive?: true\n  end\n\n  authentication do\n    strategies do\n      password :password do\n        identity_field :email\n        hashed_password_field :hashed_password\n      end\n    end\n  end\n\n  identities do\n    identity :unique_email, [:email]\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Password Authentication Strategy in Ash\nDESCRIPTION: Configuring the password authentication strategy with email or username as the identity field.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/password.md#2025-04-17_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nauthentication do\n  ...\n  strategies do\n    password :password do\n      identity_field :email\n      # or\n      identity_field :username\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining User Resource with Authentication in Elixir\nDESCRIPTION: A basic Ash Resource definition for a User with password authentication strategy. The resource includes email and hashed_password attributes along with identity configuration.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/confirmation.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  use Ash.Resource,\n    extensions: [AshAuthentication],\n    domain: MyApp.Accounts\n\n  attributes do\n    uuid_primary_key :id\n    attribute :email, :ci_string, allow_nil?: false, public?: true, sensitive?: true\n    attribute :hashed_password, :string, allow_nil?: false, public?: false, sensitive?: true\n  end\n\n  authentication do\n    strategies do\n      password :password do\n        identity_field :email\n        hashed_password_field :hashed_password\n      end\n    end\n  end\n\n  identities do\n    identity :unique_email, [:email]\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Google Authentication Strategy in Ash Resource (Elixir)\nDESCRIPTION: This snippet shows how to configure the Google authentication strategy in an Ash resource. It includes setting up the client ID, redirect URI, and client secret using a Secrets module.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/google.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  use Ash.Resource,\n    extensions: [AshAuthentication],\n    domain: MyApp.Accounts\n\n  attributes do\n    ...\n  end\n\n  authentication do\n    strategies do\n      google do\n        client_id MyApp.Secrets\n        redirect_uri MyApp.Secrets\n        client_secret MyApp.Secrets\n      end\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring OAuth2 Authentication Strategy in Ash Resource\nDESCRIPTION: Example of configuring an OAuth2 authentication strategy in an Ash resource. The configuration includes setting up required OAuth2 parameters like client_id, redirect_uri, client_secret, and site.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.Strategy.OAuth2.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  use Ash.Resource,\n    extensions: [AshAuthentication],\n    domain: MyApp.Accounts\n\n  attributes do\n    uuid_primary_key :id\n    attribute :email, :ci_string, allow_nil?: false\n  end\n\n  authentication do\n    strategies do\n      oauth2 :example do\n        client_id \"OAuth Client ID\"\n        redirect_uri \"https://my.app/\"\n        client_secret \"My Super Secret Secret\"\n        site \"https://auth.example.com/\"\n      end\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Token Resource with AshAuthentication.TokenResource Extension in Elixir\nDESCRIPTION: This snippet demonstrates how to define a token resource using the AshAuthentication.TokenResource extension. It creates a PostgreSQL-backed resource for storing authentication tokens with automatic configuration.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.TokenResource.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.Token do\n  use Ash.Resource,\n    data_layer: AshPostgres.DataLayer,\n    extensions: [AshAuthentication.TokenResource],\n    domain: MyApp.Accounts\n\n  postgres do\n    table \"tokens\"\n    repo MyApp.Repo\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Ash Resource with Auth0 Authentication Strategy\nDESCRIPTION: Basic configuration for an Ash Resource that uses Auth0 authentication. Defines a User resource with the Auth0 strategy in its authentication block, using a separate Secrets module to handle sensitive configuration.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/auth0.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  use Ash.Resource,\n    extensions: [AshAuthentication],\n    domain: MyApp.Accounts\n\n  authentication do\n    strategies do\n      auth0 do\n        client_id MyApp.Secrets\n        redirect_uri MyApp.Secrets\n        client_secret MyApp.Secrets\n        base_url MyApp.Secrets\n      end\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Registration and Sign-In OAuth2 Authentication\nDESCRIPTION: Example of configuring an OAuth2 strategy that allows both registration of new users and sign-in of existing users. Uses upsert functionality with email as the identity field.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.Strategy.OAuth2.md#2025-04-17_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  attributes do\n    uuid_primary_key :id\n    attribute :email, :ci_string, allow_nil?: false\n  end\n\n  actions do\n    create :register_with_oauth2 do\n      argument :user_info, :map, allow_nil?: false\n      argument :oauth_tokens, :map, allow_nil?: false\n      upsert? true\n      upsert_identity :email\n\n      change AshAuthentication.GenerateTokenChange\n      change fn changeset, _ctx ->\n        user_info = Ash.Changeset.get_argument(changeset, :user_info)\n\n        changeset\n        |> Ash.Changeset.change_attribute(:email, user_info[\"email\"])\n      end\n    end\n  end\n\n  authentication do\n    strategies do\n      oauth2 :example do\n      end\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Adding Magic Link Strategy to User Resource in Elixir\nDESCRIPTION: Code snippet showing how to add the magic link authentication strategy to an Ash User resource. Configures the identity field as email, enables registration, and specifies a custom sender module.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/magic-links.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\n# ...\n\nstrategies do\n  # add these lines -->\n  magic_link do\n    identity_field :email\n    registration_enabled? true\n\n    sender(Example.Accounts.User.Senders.SendMagicLink)\n  end\n  # <-- add these lines\nend\n\n# ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Magic Link Authentication in an Ash Resource\nDESCRIPTION: Example of setting up magic link authentication in an Ash resource with email identity field and custom sender function.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.Strategy.MagicLink.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  use Ash.Resource,\n    extensions: [AshAuthentication],\n    domain: MyApp.Accounts\n\n  attributes do\n    uuid_primary_key :id\n    attribute :email, :ci_string, allow_nil?: false\n  end\n\n  authentication do\n    strategies do\n      magic_link do\n        identity_field :email\n        sender fn user_or_email, token, _opts ->\n          # will be a user if the token relates to an existing user\n          # will be an email if there is no matching user (such as during sign up)\n          # opts will contain the `tenant` key, use this if you need to alter the link based\n          # on the tenant that requested the token\n          MyApp.Emails.deliver_magic_link(user_or_email, token)\n        end\n      end\n    end\n  end\n\n  identities do\n    identity :unique_email, [:email]\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Password Strategy DSL Definition\nDESCRIPTION: The DSL definition for the password strategy, showing the default name and description of the strategy.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.Strategy.Password.md#2025-04-17_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\npassword name \\\\ :password\n```\n\n----------------------------------------\n\nTITLE: Defining a Google OAuth2 Authentication Strategy in Elixir\nDESCRIPTION: This code snippet shows the function signature for defining a Google authentication strategy in AshAuthentication. It builds on top of the OAuth2 strategy and provides Google-specific defaults for authorization and token endpoints.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.Strategy.Google.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ngoogle name \\\\ :google\n```\n\n----------------------------------------\n\nTITLE: Creating Bypass Policies for AshAuthentication Operations in Elixir\nDESCRIPTION: This snippet demonstrates two equivalent ways to implement bypass policies that allow AshAuthentication to perform operations on secured User resources. It uses the AshAuthenticationInteraction check to identify when operations are being performed by the authentication system.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/topics/policies-on-authentication-resources.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\npolicies do\n  bypass always() do\n    authorize_if AshAuthentication.Checks.AshAuthenticationInteraction\n  end\n\n  # or, pick your poison\n\n  bypass AshAuthentication.Checks.AshAuthenticationInteraction do\n    authorize_if always()\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring GitHub OAuth2 Strategy in Elixir\nDESCRIPTION: Defines the GitHub authentication strategy with default configuration for OAuth2 endpoints and parameters. Requires client_id, redirect_uri, and client_secret to be configured. Supports both registration and sign-in flows.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.Strategy.Github.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ngithub name \\\\ :github\n```\n\n----------------------------------------\n\nTITLE: Configuring User Resource Attributes in Ash\nDESCRIPTION: Defining email and hashed_password attributes in the user resource. The email is set as public and non-nullable, while hashed_password is marked as sensitive.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/password.md#2025-04-17_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nattributes do\n  ...\n  attribute :email, :ci_string, allow_nil?: false, public?: true\n  attribute :hashed_password, :string, allow_nil?: false, sensitive?: true\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Auth0 Authentication Strategy in Elixir\nDESCRIPTION: Provides a pre-configured authentication strategy for Auth0 integration. This strategy builds on the OAuth2 strategy with defaults for Auth0's endpoints, setting authorize_url to '/authorize', token_url to '/oauth/token', user_url to '/userinfo', authorization_params scope to 'openid profile email', and auth_method to client_secret_post.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.Strategy.Auth0.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nauth0 name \\\\ :auth0\n```\n\n----------------------------------------\n\nTITLE: Implementing Slack Authentication Strategy in Elixir\nDESCRIPTION: This code snippet demonstrates how to configure the Slack authentication strategy. The strategy requires a name parameter and supports various configuration options including required parameters like client_id, redirect_uri, and client_secret.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.Strategy.Slack.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nslack name \\\\ :slack\n```\n\n----------------------------------------\n\nTITLE: Implementing Auth0 Registration Action in Ash Resource\nDESCRIPTION: Extended User resource configuration with a register_with_auth0 action. This action handles user registration using Auth0, supporting both new user creation and updating returning users through an upsert operation that processes Auth0 user information.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/auth0.md#2025-04-17_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  use Ash.Resource,\n    extensions: [AshAuthentication],\n    domain: MyApp.Accounts\n\n  # ...\n\n  actions do\n    create :register_with_auth0 do\n      argument :user_info, :map, allow_nil?: false\n      argument :oauth_tokens, :map, allow_nil?: false\n      upsert? true\n      upsert_identity :unique_email\n\n      # Required if you have token generation enabled.\n      change AshAuthentication.GenerateTokenChange\n\n      # Required if you have the `identity_resource` configuration enabled.\n      change AshAuthentication.Strategy.OAuth2.IdentityChange\n\n      change fn changeset, _ ->\n        user_info = Ash.Changeset.get_argument(changeset, :user_info)\n\n        Ash.Changeset.change_attributes(changeset, Map.take(user_info, [\"email\"]))\n      end\n    end\n  end\n\n  # ...\n\nend\n```\n\n----------------------------------------\n\nTITLE: Setting Up Unique Identity Constraints in Ash\nDESCRIPTION: Configuring identity constraints to ensure email or username uniqueness in the user resource.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/password.md#2025-04-17_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nidentities do\n  identity :unique_email, [:email]\n  # or\n  identity :unique_username, [:username]\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Apple Authentication Strategy in Elixir\nDESCRIPTION: Defines the apple authentication strategy with optional name parameter. Sets up pre-configured defaults for Apple Sign In including base URLs, endpoints, and authentication parameters.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.Strategy.Apple.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\napple name \\\\ :apple\n```\n\n----------------------------------------\n\nTITLE: Creating a Helper Function for Authenticating Users in LiveView Tests\nDESCRIPTION: This snippet shows how to create a ConnCase helper function for seeding a test user and authenticating them without going through the UI. It creates a user with a hashed password and stores the user in the session for LiveView testing.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/topics/testing.md#2025-04-17_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyAppWeb.ConnCase do\n  use ExUnit.CaseTemplate\n\n  using do\n    # ...\n  end\n\n  def register_and_log_in_user(%{conn: conn}) do\n    email = \"user@example.com\"\n    password = \"password\"\n    {:ok, hashed_password} = AshAuthentication.BcryptProvider.hash(password)\n\n    Ash.Seed.seed!(MyApp.Accounts.User, %{\n      email: email,\n      hashed_password: hashed_password\n    })\n\n    # Replace `:password` with the appropriate strategy for your application.\n    strategy = AshAuthentication.Info.strategy!(MyApp.Accounts.User, :password)\n\n    {:ok, user} =\n      AshAuthentication.Strategy.action(strategy, :sign_in, %{\n        email: email,\n        password: password\n      })\n\n    conn =\n      conn\n      |> Phoenix.ConnTest.init_test_session(%{})\n      |> AshAuthentication.Plug.Helpers.store_in_session(user)\n\n    %{conn: conn}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: OIDC Strategy Definition in Elixir\nDESCRIPTION: Definition of the OIDC authentication strategy with optional name parameter. This builds on top of the OAuth2 strategy and provides additional OIDC-specific functionality.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.Strategy.Oidc.md#2025-04-17_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\noidc name \\\\ :oidc\n```\n\n----------------------------------------\n\nTITLE: Adding User Email Attributes and Identity in Ash Resource\nDESCRIPTION: User resource configuration for email attributes and identity definition. This snippet demonstrates how to add an email field to your User resource with a unique identity constraint, which is required for Auth0 authentication integration.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/auth0.md#2025-04-17_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n\n  # ...\n\n  attributes do\n    uuid_primary_key :id\n\n    attribute :email, :ci_string do\n      allow_nil? false\n    end\n  end\n\n  identities do\n    identity :unique_email, [:email]\n  end\n\n  # ...\n\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing User Identity Resource with AshAuthentication\nDESCRIPTION: Example of defining a UserIdentity resource using AshAuthentication extension. This setup enables tracking of user identities across multiple authentication strategies with PostgreSQL storage.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.UserIdentity.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.UserIdentity do\n  use Ash.Resource,\n    data_layer: AshPostgres.DataLayer,\n    extensions: [AshAuthentication.UserIdentity],\n    domain: MyApp.Accounts\n\n  user_identity do\n    user_resource MyApp.Accounts.User\n  end\n\n  postgres do\n    table \"user_identities\"\n    repo MyApp.Repo\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Sign-In Only OAuth2 Authentication\nDESCRIPTION: Example of configuring an OAuth2 strategy that only allows sign-in for existing users and rejects new users. Includes the required sign-in action with OAuth2 filter preparation.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.Strategy.OAuth2.md#2025-04-17_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  attributes do\n    uuid_primary_key :id\n    attribute :email, :ci_string, allow_nil?: false\n  end\n\n  actions do\n    read :sign_in_with_example do\n      argument :user_info, :map, allow_nil?: false\n      argument :oauth_tokens, :map, allow_nil?: false\n      prepare AshAuthentication.Strategy.OAuth2.SignInPreparation\n\n      filter expr(email == get_path(^arg(:user_info), [:email]))\n    end\n  end\n\n  authentication do\n    strategies do\n      oauth2 :example do\n        registration_enabled? false\n      end\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Magic Link Sender Module in Elixir\nDESCRIPTION: Implementation of a sender module that handles sending magic links. The module uses AshAuthentication.Sender behavior and constructs a URL with the authentication token to be delivered to the user.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/magic-links.md#2025-04-17_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule Example.Accounts.User.Senders.SendMagicLink do\n  @moduledoc \"\"\"\n  Sends a magic link\n  \"\"\"\n  use AshAuthentication.Sender\n  use ExampleWeb, :verified_routes\n\n  @impl AshAuthentication.Sender\n  def send(user_or_email, token, _) do\n    # will be a user if the token relates to an existing user\n    # will be an email if there is no matching user (such as during sign up)\n    Example.Accounts.Emails.deliver_magic_link(\n      user_or_email,\n      url(~p\"/auth/user/magic_link/?token=#{token}\")\n    )\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using Module-Based Secret Configuration for OAuth2\nDESCRIPTION: Example of creating a dedicated module that implements the AshAuthentication.Secret behavior to manage OAuth2 secrets, along with how to reference it in the OAuth2 strategy configuration.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.Strategy.OAuth2.md#2025-04-17_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Secrets do\n  use AshAuthentication.Secret\n\n  def secret_for([:authentication, :strategies, :example, :client_secret], MyApp.User, _opts), do: Application.fetch_env(:my_app, :oauth2_client_secret)\nend\n\n# and in your strategies:\n\noauth2 :example do\n  client_secret MyApp.Secrets\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Confirmation Add-on for Monitored Fields in Elixir\nDESCRIPTION: Configures a confirmation add-on in the User resource that monitors the email field and triggers a confirmation when it changes. This setup specifies the confirmation should happen on updates but not on creation, requires user interaction, and uses a custom sender.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/confirmation.md#2025-04-17_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  # ...\n\n  authentication do\n    # ...\n\n    add_ons do\n      confirmation :confirm_change do\n        monitor_fields [:email]\n        confirm_on_create? false\n        confirm_on_update? true\n        confirm_action_name :confirm_change\n        require_interaction? true\n        sender MyApp.Accounts.User.Senders.SendEmailChangeConfirmationEmail\n      end\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Secret Management for GitHub OAuth in Elixir\nDESCRIPTION: Implements the AshAuthentication.Secret behaviour to manage GitHub OAuth credentials securely. Handles client ID, redirect URI, and client secret retrieval from application configuration.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/github.md#2025-04-17_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Secrets do\n  use AshAuthentication.Secret\n\n  def secret_for([:authentication, :strategies, :github, :client_id], MyApp.Accounts.User, _) do\n    get_config(:client_id)\n  end\n\n  def secret_for([:authentication, :strategies, :github, :redirect_uri], MyApp.Accounts.User, _) do\n    get_config(:redirect_uri)\n  end\n\n  def secret_for([:authentication, :strategies, :github, :client_secret], MyApp.Accounts.User, _) do\n    get_config(:client_secret)\n  end\n\n  defp get_config(key) do\n    :my_app\n    |> Application.get_env(:github, [])\n    |> Keyword.fetch(key)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring User Resource with GitHub Authentication Strategy in Elixir\nDESCRIPTION: Defines a User resource with GitHub authentication strategy setup using Ash Framework. Configures basic GitHub OAuth settings with secret management.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/github.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  use Ash.Resource,\n    extensions: [AshAuthentication],\n    domain: MyApp.Accounts\n\n  authentication do\n    strategies do\n      github do\n        client_id MyApp.Secrets\n        redirect_uri MyApp.Secrets\n        client_secret MyApp.Secrets\n      end\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Slack Registration Action\nDESCRIPTION: Defines a register action for handling Slack authentication responses and user registration/updates, including token generation and identity management.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/slack.md#2025-04-17_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  require Ash.Resource.Change.Builtins\n  use Ash.Resource,\n    extensions: [AshAuthentication],\n    domain: MyApp.Accounts\n\n  # ...\n\n  actions do\n    create :register_with_slack do\n      argument :user_info, :map, allow_nil?: false\n      argument :oauth_tokens, :map, allow_nil?: false\n      upsert? true\n      upsert_identity :unique_email\n\n      # Required if you have token generation enabled.\n      change AshAuthentication.GenerateTokenChange\n\n      # Required if you have the `identity_resource` configuration enabled.\n      change AshAuthentication.Strategy.OAuth2.IdentityChange\n\n      change fn changeset, _ ->\n        user_info = Ash.Changeset.get_argument(changeset, :user_info)\n\n        Ash.Changeset.change_attributes(changeset, Map.take(user_info, [\"email\"]))\n      end\n\n      # Required if you're using the password & confirmation strategies\n      upsert_fields []\n      change set_attribute(:confirmed_at, &DateTime.utc_now/0)\n      change after_action(fn _changeset, user, _context ->\n        case user.confirmed_at do\n          nil -> {:error, \"Unconfirmed user exists already\"}\n          _ -> {:ok, user}\n        end\n      end)\n    end\n  end\n\n  # ...\n\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Ash Resource with Slack Authentication Strategy\nDESCRIPTION: Defines an Ash resource with Slack authentication strategy configuration, including client ID, redirect URI, and client secret settings.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/slack.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  use Ash.Resource,\n    extensions: [AshAuthentication],\n    domain: MyApp.Accounts\n\n  authentication do\n    strategies do\n      slack do\n        client_id MyApp.Secrets\n        redirect_uri MyApp.Secrets\n        client_secret MyApp.Secrets\n      end\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Magic Link Strategy in Ash Authentication\nDESCRIPTION: The DSL for defining a magic link authentication strategy, showing the macro and its parameters.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.Strategy.MagicLink.md#2025-04-17_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nmagic_link name \\\\ :magic_link\n```\n\n----------------------------------------\n\nTITLE: Implementing Email Confirmation Sender in Elixir\nDESCRIPTION: A sender module for confirmation emails that implements the AshAuthentication.Sender behaviour. The module creates and sends a confirmation email with a verification link.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/confirmation.md#2025-04-17_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User.Senders.SendNewUserConfirmationEmail do\n  @moduledoc \"\"\"\n  Sends an email confirmation email\n  \"\"\"\n  use AshAuthentication.Sender\n  use MyAppWeb, :verified_routes\n\n  @impl AshAuthentication.Sender\n  def send(user, token, _opts) do\n    MyApp.Accounts.Emails.deliver_email_confirmation_instructions(\n      user,\n      url(~p\"/auth/user/confirm_new_user?#{[confirm: token]}\")\n    )\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Adding Confirmation Add-on to User Authentication in Elixir\nDESCRIPTION: Implementation of the confirmation add-on in the User resource to confirm new users. It configures which fields to monitor and specifies a custom sender module for confirmation emails.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/confirmation.md#2025-04-17_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  # ...\n\n  authentication do\n    # ...\n\n    add_ons do\n      confirmation :confirm_new_user do\n        monitor_fields [:email]\n        confirm_on_create? true\n        confirm_on_update? false\n        require_interaction? true\n        sender MyApp.Accounts.User.Senders.SendNewUserConfirmationEmail\n      end\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Confirmation Add-On in Ash Resource\nDESCRIPTION: Example of how to configure a User resource with confirmation support to monitor and confirm email changes.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.AddOn.Confirmation.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  use Ash.Resource,\n    extensions: [AshAuthentication],\n    domain: MyApp.Accounts\n\n  attributes do\n    uuid_primary_key :id\n    attribute :email, :ci_string, allow_nil?: false\n  end\n\n  authentication do\n    add_ons do\n      confirmation :confirm do\n        monitor_fields [:email]\n        sender MyApp.ConfirmationSender\n      end\n    end\n\n    strategies do\n      # ...\n    end\n  end\n\n  identities do\n    identity :email, [:email]\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Creating Email Template for Magic Links in Elixir\nDESCRIPTION: Email template implementation for magic link delivery. The function handles both user objects and email strings, extracts the email address, and generates an HTML email with a login link.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/magic-links.md#2025-04-17_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\n# ...\n\ndef deliver_magic_link(user, url) do\n  if !url do\n    raise \"Cannot deliver reset instructions without a url\"\n  end\n\n  email = case user do\n    %{email: email} -> email\n    email -> email\n  end\n\n  deliver(email, \"Magic Link\", \"\"\"\n  <html>\n    <p>\n      Hi #{email},\n    </p>\n\n    <p>\n      <a href=\\\"#{url}\\\">Click here</a> to login.\n    </p>\n  <html>\n  \"\"\")\nend\n\n# ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Log Out Everywhere Add-On in Elixir Resource\nDESCRIPTION: Example of how to set up a User resource with the log_out_everywhere add-on, enabling token storage and requiring token presence for authentication.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.AddOn.LogOutEverywhere.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  use Ash.Resource,\n    extensions: [AshAuthentication],\n    domain: MyApp.Accounts\n\n  authentication do\n    tokens do\n      enabled? true\n      store_all_tokens? true\n      require_token_presence_for_authentication? true\n    end\n\n    add_ons do\n      log_out_everywhere do\n        apply_on_password_change? true\n      end\n    end\n```\n\n----------------------------------------\n\nTITLE: Defining Strategy Phases and Actions\nDESCRIPTION: Defines the phases and actions supported by the authentication strategy. This strategy only supports sign-in, so it has a single phase and action.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/topics/custom-strategy.md#2025-04-17_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\n  def phases(_), do: [:sign_in]\n  def actions(_), do: [:sign_in]\n```\n\n----------------------------------------\n\nTITLE: Implementing Google OAuth2 Registration Action in Ash Resource (Elixir)\nDESCRIPTION: This snippet defines the :register_with_google action in an Ash resource. It handles both user registration and login for Google OAuth2 authentication, including argument definitions, changes, and upsert configuration.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/google.md#2025-04-17_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  require Ash.Resource.Change.Builtins\n  use Ash.Resource,\n    extensions: [AshAuthentication],\n    domain: MyApp.Accounts\n\n  # ...\n  actions do\n    create :register_with_google do\n      argument :user_info, :map, allow_nil?: false\n      argument :oauth_tokens, :map, allow_nil?: false\n      upsert? true\n      upsert_identity :unique_email\n\n      change AshAuthentication.GenerateTokenChange\n\n      # Required if you have the `identity_resource` configuration enabled.\n      change AshAuthentication.Strategy.OAuth2.IdentityChange\n\n      change fn changeset, _ ->\n        user_info = Ash.Changeset.get_argument(changeset, :user_info)\n\n        Ash.Changeset.change_attributes(changeset, Map.take(user_info, [\"email\"]))\n      end\n\n      # Required if you're using the password & confirmation strategies\n      upsert_fields []\n      change set_attribute(:confirmed_at, &DateTime.utc_now/0)\n      change after_action(fn _changeset, user, _context ->\n        case user.confirmed_at do\n          nil -> {:error, \"Unconfirmed user exists already\"}\n          _ -> {:ok, user}\n        end\n      end)\n    end\n  end\n\n  # ...\n\nend\n```\n\n----------------------------------------\n\nTITLE: Defining DSL Entity for Custom Authentication Strategy\nDESCRIPTION: Implements the DSL entity configuration with schema definitions, including options for case sensitivity and name field configuration.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/topics/custom-strategy.md#2025-04-17_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule OnlyMartiesAtTheParty do\n  @entity %Spark.Dsl.Entity{\n    name: :only_marty,\n    describe: \"Strategy which only allows folks whose name starts with \\\"Marty\\\" to sign in.\",\n    examples: [\n      \"\"\"\n      only_marty do\n        case_sensitive? true\n        name_field :name\n      end\n      \"\"\"\n    ],\n    target: __MODULE__,\n    args: [{:optional, :name, :marty}],\n    schema: [\n      name: [\n        type: :atom,\n        doc: \"\"\"\n        The strategy name.\n        \"\"\",\n        required: true\n      ],\n      case_sensitive?: [\n        type: :boolean,\n        doc: \"\"\"\n        Ignore letter case when comparing?\n        \"\"\",\n        required: false,\n        default: false\n      ],\n      name_field: [\n        type: :atom,\n        doc: \"\"\"\n        The field to check for the users' name.\n        \"\"\",\n        required: true\n      ]\n    ]\n  }\n\n  use AshAuthentication.Strategy.Custom, entity: @entity\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing GitHub Registration Action in User Resource\nDESCRIPTION: Defines the registration action for GitHub authentication including user info handling, OAuth token management, and user creation/update logic.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/github.md#2025-04-17_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  require Ash.Resource.Change.Builtins\n  use Ash.Resource,\n    extensions: [AshAuthentication],\n    domain: MyApp.Accounts\n\n  # ...\n\n  actions do\n    create :register_with_github do\n      argument :user_info, :map, allow_nil?: false\n      argument :oauth_tokens, :map, allow_nil?: false\n      upsert? true\n      upsert_identity :unique_email\n\n      # Required if you have token generation enabled.\n      change AshAuthentication.GenerateTokenChange\n\n      # Required if you have the `identity_resource` configuration enabled.\n      change AshAuthentication.Strategy.OAuth2.IdentityChange\n\n      change fn changeset, _ ->\n        user_info = Ash.Changeset.get_argument(changeset, :user_info)\n\n        Ash.Changeset.change_attributes(changeset, Map.take(user_info, [\"email\"]))\n      end\n\n      # Required if you're using the password & confirmation strategies\n      upsert_fields []\n      change set_attribute(:confirmed_at, &DateTime.utc_now/0)\n      change after_action(fn _changeset, user, _context ->\n        case user.confirmed_at do\n          nil -> {:error, \"Unconfirmed user exists already\"}\n          _ -> {:ok, user}\n        end\n      end)\n    end\n  end\n\n  # ...\n\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Authentication Plug\nDESCRIPTION: Implements the plug function that handles the authentication request. It extracts name field from params, calls the sign-in action, and stores the authentication result.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/topics/custom-strategy.md#2025-04-17_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\n  import AshAuthentication.Plug.Helpers, only: [store_authentication_result: 2]\n\n  def plug(strategy, :sign_in, conn) do\n    params = Map.take(conn.params, [to_string(strategy.name_field)])\n    result = action(strategy, :sign_in, params, [])\n    store_authentication_result(conn, result)\n  end\n```\n\n----------------------------------------\n\nTITLE: Configuring Authentication Strategy to Require Confirmation in Elixir\nDESCRIPTION: Configuration example that requires users to confirm their accounts before logging in. It uses the require_confirmed_with directive to specify which confirmation strategy to enforce.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/confirmation.md#2025-04-17_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\nauthentication do\n  ...\n  add_ons do\n    confirmation :confirm_new_user do\n      ...\n    end\n  end\n\n  strategies do\n    strategy :password do\n      ...\n      # which confirmation strategy to require confirmation for\n      require_confirmed_with :confirm_new_user\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Sign-in Action Logic\nDESCRIPTION: Implements the core authentication logic that finds users whose name field starts with 'Marty'. It handles different result cases and returns appropriate authentication responses.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/topics/custom-strategy.md#2025-04-17_snippet_10\n\nLANGUAGE: elixir\nCODE:\n```\n  alias AshAuthentication.Errors.AuthenticationFailed\n  require Ash.Query\n  import Ash.Expr\n\n  def action(strategy, :sign_in, params, options) do\n    name_field = strategy.name_field\n    name = Map.get(params, to_string(name_field))\n    domain = AshAuthentication.Info.domain!(strategy.resource)\n\n    strategy.resource\n    |> Ash.Query.filter(expr(^ref(name_field) == ^name))\n    |> then(fn query ->\n      if strategy.case_sensitive? do\n        Ash.Query.filter(query, like(^ref(name_field), \"Marty%\"))\n      else\n        Ash.Query.filter(query, ilike(^ref(name_field), \"Marty%\"))\n      end\n    end)\n    |> Ash.read(options)\n    |> case do\n      {:ok, [user]} ->\n        {:ok, user}\n\n      {:ok, []} ->\n        {:error, AuthenticationFailed.exception(caused_by: %{reason: :no_user})}\n\n      {:ok, _users} ->\n        {:error, AuthenticationFailed.exception(caused_by: %{reason: :too_many_users})}\n\n      {:error, reason} ->\n        {:error, AuthenticationFailed.exception(caused_by: %{reason: reason})}\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using Function-Based Secret Configuration for OAuth2\nDESCRIPTION: Example of providing OAuth2 client secrets through an anonymous function that fetches the secret from the application environment at runtime.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.Strategy.OAuth2.md#2025-04-17_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\noauth2 do\n  client_secret fn _path, resource ->\n    Application.fetch_env(:my_app, resource, :oauth2_client_secret)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Enabling Sign-in Tokens in AshAuthentication Password Strategy\nDESCRIPTION: DSL reference for enabling sign-in tokens in the password authentication strategy. These tokens can be generated on request and are used for short-lived authentication flows.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/topics/tokens.md#2025-04-17_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nAshAuthentication.Strategy.Password.authentication.strategies.password.sign_in_tokens_enabled?\n```\n\n----------------------------------------\n\nTITLE: Creating Email Template Module in Elixir\nDESCRIPTION: An email module that defines templates for confirmation emails. The module uses Swoosh for email delivery and formats HTML email content with a confirmation link.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/confirmation.md#2025-04-17_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule Example.Accounts.Emails do\n  @moduledoc \"\"\"\n  Delivers emails.\n  \"\"\"\n\n  import Swoosh.Email\n\n  def deliver_email_confirmation_instructions(user, url) do\n    if !url do\n      raise \"Cannot deliver confirmation instructions without a url\"\n    end\n\n    deliver(user.email, \"Confirm your email address\", \"\"\"\n      <p>\n        Hi #{user.email},\n      </p>\n\n      <p>\n        Someone has tried to register a new account using this email address.\n        If it was you, then please click the link below to confirm your identity. If you did not initiate this request then please ignore this email.\n      </p>\n\n      <p>\n        <a href=\"#{url}\">Click here to confirm your account</a>\n      </p>\n    \"\"\")\n  end\n\n  # For simplicity, this module simply logs messages to the terminal.\n  # You should replace it by a proper email or notification tool, such as:\n  #\n  #   * Swoosh - https://hexdocs.pm/swoosh\n  #   * Bamboo - https://hexdocs.pm/bamboo\n  #\n  defp deliver(to, subject, body) do\n    IO.puts(\"Sending email to #{to} with subject #{subject} and body #{body}\")\n\n    new()\n    |> from({\"Zach\", \"zach@ash-hq.org\"}) # TODO: Replace with your email\n    |> to(to_string(to))\n    |> subject(subject)\n    |> put_provider_option(:track_links, \"None\")\n    |> html_body(body)\n    |> MyApp.Mailer.deliver!()\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Token Presence Requirement in AshAuthentication\nDESCRIPTION: DSL reference for requiring token presence for authentication, which inverts token validation behavior to require tokens to be present in the token resource.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/topics/tokens.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nAshAuthentication.Dsl.authentication.tokens.require_token_presence_for_authentication?\n```\n\n----------------------------------------\n\nTITLE: Creating an Email Template for Change Confirmations in Elixir\nDESCRIPTION: Defines an email template function that formats and delivers the confirmation email. The template includes a personalized greeting, an explanation of why the email was sent, and a confirmation link.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/confirmation.md#2025-04-17_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.Emails do\n  # ...\n\n  def deliver_email_change_confirmation_instructions(user, url) do\n    if !url do\n      raise \"Cannot deliver confirmation instructions without a url\"\n    end\n\n    deliver(user.email, \"Confirm your new email address\", \"\"\"\n      <p>\n        Hi #{user.email},\n      </p>\n\n      <p>\n        You recently changed your email address. Please confirm it.\n      </p>\n\n      <p>\n        <a href=\"#{url}\">Click here to confirm your new email address</a>\n      </p>\n    \"\"\")\n  end\n\n  # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Customizing the Confirmation Action in Elixir\nDESCRIPTION: Implements a custom confirmation action that extends the default behavior. It defines the required arguments, accepts the email field, and adds a custom change to update an external CRM system after successful confirmation.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/confirmation.md#2025-04-17_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  # ...\n\n  actions do\n    # ...\n\n    update :confirm_change do\n      argument :confirm, :string, allow_nil?: false, public?: true\n      accept [:email]\n      require_atomic? false\n      change AshAuthentication.AddOn.Confirmation.ConfirmChange\n      change AshAuthentication.GenerateTokenChange\n      change MyApp.UpdateCrmSystem, only_when_valid?: true\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Password Strategy Configuration Example\nDESCRIPTION: Example of configuring the password strategy with custom options like identity field, hashed password field, hash provider, and confirmation requirements.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.Strategy.Password.md#2025-04-17_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\npassword :password do\n  identity_field :email\n  hashed_password_field :hashed_password\n  hash_provider AshAuthentication.BcryptProvider\n  confirmation_required? true\nend\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Email Sender for Change Confirmations in Elixir\nDESCRIPTION: Implements the sender module that generates and sends email change confirmation links. It uses AshAuthentication.Sender and creates a URL with a confirmation token that will be sent to the user.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/confirmation.md#2025-04-17_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User.Senders.SendEmailChangeConfirmationEmail do\n  @moduledoc \"\"\"\n  Sends an email change confirmation email\n  \"\"\"\n  use AshAuthentication.Sender\n  use MyAppWeb, :verified_routes\n\n  @impl AshAuthentication.Sender\n  def send(user, token, _opts) do\n    MyApp.Accounts.Emails.deliver_email_change_confirmation_instructions(\n      user,\n      url(~p\"/auth/user/confirm_change?#{[confirm: token]}\")\n    )\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Client in AshAuthentication with Finch\nDESCRIPTION: Example showing how to customize the HTTP client behavior for OAuth2-based authentication strategies by defining a custom HTTP adapter in application settings. This uses Finch as the HTTP client with a custom supervisor.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.md#2025-04-17_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :ash_authentication, :http_adapter, {Assent.HTTPAdapter.Finch, supervisor: MyApp.CustomFinch}\n```\n\n----------------------------------------\n\nTITLE: Generating Random Nonce Value in Elixir\nDESCRIPTION: Example code showing how to generate a secure random nonce value for OIDC authentication using crypto and Base64 encoding. The nonce value is used to prevent replay attacks.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.Strategy.Oidc.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\n16\n|> :crypto.strong_rand_bytes()\n|> Base.encode64(padding: false)\n```\n\n----------------------------------------\n\nTITLE: Implementing Authentication Secrets Module\nDESCRIPTION: Defines a secrets module that implements the AshAuthentication.Secret behaviour to handle sensitive configuration values for Slack authentication.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/slack.md#2025-04-17_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Secrets do\n  use AshAuthentication.Secret\n\n  def secret_for([:authentication, :strategies, :slack, :client_id], MyApp.Accounts.User, _) do\n    get_config(:client_id)\n  end\n\n  def secret_for([:authentication, :strategies, :slack, :redirect_uri], MyApp.Accounts.User, _) do\n    get_config(:redirect_uri)\n  end\n\n  def secret_for([:authentication, :strategies, :slack, :client_secret], MyApp.Accounts.User, _) do\n    get_config(:client_secret)\n  end\n\n  defp get_config(key) do\n    :my_app\n    |> Application.get_env(:slack, [])\n    |> Keyword.fetch(key)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Initializing Basic Custom Authentication Strategy Module\nDESCRIPTION: Creates the basic structure for a custom authentication strategy module using AshAuthentication.Strategy.Custom.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/topics/custom-strategy.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule OnlyMartiesAtTheParty do\n  use AshAuthentication.Strategy.Custom\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Auth0 Secrets Management in Elixir\nDESCRIPTION: Implementation of the AshAuthentication.Secret behaviour for securely providing Auth0 credentials. This module retrieves configuration values from the OTP application environment for client_id, redirect_uri, client_secret, and base_url.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/auth0.md#2025-04-17_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Secrets do\n  use AshAuthentication.Secret\n\n  def secret_for([:authentication, :strategies, :auth0, :client_id], MyApp.Accounts.User, _opts, _meth) do\n    get_config(:client_id)\n  end\n\n  def secret_for([:authentication, :strategies, :auth0, :redirect_uri], MyApp.Accounts.User, _opts, _meth) do\n    get_config(:redirect_uri)\n  end\n\n  def secret_for([:authentication, :strategies, :auth0, :client_secret], MyApp.Accounts.User, _opts, _meth) do\n    get_config(:client_secret)\n  end\n\n  def secret_for([:authentication, :strategies, :auth0, :base_url], MyApp.Accounts.User, _opts, _meth) do\n    get_config(:base_url)\n  end\n\n  defp get_config(key) do\n    :my_app\n    |> Application.fetch_env!(:auth0)\n    |> Keyword.fetch!(key)\n    |> then(&{:ok, &1})\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Method for Authentication Phase\nDESCRIPTION: Specifies which HTTP method should be used for each phase when generating routes or forms. In this case, POST is used for sign-in.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/topics/custom-strategy.md#2025-04-17_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\n  def method_for_phase(_, :sign_in), do: :post\n```\n\n----------------------------------------\n\nTITLE: Resource Configuration with Custom Strategy\nDESCRIPTION: Shows how to implement the custom authentication strategy in an Ash resource definition with necessary configurations.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/topics/custom-strategy.md#2025-04-17_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  use Ash.Resource,\n    extensions: [AshAuthentication, OnlyMartiesAtTheParty],\n    domain: MyApp.Accounts\n\n  authentication do\n    strategies do\n      only_marty do\n        name_field :name\n      end\n    end\n  end\n\n  attributes do\n    uuid_primary_key\n    attribute :name, :string, allow_nil?: false\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Strategy Protocol for OnlyMartiesAtTheParty\nDESCRIPTION: Basic protocol implementation that defines the strategy's identity.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/topics/custom-strategy.md#2025-04-17_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\ndefimpl AshAuthentication.Strategy, for: OnlyMartiesAtTheParty do\n```\n\n----------------------------------------\n\nTITLE: Implementing Strategy Struct Definition\nDESCRIPTION: Defines the struct for the authentication strategy with required fields including resource field required by Ash Authentication.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/topics/custom-strategy.md#2025-04-17_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule OnlyMartiesAtTheParty do\n  defstruct name: :marty, case_sensitive?: false, name_field: nil, resource: nil\n\n  # ...\n\n  use AshAuthentication.Strategy.Custom, entity: @entity\n\n  # other code elided ...\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Strategy Verifier for Configuration Validation\nDESCRIPTION: Example of a verifier function that runs after compilation to validate user configuration, checking that the name field contains 'marty'.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/topics/custom-strategy.md#2025-04-17_snippet_14\n\nLANGUAGE: elixir\nCODE:\n```\ndef verify(strategy, _dsl_state) do\n  if String.contains?(to_string(strategy.name_field), \"marty\") do\n    :ok\n  else\n    {:error,\n      Spark.Error.DslError.exception(\n        path: [:authentication, :strategies, :only_marties],\n        message: \"Option `name_field` must contain \\\"marty\\\"\"\n      )}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Advanced Strategy Transformer with DSL Modification\nDESCRIPTION: More complex transformer that both modifies the strategy and builds a custom sign-in action in the resource's DSL.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/topics/custom-strategy.md#2025-04-17_snippet_13\n\nLANGUAGE: elixir\nCODE:\n```\ndef transform(strategy, dsl_state) do\n  strategy = Map.put_new(strategy, :sign_in_action_name, :\"sign_in_with_#{strategy.name}\")\n\n  sign_in_action =\n    Spark.Dsl.Transformer.build_entity(Ash.Resource.Dsl, [:actions], :read,\n      name: strategy.sign_in_action_name,\n      accept: [strategy.name_field],\n      get?: true\n    )\n\n  dsl_state =\n    dsl_state\n    |> Spark.Dsl.Transformer.add_entity([:actions], sign_in_action)\n    |> put_strategy(strategy)\n    |> then(fn dsl_state ->\n      register_strategy_actions([strategy.sign_in_action_name], dsl_state, strategy)\n    end)\n\n  {:ok, dsl_state}\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Nullable Password Field in User Resource\nDESCRIPTION: Adds a nullable hashed_password attribute to the User resource to support both GitHub and password authentication strategies.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/github.md#2025-04-17_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  # ...\n  attributes do\n    # ...\n    attribute :hashed_password, :string, allow_nil?: true, sensitive?: true\n  end\n  # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Generating Authentication Routes\nDESCRIPTION: Generates routes for the strategy, including the subject name of the resource being authenticated in case multiple different resources are authenticated.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/topics/custom-strategy.md#2025-04-17_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\n  def routes(strategy) do\n    subject_name = AshAuthentication.Info.authentication_subject_name!(strategy.resource)\n\n    [\n      {\"/#{subject_name}/#{strategy.name}\", :sign_in}\n    ]\n  end\n```\n\n----------------------------------------\n\nTITLE: Generating and Running Ash Migrations (Bash)\nDESCRIPTION: This snippet provides the command-line instructions for generating and running Ash migrations to make the hashed_password field nullable in the database.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/google.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmix ash.codegen make_hashed_password_nullable\nmix ash.migrate\n```\n\n----------------------------------------\n\nTITLE: Defining Strategy Name\nDESCRIPTION: Implements the name/1 function which uniquely identifies the strategy. Must return an atom and should match the path fragment used in routes.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/topics/custom-strategy.md#2025-04-17_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\n  def name(strategy), do: strategy.name\n```\n\n----------------------------------------\n\nTITLE: Configuring Nullable Hashed Password in Ash Resource (Elixir)\nDESCRIPTION: This snippet shows how to configure the hashed_password attribute in an Ash resource to allow null values, which is necessary when using both Google and password authentication strategies.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/google.md#2025-04-17_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  # ...\n  attributes do\n    # ...\n    attribute :hashed_password, :string, allow_nil?: true, sensitive?: true\n  end\n  # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Using Authentication Helper Directly in LiveView Test Block\nDESCRIPTION: This snippet shows an alternative approach to using the authentication helper by calling it directly within a test block. This provides more control over when authentication occurs within a specific test.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/topics/testing.md#2025-04-17_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ntest \"some test\", context do\n  %{conn: conn} = register_and_log_in_user(context)\n\n  {:ok, lv, _html} = live(conn, ~p\"/authenticated-route\")\n\n  # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Running Ash Postgres Migrations\nDESCRIPTION: Commands to generate and run database migrations for Ash Postgres. These commands create the necessary database schema for the User resource with Auth0 authentication support.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/auth0.md#2025-04-17_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nmix ash_postgres.generate_migrations\nmix ecto.migrate\n```\n\n----------------------------------------\n\nTITLE: Using Authentication Helper in LiveView Tests with Setup\nDESCRIPTION: This snippet demonstrates how to use the authentication helper in LiveView tests by passing it to the setup function. This approach automatically authenticates a user before each test runs.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/topics/testing.md#2025-04-17_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyAppWeb.MyLiveTest do\n  use MyAppWeb.ConnCase\n\n  setup :register_and_log_in_user\n\n  test \"some test\", %{conn: conn} do\n    {:ok, lv, _html} = live(conn, ~p\"/authenticated-route\")\n\n    # ...\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Database Migration Commands\nDESCRIPTION: Commands for generating and running migrations to make the hashed_password field nullable.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/slack.md#2025-04-17_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nmix ash.codegen make_hashed_password_nullable\nmix ash.migrate\n```\n\n----------------------------------------\n\nTITLE: Configuring Bcrypt for Faster Testing with Ash Authentication in Elixir\nDESCRIPTION: This snippet demonstrates how to configure bcrypt_elixir to use fewer log rounds during testing, significantly reducing computational cost and speeding up tests. This should only be used in test environments.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/topics/testing.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\n# in config/test.exs\n\n# Do NOT set this value for production\nconfig :bcrypt_elixir, log_rounds: 1\n```\n\n----------------------------------------\n\nTITLE: Generating Migrations for Confirmation in Bash\nDESCRIPTION: Command to generate the necessary migrations for adding a confirmed_at column to the user resource database table.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/confirmation.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmix ash.codegen account_confirmation\n```\n\n----------------------------------------\n\nTITLE: Defining an OAuth2 Strategy with Optional Name Parameter\nDESCRIPTION: The DSL syntax for defining an OAuth2 authentication strategy in the authentication block, with an optional name parameter that uniquely identifies the strategy.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.Strategy.OAuth2.md#2025-04-17_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\noauth2 name \\\\ :oauth2\n```\n\n----------------------------------------\n\nTITLE: Setting Up Phoenix Router for Confirmation\nDESCRIPTION: Configuration example for integrating confirmation with AshAuthenticationPhoenix in a Phoenix router.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.AddOn.Confirmation.md#2025-04-17_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\n# Remove this if you do not want to use the confirmation strategy\nconfirm_route(\n  MyApp.Accounts.User,\n  :confirm_new_user,\n  auth_routes_prefix: \"/auth\",\n  overrides: [MyApp.AuthOverrides, AshAuthentication.Phoenix.Overrides.Default]\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Log Out Everywhere Add-On in Elixir\nDESCRIPTION: Syntax for defining the log_out_everywhere add-on with an optional name parameter, which uniquely identifies the add-on in the authentication system.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.AddOn.LogOutEverywhere.md#2025-04-17_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nlog_out_everywhere name \\\\ :log_out_everywhere\n```\n\n----------------------------------------\n\nTITLE: Configuring Nullable Password Field\nDESCRIPTION: Defines the hashed_password attribute as nullable to support both Slack and password authentication strategies.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/slack.md#2025-04-17_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User do\n  # ...\n  attributes do\n    # ...\n    attribute :hashed_password, :string, allow_nil?: true, sensitive?: true\n  end\n  # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Database Migration Commands for Password Field\nDESCRIPTION: Commands to generate and run migrations for making the hashed_password field nullable in the database.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/github.md#2025-04-17_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nmix ash.codegen make_hashed_password_nullable\nmix ash.migrate\n```\n\n----------------------------------------\n\nTITLE: Installing Bcrypt Dependency in Elixir\nDESCRIPTION: Adding the Bcrypt dependency to the project for password hashing functionality.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/tutorials/password.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\n{:bcrypt_elixir, \"~> 3.0\"}\n```\n\n----------------------------------------\n\nTITLE: Defining Token Resource with Optional Subject Attribute in Elixir\nDESCRIPTION: Shows how to define a token resource with a nullable subject attribute to handle migration issues when upgrading to v3.6.0. This modification allows existing tokens without subject values to remain valid during the upgrade process.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/topics/upgrading.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nattributes do\n  attribute :subject, :string, allow_nil?: true\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Strategy Transformer for Action Name Generation\nDESCRIPTION: Example of a simple transformer function that generates a default sign-in action name if the user hasn't specified one.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/topics/custom-strategy.md#2025-04-17_snippet_12\n\nLANGUAGE: elixir\nCODE:\n```\ndef transform(strategy, _dsl_state) do\n  {:ok, Map.put_new(strategy, :sign_in_action_name, :\"sign_in_with_#{strategy.name}\")}\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Token Requirements\nDESCRIPTION: Implements the tokens_required?/1 function which indicates whether the strategy creates or consumes tokens. This strategy does not use tokens.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/topics/custom-strategy.md#2025-04-17_snippet_11\n\nLANGUAGE: elixir\nCODE:\n```\ndef tokens_required?(_), do: false\n```\n\n----------------------------------------\n\nTITLE: Configuring Confirmation Add-On in Authentication DSL\nDESCRIPTION: The DSL syntax for adding confirmation to a resource's authentication, showing all available options and their default values.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/documentation/dsls/DSL-AshAuthentication.AddOn.Confirmation.md#2025-04-17_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nconfirmation name \\\\ :confirm\n```\n\n----------------------------------------\n\nTITLE: Version Release Headers in Markdown\nDESCRIPTION: Markdown formatted version release headers showing version numbers, comparison links, and dates.\nSOURCE: https://github.com/team-alembic/ash_authentication/blob/main/CHANGELOG.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## [v3.7.0](https://github.com/team-alembic/ash_authentication/compare/v3.6.1...v3.7.0) (2023-01-18)\n\n## [v3.6.1](https://github.com/team-alembic/ash_authentication/compare/v3.6.0...v3.6.1) (2023-01-15)\n\n## [v3.6.0](https://github.com/team-alembic/ash_authentication/compare/v3.5.3...v3.6.0) (2023-01-13)\n```"
  }
]