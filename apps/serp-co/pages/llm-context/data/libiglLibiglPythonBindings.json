[
  {
    "owner": "libigl",
    "repo": "libigl-python-bindings",
    "content": "TITLE: Installing Libigl and Dependencies\nDESCRIPTION: Commands to install the Libigl Python package from PyPI and the meshplot visualization library. These are the basic dependencies needed to run the tutorial examples.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython -m pip install libigl\npython -m pip install https://github.com/skoch9/meshplot/archive/0.4.0.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Installing Libigl and Dependencies via pip\nDESCRIPTION: Commands to install Libigl and its visualization dependency meshplot using pip. Libigl requires numpy and scipy, while meshplot is used for visualization in the tutorial.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter0.ipynb#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython -m pip install libigl\n```\n\nLANGUAGE: bash\nCODE:\n```\npip install https://github.com/skoch9/meshplot/archive/0.4.0.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Installing libigl Python Package via pip\nDESCRIPTION: Command to install the libigl Python bindings using pip. This provides access to the full functionality of the C++ geometry processing library through Python.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/index.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython -m pip install libigl\n```\n\n----------------------------------------\n\nTITLE: Interactive 3D Mesh Animation with ARAP in Python using libigl\nDESCRIPTION: This code implements an interactive mesh animation that deforms a 3D mesh using As-Rigid-As-Possible (ARAP) deformation. The animation is controlled by a time parameter that creates periodic movements of boundary vertices along different axes according to their segment type.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n# Plot the mesh with pseudocolors\np = plot(v, f, c, return_plot=True)\n\n@interact(t=(0.0, 10.0))\ndef update(t=1.0):\n    bc = np.zeros((b.size, v.shape[1]))\n    for i in range(0, b.size):\n        bc[i] = v[b[i]]\n        if s[b[i]] == 0:\n            r = mid[0] * 0.25\n            bc[i, 0] += r * np.sin(0.5 * t * 2 * np.pi)\n            bc[i, 1] = bc[i, 1] - r + r * np.cos(np.pi + 0.5 * t * 2 * np.pi)\n        elif s[b[i]] == 1:\n            r = mid[1] * 0.15\n            bc[i, 1] = bc[i, 1] + r + r * np.cos(np.pi + 0.15 * t * 2 * np.pi)\n            bc[i, 2] -= r * np.sin(0.15 * t * 2 * np.pi)\n        elif s[b[i]] == 2:\n            r = mid[1] * 0.15\n            bc[i, 2] = bc[i, 2] + r + r * np.cos(np.pi + 0.35 * t * 2 * np.pi)\n            bc[i, 0] += r * np.sin(0.35 * t * 2 * np.pi)\n\n    vn = arap.solve(bc, v)\n    p.update_object(vertices=vn)\n```\n\n----------------------------------------\n\nTITLE: Implementing Least Squares Conformal Maps (LSCM) Parametrization\nDESCRIPTION: Implements LSCM parametrization which minimizes angular distortion without requiring fixed boundaries. The method fixes only two boundary points and computes a parametrization that minimizes the LSCM energy. The result is visualized in both 2D and 3D.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter4.ipynb#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"camelhead.off\"))\n\n# Fix two points on the boundary\nb = np.array([2, 1])\n\nbnd = igl.boundary_loop(f)\nb[0] = bnd[0]\nb[1] = bnd[int(bnd.size / 2)]\n\nbc = np.array([[0.0, 0.0], [1.0, 0.0]])\n\n# LSCM parametrization\n_, uv = igl.lscm(v, f, b, bc)\n\np = subplot(v, f, uv=uv, shading={\"wireframe\": False, \"flat\": False}, s=[1, 2, 0])\nsubplot(uv, f, uv=uv, shading={\"wireframe\": False, \"flat\": False}, s=[1, 2, 1], data=p)\n\n# @interact(mode=['3D','2D'])\n# def switch(mode):\n#     if mode == \"3D\":\n#         plot(v, f, uv=uv, shading={\"wireframe\": False, \"flat\": False}, plot=p)\n#     if mode == \"2D\":\n#         plot(uv, f, uv=uv, shading={\"wireframe\": True, \"flat\": False}, plot=p)\n```\n\n----------------------------------------\n\nTITLE: Harmonic Parametrization of 3D Mesh in Python using libigl\nDESCRIPTION: This snippet implements a harmonic parametrization algorithm that maps a 3D mesh to a 2D UV space. It detects boundary vertices, maps them to a circle, and computes harmonic functions for internal vertices. The implementation includes an interactive view switch between 3D and 2D representations.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nv, f  = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"camelhead.off\"))\n## Find the open boundary\nbnd = igl.boundary_loop(f)\n\n## Map the boundary to a circle, preserving edge proportions\nbnd_uv = igl.map_vertices_to_circle(v, bnd)\n\n## Harmonic parametrization for the internal vertices\nuv = igl.harmonic(v, f, bnd, bnd_uv, 1)\nv_p = np.hstack([uv, np.zeros((uv.shape[0],1))])\n\np = plot(v, f, uv=uv, shading={\"wireframe\": False, \"flat\": False}, return_plot=True)\n\n@interact(mode=['3D','2D'])\ndef switch(mode):\n    if mode == \"3D\":\n        plot(v, f, uv=uv, shading={\"wireframe\": False, \"flat\": False}, plot=p)\n    if mode == \"2D\":\n        plot(v_p, f, uv=uv, shading={\"wireframe\": True, \"flat\": False}, plot=p)\n```\n\n----------------------------------------\n\nTITLE: Implementing Harmonic Parametrization with libigl\nDESCRIPTION: Demonstrates harmonic parametrization by mapping a mesh to a 2D UV space. The process includes finding the boundary vertices, mapping them to a circle, and computing harmonic functions for the interior vertices. The resulting UV coordinates are used to visualize the mesh in 2D and 3D.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter4.ipynb#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nv, f  = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"camelhead.off\"))\n## Find the open boundary\nbnd = igl.boundary_loop(f)\n\n## Map the boundary to a circle, preserving edge proportions\nbnd_uv = igl.map_vertices_to_circle(v, bnd)\n\n## Harmonic parametrization for the internal vertices\nuv = igl.harmonic(v, f, bnd, bnd_uv, 1)\nv_p = np.hstack([uv, np.zeros((uv.shape[0],1))])\n\np = subplot(v, f, uv=uv, shading={\"wireframe\": False, \"flat\": False}, s=[1, 2, 0])\nsubplot(v_p, f, uv=uv, shading={\"wireframe\": True, \"flat\": False}, s=[1, 2, 1], data=p)\n\n# @interact(mode=['3D','2D'])\n# def switch(mode):\n#     if mode == \"3D\":\n#         plot(v, f, uv=uv, shading={\"wireframe\": False, \"flat\": False}, plot=p)\n#     if mode == \"2D\":\n#         plot(v_p, f, uv=uv, shading={\"wireframe\": True, \"flat\": False}, plot=p)\n```\n\n----------------------------------------\n\nTITLE: As-Rigid-As-Possible (ARAP) Parametrization in Python using libigl\nDESCRIPTION: This snippet implements the ARAP parametrization algorithm which preserves distances and angles in the mapping process. The code initializes the optimization with harmonic parametrization and then refines it using the ARAP method, allowing the boundary to deform to minimize distortion.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nv, f  = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"camelhead.off\"))\n\n## Find the open boundary\nbnd = igl.boundary_loop(f)\n\n## Map the boundary to a circle, preserving edge proportions\nbnd_uv = igl.map_vertices_to_circle(v, bnd)\n\n## Harmonic parametrization for the internal vertices\nuv = igl.harmonic(v, f, bnd, bnd_uv, 1)\n\narap = igl.ARAP(v, f, 2, np.zeros(0))\nuva = arap.solve(np.zeros((0, 0)), uv)\n\np = plot(v, f, uv=uva, shading={\"wireframe\": False, \"flat\": False}, return_plot=True)\n\n@interact(mode=['3D','2D'])\ndef switch(mode):\n    if mode == \"3D\":\n        plot(v, f, uv=uva, shading={\"wireframe\": False, \"flat\": False}, plot=p)\n    if mode == \"2D\":\n        plot(uva, f, uv=uva, shading={\"wireframe\": True, \"flat\": False}, plot=p)\n```\n\n----------------------------------------\n\nTITLE: Generating N-Rotationally Symmetric Tangent Fields with igl.nrosy\nDESCRIPTION: Creates a smooth N-RoSy field on a triangle mesh from a sparse set of constrained faces. It returns the interpolated field for each face of the mesh and the singularities of the field. This implements the algorithm proposed by Bommes (2009).\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_25\n\nLANGUAGE: python\nCODE:\n```\noutput_field, output_singularities = igl.nrosy(v, f, b, bc, b_soft, b_soft_weight, bc_soft, n, 0.5)\n```\n\n----------------------------------------\n\nTITLE: Solving ARAP Deformation with Boundary Constraints in libigl\nDESCRIPTION: This code snippet demonstrates how to solve an as-rigid-as-possible deformation problem with fixed boundary positions. It uses the ARAP solver with boundary constraints and an initial vertex position guess.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nvn = arap.solve(bc, v)\n```\n\n----------------------------------------\n\nTITLE: Solving ARAP Deformation with Constraints\nDESCRIPTION: Code for solving the ARAP system with constraints on the positions of fixed vertices. Uses the vertices 'v' as an initial guess and computes the solution.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter3.ipynb#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nvn = arap.solve(bc, v)\n```\n\n----------------------------------------\n\nTITLE: Implementing Polyharmonic Deformation with libigl in Python\nDESCRIPTION: This example demonstrates polyharmonic deformation by creating a bump on a flat domain. It identifies boundary vertices, sets boundary conditions, and then uses harmonic functions with different k values to control the continuity level at handle vertices. The interactive widget allows adjusting the maximum bump height and polynomial degree.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"bump-domain.obj\"))\nu = v.copy()\n\n# Find boundary vertices outside annulus\nvrn = np.linalg.norm(v, axis = 1)\nis_outer = [vrn[i] - 1.00 > -1e-15 for i in range(v.shape[0])]\nis_inner = [vrn[i] - 0.15 < 1e-15 for i in range(v.shape[0])]\nin_b = [is_outer[i] or is_inner[i] for i in range(len(is_outer))]\n\nb = np.array([i for i in range(v.shape[0]) if (in_b[i])]).T\nbc = np.zeros(b.size)\n\nfor bi in range(b.size):\n    bc[bi] = 0.0 if is_outer[b[bi]] else 1.0\n\nc = np.array(is_outer)\n\np = plot(u, f, c, shading={\"wire_width\": 0.01, \"colormap\": \"tab10\"}, return_plot=True)                \n\n@interact(z_max=(0.0, 1.0), k=(1, 4))\ndef update(z_max, k):\n    z = igl.harmonic(v, f, b, bc, int(k))\n    u[:, 2] = z_max * z\n    p.update_object(vertices=u)\n```\n\n----------------------------------------\n\nTITLE: Rendering Mesh with Ambient Occlusion Using Embree\nDESCRIPTION: Example showing how to compute ambient occlusion factors for a mesh and use them for grayscale rendering. It reads a mesh, computes per-vertex normals, calculates ambient occlusion with 50 rays per vertex, and displays the result.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"fertility.off\"))\n\nn = igl.per_vertex_normals(v, f)\n\n# Compute ambient occlusion factor using embree\nao = igl.ambient_occlusion(v, f, v, n, 50)\nao = 1.0 - ao\n\nplot(v, f, ao, shading={\"colormap\": \"gist_gray\"})\n```\n\n----------------------------------------\n\nTITLE: Computing Ambient Occlusion Using Ray Casting\nDESCRIPTION: Calculates ambient occlusion for a mesh surface using ray casting. The function takes vertex positions, face indices, sample positions, sample normals, and the number of rays to cast. This technique approximates how much each vertex is exposed to ambient lighting.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nao = igl.ambient_occlusion(v, f, v_samples, n_samples, 500)\n```\n\n----------------------------------------\n\nTITLE: Computing Exact Discrete Geodesic Distances in Python using libigl\nDESCRIPTION: This code snippet demonstrates how to compute exact discrete geodesic distances on a triangle mesh using libigl's Python bindings. It reads a mesh, selects a source vertex, computes distances to all other vertices, and visualizes the results using a periodic color mapping.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter1.ipynb#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"bunny_small.off\"))\n\n## Select a vertex from which the distances should be calculated\nvs = np.array([0])\n##All vertices are the targets\nvt = np.arange(v.shape[0])\n\nd = igl.exact_geodesic(v, f, vs, vt)#, fs, ft)\n\nstrip_size = 0.02\n##The function should be 1 on each integer coordinate\nc = np.abs(np.sin((d / strip_size * np.pi)))\nplot(v, f, c, shading={\"wireframe\": False})\n```\n\n----------------------------------------\n\nTITLE: Implementing Linear Blend Skinning Deformation\nDESCRIPTION: Implements Linear Blend Skinning (LBS) deformation using weighted influence from multiple bones and provides interactive visualization.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter7.ipynb#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nlbs_matrix = igl.lbs_matrix(v, w)\n\ndef lbs_deform_mesh(pose):\n    lbs_v = lbs_matrix @ pose\n    return lbs_v\n\nviewer_lbs = mp.Viewer({})\nlbs = viewer_lbs.add_mesh(v, f, np.array([0.5, 0.0, 0.0]))\n\n@mp.interact(frame=(1, num_frames))\ndef update_frame(frame):\n    frame = frame - 1\n    pose = anim[:, frame].reshape(parents.shape[0] * 4, 3, order='F')\n    deformed_mesh = lbs_deform_mesh(pose)\n    \n    viewer_lbs.update_object(oid=lbs, vertices=deformed_mesh)\n    \nviewer_lbs._renderer\n```\n\n----------------------------------------\n\nTITLE: Implementing Direct Delta Mush Runtime Deformation\nDESCRIPTION: Implements Direct Delta Mush deformation using precomputed Omega matrix and provides interactive visualization.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter7.ipynb#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef ddm_deform_mesh(pose):\n    ddm_v = igl.direct_delta_mush(v.copy(), pose, omega)\n    return ddm_v\n\nviewer_ddm = mp.Viewer({})\nddm = viewer_ddm.add_mesh(v, f, np.array([0.0, 0.5, 0.5]))\n\n@mp.interact(frame=(1, num_frames))\ndef update_frame(frame):\n    frame = frame - 1\n    pose = anim[:, frame].reshape(parents.shape[0] * 4, 3, order='F')\n    deformed_mesh = ddm_deform_mesh(pose)\n    \n    viewer_ddm.update_object(oid=ddm, vertices=deformed_mesh)\n    \nviewer_ddm._renderer\n```\n\n----------------------------------------\n\nTITLE: Data Smoothing with Laplacian and Hessian Energy\nDESCRIPTION: Implements function smoothing on a surface using both Laplacian energy with zero Neumann boundary conditions and Hessian energy. Demonstrates the difference between both approaches with interactive visualization.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"beetle.off\"))\ne = igl.edges(f)\n\nz_exact = v[0:, 2] + 0.5 * v[0:, 1] + v[0:, 1] * v[0:, 1] + v[0:, 2] * v[0:, 2] * v[0:, 2]\n    \ns = 0.2 * (np.max(z_exact) - np.min(z_exact))\nnp.random.seed(5)\nz_noisy = z_exact + s * np.random.rand(*z_exact.shape)\n\nl = igl.cotmatrix(v, f)\nm = igl.massmatrix(v, f, igl.MASSMATRIX_TYPE_BARYCENTRIC)\n\nm_inv_l = sp.sparse.linalg.spsolve(m, l)\nql = l.T @ m_inv_l\nqh = igl.hessian_energy(v, f)\n\nal = 8e-4;\nzl = sp.sparse.linalg.spsolve(al * ql + (1 - al) * m, al * m.dot(z_noisy))\nah = 5e-6;\nzh = sp.sparse.linalg.spsolve(ah * qh + (1 - ah) * m, ah * m.dot(z_noisy))\n```\n\n----------------------------------------\n\nTITLE: Implementing Rigid Mesh Deformation\nDESCRIPTION: Implements rigid mesh deformation using precomputed rigid weights and provides interactive visualization.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter7.ipynb#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef rigid_deform_mesh(pose):\n    rigid_v = rigid_lbs_matrix @ pose\n    return rigid_v\n\nviewer_rigid = mp.Viewer({})\nrigid = viewer_rigid.add_mesh(v, f, np.array([0.0, 0.5, 0.0]))\n\n@mp.interact(frame=(1, num_frames))\ndef update_frame(frame):\n    frame = frame - 1\n    pose = anim[:, frame].reshape(parents.shape[0] * 4, 3, order='F')\n    deformed_mesh = rigid_deform_mesh(pose)\n    \n    viewer_rigid.update_object(oid=rigid, vertices=deformed_mesh)\n    \nviewer_rigid._renderer\n```\n\n----------------------------------------\n\nTITLE: Solving Laplace Equation with Dirichlet Boundary Conditions in Python\nDESCRIPTION: This snippet demonstrates how to solve the Laplace equation with Dirichlet boundary conditions using libigl and SciPy. It includes steps for finding boundary vertices, constructing the Laplacian matrix, and solving the PDE.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom scipy.sparse.linalg import spsolve\n\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"camelhead.off\"))\n\n## Find boundary vertices\ne = igl.boundary_facets(f)\nv_b = np.unique(e)\n\n## List of all vertex indices\nv_all = np.arange(v.shape[0])\n\n## List of interior indices\nv_in = np.setdiff1d(v_all, v_b)\n\n## Construct and slice up Laplacian\nl = igl.cotmatrix(v, f)\nl_ii = l[v_in, :]\nl_ii = l_ii[:, v_in]\n\nl_ib = l[v_in, :]\nl_ib = l_ib[:, v_b]\n\n## Dirichlet boundary conditions from z-coordinate\nz = v[:, 2]\nbc = z[v_b]\n\n## Solve PDE\nz_in = spsolve(-l_ii, l_ib.dot(bc))\n\nplot(v, f, z)\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Triangle Mesh\nDESCRIPTION: Demonstrates how to create a simple triangle mesh using NumPy arrays for vertices and faces. The mesh consists of 2 triangles and 4 vertices.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nV = np.array([\n    [0., 0, 0],\n    [1, 0, 0],\n    [1, 1, 1],\n    [2, 1, 0]\n])\n\nF = np.array([\n    [0, 1, 2],\n    [1, 3, 2]\n])\n\nplot(V, F)\n```\n\n----------------------------------------\n\nTITLE: Computing Mean Curvature Using Laplace-Beltrami Operator\nDESCRIPTION: Calculates the mean curvature by applying the cotangent Laplace-Beltrami operator to vertex positions. The magnitude of the resulting vector at each vertex represents the mean curvature.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter1.ipynb#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nl = igl.cotmatrix(v, f)\nm = igl.massmatrix(v, f, igl.MASSMATRIX_TYPE_VORONOI)\n\nminv = sp.sparse.diags(1 / m.diagonal())\n\nhn = -minv.dot(l.dot(v))\nh = np.linalg.norm(hn, axis=1)\nplot(v, f, h)\n```\n\n----------------------------------------\n\nTITLE: Marching Tetrahedra Implementation\nDESCRIPTION: Implements the Marching Tetrahedra algorithm for iso-surface extraction from a 3D scalar field. Creates multiple iso-surfaces at different values with interactive visualization.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_34\n\nLANGUAGE: python\nCODE:\n```\ntv = np.load(os.path.join(root_folder, \"data\", \"marching_cube_tv.npy\"))\ntt = np.load(os.path.join(root_folder, \"data\", \"marching_cube_tt.npy\"))\ns = np.linalg.norm(tv, axis=1)\n\nsvs = []\nsfs = []\nfor i in np.linspace(0.05, 0.75, 15):\n    sv, sf, _, _ = igl.marching_tets(tv, tt, s, i)\n    svs.append(sv)\n    sfs.append(sf)\n\np = plot(sv, sf, return_plot=True)\noid = 0\n\n@interact(t=(0, 14))\ndef update(t=0):\n    global oid\n    p.remove_object(oid)\n    oid = p.add_mesh(svs[t], sfs[t])\n```\n\n----------------------------------------\n\nTITLE: Data Smoothing with Laplacian and Hessian Energies using Libigl in Python\nDESCRIPTION: This code implements data smoothing on a mesh using both Laplacian energy with zero Neumann boundary conditions and Hessian energy. It demonstrates the construction of smoothing matrices, solving for smoothed solutions, and visualizing the results with isolines.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter6.ipynb#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"beetle.off\"))\ne = igl.edges(f)\n\n# Constructing an exact function to smooth\nz_exact = v[0:, 2] + 0.5 * v[0:, 1] + v[0:, 1] * v[0:, 1] + v[0:, 2] * v[0:, 2] * v[0:, 2]\n    \n# Make the exact function noisy\ns = 0.2 * (np.max(z_exact) - np.min(z_exact))\nnp.random.seed(5)\nz_noisy = z_exact + s * np.random.rand(*z_exact.shape)\n\n# Constructing the squared Laplacian and squared Hessian energy\nl = igl.cotmatrix(v, f)\nm = igl.massmatrix(v, f, igl.MASSMATRIX_TYPE_BARYCENTRIC)\n\nm_inv_l = sp.sparse.linalg.spsolve(m, l)\nql = l.T @ m_inv_l\nqh = igl.hessian_energy(v, f)\n\n# Solve to find Laplacian-smoothed and Hessian-smoothed solutions\nal = 8e-4;\nzl = sp.sparse.linalg.spsolve(al * ql + (1 - al) * m, al * m.dot(z_noisy))\nah = 5e-6;\nzh = sp.sparse.linalg.spsolve(ah * qh + (1 - ah) * m, ah * m.dot(z_noisy))\n\n# Calculate isolines\nilx_v, ilx_e = igl.isolines(v, f, z_exact, 30)\niln_v, iln_e = igl.isolines(v, f, z_noisy, 30)\nill_v, ill_e = igl.isolines(v, f, zl, 30)\nilh_v, ilh_e = igl.isolines(v, f, zh, 30)\n\n\n#TODO add edges to subplot\np = subplot(v, f, z_exact, s=[2, 2, 0])\n# p.view.add_edges(ilx_v, ilx_e)\n\nsubplot(v, f, z_noisy, s=[2, 2, 1], data=p)\n# p.view.add_edges(iln_v, iln_e)\n\nsubplot(v, f, zl, s=[2, 2, 2], data=p)\n# p.view.add_edges(ill_v, ill_e)\n\nsubplot(v, f, zh, s=[2, 2, 3], data=p)\n# p.view.add_edges(ilh_v, ilh_e)\np\n```\n\n----------------------------------------\n\nTITLE: Solving Laplace Equation with Boundary Conditions in Python\nDESCRIPTION: This code solves the Laplace equation on a 3D mesh with Dirichlet boundary conditions. It uses libigl to read a mesh, compute the cotangent Laplacian, and solve the resulting linear system.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter2.ipynb#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom scipy.sparse.linalg import spsolve\n\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"camelhead.off\"))\n\n## Find boundary vertices\ne = igl.boundary_facets(f)\nv_b = np.unique(e)\n\n## List of all vertex indices\nv_all = np.arange(v.shape[0])\n\n## List of interior indices\nv_in = np.setdiff1d(v_all, v_b)\n\n## Construct and slice up Laplacian\nl = igl.cotmatrix(v, f)\nl_ii = l[v_in, :]\nl_ii = l_ii[:, v_in]\n\nl_ib = l[v_in, :]\nl_ib = l_ib[:, v_b]\n\n## Dirichlet boundary conditions from z-coordinate\nz = v[:, 2]\nbc = z[v_b]\n\n## Solve PDE\nz_in = spsolve(-l_ii, l_ib.dot(bc))\n\nplot(v, f, z)\n```\n\n----------------------------------------\n\nTITLE: Reading a 3D Mesh from a File using Libigl in Python\nDESCRIPTION: Shows how to read a 3D mesh from an OFF file using Libigl's read_triangle_mesh function and print basic information about the mesh.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter0.ipynb#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"bunny.off\"))\n\nprint(\"Vertices: \", len(v))\nprint(\"Faces: \", len(f))\n```\n\n----------------------------------------\n\nTITLE: Mesh Subdivision Implementation in Python\nDESCRIPTION: Demonstrates different mesh subdivision methods including upsample and Loop subdivision. Reads a triangle mesh and applies different subdivision techniques with interactive visualization.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nov, of = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"decimated-knight.off\"))\nuv, uf = igl.upsample(ov, of)\nlv, lf = igl.loop(ov, of)\n\np = plot(ov, of, shading={\"wireframe\": True})\n\n@interact(mode=['Coarse','Upsample', 'Loop'])\ndef switch(mode):\n    if mode == \"Coarse\":\n        plot(ov, of, shading={\"wireframe\": True}, plot=p)\n    if mode == \"Upsample\":\n        plot(uv, uf, shading={\"wireframe\": True}, plot=p)\n    if mode == \"Loop\":\n        plot(lv, lf, shading={\"wireframe\": True}, plot=p)\n```\n\n----------------------------------------\n\nTITLE: Optimizing Discrete Biharmonic Kernels using Active Set Solver in Python\nDESCRIPTION: This snippet demonstrates using Libigl's active set solver to optimize discrete biharmonic kernels at multiple scales. It constructs Laplacian and mass matrices, sets up constraints, and solves a quadratic program.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\nv, f, _ = igl.read_off(os.path.join(root_folder, \"data\", \"cheburashka.off\"))\n\n# One fixed point on belly\nb = np.array([[2556]])\nbc = np.array([[1.0]])\n\n# Construct Laplacian and mass matrix\nl = igl.cotmatrix(v, f)\nm = igl.massmatrix(v, f, igl.MASSMATRIX_TYPE_VORONOI)\nminv = sp.sparse.diags(1 / m.diagonal())\n\n# Bi-Laplacian\nq = l @ (minv @ l)\n\n# Zero linear term\nbz = np.zeros((v.shape[0], 1))\n\n# Lower and upper bound\nlx = np.zeros((v.shape[0], 1))\nux = np.ones((v.shape[0], 1))\n\n# Equality constraint constrains solution to sum to 1\nbeq = np.array([[0.08]])\naeq = sp.sparse.csc_matrix(m.diagonal())\n\n# Empty inequality constraints\naieq = sp.sparse.csc_matrix((0, 0))\nbieq = np.array([])\n\nz = igl.active_set(q, bz, b, bc, aeq, beq, aieq, bieq, lx, ux, max_iter=8)\nplot(v, f, z[1])\n```\n\n----------------------------------------\n\nTITLE: Optimizing Discrete Biharmonic Kernels using Active Set Solver in Python\nDESCRIPTION: This example demonstrates using libigl's active_set solver to optimize discrete biharmonic kernels at multiple scales. The code creates a Laplacian and mass matrix, constructs a bi-Laplacian, and solves a quadratic programming problem with equality and inequality constraints.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter2.ipynb#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n#TODO: Check why results differ, add interactivity\n\nv, f, _ = igl.read_off(os.path.join(root_folder, \"data\", \"cheburashka.off\"))\n\n# One fixed point on belly\nb = np.array([[2556]])\nbc = np.array([[1.0]])\n\n# Construct Laplacian and mass matrix\nl = igl.cotmatrix(v, f)\nm = igl.massmatrix(v, f, igl.MASSMATRIX_TYPE_VORONOI)\nminv = sp.sparse.diags(1 / m.diagonal())\n\n# Bi-Laplacian\nq = l @ (minv @ l)\n\n# Zero linear term\nbz = np.zeros((v.shape[0], 1))\n\n# Lower and upper bound\nlx = np.zeros((v.shape[0], 1))\nux = np.ones((v.shape[0], 1))\n\n# Equality constraint constrains solution to sum to 1\nbeq = np.array([[0.08]])\naeq = sp.sparse.csc_matrix(m.diagonal())\n\n# Empty inequality constraints\naieq = sp.sparse.csc_matrix((0, 0))\nbieq = np.array([])\n\nz = igl.active_set(q, bz, b, bc, aeq, beq, aieq, bieq, lx, ux, max_iter=8)\nplot(v, f, z[1])\n```\n\n----------------------------------------\n\nTITLE: Reading OBJ Mesh File in Python\nDESCRIPTION: Reads a mesh from an ASCII OBJ file, extracting vertex positions, normals and other mesh data. This function can handle faces with any number of vertices.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nv, _, n, f, _, _ = read_obj(\"my_model.obj\")\n```\n\n----------------------------------------\n\nTITLE: Computing Gradient and Visualizing Surface Function in Python\nDESCRIPTION: This snippet loads a mesh and surface function, computes the gradient operator, applies it to the surface function, and visualizes the result using an interactive plot. It also adds arrows representing the gradient direction.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"cheburashka.off\"))\nu = igl.read_dmat(os.path.join(root_folder, \"data\", \"cheburashka-scalar.dmat\"))\n\ng = igl.grad(v, f)\ngu = g.dot(u).reshape(f.shape, order=\"F\")\n\ngu_mag = np.linalg.norm(gu, axis=1)\np = plot(v, f, u, shading={\"wireframe\":False}, return_plot=True)\n\nmax_size = igl.avg_edge_length(v, f) / np.mean(gu_mag)\nbc = igl.barycenter(v, f)\nbcn = bc + max_size * gu\np.add_lines(bc, bcn, shading={\"line_color\": \"black\"});\n```\n\n----------------------------------------\n\nTITLE: Implementing Quad Mesh Planarization with Shape-Up\nDESCRIPTION: Implements quad mesh planarization using the Shape-Up algorithm. The code loads a quad mesh, converts it to a triangle mesh for visualization, then planarizes it to meet a specified planarity threshold. The visualization uses colors to represent the planarity of each quad face.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter4.ipynb#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Load a quad mesh generated by a conjugate field\nvqc, fqc, _ = igl.read_off(os.path.join(root_folder, \"data\", \"inspired_mesh_quads_Conjugate.off\"))\n\n# Convert it to a triangle mesh\nfqc_tri = np.zeros((fqc.shape[0] * 2, 3), dtype=\"int64\")\nfqc_tri[:fqc.shape[0]] = fqc[:, :3]\nfqc_tri[fqc.shape[0]:, 0] = fqc[:, 2]\nfqc_tri[fqc.shape[0]:, 1] = fqc[:, 3]\nfqc_tri[fqc.shape[0]:, 2] = fqc[:, 0]\n\n# Planarize it\nvqc_p = igl.planarize_quad_mesh(vqc, fqc, 10, 0.005)\n\n# Calculate a color to each quad that corresponds to its planarity\nplanarity = igl.quad_planarity(vqc, fqc)\nplanarity_p = igl.quad_planarity(vqc_p, fqc)\n\nc = np.concatenate([planarity, planarity])\nc_p = np.concatenate([planarity_p, planarity_p])\nc_range = [min(np.min(c), np.min(c_p)), max(np.max(c), np.max(c_p))]\n\np = subplot(vqc, fqc_tri, c, shading={\"normalize\": c_range}, s=[1, 2, 0])\nsubplot(vqc_p, fqc_tri, c_p, shading={\"normalize\": c_range}, s=[1, 2, 1], data=p)\n\n# @interact(mode=['Curved','Planar'])\n# def switch(mode):\n#     if mode == \"Curved\":\n#         p.update_object(colors=c)\n#     if mode == \"Planar\":\n#         p.update_object(vertices=vqc_p, colors=c_p)\n```\n\n----------------------------------------\n\nTITLE: Using marching_tets function in libigl for basic iso-contouring\nDESCRIPTION: Basic usage of the igl.marching_tets function to construct a triangle mesh that approximates an iso-level set from a scalar field sampled at the vertices of a tetrahedral mesh.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter6.ipynb#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.marching_tets(tv, tt, s, isovalue)\n```\n\n----------------------------------------\n\nTITLE: Multi-level iso-surface extraction using marching tetrahedra\nDESCRIPTION: Example that loads tetrahedral mesh data, computes scalar values based on vertex distances from origin, and creates multiple iso-surfaces at different iso-values. The resulting meshes are displayed in a subplot arrangement.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter6.ipynb#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ntv = np.load(os.path.join(root_folder, \"data\", \"marching_cube_tv.npy\"))\ntt = np.load(os.path.join(root_folder, \"data\", \"marching_cube_tt.npy\"))\ns = np.linalg.norm(tv, axis=1)\n\nsvs = []\nsfs = []\nfor i in np.linspace(0.05, 0.75, 15):\n    sv, sf, _, _ = igl.marching_tets(tv, tt, s, i)\n    svs.append(sv)\n    sfs.append(sf)\n\n\ni = 0\nfor t in [3, 8, 11]:\n    if i == 0:\n        p = subplot(svs[t], sfs[t], s = [1, 3, i])\n    else:\n        subplot(svs[t], sfs[t], s = [1, 3, i], data=p)\n    i += 1\n\np\n```\n\n----------------------------------------\n\nTITLE: Reading Triangle Mesh from Various Formats in Python\nDESCRIPTION: Reads a triangle mesh from files with automatic format detection. Supports obj, off, stl, wrl, ply, and mesh formats, returning vertex positions and face indices.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nv, f = read_triangle_mesh(\"my_model.obj\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Subdivision Surfaces using Libigl in Python\nDESCRIPTION: This snippet demonstrates three different subdivision methods: upsample (in-plane), loop (smooth), and false barycentric subdivision. It uses Libigl functions to perform these subdivisions on a mesh.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter6.ipynb#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nov, of = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"decimated-knight.off\"))\nuv, uf = igl.upsample(ov, of)\nlv, lf = igl.loop(ov, of)\n\np = subplot(ov, of, shading={\"wireframe\": True}, s=[1, 3, 0])\nsubplot(uv, uf, shading={\"wireframe\": True}, s=[1, 3, 1], data=p)\nsubplot(lv, lf, shading={\"wireframe\": True}, s=[1, 3, 2], data=p)\np\n```\n\n----------------------------------------\n\nTITLE: Constructing Alternative Laplacian using Gradient Operator in Python\nDESCRIPTION: This snippet demonstrates how to construct an alternative discrete cotangent Laplacian using the gradient operator. It reads a triangle mesh, computes the cotangent Laplacian, gradient, and compares the results of different construction methods.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter1.ipynb#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"cow.off\"))\nl = igl.cotmatrix(v, f)\ng = igl.grad(v, f)\n\nd_area = igl.doublearea(v, f)\nt = sp.sparse.diags(np.hstack([d_area, d_area, d_area]) * 0.5)\n\nk = -g.T.dot(t).dot(g)\nprint(\"|k-l|: %s\"%sp.sparse.linalg.norm(k-l))\n```\n\n----------------------------------------\n\nTITLE: Computing and Visualizing Principal Curvatures\nDESCRIPTION: Calculates principal curvatures and directions using Libigl's implementation of quadric fitting. Visualizes the mean curvature and principal directions on the mesh.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nv1, v2, k1, k2 = igl.principal_curvature(v, f)\nh2 = 0.5 * (k1 + k2)\np = plot(v, f, h2, shading={\"wireframe\": False}, return_plot=True)\n\navg = igl.avg_edge_length(v, f) / 2.0\np.add_lines(v + v1 * avg, v - v1 * avg, shading={\"line_color\": \"red\"})\np.add_lines(v + v2 * avg, v - v2 * avg, shading={\"line_color\": \"green\"});\n```\n\n----------------------------------------\n\nTITLE: Implementing As-Rigid-As-Possible Deformation with libigl in Python\nDESCRIPTION: This code implements as-rigid-as-possible deformation for elastic-like mesh manipulation. It loads a 3D mesh and selection data, identifies vertices in the selection, precomputes ARAP data structure, and sets up color coding for visualization based on the selection.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"decimated-knight.off\"))\ns = igl.read_dmat(os.path.join(root_folder, \"data\", \"decimated-knight-selection.dmat\"))\n\n# Vertices in selection\nb = np.array([[t[0] for t in [(i, s[i]) for i in range(0, v.shape[0])] \n      if t[1] >= 0]]).T\n\n# Centroid\nmid = 0.5 * (np.max(v, axis=0) + np.min(v, axis=0))\n\n# Precomputation\narap = igl.ARAP(v, f, 3, b)\n\n# Set color based on selection\nc = np.ones_like(f) * np.array([1.0, 228/255, 58/255])\nfor fi in range(0, f.shape[0]):\n    if s[f[fi, 0]] >= 0 and s[f[fi, 1]] >= 0 and s[f[fi, 2]] >= 0:\n        c[fi] = np.array([80/255, 64/255, 1.0])\n```\n\n----------------------------------------\n\nTITLE: Computing Principal Curvature Directions in Python\nDESCRIPTION: Computes the principal curvature directions and magnitude of a triangle mesh. The algorithm is based on 'Efficient Multi-scale Curvature and Crease Estimation' by Panozzo, Puppo, and Rocca.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n# Mesh in (v, f)\npd1, pd2, pv1, pv2 = principal_curvature(v, f)\n```\n\n----------------------------------------\n\nTITLE: Converting Representative Vectors to N-RoSy Fields and Visualizing\nDESCRIPTION: Extended example showing how to create N-RoSy fields, visualize them with their singularities, and allow interactive control of the field degree. It demonstrates converting representative vectors and plotting the field lines and singularity points.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n# # Converts a representative vector per face in the full set of vectors that describe an N-RoSy field\n# def representative_to_nrosy(v, f, r, n):\n#     b1, b2, b3 = igl.local_basis(v, f)\n#     ym = np.zeros((f.shape[0] * n, 3))\n\n#     for i in range(f.shape[0]):\n#         x = r[i] * b1[i].T\n#         y = r[i] * b2[i].T\n#         angle = np.arctan2(y[0], x[0])\n\n#         for j in range(0, n):\n#             anglej = angle + 2 * np.pi * j / float(n)\n#             xj = np.cos(anglej)\n#             yj = np.sin(anglej)\n#             ym[i * n + j] = xj * b1[i] + yj * b2[i]\n#     return ym\n\n# # Load a mesh in OFF format and plot it\n# v, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"bumpy.off\"))\n#     #print(points_n)\n    \n# # Constrained faces id\n# b = np.array([[0]])\n\n# # Highlight in red the constrained faces\n# c = np.ones((f.shape[0], 3))\n# for i in range(b.size):\n#     c[b[i]] = np.array([1, 0, 0])\n\n# p = plot(v, f, c)\n# pn_id = pp_id = e_id = None\n\n\n# # Constrained faces representative vector\n# bcv = np.array([[1.0, 1.0, 1.0]])\n# avg = igl.avg_edge_length(v, f)\n# bc = igl.barycenter(v, f)\n\n# # Plots the mesh with an N-RoSy field and its singularities on top\n# # The constrained faces (b) are colored in red.\n# @interact(n=(1, 10))\n# def plot_mesh_nrosy(n=1):\n#     global pn_id, pp_id, e_id, bcv, avg, b, bc\n\n#     r, s = igl.nrosy(v, f, b, bcv, np.array([[]], dtype=np.int64), np.array([[]]), np.array([[]]), n, 0.5)\n    \n#     # Expand the representative vectors in the full vector set and plot them as lines\n#     y = representative_to_nrosy(v, f, r, n)\n#     be = np.zeros((bc.shape[0] * n, 3))\n#     for i in range(bc.shape[0]):\n#         for j in range(n):\n#             be[i * n + j] = bc[i]\n\n#     if e_id:\n#         p.remove_object(e_id)\n#     e_id = p.add_lines(be, be + y * (avg / 2))\n\n#     # Plot the singularities as colored dots (red for negative, blue for positive)\n#     points_n = []\n#     points_p = []\n#     for i in range(0, s.size):\n#         if s[i] < -0.001:\n#             points_n.append(v[i])\n#         elif s[i] > 0.001:\n#             points_p.append(v[i])\n    \n#     if pp_id and pn_id:\n#         p.remove_object(pn_id)\n#         p.remove_object(pp_id)\n#     if len(points_n) > 0:\n#         pn_id = p.add_points(np.array(points_n), c=\"red\", shading={\"point_size\": 2.0})\n#     if len(points_p) > 0:\n#         pp_id = p.add_points(np.array(points_p), c=\"blue\", shading={\"point_size\": 2.0})\n```\n\n----------------------------------------\n\nTITLE: Computing Gaussian Curvature with libigl\nDESCRIPTION: Loads a 3D mesh and computes the Gaussian curvature at each vertex using libigl's gaussian_curvature function. Visualizes the curvature using a color map.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter1.ipynb#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"bumpy.off\"))\nk = igl.gaussian_curvature(v, f)\nplot(v, f, k)\n```\n\n----------------------------------------\n\nTITLE: Complete ARAP Deformation Example with Surface Elastic Deformation\nDESCRIPTION: A comprehensive example that demonstrates elastic-like deformation of a mesh using ARAP. Includes loading a mesh, setting up constraints based on selection, and applying time-varying deformations to create an animation effect.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter3.ipynb#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"decimated-knight.off\"))\ns = igl.read_dmat(os.path.join(root_folder, \"data\", \"decimated-knight-selection.dmat\"))\n\n# Vertices in selection\nb = np.array([[t[0] for t in [(i, s[i]) for i in range(0, v.shape[0])] \n      if t[1] >= 0]]).T\n\n# Centroid\nmid = 0.5 * (np.max(v, axis=0) + np.min(v, axis=0))\n\n# Precomputation\narap = igl.ARAP(v, f, 3, b)\n\n# Set color based on selection\nc = np.ones_like(f) * np.array([1.0, 228/255, 58/255])\nfor fi in range(0, f.shape[0]):\n    if s[f[fi, 0]] >= 0 and s[f[fi, 1]] >= 0 and s[f[fi, 2]] >= 0:\n        c[fi] = np.array([80/255, 64/255, 1.0])\n\n# Plot the mesh with pseudocolors\np = subplot(v, f, c, s=[1, 4, 0])\nfor k in range(3):\n    t= 1 + k*3\n    bc = np.zeros((b.size, v.shape[1]))\n    for i in range(0, b.size):\n        bc[i] = v[b[i]]\n        if s[b[i]] == 0:\n            r = mid[0] * 0.25\n            bc[i, 0] += r * np.sin(0.5 * t * 2 * np.pi)\n            bc[i, 1] = bc[i, 1] - r + r * np.cos(np.pi + 0.5 * t * 2 * np.pi)\n        elif s[b[i]] == 1:\n            r = mid[1] * 0.15\n            bc[i, 1] = bc[i, 1] + r + r * np.cos(np.pi + 0.15 * t * 2 * np.pi)\n            bc[i, 2] -= r * np.sin(0.15 * t * 2 * np.pi)\n        elif s[b[i]] == 2:\n            r = mid[1] * 0.15\n            bc[i, 2] = bc[i, 2] + r + r * np.cos(np.pi + 0.35 * t * 2 * np.pi)\n            bc[i, 0] += r * np.sin(0.35 * t * 2 * np.pi)\n\n    vn = arap.solve(bc, v)\n    subplot(vn, f, c, s=[1, 4, k+1], data=p)\np\n\n\n# p = plot(v, f, c, return_plot=True)\n\n# @interact(t=(0.0, 10.0))\n# def update(t=1.0):\n#     bc = np.zeros((b.size, v.shape[1]))\n#     for i in range(0, b.size):\n#         bc[i] = v[b[i]]\n#         if s[b[i]] == 0:\n#             r = mid[0] * 0.25\n#             bc[i, 0] += r * np.sin(0.5 * t * 2 * np.pi)\n#             bc[i, 1] = bc[i, 1] - r + r * np.cos(np.pi + 0.5 * t * 2 * np.pi)\n#         elif s[b[i]] == 1:\n#             r = mid[1] * 0.15\n#             bc[i, 1] = bc[i, 1] + r + r * np.cos(np.pi + 0.15 * t * 2 * np.pi)\n#             bc[i, 2] -= r * np.sin(0.15 * t * 2 * np.pi)\n#         elif s[b[i]] == 2:\n#             r = mid[1] * 0.15\n#             bc[i, 2] = bc[i, 2] + r + r * np.cos(np.pi + 0.35 * t * 2 * np.pi)\n#             bc[i, 0] += r * np.sin(0.35 * t * 2 * np.pi)\n\n#     vn = arap.solve(bc, v)\n#     p.update_object(vertices=vn)\n```\n\n----------------------------------------\n\nTITLE: Projecting Mesh to Plane Isometrically in Python\nDESCRIPTION: Projects each triangle of a 3D mesh onto a 2D plane while preserving the triangle shapes isometrically. Returns the 2D coordinates and index mappings.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n[U,UF,I] = project_isometrically_to_plane(V,F)\n```\n\n----------------------------------------\n\nTITLE: Computing Laplacian and Visualizing Mean Curvature Flow in Python\nDESCRIPTION: This snippet calculates the Laplace-Beltrami operator on a triangle mesh, then uses it to compute and visualize mean curvature flow. It includes an interactive widget to display different stages of the flow.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nfrom scipy.sparse.linalg import spsolve\n\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"cow.off\"))\nl = igl.cotmatrix(v, f)\n\nn = igl.per_vertex_normals(v, f)*0.5+0.5\nc = np.linalg.norm(n, axis=1)\np = plot(v, f, c, shading={\"wireframe\": False}, return_plot=True)\n\nvs = [v]\ncs = [c]\nfor i in range(10):\n    m = igl.massmatrix(v, f, igl.MASSMATRIX_TYPE_BARYCENTRIC)\n    s = (m - 0.001 * l)\n    b = m.dot(v)\n    v = spsolve(s, m.dot(v))\n    n = igl.per_vertex_normals(v, f)*0.5+0.5\n    c = np.linalg.norm(n, axis=1)\n    vs.append(v)\n    cs.append(c)\n\n@interact(level=(0, 9))\ndef mcf(level=0):\n    p.update_object(vertices=vs[level], colors=cs[level])\n```\n\n----------------------------------------\n\nTITLE: Computing vertex normals with per_vertex_normals in Python\nDESCRIPTION: This example shows how to compute vertex normals for a mesh represented by vertices and faces using the per_vertex_normals function.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n# Mesh in (v, f)\nn = per_vertex_normals(v, f)\n```\n\n----------------------------------------\n\nTITLE: Computing and Visualizing Laplace-Beltrami Eigenvectors in Python\nDESCRIPTION: This code computes the first k eigenvectors of the discrete Laplace-Beltrami operator on a 3D mesh. It then rescales the eigenvectors and provides an interactive visualization of them using pseudocolors.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_14\n\nLANGUAGE: Python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"beetle.off\"))\nl = -igl.cotmatrix(v, f)\nm = igl.massmatrix(v, f, igl.MASSMATRIX_TYPE_VORONOI)\n\nk = 10\nd, u = sp.sparse.linalg.eigsh(l, k, m, sigma=0, which=\"LM\")\n\nu = (u - np.min(u)) / (np.max(u) - np.min(u))\nbbd = 0.5 * np.linalg.norm(np.max(v, axis=0) - np.min(v, axis=0))\n\np = plot(v, f, bbd * u[:, 0], shading={\"wireframe\":False, \"flat\": False}, return_plot=True)\n\n@interact(ev=[(\"EV %i\"%i, i) for i in range(k)])\ndef sf(ev):\n    p.update_object(colors=u[:, ev])\n```\n\n----------------------------------------\n\nTITLE: Using per_face_normals in Python with libigl\nDESCRIPTION: This example demonstrates how to compute face normals for a mesh, providing a specific normalized vector for degenerate faces.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nGive degenerate faces (1/3,1/3,1/3)^0.5\nper_face_normals(V,F,Vector3d(1,1,1).normalized(),N);\n```\n\n----------------------------------------\n\nTITLE: Visualizing Polyharmonic Deformation with Different K Values\nDESCRIPTION: Demonstrates polyharmonic deformation on a flat domain by solving k-harmonic PDEs with increasing k values (1-4). The code creates a visualization that shows how different values of k affect the continuity at the boundary handles, creating different bump shapes.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter3.ipynb#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"bump-domain.obj\"))\nu = v.copy()\n\n# Find boundary vertices outside annulus\nvrn = np.linalg.norm(v, axis = 1)\nis_outer = [vrn[i] - 1.00 > -1e-15 for i in range(v.shape[0])]\nis_inner = [vrn[i] - 0.15 < 1e-15 for i in range(v.shape[0])]\nin_b = [is_outer[i] or is_inner[i] for i in range(len(is_outer))]\n\nb = np.array([i for i in range(v.shape[0]) if (in_b[i])]).T\nbc = np.zeros(b.size)\n\nfor bi in range(b.size):\n    bc[bi] = 0.0 if is_outer[b[bi]] else 1.0\n\nc = np.array(is_outer)\n\nfor i in range(1,5):\n    z = igl.harmonic(v, f, b, bc, int(i))\n    u[:, 2] = z\n    if i == 1:\n        p = subplot(u, f, c, shading={\"wire_width\": 0.01, \"colormap\": \"tab10\"}, s=[1, 4, i-1])\n    else:\n        subplot(u, f, c, shading={\"wire_width\": 0.01, \"colormap\": \"tab10\"}, s=[1, 4, i-1], data=p)\np\n    \n# p = plot(v, f, c, shading={\"wire_width\": 0.01, \"colormap\": \"tab10\"})\n# @interact(z_max=(0.0, 1.0), k=(1, 4))\n# def update(z_max, k):\n#     print(k)\n#     z = igl.harmonic(v, f, b, bc, int(k))\n#     u[:, 2] = z_max * z\n#     p.update_object(vertices=u)\n```\n\n----------------------------------------\n\nTITLE: Using marching_tets for Isosurface Extraction in Python\nDESCRIPTION: Example demonstrating how to extract an isosurface from a tetrahedral mesh using the marching tetrahedra algorithm. The function computes a triangle mesh approximation of an isosurface at a specified value.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nsv, sf, j, bc = igl.marching_tets(tv, tt, s, isovalue)\n```\n\n----------------------------------------\n\nTITLE: Computing Laplace-Beltrami Eigenvectors using Generalized Eigen Solver in Python\nDESCRIPTION: This example computes the first k eigenvectors of the discrete Laplace-Beltrami operator and visualizes them on a beetle model. The code constructs the Laplacian and mass matrices, solves the generalized eigen problem using scipy/arpack, and then visualizes the eigenvectors in pseudocolors.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter2.ipynb#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"beetle.off\"))\nl = -igl.cotmatrix(v, f)\nm = igl.massmatrix(v, f, igl.MASSMATRIX_TYPE_VORONOI)\n\nk = 10\nd, u = sp.sparse.linalg.eigsh(l, k, m, sigma=0, which=\"LM\")\n\nu = (u - np.min(u)) / (np.max(u) - np.min(u))\nbbd = 0.5 * np.linalg.norm(np.max(v, axis=0) - np.min(v, axis=0))\n\np = subplot(v, f, bbd * u[:, 0], shading={\"wireframe\":False, \"flat\": False}, s=[1, 2, 0])\nsubplot(v, f, bbd * u[:, 1], shading={\"wireframe\":False, \"flat\": False}, s=[1, 2, 1], data=p)\n\n# @interact(ev=[(\"EV %i\"%i, i) for i in range(k)])\n# def sf(ev):\n#     p.update_object(colors=u[:, ev])\n```\n\n----------------------------------------\n\nTITLE: Projecting Points onto Line Segment in Python\nDESCRIPTION: Projects points onto a line segment defined by start and destination points. Computes the projection parameter (constrained to [0,1]) and squared distance to the segment for each point.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_30\n\nLANGUAGE: python\nCODE:\n```\n[T,sqrD] = project_to_line_segment(P,S,D)\n```\n\n----------------------------------------\n\nTITLE: Computing Mean Curvature Using Laplace-Beltrami Operator\nDESCRIPTION: Demonstrates how to compute the mean curvature of a mesh using the cotangent Laplace-Beltrami operator. The result is visualized as a heatmap on the mesh.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nl = igl.cotmatrix(v, f)\nm = igl.massmatrix(v, f, igl.MASSMATRIX_TYPE_VORONOI)\n\nminv = sp.sparse.diags(1 / m.diagonal())\n\nhn = -minv.dot(l.dot(v))\nh = np.linalg.norm(hn, axis=1)\nplot(v, f, h)\n```\n\n----------------------------------------\n\nTITLE: Reordering Vertices for Face-First Order in Python\nDESCRIPTION: Reorders vertices so that vertices in the face list come before vertices that don't appear in the face list. Useful for separating surface vertices from internal vertices.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nTet mesh in (V,T,F)\n```\n\n----------------------------------------\n\nTITLE: Least Squares Conformal Maps (LSCM) Parametrization in Python using libigl\nDESCRIPTION: This snippet implements the LSCM parametrization algorithm which minimizes conformal (angular) distortion without fixed boundaries. The code computes the energy matrix using cotangent Laplacian and vector area matrices, with two boundary points fixed to make the solution unique.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"camelhead.off\"))\n\n# Fix two points on the boundary\nb = np.array([2, 1])\n\nbnd = igl.boundary_loop(f)\nb[0] = bnd[0]\nb[1] = bnd[int(bnd.size / 2)]\n\nbc = np.array([[0.0, 0.0], [1.0, 0.0]])\n\n# LSCM parametrization\n_, uv = igl.lscm(v, f, b, bc)\n\np = plot(v, f, uv=uv, shading={\"wireframe\": False, \"flat\": False}, return_plot=True)\n\n@interact(mode=['3D','2D'])\ndef switch(mode):\n    if mode == \"3D\":\n        plot(v, f, uv=uv, shading={\"wireframe\": False, \"flat\": False}, plot=p)\n    if mode == \"2D\":\n        plot(uv, f, uv=uv, shading={\"wireframe\": True, \"flat\": False}, plot=p)\n```\n\n----------------------------------------\n\nTITLE: Computing Mean Value Coordinates in Python\nDESCRIPTION: Example showing how to compute Mean Value Coordinates (MVC) for vertices with respect to polygon vertices. This returns a weight matrix representing the coordinates.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nW = mvc(V,C)\n```\n\n----------------------------------------\n\nTITLE: Computing and Visualizing Gradients on a Mesh\nDESCRIPTION: Demonstrates computing gradients of a scalar function defined on mesh vertices. Uses libigl's grad function to construct the gradient operator, then visualizes the gradient vectors at triangle barycenters.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter1.ipynb#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"cheburashka.off\"))\nu = igl.read_dmat(os.path.join(root_folder, \"data\", \"cheburashka-scalar.dmat\"))\n\ng = igl.grad(v, f)\ngu = g.dot(u).reshape(f.shape, order=\"F\")\n\ngu_mag = np.linalg.norm(gu, axis=1)\np = plot(v, f, u, shading={\"wireframe\":False}, return_plot=True)\n\nmax_size = igl.avg_edge_length(v, f) / np.mean(gu_mag)\nbc = igl.barycenter(v, f)\nbcn = bc + max_size * gu\np.add_lines(bc, bcn, shading={\"line_color\": \"black\"})\n```\n\n----------------------------------------\n\nTITLE: ARAP Solver Method\nDESCRIPTION: As-Rigid-As-Possible solver method that takes boundary conditions and an initial guess for deformation.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_44\n\nLANGUAGE: Python\nCODE:\n```\nsolve(: igl.pyigl_classes.ARAP, bc: numpy.ndarray, initial_guess: numpy.ndarray)\n```\n\n----------------------------------------\n\nTITLE: Quadratic Energy Minimization with Fixed and Linear Equality Constraints in Python\nDESCRIPTION: This snippet shows how to solve a quadratic energy minimization problem with fixed value constraints and linear equality constraints using libigl's min_quad_with_fixed function. It demonstrates solving the bi-Laplace equation with various constraints.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"cheburashka.off\"))\n\n## Two fixed points: Left hand, left foot should have values 1 and -1\nb = np.array([4331, 5957])\nbc = np.array([1., -1.])\nB = np.zeros((v.shape[0], 1))\n\n## Construct Laplacian and mass matrix\nL = igl.cotmatrix(v, f)\nM = igl.massmatrix(v, f, igl.MASSMATRIX_TYPE_VORONOI)\nMinv = sp.sparse.diags(1 / M.diagonal())\n\n## Bi-Laplacian\nQ = L @ (Minv @ L)\n\n## Solve with only equality constraints\nAeq = sp.sparse.csc_matrix((0, 0))\nBeq = np.array([])\n_, z1 = igl.min_quad_with_fixed(Q, B, b, bc, Aeq, Beq, True)\n\n## Solve with equality and linear constraints\nAeq = sp.sparse.csc_matrix((1, v.shape[0]))\nAeq[0,6074] = 1\nAeq[0, 6523] = -1\nBeq = np.array([0.])\n_, z2 = igl.min_quad_with_fixed(Q, B, b, bc, Aeq, Beq, True)\n\n## Normalize colors to same range\nmin_z = min(np.min(z1), np.min(z2))\nmax_z = max(np.max(z1), np.max(z2))\nz = [(z1 - min_z) / (max_z - min_z), (z2 - min_z) / (max_z - min_z)]\n\n## Plot the functions\np = plot(v, f, z1, shading={\"wireframe\":False}, return_plot=True)\n\n@interact(function=[('z0', 0), ('z1', 1)])\ndef sf(function):\n    p.update_object(colors=z[function])\n```\n\n----------------------------------------\n\nTITLE: Computing Circumradius in a Triangle Mesh with Python\nDESCRIPTION: Demonstrates how to compute the circumradius of each triangle in a mesh using the circumradius function. Takes vertex positions V and face indices F as input and returns a list of circumradii for each face.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nR = circumradius(V, F)\n```\n\n----------------------------------------\n\nTITLE: Computing and Visualizing Principal Curvature Directions\nDESCRIPTION: Uses libigl's principal_curvature function to compute both the principal curvature values and their directions. Visualizes these directions as red and green lines on the mesh surface.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter1.ipynb#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nv1, v2, k1, k2 = igl.principal_curvature(v, f)\nh2 = 0.5 * (k1 + k2)\np = plot(v, f, h2, shading={\"wireframe\": False}, return_plot=True)\n\navg = igl.avg_edge_length(v, f) / 2.0\np.add_lines(v + v1 * avg, v - v1 * avg, shading={\"line_color\": \"red\"})\np.add_lines(v + v2 * avg, v - v2 * avg, shading={\"line_color\": \"green\"})\n```\n\n----------------------------------------\n\nTITLE: Computing Exact Geodesic Distances in Python\nDESCRIPTION: This snippet calculates exact geodesic distances on a triangle mesh using libigl's wrapper for the algorithm by Danil Kirsanov. It computes distances from a source vertex to all other vertices and visualizes the result using a periodic color mapping.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"armadillo.obj\"))\n\n## Select a vertex from which the distances should be calculated\nvs = np.array([0])\n##All vertices are the targets\nvt = np.arange(v.shape[0])\n\nd = igl.exact_geodesic(v, f, vs, vt)#, fs, ft)\n\nstrip_size = 0.1\n##The function should be 1 on each integer coordinate\nc = np.abs(np.sin((d / strip_size * np.pi)))\nplot(v, f, c, shading={\"wireframe\": False})\n```\n\n----------------------------------------\n\nTITLE: Reading and Writing Mesh Files\nDESCRIPTION: Shows how to read a mesh from an OFF file and write it to an OBJ file using Libigl's I/O functions. Also prints the number of vertices and faces in the loaded mesh.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n## Load a mesh in OFF format\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"bunny.off\"))\n\n## Print the vertices and faces matrices \nprint(\"Vertices: \", len(v))\nprint(\"Faces: \", len(f))\n\n## Save the mesh in OBJ format\nret = igl.write_triangle_mesh(os.path.join(root_folder, \"data\", \"bunny_out.obj\"), v, f)\n```\n\n----------------------------------------\n\nTITLE: Updating Mesh Deformations in Interactive Visualization using Python\nDESCRIPTION: This function updates the mesh deformations for each frame of the animation. It applies rigid, linear blend, and direct delta mush skinning techniques to the mesh and updates the visualization accordingly.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter7.ipynb#2025-04-21_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\n@mp.interact(frame=(1, num_frames))\ndef update_frame(frame):\n    frame = frame - 1\n    pose = anim[:, frame].reshape(parents.shape[0] * 4, 3, order='F')\n    rigid_deformed_mesh = rigid_deform_mesh(pose)\n    lbs_deformed_mesh = lbs_deform_mesh(pose)\n    ddm_deformed_mesh = ddm_deform_mesh(pose)\n    \n    viewer_comp.update_object(oid=rigid, vertices=rigid_deformed_mesh + offset_rigid)\n    viewer_comp.update_object(oid=lbs, vertices=lbs_deformed_mesh + offset_lbs)\n    viewer_comp.update_object(oid=ddm, vertices=ddm_deformed_mesh + offset_ddm)\n    \nviewer_comp._renderer\n```\n\n----------------------------------------\n\nTITLE: Comparing Laplacian Constructions in Python\nDESCRIPTION: This snippet demonstrates an alternative construction of the discrete cotangent Laplacian by 'squaring' the discrete gradient operator. It compares the result with the direct computation of the cotangent Laplacian.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"cow.off\"))\nl = igl.cotmatrix(v, f)\ng = igl.grad(v, f)\n\nd_area = igl.doublearea(v, f)\nt = sp.sparse.diags(np.hstack([d_area, d_area, d_area]) * 0.5)\n\nk = -g.T.dot(t).dot(g)\nprint(\"|k-l|: %s\"%sp.sparse.linalg.norm(k-l))\n```\n\n----------------------------------------\n\nTITLE: Loading Mesh and Skeleton Data\nDESCRIPTION: Loads the elephant mesh, skeleton structure, weights, and animation sequence from files. Includes vertex positions, faces, bones, parent relationships, and animation data.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter7.ipynb#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"elephant.obj\"))\n\nbones, parents, _, _, _, _ = igl.read_tgf(os.path.join(root_folder, \"data\", \"elephant.tgf\"))\n\nw = igl.read_dmat(os.path.join(root_folder, \"data\", \"elephant-weights.dmat\"))\n\nanim = igl.read_dmat(os.path.join(root_folder, \"data\", \"elephant-anim.dmat\"))\n\nnum_frames = anim.shape[1]\n\nprint(f\"Array Shapes\\nVertices: {v.shape}, Faces: {f.shape}, Bones: {bones.shape}, Parents: {parents.shape}, Weights: {w.shape}, Anim: {anim.shape}\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Cotangent Laplacian Matrix with Python\nDESCRIPTION: Shows how to construct a cotangent stiffness matrix (discrete Laplacian) for a given mesh. This Laplacian uses the convention that diagonal entries are minus the sum of off-diagonal entries, making the matrix negative semi-definite.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Mesh in (v, f)\nl = cotmatrix(v, f)\n```\n\n----------------------------------------\n\nTITLE: Computing and Visualizing Gaussian Curvature\nDESCRIPTION: Calculates the Gaussian curvature of a mesh using Libigl, then normalizes it by the vertex areas. The result is visualized using pseudocolors.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"bumpy.off\"))\nk = igl.gaussian_curvature(v, f)\nplot(v, f, k)\n\nm = igl.massmatrix(v, f, igl.MASSMATRIX_TYPE_VORONOI)\nminv = sp.sparse.diags(1 / m.diagonal())\nkn = minv.dot(k)\nplot(v, f, kn)\n```\n\n----------------------------------------\n\nTITLE: Creating and Visualizing a Simple 3D Mesh in Python\nDESCRIPTION: Demonstrates how to create a simple 3D mesh using numpy arrays for vertices and faces, and visualize it using the meshplot library.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter0.ipynb#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nV = np.array([\n    [0., 0, 0],\n    [1, 0, 0],\n    [1, 1, 1],\n    [2, 1, 0]\n])\n\nF = np.array([\n    [0, 1, 2],\n    [1, 3, 2]\n])\n\nplot(V, F)\n```\n\n----------------------------------------\n\nTITLE: Computing Gradient Operator for Mesh Functions in Python\nDESCRIPTION: Computes the numerical gradient operator for a mesh. The gradient of a scalar function defined on piecewise linear elements is constant on each triangle/tetrahedron. The function takes vertex positions and face indices as input.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n# Mesh in (v, f)\ng = grad(v, f)\n```\n\n----------------------------------------\n\nTITLE: Computing Gaussian Curvature for Triangle Meshes in Python\nDESCRIPTION: Computes discrete local integral Gaussian curvature (angle deficit) for vertices in a triangle mesh. The function takes vertex positions and face indices as input and returns a per-vertex curvature value without averaging by local area.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n# Mesh in (v, f)\nk = gaussian_curvature(v, f)\n```\n\n----------------------------------------\n\nTITLE: Writing Triangle Mesh Function\nDESCRIPTION: Function to write a triangle mesh to a file with automatic format detection. Supports obj, off, stl, wrl, ply, and mesh formats. Takes vertex positions, face indices and optional ASCII forcing parameter.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_43\n\nLANGUAGE: Python\nCODE:\n```\nwrite_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -> bool\n```\n\n----------------------------------------\n\nTITLE: Setting up Biharmonic Deformation in Python using Libigl\nDESCRIPTION: This snippet demonstrates how to set up a biharmonic deformation problem using Libigl. It reads a mesh, swaps axes, and prepares handle constraints for deformation.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_15\n\nLANGUAGE: Python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"decimated-max.obj\"))\nv[:,[0, 2]] = v[:,[2, 0]] # Swap X and Z axes\nu = v.copy()\n\ns = igl.read_dmat(os.path.join(root_folder, \"data\", \"decimated-max-selection.dmat\"))\nb = np.array([[t[0] for t in [(i, s[i]) for i in range(0, v.shape[0])] if t[1] >= 0]]).T\n```\n\n----------------------------------------\n\nTITLE: Computing Mesh Angles in Python using LibIGL\nDESCRIPTION: Calculates per-face angles and statistical measures including minimum, maximum and standard deviation of angles in a mesh. The angles are converted from radians to degrees and various statistical metrics are computed.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nangles = igl.internal_angles(v, f)\nangles = 360.0 * (angles / (2 * np.pi))\n\nangle_avg = np.mean(angles)\nangle_min = np.min(angles)\nangle_max = np.max(angles)\nangle_ns = angles - angle_avg\nangle_sigma = np.sqrt(np.mean(np.square(angle_ns)))\n\nprint(\"Angles in degrees (Min/Max) Sigma: \\n%.2f/%.2f (%.2f)\\n\"%(angle_min, angle_max, angle_sigma))\n```\n\n----------------------------------------\n\nTITLE: Importing Libigl and Required Libraries in Python\nDESCRIPTION: Python code to import Libigl along with numpy, scipy, and meshplot for 3D mesh processing and visualization. Also sets up the root folder for file operations.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter0.ipynb#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport igl\nimport scipy as sp\nimport numpy as np\nfrom meshplot import plot, subplot, interact\n\nimport os\nroot_folder = os.getcwd()\n```\n\n----------------------------------------\n\nTITLE: Initializing ARAP Solver in Python with libigl\nDESCRIPTION: Code for initializing the As-Rigid-As-Possible solver with different energy types. This precomputation phase depends on the mesh, fixed vertex indices, and energy parameters.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter3.ipynb#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n#arap_data.energy = igl::ARAP_ENERGY_TYPE_SPOKES;\n#arap_data.energy = igl::ARAP_ENERGY_TYPE_SPOKES_AND_RIMS;\n#arap_data.energy = igl::ARAP_ENERGY_TYPE_ELEMENTS;\narap = igl.ARAP(v, f, dimension, b)\n```\n\n----------------------------------------\n\nTITLE: Analyzing Mesh Statistics for Regularity and Isometry\nDESCRIPTION: Demonstrates how to compute various mesh statistics including identification of irregular vertices, face areas, and statistical analysis. This helps evaluate mesh quality in terms of regularity and isometry properties.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"horse_quad.obj\"))\n\n## Count the number of irregular vertices, the border is ignored\nirregular = igl.is_irregular_vertex(v, f) \nv_count = v.shape[0]\nirregular_v_count = np.sum(irregular)\nirregular_ratio = irregular_v_count / v_count\n\nprint(\"Irregular vertices: \\n%d/%d (%.2f%%)\\n\"%(irregular_v_count, v_count, irregular_ratio * 100))\n\n## Compute areas, min, max and standard deviation\narea = igl.doublearea(v, f) / 2.0\n\narea_avg = np.mean(area)\narea_min = np.min(area) / area_avg\narea_max = np.max(area) / area_avg\narea_ns = (area - area_avg) / area_avg\narea_sigma = np.sqrt(np.mean(np.square(area_ns)))\n\nprint(\"Areas (Min/Max)/Avg_Area Sigma: \\n%.2f/%.2f (%.2f)\\n\"%(area_min, area_max, area_sigma))\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries and Setting Up Environment in Python\nDESCRIPTION: This snippet imports necessary libraries including igl, scipy, numpy, and meshplot. It also sets up the root folder for accessing data files.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter2.ipynb#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport igl\nimport scipy as sp\nimport numpy as np\nfrom meshplot import plot, subplot, interact\n\nimport os\nroot_folder = os.getcwd()\n```\n\n----------------------------------------\n\nTITLE: Solving Procrustes Problem in C++\nDESCRIPTION: Solves the Procrustes problem to find the optimal rotation, scale, and translation between two point sets in d-dimensional space.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_27\n\nLANGUAGE: cpp\nCODE:\n```\nMatrixXd X, Y; (containing 3d points as rows)\ndouble scale;\nMatrixXd R;\nVectorXd t;\nigl::procrustes(X,Y,true,false,scale,R,t);\nR *= scale;\nMatrixXd Xprime = (X * R).rowwise() + t.transpose();\n```\n\n----------------------------------------\n\nTITLE: Planarizing Quad Meshes Using Shape-Up Algorithm\nDESCRIPTION: Demonstrates how to transform a quad mesh into a planar quad mesh using the Shape-Up algorithm (Bouaziz, 2012). The example loads a quad mesh, planarizes it, and visualizes the planarity of each quad before and after processing.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n# Load a quad mesh generated by a conjugate field\nvqc, fqc, _ = igl.read_off(os.path.join(root_folder, \"data\", \"inspired_mesh_quads_Conjugate.off\"))\n\n# Convert it to a triangle mesh\nfqc_tri = np.zeros((fqc.shape[0] * 2, 3), dtype=\"int64\")\nfqc_tri[:fqc.shape[0]] = fqc[:, :3]\nfqc_tri[fqc.shape[0]:, 0] = fqc[:, 2]\nfqc_tri[fqc.shape[0]:, 1] = fqc[:, 3]\nfqc_tri[fqc.shape[0]:, 2] = fqc[:, 0]\n\n# Planarize it\nvqc_p = igl.planarize_quad_mesh(vqc, fqc, 100, 0.005)\n\n# Calculate a color to each quad that corresponds to its planarity\nplanarity = igl.quad_planarity(vqc, fqc)\nplanarity_p = igl.quad_planarity(vqc_p, fqc)\n\nc = np.concatenate([planarity, planarity])\nc_p = np.concatenate([planarity_p, planarity_p])\n\np = plot(vqc, fqc_tri, c, shading={\"normalize\":[min(np.min(c), np.min(c_p)), max(np.max(c), np.max(c_p))]})\n\n@interact(mode=['Curved','Planar'])\ndef switch(mode):\n    if mode == \"Curved\":\n        p.update_object(colors=c)\n    if mode == \"Planar\":\n        p.update_object(vertices=vqc_p, colors=c_p)\n```\n\n----------------------------------------\n\nTITLE: Initializing Environment and Importing Dependencies for libigl Python\nDESCRIPTION: Sets up the necessary imports for working with libigl Python bindings. Imports igl, scipy, numpy, and meshplot for mesh visualization, and establishes the root folder path.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter3.ipynb#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport igl\nimport scipy as sp\nimport numpy as np\nfrom meshplot import plot, subplot, interact\n\nimport os\nroot_folder = os.getcwd()\n```\n\n----------------------------------------\n\nTITLE: Constructing Unique Edges List in Python\nDESCRIPTION: Constructs a list of unique edges represented in a given mesh. Takes a face list as input and returns an edge list.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nV, F, _ = igl.read_off(\"test.off\")\nE = igl.edges(F)\n```\n\n----------------------------------------\n\nTITLE: Creating and using adjacency matrix for mesh Laplacian in Python\nDESCRIPTION: Shows how to construct an adjacency matrix for a mesh and use it to build a uniform Laplacian matrix, which is useful for many geometry processing operations.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Mesh in (v, f)\na = adjacency_matrix(f)\n# Sum each row\na_sum = np.sum(a, axis=1)\n# Convert row sums into diagonal of sparse matrix\na_diag = diag(a_sum)\n# Build uniform laplacian\nu = a - a_diag\n```\n\n----------------------------------------\n\nTITLE: Setting Up the Environment for Mesh Parametrization in Python\nDESCRIPTION: Imports necessary libraries for mesh parametrization including igl (libigl), scipy, numpy, and meshplot for visualization. Sets up the root folder to access mesh data files.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter4.ipynb#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport igl\nimport scipy as sp\nimport numpy as np\nfrom meshplot import plot, subplot, interact\n\nimport os\nroot_folder = os.getcwd()\n```\n\n----------------------------------------\n\nTITLE: Initializing Edge Topology in Python\nDESCRIPTION: Initialize edges and their topological relations for an edge-manifold mesh. Returns edge vertices, face-edge relations, and edge-face relations.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# Mesh in (v, f)\nev, fe, ef = edge_topology(v, f)\n```\n\n----------------------------------------\n\nTITLE: Creating and using mesh adjacency list in Python\nDESCRIPTION: Demonstrates how to construct an adjacency list representation for a mesh, which creates a list of lists where each inner list contains the vertices adjacent to a given vertex.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Mesh in (v, f)\na = mesh_adjacency_list(f)\n```\n\n----------------------------------------\n\nTITLE: Asserting Input Types in Python Bindings\nDESCRIPTION: Example of how to handle different input matrix types in Python bindings for libigl functions. This shows the use of dense_int, dense_long, and dense_longlong for MatrixXi, and dense_float and dense_double for MatrixXd.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/contributing.md#2025-04-21_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n* every `MatrixXi` it should have `dense_int`, `dense_long`, `dense_longlong`\n* every `MatrixXd` it should be `dense_float`, `dense_double`\n* similar for sparse matrice\n* avoid having too many combinations, for instance the second `MatrixXi` should be `npe_matches(v)`\n```\n\n----------------------------------------\n\nTITLE: Computing Dihedral Angles for Tetrahedral Mesh in Python\nDESCRIPTION: This snippet demonstrates how to compute dihedral angles for all tetrahedra in a given tetrahedral mesh using the dihedral_angles function. It takes vertex positions and tetrahedron indices as input and returns both the angles and their cosines.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\n# TetMesh in (v, t)\ntheta, cos_theta = dihedral_angles(v, t)\n```\n\n----------------------------------------\n\nTITLE: Implementing Boundary Conditions for Mesh Deformation in Python\nDESCRIPTION: This snippet sets up boundary conditions for mesh deformation by initializing arrays for original and deformed positions, then applies different transformations to selected vertices based on their handle index. A plotting function with interactive parameters allows users to visualize the deformation.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nu_bc = np.zeros((b.shape[0], v.shape[1]))\nv_bc = np.zeros((b.shape[0], v.shape[1]))\n\nfor bi in range(b.shape[0]):\n    v_bc[bi] = v[b[bi]]\n\n    if s[b[bi]] == 0: # Don't move handle 0\n        u_bc[bi] = v[b[bi]]\n    elif s[b[bi]] == 1: # Move handle 1 down\n        u_bc[bi] = v[b[bi]] + np.array([[0, -50, 0]])\n    else: # Move other handles forward\n        u_bc[bi] = v[b[bi]] + np.array([[-25, 0, 0]])\n\np = plot(v, f, s, shading={\"wireframe\": False, \"colormap\": \"tab10\"}, return_plot=True)\n\n@interact(deformation_field=True, step=(0.0, 2.0))\ndef update(deformation_field, step=0.0):\n    # Determine boundary conditions\n    u_bc_anim = v_bc + step * (u_bc - v_bc)\n\n    if deformation_field:\n        d_bc = u_bc_anim - v_bc\n        d = igl.harmonic(v, f, b, d_bc, 2)\n        u = v + d\n    else:\n        u = igl.harmonic(v, f, b, u_bc_anim, 2)\n    p.update_object(vertices=u)\n```\n\n----------------------------------------\n\nTITLE: Single Tet Volume Example in Python\nDESCRIPTION: Example demonstrating volume calculation for a single tetrahedron.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_41\n\nLANGUAGE: python\nCODE:\n```\nSingle tet\n```\n\n----------------------------------------\n\nTITLE: Calculating Double Area of Mesh Faces in Python\nDESCRIPTION: This example shows how to compute twice the area for each input triangle or quad in a mesh using the doublearea function. It takes vertex positions and face indices as input and returns a list of double areas for each face.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\n# Mesh in (v, f)\ndbl_area = doublearea(v, f)\n```\n\n----------------------------------------\n\nTITLE: Implementing Biharmonic Deformation Fields with libigl\nDESCRIPTION: Demonstrates the implementation of biharmonic deformation fields. The code loads a mesh, defines handle constraints, and applies deformation using the harmonic function with k=2. The example shows progressive deformation of the mesh with visualization at different steps.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter3.ipynb#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"decimated-max.obj\"))\nv[:,[0, 2]] = v[:,[2, 0]] # Swap X and Z axes\nu = v.copy()\n\ns = igl.read_dmat(os.path.join(root_folder, \"data\", \"decimated-max-selection.dmat\"))\nb = np.array([[t[0] for t in [(i, s[i]) for i in range(0, v.shape[0])] if t[1] >= 0]]).T\n\n## Boundary conditions directly on deformed positions\nu_bc = np.zeros((b.shape[0], v.shape[1]))\nv_bc = np.zeros((b.shape[0], v.shape[1]))\n\nfor bi in range(b.shape[0]):\n    v_bc[bi] = v[b[bi]]\n\n    if s[b[bi]] == 0: # Don't move handle 0\n        u_bc[bi] = v[b[bi]]\n    elif s[b[bi]] == 1: # Move handle 1 down\n        u_bc[bi] = v[b[bi]] + np.array([[0, -50, 0]])\n    else: # Move other handles forward\n        u_bc[bi] = v[b[bi]] + np.array([[-25, 0, 0]])\n\np = subplot(v, f, s, shading={\"wireframe\": False, \"colormap\": \"tab10\"}, s=[1, 4, 0])\nfor i in range(3):\n    u_bc_anim = v_bc + i*0.6 * (u_bc - v_bc)\n    d_bc = u_bc_anim - v_bc\n    d = igl.harmonic(v, f, b, d_bc, 2)\n    u = v + d\n    subplot(u, f, s, shading={\"wireframe\": False, \"colormap\": \"tab10\"}, s=[1, 4, i+1], data=p)\np\n\n# @interact(deformation_field=True, step=(0.0, 2.0))\n# def update(deformation_field, step=0.0):\n#     # Determine boundary conditions\n#     u_bc_anim = v_bc + step * (u_bc - v_bc)\n#\n#     if deformation_field:\n#         d_bc = u_bc_anim - v_bc\n#         d = igl.harmonic(v, f, b, d_bc, 2)\n#         u = v + d\n#     else:\n#         u = igl.harmonic(v, f, b, u_bc_anim, 2)\n#     p.update_object(vertices=u)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Comparison Visualization\nDESCRIPTION: Creates a visualization to compare different skinning techniques side by side.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter7.ipynb#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nviewer_comp = mp.Viewer({})\n# Rigid Blue\noffset_rigid = np.array([-90.0, 0.0, 0.0])\nrigid = viewer_comp.add_mesh(v + offset_rigid, f, np.array([0.0, 0.5, 0.0]))\n\n# LBS Red\noffset_lbs = np.array([0.0, 0.0, 0.0])\nlbs = viewer_comp.add_mesh(v + offset_lbs, f, np.array([0.5, 0.0, 0.0]))\n```\n\n----------------------------------------\n\nTITLE: Computing all-pairs distances between point sets in Python\nDESCRIPTION: Demonstrates how to compute the distances between each point in two different point sets, resulting in a distance matrix where D(i,j) gives the distance between point i in the first set and point j in the second set.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nD = all_pairs_distances(u,v)\n```\n\n----------------------------------------\n\nTITLE: Computing Signed Distance to Mesh in Python using IGL\nDESCRIPTION: This function computes the signed distance from query points to a mesh. It returns the smallest signed distances, corresponding facet indices, and closest points. Optionally, it can return pseudonormals of closest points.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_38\n\nLANGUAGE: Python\nCODE:\n```\nS, I, C = signed_distance(P, V, F, return_normals=False)\n```\n\n----------------------------------------\n\nTITLE: Implementing Discrete Quadratic Curvature Energies with Crouzeix-Raviart Cotmatrix\nDESCRIPTION: Example referencing how to use the Crouzeix-Raviart cotangent matrix for implementing discrete quadratic curvature energies as described in the paper by Wardetzky et al. (2007).\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nSee for example \"Discrete Quadratic Curvature Energies\" [Wardetzky, Bergou,\nHarmon, Zorin, Grinspun 2007]\n```\n\n----------------------------------------\n\nTITLE: Finding Boundary Facets of a Mesh in Python\nDESCRIPTION: Determines the boundary faces or edges of a tetrahedral or triangular mesh.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Mesh in (v, f)\nb = boundary_facets(f)\n```\n\n----------------------------------------\n\nTITLE: Computing Biharmonic Coordinates in C++\nDESCRIPTION: Calculates discrete biharmonic generalized barycentric coordinates for mesh deformation, minimizing the squared Laplacian energy subject to positional and transformation constraints.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nMatrixXd W;\nigl::biharmonic_coordinates(V,F,S,W);\nconst size_t dim = T.cols()-1;\nMatrixXd H(W.cols(),dim);\n{\nint c = 0;\nfor(int h = 0;h<S.size();h++)\n{\nif(S[h].size()==1)\n{\nH.row(c++) = V.block(S[h][0],0,1,dim);\n}else\n{\nH.block(c,0,dim+1,dim).setIdentity();\nc+=dim+1;\n}\n}\n}\nassert( (V-(W*H)).array().maxCoeff() < 1e-7 );\n```\n\n----------------------------------------\n\nTITLE: Normalizing Gaussian Curvature by Area\nDESCRIPTION: Computes the mass matrix using Voronoi areas, then normalizes the Gaussian curvature by dividing by these areas to get the integral average at each vertex.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter1.ipynb#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nm = igl.massmatrix(v, f, igl.MASSMATRIX_TYPE_VORONOI)\nminv = sp.sparse.diags(1 / m.diagonal())\nkn = minv.dot(k)\nplot(v, f, kn)\n```\n\n----------------------------------------\n\nTITLE: Bounded Biharmonic Weights Solver\nDESCRIPTION: BBW solver method for computing bounded biharmonic weights. Takes vertex positions, faces, boundary vertices and boundary conditions.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_45\n\nLANGUAGE: Python\nCODE:\n```\nsolve(: igl.pyigl_classes.BBW, V: numpy.ndarray, F: numpy.ndarray, b: numpy.ndarray[int32[m, 1]], bc: numpy.ndarray)\n```\n\n----------------------------------------\n\nTITLE: Quadratic Energy Minimization with Constraints in Python\nDESCRIPTION: This snippet demonstrates solving a quadratic energy minimization problem with fixed value constraints and linear equality constraints using libigl's min_quad_with_fixed function.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter2.ipynb#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"cheburashka.off\"))\n\n## Two fixed points: Left hand, left foot should have values 1 and -1\nb = np.array([4331, 5957])\nbc = np.array([1., -1.])\nB = np.zeros((v.shape[0], 1))\n\n## Construct Laplacian and mass matrix\nL = igl.cotmatrix(v, f)\nM = igl.massmatrix(v, f, igl.MASSMATRIX_TYPE_VORONOI)\nMinv = sp.sparse.diags(1 / M.diagonal())\n\n## Bi-Laplacian\nQ = L @ (Minv @ L)\n\n## Solve with only equality constraints\nAeq = sp.sparse.csc_matrix((0, 0))\nBeq = np.array([])\n_, z1 = igl.min_quad_with_fixed(Q, B, b, bc, Aeq, Beq, True)\n\n## Solve with equality and linear constraints\nAeq = sp.sparse.csc_matrix((1, v.shape[0]))\nAeq[0,6074] = 1\nAeq[0, 6523] = -1\nBeq = np.array([0.])\n_, z2 = igl.min_quad_with_fixed(Q, B, b, bc, Aeq, Beq, True)\n\n## Normalize colors to same range\nmin_z = min(np.min(z1), np.min(z2))\nmax_z = max(np.max(z1), np.max(z2))\nz = [(z1 - min_z) / (max_z - min_z), (z2 - min_z) / (max_z - min_z)]\n\n## Plot the functions\np = subplot(v, f, z[0], shading={\"wireframe\":False}, s=[1, 2, 0])\nsubplot(v, f, z[1], shading={\"wireframe\":False}, s=[1, 2, 1], data=p)\n```\n\n----------------------------------------\n\nTITLE: Computing Mesh Statistics using Libigl in Python\nDESCRIPTION: This code computes various mesh statistics including irregular vertices, face areas, and angles. It demonstrates the use of Libigl functions for mesh analysis and basic statistical calculations.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter6.ipynb#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"horse_quad.obj\"))\n\n## Count the number of irregular vertices, the border is ignored\nirregular = igl.is_irregular_vertex(v, f) \nv_count = v.shape[0]\nirregular_v_count = np.sum(irregular)\nirregular_ratio = irregular_v_count / v_count\n\nprint(\"Irregular vertices: \\n%d/%d (%.2f%%)\\n\"%(irregular_v_count, v_count, irregular_ratio * 100))\n\n## Compute areas, min, max and standard deviation\narea = igl.doublearea(v, f) / 2.0\n\narea_avg = np.mean(area)\narea_min = np.min(area) / area_avg\narea_max = np.max(area) / area_avg\narea_ns = (area - area_avg) / area_avg\narea_sigma = np.sqrt(np.mean(np.square(area_ns)))\n\nprint(\"Areas (Min/Max)/Avg_Area Sigma: \\n%.2f/%.2f (%.2f)\\n\"%(area_min, area_max, area_sigma))\n\n## Compute per face angles, min, max and standard deviation\nangles = igl.internal_angles(v, f)\nangles = 360.0 * (angles / (2 * np.pi))\n\nangle_avg = np.mean(angles)\nangle_min = np.min(angles)\nangle_max = np.max(angles)\nangle_ns = angles - angle_avg\nangle_sigma = np.sqrt(np.mean(np.square(angle_ns)))\n\nprint(\"Angles in degrees (Min/Max) Sigma: \\n%.2f/%.2f (%.2f)\\n\"%(angle_min, angle_max, angle_sigma))\n```\n\n----------------------------------------\n\nTITLE: Computing Ambient Occlusion in libigl\nDESCRIPTION: Example showing how to compute ambient occlusion using the igl.ambient_occlusion function, which casts rays to estimate the exposure of each point to ambient lighting.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter5.ipynb#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nao = igl.ambient_occlusion(v, f, v_samples, n_samples, 500)\n```\n\n----------------------------------------\n\nTITLE: Finding Ear Triangles in Mesh using Python\nDESCRIPTION: This snippet demonstrates how to find all ear triangles (faces with two boundary edges) in a given triangle mesh using the ears function. It returns indices of ear triangles and their opposite non-boundary edges.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_14\n\nLANGUAGE: Python\nCODE:\n```\nears,ear_opp = find_ears(F)\n```\n\n----------------------------------------\n\nTITLE: Constructing Sparse Voxel Grid for Isosurface in Python using IGL\nDESCRIPTION: This function constructs a shell of epsilon-sized cubes surrounding an isosurface, given a point on the surface and a scalar function. The resulting cubes can be used as input for marching cubes algorithm.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_39\n\nLANGUAGE: Python\nCODE:\n```\nCS, CV, CI = sparse_voxel_grid(p0, scalar_func, eps, expected_number_of_cubes)\n```\n\n----------------------------------------\n\nTITLE: Computing Longest Boundary Loop of a Mesh in Python\nDESCRIPTION: Calculates the ordered boundary loops for a manifold mesh and returns the longest loop in terms of vertices.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Mesh in (v, f)\nl = boundary_loop(f)\n```\n\n----------------------------------------\n\nTITLE: Calculating Volume Example in Python\nDESCRIPTION: Example showing how to calculate volume for a tetrahedral mesh using the volume() function.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_40\n\nLANGUAGE: python\nCODE:\n```\nvol = volume(V,T)\n```\n\n----------------------------------------\n\nTITLE: Orienting Faces in Mesh Patches using BFS in Python\nDESCRIPTION: Consistently orients faces in orientable patches of a mesh using breadth-first search, returning oriented faces and component IDs.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nv, f, _ = igl.read_off(\"test.off\")\nff, c = igl.bfs_orient(f)\n```\n\n----------------------------------------\n\nTITLE: Writing OBJ File Example in Python\nDESCRIPTION: Example showing how to write a mesh to an OBJ file using write_obj() function.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_42\n\nLANGUAGE: python\nCODE:\n```\n# Mesh in (v, f)\nsuccess = write_obj(v, f)\n```\n\n----------------------------------------\n\nTITLE: Computing Directed Edge Parents in Python\nDESCRIPTION: This example shows how to recover 'parent' edges (preceding edges) in a tree given just directed edges using the directed_edge_parents function. It takes a list of directed edges and returns parent indices for each edge.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_15\n\nLANGUAGE: Python\nCODE:\n```\ne.np.random.randint(0, 10, size=(10, 2))\np = directed_edge_parents(e)\n```\n\n----------------------------------------\n\nTITLE: Configuring ARAP Energy Types in libigl\nDESCRIPTION: This code snippet shows different energy type options for as-rigid-as-possible deformation in libigl. It demonstrates how to set the energy type (commented options include spokes, spokes and rims, or elements) before the precomputation phase and how to solve for deformed vertex positions.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n#arap_data.energy = igl::ARAP_ENERGY_TYPE_SPOKES;\n#arap_data.energy = igl::ARAP_ENERGY_TYPE_SPOKES_AND_RIMS;\n#arap_data.energy = igl::ARAP_ENERGY_TYPE_ELEMENTS;\narap = igl.ARAP(v, f, dimension, b)\n```\n\n----------------------------------------\n\nTITLE: Performing Breadth-First Search on a Graph in Python\nDESCRIPTION: Executes a breadth-first search on a directed graph represented by an adjacency matrix, returning discovery order and predecessors.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nV, F, _ = igl.read_off(\"test.off\")\nA = igl.adjacency_matrix(V, F)\nd, p = igl.bfs(A, V[0])\n```\n\n----------------------------------------\n\nTITLE: Implementing As-Rigid-As-Possible (ARAP) Parametrization\nDESCRIPTION: Demonstrates ARAP parametrization which preserves distances and angles by mapping each triangle to the plane while maintaining its original shape. The algorithm is initialized with harmonic parametrization and then optimized using the ARAP solver. Results are visualized in both 2D and 3D.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter4.ipynb#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nv, f  = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"camelhead.off\"))\n\n## Find the open boundary\nbnd = igl.boundary_loop(f)\n\n## Map the boundary to a circle, preserving edge proportions\nbnd_uv = igl.map_vertices_to_circle(v, bnd)\n\n## Harmonic parametrization for the internal vertices\nuv = igl.harmonic(v, f, bnd, bnd_uv, 1)\n\narap = igl.ARAP(v, f, 2, np.zeros(0))\nuva = arap.solve(np.zeros((0, 0)), uv)\n\np = subplot(v, f, uv=uva, shading={\"wireframe\": False, \"flat\": False}, s=[1, 2, 0])\np = subplot(uva, f, uv=uva, shading={\"wireframe\": False, \"flat\": False}, s=[1, 2, 1], data=p)\n\n# @interact(mode=['3D','2D'])\n# def switch(mode):\n#     if mode == \"3D\":\n#         plot(v, f, uv=uva, shading={\"wireframe\": False, \"flat\": False}, plot=p)\n#     if mode == \"2D\":\n#         plot(uva, f, uv=uva, shading={\"wireframe\": True, \"flat\": False}, plot=p)\n```\n\n----------------------------------------\n\nTITLE: Initializing Mesh Objects for Deformation Comparison in Python\nDESCRIPTION: This snippet initializes the mesh objects for the Direct Delta Mush (DDM) deformation technique. It sets up the offset and adds the mesh to the viewer with a specific color.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter7.ipynb#2025-04-21_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\n# DDM Green\noffset_ddm = np.array([90.0, 0.0, 0.0])\nddm = viewer_comp.add_mesh(v + offset_ddm, f, np.array([0.0, 0.5, 0.5]))\n```\n\n----------------------------------------\n\nTITLE: Implementing Direct Delta Mush Precomputation\nDESCRIPTION: Performs Direct Delta Mush precomputation to generate skinning weights matrix Omega using smoothness control parameters.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter7.ipynb#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\np = 20\nl = 3\nk = 1\na = 0.8\nomega = igl.direct_delta_mush_precomputation(v, f, rigid_w, p, l, k, a)\n\nprint(f\"Num Frames: {num_frames}, Omega: {omega.shape}\")\n```\n\n----------------------------------------\n\nTITLE: Computing Average Edge Length in Python\nDESCRIPTION: Calculates the average edge length for a given triangle mesh using vertex and face data.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Mesh in (v, f)\nlength = avg_edge_length(v, f)\n```\n\n----------------------------------------\n\nTITLE: SLIM Methods Collection\nDESCRIPTION: Methods for the SLIM (Simple Linear Iterative Minimization) class including energy computation, solver, and vertex access.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_46\n\nLANGUAGE: Python\nCODE:\n```\nenergy(: igl.pyigl_classes.SLIM) -> float\n```\n\nLANGUAGE: Python\nCODE:\n```\nsolve(: igl.pyigl_classes.SLIM, num_iters: int)\n```\n\nLANGUAGE: Python\nCODE:\n```\nvertices(: igl.pyigl_classes.SLIM)\n```\n\n----------------------------------------\n\nTITLE: Implementing Rigid Skinning Weight Conversion\nDESCRIPTION: Converts Linear Blend Skinning weights to rigid skinning weights by setting the maximum influence to 1 and others to 0 for each vertex.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter7.ipynb#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef convert_lbs_weights_rigid_weights(lbs_w):\n    rigid_w = np.zeros(w.shape)\n    for i in range(0, w.shape[0]):\n        maxj = w[i].argmax()\n        for j in range(0, w.shape[1]):\n            rigid_w[i, j] = float(maxj == j)\n    return rigid_w\n    \nrigid_w = convert_lbs_weights_rigid_weights(w)\n        \nrigid_lbs_matrix = igl.lbs_matrix(v, rigid_w)\n        \nprint(f\"Example of Conversion at vertex 10\\nLBS Weights: {w[10, 5:9]}\\nRigid Weights: {rigid_w[10, 5:9]}\")\n```\n\n----------------------------------------\n\nTITLE: ShapeUp Solver Method\nDESCRIPTION: ShapeUp solver implementation that takes boundary conditions, initial positions, projection type and quietness flag for iterations.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_47\n\nLANGUAGE: Python\nCODE:\n```\nsolve(: igl.pyigl_classes.shapeup, bc: numpy.ndarray, P0: numpy.ndarray, local_projection: str = 'regular_face_projection', quietIterations: bool = True)\n```\n\n----------------------------------------\n\nTITLE: Adding Tests for New Python Bindings\nDESCRIPTION: Guidelines for adding tests for newly bound functions in the test_basic.py file. This includes asserting for correct dtype, size, and c_contiguous properties of the function outputs.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/contributing.md#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n*Add a test* to just run the new function in the [test_basic.py](https://github.com/libigl/libigl-python-bindings/blob/master/tests/test_basic.py) file. At least assert for the correct `dtype`, `size`, and  `c_contiguous` (correct major).\n```\n\n----------------------------------------\n\nTITLE: Writing a 3D Mesh to a File using Libigl in Python\nDESCRIPTION: Demonstrates how to write a 3D mesh to an OBJ file using Libigl's write_triangle_mesh function.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter0.ipynb#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nret = igl.write_triangle_mesh(os.path.join(root_folder, \"data\", \"bunny_out.obj\"), v, f)\n```\n\n----------------------------------------\n\nTITLE: Reading Graph from TGF File in Python\nDESCRIPTION: Reads a graph structure from a .tgf file, returning vertices, edges, and various special edges (bone-edges, cage-edges, pseudo-edges). Assumes that graph vertices are 3-dimensional.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nV,E,P,BE,CE,PE = igl.read_tgf(filename)\n```\n\n----------------------------------------\n\nTITLE: Projecting Points onto Line in Python\nDESCRIPTION: Projects points onto a line defined by start and destination points. Computes the projection parameter and squared distance to the line for each point.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n[T,sqrD] = project_to_line(P,S,D)\n```\n\n----------------------------------------\n\nTITLE: Using kronecker products for Linear Blend Skinning in MATLAB\nDESCRIPTION: MATLAB code example showing how to compute the Linear Blend Skinning matrix using kronecker products. This relates to the lbs_matrix function implementation.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_21\n\nLANGUAGE: matlab\nCODE:\n```\nkron(ones(1,size(W,2)),[V ones(size(V,1),1)]).*kron(W,ones(1,size(V,2)+1))\n```\n\n----------------------------------------\n\nTITLE: Reading Matrix from DMAT File in Python\nDESCRIPTION: Reads a matrix from an ASCII DMAT file format. The first line contains columns and rows count, followed by the matrix coefficients with columns running fastest.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nw = read_dmat(\"my_model.dmat\")\n```\n\n----------------------------------------\n\nTITLE: Importing Libigl and Required Libraries\nDESCRIPTION: Imports the necessary Python libraries including Libigl, NumPy, SciPy, and meshplot for visualization. Also sets up paths and clones tutorial data if needed.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tutorials.ipynb#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport igl\nimport scipy as sp\nimport numpy as np\nfrom meshplot import plot, subplot, interact\n\nimport os\nroot_folder = os.getcwd()\n#root_folder = os.path.join(os.getcwd(), \"tutorial\")\ndata_folder = os.path.join(root_folder,\"/data\")\n# pip install gitpython\nfrom git import Repo\nif not os.path.isdir(data_folder):\n    Repo.clone_from(\"https://github.com/libigl/libigl-tutorial-data.git\", data_folder)\n```\n\n----------------------------------------\n\nTITLE: Reading Tetrahedral Mesh from .mesh File in Python\nDESCRIPTION: Loads a tetrahedral volume mesh from a .mesh file, returning vertex positions, tetrahedron indices, and face indices. Note that holes and regions are not currently supported.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nv, t, f = read_mesh(\"my_mesh.mesh\")\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries and Setting Up Environment in Python\nDESCRIPTION: This snippet imports necessary libraries including igl, scipy, numpy, and meshplot. It also sets up the root folder for accessing data files.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter6.ipynb#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport igl\nimport scipy as sp\nimport numpy as np\nfrom meshplot import plot, subplot, interact\n\nimport os\nroot_folder = os.getcwd()\n```\n\n----------------------------------------\n\nTITLE: Reading OFF Mesh File in Python\nDESCRIPTION: Reads a mesh from an ASCII OFF file, obtaining vertex positions, face indices, and optionally normals. The function can handle faces with any number of vertices.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nv, f, n, c = read_off(\"my_model.off\")\n```\n\n----------------------------------------\n\nTITLE: Defining Module Building Function for PyIGL Components\nDESCRIPTION: Creates a function that generates binding files, sets up build targets, and configures module outputs for each libigl component. This function handles different module prefixes (core, copyleft, restricted).\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/CMakeLists.txt#2025-04-21_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\n# don't need to worry about nested modules (opengl/** are the only ones and\n# those probably aren't ever getting python bindings)\n#\n# prefix is either \"\", \"copyleft\", or \"restricted\"\nfunction(pyigl_include prefix name)\n  string(TOUPPER \"${prefix}\" prefix_uc)\n  string(TOUPPER \"${name}\" name_uc)\n  if(prefix_uc)\n      string(PREPEND prefix_uc _)\n  endif()\n  string(TOLOWER \"${prefix_uc}\" prefix_lc)\n  # if(LIBIGL${prefix_uc}_${name_uc}) or name == \"core\"\n  if(LIBIGL${prefix_uc}_${name_uc} OR name STREQUAL \"core\")\n    if(\"${prefix}\" STREQUAL \"copyleft\")\n      if(\"${name}\" STREQUAL \"core\")\n        set(subpath \"copyleft\")\n      else()\n        set(subpath \"copyleft/${name}\")\n      endif()\n    elseif(\"${name}\" STREQUAL \"core\")\n      set(subpath \"\")\n    else() # \"\" or \"restricted\"\n      set(subpath \"${name}\")\n    endif()\n    file(GLOB sources \"${CMAKE_CURRENT_SOURCE_DIR}/src/${subpath}/*.cpp\")\n\n    ## Just compile a single file\n    #list(FILTER sources EXCLUDE REGEX \".*/module\\\\.cpp$\")\n    #list(GET sources 0 sources)\n    #list(APPEND sources \"${CMAKE_CURRENT_SOURCE_DIR}/src/${subpath}/module.cpp\")\n\n    message(STATUS \"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\")\n    message(STATUS \"${prefix} ${name} sources: ${sources}\")\n\n    set(BINDING_SOURCES ${sources})\n    list(FILTER BINDING_SOURCES EXCLUDE REGEX \".*/module\\\\.cpp$\")\n\n    # keep just the first in the list and overwrite BINDING_SOURCES\n\n    # Generate the function calls based on filenames\n    set(BINDING_DECLARATIONS \"\")\n    foreach(source_file ${BINDING_SOURCES})\n      get_filename_component(filename ${source_file} NAME_WE)\n      set(BINDING_DECLARATIONS \"${BINDING_DECLARATIONS}extern void bind_${filename}(nb::module_ &m);\\n\")\n      set(BINDING_INVOCATIONS \"${BINDING_INVOCATIONS}    bind_${filename}(m);\\n\")\n    endforeach()\n    # make a temporary folder in the build directory to store the generated files\n    set(generated_dir \"${CMAKE_CURRENT_BINARY_DIR}/include/${subpath}\")\n    file(MAKE_DIRECTORY \"${generated_dir}\")\n    # write contents into BINDING_DECLARATIONS.h and BINDING_INVOCATIONS.h\n    file(WRITE \"${generated_dir}/BINDING_DECLARATIONS.in\" \"${BINDING_DECLARATIONS}\")\n    file(WRITE \"${generated_dir}/BINDING_INVOCATIONS.in\" \"${BINDING_INVOCATIONS}\")\n\n    set(target_name \"pyigl${prefix_lc}_${name}\")\n    nanobind_add_module(${target_name} ${sources})\n\n    # important for scikit-build\n    install(TARGETS ${target_name} LIBRARY DESTINATION  \"igl/${subpath}\")\n\n\n    if(\"${name}\" STREQUAL \"core\")\n      target_link_libraries(${target_name} PRIVATE igl::core)\n    else()\n      target_link_libraries(${target_name} PRIVATE igl::core igl${prefix_lc}::${name})\n    endif()\n    target_include_directories(${target_name} PRIVATE \"${CMAKE_CURRENT_BINARY_DIR}/include\")\n    target_include_directories(${target_name} PRIVATE \"${CMAKE_CURRENT_SOURCE_DIR}/include\")\n    set(output_dir \"${PYIGL_OUTPUT_DIRECTORY}/${subpath}\")\n    file(MAKE_DIRECTORY ${output_dir})\n    file(WRITE \"${output_dir}/__init__.py\" \"from .${target_name} import *\\n\")\n    install(FILES \"${output_dir}/__init__.py\" DESTINATION \"igl/${subpath}\")\n\n    set_target_properties(${target_name} PROPERTIES \n        LIBRARY_OUTPUT_DIRECTORY         \"${output_dir}\"\n        RUNTIME_OUTPUT_DIRECTORY         \"${output_dir}\"\n        LIBRARY_OUTPUT_DIRECTORY_RELEASE \"${output_dir}\"\n        RUNTIME_OUTPUT_DIRECTORY_RELEASE \"${output_dir}\"\n    )\n    set(PYI_OUTPUT \"${output_dir}/${target_name}.pyi\")\n    nanobind_add_stub(\n      ${target_name}_stub\n      MODULE ${target_name}\n      OUTPUT ${PYI_OUTPUT}\n      PYTHON_PATH $<TARGET_FILE_DIR:${target_name}>\n      DEPENDS ${target_name}\n    )\n    install(FILES \"${PYI_OUTPUT}\" DESTINATION \"igl/${subpath}\")\n\n    # just to add dependency?\n    if(\"${name}\" STREQUAL \"core\")\n    else()\n      target_link_libraries(pyigl_core INTERFACE ${target_name})\n    endif()\n  endif()\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Removing Duplicate Vertices in Python\nDESCRIPTION: Removes duplicate vertices from a mesh up to a specified uniqueness tolerance (epsilon). Returns new vertex positions and index mappings between original and simplified mesh.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/igl_docs.md#2025-04-21_snippet_37\n\nLANGUAGE: python\nCODE:\n```\n% Mesh in (V,F)\n[SV,SVI,SVJ] = remove_duplicate_vertices(V,1e-7);\n% remap faces\nSF = SVJ(F);\n```\n\n----------------------------------------\n\nTITLE: Configuring Python Dependencies for nanobind\nDESCRIPTION: Sets up Python dependencies required for building the bindings, with special handling for different CMake versions and build types.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif (CMAKE_VERSION VERSION_LESS 3.18)\n  set(DEV_MODULE Development)\nelse()\n  set(DEV_MODULE Development.Module)\nendif()\n\nfind_package(Python 3.8 COMPONENTS Interpreter ${DEV_MODULE} REQUIRED)\n\nif (NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n  set(CMAKE_BUILD_TYPE Release CACHE STRING \"Choose the type of build.\" FORCE)\n  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS \"Debug\" \"Release\" \"MinSizeRel\" \"RelWithDebInfo\")\nendif()\n\nmessage(STATUS \"CMAKE_BUILD_TYPE: ${CMAKE_BUILD_TYPE}\")\n```\n\n----------------------------------------\n\nTITLE: Fetching Dependencies with FetchContent in CMake\nDESCRIPTION: Downloads and configures nanobind and libigl dependencies using CMake's FetchContent module. Sets various libigl module options.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# Enable FetchContent to download dependencies at configure time\ninclude(FetchContent)\n\n# Download and set up nanobind\nFetchContent_Declare(\n  nanobind\n  GIT_REPOSITORY https://github.com/wjakob/nanobind.git\n  GIT_TAG        v2.2.0\n)\nFetchContent_MakeAvailable(nanobind)\n\n# Download and set up libigl\noption(LIBIGL_COPYLEFT_CORE        \"Build target igl_copyleft::core\"       ON)\noption(LIBIGL_COPYLEFT_CGAL        \"Build target igl_copyleft::cgal\"       ON)\noption(LIBIGL_EMBREE               \"Build target igl::embree\"              ON)\noption(LIBIGL_COPYLEFT_TETGEN      \"Build target igl_copyleft::tetgen\"     ON)\noption(LIBIGL_RESTRICTED_TRIANGLE  \"Build target igl_restricted::triangle\" ON)\nFetchContent_Declare(\n  libigl\n  GIT_REPOSITORY https://github.com/libigl/libigl.git\n  GIT_TAG 788871103938ce92112714d11ea491e8e6b4d972\n)\nFetchContent_MakeAvailable(libigl)\n```\n\n----------------------------------------\n\nTITLE: Installing libigl Python Package\nDESCRIPTION: Command to install the libigl Python package using pip.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython -m pip install libigl\n```\n\n----------------------------------------\n\nTITLE: Implementing Mean Curvature Flow with Laplacian Smoothing\nDESCRIPTION: Implements mean curvature flow by iteratively applying the Laplace-Beltrami operator to vertex positions. Visualizes the evolution of the mesh through multiple iterations of smoothing.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter1.ipynb#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom scipy.sparse.linalg import spsolve\n\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"cow.off\"))\nl = igl.cotmatrix(v, f)\n\nn = igl.per_vertex_normals(v, f)*0.5+0.5\nc = np.linalg.norm(n, axis=1)\n\n\nvs = [v]\ncs = [c]\nfor i in range(10):\n    m = igl.massmatrix(v, f, igl.MASSMATRIX_TYPE_BARYCENTRIC)\n    s = (m - 0.001 * l)\n    b = m.dot(v)\n    v = spsolve(s, m.dot(v))\n    n = igl.per_vertex_normals(v, f)*0.5+0.5\n    c = np.linalg.norm(n, axis=1)\n    vs.append(v)\n    cs.append(c)\n    \n    \np = subplot(vs[0], f, c, shading={\"wireframe\": False}, s=[1, 4, 0])\nsubplot(vs[3], f, c, shading={\"wireframe\": False}, s=[1, 4, 1], data=p)\nsubplot(vs[6], f, c, shading={\"wireframe\": False}, s=[1, 4, 2], data=p)\nsubplot(vs[9], f, c, shading={\"wireframe\": False}, s=[1, 4, 3], data=p)\n\n# @interact(level=(0, 9))\n# def mcf(level=0):\n#     p.update_object(vertices=vs[level], colors=cs[level])\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries and Setting Up Environment\nDESCRIPTION: Imports required libraries including igl, scipy, numpy, and meshplot for visualization. Sets up the root folder for data access.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter1.ipynb#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport igl\nimport scipy as sp\nimport numpy as np\nfrom meshplot import plot, subplot, interact\n\nimport os\nroot_folder = os.getcwd()\n#root_folder = os.path.join(os.getcwd(), \"tutorial\")\n```\n\n----------------------------------------\n\nTITLE: Creating an Editable Build for Development\nDESCRIPTION: Command to create an editable (incremental) build for development purposes using pip, allowing changes to be immediately reflected without reinstalling.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython -m pip install --no-build-isolation --config-settings=editable.rebuild=true -Cbuild-dir=build -ve.\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for libigl Python Bindings\nDESCRIPTION: Basic setup for using libigl with Python, importing necessary scientific computing libraries (scipy, numpy) and visualization tools (meshplot), as well as setting up the root folder path.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter5.ipynb#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport igl\nimport scipy as sp\nimport numpy as np\nfrom meshplot import plot, subplot, interact\n\nimport os\nroot_folder = os.getcwd()\n```\n\n----------------------------------------\n\nTITLE: Including LibIGL Components for Python Binding Generation\nDESCRIPTION: Calls the pyigl_include function for each libigl component to generate Python bindings, conditionally including modules based on the options set earlier.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/CMakeLists.txt#2025-04-21_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\npyigl_include(\"\" \"core\")\nif(LIBIGL_COPYLEFT_CORE)\n  pyigl_include(\"copyleft\" \"core\")\nendif()\nif(LIBIGL_COPYLEFT_CGAL)\n  pyigl_include(\"copyleft\" \"cgal\")\nendif()\nif(LIBIGL_EMBREE)\n  pyigl_include(\"\" \"embree\")\nendif()\nif(LIBIGL_COPYLEFT_TETGEN)\n  pyigl_include(\"copyleft\" \"tetgen\")\nendif()\nif(LIBIGL_RESTRICTED_TRIANGLE)\n  pyigl_include(\"restricted\" \"triangle\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Getting libigl Version in Python\nDESCRIPTION: Code to retrieve the version of the libigl package being used in Python code, using the importlib.metadata module.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/README.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport importlib.metadata\nlibigl_version = importlib.metadata.version('libigl')\n```\n\n----------------------------------------\n\nTITLE: Initializing Environment and Loading Dependencies\nDESCRIPTION: Sets up the required imports and initializes the working directory for mesh processing.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter7.ipynb#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport igl\nimport scipy as sp\nimport numpy as np\nimport meshplot as mp\nimport os\n\nroot_folder = os.getcwd()\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Project Requirements for libigl-python-bindings\nDESCRIPTION: Initializes the CMake project with minimum required version, project name, C++ standard, and deployment target settings for macOS.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15...3.27)\nproject(pyigl)\n\n# For std::filesystem::path (generic_string)\nset(CMAKE_OSX_DEPLOYMENT_TARGET \"10.15\")\n# ≥17 for return value optimization \n# <20 for embree\nset(CMAKE_CXX_STANDARD 17)\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Settings and Include Paths\nDESCRIPTION: Sets output directory and includes additional CMake modules for configuring build features like warnings, C++ standards, and color output.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n# set PYIGL_OUTPUT_DIRECTORY to [this dir]/igl\nset(PYIGL_OUTPUT_DIRECTORY \"${CMAKE_CURRENT_SOURCE_DIR}/igl\")\n\nlist(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)\n# Color output\ninclude(UseColors)\n\n# Extra warnings\ninclude(Warnings)\n\n# Use C++11/14\ninclude(CXXFeatures)\n\n# Generate position independent code by default\nset(CMAKE_POSITION_INDEPENDENT_CODE ON CACHE INTERNAL \"\")\n```\n\n----------------------------------------\n\nTITLE: Testing cibuildwheel Locally on macOS\nDESCRIPTION: Commands to test cibuildwheel locally on macOS by creating a virtual environment with a specific Python version and building wheels for the platform.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/README.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n/Library/Frameworks/Python.framework/Versions/3.11/bin/python3.11 -m venv venv-official-3.11\nsource venv-official-3.11/bin/activate\npython -m pip install cibuildwheel\nCIBW_BUILD=\"cp311-*\" python -m cibuildwheel --output-dir wheelhouse --platform macos\n```\n\n----------------------------------------\n\nTITLE: Complete Ambient Occlusion Example with Visualization\nDESCRIPTION: A complete example demonstrating how to load a mesh, compute per-vertex normals, calculate ambient occlusion factors, and visualize the result using meshplot with a grayscale colormap.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/tutorial/tut-chapter5.ipynb#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nv, f = igl.read_triangle_mesh(os.path.join(root_folder, \"data\", \"fertility.off\"))\n\nn = igl.per_vertex_normals(v, f)\n\n# Compute ambient occlusion factor using embree\nao = igl.ambient_occlusion(v, f, v, n, 20)\nao = 1.0 - ao\n\nplot(v, f, ao, shading={\"colormap\": \"gist_gray\"})\n```\n\n----------------------------------------\n\nTITLE: Uploading Wheels to TestPyPI\nDESCRIPTION: Command to upload the built wheel files to TestPyPI using the twine package, which allows for testing distribution before pushing to the main PyPI repository.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/README.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npython -m twine upload --repository testpypi wheelhouse/*/*.whl wheelhouse/*/*.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Downloading Build Artifacts from GitHub Actions\nDESCRIPTION: Commands to download all the wheel artifacts from a successful GitHub Actions workflow run using the GitHub CLI tool.\nSOURCE: https://github.com/libigl/libigl-python-bindings/blob/main/README.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nmkdir wheelhouse\ncd wheelhouse\ngh run download [runid]\n```"
  }
]